[
  {
    "sha": "f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzRmYTcxOWNmMzNhNTFkMTFmMWQyMjE5Y2JlNzNjY2ZmNmZkNjk3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-18T13:14:21Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T15:00:19Z"
      },
      "message": "Drop obsolete sigops comment\n\nThis comment was confusing and incorrect when first added (\"invalid rather than\nmerely non-standard\" has the opposite meaning of what is actually the case),\nand was also not updated after segwit with the correct variable names.\n\nDelete it since the code reads just fine on its own.\n\nCo-authored by: Anthony Towns <aj@erisian.com.au>\n                Suhas Daftuar <sdaftuar@gmail.com>",
      "tree": {
        "sha": "cc2cf08a5e26978f1962a35a0b267083fe262f67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc2cf08a5e26978f1962a35a0b267083fe262f67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f34fa719cf33a51d11f1d2219cbe73ccff6fd697/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0e9cb2d24dbf982cd13d568c9318308b90b024ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e9cb2d24dbf982cd13d568c9318308b90b024ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0e9cb2d24dbf982cd13d568c9318308b90b024ea"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 0,
      "deletions": 5
    },
    "files": [
      {
        "sha": "ad2d327e30748180b5e99149f0d93fbabce48c97",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f34fa719cf33a51d11f1d2219cbe73ccff6fd697/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f34fa719cf33a51d11f1d2219cbe73ccff6fd697/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
        "patch": "@@ -721,11 +721,6 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                               fSpendsCoinbase, nSigOpsCost, lp);\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Check that the transaction doesn't have an excessive number of\n-        // sigops, making it impossible to mine. Since the coinbase transaction\n-        // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n-        // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n-        // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d\", nSigOpsCost));"
      }
    ]
  },
  {
    "sha": "00e11e61c0211a62788611cd6a6714a393fdc26c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGUxMWU2MWMwMjExYTYyNzg4NjExY2Q2YTY3MTRhMzkzZmRjMjZj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-22T20:20:34Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T15:00:19Z"
      },
      "message": "[refactor] rename stateDummy -> orphan_state\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>\n                Suhas Daftuar <sdaftuar@gmail.com>",
      "tree": {
        "sha": "812a6a6e43235f93b7c7bda1862f08ca349c2d8e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/812a6a6e43235f93b7c7bda1862f08ca349c2d8e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00e11e61c0211a62788611cd6a6714a393fdc26c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00e11e61c0211a62788611cd6a6714a393fdc26c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00e11e61c0211a62788611cd6a6714a393fdc26c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00e11e61c0211a62788611cd6a6714a393fdc26c/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f34fa719cf33a51d11f1d2219cbe73ccff6fd697",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f34fa719cf33a51d11f1d2219cbe73ccff6fd697"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "7f3af6804224bde3aab9d7fd42ac1bbc6bb14d02",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00e11e61c0211a62788611cd6a6714a393fdc26c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00e11e61c0211a62788611cd6a6714a393fdc26c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=00e11e61c0211a62788611cd6a6714a393fdc26c",
        "patch": "@@ -1730,10 +1730,10 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n         // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n         // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n         // anyone relaying LegitTxX banned)\n-        CValidationState stateDummy;\n+        CValidationState orphan_state;\n \n         if (setMisbehaving.count(fromPeer)) continue;\n-        if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+        if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &fMissingInputs2, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n             RelayTransaction(orphanTx, connman);\n             for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n@@ -1748,7 +1748,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             done = true;\n         } else if (!fMissingInputs2) {\n             int nDos = 0;\n-            if (stateDummy.IsInvalid(nDos) && nDos > 0) {\n+            if (orphan_state.IsInvalid(nDos) && nDos > 0) {\n                 // Punish peer that gave us an invalid orphan tx\n                 Misbehaving(fromPeer, nDos);\n                 setMisbehaving.insert(fromPeer);\n@@ -1757,7 +1757,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             // Has inputs but not accepted to mempool\n             // Probably non-standard or insufficient fee\n             LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n-            if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n+            if (!orphanTx.HasWitness() && !orphan_state.CorruptionPossible()) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n                 // See https://github.com/bitcoin/bitcoin/issues/8279 for details."
      }
    ]
  },
  {
    "sha": "8818729013e17c650a25f030b2b80e0997389155",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ODE4NzI5MDEzZTE3YzY1MGEyNWYwMzBiMmI4MGUwOTk3Mzg5MTU1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-04-16T16:52:03Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T15:00:19Z"
      },
      "message": "[refactor] Refactor misbehavior ban decisions to MaybePunishNode()\n\nIsolate the decision of whether to ban a peer to one place in the\ncode, rather than having it sprinkled throughout net_processing.\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>\n                Suhas Daftuar <sdaftuar@gmail.com>\n                John Newbery <john@johnnewbery.com>",
      "tree": {
        "sha": "d9fea6eb7676e1b669920958a8a2380830386696",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d9fea6eb7676e1b669920958a8a2380830386696"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8818729013e17c650a25f030b2b80e0997389155",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8818729013e17c650a25f030b2b80e0997389155",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8818729013e17c650a25f030b2b80e0997389155",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8818729013e17c650a25f030b2b80e0997389155/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00e11e61c0211a62788611cd6a6714a393fdc26c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00e11e61c0211a62788611cd6a6714a393fdc26c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00e11e61c0211a62788611cd6a6714a393fdc26c"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 58,
      "deletions": 34
    },
    "files": [
      {
        "sha": "36142e1e41d9613dce02152c1cc3c5fcc594eebe",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8818729013e17c650a25f030b2b80e0997389155/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8818729013e17c650a25f030b2b80e0997389155/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=8818729013e17c650a25f030b2b80e0997389155",
        "patch": "@@ -84,6 +84,7 @@ class CValidationState {\n     void SetCorruptionPossible() {\n         corruptionPossible = true;\n     }\n+    int GetDoS(void) const { return nDoS; }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }"
      },
      {
        "sha": "a416093db14857616578e487965e85c6cc6cd1fc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 34,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8818729013e17c650a25f030b2b80e0997389155/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8818729013e17c650a25f030b2b80e0997389155/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8818729013e17c650a25f030b2b80e0997389155",
        "patch": "@@ -959,6 +959,34 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n \n+static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n+{\n+    return (state.GetDoS() > 0);\n+}\n+\n+/**\n+ * Potentially ban a node based on the contents of a CValidationState object\n+ * TODO: net_processing should make the punish decision based on the reason\n+ * a tx/block was invalid, rather than just the nDoS score handed back by validation.\n+ *\n+ * @parameter via_compact_block: this bool is passed in because net_processing should\n+ * punish peers differently depending on whether the data was provided in a compact\n+ * block message or not. If the compact block had a valid header, but contained invalid\n+ * txs, the peer should not be punished. See BIP 152.\n+ */\n+static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+    int nDoS = state.GetDoS();\n+    if (nDoS > 0 && !via_compact_block) {\n+         LOCK(cs_main);\n+         Misbehaving(nodeid, nDoS, message);\n+         return true;\n+    }\n+    if (message != \"\") {\n+        LogPrint(BCLog::NET, \"peer=%d: %s\\n\", nodeid, message);\n+    }\n+    return false;\n+}\n+\n \n \n \n@@ -1132,14 +1160,12 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     const uint256 hash(block.GetHash());\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n \n-    int nDoS = 0;\n-    if (state.IsInvalid(nDoS)) {\n+    if (state.IsInvalid()) {\n         // Don't send reject message with code 0 or an internal reject code.\n         if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n             CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n             State(it->second.first)->rejects.push_back(reject);\n-            if (nDoS > 0 && it->second.second)\n-                Misbehaving(it->second.first, nDoS);\n+            MaybePunishNode(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n         }\n     }\n     // Check that:\n@@ -1551,14 +1577,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     CValidationState state;\n     CBlockHeader first_invalid_header;\n     if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n-        int nDoS;\n-        if (state.IsInvalid(nDoS)) {\n-            LOCK(cs_main);\n-            if (nDoS > 0) {\n-                Misbehaving(pfrom->GetId(), nDoS, \"invalid header received\");\n-            } else {\n-                LogPrint(BCLog::NET, \"peer=%d: invalid header received\\n\", pfrom->GetId());\n-            }\n+        if (state.IsInvalid()) {\n             if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {\n                 // Goal: don't allow outbound peers to use up our outbound\n                 // connection slots if they are on incompatible chains.\n@@ -1593,6 +1612,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n                 // etc), and not just the duplicate-invalid case.\n                 pfrom->fDisconnect = true;\n             }\n+            MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ false, \"invalid header received\");\n             return false;\n         }\n     }\n@@ -1727,9 +1747,9 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n         const CTransaction& orphanTx = *porphanTx;\n         NodeId fromPeer = orphan_it->second.fromPeer;\n         bool fMissingInputs2 = false;\n-        // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n-        // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n-        // anyone relaying LegitTxX banned)\n+        // Use a new CValidationState because orphans come from different peers (and we call\n+        // MaybePunishNode based on the source peer from the orphan map, not based on the peer\n+        // that relayed the previous transaction).\n         CValidationState orphan_state;\n \n         if (setMisbehaving.count(fromPeer)) continue;\n@@ -1747,11 +1767,11 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             EraseOrphanTx(orphanHash);\n             done = true;\n         } else if (!fMissingInputs2) {\n-            int nDos = 0;\n-            if (orphan_state.IsInvalid(nDos) && nDos > 0) {\n+            if (orphan_state.IsInvalid()) {\n                 // Punish peer that gave us an invalid orphan tx\n-                Misbehaving(fromPeer, nDos);\n-                setMisbehaving.insert(fromPeer);\n+                if (MaybePunishNode(fromPeer, orphan_state, /*via_compact_block*/ false)) {\n+                    setMisbehaving.insert(fromPeer);\n+                }\n                 LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n             }\n             // Has inputs but not accepted to mempool\n@@ -2496,8 +2516,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // Never relay transactions that we would assign a non-zero DoS\n                 // score for, as we expect peers to do the same with us in that\n                 // case.\n-                int nDoS = 0;\n-                if (!state.IsInvalid(nDoS) || nDoS == 0) {\n+                if (!state.IsInvalid() || !TxRelayMayResultInDisconnect(state)) {\n                     LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n                 } else {\n@@ -2526,8 +2545,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // peer simply for relaying a tx that our recentRejects has caught,\n         // regardless of false positives.\n \n-        int nDoS = 0;\n-        if (state.IsInvalid(nDoS))\n+        if (state.IsInvalid())\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n                 pfrom->GetId(),\n@@ -2536,9 +2554,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n             }\n-            if (nDoS > 0) {\n-                Misbehaving(pfrom->GetId(), nDoS);\n-            }\n+            MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ false);\n         }\n         return true;\n     }\n@@ -2574,14 +2590,21 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         const CBlockIndex *pindex = nullptr;\n         CValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n-            int nDoS;\n-            if (state.IsInvalid(nDoS)) {\n-                if (nDoS > 0) {\n-                    LOCK(cs_main);\n-                    Misbehaving(pfrom->GetId(), nDoS, strprintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId()));\n-                } else {\n-                    LogPrint(BCLog::NET, \"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n-                }\n+            if (state.IsInvalid() && received_new_header) {\n+                // In this situation, the block header is known to be invalid.\n+                // If we never created a CBlockIndex entry for it, then the\n+                // header must be bad just by inspection (and is not one that\n+                // looked okay but the block later turned out to be invalid for\n+                // some other reason).\n+                // We should punish compact block peers that give us an invalid\n+                // header (other than a \"duplicate-invalid\" one, see\n+                // ProcessHeadersMessage), so set via_compact_block to false\n+                // here.\n+                // TODO: when we switch from DoS scores to reasons that\n+                // tx/blocks are invalid, this call should set\n+                // via_compact_block to true, since MaybePunishNode will have\n+                // sufficient information to act correctly.\n+                MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ false, \"invalid header via cmpctblock\");\n                 return true;\n             }\n         }"
      }
    ]
  },
  {
    "sha": "b8b4c80146780f9011abbd1be72343cc965c07b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOGI0YzgwMTQ2NzgwZjkwMTFhYmJkMWJlNzIzNDNjYzk2NWMwN2I5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-17T04:48:25Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T15:00:19Z"
      },
      "message": "[refactor] drop IsInvalid(nDoSOut)\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "f96b9894a37d073925dd0f0321631661f8ccc254",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f96b9894a37d073925dd0f0321631661f8ccc254"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8b4c80146780f9011abbd1be72343cc965c07b9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8b4c80146780f9011abbd1be72343cc965c07b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8b4c80146780f9011abbd1be72343cc965c07b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8b4c80146780f9011abbd1be72343cc965c07b9/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8818729013e17c650a25f030b2b80e0997389155",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8818729013e17c650a25f030b2b80e0997389155",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8818729013e17c650a25f030b2b80e0997389155"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 0,
      "deletions": 11
    },
    "files": [
      {
        "sha": "163b17e629d109d3222d811e34298d0cde023989",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8b4c80146780f9011abbd1be72343cc965c07b9/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8b4c80146780f9011abbd1be72343cc965c07b9/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=b8b4c80146780f9011abbd1be72343cc965c07b9",
        "patch": "@@ -71,13 +71,6 @@ class CValidationState {\n     bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    bool IsInvalid(int &nDoSOut) const {\n-        if (IsInvalid()) {\n-            nDoSOut = nDoS;\n-            return true;\n-        }\n-        return false;\n-    }\n     bool CorruptionPossible() const {\n         return corruptionPossible;\n     }"
      },
      {
        "sha": "4876c44f1091f830308a288099727d97e2bbc9b9",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8b4c80146780f9011abbd1be72343cc965c07b9/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8b4c80146780f9011abbd1be72343cc965c07b9/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=b8b4c80146780f9011abbd1be72343cc965c07b9",
        "patch": "@@ -52,10 +52,6 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n     // Check that the validation state reflects the unsuccessful attempt.\n     BOOST_CHECK(state.IsInvalid());\n     BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n-\n-    int nDoS;\n-    BOOST_CHECK_EQUAL(state.IsInvalid(nDoS), true);\n-    BOOST_CHECK_EQUAL(nDoS, 100);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "7b999103e21509e1c2dec10f68e48744ffe90f55",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3Yjk5OTEwM2UyMTUwOWUxYzJkZWMxMGY2OGU0ODc0NGZmZTkwZjU1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-23T20:14:16Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T15:00:19Z"
      },
      "message": "Clean up banning levels\n\nCompared with previous bans, the following changes are made:\n * Txn with empty vin/vout or null prevouts move from 10 DoS\n   points to 100.\n * Loose transactions with a dependency loop now result in a ban\n   instead of 10 DoS points.\n * Many pre-segwit soft-fork errors now result in a ban.\n   Note: Transactions that violate soft-fork script flags since P2SH do not generally\n   result in a ban. Also, banning behavior for invalid blocks is dependent on\n   whether the node is validating with multiple script check threads, due to a long-\n   standing bug. That inconsistency is still present after this commit.\n * Proof of work failure moves from 50 DoS points to a ban.\n * Blocks with timestamps under MTP now result in a ban, blocks\n   too far in the future continue to *not* result in a ban.\n * Inclusion of non-final transactions in a block now results in a\n   ban instead of 10 DoS points.\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "4c602dc5527eec26313c0aeced76b691047abab6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c602dc5527eec26313c0aeced76b691047abab6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7b999103e21509e1c2dec10f68e48744ffe90f55",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b999103e21509e1c2dec10f68e48744ffe90f55",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7b999103e21509e1c2dec10f68e48744ffe90f55",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b999103e21509e1c2dec10f68e48744ffe90f55/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8b4c80146780f9011abbd1be72343cc965c07b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8b4c80146780f9011abbd1be72343cc965c07b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8b4c80146780f9011abbd1be72343cc965c07b9"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 17,
      "deletions": 17
    },
    "files": [
      {
        "sha": "638f6b808d5ddb91d9b66155440ac20795d3bd4a",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b999103e21509e1c2dec10f68e48744ffe90f55/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b999103e21509e1c2dec10f68e48744ffe90f55/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=7b999103e21509e1c2dec10f68e48744ffe90f55",
        "patch": "@@ -11,9 +11,9 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n@@ -50,7 +50,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;"
      },
      {
        "sha": "24b5338503a8749390382a3a2214f1aea6a1e141",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b999103e21509e1c2dec10f68e48744ffe90f55/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b999103e21509e1c2dec10f68e48744ffe90f55/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=7b999103e21509e1c2dec10f68e48744ffe90f55",
        "patch": "@@ -172,8 +172,8 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(false,\n-                REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.DoS(0, false,\n+                REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\", false,\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "37082d3b065ead9897014c19895dcbdde532aca0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b999103e21509e1c2dec10f68e48744ffe90f55/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b999103e21509e1c2dec10f68e48744ffe90f55/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7b999103e21509e1c2dec10f68e48744ffe90f55",
        "patch": "@@ -760,7 +760,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, false,\n+                return state.DoS(100, false,\n                                  REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n@@ -3047,7 +3047,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.DoS(100, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n \n     return true;\n }\n@@ -3214,7 +3214,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.DoS(100, false, REJECT_INVALID, \"time-too-old\", false, \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n@@ -3225,7 +3225,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.DoS(100, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion), false,\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3255,7 +3255,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n         }\n     }\n "
      },
      {
        "sha": "f0991a284b5b1567dc1d1a382d0a38c55e849799",
        "filename": "test/functional/data/invalid_txs.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b999103e21509e1c2dec10f68e48744ffe90f55/test/functional/data/invalid_txs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b999103e21509e1c2dec10f68e48744ffe90f55/test/functional/data/invalid_txs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/data/invalid_txs.py?ref=7b999103e21509e1c2dec10f68e48744ffe90f55",
        "patch": "@@ -58,7 +58,7 @@ def get_tx(self, *args, **kwargs):\n \n class OutputMissing(BadTxTemplate):\n     reject_reason = \"bad-txns-vout-empty\"\n-    expect_disconnect = False\n+    expect_disconnect = True\n \n     def get_tx(self):\n         tx = CTransaction()\n@@ -69,7 +69,7 @@ def get_tx(self):\n \n class InputMissing(BadTxTemplate):\n     reject_reason = \"bad-txns-vin-empty\"\n-    expect_disconnect = False\n+    expect_disconnect = True\n \n     def get_tx(self):\n         tx = CTransaction()"
      },
      {
        "sha": "9e00e2d23cc5e6de71c8a2d295eef93042e87478",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b999103e21509e1c2dec10f68e48744ffe90f55/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b999103e21509e1c2dec10f68e48744ffe90f55/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=7b999103e21509e1c2dec10f68e48744ffe90f55",
        "patch": "@@ -630,7 +630,7 @@ def run_test(self):\n         while b47.sha256 < target:\n             b47.nNonce += 1\n             b47.rehash()\n-        self.send_blocks([b47], False, force_send=True, reject_reason='high-hash')\n+        self.send_blocks([b47], False, force_send=True, reject_reason='high-hash', reconnect=True)\n \n         self.log.info(\"Reject a block with a timestamp >2 hours in the future\")\n         self.move_tip(44)\n@@ -681,7 +681,7 @@ def run_test(self):\n         b54 = self.next_block(54, spend=out[15])\n         b54.nTime = b35.nTime - 1\n         b54.solve()\n-        self.send_blocks([b54], False, force_send=True, reject_reason='time-too-old')\n+        self.send_blocks([b54], False, force_send=True, reject_reason='time-too-old', reconnect=True)\n \n         # valid timestamp\n         self.move_tip(53)\n@@ -827,7 +827,7 @@ def run_test(self):\n         assert tx.vin[0].nSequence < 0xffffffff\n         tx.calc_sha256()\n         b62 = self.update_block(62, [tx])\n-        self.send_blocks([b62], success=False, reject_reason='bad-txns-nonfinal')\n+        self.send_blocks([b62], success=False, reject_reason='bad-txns-nonfinal', reconnect=True)\n \n         # Test a non-final coinbase is also rejected\n         #\n@@ -841,7 +841,7 @@ def run_test(self):\n         b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n         b63.vtx[0].rehash()\n         b63 = self.update_block(63, [])\n-        self.send_blocks([b63], success=False, reject_reason='bad-txns-nonfinal')\n+        self.send_blocks([b63], success=False, reject_reason='bad-txns-nonfinal', reconnect=True)\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n         #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n@@ -1255,7 +1255,7 @@ def run_test(self):\n \n         self.log.info(\"Reject a block with an invalid block header version\")\n         b_v1 = self.next_block('b_v1', version=1)\n-        self.send_blocks([b_v1], success=False, force_send=True, reject_reason='bad-version(0x00000001)')\n+        self.send_blocks([b_v1], success=False, force_send=True, reject_reason='bad-version(0x00000001)', reconnect=True)\n \n         self.move_tip(chain1_tip + 2)\n         b_cb34 = self.next_block('b_cb34', version=4)"
      }
    ]
  },
  {
    "sha": "6a7f8777a0b193fae4f976196f3464ffac01bf1b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTdmODc3N2EwYjE5M2ZhZTRmOTc2MTk2ZjM0NjRmZmFjMDFiZjFi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-04-16T16:38:14Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T15:00:19Z"
      },
      "message": "Ban all peers for all block script failures\n\nThis eliminates a discrepancy between block validation with multiple\nscript check threads, versus a single script check thread.",
      "tree": {
        "sha": "67d033d1829c84e0c7a7cfe13b8f838e48f0c1dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/67d033d1829c84e0c7a7cfe13b8f838e48f0c1dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a7f8777a0b193fae4f976196f3464ffac01bf1b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a7f8777a0b193fae4f976196f3464ffac01bf1b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a7f8777a0b193fae4f976196f3464ffac01bf1b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a7f8777a0b193fae4f976196f3464ffac01bf1b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7b999103e21509e1c2dec10f68e48744ffe90f55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b999103e21509e1c2dec10f68e48744ffe90f55",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b999103e21509e1c2dec10f68e48744ffe90f55"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 5,
      "deletions": 1
    },
    "files": [
      {
        "sha": "0951b3cf9715176db7ad4ebe7985aaa5ca1d2d1f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a7f8777a0b193fae4f976196f3464ffac01bf1b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a7f8777a0b193fae4f976196f3464ffac01bf1b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6a7f8777a0b193fae4f976196f3464ffac01bf1b",
        "patch": "@@ -1998,9 +1998,13 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         {\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n+                // With parallel script checks, we always set DoS to 100; do\n+                // that here as well for simplicity (for now).\n+                state.DoS(100, false, state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n+            }\n             control.Add(vChecks);\n         }\n "
      }
    ]
  },
  {
    "sha": "34477ccd39a8d4bfa8ad612f22d5a46291922185",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDQ3N2NjZDM5YThkNGJmYThhZDYxMmYyMmQ1YTQ2MjkxOTIyMTg1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-16T03:11:13Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T18:55:13Z"
      },
      "message": "[refactor] Add useful-for-dos \"reason\" field to CValidationState\n\nThis is a first step towards cleaning up our DoS interface - make\nvalidation return *why* something is invalid, and let net_processing\nfigure out what that implies in terms of banning/disconnection/etc.\n\nBehavior change: peers will now be banned for providing blocks\nwith premature coinbase spends.\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>\n                Suhas Daftuar <sdaftuar@gmail.com>",
      "tree": {
        "sha": "cb10c04ca46dc532d59d8da2c5ca797e54093b9e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb10c04ca46dc532d59d8da2c5ca797e54093b9e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34477ccd39a8d4bfa8ad612f22d5a46291922185",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34477ccd39a8d4bfa8ad612f22d5a46291922185",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34477ccd39a8d4bfa8ad612f22d5a46291922185",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34477ccd39a8d4bfa8ad612f22d5a46291922185/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a7f8777a0b193fae4f976196f3464ffac01bf1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a7f8777a0b193fae4f976196f3464ffac01bf1b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a7f8777a0b193fae4f976196f3464ffac01bf1b"
      }
    ],
    "stats": {
      "total": 251,
      "additions": 173,
      "deletions": 78
    },
    "files": [
      {
        "sha": "3aa6d3ae1f9b495ead55fc268ef425fb16e859d6",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -11,24 +11,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -37,20 +37,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;"
      },
      {
        "sha": "62a1676e2bb93ac27a62f192473b4209b9d389a4",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -160,7 +160,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.DoS(0, ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -172,28 +172,28 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.DoS(0, false,\n+            return state.DoS(0, ValidationInvalidReason::TX_MISSING_INPUTS, false,\n                 REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\", false,\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "787b171eeaf4aef796f224405c0f1f4818d80bf3",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 80,
        "deletions": 5,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -22,6 +22,50 @@ static const unsigned char REJECT_NONSTANDARD = 0x40;\n static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n+/** A \"reason\" why something was invalid, suitable for determining whether the\n+  * provider of the object should be banned/ignored/disconnected/etc.\n+  * These are much more granular than the rejection codes, which may be more\n+  * useful for some other use-cases.\n+  */\n+enum class ValidationInvalidReason {\n+    // txn and blocks:\n+    NONE,                    //!< not actually invalid\n+    CONSENSUS,               //!< invalid by consensus rules (excluding any below reasons)\n+    /**\n+     * Invalid by a change to consensus rules more recent than SegWit.\n+     * Currently unused as there are no such consensus rule changes, and any download\n+     * sources realistically need to support SegWit in order to provide useful data,\n+     * so differentiating between always-invalid and invalid-by-pre-SegWit-soft-fork\n+     * is uninteresting.\n+     */\n+    RECENT_CONSENSUS_CHANGE,\n+    // Only blocks (or headers):\n+    CACHED_INVALID,          //!< this object was cached as being invalid, but we don't know why\n+    BLOCK_INVALID_HEADER,    //!< invalid proof of work or time too old\n+    BLOCK_MUTATED,           //!< the block's data didn't match the data committed to by the PoW\n+    BLOCK_MISSING_PREV,      //!< We don't have the previous block the checked one is built on\n+    BLOCK_INVALID_PREV,      //!< A block this one builds on is invalid\n+    BLOCK_TIME_FUTURE,          //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    BLOCK_CHECKPOINT,        //!< the block failed to meet one of our checkpoints\n+    // Only loose txn:\n+    TX_NOT_STANDARD,          //!< didn't meet our local policy rules\n+    TX_MISSING_INPUTS,        //!< a transaction was missing some of its inputs (or its inputs were spent at < coinbase maturity height)\n+    /**\n+     * Transaction might be missing a witness, have a witness prior to SegWit\n+     * activation, or witness may have been malleated (which includes\n+     * non-standard witnesses).\n+     */\n+    TX_WITNESS_MUTATED,\n+    /**\n+     * Tx already in mempool or conflicts with a tx in the chain\n+     * (if it conflicts with another tx in mempool, we use MEMPOOL_POLICY as it failed to reach the RBF threshold)\n+     * TODO: Currently this is only used if the transaction already exists in the mempool or on chain,\n+     * TODO: ATMP's fMissingInputs and a valid CValidationState being used to indicate missing inputs\n+     */\n+    TX_CONFLICT,\n+    TX_MEMPOOL_POLICY,        //!< violated mempool's fee/size/descendant/RBF/etc limits\n+};\n+\n /** Capture information about block/transaction validation */\n class CValidationState {\n private:\n@@ -30,31 +74,35 @@ class CValidationState {\n         MODE_INVALID, //!< network rule violation (DoS value may be set)\n         MODE_ERROR,   //!< run-time error\n     } mode;\n+    ValidationInvalidReason m_reason;\n     int nDoS;\n     std::string strRejectReason;\n     unsigned int chRejectCode;\n     bool corruptionPossible;\n     std::string strDebugMessage;\n public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n+    CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+    bool DoS(int level, ValidationInvalidReason reasonIn, bool ret = false,\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n              bool corruptionIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n+        m_reason = reasonIn;\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n+        nDoS += level;\n+        assert(nDoS == GetDoSForReason());\n+        assert(corruptionPossible == (m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED));\n         if (mode == MODE_ERROR)\n             return ret;\n-        nDoS += level;\n         mode = MODE_INVALID;\n         return ret;\n     }\n-    bool Invalid(bool ret = false,\n+    bool Invalid(ValidationInvalidReason _reason, bool ret = false,\n                  unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(0, _reason, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n@@ -72,12 +120,39 @@ class CValidationState {\n         return mode == MODE_ERROR;\n     }\n     bool CorruptionPossible() const {\n+        assert(corruptionPossible == (m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED));\n         return corruptionPossible;\n     }\n     void SetCorruptionPossible() {\n         corruptionPossible = true;\n+        assert(corruptionPossible == (m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED));\n     }\n     int GetDoS(void) const { return nDoS; }\n+    int GetDoSForReason() const {\n+        switch (m_reason) {\n+        case ValidationInvalidReason::NONE:\n+            return 0;\n+        case ValidationInvalidReason::CONSENSUS:\n+        case ValidationInvalidReason::BLOCK_MUTATED:\n+        case ValidationInvalidReason::BLOCK_INVALID_HEADER:\n+        case ValidationInvalidReason::BLOCK_CHECKPOINT:\n+        case ValidationInvalidReason::BLOCK_INVALID_PREV:\n+            return 100;\n+        case ValidationInvalidReason::BLOCK_MISSING_PREV:\n+            return 10;\n+        case ValidationInvalidReason::CACHED_INVALID:\n+        case ValidationInvalidReason::RECENT_CONSENSUS_CHANGE:\n+        case ValidationInvalidReason::BLOCK_TIME_FUTURE:\n+        case ValidationInvalidReason::TX_NOT_STANDARD:\n+        case ValidationInvalidReason::TX_MISSING_INPUTS:\n+        case ValidationInvalidReason::TX_WITNESS_MUTATED:\n+        case ValidationInvalidReason::TX_CONFLICT:\n+        case ValidationInvalidReason::TX_MEMPOOL_POLICY:\n+            return 0;\n+        }\n+        return 0;\n+    }\n+    ValidationInvalidReason GetReason() const { return m_reason; }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }"
      },
      {
        "sha": "489ffcdc662eec0cbe18d6f35ea3a608865e82c5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -961,6 +961,7 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n \n static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n {\n+    assert(state.GetDoS() == state.GetDoSForReason());\n     return (state.GetDoS() > 0);\n }\n \n@@ -975,6 +976,7 @@ static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n  * txs, the peer should not be punished. See BIP 152.\n  */\n static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+    assert(state.GetDoS() == state.GetDoSForReason());\n     int nDoS = state.GetDoS();\n     if (nDoS > 0 && !via_compact_block) {\n          LOCK(cs_main);"
      },
      {
        "sha": "aa30129361f255de8ad4598b4f2ed2353bd4783c",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -52,6 +52,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n     // Check that the validation state reflects the unsuccessful attempt.\n     BOOST_CHECK(state.IsInvalid());\n     BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n+    BOOST_CHECK(state.GetReason() == ValidationInvalidReason::CONSENSUS);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "5f6d578c2b3d48baad0bcd42261377dbb82aa8b6",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 57,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -579,28 +579,28 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n+        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to reduce unnecessary malloc overhead.\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"tx-size-small\");\n+        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -636,7 +636,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -662,7 +662,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -685,7 +685,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -694,11 +694,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -722,21 +722,21 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         unsigned int nSize = entry.GetTxSize();\n \n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n+            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n+            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(false,\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n@@ -748,7 +748,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -760,7 +760,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(100, false,\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n                                  REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n@@ -803,7 +803,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, false,\n+                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                             REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n@@ -832,7 +832,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                         REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n@@ -852,7 +852,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.DoS(0, false,\n+                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                                          REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n@@ -865,7 +865,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                                  REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n@@ -876,7 +876,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n                         REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n@@ -898,7 +898,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n                 !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n-                state.SetCorruptionPossible();\n+                state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n+                          state.GetRejectCode(), state.GetRejectReason(), true, state.GetDebugMessage());\n             }\n             return false; // state filled in by CheckInputs\n         }\n@@ -956,7 +957,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1357,6 +1358,9 @@ void InitScriptExecutionCache() {\n  * which are matched. This is useful for checking blocks where we will likely never need the cache\n  * entry again.\n  *\n+ * Note that we may set state.reason to NOT_STANDARD for extra soft-fork flags in flags, block-checking\n+ * callers should probably reset it to CONSENSUS in such cases.\n+ *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -1418,7 +1422,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -1427,7 +1431,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1922,7 +1926,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n@@ -1962,11 +1966,17 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         {\n             CAmount txfee = 0;\n             if (!Consensus::CheckTxInputs(tx, state, view, pindex->nHeight, txfee)) {\n+                if (state.GetReason() == ValidationInvalidReason::TX_MISSING_INPUTS) {\n+                    // CheckTxInputs may return MISSING_INPUTS but we can't return that, as\n+                    // it's not defined for a block, so we reset the reason flag to CONSENSUS here.\n+                    state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                }\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, error(\"%s: accumulated fee in the block out of range.\", __func__),\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n                                  REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n@@ -1979,7 +1989,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n@@ -1990,7 +2000,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n         txdata.emplace_back(tx);\n@@ -1999,9 +2009,16 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n             if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n-                // With parallel script checks, we always set DoS to 100; do\n-                // that here as well for simplicity (for now).\n-                state.DoS(100, false, state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                if (state.GetReason() == ValidationInvalidReason::TX_NOT_STANDARD) {\n+                    // CheckInputs may return NOT_STANDARD for extra flags we passed,\n+                    // but we can't return that, as it's not defined for a block, so\n+                    // we reset the reason flag to CONSENSUS here.\n+                    // In the event of a future soft-fork, we may need to\n+                    // consider whether rewriting to CONSENSUS or\n+                    // RECENT_CONSENSUS_CHANGE would be more appropriate.\n+                    state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                }\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n@@ -2019,13 +2036,13 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100,\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS,\n                          error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0]->GetValueOut(), blockReward),\n                                REJECT_INVALID, \"bad-cb-amount\");\n \n     if (!control.Wait())\n-        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3051,7 +3068,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(100, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n \n     return true;\n }\n@@ -3073,13 +3090,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3090,19 +3107,19 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, true))\n-            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n+            return state.Invalid(state.GetReason(), false, state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3111,7 +3128,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3204,7 +3221,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3213,23 +3230,23 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.DoS(100, false, REJECT_INVALID, \"time-too-old\", false, \"block's timestamp is too early\");\n+        return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"time-too-old\", false, \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_TIME_FUTURE, false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.DoS(100, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion), false,\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion), false,\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3259,7 +3276,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n         }\n     }\n \n@@ -3269,7 +3286,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3291,11 +3308,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3305,7 +3322,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3317,7 +3334,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3337,7 +3354,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n             return true;\n         }\n \n@@ -3348,10 +3365,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+            return state.DoS(10, ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3388,7 +3405,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      },
      {
        "sha": "9a9424b82b547280bb001dced5e31ff3c769301d",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34477ccd39a8d4bfa8ad612f22d5a46291922185/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34477ccd39a8d4bfa8ad612f22d5a46291922185/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "patch": "@@ -295,7 +295,7 @@ def run_test(self):\n         self.log.info(\"Reject a block spending an immature coinbase.\")\n         self.move_tip(15)\n         b20 = self.next_block(20, spend=out[7])\n-        self.send_blocks([b20], success=False, reject_reason='bad-txns-premature-spend-of-coinbase')\n+        self.send_blocks([b20], success=False, reject_reason='bad-txns-premature-spend-of-coinbase', reconnect=True)\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n@@ -308,7 +308,7 @@ def run_test(self):\n         self.send_blocks([b21], False)\n \n         b22 = self.next_block(22, spend=out[5])\n-        self.send_blocks([b22], success=False, reject_reason='bad-txns-premature-spend-of-coinbase')\n+        self.send_blocks([b22], success=False, reject_reason='bad-txns-premature-spend-of-coinbase', reconnect=True)\n \n         # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)"
      }
    ]
  },
  {
    "sha": "c8b0d22698385f91215ce8145631e3d5826dc977",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOGIwZDIyNjk4Mzg1ZjkxMjE1Y2U4MTQ1NjMxZTNkNTgyNmRjOTc3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-18T02:58:41Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:10:32Z"
      },
      "message": "[refactor] Drop redundant nDoS, corruptionPossible, SetCorruptionPossible\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "f3ff70231f17bc4a7d232a7084825cb0b91efe8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3ff70231f17bc4a7d232a7084825cb0b91efe8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c8b0d22698385f91215ce8145631e3d5826dc977",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8b0d22698385f91215ce8145631e3d5826dc977",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c8b0d22698385f91215ce8145631e3d5826dc977",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8b0d22698385f91215ce8145631e3d5826dc977/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34477ccd39a8d4bfa8ad612f22d5a46291922185",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34477ccd39a8d4bfa8ad612f22d5a46291922185"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 5,
      "deletions": 18
    },
    "files": [
      {
        "sha": "a18739135ffbf3d975463fd43f83c6c55b3b0511",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 16,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b0d22698385f91215ce8145631e3d5826dc977/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b0d22698385f91215ce8145631e3d5826dc977/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=c8b0d22698385f91215ce8145631e3d5826dc977",
        "patch": "@@ -75,25 +75,20 @@ class CValidationState {\n         MODE_ERROR,   //!< run-time error\n     } mode;\n     ValidationInvalidReason m_reason;\n-    int nDoS;\n     std::string strRejectReason;\n     unsigned int chRejectCode;\n-    bool corruptionPossible;\n     std::string strDebugMessage;\n public:\n-    CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+    CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE), chRejectCode(0) {}\n     bool DoS(int level, ValidationInvalidReason reasonIn, bool ret = false,\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n-             bool corruptionIn=false,\n+             bool corruptionPossibleIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n         m_reason = reasonIn;\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n-        corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n-        nDoS += level;\n-        assert(nDoS == GetDoSForReason());\n-        assert(corruptionPossible == (m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED));\n+        assert(corruptionPossibleIn == CorruptionPossible());\n         if (mode == MODE_ERROR)\n             return ret;\n         mode = MODE_INVALID;\n@@ -120,15 +115,9 @@ class CValidationState {\n         return mode == MODE_ERROR;\n     }\n     bool CorruptionPossible() const {\n-        assert(corruptionPossible == (m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED));\n-        return corruptionPossible;\n+        return m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED;\n     }\n-    void SetCorruptionPossible() {\n-        corruptionPossible = true;\n-        assert(corruptionPossible == (m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED));\n-    }\n-    int GetDoS(void) const { return nDoS; }\n-    int GetDoSForReason() const {\n+    int GetDoS() const {\n         switch (m_reason) {\n         case ValidationInvalidReason::NONE:\n             return 0;"
      },
      {
        "sha": "a416093db14857616578e487965e85c6cc6cd1fc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b0d22698385f91215ce8145631e3d5826dc977/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b0d22698385f91215ce8145631e3d5826dc977/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c8b0d22698385f91215ce8145631e3d5826dc977",
        "patch": "@@ -961,7 +961,6 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n \n static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n {\n-    assert(state.GetDoS() == state.GetDoSForReason());\n     return (state.GetDoS() > 0);\n }\n \n@@ -976,7 +975,6 @@ static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n  * txs, the peer should not be punished. See BIP 152.\n  */\n static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n-    assert(state.GetDoS() == state.GetDoSForReason());\n     int nDoS = state.GetDoS();\n     if (nDoS > 0 && !via_compact_block) {\n          LOCK(cs_main);"
      }
    ]
  },
  {
    "sha": "7df16e70e67c753c871797ce947ea09d7cb0e519",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZGYxNmU3MGU2N2M3NTNjODcxNzk3Y2U5NDdlYTA5ZDdjYjBlNTE5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-17T04:33:16Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:11:03Z"
      },
      "message": "LookupBlockIndex -> CACHED_INVALID\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "cbd6c498379f6ad3b23d0be1f997b78f61116e0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cbd6c498379f6ad3b23d0be1f997b78f61116e0e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7df16e70e67c753c871797ce947ea09d7cb0e519",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7df16e70e67c753c871797ce947ea09d7cb0e519",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7df16e70e67c753c871797ce947ea09d7cb0e519",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7df16e70e67c753c871797ce947ea09d7cb0e519/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c8b0d22698385f91215ce8145631e3d5826dc977",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8b0d22698385f91215ce8145631e3d5826dc977",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c8b0d22698385f91215ce8145631e3d5826dc977"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5c5faa1304bde385da184fe01119d97f5ce2c6fc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7df16e70e67c753c871797ce947ea09d7cb0e519/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7df16e70e67c753c871797ce947ea09d7cb0e519/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7df16e70e67c753c871797ce947ea09d7cb0e519",
        "patch": "@@ -1578,7 +1578,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     CBlockHeader first_invalid_header;\n     if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n         if (state.IsInvalid()) {\n-            if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {\n+            if (punish_duplicate_invalid && state.GetReason() == ValidationInvalidReason::CACHED_INVALID) {\n                 // Goal: don't allow outbound peers to use up our outbound\n                 // connection slots if they are on incompatible chains.\n                 //"
      }
    ]
  },
  {
    "sha": "6e55b292b0ea944897b6dc2f766446fd209af484",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZTU1YjI5MmIwZWE5NDQ4OTdiNmRjMmY3NjY0NDZmZDIwOWFmNDg0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-17T04:35:01Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:12:38Z"
      },
      "message": "CorruptionPossible -> TX_WITNESS_MUTATED\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "8793ce803819c7234effc069adc306283d36141f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8793ce803819c7234effc069adc306283d36141f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e55b292b0ea944897b6dc2f766446fd209af484",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e55b292b0ea944897b6dc2f766446fd209af484",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6e55b292b0ea944897b6dc2f766446fd209af484",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e55b292b0ea944897b6dc2f766446fd209af484/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7df16e70e67c753c871797ce947ea09d7cb0e519",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7df16e70e67c753c871797ce947ea09d7cb0e519",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7df16e70e67c753c871797ce947ea09d7cb0e519"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "99c791daebf3bd308b359261d5d6c481450dd4f1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e55b292b0ea944897b6dc2f766446fd209af484/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e55b292b0ea944897b6dc2f766446fd209af484/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6e55b292b0ea944897b6dc2f766446fd209af484",
        "patch": "@@ -1777,7 +1777,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             // Has inputs but not accepted to mempool\n             // Probably non-standard or insufficient fee\n             LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n-            if (!orphanTx.HasWitness() && !orphan_state.CorruptionPossible()) {\n+            if (!orphanTx.HasWitness() && orphan_state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n                 // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n@@ -2494,7 +2494,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 recentRejects->insert(tx.GetHash());\n             }\n         } else {\n-            if (!tx.HasWitness() && !state.CorruptionPossible()) {\n+            if (!tx.HasWitness() && state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n                 // See https://github.com/bitcoin/bitcoin/issues/8279 for details."
      }
    ]
  },
  {
    "sha": "9ab2a0412e96e87956fe61257387683635213035",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YWIyYTA0MTJlOTZlODc5NTZmZTYxMjU3Mzg3NjgzNjM1MjEzMDM1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-18T02:56:06Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:14:12Z"
      },
      "message": "CorruptionPossible -> BLOCK_MUTATED\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "bfae8be517c80d86ecad10a0fb9b3199c81c13ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bfae8be517c80d86ecad10a0fb9b3199c81c13ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ab2a0412e96e87956fe61257387683635213035",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ab2a0412e96e87956fe61257387683635213035",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ab2a0412e96e87956fe61257387683635213035",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ab2a0412e96e87956fe61257387683635213035/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6e55b292b0ea944897b6dc2f766446fd209af484",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e55b292b0ea944897b6dc2f766446fd209af484",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6e55b292b0ea944897b6dc2f766446fd209af484"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "f0fcf675eb2c970cc8f8490ee65edc8504ababf3",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ab2a0412e96e87956fe61257387683635213035/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ab2a0412e96e87956fe61257387683635213035/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=9ab2a0412e96e87956fe61257387683635213035",
        "patch": "@@ -203,7 +203,7 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         // but that is expensive, and CheckBlock caches a block's\n         // \"checked-status\" (in the CBlock?). CBlock should be able to\n         // check its own merkle root and cache that check.\n-        if (state.CorruptionPossible())\n+        if (state.GetReason() == ValidationInvalidReason::BLOCK_MUTATED)\n             return READ_STATUS_FAILED; // Possible Short ID collision\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }"
      },
      {
        "sha": "6aa2941e524174d86790bef4e0d4e7aa9110c26e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ab2a0412e96e87956fe61257387683635213035/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ab2a0412e96e87956fe61257387683635213035/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=9ab2a0412e96e87956fe61257387683635213035",
        "patch": "@@ -1290,7 +1290,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(c\n }\n \n void CChainState::InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n-    if (!state.CorruptionPossible()) {\n+    if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         m_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n@@ -1791,7 +1791,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     // re-enforce that rule here (at least until we make it impossible for\n     // GetAdjustedTime() to go backward).\n     if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck)) {\n-        if (state.CorruptionPossible()) {\n+        if (state.GetReason() == ValidationInvalidReason::BLOCK_MUTATED) {\n             // We don't write down blocks to disk if they may have been\n             // corrupted, so this should be impossible unless we're having hardware\n             // problems.\n@@ -2570,7 +2570,7 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n             if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n-                    if (!state.CorruptionPossible()) {\n+                    if (state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n                         InvalidChainFound(vpindexToConnect.front());\n                     }\n                     state = CValidationState();\n@@ -3509,7 +3509,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n-        if (state.IsInvalid() && !state.CorruptionPossible()) {\n+        if (state.IsInvalid() && state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n             setDirtyBlockIndex.insert(pindex);\n         }"
      }
    ]
  },
  {
    "sha": "ef54b486d5333dfc85c56e6b933c81735196a25d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZjU0YjQ4NmQ1MzMzZGZjODVjNTZlNmI5MzNjODE3MzUxOTZhMjVk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-08T16:57:38Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:15:50Z"
      },
      "message": "[refactor] Use Reasons directly instead of DoS codes",
      "tree": {
        "sha": "599013fa1d8f3af6858ede2d813510e4764a21dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/599013fa1d8f3af6858ede2d813510e4764a21dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef54b486d5333dfc85c56e6b933c81735196a25d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef54b486d5333dfc85c56e6b933c81735196a25d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ef54b486d5333dfc85c56e6b933c81735196a25d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef54b486d5333dfc85c56e6b933c81735196a25d/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ab2a0412e96e87956fe61257387683635213035",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ab2a0412e96e87956fe61257387683635213035",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ab2a0412e96e87956fe61257387683635213035"
      }
    ],
    "stats": {
      "total": 87,
      "additions": 57,
      "deletions": 30
    },
    "files": [
      {
        "sha": "0a78ad47e08df9aeb5e25f4667d39c22180d951b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 30,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef54b486d5333dfc85c56e6b933c81735196a25d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef54b486d5333dfc85c56e6b933c81735196a25d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ef54b486d5333dfc85c56e6b933c81735196a25d",
        "patch": "@@ -959,27 +959,68 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n         LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n }\n \n+/**\n+ * Returns true if the given validation state result may result in a peer\n+ * banning/disconnecting us. We use this to determine which unaccepted\n+ * transactions from a whitelisted peer that we can safely relay.\n+ */\n static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n {\n-    return (state.GetDoS() > 0);\n+    return state.GetReason() == ValidationInvalidReason::CONSENSUS;\n }\n \n /**\n  * Potentially ban a node based on the contents of a CValidationState object\n- * TODO: net_processing should make the punish decision based on the reason\n- * a tx/block was invalid, rather than just the nDoS score handed back by validation.\n  *\n- * @parameter via_compact_block: this bool is passed in because net_processing should\n+ * @param[in] via_compact_block: this bool is passed in because net_processing should\n  * punish peers differently depending on whether the data was provided in a compact\n  * block message or not. If the compact block had a valid header, but contained invalid\n  * txs, the peer should not be punished. See BIP 152.\n+ *\n+ * @return Returns true if the peer was punished (probably disconnected)\n+ *\n+ * Changes here may need to be reflected in TxRelayMayResultInDisconnect().\n  */\n static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n-    int nDoS = state.GetDoS();\n-    if (nDoS > 0 && !via_compact_block) {\n-         LOCK(cs_main);\n-         Misbehaving(nodeid, nDoS, message);\n-         return true;\n+    switch (state.GetReason()) {\n+    case ValidationInvalidReason::NONE:\n+        break;\n+    // The node is providing invalid data:\n+    case ValidationInvalidReason::CONSENSUS:\n+    case ValidationInvalidReason::BLOCK_MUTATED:\n+        if (!via_compact_block) {\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 100, message);\n+            return true;\n+        }\n+        break;\n+    // Handled elsewhere for now\n+    case ValidationInvalidReason::CACHED_INVALID:\n+        break;\n+    case ValidationInvalidReason::BLOCK_INVALID_HEADER:\n+    case ValidationInvalidReason::BLOCK_CHECKPOINT:\n+    case ValidationInvalidReason::BLOCK_INVALID_PREV:\n+        {\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 100, message);\n+        }\n+        return true;\n+    // Conflicting (but not necessarily invalid) data or different policy:\n+    case ValidationInvalidReason::BLOCK_MISSING_PREV:\n+        {\n+            // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)\n+            LOCK(cs_main);\n+            Misbehaving(nodeid, 10, message);\n+        }\n+        return true;\n+    case ValidationInvalidReason::RECENT_CONSENSUS_CHANGE:\n+    case ValidationInvalidReason::BLOCK_TIME_FUTURE:\n+    case ValidationInvalidReason::TX_NOT_STANDARD:\n+    case ValidationInvalidReason::TX_MISSING_INPUTS:\n+    case ValidationInvalidReason::TX_WITNESS_MUTATED:\n+    case ValidationInvalidReason::TX_CONFLICT:\n+    case ValidationInvalidReason::TX_MEMPOOL_POLICY:\n+        break;\n     }\n     if (message != \"\") {\n         LogPrint(BCLog::NET, \"peer=%d: %s\\n\", nodeid, message);\n@@ -2513,14 +2554,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // to policy, allowing the node to function as a gateway for\n                 // nodes hidden behind it.\n                 //\n-                // Never relay transactions that we would assign a non-zero DoS\n-                // score for, as we expect peers to do the same with us in that\n-                // case.\n-                if (!state.IsInvalid() || !TxRelayMayResultInDisconnect(state)) {\n+                // Never relay transactions that might result in being\n+                // disconnected (or banned).\n+                if (state.IsInvalid() && TxRelayMayResultInDisconnect(state)) {\n+                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n+                } else {\n                     LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n-                } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n                 }\n             }\n         }\n@@ -2590,21 +2630,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         const CBlockIndex *pindex = nullptr;\n         CValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n-            if (state.IsInvalid() && received_new_header) {\n-                // In this situation, the block header is known to be invalid.\n-                // If we never created a CBlockIndex entry for it, then the\n-                // header must be bad just by inspection (and is not one that\n-                // looked okay but the block later turned out to be invalid for\n-                // some other reason).\n-                // We should punish compact block peers that give us an invalid\n-                // header (other than a \"duplicate-invalid\" one, see\n-                // ProcessHeadersMessage), so set via_compact_block to false\n-                // here.\n-                // TODO: when we switch from DoS scores to reasons that\n-                // tx/blocks are invalid, this call should set\n-                // via_compact_block to true, since MaybePunishNode will have\n-                // sufficient information to act correctly.\n-                MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ false, \"invalid header via cmpctblock\");\n+            if (state.IsInvalid()) {\n+                MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ true, \"invalid header via cmpctblock\");\n                 return true;\n             }\n         }"
      }
    ]
  },
  {
    "sha": "6b34bc6b6f54f85537494cbea3846d5d195a06d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YjM0YmM2YjZmNTRmODU1Mzc0OTRjYmVhMzg0NmQ1ZDE5NWEwNmQ5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-01-15T20:54:04Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:17:24Z"
      },
      "message": "Fix handling of invalid headers\n\nWe only disconnect outbound peers (excluding HB compact block peers and manual\nconnections) when receiving a CACHED_INVALID header.",
      "tree": {
        "sha": "78b40adb6d30d8694a5002db081e96aaa55322a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78b40adb6d30d8694a5002db081e96aaa55322a8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b34bc6b6f54f85537494cbea3846d5d195a06d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b34bc6b6f54f85537494cbea3846d5d195a06d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6b34bc6b6f54f85537494cbea3846d5d195a06d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b34bc6b6f54f85537494cbea3846d5d195a06d9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ef54b486d5333dfc85c56e6b933c81735196a25d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef54b486d5333dfc85c56e6b933c81735196a25d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef54b486d5333dfc85c56e6b933c81735196a25d"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 30,
      "deletions": 47
    },
    "files": [
      {
        "sha": "c19befcf88433b37108f313933585800b059b578",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 47,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b34bc6b6f54f85537494cbea3846d5d195a06d9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b34bc6b6f54f85537494cbea3846d5d195a06d9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6b34bc6b6f54f85537494cbea3846d5d195a06d9",
        "patch": "@@ -351,7 +351,16 @@ struct CNodeState {\n \n     TxDownloadState m_tx_download;\n \n-    CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n+    //! Whether this peer is an inbound connection\n+    bool m_is_inbound;\n+\n+    //! Whether this peer is a manual connection\n+    bool m_is_manual_connection;\n+\n+    CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :\n+        address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),\n+        m_is_manual_connection (is_manual)\n+    {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n         fShouldBan = false;\n@@ -747,7 +756,7 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     NodeId nodeid = pnode->GetId();\n     {\n         LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n     if(!pnode->fInbound)\n         PushNodeVersion(pnode, connman, GetTime());\n@@ -994,9 +1003,22 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n             return true;\n         }\n         break;\n-    // Handled elsewhere for now\n     case ValidationInvalidReason::CACHED_INVALID:\n-        break;\n+        {\n+            LOCK(cs_main);\n+            CNodeState *node_state = State(nodeid);\n+            if (node_state == nullptr) {\n+                break;\n+            }\n+\n+            // Ban outbound (but not inbound) peers if on an invalid chain.\n+            // Exempt HB compact block peers and manual connections.\n+            if (!via_compact_block && !node_state->m_is_inbound && !node_state->m_is_manual_connection) {\n+                Misbehaving(nodeid, 100, message);\n+                return true;\n+            }\n+            break;\n+        }\n     case ValidationInvalidReason::BLOCK_INVALID_HEADER:\n     case ValidationInvalidReason::BLOCK_CHECKPOINT:\n     case ValidationInvalidReason::BLOCK_INVALID_PREV:\n@@ -1556,7 +1578,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool punish_duplicate_invalid)\n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1619,41 +1641,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     CBlockHeader first_invalid_header;\n     if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n         if (state.IsInvalid()) {\n-            if (punish_duplicate_invalid && state.GetReason() == ValidationInvalidReason::CACHED_INVALID) {\n-                // Goal: don't allow outbound peers to use up our outbound\n-                // connection slots if they are on incompatible chains.\n-                //\n-                // We ask the caller to set punish_invalid appropriately based\n-                // on the peer and the method of header delivery (compact\n-                // blocks are allowed to be invalid in some circumstances,\n-                // under BIP 152).\n-                // Here, we try to detect the narrow situation that we have a\n-                // valid block header (ie it was valid at the time the header\n-                // was received, and hence stored in mapBlockIndex) but know the\n-                // block is invalid, and that a peer has announced that same\n-                // block as being on its active chain.\n-                // Disconnect the peer in such a situation.\n-                //\n-                // Note: if the header that is invalid was not accepted to our\n-                // mapBlockIndex at all, that may also be grounds for\n-                // disconnecting the peer, as the chain they are on is likely\n-                // to be incompatible. However, there is a circumstance where\n-                // that does not hold: if the header's timestamp is more than\n-                // 2 hours ahead of our current time. In that case, the header\n-                // may become valid in the future, and we don't want to\n-                // disconnect a peer merely for serving us one too-far-ahead\n-                // block header, to prevent an attacker from splitting the\n-                // network by mining a block right at the 2 hour boundary.\n-                //\n-                // TODO: update the DoS logic (or, rather, rewrite the\n-                // DoS-interface between validation and net_processing) so that\n-                // the interface is cleaner, and so that we disconnect on all the\n-                // reasons that a peer's headers chain is incompatible\n-                // with ours (eg block->nVersion softforks, MTP violations,\n-                // etc), and not just the duplicate-invalid case.\n-                pfrom->fDisconnect = true;\n-            }\n-            MaybePunishNode(pfrom->GetId(), state, /*via_compact_block*/ false, \"invalid header received\");\n+            MaybePunishNode(pfrom->GetId(), state, via_compact_block, \"invalid header received\");\n             return false;\n         }\n     }\n@@ -2781,7 +2769,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // the peer if the header turns out to be for an invalid block.\n             // Note that if a peer tries to build on an invalid chain, that\n             // will be detected and the peer will be banned.\n-            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false);\n+            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n         }\n \n         if (fBlockReconstructed) {\n@@ -2924,12 +2912,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        // Headers received via a HEADERS message should be valid, and reflect\n-        // the chain the peer is on. If we receive a known-invalid header,\n-        // disconnect the peer if it is using one of our outbound connection\n-        // slots.\n-        bool should_punish = !pfrom->fInbound && !pfrom->m_manual_connection;\n-        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish);\n+        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, /*via_compact_block=*/false);\n     }\n \n     if (strCommand == NetMsgType::BLOCK)"
      }
    ]
  },
  {
    "sha": "5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTc4YzU3MzRiYjBjOWFhZTdiMGE3MDE5YTc0NWIyZDcwNTliM2Q5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-20T03:21:55Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:21:24Z"
      },
      "message": "Allow use of state.Invalid() for all reasons\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "2f3527796d51a95a430e025cc6eab032d4636c81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f3527796d51a95a430e025cc6eab032d4636c81"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6b34bc6b6f54f85537494cbea3846d5d195a06d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b34bc6b6f54f85537494cbea3846d5d195a06d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6b34bc6b6f54f85537494cbea3846d5d195a06d9"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 8,
      "deletions": 6
    },
    "files": [
      {
        "sha": "9583e610569ce60c3df47f9a9b80cb535f7d0c97",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
        "patch": "@@ -84,21 +84,23 @@ class CValidationState {\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n              bool corruptionPossibleIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n+        ret = Invalid(reasonIn, ret, chRejectCodeIn, strRejectReasonIn, strDebugMessageIn);\n+        assert(level == GetDoS());\n+        assert(corruptionPossibleIn == CorruptionPossible());\n+        return ret;\n+    }\n+    bool Invalid(ValidationInvalidReason reasonIn, bool ret = false,\n+                 unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n+                 const std::string &strDebugMessageIn=\"\") {\n         m_reason = reasonIn;\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         strDebugMessage = strDebugMessageIn;\n-        assert(corruptionPossibleIn == CorruptionPossible());\n         if (mode == MODE_ERROR)\n             return ret;\n         mode = MODE_INVALID;\n         return ret;\n     }\n-    bool Invalid(ValidationInvalidReason _reason, bool ret = false,\n-                 unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n-                 const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, _reason, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n-    }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;"
      }
    ]
  },
  {
    "sha": "7721ad64f40a0c67edefaaf7353264d78df8803e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NzIxYWQ2NGY0MGEwYzY3ZWRlZmFhZjczNTMyNjRkNzhkZjg4MDNl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-08T19:50:18Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:22:29Z"
      },
      "message": "[refactor] Prep for scripted-diff by removing some \\ns which annoy sed.",
      "tree": {
        "sha": "44727b13ce020db93cdb5df3c75251679f4af97a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44727b13ce020db93cdb5df3c75251679f4af97a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7721ad64f40a0c67edefaaf7353264d78df8803e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7721ad64f40a0c67edefaaf7353264d78df8803e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7721ad64f40a0c67edefaaf7353264d78df8803e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7721ad64f40a0c67edefaaf7353264d78df8803e/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e78c5734bb0c9aae7b0a7019a745b2d7059b3d9"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 9,
      "deletions": 16
    },
    "files": [
      {
        "sha": "60af773b1754d88994cf1664a5ad730134760977",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7721ad64f40a0c67edefaaf7353264d78df8803e/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7721ad64f40a0c67edefaaf7353264d78df8803e/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=7721ad64f40a0c67edefaaf7353264d78df8803e",
        "patch": "@@ -172,8 +172,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MISSING_INPUTS, false,\n-                REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\", false,\n+            return state.DoS(0, ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\", false,\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "d7595627e9d3354a4093bd1eae91d407a93c50e1",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 14,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7721ad64f40a0c67edefaaf7353264d78df8803e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7721ad64f40a0c67edefaaf7353264d78df8803e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7721ad64f40a0c67edefaaf7353264d78df8803e",
        "patch": "@@ -760,8 +760,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n-                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n                                            hashAncestor.ToString()));\n@@ -803,8 +802,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n@@ -832,8 +830,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n@@ -852,8 +849,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n                     }\n@@ -865,8 +861,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -876,8 +871,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false,\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n@@ -899,7 +893,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n-                          state.GetRejectCode(), state.GetRejectReason(), true, state.GetDebugMessage());\n+                        state.GetRejectCode(), state.GetRejectReason(), true, state.GetDebugMessage());\n             }\n             return false; // state filled in by CheckInputs\n         }\n@@ -1970,7 +1964,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                     // CheckTxInputs may return MISSING_INPUTS but we can't return that, as\n                     // it's not defined for a block, so we reset the reason flag to CONSENSUS here.\n                     state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n-                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                            state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n                 }\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }"
      }
    ]
  },
  {
    "sha": "aa502b88d10c2c3ac56d9163555849b96dc4df1e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYTUwMmI4OGQxMGMyYzNhYzU2ZDkxNjM1NTU4NDliOTZkYzRkZjFl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-04-11T18:11:48Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:24:07Z"
      },
      "message": "scripted-diff: Remove DoS calls to CValidationState\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/\\.DoS(\\(.*\\), REJECT_\\(.*\\), \\(true\\|false\\)/.DoS(\\1, REJECT_\\2/' src/validation.cpp src/consensus/tx_verify.cpp src/consensus/tx_check.cpp\nsed -i 's/state.GetRejectCode(), state.GetRejectReason(), [^,]\\+, state.GetDebugMessage())/state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage())/' src/validation.cpp\nsed -i 's/\\.DoS([^,]*, /.Invalid\\(/' src/validation.cpp src/consensus/tx_verify.cpp src/consensus/tx_check.cpp\n-END VERIFY SCRIPT-\n\nCo-authored-by: Suhas Daftuar <sdaftuar@gmail.com>",
      "tree": {
        "sha": "1d2604a89a30b80be170271439d61706363ad119",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1d2604a89a30b80be170271439d61706363ad119"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa502b88d10c2c3ac56d9163555849b96dc4df1e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa502b88d10c2c3ac56d9163555849b96dc4df1e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aa502b88d10c2c3ac56d9163555849b96dc4df1e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa502b88d10c2c3ac56d9163555849b96dc4df1e/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7721ad64f40a0c67edefaaf7353264d78df8803e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7721ad64f40a0c67edefaaf7353264d78df8803e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7721ad64f40a0c67edefaaf7353264d78df8803e"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 64,
      "deletions": 64
    },
    "files": [
      {
        "sha": "23ed3ecb5386303c08bf05579e3728e2bd87d42e",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa502b88d10c2c3ac56d9163555849b96dc4df1e/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa502b88d10c2c3ac56d9163555849b96dc4df1e/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=aa502b88d10c2c3ac56d9163555849b96dc4df1e",
        "patch": "@@ -11,24 +11,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -37,20 +37,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;"
      },
      {
        "sha": "c13a38cd6fd512eb715a8139b5cb673550d865d2",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa502b88d10c2c3ac56d9163555849b96dc4df1e/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa502b88d10c2c3ac56d9163555849b96dc4df1e/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=aa502b88d10c2c3ac56d9163555849b96dc4df1e",
        "patch": "@@ -160,7 +160,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(0, ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -172,27 +172,27 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\", false,\n+            return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "4184d5a81a1a75c5252f5272156044d076166a05",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa502b88d10c2c3ac56d9163555849b96dc4df1e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa502b88d10c2c3ac56d9163555849b96dc4df1e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=aa502b88d10c2c3ac56d9163555849b96dc4df1e",
        "patch": "@@ -579,24 +579,24 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason))\n-        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to reduce unnecessary malloc overhead.\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n@@ -685,7 +685,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -698,7 +698,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -722,17 +722,17 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         unsigned int nSize = entry.GetTxSize();\n \n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -748,7 +748,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -760,7 +760,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n                                            hashAncestor.ToString()));\n@@ -802,7 +802,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n@@ -830,7 +830,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n@@ -849,7 +849,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n                     }\n@@ -861,7 +861,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -871,7 +871,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n@@ -892,8 +892,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n                 !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n-                state.DoS(0, ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n-                        state.GetRejectCode(), state.GetRejectReason(), true, state.GetDebugMessage());\n+                state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n+                        state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n             }\n             return false; // state filled in by CheckInputs\n         }\n@@ -951,7 +951,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1425,7 +1425,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1920,7 +1920,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                    return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n@@ -1963,14 +1963,14 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                 if (state.GetReason() == ValidationInvalidReason::TX_MISSING_INPUTS) {\n                     // CheckTxInputs may return MISSING_INPUTS but we can't return that, as\n                     // it's not defined for a block, so we reset the reason flag to CONSENSUS here.\n-                    state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n-                            state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                    state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n+                            state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 }\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n                                  REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n@@ -1983,7 +1983,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n@@ -1994,7 +1994,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n         txdata.emplace_back(tx);\n@@ -2010,8 +2010,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                     // In the event of a future soft-fork, we may need to\n                     // consider whether rewriting to CONSENSUS or\n                     // RECENT_CONSENSUS_CHANGE would be more appropriate.\n-                    state.DoS(100, ValidationInvalidReason::CONSENSUS, false,\n-                              state.GetRejectCode(), state.GetRejectReason(), state.CorruptionPossible(), state.GetDebugMessage());\n+                    state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n+                              state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 }\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n@@ -2030,13 +2030,13 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS,\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS,\n                          error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0]->GetValueOut(), blockReward),\n                                REJECT_INVALID, \"bad-cb-amount\");\n \n     if (!control.Wait())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3062,7 +3062,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -3084,13 +3084,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3101,14 +3101,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n@@ -3122,7 +3122,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3215,7 +3215,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3224,12 +3224,12 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"time-too-old\", false, \"block's timestamp is too early\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n@@ -3240,7 +3240,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion), false,\n+            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3270,7 +3270,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3280,7 +3280,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3302,11 +3302,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3316,7 +3316,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3328,7 +3328,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3359,10 +3359,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3399,7 +3399,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.DoS(100, ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmRiZGQ3YTQxYmFjNzNlNTFlZDhmN2IyOTBiNzY3MTE5NmJmOWVh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-01-18T02:59:02Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:25:43Z"
      },
      "message": "[refactor] Drop unused state.DoS(), state.GetDoS(), state.CorruptionPossible()\n\nCo-authored-by: Anthony Towns <aj@erisian.com.au>",
      "tree": {
        "sha": "1ceba963fb50fd082a7f3d6e7d094b5517b322b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ceba963fb50fd082a7f3d6e7d094b5517b322b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aa502b88d10c2c3ac56d9163555849b96dc4df1e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa502b88d10c2c3ac56d9163555849b96dc4df1e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aa502b88d10c2c3ac56d9163555849b96dc4df1e"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 2,
      "deletions": 38
    },
    "files": [
      {
        "sha": "ed1b0476142460f0d532b122cc7779ba829cb702",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 38,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
        "patch": "@@ -80,18 +80,9 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE), chRejectCode(0) {}\n-    bool DoS(int level, ValidationInvalidReason reasonIn, bool ret = false,\n-             unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n-             bool corruptionPossibleIn=false,\n-             const std::string &strDebugMessageIn=\"\") {\n-        ret = Invalid(reasonIn, ret, chRejectCodeIn, strRejectReasonIn, strDebugMessageIn);\n-        assert(level == GetDoS());\n-        assert(corruptionPossibleIn == CorruptionPossible());\n-        return ret;\n-    }\n     bool Invalid(ValidationInvalidReason reasonIn, bool ret = false,\n-                 unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n-                 const std::string &strDebugMessageIn=\"\") {\n+            unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n+            const std::string &strDebugMessageIn=\"\") {\n         m_reason = reasonIn;\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n@@ -116,33 +107,6 @@ class CValidationState {\n     bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    bool CorruptionPossible() const {\n-        return m_reason == ValidationInvalidReason::BLOCK_MUTATED || m_reason == ValidationInvalidReason::TX_WITNESS_MUTATED;\n-    }\n-    int GetDoS() const {\n-        switch (m_reason) {\n-        case ValidationInvalidReason::NONE:\n-            return 0;\n-        case ValidationInvalidReason::CONSENSUS:\n-        case ValidationInvalidReason::BLOCK_MUTATED:\n-        case ValidationInvalidReason::BLOCK_INVALID_HEADER:\n-        case ValidationInvalidReason::BLOCK_CHECKPOINT:\n-        case ValidationInvalidReason::BLOCK_INVALID_PREV:\n-            return 100;\n-        case ValidationInvalidReason::BLOCK_MISSING_PREV:\n-            return 10;\n-        case ValidationInvalidReason::CACHED_INVALID:\n-        case ValidationInvalidReason::RECENT_CONSENSUS_CHANGE:\n-        case ValidationInvalidReason::BLOCK_TIME_FUTURE:\n-        case ValidationInvalidReason::TX_NOT_STANDARD:\n-        case ValidationInvalidReason::TX_MISSING_INPUTS:\n-        case ValidationInvalidReason::TX_WITNESS_MUTATED:\n-        case ValidationInvalidReason::TX_CONFLICT:\n-        case ValidationInvalidReason::TX_MEMPOOL_POLICY:\n-            return 0;\n-        }\n-        return 0;\n-    }\n     ValidationInvalidReason GetReason() const { return m_reason; }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }"
      }
    ]
  },
  {
    "sha": "2120c31521aa51aa1984ee33250b8320506d3a0f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMTIwYzMxNTIxYWE1MWFhMTk4NGVlMzMyNTBiODMyMDUwNmQzYTBm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-04-17T14:46:30Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:27:32Z"
      },
      "message": "[refactor] Update some comments in validation.cpp as we arent doing DoS there",
      "tree": {
        "sha": "81946da053c38848280d1cd42cf7b23fbf3a7707",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/81946da053c38848280d1cd42cf7b23fbf3a7707"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2120c31521aa51aa1984ee33250b8320506d3a0f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2120c31521aa51aa1984ee33250b8320506d3a0f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2120c31521aa51aa1984ee33250b8320506d3a0f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2120c31521aa51aa1984ee33250b8320506d3a0f/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/12dbdd7a41bac73e51ed8f7b290b7671196bf9ea"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 14,
      "deletions": 10
    },
    "files": [
      {
        "sha": "a9cf42501159f6e328870e1da1c06cd0906b7bed",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 10,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2120c31521aa51aa1984ee33250b8320506d3a0f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2120c31521aa51aa1984ee33250b8320506d3a0f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2120c31521aa51aa1984ee33250b8320506d3a0f",
        "patch": "@@ -1410,21 +1410,25 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // Check whether the failure was caused by a\n                         // non-mandatory script verification check, such as\n                         // non-standard DER encodings or non-null dummy\n-                        // arguments; if so, don't trigger DoS protection to\n-                        // avoid splitting the network between upgraded and\n-                        // non-upgraded nodes.\n+                        // arguments; if so, ensure we return NOT_STANDARD\n+                        // instead of CONSENSUS to avoid downstream users\n+                        // splitting the network between upgraded and\n+                        // non-upgraded nodes by banning CONSENSUS-failing\n+                        // data providers.\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n                             return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n-                    // Failures of other flags indicate a transaction that is\n-                    // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n-                    // such nodes as they are not following the protocol. That\n-                    // said during an upgrade careful thought should be taken\n-                    // as to the correct behavior - we may want to continue\n-                    // peering with non-upgraded nodes even after soft-fork\n-                    // super-majority signaling has occurred.\n+                    // MANDATORY flag failures correspond to\n+                    // ValidationInvalidReason::CONSENSUS. Because CONSENSUS\n+                    // failures are the most serious case of validation\n+                    // failures, we may need to consider using\n+                    // RECENT_CONSENSUS_CHANGE for any script failure that\n+                    // could be due to non-upgraded nodes which we may want to\n+                    // support, to avoid splitting the network (but this\n+                    // depends on the details of how net_processing handles\n+                    // such errors).\n                     return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "54470e767bab37f9b7089782b1be73d5883bb244",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDQ3MGU3NjdiYWIzN2Y5YjcwODk3ODJiMWJlNzNkNTg4M2JiMjQ0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-02-21T18:46:25Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:29:09Z"
      },
      "message": "Assert validation reasons are contextually correct",
      "tree": {
        "sha": "93593dd9585f122caa07da630ace4931e1ef5d33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/93593dd9585f122caa07da630ace4931e1ef5d33"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54470e767bab37f9b7089782b1be73d5883bb244",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54470e767bab37f9b7089782b1be73d5883bb244",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54470e767bab37f9b7089782b1be73d5883bb244",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54470e767bab37f9b7089782b1be73d5883bb244/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2120c31521aa51aa1984ee33250b8320506d3a0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2120c31521aa51aa1984ee33250b8320506d3a0f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2120c31521aa51aa1984ee33250b8320506d3a0f"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 32,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3079f3b08cb76bd71fbcdcfb979d0593a6cdbed2",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54470e767bab37f9b7089782b1be73d5883bb244/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54470e767bab37f9b7089782b1be73d5883bb244/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=54470e767bab37f9b7089782b1be73d5883bb244",
        "patch": "@@ -66,6 +66,32 @@ enum class ValidationInvalidReason {\n     TX_MEMPOOL_POLICY,        //!< violated mempool's fee/size/descendant/RBF/etc limits\n };\n \n+inline bool IsTransactionReason(ValidationInvalidReason r)\n+{\n+    return r == ValidationInvalidReason::NONE ||\n+           r == ValidationInvalidReason::CONSENSUS ||\n+           r == ValidationInvalidReason::RECENT_CONSENSUS_CHANGE ||\n+           r == ValidationInvalidReason::TX_NOT_STANDARD ||\n+           r == ValidationInvalidReason::TX_MISSING_INPUTS ||\n+           r == ValidationInvalidReason::TX_WITNESS_MUTATED ||\n+           r == ValidationInvalidReason::TX_CONFLICT ||\n+           r == ValidationInvalidReason::TX_MEMPOOL_POLICY;\n+}\n+\n+inline bool IsBlockReason(ValidationInvalidReason r)\n+{\n+    return r == ValidationInvalidReason::NONE ||\n+           r == ValidationInvalidReason::CONSENSUS ||\n+           r == ValidationInvalidReason::RECENT_CONSENSUS_CHANGE ||\n+           r == ValidationInvalidReason::CACHED_INVALID ||\n+           r == ValidationInvalidReason::BLOCK_INVALID_HEADER ||\n+           r == ValidationInvalidReason::BLOCK_MUTATED ||\n+           r == ValidationInvalidReason::BLOCK_MISSING_PREV ||\n+           r == ValidationInvalidReason::BLOCK_INVALID_PREV ||\n+           r == ValidationInvalidReason::BLOCK_TIME_FUTURE ||\n+           r == ValidationInvalidReason::BLOCK_CHECKPOINT;\n+}\n+\n /** Capture information about block/transaction validation */\n class CValidationState {\n private:"
      },
      {
        "sha": "3319d3211ac2ee4a7e294c0afc59fd7786e1dd05",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54470e767bab37f9b7089782b1be73d5883bb244/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54470e767bab37f9b7089782b1be73d5883bb244/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=54470e767bab37f9b7089782b1be73d5883bb244",
        "patch": "@@ -975,6 +975,7 @@ void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIV\n  */\n static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n {\n+    assert(IsTransactionReason(state.GetReason()));\n     return state.GetReason() == ValidationInvalidReason::CONSENSUS;\n }\n \n@@ -1806,6 +1807,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             // Has inputs but not accepted to mempool\n             // Probably non-standard or insufficient fee\n             LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+            assert(IsTransactionReason(orphan_state.GetReason()));\n             if (!orphanTx.HasWitness() && orphan_state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated.\n@@ -2523,6 +2525,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 recentRejects->insert(tx.GetHash());\n             }\n         } else {\n+            assert(IsTransactionReason(state.GetReason()));\n             if (!tx.HasWitness() && state.GetReason() != ValidationInvalidReason::TX_WITNESS_MUTATED) {\n                 // Do not use rejection cache for witness transactions or\n                 // witness-stripped transactions, as they can have been malleated."
      },
      {
        "sha": "c29bff9d304c0bc43971fa396363edeeb139854a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54470e767bab37f9b7089782b1be73d5883bb244/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54470e767bab37f9b7089782b1be73d5883bb244/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=54470e767bab37f9b7089782b1be73d5883bb244",
        "patch": "@@ -895,6 +895,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n                         state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n             }\n+            assert(IsTransactionReason(state.GetReason()));\n             return false; // state filled in by CheckInputs\n         }\n \n@@ -1970,6 +1971,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                     state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n                             state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 }\n+                assert(IsBlockReason(state.GetReason()));\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n@@ -3507,6 +3509,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n+        assert(IsBlockReason(state.GetReason()));\n         if (state.IsInvalid() && state.GetReason() != ValidationInvalidReason::BLOCK_MUTATED) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n             setDirtyBlockIndex.insert(pindex);"
      }
    ]
  },
  {
    "sha": "0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZmYxYzJhODM4ZGE5ZThkYzdmNzc2MDlhZGM4OTEyNGJiZWEzZTJi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-08T14:55:23Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-02T19:30:58Z"
      },
      "message": "Separate reason for premature spends (coinbase/locktime)",
      "tree": {
        "sha": "884d36c96434932ac1cf3866e48016f49f606b6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/884d36c96434932ac1cf3866e48016f49f606b6a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "54470e767bab37f9b7089782b1be73d5883bb244",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54470e767bab37f9b7089782b1be73d5883bb244",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54470e767bab37f9b7089782b1be73d5883bb244"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 12,
      "deletions": 8
    },
    "files": [
      {
        "sha": "4b93cae8484229d8181bbc5f7ded8f0fc6c861e1",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
        "patch": "@@ -172,7 +172,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "2e23f4b3a4f9487dcef26857e2e7e396a2b4cb32",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
        "patch": "@@ -49,7 +49,8 @@ enum class ValidationInvalidReason {\n     BLOCK_CHECKPOINT,        //!< the block failed to meet one of our checkpoints\n     // Only loose txn:\n     TX_NOT_STANDARD,          //!< didn't meet our local policy rules\n-    TX_MISSING_INPUTS,        //!< a transaction was missing some of its inputs (or its inputs were spent at < coinbase maturity height)\n+    TX_MISSING_INPUTS,        //!< a transaction was missing some of its inputs\n+    TX_PREMATURE_SPEND,       //!< transaction spends a coinbase too early, or violates locktime/sequence locks\n     /**\n      * Transaction might be missing a witness, have a witness prior to SegWit\n      * activation, or witness may have been malleated (which includes\n@@ -72,6 +73,7 @@ inline bool IsTransactionReason(ValidationInvalidReason r)\n            r == ValidationInvalidReason::CONSENSUS ||\n            r == ValidationInvalidReason::RECENT_CONSENSUS_CHANGE ||\n            r == ValidationInvalidReason::TX_NOT_STANDARD ||\n+           r == ValidationInvalidReason::TX_PREMATURE_SPEND ||\n            r == ValidationInvalidReason::TX_MISSING_INPUTS ||\n            r == ValidationInvalidReason::TX_WITNESS_MUTATED ||\n            r == ValidationInvalidReason::TX_CONFLICT ||"
      },
      {
        "sha": "71ebd72b838d5fb5dbaabdea3ada3bcff5eb8a65",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
        "patch": "@@ -1040,6 +1040,7 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n     case ValidationInvalidReason::BLOCK_TIME_FUTURE:\n     case ValidationInvalidReason::TX_NOT_STANDARD:\n     case ValidationInvalidReason::TX_MISSING_INPUTS:\n+    case ValidationInvalidReason::TX_PREMATURE_SPEND:\n     case ValidationInvalidReason::TX_WITNESS_MUTATED:\n     case ValidationInvalidReason::TX_CONFLICT:\n     case ValidationInvalidReason::TX_MEMPOOL_POLICY:"
      },
      {
        "sha": "c394afd82abf7519189258df5f8187d71b08f669",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ff1c2a838da9e8dc7f77609adc89124bbea3e2b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0ff1c2a838da9e8dc7f77609adc89124bbea3e2b",
        "patch": "@@ -596,7 +596,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n@@ -685,7 +685,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -1965,13 +1965,14 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         {\n             CAmount txfee = 0;\n             if (!Consensus::CheckTxInputs(tx, state, view, pindex->nHeight, txfee)) {\n-                if (state.GetReason() == ValidationInvalidReason::TX_MISSING_INPUTS) {\n-                    // CheckTxInputs may return MISSING_INPUTS but we can't return that, as\n-                    // it's not defined for a block, so we reset the reason flag to CONSENSUS here.\n+                if (!IsBlockReason(state.GetReason())) {\n+                    // CheckTxInputs may return MISSING_INPUTS or\n+                    // PREMATURE_SPEND but we can't return that, as it's not\n+                    // defined for a block, so we reset the reason flag to\n+                    // CONSENSUS here.\n                     state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n                             state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n                 }\n-                assert(IsBlockReason(state.GetReason()));\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;"
      }
    ]
  }
]