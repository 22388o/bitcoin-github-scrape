[
  {
    "sha": "f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNmVkNzQ4Y2YwNDVkN2YwZDlhNDllMTVjYzBjMDAwMTYxMGI5MjMx",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-09T04:29:27Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-24T20:30:56Z"
      },
      "message": "Add SegWit support to importmulti with some ProcessImport cleanup",
      "tree": {
        "sha": "efc37d6175ee92a4506dae1a3c7c1f73456512c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efc37d6175ee92a4506dae1a3c7c1f73456512c9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6ed748cf045d7f0d9a49e15cc0c0001610b9231/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a2cac787360e80ec1aeba58b54d03ff81f5d20f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a2cac787360e80ec1aeba58b54d03ff81f5d20f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a2cac787360e80ec1aeba58b54d03ff81f5d20f"
      }
    ],
    "stats": {
      "total": 281,
      "additions": 124,
      "deletions": 157
    },
    "files": [
      {
        "sha": "188c2246f82dc5386ed8c2a4e6639081d2a39ae2",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 118,
        "deletions": 151,
        "changes": 269,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6ed748cf045d7f0d9a49e15cc0c0001610b9231/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6ed748cf045d7f0d9a49e15cc0c0001610b9231/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
        "patch": "@@ -809,29 +809,24 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     try {\n-        bool success = false;\n-\n-        // Required fields.\n+        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n         const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n         }\n+        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n \n         // Optional fields.\n         const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n         const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n-        // Parse the output.\n+        // Generate the script and destination for the scriptPubKey provided\n         CScript script;\n         CTxDestination dest;\n \n@@ -855,35 +850,38 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n \n         // Watchonly and private keys\n         if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n         }\n \n-        // Internal + Label\n+        // Internal addresses should not have a label\n         if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n+        // Force users to provide the witness script in its field rather than redeemscript\n+        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n         }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n-        }\n-\n-        // Process. //\n+        CScript scriptpubkey_script = script;\n+        CTxDestination scriptpubkey_dest = dest;\n+        bool allow_p2wpkh = true;\n \n         // P2SH\n-        if (isP2SH) {\n+        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+            // Check the redeemScript is valid\n+            if (!IsHex(strRedeemScript)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n+            }\n+\n             // Import redeem script.\n             std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n             CScript redeemScript = CScript(vData.begin(), vData.end());\n+            CScriptID redeem_id(redeemScript);\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n+            // Check that the redeemScript and scriptPubKey match\n+            if (GetScriptForDestination(redeem_id) != script) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n             }\n \n             pwallet->MarkDirty();\n@@ -892,103 +890,83 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            CScriptID redeem_id(redeemScript);\n             if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n+            script = redeemScript;\n+            ExtractDestination(script, dest);\n+        }\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        // (P2SH-)P2WSH\n+        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n             }\n \n-            pwallet->MarkDirty();\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+            // Check that the witnessScript and scriptPubKey match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n+            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n-\n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n-\n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n-\n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+            }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n+            script = witness_script;\n+            ExtractDestination(script, dest);\n+            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+        // (P2SH-)P2PK/P2PKH/P2WPKH\n+        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n             }\n-\n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n+            if (keys.size() > 1 || pubKeys.size() > 1) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+            }\n+            CPubKey pubkey;\n+            if (keys.size()) {\n+                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+            }\n+            if (pubKeys.size()) {\n                 const std::string& strPubKey = pubKeys[0].get_str();\n-\n                 if (!IsHex(strPubKey)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n                 }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+                CPubKey pubkey_temp(vData.begin(), vData.end());\n+                if (pubkey.size() && pubkey_temp != pubkey) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n                 }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                pubkey = pubkey_temp;\n+            }\n+            if (pubkey.size() > 0) {\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n                 }\n \n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n+                // Check the key corresponds to the destination given\n+                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n                 }\n \n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+                // This is necessary to force the wallet to import the pubKey\n+                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n                 if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n@@ -999,73 +977,61 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n-\n-                success = true;\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n-\n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n-\n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n-\n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n+        // Import the address\n+        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        pwallet->MarkDirty();\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        }\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // add to address book or update label\n+        if (IsValidDestination(scriptpubkey_dest)) {\n+            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        }\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        // Import private keys.\n+        for (size_t i = 0; i < keys.size(); i++) {\n+            const std::string& strPrivkey = keys[i].get_str();\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+            // Checks.\n+            CKey key = DecodeSecret(strPrivkey);\n \n-                success = true;\n+            if (!key.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n             }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            CPubKey pubKey = key.GetPubKey();\n+            assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->MarkDirty();\n+            CKeyID vchAddress = pubKey.GetID();\n+            pwallet->MarkDirty();\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            if (pwallet->HaveKey(vchAddress)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+            pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n+            if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n+\n+            pwallet->UpdateTimeFirstKey(timestamp);\n         }\n \n         UniValue result = UniValue(UniValue::VOBJ);\n-        result.pushKV(\"success\", UniValue(success));\n+        result.pushKV(\"success\", UniValue(true));\n         return result;\n     } catch (const UniValue& e) {\n         UniValue result = UniValue(UniValue::VOBJ);\n@@ -1118,7 +1084,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             \"                                                              \\\"now\\\" can be specified to bypass scanning, for keys which are known to never have been used, and\\n\"\n             \"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\\n\"\n             \"                                                              creation time of all keys being imported by the importmulti call will be scanned.\\n\"\n-            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n+            \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH or P2SH-P2WSH address/scriptPubKey\\n\"\n+            \"      \\\"witnessscript\\\": \\\"<script>\\\"                           , (string, optional) Allowed only if the scriptPubKey is a P2SH-P2WSH or P2WSH address/scriptPubKey\\n\"\n             \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n             \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n             \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be treated as not incoming payments\\n\""
      },
      {
        "sha": "888e84f7d81f3d417ce474bdd8ff7874c41bf913",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6ed748cf045d7f0d9a49e15cc0c0001610b9231/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6ed748cf045d7f0d9a49e15cc0c0001610b9231/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
        "patch": "@@ -198,7 +198,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n+        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -339,7 +339,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Incompatibility found between watchonly and keys')\n+        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n \n \n         # Address + Public key + !Internal + Wrong pubkey\n@@ -355,7 +355,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -375,7 +375,7 @@ def run_test (self):\n         result = self.nodes[1].importmulti(request)\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -395,7 +395,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -414,7 +414,7 @@ def run_test (self):\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Consistency check failed')\n+        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)"
      }
    ]
  },
  {
    "sha": "353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTNjMDY0NTk2ZmMyZTJjMTQ5OTg3YWMzYjNjMTFiNGM5MGM0ZDVm",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-09T13:18:34Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-24T20:30:57Z"
      },
      "message": "Fix typo in test_framework/blocktools",
      "tree": {
        "sha": "482cdb641f86879e4c08499b1dd7db03885ad760",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/482cdb641f86879e4c08499b1dd7db03885ad760"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/353c064596fc2e2c149987ac3b3c11b4c90c4d5f/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6ed748cf045d7f0d9a49e15cc0c0001610b9231",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6ed748cf045d7f0d9a49e15cc0c0001610b9231"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "81cce1167bae8832aa9bf06311b2d115b91022f3",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353c064596fc2e2c149987ac3b3c11b4c90c4d5f/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353c064596fc2e2c149987ac3b3c11b4c90c4d5f/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
        "patch": "@@ -169,7 +169,7 @@ def get_legacy_sigopcount_tx(tx, accurate=True):\n     return count\n \n def witness_script(use_p2wsh, pubkey):\n-    \"\"\"Create a scriptPubKey for a pay-to-wtiness TxOut.\n+    \"\"\"Create a scriptPubKey for a pay-to-witness TxOut.\n \n     This is either a P2WPKH output for the given pubkey, or a P2WSH output of a\n     1-of-1 multisig for the given pubkey. Returns the hex encoding of the"
      }
    ]
  },
  {
    "sha": "1753d217ead7e2de35b3df6cd6573a1c9a068f84",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNzUzZDIxN2VhZDdlMmRlMzViM2RmNmNkNjU3M2ExYzlhMDY4Zjg0",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-15T06:01:21Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-24T20:30:57Z"
      },
      "message": "Add release notes for importmulti segwit change",
      "tree": {
        "sha": "af86a3f633d4c8e8f13c094ee952b393b89ecf28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af86a3f633d4c8e8f13c094ee952b393b89ecf28"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1753d217ead7e2de35b3df6cd6573a1c9a068f84",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1753d217ead7e2de35b3df6cd6573a1c9a068f84",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1753d217ead7e2de35b3df6cd6573a1c9a068f84",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1753d217ead7e2de35b3df6cd6573a1c9a068f84/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/353c064596fc2e2c149987ac3b3c11b4c90c4d5f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/353c064596fc2e2c149987ac3b3c11b4c90c4d5f"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 6,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dd2c6c7ced57f3dbe6d3dbd6ae554ed5d711c286",
        "filename": "doc/release-notes-14454.md",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1753d217ead7e2de35b3df6cd6573a1c9a068f84/doc/release-notes-14454.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1753d217ead7e2de35b3df6cd6573a1c9a068f84/doc/release-notes-14454.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14454.md?ref=1753d217ead7e2de35b3df6cd6573a1c9a068f84",
        "patch": "@@ -0,0 +1,6 @@\n+Low-level RPC changes\n+----------------------\n+\n+The `importmulti` RPC has been updated to support P2WSH, P2WPKH, P2SH-P2WPKH,\n+P2SH-P2WSH. Each request now accepts an additional `witnessscript` to be used\n+for P2WSH or P2SH-P2WSH."
      }
    ]
  },
  {
    "sha": "201451b1ca3c6db3b13f9491a81db5b120b864bb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDE0NTFiMWNhM2M2ZGIzYjEzZjk0OTFhODFkYjViMTIwYjg2NGJi",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-17T01:51:00Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-24T20:30:57Z"
      },
      "message": "Make getaddressinfo return solvability",
      "tree": {
        "sha": "002f598c2436f44d3f2df652b7722b7f84b937fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/002f598c2436f44d3f2df652b7722b7f84b937fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/201451b1ca3c6db3b13f9491a81db5b120b864bb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201451b1ca3c6db3b13f9491a81db5b120b864bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/201451b1ca3c6db3b13f9491a81db5b120b864bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201451b1ca3c6db3b13f9491a81db5b120b864bb/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1753d217ead7e2de35b3df6cd6573a1c9a068f84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1753d217ead7e2de35b3df6cd6573a1c9a068f84",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1753d217ead7e2de35b3df6cd6573a1c9a068f84"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "fb6a97a1fe52dea8b9705aea908d1e0e8d831726",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201451b1ca3c6db3b13f9491a81db5b120b864bb/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201451b1ca3c6db3b13f9491a81db5b120b864bb/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=201451b1ca3c6db3b13f9491a81db5b120b864bb",
        "patch": "@@ -3538,6 +3538,7 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n             \"  \\\"address\\\" : \\\"address\\\",        (string) The bitcoin address validated\\n\"\n             \"  \\\"scriptPubKey\\\" : \\\"hex\\\",       (string) The hex-encoded scriptPubKey generated by the address\\n\"\n             \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n+            \"  \\\"solvable\\\" : true|false,      (boolean) If the address is solvable by the wallet\\n\"\n             \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n             \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n             \"  \\\"iswitness\\\" : true|false,     (boolean) If the address is a witness address\\n\"\n@@ -3592,6 +3593,7 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n     isminetype mine = IsMine(*pwallet, dest);\n     ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n     ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n+    ret.pushKV(\"solvable\", IsSolvable(*pwallet, scriptPubKey));\n     UniValue detail = DescribeWalletAddress(pwallet, dest);\n     ret.pushKVs(detail);\n     if (pwallet->mapAddressBook.count(dest)) {"
      }
    ]
  },
  {
    "sha": "c11875c5908a17314bb38caa911507dc6401ec49",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMTE4NzVjNTkwOGExNzMxNGJiMzhjYWE5MTE1MDdkYzY0MDFlYzQ5",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-09T05:43:20Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-10-24T20:30:57Z"
      },
      "message": "Add segwit address tests for importmulti",
      "tree": {
        "sha": "d824f86efb9d0f30f81cad9fc5868ef08e05d850",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d824f86efb9d0f30f81cad9fc5868ef08e05d850"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c11875c5908a17314bb38caa911507dc6401ec49",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c11875c5908a17314bb38caa911507dc6401ec49",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c11875c5908a17314bb38caa911507dc6401ec49",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c11875c5908a17314bb38caa911507dc6401ec49/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "201451b1ca3c6db3b13f9491a81db5b120b864bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201451b1ca3c6db3b13f9491a81db5b120b864bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/201451b1ca3c6db3b13f9491a81db5b120b864bb"
      }
    ],
    "stats": {
      "total": 162,
      "additions": 161,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9ba6860306b517de9671f217e20470c4b9fccdc5",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 161,
        "deletions": 1,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c11875c5908a17314bb38caa911507dc6401ec49/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c11875c5908a17314bb38caa911507dc6401ec49/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=c11875c5908a17314bb38caa911507dc6401ec49",
        "patch": "@@ -11,8 +11,14 @@\n     assert_greater_than,\n     assert_raises_rpc_error,\n     bytes_to_hex_str,\n+    hex_str_to_bytes\n )\n-\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    hash160\n+)\n+from test_framework.messages import sha256\n \n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -90,6 +96,19 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n+        # ScriptPubKey + internal + label\n+        self.log.info(\"Should not allow a label to be specified when internal is true\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n+            \"internal\": True,\n+            \"label\": \"Example label\"\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -8)\n+        assert_equal(result[0]['error']['message'], 'Internal addresses should not have a label')\n+\n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n         nonstandardScriptPubKey = address['scriptPubKey'] + bytes_to_hex_str(script.CScript([script.OP_NOP]))\n@@ -458,6 +477,147 @@ def run_test (self):\n                 \"timestamp\": \"\",\n             }])\n \n+        # Import P2WPKH address as watch only\n+        self.log.info(\"Should import a P2WPKH address as watch only\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"timestamp\": \"now\",\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['solvable'], False)\n+\n+        # Import P2WPKH address with public key but no private key\n+        self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"pubkeys\": [ address['pubkey'] ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['solvable'], True)\n+\n+        # Import P2WPKH address with key and check it is spendable\n+        self.log.info(\"Should import a P2WPKH address with key\")\n+        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        assert_equal(address_assert['iswatchonly'], False)\n+        assert_equal(address_assert['ismine'], True)\n+\n+        # P2WSH multisig address without scripts or keys\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].addmultisigaddress(2, [sig_address_1['pubkey'], sig_address_2['pubkey']], \"\", \"bech32\")\n+        self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"timestamp\": \"now\"\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        assert_equal(address_assert['solvable'], False)\n+\n+        # Same P2WSH multisig address as above, but now with witnessscript + private keys\n+        self.log.info(\"Should import a p2wsh with respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"witnessscript\": multi_sig_script['redeemScript'],\n+            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address']) ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        assert_equal(address_assert['solvable'], True)\n+        assert_equal(address_assert['ismine'], True)\n+        assert_equal(address_assert['sigsrequired'], 2)\n+\n+        # P2SH-P2WPKH address with no redeemscript or public or private key\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n+        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n+        pkscript = CScript([OP_0, pubkeyhash])\n+        self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": sig_address_1['address']\n+            },\n+            \"timestamp\": \"now\"\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        assert_equal(address_assert['solvable'], False)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # P2SH-P2WPKH address + redeemscript + public key with no private key\n+        self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": sig_address_1['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"redeemscript\": bytes_to_hex_str(pkscript),\n+            \"pubkeys\": [ sig_address_1['pubkey'] ]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        assert_equal(address_assert['solvable'], True)\n+        assert_equal(address_assert['ismine'], False)\n+\n+        # P2SH-P2WPKH address + redeemscript + private key\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n+        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n+        pkscript = CScript([OP_0, pubkeyhash])\n+        self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": sig_address_1['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"redeemscript\": bytes_to_hex_str(pkscript),\n+            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address'])]\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        assert_equal(address_assert['solvable'], True)\n+        assert_equal(address_assert['ismine'], True)\n+\n+        # P2SH-P2WSH 1-of-1 multisig + redeemscript with no private key\n+        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        multi_sig_script = self.nodes[0].addmultisigaddress(1, [sig_address_1['pubkey']], \"\", \"p2sh-segwit\")\n+        scripthash = sha256(hex_str_to_bytes(multi_sig_script['redeemScript']))\n+        redeem_script = CScript([OP_0, scripthash])\n+        self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": multi_sig_script['address']\n+            },\n+            \"timestamp\": \"now\",\n+            \"redeemscript\": bytes_to_hex_str(redeem_script),\n+            \"witnessscript\": multi_sig_script['redeemScript']\n+        }])\n+        assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        assert_equal(address_assert['solvable'], True)\n \n if __name__ == '__main__':\n     ImportMultiTest ().main ()"
      }
    ]
  }
]