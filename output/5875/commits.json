[
  {
    "sha": "9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmUwZTY4MzdiODc4ZjcyYmQwODdjZTMyYjdhMmYyZmZiMmZkNTQ0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-09T17:21:11Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-06-02T17:54:29Z"
      },
      "message": "Be stricter in processing unrequested blocks\n\nAcceptBlock will no longer process an unrequested block, unless it has not\nbeen previously processed and has more work than chainActive.Tip()",
      "tree": {
        "sha": "7c1a9a8c887697e3f87a107ea27448da66abc251",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7c1a9a8c887697e3f87a107ea27448da66abc251"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f00b62391b9317bf4c83676520fede1fb4027c43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f00b62391b9317bf4c83676520fede1fb4027c43",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f00b62391b9317bf4c83676520fede1fb4027c43"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 33,
      "deletions": 22
    },
    "files": [
      {
        "sha": "760cda5dee60753b4b92bcbdce62ad5d117e8717",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 15,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "patch": "@@ -296,7 +296,8 @@ void FinalizeNode(NodeId nodeid) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsReceived(const uint256& hash) {\n+// Returns a bool indicating whether we requested this block.\n+bool MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n@@ -306,7 +307,9 @@ void MarkBlockAsReceived(const uint256& hash) {\n         state->nBlocksInFlight--;\n         state->nStallingSince = 0;\n         mapBlocksInFlight.erase(itInFlight);\n+        return true;\n     }\n+    return false;\n }\n \n // Requires cs_main.\n@@ -2826,7 +2829,7 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n     return true;\n }\n \n-bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex, CDiskBlockPos* dbp)\n+bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex, bool fRequested, CDiskBlockPos* dbp)\n {\n     const CChainParams& chainparams = Params();\n     AssertLockHeld(cs_main);\n@@ -2836,13 +2839,18 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     if (!AcceptBlockHeader(block, state, &pindex))\n         return false;\n \n-    // If we're pruning, ensure that we don't allow a peer to dump a copy\n-    // of old blocks.  But we might need blocks that are not on the main chain\n-    // to handle a reorg, even if we've processed once.\n-    if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n-        // TODO: deal better with duplicate blocks.\n-        // return state.DoS(20, error(\"AcceptBlock(): already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n-        return true;\n+    // Try to process all requested blocks that we don't have, but only\n+    // process an unrequested block if it's new and has enough work to\n+    // advance our tip.\n+    bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n+    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);\n+\n+    // TODO: deal better with return value and error conditions for duplicate\n+    // and unrequested blocks.\n+    if (fAlreadyHave) return true;\n+    if (!fRequested) {  // If we didn't ask for it:\n+        if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n+        if (!fHasMoreWork) return true;     // Don't process less-work chains\n     }\n \n     if ((!CheckBlock(block, state)) || !ContextualCheckBlock(block, state, pindex->pprev)) {\n@@ -2891,21 +2899,22 @@ static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned\n }\n \n \n-bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n+bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, bool fForceProcessing, CDiskBlockPos *dbp)\n {\n     // Preliminary checks\n     bool checked = CheckBlock(*pblock, state);\n \n     {\n         LOCK(cs_main);\n-        MarkBlockAsReceived(pblock->GetHash());\n+        bool fRequested = MarkBlockAsReceived(pblock->GetHash());\n+        fRequested |= fForceProcessing;\n         if (!checked) {\n             return error(\"%s: CheckBlock FAILED\", __func__);\n         }\n \n         // Store to disk\n         CBlockIndex *pindex = NULL;\n-        bool ret = AcceptBlock(*pblock, state, &pindex, dbp);\n+        bool ret = AcceptBlock(*pblock, state, &pindex, fRequested, dbp);\n         if (pindex && pfrom) {\n             mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n         }\n@@ -3453,7 +3462,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                 // process in case the block isn't known yet\n                 if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n                     CValidationState state;\n-                    if (ProcessNewBlock(state, NULL, &block, dbp))\n+                    if (ProcessNewBlock(state, NULL, &block, true, dbp))\n                         nLoaded++;\n                     if (state.IsError())\n                         break;\n@@ -3475,7 +3484,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                             LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n                                     head.ToString());\n                             CValidationState dummy;\n-                            if (ProcessNewBlock(dummy, NULL, &block, &it->second))\n+                            if (ProcessNewBlock(dummy, NULL, &block, true, &it->second))\n                             {\n                                 nLoaded++;\n                                 queue.push_back(block.GetHash());\n@@ -4462,7 +4471,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         pfrom->AddInventoryKnown(inv);\n \n         CValidationState state;\n-        ProcessNewBlock(state, pfrom, &block);\n+        // Process all blocks from whitelisted peers, even if not requested.\n+        ProcessNewBlock(state, pfrom, &block, pfrom->fWhitelisted, NULL);\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),"
      },
      {
        "sha": "669ea7128a7dc26ba1bc54dddd1bf73aad21a3d2",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "patch": "@@ -153,10 +153,11 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n  * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface (see validationinterface.h) - this will have its BlockChecked method called whenever *any* block completes validation.\n  * @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n  * @param[in]   pblock  The block we want to process.\n+ * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n  * @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its location.\n  * @return True if state.IsValid()\n  */\n-bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n+bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, bool fForceProcessing, CDiskBlockPos *dbp);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n@@ -400,8 +401,8 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n /** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */\n bool TestBlockValidity(CValidationState &state, const CBlock& block, CBlockIndex *pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n-/** Store block on disk. If dbp is provided, the file is known to already reside on disk */\n-bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n+/** Store block on disk. If dbp is non-NULL, the file is known to already reside on disk */\n+bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, bool fRequested, CDiskBlockPos* dbp);\n bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n \n "
      },
      {
        "sha": "f5919ca3af8938a4d9a49d51a3205b8c7bcc9546",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "patch": "@@ -434,7 +434,7 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n \n     // Process this block the same as if we had received it from another node\n     CValidationState state;\n-    if (!ProcessNewBlock(state, NULL, pblock))\n+    if (!ProcessNewBlock(state, NULL, pblock, true, NULL))\n         return error(\"BitcoinMiner: ProcessNewBlock, block not accepted\");\n \n     return true;"
      },
      {
        "sha": "528d5406f48e16d7769c4206e90beeec7b876108",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "patch": "@@ -164,7 +164,7 @@ Value generate(const Array& params, bool fHelp)\n             ++pblock->nNonce;\n         }\n         CValidationState state;\n-        if (!ProcessNewBlock(state, NULL, pblock))\n+        if (!ProcessNewBlock(state, NULL, pblock, true, NULL))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -650,7 +650,7 @@ Value submitblock(const Array& params, bool fHelp)\n     CValidationState state;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(state, NULL, &block);\n+    bool fAccepted = ProcessNewBlock(state, NULL, &block, true, NULL);\n     UnregisterValidationInterface(&sc);\n     if (fBlockPresent)\n     {"
      },
      {
        "sha": "9e4fd8513ea07517bc806e5c3a2185830e3b9b90",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "patch": "@@ -84,7 +84,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n-        BOOST_CHECK(ProcessNewBlock(state, NULL, pblock));\n+        BOOST_CHECK(ProcessNewBlock(state, NULL, pblock, true, NULL));\n         BOOST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }"
      }
    ]
  },
  {
    "sha": "aa8c827968a68a3adc4df5f126635e37a71a7fbb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYThjODI3OTY4YTY4YTNhZGM0ZGY1ZjEyNjYzNWUzN2E3MWE3ZmJi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-04T14:50:24Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-06-02T18:01:35Z"
      },
      "message": "P2P regression test for new AcceptBlock behavior",
      "tree": {
        "sha": "cfd7eb60b354cb6910be24ff28860f7eea90cb18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cfd7eb60b354cb6910be24ff28860f7eea90cb18"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa8c827968a68a3adc4df5f126635e37a71a7fbb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa8c827968a68a3adc4df5f126635e37a71a7fbb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aa8c827968a68a3adc4df5f126635e37a71a7fbb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa8c827968a68a3adc4df5f126635e37a71a7fbb/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9be0e6837b878f72bd087ce32b7a2f2ffb2fd544"
      }
    ],
    "stats": {
      "total": 227,
      "additions": 227,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9b318650e939451b580691bf98cf6ecb0c9cfe72",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa8c827968a68a3adc4df5f126635e37a71a7fbb/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa8c827968a68a3adc4df5f126635e37a71a7fbb/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=aa8c827968a68a3adc4df5f126635e37a71a7fbb",
        "patch": "@@ -51,6 +51,7 @@ testScriptsExt=(\n     'invalidblockrequest.py'\n     'rawtransactions.py'\n #    'forknotify.py'\n+    'p2p-acceptblock.py'\n );\n \n extArg=\"-extended\""
      },
      {
        "sha": "fcdd1e1b99c88cdf535e2843b7e426f510f4d7b0",
        "filename": "qa/rpc-tests/p2p-acceptblock.py",
        "status": "added",
        "additions": 226,
        "deletions": 0,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa8c827968a68a3adc4df5f126635e37a71a7fbb/qa/rpc-tests/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa8c827968a68a3adc4df5f126635e37a71a7fbb/qa/rpc-tests/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-acceptblock.py?ref=aa8c827968a68a3adc4df5f126635e37a71a7fbb",
        "patch": "@@ -0,0 +1,226 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+AcceptBlockTest -- test processing of unrequested blocks.\n+\n+Since behavior differs when receiving unrequested blocks from whitelisted peers\n+versus non-whitelisted peers, this tests the behavior of both (effectively two\n+separate tests running in parallel).\n+\n+Setup: two nodes, node0 and node1, not connected to each other.  Node0 does not\n+whitelist localhost, but node1 does. They will each be on their own chain for\n+this test.\n+\n+We have one NodeConn connection to each, test_node and white_node respectively.\n+\n+The test:\n+1. Generate one block on each node, to leave IBD.\n+\n+2. Mine a new block on each tip, and deliver to each node from node's peer.\n+   The tip should advance.\n+\n+3. Mine a block that forks the previous block, and deliver to each node from\n+   corresponding peer.\n+   Node0 should not process this block (just accept the header), because it is\n+   unrequested and doesn't have more work than the tip.\n+   Node1 should process because this is coming from a whitelisted peer.\n+\n+4. Send another block that builds on the forking block.\n+   Node0 should process this block but be stuck on the shorter chain, because\n+   it's missing an intermediate block.\n+   Node1 should reorg to this longer chain.\n+\n+5. Send a duplicate of the block in #3 to Node0.\n+   Node0 should not process the block because it is unrequested, and stay on\n+   the shorter chain.\n+\n+6. Send Node0 an inv for the height 3 block produced in #4 above.\n+   Node0 should figure out that Node0 has the missing height 2 block and send a\n+   getdata.\n+\n+7. Send Node0 the missing block again.\n+   Node0 should process and the tip should advance.\n+'''\n+\n+# TestNode: bare-bones \"peer\".  Used mostly as a conduit for a test to sending\n+# p2p messages to a node, generating the messages in the main testing logic.\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.connection = None\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Track the last getdata message we receive (used in the test)\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    # Spin until verack message is received from the node.\n+    # We use this to signal that our test can begin. This\n+    # is called from the testing thread, so it needs to acquire\n+    # the global lock.\n+    def wait_for_verack(self):\n+        while True:\n+            with mininode_lock:\n+                if self.verack_received:\n+                    return\n+            time.sleep(0.05)\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+class AcceptBlockTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n+                          help=\"bitcoind binary to test\")\n+\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 2)\n+\n+    def setup_network(self):\n+        # Node0 will be used to test behavior of processing unrequested blocks\n+        # from peers which are not whitelisted, while Node1 will be used for\n+        # the whitelisted case.\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"],\n+                                     binary=self.options.testbinary))\n+        self.nodes.append(start_node(1, self.options.tmpdir,\n+                                     [\"-debug\", \"-whitelist=127.0.0.1\"],\n+                                     binary=self.options.testbinary))\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        test_node = TestNode()   # connects to node0 (not whitelisted)\n+        white_node = TestNode()  # connects to node1 (whitelisted)\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], white_node))\n+        test_node.add_connection(connections[0])\n+        white_node.add_connection(connections[1])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        # Test logic begins here\n+        test_node.wait_for_verack()\n+        white_node.wait_for_verack()\n+\n+        # 1. Have both nodes mine a block (leave IBD)\n+        [ n.generate(1) for n in self.nodes ]\n+        tips = [ int (\"0x\" + n.getbestblockhash() + \"L\", 0) for n in self.nodes ]\n+\n+        # 2. Send one block that builds on each tip.\n+        # This should be accepted.\n+        blocks_h2 = []  # the height 2 blocks on each node's chain\n+        for i in xrange(2):\n+            blocks_h2.append(create_block(tips[i], create_coinbase(), time.time()+1))\n+            blocks_h2[i].solve()\n+        test_node.send_message(msg_block(blocks_h2[0]))\n+        white_node.send_message(msg_block(blocks_h2[1]))\n+\n+        time.sleep(1)\n+        assert_equal(self.nodes[0].getblockcount(), 2)\n+        assert_equal(self.nodes[1].getblockcount(), 2)\n+        print \"First height 2 block accepted by both nodes\"\n+\n+        # 3. Send another block that builds on the original tip.\n+        blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n+        for i in xrange(2):\n+            blocks_h2f.append(create_block(tips[i], create_coinbase(), blocks_h2[i].nTime+1))\n+            blocks_h2f[i].solve()\n+        test_node.send_message(msg_block(blocks_h2f[0]))\n+        white_node.send_message(msg_block(blocks_h2f[1]))\n+\n+        time.sleep(1)  # Give time to process the block\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == blocks_h2f[0].hash:\n+                assert_equal(x['status'], \"headers-only\")\n+\n+        for x in self.nodes[1].getchaintips():\n+            if x['hash'] == blocks_h2f[1].hash:\n+                assert_equal(x['status'], \"valid-headers\")\n+\n+        print \"Second height 2 block accepted only from whitelisted peer\"\n+\n+        # 4. Now send another block that builds on the forking chain.\n+        blocks_h3 = []\n+        for i in xrange(2):\n+            blocks_h3.append(create_block(blocks_h2f[i].sha256, create_coinbase(), blocks_h2f[i].nTime+1))\n+            blocks_h3[i].solve()\n+        test_node.send_message(msg_block(blocks_h3[0]))\n+        white_node.send_message(msg_block(blocks_h3[1]))\n+\n+        time.sleep(1)\n+        # Since the earlier block was not processed by node0, the new block\n+        # can't be fully validated.\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == blocks_h3[0].hash:\n+                assert_equal(x['status'], \"headers-only\")\n+\n+        # But this block should be accepted by node0 since it has more work.\n+        try:\n+            self.nodes[0].getblock(blocks_h3[0].hash)\n+            print \"Unrequested more-work block accepted from non-whitelisted peer\"\n+        except:\n+            raise AssertionError(\"Unrequested more work block was not processed\")\n+\n+        # Node1 should have accepted and reorged.\n+        assert_equal(self.nodes[1].getblockcount(), 3)\n+        print \"Successfully reorged to length 3 chain from whitelisted peer\"\n+\n+        # 5. Test handling of unrequested block on the node that didn't process\n+        # Should still not be processed (even though it has a child that has more\n+        # work).\n+        test_node.send_message(msg_block(blocks_h2f[0]))\n+\n+        # Here, if the sleep is too short, the test could falsely succeed (if the\n+        # node hasn't processed the block by the time the sleep returns, and then\n+        # the node processes it and incorrectly advances the tip).\n+        # But this would be caught later on, when we verify that an inv triggers\n+        # a getdata request for this block.\n+        time.sleep(1)\n+        assert_equal(self.nodes[0].getblockcount(), 2)\n+        print \"Unrequested block that would complete more-work chain was ignored\"\n+\n+        # 6. Try to get node to request the missing block.\n+        # Poke the node with an inv for block at height 3 and see if that\n+        # triggers a getdata on block 2 (it should if block 2 is missing).\n+        with mininode_lock:\n+            # Clear state so we can check the getdata request\n+            test_node.last_getdata = None\n+            test_node.send_message(msg_inv([CInv(2, blocks_h3[0].sha256)]))\n+\n+        time.sleep(1)\n+        with mininode_lock:\n+            getdata = test_node.last_getdata\n+\n+        # Check that the getdata is for the right block\n+        assert_equal(len(getdata.inv), 1)\n+        assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)\n+        print \"Inv at tip triggered getdata for unprocessed block\"\n+\n+        # 7. Send the missing block for the third time (now it is requested)\n+        test_node.send_message(msg_block(blocks_h2f[0]))\n+\n+        time.sleep(1)\n+        assert_equal(self.nodes[0].getblockcount(), 3)\n+        print \"Successfully reorged to length 3 chain from non-whitelisted peer\"\n+\n+        [ c.disconnect_node() for c in connections ]\n+\n+if __name__ == '__main__':\n+    AcceptBlockTest().main()"
      }
    ]
  }
]