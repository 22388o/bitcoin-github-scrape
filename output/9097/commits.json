[
  {
    "sha": "fac1141600e15216aea96da5ec0c257d89fcaa00",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWMxMTQxNjAwZTE1MjE2YWVhOTZkYTVlYzBjMjU3ZDg5ZmNhYTAw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-11-07T18:24:32Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-11-07T18:23:33Z"
      },
      "message": "[qa] preciousblock: Use assert_equal and BitcoinTestFramework.__init__",
      "tree": {
        "sha": "9a42d2e161614fffc09b397626c92b6ff428c467",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a42d2e161614fffc09b397626c92b6ff428c467"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac1141600e15216aea96da5ec0c257d89fcaa00",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac1141600e15216aea96da5ec0c257d89fcaa00",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fac1141600e15216aea96da5ec0c257d89fcaa00",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac1141600e15216aea96da5ec0c257d89fcaa00/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1253f8692fc3a11be9430685cd405236a68df6c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1253f8692fc3a11be9430685cd405236a68df6c3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1253f8692fc3a11be9430685cd405236a68df6c3"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 34,
      "deletions": 31
    },
    "files": [
      {
        "sha": "3cefa51c0a7f046272042adfe13dfd98f3c2bf1b",
        "filename": "qa/rpc-tests/preciousblock.py",
        "status": "modified",
        "additions": 34,
        "deletions": 31,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac1141600e15216aea96da5ec0c257d89fcaa00/qa/rpc-tests/preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac1141600e15216aea96da5ec0c257d89fcaa00/qa/rpc-tests/preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/preciousblock.py?ref=fac1141600e15216aea96da5ec0c257d89fcaa00",
        "patch": "@@ -8,7 +8,12 @@\n #\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes_bi,\n+    sync_chain,\n+    sync_blocks,\n+)\n \n def unidirectional_node_sync_via_rpc(node_src, node_dest):\n     blocks_to_copy = []\n@@ -33,84 +38,82 @@ def node_sync_via_rpc(nodes):\n             unidirectional_node_sync_via_rpc(node_src, node_dest)\n \n class PreciousTest(BitcoinTestFramework):\n-    def setup_chain(self):\n-        print(\"Initializing test directory \"+self.options.tmpdir)\n-        initialize_chain_clean(self.options.tmpdir, 3)\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        self.extra_args = [[\"-debug\"]] * self.num_nodes\n \n     def setup_network(self):\n-        self.nodes = []\n-        self.is_network_split = False\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes = self.setup_nodes()\n \n     def run_test(self):\n         print(\"Ensure submitblock can in principle reorg to a competing chain\")\n         self.nodes[0].generate(1)\n-        assert(self.nodes[0].getblockcount() == 1)\n+        assert_equal(self.nodes[0].getblockcount(), 1)\n         (hashY, hashZ) = self.nodes[1].generate(2)\n-        assert(self.nodes[1].getblockcount() == 2)\n+        assert_equal(self.nodes[1].getblockcount(), 2)\n         node_sync_via_rpc(self.nodes[0:3])\n-        assert(self.nodes[0].getbestblockhash() == hashZ)\n+        assert_equal(self.nodes[0].getbestblockhash(), hashZ)\n \n         print(\"Mine blocks A-B-C on Node 0\")\n         (hashA, hashB, hashC) = self.nodes[0].generate(3)\n-        assert(self.nodes[0].getblockcount() == 5)\n+        assert_equal(self.nodes[0].getblockcount(), 5)\n         print(\"Mine competing blocks E-F-G on Node 1\")\n         (hashE, hashF, hashG) = self.nodes[1].generate(3)\n-        assert(self.nodes[1].getblockcount() == 5)\n+        assert_equal(self.nodes[1].getblockcount(), 5)\n         assert(hashC != hashG)\n         print(\"Connect nodes and check no reorg occurs\")\n         # Submit competing blocks via RPC so any reorg should occur before we proceed (no way to wait on inaction for p2p sync)\n         node_sync_via_rpc(self.nodes[0:2])\n         connect_nodes_bi(self.nodes,0,1)\n-        assert(self.nodes[0].getbestblockhash() == hashC)\n-        assert(self.nodes[1].getbestblockhash() == hashG)\n+        assert_equal(self.nodes[0].getbestblockhash(), hashC)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashG)\n         print(\"Make Node0 prefer block G\")\n         self.nodes[0].preciousblock(hashG)\n-        assert(self.nodes[0].getbestblockhash() == hashG)\n+        assert_equal(self.nodes[0].getbestblockhash(), hashG)\n         print(\"Make Node0 prefer block C again\")\n         self.nodes[0].preciousblock(hashC)\n-        assert(self.nodes[0].getbestblockhash() == hashC)\n+        assert_equal(self.nodes[0].getbestblockhash(), hashC)\n         print(\"Make Node1 prefer block C\")\n         self.nodes[1].preciousblock(hashC)\n         sync_chain(self.nodes[0:2]) # wait because node 1 may not have downloaded hashC\n-        assert(self.nodes[1].getbestblockhash() == hashC)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashC)\n         print(\"Make Node1 prefer block G again\")\n         self.nodes[1].preciousblock(hashG)\n-        assert(self.nodes[1].getbestblockhash() == hashG)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashG)\n         print(\"Make Node0 prefer block G again\")\n         self.nodes[0].preciousblock(hashG)\n-        assert(self.nodes[0].getbestblockhash() == hashG)\n+        assert_equal(self.nodes[0].getbestblockhash(), hashG)\n         print(\"Make Node1 prefer block C again\")\n         self.nodes[1].preciousblock(hashC)\n-        assert(self.nodes[1].getbestblockhash() == hashC)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashC)\n         print(\"Mine another block (E-F-G-)H on Node 0 and reorg Node 1\")\n         self.nodes[0].generate(1)\n-        assert(self.nodes[0].getblockcount() == 6)\n+        assert_equal(self.nodes[0].getblockcount(), 6)\n         sync_blocks(self.nodes[0:2])\n         hashH = self.nodes[0].getbestblockhash()\n-        assert(self.nodes[1].getbestblockhash() == hashH)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         print(\"Node1 should not be able to prefer block C anymore\")\n         self.nodes[1].preciousblock(hashC)\n-        assert(self.nodes[1].getbestblockhash() == hashH)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         print(\"Mine competing blocks I-J-K-L on Node 2\")\n         self.nodes[2].generate(4)\n-        assert(self.nodes[2].getblockcount() == 6)\n+        assert_equal(self.nodes[2].getblockcount(), 6)\n         hashL = self.nodes[2].getbestblockhash()\n         print(\"Connect nodes and check no reorg occurs\")\n         node_sync_via_rpc(self.nodes[0:3])\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n-        assert(self.nodes[0].getbestblockhash() == hashH)\n-        assert(self.nodes[1].getbestblockhash() == hashH)\n-        assert(self.nodes[2].getbestblockhash() == hashL)\n+        assert_equal(self.nodes[0].getbestblockhash(), hashH)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashH)\n+        assert_equal(self.nodes[2].getbestblockhash(), hashL)\n         print(\"Make Node1 prefer block L\")\n         self.nodes[1].preciousblock(hashL)\n-        assert(self.nodes[1].getbestblockhash() == hashL)\n+        assert_equal(self.nodes[1].getbestblockhash(), hashL)\n         print(\"Make Node2 prefer block H\")\n         self.nodes[2].preciousblock(hashH)\n-        assert(self.nodes[2].getbestblockhash() == hashH)\n+        assert_equal(self.nodes[2].getbestblockhash(), hashH)\n \n if __name__ == '__main__':\n     PreciousTest().main()"
      }
    ]
  },
  {
    "sha": "fa97ccb06d59f56d215004ee1aa7dd786fae9d6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTk3Y2NiMDZkNTlmNTZkMjE1MDA0ZWUxYWE3ZGQ3ODZmYWU5ZDZk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-11-07T18:52:41Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-11-07T19:42:21Z"
      },
      "message": "[qa] util: Rework sync_*()\n\n* Only allow named args in sync_*()\n* Make sync_* fails more verbose\n* Add timeout to sync_chain()",
      "tree": {
        "sha": "b5d914579f867636b604ce8ca99909e80cd872c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5d914579f867636b604ce8ca99909e80cd872c1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fac1141600e15216aea96da5ec0c257d89fcaa00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac1141600e15216aea96da5ec0c257d89fcaa00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fac1141600e15216aea96da5ec0c257d89fcaa00"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 20,
      "deletions": 18
    },
    "files": [
      {
        "sha": "74a74f679a85d8ae40e9066137fe4ad900b1e435",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=fa97ccb06d59f56d215004ee1aa7dd786fae9d6d",
        "patch": "@@ -225,9 +225,9 @@ def transact_and_mine(self, numblocks, mining_node):\n                                                       self.memutxo, Decimal(\"0.005\"), min_fee, min_fee)\n                 tx_kbytes = (len(txhex) // 2) / 1000.0\n                 self.fees_per_kb.append(float(fee)/tx_kbytes)\n-            sync_mempools(self.nodes[0:3],.1)\n+            sync_mempools(self.nodes[0:3], wait=.1)\n             mined = mining_node.getblock(mining_node.generate(1)[0],True)[\"tx\"]\n-            sync_blocks(self.nodes[0:3],.1)\n+            sync_blocks(self.nodes[0:3], wait=.1)\n             # update which txouts are confirmed\n             newmem = []\n             for utx in self.memutxo:\n@@ -259,7 +259,7 @@ def run_test(self):\n         while len(self.nodes[1].getrawmempool()) > 0:\n             self.nodes[1].generate(1)\n \n-        sync_blocks(self.nodes[0:3],.1)\n+        sync_blocks(self.nodes[0:3], wait=.1)\n         print(\"Final estimates after emptying mempools\")\n         check_estimates(self.nodes[1], self.fees_per_kb, 2)\n "
      },
      {
        "sha": "b5ef0689b47a16f75a6172ef0bc5a331538c46ec",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 17,
        "deletions": 15,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa97ccb06d59f56d215004ee1aa7dd786fae9d6d/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=fa97ccb06d59f56d215004ee1aa7dd786fae9d6d",
        "patch": "@@ -121,33 +121,35 @@ def hex_str_to_bytes(hex_str):\n def str_to_b64str(string):\n     return b64encode(string.encode('utf-8')).decode('ascii')\n \n-def sync_blocks(rpc_connections, wait=1, timeout=60):\n+def sync_blocks(rpc_connections, *, wait=1, timeout=60):\n     \"\"\"\n     Wait until everybody has the same tip\n     \"\"\"\n     maxheight = 0\n     while timeout > 0:\n-        tips = [ x.waitforblockheight(maxheight, int(wait * 1000)) for x in rpc_connections ]\n-        heights = [ x[\"height\"] for x in tips ]\n-        if tips == [ tips[0] ]*len(tips):\n-            return True\n-        if heights == [ heights[0] ]*len(heights): #heights are the same but hashes are not\n-            raise AssertionError(\"Block sync failed\")\n+        tips = [r.waitforblockheight(maxheight, int(wait * 1000)) for r in rpc_connections]\n+        heights = [t[\"height\"] for t in tips]\n+        if tips == [tips[0]] * len(tips):\n+            return\n+        if heights == [heights[0]] * len(heights):\n+            raise AssertionError(\"Block sync failed: (Hashes don't match)\")\n         timeout -= wait\n         maxheight = max(heights)\n-    raise AssertionError(\"Block sync failed\")\n+    raise AssertionError(\"Block sync failed with heights: {}\".format(heights))\n \n-def sync_chain(rpc_connections, wait=1):\n+def sync_chain(rpc_connections, *, wait=1, timeout=60):\n     \"\"\"\n     Wait until everybody has the same best block\n     \"\"\"\n-    while True:\n-        counts = [ x.getbestblockhash() for x in rpc_connections ]\n-        if counts == [ counts[0] ]*len(counts):\n-            break\n+    while timeout > 0:\n+        best_hash = [x.getbestblockhash() for x in rpc_connections]\n+        if best_hash == [best_hash[0]]*len(best_hash):\n+            return\n         time.sleep(wait)\n+        timeout -= wait\n+    raise AssertionError(\"Chain sync failed: Best block hashes don't match\")\n \n-def sync_mempools(rpc_connections, wait=1, timeout=60):\n+def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n     \"\"\"\n     Wait until everybody has the same transactions in their memory\n     pools\n@@ -159,7 +161,7 @@ def sync_mempools(rpc_connections, wait=1, timeout=60):\n             if set(rpc_connections[i].getrawmempool()) == pool:\n                 num_match = num_match+1\n         if num_match == len(rpc_connections):\n-            return True\n+            return\n         time.sleep(wait)\n         timeout -= wait\n     raise AssertionError(\"Mempool sync failed\")"
      }
    ]
  }
]