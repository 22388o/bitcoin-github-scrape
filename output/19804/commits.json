[
  {
    "sha": "784f757994c1306bb6584b14c0c78617d6248432",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODRmNzU3OTk0YzEzMDZiYjY1ODRiMTRjMGM3ODYxN2Q2MjQ4NDMy",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-04T01:05:26Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-10T14:37:14Z"
      },
      "message": "[refactor] clarify tests by referencing p2p objects directly\n\nUse object returned from add_p2p_connection to refer to\np2ps. Add a test class attribute if it needs to be used across\nmany methods. Don't use the p2p property.",
      "tree": {
        "sha": "a884db60889e652e08236f668585d24aca65a3a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a884db60889e652e08236f668585d24aca65a3a6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/784f757994c1306bb6584b14c0c78617d6248432",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/784f757994c1306bb6584b14c0c78617d6248432",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/784f757994c1306bb6584b14c0c78617d6248432",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/784f757994c1306bb6584b14c0c78617d6248432/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2"
      }
    ],
    "stats": {
      "total": 146,
      "additions": 73,
      "deletions": 73
    },
    "files": [
      {
        "sha": "3b9bd3048f671eaac752dd471865c4532534e8be",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -136,7 +136,7 @@ def run_test(self):\n         \"\"\"Main test logic\"\"\"\n \n         # Create P2P connections will wait for a verack to make sure the connection is fully up\n-        self.nodes[0].add_p2p_connection(BaseNode())\n+        peer_messaging = self.nodes[0].add_p2p_connection(BaseNode())\n \n         # Generating a block on one of the nodes will get us out of IBD\n         blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n@@ -173,7 +173,7 @@ def run_test(self):\n             block.solve()\n             block_message = msg_block(block)\n             # Send message is used to send a P2P message to the node over our P2PInterface\n-            self.nodes[0].p2p.send_message(block_message)\n+            peer_messaging.send_message(block_message)\n             self.tip = block.sha256\n             blocks.append(self.tip)\n             self.block_time += 1\n@@ -191,25 +191,25 @@ def run_test(self):\n         self.log.info(\"Add P2P connection to node2\")\n         self.nodes[0].disconnect_p2ps()\n \n-        self.nodes[2].add_p2p_connection(BaseNode())\n+        peer_receiving = self.nodes[2].add_p2p_connection(BaseNode())\n \n         self.log.info(\"Test that node2 propagates all the blocks to us\")\n \n         getdata_request = msg_getdata()\n         for block in blocks:\n             getdata_request.inv.append(CInv(MSG_BLOCK, block))\n-        self.nodes[2].p2p.send_message(getdata_request)\n+        peer_receiving.send_message(getdata_request)\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n         # P2PInterface objects.\n-        self.nodes[2].p2p.wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5)\n+        peer_receiving.wait_until(lambda: sorted(blocks) == sorted(list(peer_receiving.block_receive_map.keys())), timeout=5)\n \n         self.log.info(\"Check that each block was received only once\")\n         # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving\n         # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking\n         # and synchronization issues. Note p2p.wait_until() acquires this global lock internally when testing the predicate.\n         with p2p_lock:\n-            for block in self.nodes[2].p2p.block_receive_map.values():\n+            for block in peer_receiving.block_receive_map.values():\n                 assert_equal(block, 1)\n \n "
      },
      {
        "sha": "19753d73ef34e14454286a814be2a628447f05a6",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -1386,14 +1386,14 @@ def bootstrap_p2p(self, timeout=10):\n         \"\"\"Add a P2P connection to the node.\n \n         Helper to connect and wait for version handshake.\"\"\"\n-        self.nodes[0].add_p2p_connection(P2PDataStore())\n+        self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore())\n         # We need to wait for the initial getheaders from the peer before we\n         # start populating our blockstore. If we don't, then we may run ahead\n         # to the next subtest before we receive the getheaders. We'd then send\n         # an INV for the next block and receive two getheaders - one for the\n         # IBD and one for the INV. We'd respond to both and could get\n         # unexpectedly disconnected if the DoS score for that error is 50.\n-        self.nodes[0].p2p.wait_for_getheaders(timeout=timeout)\n+        self.helper_peer.wait_for_getheaders(timeout=timeout)\n \n     def reconnect_p2p(self, timeout=60):\n         \"\"\"Tear down and bootstrap the P2P connection to the node.\n@@ -1407,7 +1407,7 @@ def send_blocks(self, blocks, success=True, reject_reason=None, force_send=False\n         \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n \n         Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n-        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_reason=reject_reason, force_send=force_send, timeout=timeout, expect_disconnect=reconnect)\n+        self.helper_peer.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_reason=reject_reason, force_send=force_send, timeout=timeout, expect_disconnect=reconnect)\n \n         if reconnect:\n             self.reconnect_p2p(timeout=timeout)"
      },
      {
        "sha": "aad255c4a9e6a1ca52629c190873dd68673d4afc",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -75,7 +75,7 @@ def test_cltv_info(self, *, is_active):\n         )\n \n     def run_test(self):\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n \n         self.test_cltv_info(is_active=False)\n \n@@ -99,7 +99,7 @@ def run_test(self):\n         block.solve()\n \n         self.test_cltv_info(is_active=False)  # Not active as of current tip and next block does not need to obey rules\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n+        peer.send_and_ping(msg_block(block))\n         self.test_cltv_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n@@ -111,9 +111,9 @@ def run_test(self):\n         block.solve()\n \n         with self.nodes[0].assert_debug_log(expected_msgs=['{}, bad-version(0x00000003)'.format(block.hash)]):\n-            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            peer.send_and_ping(msg_block(block))\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-            self.nodes[0].p2p.sync_with_ping()\n+            peer.sync_with_ping()\n \n         self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n         block.nVersion = 4\n@@ -136,9 +136,9 @@ def run_test(self):\n         block.solve()\n \n         with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputScripts on {} failed with non-mandatory-script-verify-flag (Negative locktime)'.format(block.vtx[-1].hash)]):\n-            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            peer.send_and_ping(msg_block(block))\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-            self.nodes[0].p2p.sync_with_ping()\n+            peer.sync_with_ping()\n \n         self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n         spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)\n@@ -150,7 +150,7 @@ def run_test(self):\n         block.solve()\n \n         self.test_cltv_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n+        peer.send_and_ping(msg_block(block))\n         self.test_cltv_info(is_active=True)  # Active as of current tip\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n "
      },
      {
        "sha": "39e8bca751dc2ed906c702d5794c8072ae7b2226",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -182,10 +182,10 @@ def send_blocks(self, blocks, success=True, reject_reason=None):\n         \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n \n         Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n-        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_reason=reject_reason)\n+        self.helper_peer.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_reason=reject_reason)\n \n     def run_test(self):\n-        self.nodes[0].add_p2p_connection(P2PDataStore())\n+        self.helper_peer = self.nodes[0].add_p2p_connection(P2PDataStore())\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future"
      },
      {
        "sha": "3f7efdbded754ea530c778d5760af99bc59c635e",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -59,7 +59,7 @@ def test_dersig_info(self, *, is_active):\n         )\n \n     def run_test(self):\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n \n         self.test_dersig_info(is_active=False)\n \n@@ -84,7 +84,7 @@ def run_test(self):\n         block.solve()\n \n         self.test_dersig_info(is_active=False)  # Not active as of current tip and next block does not need to obey rules\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n+        peer.send_and_ping(msg_block(block))\n         self.test_dersig_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n@@ -97,9 +97,9 @@ def run_test(self):\n         block.solve()\n \n         with self.nodes[0].assert_debug_log(expected_msgs=['{}, bad-version(0x00000002)'.format(block.hash)]):\n-            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            peer.send_and_ping(msg_block(block))\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-            self.nodes[0].p2p.sync_with_ping()\n+            peer.sync_with_ping()\n \n         self.log.info(\"Test that transactions with non-DER signatures cannot appear in a block\")\n         block.nVersion = 3\n@@ -123,9 +123,9 @@ def run_test(self):\n         block.solve()\n \n         with self.nodes[0].assert_debug_log(expected_msgs=['CheckInputScripts on {} failed with non-mandatory-script-verify-flag (Non-canonical DER signature)'.format(block.vtx[-1].hash)]):\n-            self.nodes[0].p2p.send_and_ping(msg_block(block))\n+            peer.send_and_ping(msg_block(block))\n             assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n-            self.nodes[0].p2p.sync_with_ping()\n+            peer.sync_with_ping()\n \n         self.log.info(\"Test that a version 3 block with a DERSIG-compliant transaction is accepted\")\n         block.vtx[1] = create_transaction(self.nodes[0], self.coinbase_txids[1], self.nodeaddress, amount=1.0)\n@@ -134,7 +134,7 @@ def run_test(self):\n         block.solve()\n \n         self.test_dersig_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n-        self.nodes[0].p2p.send_and_ping(msg_block(block))\n+        peer.send_and_ping(msg_block(block))\n         self.test_dersig_info(is_active=True)  # Active as of current tip\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n "
      },
      {
        "sha": "d0a94658ff2a7503f4f71cfe257b57c719f39adb",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -145,16 +145,16 @@ def run_test(self):\n         self.restart_node(0, [\"-whitelist=download@127.0.0.1\", \"-maxuploadtarget=1\"])\n \n         # Reconnect to self.nodes[0]\n-        self.nodes[0].add_p2p_connection(TestP2PConn())\n+        peer = self.nodes[0].add_p2p_connection(TestP2PConn())\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit\n         getdata_request.inv = [CInv(MSG_BLOCK, big_new_block)]\n         for i in range(20):\n-            self.nodes[0].p2p.send_and_ping(getdata_request)\n-            assert_equal(self.nodes[0].p2p.block_receive_map[big_new_block], i+1)\n+            peer.send_and_ping(getdata_request)\n+            assert_equal(peer.block_receive_map[big_new_block], i+1)\n \n         getdata_request.inv = [CInv(MSG_BLOCK, big_old_block)]\n-        self.nodes[0].p2p.send_and_ping(getdata_request)\n+        peer.send_and_ping(getdata_request)\n \n         self.log.info(\"Peer still connected after trying to download old block (download permission)\")\n         peer_info = self.nodes[0].getpeerinfo()"
      },
      {
        "sha": "2e4f4796b001b2511efecce82359b7e2cabb8273",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -61,23 +61,23 @@ def versionbits_in_alert_file(self):\n \n     def run_test(self):\n         node = self.nodes[0]\n-        node.add_p2p_connection(P2PInterface())\n+        peer = node.add_p2p_connection(P2PInterface())\n \n         node_deterministic_address = node.get_deterministic_priv_key().address\n         # Mine one period worth of blocks\n         node.generatetoaddress(VB_PERIOD, node_deterministic_address)\n \n         self.log.info(\"Check that there is no warning if previous VB_BLOCKS have <VB_THRESHOLD blocks with unknown versionbits version.\")\n         # Build one period of blocks with < VB_THRESHOLD blocks signaling some unknown bit\n-        self.send_blocks_with_version(node.p2p, VB_THRESHOLD - 1, VB_UNKNOWN_VERSION)\n+        self.send_blocks_with_version(peer, VB_THRESHOLD - 1, VB_UNKNOWN_VERSION)\n         node.generatetoaddress(VB_PERIOD - VB_THRESHOLD + 1, node_deterministic_address)\n \n         # Check that we're not getting any versionbit-related errors in get*info()\n         assert not VB_PATTERN.match(node.getmininginfo()[\"warnings\"])\n         assert not VB_PATTERN.match(node.getnetworkinfo()[\"warnings\"])\n \n         # Build one period of blocks with VB_THRESHOLD blocks signaling some unknown bit\n-        self.send_blocks_with_version(node.p2p, VB_THRESHOLD, VB_UNKNOWN_VERSION)\n+        self.send_blocks_with_version(peer, VB_THRESHOLD, VB_UNKNOWN_VERSION)\n         node.generatetoaddress(VB_PERIOD - VB_THRESHOLD, node_deterministic_address)\n \n         self.log.info(\"Check that there is a warning if previous VB_BLOCKS have >=VB_THRESHOLD blocks with unknown versionbits version.\")"
      },
      {
        "sha": "d7cb7db9f856f3c55d2b2ddf8720f7c7038e982c",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -58,7 +58,7 @@ def chain_transaction(self, node, parent_txid, vout, value, fee, num_outputs):\n \n     def run_test(self):\n         # Mine some blocks and have them mature.\n-        self.nodes[0].add_p2p_connection(P2PTxInvStore()) # keep track of invs\n+        peer_inv_store = self.nodes[0].add_p2p_connection(P2PTxInvStore()) # keep track of invs\n         self.nodes[0].generate(101)\n         utxo = self.nodes[0].listunspent(10)\n         txid = utxo[0]['txid']\n@@ -80,7 +80,7 @@ def run_test(self):\n \n         # Wait until mempool transactions have passed initial broadcast (sent inv and received getdata)\n         # Otherwise, getrawmempool may be inconsistent with getmempoolentry if unbroadcast changes in between\n-        self.nodes[0].p2p.wait_for_broadcast(witness_chain)\n+        peer_inv_store.wait_for_broadcast(witness_chain)\n \n         # Check mempool has MAX_ANCESTORS transactions in it, and descendant and ancestor\n         # count and fees should look correct"
      },
      {
        "sha": "1b2c7644bd4b8a4038502ac279712a4f80c6a73b",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -234,9 +234,9 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n         assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=CBlockHeader(bad_block_time).serialize().hex()))\n \n         # Should ask for the block from a p2p node, if they announce the header as well:\n-        node.add_p2p_connection(P2PDataStore())\n-        node.p2p.wait_for_getheaders(timeout=5)  # Drop the first getheaders\n-        node.p2p.send_blocks_and_test(blocks=[block], node=node)\n+        peer = node.add_p2p_connection(P2PDataStore())\n+        peer.wait_for_getheaders(timeout=5)  # Drop the first getheaders\n+        peer.send_blocks_and_test(blocks=[block], node=node)\n         # Must be active now:\n         assert chain_tip(block.hash, status='active', branchlen=0) in node.getchaintips()\n "
      },
      {
        "sha": "2bc44f81f6ab7d0dad6e2baca07a40afc77aecfc",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -17,7 +17,7 @@ def set_test_params(self):\n         self.extra_args = [[\"-blocksonly\"]]\n \n     def run_test(self):\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n+        block_relay_peer = self.nodes[0].add_p2p_connection(P2PInterface())\n \n         self.log.info('Check that txs from p2p are rejected and result in disconnect')\n         prevtx = self.nodes[0].getblock(self.nodes[0].getblockhash(1), 2)['tx'][0]\n@@ -41,20 +41,20 @@ def run_test(self):\n         )['hex']\n         assert_equal(self.nodes[0].getnetworkinfo()['localrelay'], False)\n         with self.nodes[0].assert_debug_log(['transaction sent in violation of protocol peer=0']):\n-            self.nodes[0].p2p.send_message(msg_tx(FromHex(CTransaction(), sigtx)))\n-            self.nodes[0].p2p.wait_for_disconnect()\n+            block_relay_peer.send_message(msg_tx(FromHex(CTransaction(), sigtx)))\n+            block_relay_peer.wait_for_disconnect()\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 0)\n \n         # Remove the disconnected peer and add a new one.\n         del self.nodes[0].p2ps[0]\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n+        tx_relay_peer = self.nodes[0].add_p2p_connection(P2PInterface())\n \n         self.log.info('Check that txs from rpc are not rejected and relayed to other peers')\n         assert_equal(self.nodes[0].getpeerinfo()[0]['relaytxes'], True)\n         txid = self.nodes[0].testmempoolaccept([sigtx])[0]['txid']\n         with self.nodes[0].assert_debug_log(['received getdata for: wtx {} peer=1'.format(txid)]):\n             self.nodes[0].sendrawtransaction(sigtx)\n-            self.nodes[0].p2p.wait_for_tx(txid)\n+            tx_relay_peer.wait_for_tx(txid)\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 1)\n \n         self.log.info('Check that txs from forcerelay peers are not rejected and relayed to others')"
      },
      {
        "sha": "2349afa1eefa61f912fea3252500f555e4e3cbc6",
        "filename": "test/functional/p2p_dos_header_tree.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_dos_header_tree.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_dos_header_tree.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_dos_header_tree.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -46,8 +46,8 @@ def run_test(self):\n         self.headers_fork = [FromHex(CBlockHeader(), h) for h in self.headers_fork]\n \n         self.log.info(\"Feed all non-fork headers, including and up to the first checkpoint\")\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n-        self.nodes[0].p2p.send_and_ping(msg_headers(self.headers))\n+        peer_checkpoint = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer_checkpoint.send_and_ping(msg_headers(self.headers))\n         assert {\n             'height': 546,\n             'hash': '000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70',\n@@ -57,14 +57,14 @@ def run_test(self):\n \n         self.log.info(\"Feed all fork headers (fails due to checkpoint)\")\n         with self.nodes[0].assert_debug_log(['bad-fork-prior-to-checkpoint']):\n-            self.nodes[0].p2p.send_message(msg_headers(self.headers_fork))\n-            self.nodes[0].p2p.wait_for_disconnect()\n+            peer_checkpoint.send_message(msg_headers(self.headers_fork))\n+            peer_checkpoint.wait_for_disconnect()\n \n         self.log.info(\"Feed all fork headers (succeeds without checkpoint)\")\n         # On node 0 it succeeds because checkpoints are disabled\n         self.restart_node(0, extra_args=['-nocheckpoints'])\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n-        self.nodes[0].p2p.send_and_ping(msg_headers(self.headers_fork))\n+        peer_no_checkpoint = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer_no_checkpoint.send_and_ping(msg_headers(self.headers_fork))\n         assert {\n             \"height\": 2,\n             \"hash\": \"00000000b0494bd6c3d5ff79c497cfce40831871cbf39b1bc28bd1dac817dc39\",\n@@ -73,8 +73,8 @@ def run_test(self):\n         } in self.nodes[0].getchaintips()\n \n         # On node 1 it succeeds because no checkpoint has been reached yet by a chain tip\n-        self.nodes[1].add_p2p_connection(P2PInterface())\n-        self.nodes[1].p2p.send_and_ping(msg_headers(self.headers_fork))\n+        peer_before_checkpoint = self.nodes[1].add_p2p_connection(P2PInterface())\n+        peer_before_checkpoint.send_and_ping(msg_headers(self.headers_fork))\n         assert {\n             \"height\": 2,\n             \"hash\": \"00000000b0494bd6c3d5ff79c497cfce40831871cbf39b1bc28bd1dac817dc39\","
      },
      {
        "sha": "642a21704796c524d31b98b7d90774a3222f611f",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -131,7 +131,7 @@ def test_msg_mempool(self):\n         self.log.debug(\"Send a mempool msg after connecting and check that the tx is received\")\n         self.nodes[0].add_p2p_connection(filter_peer)\n         filter_peer.send_and_ping(filter_peer.watch_filter_init)\n-        self.nodes[0].p2p.send_message(msg_mempool())\n+        filter_peer.send_message(msg_mempool())\n         filter_peer.wait_for_tx(txid)\n \n     def test_frelay_false(self, filter_peer):"
      },
      {
        "sha": "483f25f48c4fcfb86b2ea345777e105c5dd837c4",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -27,7 +27,7 @@ def set_test_params(self):\n     def run_test(self):\n         # Add p2p connection to node0\n         node = self.nodes[0]  # convenience reference to the node\n-        node.add_p2p_connection(P2PDataStore())\n+        peer = node.add_p2p_connection(P2PDataStore())\n \n         best_block = node.getblock(node.getbestblockhash())\n         tip = int(node.getbestblockhash(), 16)\n@@ -42,7 +42,7 @@ def run_test(self):\n         # Save the coinbase for later\n         block1 = block\n         tip = block.sha256\n-        node.p2p.send_blocks_and_test([block1], node, success=True)\n+        peer.send_blocks_and_test([block1], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n         node.generatetoaddress(100, node.get_deterministic_priv_key().address)\n@@ -80,7 +80,7 @@ def run_test(self):\n         assert_equal(orig_hash, block2.rehash())\n         assert block2_orig.vtx != block2.vtx\n \n-        node.p2p.send_blocks_and_test([block2], node, success=False, reject_reason='bad-txns-duplicate')\n+        peer.send_blocks_and_test([block2], node, success=False, reject_reason='bad-txns-duplicate')\n \n         # Check transactions for duplicate inputs (CVE-2018-17144)\n         self.log.info(\"Test duplicate input block.\")\n@@ -91,7 +91,7 @@ def run_test(self):\n         block2_dup.hashMerkleRoot = block2_dup.calc_merkle_root()\n         block2_dup.rehash()\n         block2_dup.solve()\n-        node.p2p.send_blocks_and_test([block2_dup], node, success=False, reject_reason='bad-txns-inputs-duplicate')\n+        peer.send_blocks_and_test([block2_dup], node, success=False, reject_reason='bad-txns-inputs-duplicate')\n \n         self.log.info(\"Test very broken block.\")\n \n@@ -104,14 +104,14 @@ def run_test(self):\n         block3.rehash()\n         block3.solve()\n \n-        node.p2p.send_blocks_and_test([block3], node, success=False, reject_reason='bad-cb-amount')\n+        peer.send_blocks_and_test([block3], node, success=False, reject_reason='bad-cb-amount')\n \n \n         # Complete testing of CVE-2012-2459 by sending the original block.\n         # It should be accepted even though it has the same hash as the mutated one.\n \n         self.log.info(\"Test accepting original block after rejecting its mutated version.\")\n-        node.p2p.send_blocks_and_test([block2_orig], node, success=True, timeout=5)\n+        peer.send_blocks_and_test([block2_orig], node, success=True, timeout=5)\n \n         # Update tip info\n         height += 1\n@@ -131,7 +131,7 @@ def run_test(self):\n         block4.rehash()\n         block4.solve()\n         self.log.info(\"Test inflation by duplicating input\")\n-        node.p2p.send_blocks_and_test([block4], node, success=False,  reject_reason='bad-txns-inputs-duplicate')\n+        peer.send_blocks_and_test([block4], node, success=False,  reject_reason='bad-txns-inputs-duplicate')\n \n if __name__ == '__main__':\n     InvalidBlockRequestTest().main()"
      },
      {
        "sha": "e4fc9fd17883bde0065ea12fe05854af8c513d5e",
        "filename": "test/functional/p2p_invalid_locator.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_invalid_locator.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_invalid_locator.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_locator.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -23,20 +23,20 @@ def run_test(self):\n         block_count = node.getblockcount()\n         for msg in [msg_getheaders(), msg_getblocks()]:\n             self.log.info('Wait for disconnect when sending {} hashes in locator'.format(MAX_LOCATOR_SZ + 1))\n-            node.add_p2p_connection(P2PInterface())\n+            exceed_max_peer = node.add_p2p_connection(P2PInterface())\n             msg.locator.vHave = [int(node.getblockhash(i - 1), 16) for i in range(block_count, block_count - (MAX_LOCATOR_SZ + 1), -1)]\n-            node.p2p.send_message(msg)\n-            node.p2p.wait_for_disconnect()\n+            exceed_max_peer.send_message(msg)\n+            exceed_max_peer.wait_for_disconnect()\n             node.disconnect_p2ps()\n \n             self.log.info('Wait for response when sending {} hashes in locator'.format(MAX_LOCATOR_SZ))\n-            node.add_p2p_connection(P2PInterface())\n+            within_max_peer = node.add_p2p_connection(P2PInterface())\n             msg.locator.vHave = [int(node.getblockhash(i - 1), 16) for i in range(block_count, block_count - (MAX_LOCATOR_SZ), -1)]\n-            node.p2p.send_message(msg)\n+            within_max_peer.send_message(msg)\n             if type(msg) == msg_getheaders:\n-                node.p2p.wait_for_header(node.getbestblockhash())\n+                within_max_peer.wait_for_header(node.getbestblockhash())\n             else:\n-                node.p2p.wait_for_block(int(node.getbestblockhash(), 16))\n+                within_max_peer.wait_for_block(int(node.getbestblockhash(), 16))\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "247e69d7d711d05641018c69892ececbbf21c1ae",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -2096,14 +2096,14 @@ def serialize(self):\n         tx = FromHex(CTransaction(), raw)\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, serialize_with_bogus_witness(tx).hex())\n         with self.nodes[0].assert_debug_log(['Superfluous witness record']):\n-            self.nodes[0].p2p.send_and_ping(msg_bogus_tx(tx))\n+            self.test_node.send_and_ping(msg_bogus_tx(tx))\n         raw = self.nodes[0].signrawtransactionwithwallet(raw)\n         assert raw['complete']\n         raw = raw['hex']\n         tx = FromHex(CTransaction(), raw)\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, serialize_with_bogus_witness(tx).hex())\n         with self.nodes[0].assert_debug_log(['Unknown transaction optional data']):\n-            self.nodes[0].p2p.send_and_ping(msg_bogus_tx(tx))\n+            self.test_node.send_and_ping(msg_bogus_tx(tx))\n \n     @subtest  # type: ignore\n     def test_wtxid_relay(self):"
      },
      {
        "sha": "35cea85c07e3bfde5557cb5a5c7aa77590967ad1",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -317,7 +317,7 @@ def _test_stopatheight(self):\n     def _test_waitforblockheight(self):\n         self.log.info(\"Test waitforblockheight\")\n         node = self.nodes[0]\n-        node.add_p2p_connection(P2PInterface())\n+        peer = node.add_p2p_connection(P2PInterface())\n \n         current_height = node.getblock(node.getbestblockhash())['height']\n \n@@ -334,7 +334,7 @@ def _test_waitforblockheight(self):\n         def solve_and_send_block(prevhash, height, time):\n             b = create_block(prevhash, create_coinbase(height), time)\n             b.solve()\n-            node.p2p.send_and_ping(msg_block(b))\n+            peer.send_and_ping(msg_block(b))\n             return b\n \n         b21f = solve_and_send_block(int(b20hash, 16), 21, b20['time'] + 1)"
      },
      {
        "sha": "ca1039092d78bb7394b322687d6979791497639a",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/784f757994c1306bb6584b14c0c78617d6248432/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/784f757994c1306bb6584b14c0c78617d6248432/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=784f757994c1306bb6584b14c0c78617d6248432",
        "patch": "@@ -21,7 +21,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         node = self.nodes[0]  # alias\n \n-        node.add_p2p_connection(P2PTxInvStore())\n+        peer_first = node.add_p2p_connection(P2PTxInvStore())\n \n         self.log.info(\"Create a new transaction and wait until it's broadcast\")\n         txid = node.sendtoaddress(node.getnewaddress(), 1)\n@@ -33,10 +33,10 @@ def run_test(self):\n         time.sleep(1.1)\n \n         # Can take a few seconds due to transaction trickling\n-        node.p2p.wait_for_broadcast([txid])\n+        peer_first.wait_for_broadcast([txid])\n \n         # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)\n-        node.add_p2p_connection(P2PTxInvStore())\n+        peer_second = node.add_p2p_connection(P2PTxInvStore())\n \n         self.log.info(\"Create a block\")\n         # Create and submit a block without the transaction.\n@@ -64,7 +64,7 @@ def run_test(self):\n         # Transaction should be rebroadcast approximately 24 hours in the future,\n         # but can range from 12-36. So bump 36 hours to be sure.\n         node.setmocktime(now + 36 * 60 * 60)\n-        node.p2p.wait_for_broadcast([txid])\n+        peer_second.wait_for_broadcast([txid])\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "7a0de46aeafb351cffa3410e1aae9809fd4698ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTBkZTQ2YWVhZmIzNTFjZmZhMzQxMGUxYWFlOTgwOWZkNDY5OGFk",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-10T14:33:44Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-10T14:38:28Z"
      },
      "message": "[doc] sample code for test framework p2p objects",
      "tree": {
        "sha": "87b088e4dcc334eb00e2e3bc784251824b88551a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87b088e4dcc334eb00e2e3bc784251824b88551a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a0de46aeafb351cffa3410e1aae9809fd4698ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a0de46aeafb351cffa3410e1aae9809fd4698ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a0de46aeafb351cffa3410e1aae9809fd4698ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a0de46aeafb351cffa3410e1aae9809fd4698ad/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "784f757994c1306bb6584b14c0c78617d6248432",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/784f757994c1306bb6584b14c0c78617d6248432",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/784f757994c1306bb6584b14c0c78617d6248432"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 20,
      "deletions": 4
    },
    "files": [
      {
        "sha": "82b30fed513a0081fc75bee1020489e24327b96d",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 20,
        "deletions": 4,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a0de46aeafb351cffa3410e1aae9809fd4698ad/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a0de46aeafb351cffa3410e1aae9809fd4698ad/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=7a0de46aeafb351cffa3410e1aae9809fd4698ad",
        "patch": "@@ -87,7 +87,9 @@ P2P messages. These can be found in the following source files:\n \n #### Using the P2P interface\n \n-- [messages.py](test_framework/messages.py) contains all the definitions for objects that pass\n+- `P2P`s can be used to test specific P2P protocol behavior.\n+[p2p.py](test_framework/p2p.py) contains test framework p2p objects and\n+[messages.py](test_framework/messages.py) contains all the definitions for objects passed\n over the network (`CBlock`, `CTransaction`, etc, along with the network-level\n wrappers for them, `msg_block`, `msg_tx`, etc).\n \n@@ -100,8 +102,22 @@ contains the higher level logic for processing P2P payloads and connecting to\n the Bitcoin Core node application logic. For custom behaviour, subclass the\n P2PInterface object and override the callback methods.\n \n-- Can be used to write tests where specific P2P protocol behavior is tested.\n-Examples tests are [p2p_unrequested_blocks.py](p2p_unrequested_blocks.py),\n+`P2PConnection`s can be used as such:\n+\n+```python\n+p2p_conn = node.add_p2p_connection(P2PInterface())\n+p2p_conn.send_and_ping(msg)\n+```\n+\n+They can also be referenced by indexing into a `TestNode`'s `p2ps` list, which\n+contains the list of test framework `p2p` objects connected to itself\n+(it does not include any `TestNode`s):\n+\n+```python\n+node.p2ps[0].sync_with_ping()\n+```\n+\n+More examples can be found in [p2p_unrequested_blocks.py](p2p_unrequested_blocks.py),\n [p2p_compactblocks.py](p2p_compactblocks.py).\n \n #### Prototyping tests\n@@ -157,7 +173,7 @@ way is the use the `profile_with_perf` context manager, e.g.\n with node.profile_with_perf(\"send-big-msgs\"):\n     # Perform activity on the node you're interested in profiling, e.g.:\n     for _ in range(10000):\n-        node.p2p.send_message(some_large_message)\n+        node.p2ps[0].send_message(some_large_message)\n ```\n \n To see useful textual output, run"
      }
    ]
  },
  {
    "sha": "549d30faf04612d9589c81edf9770c99e3221885",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDlkMzBmYWYwNDYxMmQ5NTg5YzgxZWRmOTc3MGM5OWUzMjIxODg1",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-04T01:18:34Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-10T14:39:01Z"
      },
      "message": "scripted-diff: replace p2p with p2ps[0] in p2p_invalid_tx\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/\\.p2p\\./.p2ps[0]./g' test/functional/p2p_invalid_tx.py\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "ae4f10154779a9300ff78ca370d37a2b036b9736",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ae4f10154779a9300ff78ca370d37a2b036b9736"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/549d30faf04612d9589c81edf9770c99e3221885",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/549d30faf04612d9589c81edf9770c99e3221885",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/549d30faf04612d9589c81edf9770c99e3221885",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/549d30faf04612d9589c81edf9770c99e3221885/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a0de46aeafb351cffa3410e1aae9809fd4698ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a0de46aeafb351cffa3410e1aae9809fd4698ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a0de46aeafb351cffa3410e1aae9809fd4698ad"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 6,
      "deletions": 6
    },
    "files": [
      {
        "sha": "489d903c21c66eadff7b6f05fc474f210968a0f2",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/549d30faf04612d9589c81edf9770c99e3221885/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/549d30faf04612d9589c81edf9770c99e3221885/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=549d30faf04612d9589c81edf9770c99e3221885",
        "patch": "@@ -61,7 +61,7 @@ def run_test(self):\n         # Save the coinbase for later\n         block1 = block\n         tip = block.sha256\n-        node.p2p.send_blocks_and_test([block], node, success=True)\n+        node.p2ps[0].send_blocks_and_test([block], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n         self.nodes[0].generatetoaddress(100, self.nodes[0].get_deterministic_priv_key().address)\n@@ -72,7 +72,7 @@ def run_test(self):\n             self.log.info(\"Testing invalid transaction: %s\", BadTxTemplate.__name__)\n             template = BadTxTemplate(spend_block=block1)\n             tx = template.get_tx()\n-            node.p2p.send_txs_and_test(\n+            node.p2ps[0].send_txs_and_test(\n                 [tx], node, success=False,\n                 expect_disconnect=template.expect_disconnect,\n                 reject_reason=template.reject_reason,\n@@ -121,7 +121,7 @@ def run_test(self):\n \n         self.log.info('Send the orphans ... ')\n         # Send valid orphan txs from p2ps[0]\n-        node.p2p.send_txs_and_test([tx_orphan_1, tx_orphan_2_no_fee, tx_orphan_2_valid], node, success=False)\n+        node.p2ps[0].send_txs_and_test([tx_orphan_1, tx_orphan_2_no_fee, tx_orphan_2_valid], node, success=False)\n         # Send invalid tx from p2ps[1]\n         node.p2ps[1].send_txs_and_test([tx_orphan_2_invalid], node, success=False)\n \n@@ -130,7 +130,7 @@ def run_test(self):\n \n         self.log.info('Send the withhold tx ... ')\n         with node.assert_debug_log(expected_msgs=[\"bad-txns-in-belowout\"]):\n-            node.p2p.send_txs_and_test([tx_withhold], node, success=True)\n+            node.p2ps[0].send_txs_and_test([tx_withhold], node, success=True)\n \n         # Transactions that should end up in the mempool\n         expected_mempool = {\n@@ -155,14 +155,14 @@ def run_test(self):\n             orphan_tx_pool[i].vout.append(CTxOut(nValue=11 * COIN, scriptPubKey=SCRIPT_PUB_KEY_OP_TRUE))\n \n         with node.assert_debug_log(['mapOrphan overflow, removed 1 tx']):\n-            node.p2p.send_txs_and_test(orphan_tx_pool, node, success=False)\n+            node.p2ps[0].send_txs_and_test(orphan_tx_pool, node, success=False)\n \n         rejected_parent = CTransaction()\n         rejected_parent.vin.append(CTxIn(outpoint=COutPoint(tx_orphan_2_invalid.sha256, 0)))\n         rejected_parent.vout.append(CTxOut(nValue=11 * COIN, scriptPubKey=SCRIPT_PUB_KEY_OP_TRUE))\n         rejected_parent.rehash()\n         with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(rejected_parent.hash)]):\n-            node.p2p.send_txs_and_test([rejected_parent], node, success=False)\n+            node.p2ps[0].send_txs_and_test([rejected_parent], node, success=False)\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "10d61505fe77880d6989115defa5e08417f3de2d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMGQ2MTUwNWZlNzc4ODBkNjk4OTExNWRlZmE1ZTA4NDE3ZjNkZTJk",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-04T01:21:32Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-09-10T14:39:14Z"
      },
      "message": "[test] remove confusing p2p property",
      "tree": {
        "sha": "d6f7530ddbea42e074181daee3dd380c2d568687",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6f7530ddbea42e074181daee3dd380c2d568687"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/10d61505fe77880d6989115defa5e08417f3de2d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/10d61505fe77880d6989115defa5e08417f3de2d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/10d61505fe77880d6989115defa5e08417f3de2d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/10d61505fe77880d6989115defa5e08417f3de2d/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "549d30faf04612d9589c81edf9770c99e3221885",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/549d30faf04612d9589c81edf9770c99e3221885",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/549d30faf04612d9589c81edf9770c99e3221885"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 0,
      "deletions": 9
    },
    "files": [
      {
        "sha": "046efe730e22656684e14fbc512e19484465bb65",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/10d61505fe77880d6989115defa5e08417f3de2d/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/10d61505fe77880d6989115defa5e08417f3de2d/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=10d61505fe77880d6989115defa5e08417f3de2d",
        "patch": "@@ -542,15 +542,6 @@ def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, **kwargs):\n \n         return p2p_conn\n \n-    @property\n-    def p2p(self):\n-        \"\"\"Return the first p2p connection\n-\n-        Convenience property - most tests only use a single p2p connection to each\n-        node, so this saves having to write node.p2ps[0] many times.\"\"\"\n-        assert self.p2ps, self._node_msg(\"No p2p connection\")\n-        return self.p2ps[0]\n-\n     def num_test_p2p_connections(self):\n         \"\"\"Return number of test framework p2p connections to the node.\"\"\"\n         return len([peer for peer in self.getpeerinfo() if peer['subver'] == MY_SUBVERSION])"
      }
    ]
  }
]