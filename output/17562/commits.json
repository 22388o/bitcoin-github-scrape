[
  {
    "sha": "ab00be08e8e4371bf1483d139ecb50dacba40e0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYjAwYmUwOGU4ZTQzNzFiZjE0ODNkMTM5ZWNiNTBkYWNiYTQwZTBh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-11-18T16:53:26Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-03-19T20:44:19Z"
      },
      "message": "[validation] Remove ConnectTrace and PerBlockConnectTrace\n\nConnectTrace was introduced in 6fdd43b968f984ef92ca4576872dc65462ba7312\nwhen the SyncTransactions signal needed to be fired outside the cs_main\nscope. The CValidationInterface is now asynchronous and callbacks can be\nscheduled without holding cs_main. The scheduler thread can execute the\ncallback later without regard to cs_main.\n\nRemove the ConnectTrace struct that needs to be passed up and down the\nstack and just fire BlockConnected() directly in ConnectTip().",
      "tree": {
        "sha": "439695ff8968dda80e529d95bdd01dd7b2474b52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/439695ff8968dda80e529d95bdd01dd7b2474b52"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab00be08e8e4371bf1483d139ecb50dacba40e0a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab00be08e8e4371bf1483d139ecb50dacba40e0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ab00be08e8e4371bf1483d139ecb50dacba40e0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab00be08e8e4371bf1483d139ecb50dacba40e0a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5bf45fe2a9642f8ae8f8a12bcbf8f8b4770421ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bf45fe2a9642f8ae8f8a12bcbf8f8b4770421ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5bf45fe2a9642f8ae8f8a12bcbf8f8b4770421ad"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 15,
      "deletions": 61
    },
    "files": [
      {
        "sha": "0323e0f5eb3150baf03d424874e5de09749a44fd",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 57,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab00be08e8e4371bf1483d139ecb50dacba40e0a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab00be08e8e4371bf1483d139ecb50dacba40e0a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ab00be08e8e4371bf1483d139ecb50dacba40e0a",
        "patch": "@@ -2501,53 +2501,11 @@ static int64_t nTimeFlush = 0;\n static int64_t nTimeChainState = 0;\n static int64_t nTimePostConnect = 0;\n \n-struct PerBlockConnectTrace {\n-    CBlockIndex* pindex = nullptr;\n-    std::shared_ptr<const CBlock> pblock;\n-    PerBlockConnectTrace() {}\n-};\n-/**\n- * Used to track blocks whose transactions were applied to the UTXO state as a\n- * part of a single ActivateBestChainStep call.\n- *\n- * This class is single-use, once you call GetBlocksConnected() you have to throw\n- * it away and make a new one.\n- */\n-class ConnectTrace {\n-private:\n-    std::vector<PerBlockConnectTrace> blocksConnected;\n-\n-public:\n-    explicit ConnectTrace() : blocksConnected(1) {}\n-\n-    void BlockConnected(CBlockIndex* pindex, std::shared_ptr<const CBlock> pblock) {\n-        assert(!blocksConnected.back().pindex);\n-        assert(pindex);\n-        assert(pblock);\n-        blocksConnected.back().pindex = pindex;\n-        blocksConnected.back().pblock = std::move(pblock);\n-        blocksConnected.emplace_back();\n-    }\n-\n-    std::vector<PerBlockConnectTrace>& GetBlocksConnected() {\n-        // We always keep one extra block at the end of our list because\n-        // blocks are added after all the conflicted transactions have\n-        // been filled in. Thus, the last entry should always be an empty\n-        // one waiting for the transactions from the next block. We pop\n-        // the last entry here to make sure the list we return is sane.\n-        assert(!blocksConnected.back().pindex);\n-        blocksConnected.pop_back();\n-        return blocksConnected;\n-    }\n-};\n-\n /**\n  * Connect a new block to m_chain. pblock is either nullptr or a pointer to a CBlock\n  * corresponding to pindexNew, to bypass loading it again from disk.\n- *\n- * The block is added to connectTrace if connection succeeds.\n  */\n-bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n+bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, DisconnectedBlockTransactions &disconnectpool)\n {\n     assert(pindexNew->pprev == m_chain.Tip());\n     // Read block from disk.\n@@ -2599,7 +2557,7 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime6 - nTime5) * MILLI, nTimePostConnect * MICRO, nTimePostConnect * MILLI / nBlocksTotal);\n     LogPrint(BCLog::BENCH, \"- Connect block: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime6 - nTime1) * MILLI, nTimeTotal * MICRO, nTimeTotal * MILLI / nBlocksTotal);\n \n-    connectTrace.BlockConnected(pindexNew, std::move(pthisBlock));\n+    GetMainSignals().BlockConnected(pthisBlock, pindexNew);\n     return true;\n }\n \n@@ -2680,7 +2638,7 @@ void CChainState::PruneBlockIndexCandidates() {\n  *\n  * @returns true unless a system error occurred\n  */\n-bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n+bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound)\n {\n     AssertLockHeld(cs_main);\n \n@@ -2724,7 +2682,7 @@ bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai\n \n         // Connect new blocks.\n         for (CBlockIndex *pindexConnect : reverse_iterate(vpindexToConnect)) {\n-            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n+            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n                     if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n@@ -2826,14 +2784,13 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n         LimitValidationInterfaceQueue();\n \n         {\n-            LOCK2(cs_main, ::mempool.cs); // Lock transaction pool for at least as long as it takes for connectTrace to be consumed\n+            // Do not unlock cs_main or mempool until we've made forward\n+            // progress (with the exception of shutdown due to hardware issues,\n+            // low disk space, etc).\n+            LOCK2(cs_main, ::mempool.cs);\n             CBlockIndex* starting_tip = m_chain.Tip();\n             bool blocks_connected = false;\n             do {\n-                // We absolutely may not unlock cs_main until we've made forward progress\n-                // (with the exception of shutdown due to hardware issues, low disk space, etc).\n-                ConnectTrace connectTrace; // Destructed before cs_main is unlocked\n-\n                 if (pindexMostWork == nullptr) {\n                     pindexMostWork = FindMostWorkChain();\n                 }\n@@ -2845,7 +2802,7 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n \n                 bool fInvalidFound = false;\n                 std::shared_ptr<const CBlock> nullBlockPtr;\n-                if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace)) {\n+                if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound)) {\n                     // A system error occurred\n                     return false;\n                 }\n@@ -2855,13 +2812,11 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n                     // Wipe cache, we may need another branch now.\n                     pindexMostWork = nullptr;\n                 }\n+\n                 pindexNewTip = m_chain.Tip();\n \n-                for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {\n-                    assert(trace.pblock && trace.pindex);\n-                    GetMainSignals().BlockConnected(trace.pblock, trace.pindex);\n-                }\n             } while (!m_chain.Tip() || (starting_tip && CBlockIndexWorkComparator()(m_chain.Tip(), starting_tip)));\n+\n             if (!blocks_connected) return true;\n \n             const CBlockIndex* pindexFork = m_chain.FindFork(starting_tip);\n@@ -2876,7 +2831,8 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n                 // Always notify the UI if a new block tip was connected\n                 uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip);\n             }\n-        }\n+        } // cs_main, mempool.cs scope\n+\n         // When we reach this point, we switched to a new tip (stored in pindexNewTip).\n \n         if (nStopAtHeight && pindexNewTip && pindexNewTip->nHeight >= nStopAtHeight) StartShutdown();"
      },
      {
        "sha": "530987764ac6e39e6360e4a7f4940d54ad180d50",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab00be08e8e4371bf1483d139ecb50dacba40e0a/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab00be08e8e4371bf1483d139ecb50dacba40e0a/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=ab00be08e8e4371bf1483d139ecb50dacba40e0a",
        "patch": "@@ -411,8 +411,6 @@ enum DisconnectResult\n     DISCONNECT_FAILED   // Something else went wrong.\n };\n \n-class ConnectTrace;\n-\n /** @see CChainState::FlushStateToDisk */\n enum class FlushStateMode {\n     NONE,\n@@ -742,8 +740,8 @@ class CChainState {\n         size_t max_mempool_size_bytes) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n private:\n-    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n-    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n \n     void InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      }
    ]
  }
]