[
  {
    "sha": "fab558612278909df93bdf88f5727b04f13aef0f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWI1NTg2MTIyNzg5MDlkZjkzYmRmODhmNTcyN2IwNGYxM2FlZjBm",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-07-09T15:59:54Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-07-10T13:37:42Z"
      },
      "message": "doc: Use precise permission flags where possible",
      "tree": {
        "sha": "d8c23edec4f024feab7a604b0b918f53c5652387",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8c23edec4f024feab7a604b0b918f53c5652387"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fab558612278909df93bdf88f5727b04f13aef0f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgfSAv/Q4Xo4DEQ/Y1v4YZqFirrGLNahKnAZ7g74boc0lmscpVll8jO9paWBf7f\nqY8k/3DiRdu2lFbctHoWkzQcyTD5KHOufBhob+T7kQIMI4Vqe4/zLQ8cibbPhrKY\ndKqZ4j9l+u4VKfGywPoUSIOKQTWjf+MrBhunbequu1dRZNUl1LSrXlUUReWJfEzH\negbmgJqMRUSIGd2BE+man2Yl1Pvdbo0DDuMC6SfZol223F27kNmWrCSlKaBqVZlx\nDrFJKBRSzNpx4LtfVSL3VKPqj5vTwyPtAmo3aCcdcaIciCPhquAEuXyTMz+XUrg5\nRuEvnY255Qm7uZ6/iD4BC7+6zSBmkka7jjpmTtL+EjwOQrRs0IHLCk+5axd03gna\n87GJUT5i3PxGoPLvURAkZGStRjfZRkP0MttsVATXCdgirx+kqcoKifkzojH1fcRR\nSVgiOJVBdRFKmqIXeYQe/dmW3eiymvjW3H3an89IyRHaM1Gde6gz4uMstyNMJ9AR\n2rK1j1XJ\n=fzbp\n-----END PGP SIGNATURE-----",
        "payload": "tree d8c23edec4f024feab7a604b0b918f53c5652387\nparent cc9d09e73de0fa5639bd782166b171448fd6b90b\nauthor MarcoFalke <falke.marco@gmail.com> 1594310394 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1594388262 +0200\n\ndoc: Use precise permission flags where possible\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab558612278909df93bdf88f5727b04f13aef0f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fab558612278909df93bdf88f5727b04f13aef0f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab558612278909df93bdf88f5727b04f13aef0f/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc9d09e73de0fa5639bd782166b171448fd6b90b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc9d09e73de0fa5639bd782166b171448fd6b90b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc9d09e73de0fa5639bd782166b171448fd6b90b"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 37,
      "deletions": 45
    },
    "files": [
      {
        "sha": "86943b1f727cfff6e8fd3bc343a217ccd48be776",
        "filename": "doc/reduce-traffic.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/doc/reduce-traffic.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/doc/reduce-traffic.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/reduce-traffic.md?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -50,7 +50,7 @@ Be reminded of the effects of this setting.\n   Doing so disables the automatic broadcasting of transactions from wallet. Not\n   relaying other's transactions could hurt your privacy if used while a wallet\n   is loaded or if you use the node to broadcast transactions.\n-- If a peer is whitelisted and \"-whitelistforcerelay\" is set to \"1\" (which will\n-  also set \"whitelistrelay\" to \"1\"), we will still receive and relay their transactions.\n+- If a peer has the forcerelay permission, we will still receive and relay\n+  their transactions.\n - It makes block propagation slower because compact block relay can only be\n   used when transaction relay is enabled."
      },
      {
        "sha": "90a592cc63f1625142308580e59155e09559b4e9",
        "filename": "share/examples/bitcoin.conf",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/share/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/share/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/examples/bitcoin.conf?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -20,8 +20,8 @@\n # Bind to given address and always listen on it. Use [host]:port notation for IPv6\n #bind=<addr>\n \n-# Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\n-#whitebind=<addr>\n+# Bind to given address and add permission flags to peers connecting to it. Use [host]:port notation for IPv6\n+#whitebind=perm@<addr>\n \n ##############################################################\n ##            Quick Primer on addnode vs connect            ##"
      },
      {
        "sha": "16f765574f2ccc24a95669a5d5bc436f2e18e76f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -396,7 +396,7 @@ void SetupServerArgs(NodeContext& node)\n     gArgs.AddArg(\"-blocknotify=<cmd>\", \"Execute command when the best block changes (%s in cmd is replaced by block hash)\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Automatic broadcast and rebroadcast of any transactions from inbound peers is disabled, unless '-whitelistforcerelay' is '1', in which case whitelisted peers' transactions will be relayed. RPC transactions are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Automatic broadcast and rebroadcast of any transactions from inbound peers is disabled, unless the peer has the 'forcerelay' permission. RPC transactions are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-conf=<file>\", strprintf(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\", BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-datadir=<dir>\", \"Specify data directory\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::OPTIONS);"
      },
      {
        "sha": "b013a24797f958175ef6786d9dbadf7b288986d2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 14,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -117,7 +117,7 @@ static constexpr std::chrono::hours AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL{24};\n /** Average delay between peer address broadcasts */\n static constexpr std::chrono::seconds AVG_ADDRESS_BROADCAST_INTERVAL{30};\n /** Average delay between trickled inventory transmissions in seconds.\n- *  Blocks and whitelisted receivers bypass this, outbound peers get half this delay. */\n+ *  Blocks and peers with noban permission bypass this, outbound peers get half this delay. */\n static const unsigned int INVENTORY_BROADCAST_INTERVAL = 5;\n /** Maximum number of inventory items to send per transmission.\n  *  Limits the impact of low-fee transaction floods. */\n@@ -249,7 +249,7 @@ struct CNodeState {\n     bool fCurrentlyConnected;\n     //! Accumulated misbehaviour score for this peer.\n     int nMisbehavior;\n-    //! Whether this peer should be disconnected and marked as discouraged (unless whitelisted with noban).\n+    //! Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission).\n     bool m_should_discourage;\n     //! String name of this peer (debugging/logging purposes).\n     const std::string name;\n@@ -1895,8 +1895,8 @@ static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n             // headers to fetch from this peer.\n             if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n                 // This peer has too little work on their headers chain to help\n-                // us sync -- disconnect if using an outbound slot (unless\n-                // whitelisted or addnode).\n+                // us sync -- disconnect if it is an outbound disconnection\n+                // candidate.\n                 // Note: We compare their tip to nMinimumChainWork (rather than\n                 // ::ChainActive().Tip()) because we won't start block download\n                 // until we have a headers chain that has at least\n@@ -2537,9 +2537,10 @@ void ProcessMessage(\n         // block-relay-only peer\n         bool fBlocksOnly = !g_relay_txes || (pfrom.m_tx_relay == nullptr);\n \n-        // Allow whitelisted peers to send data other than blocks in blocks only mode if whitelistrelay is true\n-        if (pfrom.HasPermission(PF_RELAY))\n+        // Allow peers with relay permission to send data other than blocks in blocks only mode\n+        if (pfrom.HasPermission(PF_RELAY)) {\n             fBlocksOnly = false;\n+        }\n \n         LOCK(cs_main);\n \n@@ -2893,14 +2894,14 @@ void ProcessMessage(\n             }\n \n             if (pfrom.HasPermission(PF_FORCERELAY)) {\n-                // Always relay transactions received from whitelisted peers, even\n+                // Always relay transactions received from peers with forcerelay permission, even\n                 // if they were already in the mempool,\n                 // allowing the node to function as a gateway for\n                 // nodes hidden behind it.\n                 if (!mempool.exists(tx.GetHash())) {\n-                    LogPrintf(\"Not relaying non-mempool transaction %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n+                    LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n+                    LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                     RelayTransaction(tx.GetHash(), *connman);\n                 }\n             }\n@@ -3050,7 +3051,7 @@ void ProcessMessage(\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n+                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                     Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us invalid compact block\\n\", pfrom.GetId()));\n                     return;\n                 } else if (status == READ_STATUS_FAILED) {\n@@ -3183,7 +3184,7 @@ void ProcessMessage(\n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n+                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                 Misbehaving(pfrom.GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom.GetId()));\n                 return;\n             } else if (status == READ_STATUS_FAILED) {\n@@ -4264,9 +4265,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // Check for headers sync timeouts\n         if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {\n             // Detect whether this is a stalling initial-headers-sync peer\n-            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n+            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24 * 60 * 60) {\n                 if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n-                    // Disconnect a (non-whitelisted) peer if it is our only sync peer,\n+                    // Disconnect a peer (without the noban permission) if it is our only sync peer,\n                     // and we have others we could be using instead.\n                     // Note: If all our peers are inbound, then we won't\n                     // disconnect our sync peer for stalling; we have bigger\n@@ -4276,7 +4277,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         pto->fDisconnect = true;\n                         return true;\n                     } else {\n-                        LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());\n+                        LogPrintf(\"Timeout downloading headers from noban peer=%d, not disconnecting\\n\", pto->GetId());\n                         // Reset the headers sync state so that we have a\n                         // chance to try downloading from a different peer.\n                         // Note: this will also result in at least one more"
      },
      {
        "sha": "c6c78a983ac65b696cd42501b25839fb027e66c9",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -798,10 +798,8 @@ static CBlock GetBlockChecked(const CBlockIndex* pblockindex)\n \n     if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n         // Block not found on disk. This could be because we have the block\n-        // header in our index but don't have the block (for example if a\n-        // non-whitelisted node sends us an unrequested long chain of valid\n-        // blocks, we add the headers to our index, but don't accept the\n-        // block).\n+        // header in our index but not yet have the block or did not accept the\n+        // block.\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not found on disk\");\n     }\n "
      },
      {
        "sha": "ea3e633cc27c048b5e37951ef5ee6e3afdfd89e5",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -383,7 +383,7 @@ BOOST_AUTO_TEST_CASE(netpermissions_test)\n     BOOST_CHECK(!NetWhitebindPermissions::TryParse(\"bloom,forcerelay,oopsie@1.2.3.4:32\", whitebindPermissions, error));\n     BOOST_CHECK(error.original.find(\"Invalid P2P permission\") != std::string::npos);\n \n-    // Check whitelist error\n+    // Check netmask error\n     BOOST_CHECK(!NetWhitelistPermissions::TryParse(\"bloom,forcerelay,noban@1.2.3.4:32\", whitelistPermissions, error));\n     BOOST_CHECK(error.original.find(\"Invalid netmask specified in -whitelist\") != std::string::npos);\n "
      },
      {
        "sha": "9b49627135bae6d329cabc2234a9b5a831be47aa",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -845,7 +845,7 @@ class ChainstateManager\n      * validationinterface callback.\n      *\n      * @param[in]   pblock  The block we want to process.\n-     * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n+     * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources.\n      * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n      * @returns     If the block was processed, independently of block validity\n      */"
      },
      {
        "sha": "f42a3430420507aae1c146b4b5d91ebd0fd81558",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -57,10 +57,10 @@ def run_test(self):\n             self.nodes[0].p2p.wait_for_tx(txid)\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 1)\n \n-        self.log.info('Check that txs from whitelisted peers are not rejected and relayed to others')\n-        self.log.info(\"Restarting node 0 with whitelist permission and blocksonly\")\n+        self.log.info('Check that txs from forcerelay peers are not rejected and relayed to others')\n+        self.log.info(\"Restarting node 0 with forcerelay permission and blocksonly\")\n         self.restart_node(0, [\"-persistmempool=0\", \"-whitelist=127.0.0.1\", \"-whitelistforcerelay\", \"-blocksonly\"])\n-        assert_equal(self.nodes[0].getrawmempool(),[])\n+        assert_equal(self.nodes[0].getrawmempool(), [])\n         first_peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         second_peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         peer_1_info = self.nodes[0].getpeerinfo()[0]\n@@ -72,14 +72,15 @@ def run_test(self):\n         assert_equal(self.nodes[0].testmempoolaccept([sigtx])[0]['allowed'], True)\n         txid = self.nodes[0].testmempoolaccept([sigtx])[0]['txid']\n \n-        self.log.info('Check that the tx from whitelisted first_peer is relayed to others (ie.second_peer)')\n+        self.log.info('Check that the tx from forcerelay first_peer is relayed to others (ie.second_peer)')\n         with self.nodes[0].assert_debug_log([\"received getdata\"]):\n             first_peer.send_message(msg_tx(FromHex(CTransaction(), sigtx)))\n-            self.log.info('Check that the whitelisted peer is still connected after sending the transaction')\n+            self.log.info('Check that the forcerelay peer is still connected after sending the transaction')\n             assert_equal(first_peer.is_connected, True)\n             second_peer.wait_for_tx(txid)\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 1)\n-        self.log.info(\"Whitelisted peer's transaction is accepted and relayed\")\n+        self.log.info(\"Forcerelay peer's transaction is accepted and relayed\")\n+\n \n if __name__ == '__main__':\n     P2PBlocksOnly().main()"
      },
      {
        "sha": "32a795e3453d356bb9d4e2a1685fcb3b7c9dec16",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -108,9 +108,9 @@ def check_tx_relay(self):\n         block_op_true = self.nodes[0].getblock(self.nodes[0].generatetoaddress(100, ADDRESS_BCRT1_P2WSH_OP_TRUE)[0])\n         self.sync_all()\n \n-        self.log.debug(\"Create a connection from a whitelisted wallet that rebroadcasts raw txs\")\n+        self.log.debug(\"Create a connection from a forcerelay peer that rebroadcasts raw txs\")\n         # A python mininode is needed to send the raw transaction directly. If a full node was used, it could only\n-        # rebroadcast via the inv-getdata mechanism. However, even for whitelisted connections, a full node would\n+        # rebroadcast via the inv-getdata mechanism. However, even for forcerelay connections, a full node would\n         # currently not request a txid that is already in the mempool.\n         self.restart_node(1, extra_args=[\"-whitelist=forcerelay@127.0.0.1\"])\n         p2p_rebroadcast_wallet = self.nodes[1].add_p2p_connection(P2PDataStore())\n@@ -135,7 +135,7 @@ def check_tx_relay(self):\n \n         self.log.debug(\"Check that node[1] will send the tx to node[0] even though it is already in the mempool\")\n         connect_nodes(self.nodes[1], 0)\n-        with self.nodes[1].assert_debug_log([\"Force relaying tx {} from whitelisted peer=0\".format(txid)]):\n+        with self.nodes[1].assert_debug_log([\"Force relaying tx {} from peer=0\".format(txid)]):\n             p2p_rebroadcast_wallet.send_txs_and_test([tx], self.nodes[1])\n             wait_until(lambda: txid in self.nodes[0].getrawmempool())\n \n@@ -146,7 +146,7 @@ def check_tx_relay(self):\n             [tx],\n             self.nodes[1],\n             success=False,\n-            reject_reason='Not relaying non-mempool transaction {} from whitelisted peer=0'.format(txid),\n+            reject_reason='Not relaying non-mempool transaction {} from forcerelay peer=0'.format(txid),\n         )\n \n     def checkpermission(self, args, expectedPermissions, whitelisted):"
      },
      {
        "sha": "71b0b0f63a18a5eb8e210da970048a7e8668f438",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 2,
        "deletions": 10,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab558612278909df93bdf88f5727b04f13aef0f/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab558612278909df93bdf88f5727b04f13aef0f/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=fab558612278909df93bdf88f5727b04f13aef0f",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test processing of unrequested blocks.\n \n-Setup: two nodes, node0+node1, not connected to each other. Node1 will have\n+Setup: two nodes, node0 + node1, not connected to each other. Node1 will have\n nMinimumChainWork set to 0x10, so it won't process low-work unrequested blocks.\n \n We have one P2PInterface connection to node0 called test_node, and one to node1\n@@ -71,18 +71,10 @@ def set_test_params(self):\n         self.extra_args = [[], [\"-minimumchainwork=0x10\"]]\n \n     def setup_network(self):\n-        # Node0 will be used to test behavior of processing unrequested blocks\n-        # from peers which are not whitelisted, while Node1 will be used for\n-        # the whitelisted case.\n-        # Node2 will be used for non-whitelisted peers to test the interaction\n-        # with nMinimumChainWork.\n         self.setup_nodes()\n \n     def run_test(self):\n-        # Setup the p2p connections\n-        # test_node connects to node0 (not whitelisted)\n         test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n-        # min_work_node connects to node1 (whitelisted)\n         min_work_node = self.nodes[1].add_p2p_connection(P2PInterface())\n \n         # 1. Have nodes mine a block (leave IBD)\n@@ -226,7 +218,7 @@ def run_test(self):\n         self.nodes[0].getblock(all_blocks[286].hash)\n         assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[287].hash)\n-        self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n+        self.log.info(\"Successfully reorged to longer chain\")\n \n         # 8. Create a chain which is invalid at a height longer than the\n         # current chain, but which has more blocks on top of that"
      }
    ]
  }
]