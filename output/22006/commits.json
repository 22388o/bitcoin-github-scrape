[
  {
    "sha": "84ace9aef116a05e034730f2bb2f109d1d77aac7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NGFjZTlhZWYxMTZhMDVlMDM0NzMwZjJiYjJmMTA5ZDFkNzdhYWM3",
    "commit": {
      "author": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-05-20T13:21:34Z"
      },
      "committer": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-07-27T14:32:01Z"
      },
      "message": "doc: Add initial USDT documentation\n\nBoth added files are extended in the following commits.\n\ndoc/usdt.md is based on earlier work by laanwj.\n\nCo-authored-by: W. J. van der Laan <laanwj@protonmail.com>",
      "tree": {
        "sha": "edc6fe1bf43e7ce91de13b3d3e4cf5b25db0e83f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/edc6fe1bf43e7ce91de13b3d3e4cf5b25db0e83f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/84ace9aef116a05e034730f2bb2f109d1d77aac7",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDMuq/Xai7OLM0xQd4v/VsdiMqX0FAmEAGOEACgkQ4v/VsdiM\nqX1ujw//WuGOVdRRNMA3icDA6nXcCEgoGX8I1afXMFZyPnxhmVFGnWRukCnHXsm7\n2nPPhx464EAIbEOwB9a85xK9FuwQ4tX5V1P8EoW/Z6SWkX3EGFACT9VueT6lPzXd\nXCHMl62xxUbZKziduea+/nEl8SYlN+q8SW/3roalsH8cNjFj0OESmWN9AMfSyn0V\nRoVE4LWqf7RLLL2+LqNkIJaOJsWHpDxFd+1zi27hggIy5rapkh3MevmoQs1Lz8yc\nzI0bOZqVAmVci2NAZmSJ8NPb9yNRSdDA9nO+czyfyQWTbXnUzDFztN9lSPA8PumS\n/O1GxS3zdQvDcwbDmrHGsqW7yxvzIBhn5Psf5AlNRgPhRYwZYtAGoFUnz1OipHZs\nb4YheEmrXVATj7Wt7oPBWGqJmCNjvu+y7WTXdqUmj+oPyyKbGgp+Pmr8aoLmWaxI\nhseDgiD2BfahudtIyoc/73RwAgU/PiNuEjbonlS8+iLl0Sx1FBqWI5BjjQvDIID/\nAKz3St6rZAy6QYEiuHAvCLHikMTocdtjglRSlDdhGI0EjcscQ4uI1VY8XsIztvO0\nkRxShAO1oCJ5IXz/C5QkAeU1bOKQvhn/oMBvQG9N+BmHr4aEdRwAE/hAwKWP417W\nuGR6I0psHCq9FWpD6YDR/iUGG6cXRfZU21n59dM/d75b4IFYwqM=\n=WTbS\n-----END PGP SIGNATURE-----",
        "payload": "tree edc6fe1bf43e7ce91de13b3d3e4cf5b25db0e83f\nparent 979f410e69a0350da8bf67f329f760d4dd3a4f44\nauthor 0xb10c <0xb10c@gmail.com> 1621516894 +0200\ncommitter 0xb10c <0xb10c@gmail.com> 1627396321 +0200\n\ndoc: Add initial USDT documentation\n\nBoth added files are extended in the following commits.\n\ndoc/usdt.md is based on earlier work by laanwj.\n\nCo-authored-by: W. J. van der Laan <laanwj@protonmail.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84ace9aef116a05e034730f2bb2f109d1d77aac7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/84ace9aef116a05e034730f2bb2f109d1d77aac7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84ace9aef116a05e034730f2bb2f109d1d77aac7/comments",
    "author": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "979f410e69a0350da8bf67f329f760d4dd3a4f44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/979f410e69a0350da8bf67f329f760d4dd3a4f44",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/979f410e69a0350da8bf67f329f760d4dd3a4f44"
      }
    ],
    "stats": {
      "total": 249,
      "additions": 249,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e4da7247506d0cfeaa80fd1fe4d16b75c686c241",
        "filename": "contrib/tracing/README.md",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84ace9aef116a05e034730f2bb2f109d1d77aac7/contrib/tracing/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84ace9aef116a05e034730f2bb2f109d1d77aac7/contrib/tracing/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/README.md?ref=84ace9aef116a05e034730f2bb2f109d1d77aac7",
        "patch": "@@ -0,0 +1,45 @@\n+Example scripts for User-space, Statically Defined Tracing (USDT)\n+=================================================================\n+\n+This directory contains scripts showcasing User-space, Statically Defined\n+Tracing (USDT) support for Bitcoin Core on Linux using. For more information on\n+USDT support in Bitcoin Core see the [USDT documentation].\n+\n+[USDT documentation]: ../../doc/tracing.md\n+\n+\n+Examples for the two main eBPF front-ends, [bpftrace] and\n+[BPF Compiler Collection (BCC)], with support for USDT, are listed. BCC is used\n+for complex tools and daemons and `bpftrace` is preferred for one-liners and\n+shorter scripts.\n+\n+[bpftrace]: https://github.com/iovisor/bpftrace\n+[BPF Compiler Collection (BCC)]: https://github.com/iovisor/bcc\n+\n+\n+To develop and run bpftrace and BCC scripts you need to install the\n+corresponding packages. See [installing bpftrace] and [installing BCC] for more\n+information. For development there exist a [bpftrace Reference Guide], a\n+[BCC Reference Guide], and a [bcc Python Developer Tutorial].\n+\n+[installing bpftrace]: https://github.com/iovisor/bpftrace/blob/master/INSTALL.md\n+[installing BCC]: https://github.com/iovisor/bcc/blob/master/INSTALL.md\n+[bpftrace Reference Guide]: https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md\n+[BCC Reference Guide]: https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md\n+[bcc Python Developer Tutorial]: https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md\n+\n+## Examples\n+\n+The bpftrace examples contain a relative path to the `bitcoind` binary. By\n+default, the scripts should be run from the repository-root and assume a\n+self-compiled `bitcoind` binary. The paths in the examples can be changed, for\n+example, to point to release builds if needed. See the\n+[Bitcoin Core USDT documentation] on how to list available tracepoints in your\n+`bitcoind` binary.\n+\n+[Bitcoin Core USDT documentation]: ../../doc/tracing.md#listing-available-tracepoints\n+\n+**WARNING: eBPF programs require root privileges to be loaded into a Linux\n+kernel VM. This means the bpftrace and BCC examples must be executed with root\n+privileges. Make sure to carefully review any scripts that you run with root\n+privileges first!**"
      },
      {
        "sha": "4c472b41547f9253fe88f449d182d8dbec0b2616",
        "filename": "doc/tracing.md",
        "status": "added",
        "additions": 204,
        "deletions": 0,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/84ace9aef116a05e034730f2bb2f109d1d77aac7/doc/tracing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/84ace9aef116a05e034730f2bb2f109d1d77aac7/doc/tracing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tracing.md?ref=84ace9aef116a05e034730f2bb2f109d1d77aac7",
        "patch": "@@ -0,0 +1,204 @@\n+# User-space, Statically Defined Tracing (USDT) for Bitcoin Core\n+\n+Bitcoin Core includes statically defined tracepoints to allow for more\n+observability during development, debugging, code review, and production usage.\n+These tracepoints make it possible to keep track of custom statistics and\n+enable detailed monitoring of otherwise hidden internals. They have\n+little to no performance impact when unused.\n+\n+```\n+eBPF and USDT Overview\n+======================\n+\n+                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                \u2502 tracing script   \u2502            \u2502 bitcoind     \u2502\n+                \u2502==================\u2502      2.    \u2502==============\u2502\n+                \u2502  eBPF  \u2502 tracing \u2502      hooks \u2502              \u2502\n+                \u2502  code  \u2502 logic   \u2502      into\u250c\u2500\u2524\u25batracepoint 1\u2500\u253c\u2500\u2500\u2500\u2510 3.\n+                \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2534\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u251c\u2500\u2524\u25batracepoint 2 \u2502   \u2502 pass args\n+            1.       \u2502      \u2502 4.              \u2502 \u2502 ...          \u2502   \u2502 to eBPF\n+    User    compiles \u2502      \u2502 pass data to    \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502 program\n+    Space    & loads \u2502      \u2502 tracing script  \u2502                    \u2502\n+    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\n+    Kernel           \u2502      \u2502                 \u2502                    \u2502\n+    Space       \u250c\u2500\u2500\u252c\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                \u2502  \u2502  eBPF program                         \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+                \u2502 eBPF kernel Virtual Machine (sandboxed)  \u2502\n+                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+1. The tracing script compiles the eBPF code and loads the eBPF program into a kernel VM\n+2. The eBPF program hooks into one or more tracepoints\n+3. When the tracepoint is called, the arguments are passed to the eBPF program\n+4. The eBPF program processes the arguments and returns data to the tracing script\n+```\n+\n+The Linux kernel can hook into the tracepoints during runtime and pass data to\n+sandboxed [eBPF] programs running in the kernel. These eBPF programs can, for\n+example, collect statistics or pass data back to user-space scripts for further\n+processing.\n+\n+[eBPF]: https://ebpf.io/\n+\n+The two main eBPF front-ends with support for USDT are [bpftrace] and\n+[BPF Compiler Collection (BCC)]. BCC is used for complex tools and daemons and\n+`bpftrace` is preferred for one-liners and shorter scripts. Examples for both can\n+be found in [contrib/tracing].\n+\n+[bpftrace]: https://github.com/iovisor/bpftrace\n+[BPF Compiler Collection (BCC)]: https://github.com/iovisor/bcc\n+[contrib/tracing]: ../contrib/tracing/\n+\n+## Tracepoint documentation\n+\n+The currently available tracepoints are listed here.\n+\n+## Adding tracepoints to Bitcoin Core\n+\n+To add a new tracepoint, `#include <util/trace.h>` in the compilation unit where\n+the tracepoint is inserted. Use one of the `TRACEx` macros listed below\n+depending on the number of arguments passed to the tracepoint. Up to 12\n+arguments can be provided. The `context` and `event` specify the names by which\n+the tracepoint is referred to. Please use `snake_case` and try to make sure that\n+the tracepoint names make sense even without detailed knowledge of the\n+implementation details. Do not forget to update the tracepoint list in this\n+document.\n+\n+```c\n+#define TRACE(context, event)\n+#define TRACE1(context, event, a)\n+#define TRACE2(context, event, a, b)\n+#define TRACE3(context, event, a, b, c)\n+#define TRACE4(context, event, a, b, c, d)\n+#define TRACE5(context, event, a, b, c, d, e)\n+#define TRACE6(context, event, a, b, c, d, e, f)\n+#define TRACE7(context, event, a, b, c, d, e, f, g)\n+#define TRACE8(context, event, a, b, c, d, e, f, g, h)\n+#define TRACE9(context, event, a, b, c, d, e, f, g, h, i)\n+#define TRACE10(context, event, a, b, c, d, e, f, g, h, i, j)\n+#define TRACE11(context, event, a, b, c, d, e, f, g, h, i, j, k)\n+#define TRACE12(context, event, a, b, c, d, e, f, g, h, i, j, k, l)\n+```\n+\n+For example:\n+\n+```C++\n+TRACE6(net, inbound_message,\n+    pnode->GetId(),\n+    pnode->GetAddrName().c_str(),\n+    pnode->ConnectionTypeAsString().c_str(),\n+    sanitizedType.c_str(),\n+    msg.data.size(),\n+    msg.data.data()\n+);\n+```\n+\n+### Guidelines and best practices\n+\n+#### Clear motivation and use-case\n+Tracepoints need a clear motivation and use-case. The motivation should\n+outweigh the impact on, for example, code readability. There is no point in\n+adding tracepoints that don't end up being used.\n+\n+#### Provide an example\n+When adding a new tracepoint, provide an example. Examples can show the use case\n+and help reviewers testing that the tracepoint works as intended. The examples\n+can be kept simple but should give others a starting point when working with\n+the tracepoint. See existing examples in [contrib/tracing/].\n+\n+[contrib/tracing/]: ../contrib/tracing/\n+\n+#### No expensive computations for tracepoints\n+Data passed to the tracepoint should be inexpensive to compute. Although the\n+tracepoint itself only has overhead when enabled, the code to compute arguments\n+is always run - even if the tracepoint is not used. For example, avoid\n+serialization and parsing.\n+\n+#### Semi-stable API\n+Tracepoints should have a semi-stable API. Users should be able to rely on the\n+tracepoints for scripting. This means tracepoints need to be documented, and the\n+argument order ideally should not change. If there is an important reason to\n+change argument order, make sure to document the change and update the examples\n+using the tracepoint.\n+\n+#### eBPF Virtual Machine limits\n+Keep the eBPF Virtual Machine limits in mind. eBPF programs receiving data from\n+the tracepoints run in a sandboxed Linux kernel VM. This VM has a limited stack\n+size of 512 bytes. Check if it makes sense to pass larger amounts of data, for\n+example, with a tracing script that can handle the passed data.\n+\n+#### `bpftrace` argument limit\n+While tracepoints can have up to 12 arguments, bpftrace scripts currently only\n+support reading from the first six arguments (`arg0` till `arg5`) on `x86_64`.\n+bpftrace currently lacks real support for handling and printing binary data,\n+like block header hashes and txids. When a tracepoint passes more than six\n+arguments, then string and integer arguments should preferably be placed in the\n+first six argument fields. Binary data can be placed in later arguments. The BCC\n+supports reading from all 12 arguments.\n+\n+#### Strings as C-style String\n+Generally, strings should be passed into the `TRACEx` macros as pointers to\n+C-style strings (a null-terminated sequence of characters). For C++\n+`std::strings`, [`c_str()`]  can be used. It's recommended to document the\n+maximum expected string size if known.\n+\n+\n+[`c_str()`]: https://www.cplusplus.com/reference/string/string/c_str/\n+\n+\n+## Listing available tracepoints\n+\n+Multiple tools can list the available tracepoints in a `bitcoind` binary with\n+USDT support.\n+\n+### GDB - GNU Project Debugger\n+\n+To list probes in Bitcoin Core, use `info probes` in `gdb`:\n+\n+```\n+$ gdb ./src/bitcoind\n+\u2026\n+(gdb) info probes\n+Type Provider   Name             Where              Semaphore Object\n+stap net        inbound_message  0x000000000014419e /src/bitcoind\n+stap net        outbound_message 0x0000000000107c05 /src/bitcoind\n+stap validation block_connected  0x00000000002fb10c /src/bitcoind\n+\u2026\n+```\n+\n+### With `readelf`\n+\n+The `readelf` tool can be used to display the USDT tracepoints in Bitcoin Core.\n+Look for the notes with the description `NT_STAPSDT`.\n+\n+```\n+$ readelf -n ./src/bitcoind | grep NT_STAPSDT -A 4 -B 2\n+Displaying notes found in: .note.stapsdt\n+  Owner                 Data size\tDescription\n+  stapsdt              0x0000005d\tNT_STAPSDT (SystemTap probe descriptors)\n+    Provider: net\n+    Name: outbound_message\n+    Location: 0x0000000000107c05, Base: 0x0000000000579c90, Semaphore: 0x0000000000000000\n+    Arguments: -8@%r12 8@%rbx 8@%rdi 8@192(%rsp) 8@%rax 8@%rdx\n+\u2026\n+```\n+\n+### With `tplist`\n+\n+The `tplist` tool is provided by BCC (see [Installing BCC]). It displays kernel\n+tracepoints or USDT probes and their formats (for more information, see the\n+[`tplist` usage demonstration]). There are slight binary naming differences\n+between distributions. For example, on\n+[Ubuntu the binary is called `tplist-bpfcc`][ubuntu binary].\n+\n+[Installing BCC]: https://github.com/iovisor/bcc/blob/master/INSTALL.md\n+[`tplist` usage demonstration]: https://github.com/iovisor/bcc/blob/master/tools/tplist_example.txt\n+[ubuntu binary]: https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary\n+\n+```\n+$ tplist -l ./src/bitcoind -v\n+b'net':b'outbound_message' [sema 0x0]\n+  1 location(s)\n+  6 argument(s)\n+\u2026\n+```"
      }
    ]
  },
  {
    "sha": "469b71ae629228b2591a55831817a0e5fad89360",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NjliNzFhZTYyOTIyOGIyNTkxYTU1ODMxODE3YTBlNWZhZDg5MzYw",
    "commit": {
      "author": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-06-07T16:24:11Z"
      },
      "committer": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-07-27T14:33:43Z"
      },
      "message": "doc: document systemtap dependency",
      "tree": {
        "sha": "3d69657c188d55829c52084a56ed6a22ee59c04d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d69657c188d55829c52084a56ed6a22ee59c04d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/469b71ae629228b2591a55831817a0e5fad89360",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDMuq/Xai7OLM0xQd4v/VsdiMqX0FAmEAGUoACgkQ4v/VsdiM\nqX1NaQ//TZg+TzzxWWczvBmVLcISbq0vGYtkygXGo05Jd3UXKJXjjcyLlKJjn85d\nuoBNkOc+94fAGLsb2GhAaARdoJjtXozFDjQTrha7uUZQ51ufc/KxIYZ6NT4JSsBw\n7fiO87yxfaq2vxEb16cJ1iX7fBQqlHMa1YUKJn4wu/f5krdpz/rEAm1UxTEm99r3\nmdseSpPrYumersuDDEoL5LC4cDJF53VgHW685dy4XjPG6b1LbgwfCv81NCUp75F2\nH3+6I6LfzGy/iGz+gQvylLBCYjGs9t/XLPlh1VrsU3N5ZZf/lBkz+ycO1mH07FAP\nm9Lk/pK/IXguzcaI3IT3IBZpRETQHPFeBhqgQy1qk/UEuXaclf/mab5DoDGEqrJ+\ntsYmyZ8D4c33+Cxdhp5HmWgSAq4Fn6iMjk6h09Ces3NKqNwSQ0910tmi9aSN2/cm\nOoHZmC+TvfchkWRRj6agwg5NKu5lQFnKWGPv/UVvw8HkGMVS8L7PeBVU2/lgOPa4\nfA8OyGC3kSkmQvEr6tL0/j55xKL/39X+lUznY8wkzhhoXqMEHgDHkMl9o+pBWg3m\nTus4gjSRd05+MLDpRbl4ol/gSBRmGn1kdbiKTLScgd29I+WKMrxUy46n0PoZE4aE\n+1zq+puEBScARQJrDI+qccv4Jk28KzkzchYQiorzvBN9W5trfNk=\n=ykOw\n-----END PGP SIGNATURE-----",
        "payload": "tree 3d69657c188d55829c52084a56ed6a22ee59c04d\nparent 84ace9aef116a05e034730f2bb2f109d1d77aac7\nauthor 0xb10c <0xb10c@gmail.com> 1623083051 +0200\ncommitter 0xb10c <0xb10c@gmail.com> 1627396423 +0200\n\ndoc: document systemtap dependency\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/469b71ae629228b2591a55831817a0e5fad89360",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/469b71ae629228b2591a55831817a0e5fad89360",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/469b71ae629228b2591a55831817a0e5fad89360/comments",
    "author": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "84ace9aef116a05e034730f2bb2f109d1d77aac7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/84ace9aef116a05e034730f2bb2f109d1d77aac7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/84ace9aef116a05e034730f2bb2f109d1d77aac7"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 11,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4a56114109e49e2a80d8e7a1db260871a7b1f303",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/469b71ae629228b2591a55831817a0e5fad89360/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/469b71ae629228b2591a55831817a0e5fad89360/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=469b71ae629228b2591a55831817a0e5fad89360",
        "patch": "@@ -48,6 +48,7 @@ Optional dependencies:\n  univalue    | Utility          | JSON parsing and encoding (bundled version will be used unless --with-system-univalue passed to configure)\n  libzmq3     | ZMQ notification | Optional, allows generating ZMQ notifications (requires ZMQ version >= 4.0.0)\n  sqlite3     | SQLite DB        | Optional, wallet storage (only needed when wallet enabled)\n+ systemtap   | Tracing (USDT)   | Optional, statically defined tracepoints\n \n For the versions used, see [dependencies.md](dependencies.md)\n \n@@ -107,6 +108,10 @@ ZMQ dependencies (provides ZMQ API):\n \n     sudo apt-get install libzmq3-dev\n \n+User-Space, Statically Defined Tracing (USDT) dependencies:\n+\n+    sudo apt install systemtap-sdt-dev\n+\n GUI dependencies:\n \n If you want to build bitcoin-qt, make sure that the required packages for Qt development\n@@ -162,6 +167,10 @@ ZMQ dependencies (provides ZMQ API):\n \n     sudo dnf install zeromq-devel\n \n+User-Space, Statically Defined Tracing (USDT) dependencies:\n+\n+    sudo dnf install systemtap\n+\n GUI dependencies:\n \n If you want to build bitcoin-qt, make sure that the required packages for Qt development"
      },
      {
        "sha": "b7634718e8d61ae57593094308db27b6f95fb357",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/469b71ae629228b2591a55831817a0e5fad89360/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/469b71ae629228b2591a55831817a0e5fad89360/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=469b71ae629228b2591a55831817a0e5fad89360",
        "patch": "@@ -24,6 +24,7 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | Qt | [5.12.11](https://download.qt.io/official_releases/qt/) | [5.9.5](https://github.com/bitcoin/bitcoin/issues/20104) | No |  |  |\n | SQLite | [3.32.1](https://sqlite.org/download.html) | [3.7.17](https://github.com/bitcoin/bitcoin/pull/19077) |  |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Linux only) |\n+| systemtap ([tracing](tracing.md))|  |  |  |  | |\n | xkbcommon |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Linux only) |\n | ZeroMQ | [4.3.1](https://github.com/zeromq/libzmq/releases) | 4.0.0 | No |  |  |\n | zlib |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n@@ -41,6 +42,7 @@ Some dependencies are not needed in all configurations. The following are some f\n * SQLite is not needed with `--disable-wallet` or `--without-sqlite`.\n * Qt is not needed with `--without-gui`.\n * If the qrencode dependency is absent, QR support won't be added. To force an error when that happens, pass `--with-qrencode`.\n+* If the systemtap dependency is absent, USDT support won't compiled in.\n * ZeroMQ is needed only with the `--with-zmq` option.\n \n #### Other"
      }
    ]
  },
  {
    "sha": "4224dec22baa66547303840707cf1d4f15a49b20",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MjI0ZGVjMjJiYWE2NjU0NzMwMzg0MDcwN2NmMWQ0ZjE1YTQ5YjIw",
    "commit": {
      "author": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-05-20T14:54:54Z"
      },
      "committer": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-07-27T15:12:16Z"
      },
      "message": "tracing: Tracepoints for in- and outbound P2P msgs\n\nCan be used to monitor in- and outbound node traffic.\n\nBased on ealier work by jb55.\n\nCo-authored-by: William Casarin <jb55@jb55.com>",
      "tree": {
        "sha": "467d8bc70b3a3d3ada1fc4a2281ff2725031f09d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/467d8bc70b3a3d3ada1fc4a2281ff2725031f09d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4224dec22baa66547303840707cf1d4f15a49b20",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDMuq/Xai7OLM0xQd4v/VsdiMqX0FAmEAIlMACgkQ4v/VsdiM\nqX0sPQ/9HCES1MEfflo2nuulzZdCt8SwX1QLtTYmpcR069bDlF/MLqVZEjOA3E3e\nWETYEZs0Qw9asXMiXp9TOYglUtFZYQG70vEHfwVeHDWr9Gm35NNoRtSe0jiXIW85\nN2swchDNZZzBie5NX0zHK2rBuQ7OlYDRCuPvkyNdY53eRo/QChj7k4OHHPmrnMAX\nYixyaaxaYh0wq1mgG8E2McD9ASB+eGap6Bs6gv6EWcoXdOzzzv/F55uMFYnzbzRo\n1WST+ov170LOj/x+Je4UAss3i+AzqnAPThjZ8o838i4aeX7s704nv9RdZxXsUime\nMvUbaYvFu2G6N71mliLyRcFuiH64XJT/KSdnnaqi3+ZtvEzwequc4EK327SNTZIX\nJDiZJHglWYFtwgNvS5CLdTteIjwYoq9HUKAPCT6/w4KZaEHH0S3+GJ2G7qsmZyze\nbWavPoTjjp3puSwsrjyZnJCDj6lgMPjo/V+psBB24Rrr7s7iRnsTuKlym1NJ3qd0\nHm9G+5YNZSURzDXyyVjhyk3xxOSgWDoKKap+EFSK6AkxgxPZW16dwr98a6pdc6bg\n5lySSjVxqnT7426OnpiSJd/l9E8Vw9nXS/hvQIzevoldKgbY701xIUiFhvZTMKDf\ngL7C/XIwK3X7ZmR8MNx1UjkcYX+sRSmFwZn259tmJnJMpn7bqVI=\n=ok2r\n-----END PGP SIGNATURE-----",
        "payload": "tree 467d8bc70b3a3d3ada1fc4a2281ff2725031f09d\nparent 469b71ae629228b2591a55831817a0e5fad89360\nauthor 0xb10c <0xb10c@gmail.com> 1621522494 +0200\ncommitter 0xb10c <0xb10c@gmail.com> 1627398736 +0200\n\ntracing: Tracepoints for in- and outbound P2P msgs\n\nCan be used to monitor in- and outbound node traffic.\n\nBased on ealier work by jb55.\n\nCo-authored-by: William Casarin <jb55@jb55.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4224dec22baa66547303840707cf1d4f15a49b20",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4224dec22baa66547303840707cf1d4f15a49b20",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4224dec22baa66547303840707cf1d4f15a49b20/comments",
    "author": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "469b71ae629228b2591a55831817a0e5fad89360",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/469b71ae629228b2591a55831817a0e5fad89360",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/469b71ae629228b2591a55831817a0e5fad89360"
      }
    ],
    "stats": {
      "total": 640,
      "additions": 639,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2d81e375dc55953e7f677fa7eba2211c528c3417",
        "filename": "contrib/tracing/README.md",
        "status": "modified",
        "additions": 120,
        "deletions": 0,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/README.md?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -43,3 +43,123 @@ example, to point to release builds if needed. See the\n kernel VM. This means the bpftrace and BCC examples must be executed with root\n privileges. Make sure to carefully review any scripts that you run with root\n privileges first!**\n+\n+### log_p2p_traffic.bt\n+\n+A bpftrace script logging information about inbound and outbound P2P network\n+messages. Based on the `net:inbound_message` and `net:outbound_message`\n+tracepoints.\n+\n+By default, `bpftrace` limits strings to 64 bytes due to the limited stack size\n+in the eBPF VM. For example, Tor v3 addresses exceed the string size limit which\n+results in the port being cut off during logging. The string size limit can be\n+increased with the `BPFTRACE_STRLEN` environment variable (`BPFTRACE_STRLEN=70`\n+works fine).\n+\n+```\n+$ bpftrace contrib/tracing/log_p2p_traffic.bt\n+```\n+\n+Output\n+```\n+outbound 'ping' msg to peer 11 (outbound-full-relay, [2a02:b10c:f747:1:ef:fake:ipv6:addr]:8333) with 8 bytes\n+inbound 'pong' msg from peer 11 (outbound-full-relay, [2a02:b10c:f747:1:ef:fake:ipv6:addr]:8333) with 8 bytes\n+inbound 'inv' msg from peer 16 (outbound-full-relay, XX.XX.XXX.121:8333) with 37 bytes\n+outbound 'getdata' msg to peer 16 (outbound-full-relay, XX.XX.XXX.121:8333) with 37 bytes\n+inbound 'tx' msg from peer 16 (outbound-full-relay, XX.XX.XXX.121:8333) with 222 bytes\n+outbound 'inv' msg to peer 9 (outbound-full-relay, faketorv3addressa2ufa6odvoi3s77j4uegey0xb10csyfyve2t33curbyd.onion:8333) with 37 bytes\n+outbound 'inv' msg to peer 7 (outbound-full-relay, XX.XX.XXX.242:8333) with 37 bytes\n+\u2026\n+```\n+\n+### p2p_monitor.py\n+\n+A BCC Python script using curses for an interactive P2P message monitor. Based\n+on the `net:inbound_message` and `net:outbound_message` tracepoints.\n+\n+Inbound and outbound traffic is listed for each peer together with information\n+about the connection. Peers can be selected individually to view recent P2P\n+messages.\n+\n+```\n+$ python3 contrib/tracing/p2p_monitor.py ./src/bitcoind\n+```\n+\n+Lists selectable peers and traffic and connection information.\n+```\n+ P2P Message Monitor\n+ Navigate with UP/DOWN or J/K and select a peer with ENTER or SPACE to see individual P2P messages\n+\n+ PEER  OUTBOUND              INBOUND               TYPE                   ADDR\n+    0  46          398 byte  61      1407590 byte  block-relay-only       XX.XX.XXX.196:8333\n+   11  1156     253570 byte  3431    2394924 byte  outbound-full-relay    XXX.X.XX.179:8333\n+   13  3425    1809620 byte  1236     305458 byte  inbound                XXX.X.X.X:60380\n+   16  1046     241633 byte  1589    1199220 byte  outbound-full-relay    4faketorv2pbfu7x.onion:8333\n+   19  577      181679 byte  390      148951 byte  outbound-full-relay    kfake4vctorjv2o2.onion:8333\n+   20  11         1248 byte  13         1283 byte  block-relay-only       [2600:fake:64d9:b10c:4436:aaaa:fe:bb]:8333\n+   21  11         1248 byte  13         1299 byte  block-relay-only       XX.XXX.X.155:8333\n+   22  5           103 byte  1           102 byte  feeler                 XX.XX.XXX.173:8333\n+   23  11         1248 byte  12         1255 byte  block-relay-only       XX.XXX.XXX.220:8333\n+   24  3           103 byte  1           102 byte  feeler                 XXX.XXX.XXX.64:8333\n+\u2026\n+```\n+\n+Showing recent P2P messages between our node and a selected peer.\n+\n+```\n+    ----------------------------------------------------------------------\n+    |                PEER 16 (4faketorv2pbfu7x.onion:8333)               |\n+    | OUR NODE                outbound-full-relay                   PEER |\n+    |                                           <--- sendcmpct (9 bytes) |\n+    | inv (37 byte) --->                                                 |\n+    |                                                <--- ping (8 bytes) |\n+    | pong (8 byte) --->                                                 |\n+    | inv (37 byte) --->                                                 |\n+    |                                               <--- addr (31 bytes) |\n+    | inv (37 byte) --->                                                 |\n+    |                                       <--- getheaders (1029 bytes) |\n+    | headers (1 byte) --->                                              |\n+    |                                           <--- feefilter (8 bytes) |\n+    |                                                <--- pong (8 bytes) |\n+    |                                            <--- headers (82 bytes) |\n+    |                                            <--- addr (30003 bytes) |\n+    | inv (1261 byte) --->                                               |\n+    |                                 \u2026                                  |\n+\n+```\n+\n+### log_raw_p2p_msgs.py\n+\n+A BCC Python script showcasing eBPF and USDT limitations when passing data\n+larger than about 32kb. Based on the `net:inbound_message` and\n+`net:outbound_message` tracepoints.\n+\n+Bitcoin P2P messages can be larger than 32kb (e.g. `tx`, `block`, ...). The\n+eBPF VM's stack is limited to 512 bytes, and we can't allocate more than about\n+32kb for a P2P message in the eBPF VM. The **message data is cut off** when the\n+message is larger than MAX_MSG_DATA_LENGTH (see script). This can be detected\n+in user-space by comparing the data length to the message length variable. The\n+message is cut off when the data length is smaller than the message length.\n+A warning is included with the printed message data.\n+\n+Data is submitted to user-space (i.e. to this script) via a ring buffer. The\n+throughput of the ring buffer is limited. Each p2p_message is about 32kb in\n+size. In- or outbound messages submitted to the ring buffer in rapid\n+succession fill the ring buffer faster than it can be read. Some messages are\n+lost. BCC prints: `Possibly lost 2 samples` on lost messages.\n+\n+\n+```\n+$ python3 contrib/tracing/log_raw_p2p_msgs.py ./src/bitcoind\n+```\n+\n+```\n+Logging raw P2P messages.\n+Messages larger that about 32kb will be cut off!\n+Some messages might be lost!\n+ outbound msg 'inv' from peer 4 (outbound-full-relay, XX.XXX.XX.4:8333) with 253 bytes: 0705000000be2245c8f844c9f763748e1a7\u2026\n+\u2026\n+Warning: incomplete message (only 32568 out of 53552 bytes)! inbound msg 'tx' from peer 32 (outbound-full-relay, XX.XXX.XXX.43:8333) with 53552 bytes: 020000000001fd3c01939c85ad6756ed9fc\u2026\n+\u2026\n+Possibly lost 2 samples\n+```"
      },
      {
        "sha": "f62956aa5e1c3d36844c762b620ec4d43f9ee764",
        "filename": "contrib/tracing/log_p2p_traffic.bt",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/log_p2p_traffic.bt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/log_p2p_traffic.bt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/log_p2p_traffic.bt?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -0,0 +1,28 @@\n+#!/usr/bin/env bpftrace\n+\n+BEGIN\n+{\n+  printf(\"Logging P2P traffic\\n\")\n+}\n+\n+usdt:./src/bitcoind:net:inbound_message\n+{\n+  $peer_id = (int64) arg0;\n+  $peer_addr = str(arg1);\n+  $peer_type = str(arg2);\n+  $msg_type = str(arg3);\n+  $msg_len = arg4;\n+  printf(\"inbound '%s' msg from peer %d (%s, %s) with %d bytes\\n\", $msg_type, $peer_id, $peer_type, $peer_addr, $msg_len);\n+}\n+\n+usdt:./src/bitcoind:net:outbound_message\n+{\n+  $peer_id = (int64) arg0;\n+  $peer_addr = str(arg1);\n+  $peer_type = str(arg2);\n+  $msg_type = str(arg3);\n+  $msg_len = arg4;\n+\n+  printf(\"outbound '%s' msg to peer %d (%s, %s) with %d bytes\\n\", $msg_type, $peer_id, $peer_type, $peer_addr, $msg_len);\n+}\n+"
      },
      {
        "sha": "b5b57556324e350b879bc60749338d442ea3f8b9",
        "filename": "contrib/tracing/log_raw_p2p_msgs.py",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/log_raw_p2p_msgs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/log_raw_p2p_msgs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/log_raw_p2p_msgs.py?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+\n+\"\"\" Demonstration of eBPF limitations and the effect on USDT with the\n+    net:inbound_message and net:outbound_message tracepoints. \"\"\"\n+\n+# This script shows a limitation of eBPF when data larger than 32kb is passed to\n+# user-space. It uses BCC (https://github.com/iovisor/bcc) to load a sandboxed\n+# eBPF program into the Linux kernel (root privileges are required). The eBPF\n+# program attaches to two statically defined tracepoints. The tracepoint\n+# 'net:inbound_message' is called when a new P2P message is received, and\n+# 'net:outbound_message' is called on outbound P2P messages. The eBPF program\n+# submits the P2P messages to this script via a BPF ring buffer. The submitted\n+# messages are printed.\n+\n+# eBPF Limitations:\n+#\n+# Bitcoin P2P messages can be larger than 32kb (e.g. tx, block, ...). The eBPF\n+# VM's stack is limited to 512 bytes, and we can't allocate more than about 32kb\n+# for a P2P message in the eBPF VM. The message data is cut off when the message\n+# is larger than MAX_MSG_DATA_LENGTH (see definition below). This can be detected\n+# in user-space by comparing the data length to the message length variable. The\n+# message is cut off when the data length is smaller than the message length.\n+# A warning is included with the printed message data.\n+#\n+# Data is submitted to user-space (i.e. to this script) via a ring buffer. The\n+# throughput of the ring buffer is limited. Each p2p_message is about 32kb in\n+# size. In- or outbound messages submitted to the ring buffer in rapid\n+# succession fill the ring buffer faster than it can be read. Some messages are\n+# lost.\n+#\n+# BCC prints: \"Possibly lost 2 samples\" on lost messages.\n+\n+import sys\n+from bcc import BPF, USDT\n+\n+# BCC: The C program to be compiled to an eBPF program (by BCC) and loaded into\n+# a sandboxed Linux kernel VM.\n+program = \"\"\"\n+#include <uapi/linux/ptrace.h>\n+\n+#define MIN(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b); _a < _b ? _a : _b; })\n+\n+// Maximum possible allocation size\n+// from include/linux/percpu.h in the Linux kernel\n+#define PCPU_MIN_UNIT_SIZE (32 << 10)\n+\n+// Tor v3 addresses are 62 chars + 6 chars for the port (':12345').\n+#define MAX_PEER_ADDR_LENGTH 62 + 6\n+#define MAX_PEER_CONN_TYPE_LENGTH 20\n+#define MAX_MSG_TYPE_LENGTH 20\n+#define MAX_MSG_DATA_LENGTH PCPU_MIN_UNIT_SIZE - 200\n+\n+struct p2p_message\n+{\n+    u64     peer_id;\n+    char    peer_addr[MAX_PEER_ADDR_LENGTH];\n+    char    peer_conn_type[MAX_PEER_CONN_TYPE_LENGTH];\n+    char    msg_type[MAX_MSG_TYPE_LENGTH];\n+    u64     msg_size;\n+    u8      msg[MAX_MSG_DATA_LENGTH];\n+};\n+\n+// We can't store the p2p_message struct on the eBPF stack as it is limited to\n+// 512 bytes and P2P message can be bigger than 512 bytes. However, we can use\n+// an BPF-array with a length of 1 to allocate up to 32768 bytes (this is\n+// defined by PCPU_MIN_UNIT_SIZE in include/linux/percpu.h in the Linux kernel).\n+// Also see https://github.com/iovisor/bcc/issues/2306\n+BPF_ARRAY(msg_arr, struct p2p_message, 1);\n+\n+// Two BPF perf buffers for pushing data (here P2P messages) to user-space.\n+BPF_PERF_OUTPUT(inbound_messages);\n+BPF_PERF_OUTPUT(outbound_messages);\n+\n+int trace_inbound_message(struct pt_regs *ctx) {\n+    int idx = 0;\n+    struct p2p_message *msg = msg_arr.lookup(&idx);\n+\n+    // lookup() does not return a NULL pointer. However, the BPF verifier\n+    // requires an explicit check that that the `msg` pointer isn't a NULL\n+    // pointer. See https://github.com/iovisor/bcc/issues/2595\n+    if (msg == NULL) return 1;\n+\n+    bpf_usdt_readarg(1, ctx, &msg->peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg->peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg->peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg->msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg->msg_size);\n+    bpf_usdt_readarg_p(6, ctx, &msg->msg, MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));\n+\n+    inbound_messages.perf_submit(ctx, msg, sizeof(*msg));\n+    return 0;\n+};\n+\n+int trace_outbound_message(struct pt_regs *ctx) {\n+    int idx = 0;\n+    struct p2p_message *msg = msg_arr.lookup(&idx);\n+\n+    // lookup() does not return a NULL pointer. However, the BPF verifier\n+    // requires an explicit check that that the `msg` pointer isn't a NULL\n+    // pointer. See https://github.com/iovisor/bcc/issues/2595\n+    if (msg == NULL) return 1;\n+\n+    bpf_usdt_readarg(1, ctx, &msg->peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg->peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg->peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg->msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg->msg_size);\n+    bpf_usdt_readarg_p(6, ctx, &msg->msg,  MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));\n+\n+    outbound_messages.perf_submit(ctx, msg, sizeof(*msg));\n+    return 0;\n+};\n+\"\"\"\n+\n+\n+def print_message(event, inbound):\n+    print(f\"%s %s msg '%s' from peer %d (%s, %s) with %d bytes: %s\" %\n+          (\n+              f\"Warning: incomplete message (only %d out of %d bytes)!\" % (\n+                  len(event.msg), event.msg_size) if len(event.msg) < event.msg_size else \"\",\n+              \"inbound\" if inbound else \"outbound\",\n+              event.msg_type.decode(\"utf-8\"),\n+              event.peer_id,\n+              event.peer_conn_type.decode(\"utf-8\"),\n+              event.peer_addr.decode(\"utf-8\"),\n+              event.msg_size,\n+              bytes(event.msg[:event.msg_size]).hex(),\n+          )\n+          )\n+\n+\n+def main(bitcoind_path):\n+    bitcoind_with_usdts = USDT(path=str(bitcoind_path))\n+\n+    # attaching the trace functions defined in the BPF program to the tracepoints\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"inbound_message\", fn_name=\"trace_inbound_message\")\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"outbound_message\", fn_name=\"trace_outbound_message\")\n+    bpf = BPF(text=program, usdt_contexts=[bitcoind_with_usdts])\n+\n+    # BCC: perf buffer handle function for inbound_messages\n+    def handle_inbound(_, data, size):\n+        \"\"\" Inbound message handler.\n+\n+        Called each time a message is submitted to the inbound_messages BPF table.\"\"\"\n+\n+        event = bpf[\"inbound_messages\"].event(data)\n+        print_message(event, True)\n+\n+    # BCC: perf buffer handle function for outbound_messages\n+\n+    def handle_outbound(_, data, size):\n+        \"\"\" Outbound message handler.\n+\n+        Called each time a message is submitted to the outbound_messages BPF table.\"\"\"\n+\n+        event = bpf[\"outbound_messages\"].event(data)\n+        print_message(event, False)\n+\n+    # BCC: add handlers to the inbound and outbound perf buffers\n+    bpf[\"inbound_messages\"].open_perf_buffer(handle_inbound)\n+    bpf[\"outbound_messages\"].open_perf_buffer(handle_outbound)\n+\n+    print(\"Logging raw P2P messages.\")\n+    print(\"Messages larger that about 32kb will be cut off!\")\n+    print(\"Some messages might be lost!\")\n+    while True:\n+        try:\n+            bpf.perf_buffer_poll()\n+        except KeyboardInterrupt:\n+            exit()\n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) < 2:\n+        print(\"USAGE:\", sys.argv[0], \"path/to/bitcoind\")\n+        exit()\n+    path = sys.argv[1]\n+    main(path)"
      },
      {
        "sha": "14e3e3a80123ad163f35000fa27b62835e02c992",
        "filename": "contrib/tracing/p2p_monitor.py",
        "status": "added",
        "additions": 250,
        "deletions": 0,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/p2p_monitor.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/contrib/tracing/p2p_monitor.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/p2p_monitor.py?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -0,0 +1,250 @@\n+#!/usr/bin/env python3\n+\n+\"\"\" Interactive bitcoind P2P network traffic monitor utilizing USDT and the\n+    net:inbound_message and net:outbound_message tracepoints. \"\"\"\n+\n+# This script demonstrates what USDT for Bitcoin Core can enable. It uses BCC\n+# (https://github.com/iovisor/bcc) to load a sandboxed eBPF program into the\n+# Linux kernel (root privileges are required). The eBPF program attaches to two\n+# statically defined tracepoints. The tracepoint 'net:inbound_message' is called\n+# when a new P2P message is received, and 'net:outbound_message' is called on\n+# outbound P2P messages. The eBPF program submits the P2P messages to\n+# this script via a BPF ring buffer.\n+\n+import sys\n+import curses\n+from curses import wrapper, panel\n+from bcc import BPF, USDT\n+\n+# BCC: The C program to be compiled to an eBPF program (by BCC) and loaded into\n+# a sandboxed Linux kernel VM.\n+program = \"\"\"\n+#include <uapi/linux/ptrace.h>\n+\n+// Tor v3 addresses are 62 chars + 6 chars for the port (':12345').\n+// I2P addresses are 60 chars + 6 chars for the port (':12345').\n+#define MAX_PEER_ADDR_LENGTH 62 + 6\n+#define MAX_PEER_CONN_TYPE_LENGTH 20\n+#define MAX_MSG_TYPE_LENGTH 20\n+\n+struct p2p_message\n+{\n+    u64     peer_id;\n+    char    peer_addr[MAX_PEER_ADDR_LENGTH];\n+    char    peer_conn_type[MAX_PEER_CONN_TYPE_LENGTH];\n+    char    msg_type[MAX_MSG_TYPE_LENGTH];\n+    u64     msg_size;\n+};\n+\n+\n+// Two BPF perf buffers for pushing data (here P2P messages) to user space.\n+BPF_PERF_OUTPUT(inbound_messages);\n+BPF_PERF_OUTPUT(outbound_messages);\n+\n+int trace_inbound_message(struct pt_regs *ctx) {\n+    struct p2p_message msg = {};\n+\n+    bpf_usdt_readarg(1, ctx, &msg.peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg.peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg.peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg.msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg.msg_size);\n+\n+    inbound_messages.perf_submit(ctx, &msg, sizeof(msg));\n+    return 0;\n+};\n+\n+int trace_outbound_message(struct pt_regs *ctx) {\n+    struct p2p_message msg = {};\n+\n+    bpf_usdt_readarg(1, ctx, &msg.peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg.peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg.peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg.msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg.msg_size);\n+\n+    outbound_messages.perf_submit(ctx, &msg, sizeof(msg));\n+    return 0;\n+};\n+\"\"\"\n+\n+\n+class Message:\n+    \"\"\" A P2P network message. \"\"\"\n+    msg_type = \"\"\n+    size = 0\n+    data = bytes()\n+    inbound = False\n+\n+    def __init__(self, msg_type, size, inbound):\n+        self.msg_type = msg_type\n+        self.size = size\n+        self.inbound = inbound\n+\n+\n+class Peer:\n+    \"\"\" A P2P network peer. \"\"\"\n+    id = 0\n+    address = \"\"\n+    connection_type = \"\"\n+    last_messages = list()\n+\n+    total_inbound_msgs = 0\n+    total_inbound_bytes = 0\n+    total_outbound_msgs = 0\n+    total_outbound_bytes = 0\n+\n+    def __init__(self, id, address, connection_type):\n+        self.id = id\n+        self.address = address\n+        self.connection_type = connection_type\n+        self.last_messages = list()\n+\n+    def add_message(self, message):\n+        self.last_messages.append(message)\n+        if len(self.last_messages) > 25:\n+            self.last_messages.pop(0)\n+        if message.inbound:\n+            self.total_inbound_bytes += message.size\n+            self.total_inbound_msgs += 1\n+        else:\n+            self.total_outbound_bytes += message.size\n+            self.total_outbound_msgs += 1\n+\n+\n+def main(bitcoind_path):\n+    peers = dict()\n+\n+    bitcoind_with_usdts = USDT(path=str(bitcoind_path))\n+\n+    # attaching the trace functions defined in the BPF program to the tracepoints\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"inbound_message\", fn_name=\"trace_inbound_message\")\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"outbound_message\", fn_name=\"trace_outbound_message\")\n+    bpf = BPF(text=program, usdt_contexts=[bitcoind_with_usdts])\n+\n+    # BCC: perf buffer handle function for inbound_messages\n+    def handle_inbound(_, data, size):\n+        \"\"\" Inbound message handler.\n+\n+        Called each time a message is submitted to the inbound_messages BPF table.\"\"\"\n+        event = bpf[\"inbound_messages\"].event(data)\n+        if event.peer_id not in peers:\n+            peer = Peer(event.peer_id, event.peer_addr.decode(\n+                \"utf-8\"), event.peer_conn_type.decode(\"utf-8\"))\n+            peers[peer.id] = peer\n+        peers[event.peer_id].add_message(\n+            Message(event.msg_type.decode(\"utf-8\"), event.msg_size, True))\n+\n+    # BCC: perf buffer handle function for outbound_messages\n+    def handle_outbound(_, data, size):\n+        \"\"\" Outbound message handler.\n+\n+        Called each time a message is submitted to the outbound_messages BPF table.\"\"\"\n+        event = bpf[\"outbound_messages\"].event(data)\n+        if event.peer_id not in peers:\n+            peer = Peer(event.peer_id, event.peer_addr.decode(\n+                \"utf-8\"), event.peer_conn_type.decode(\"utf-8\"))\n+            peers[peer.id] = peer\n+        peers[event.peer_id].add_message(\n+            Message(event.msg_type.decode(\"utf-8\"), event.msg_size, False))\n+\n+    # BCC: add handlers to the inbound and outbound perf buffers\n+    bpf[\"inbound_messages\"].open_perf_buffer(handle_inbound)\n+    bpf[\"outbound_messages\"].open_perf_buffer(handle_outbound)\n+\n+    wrapper(loop, bpf, peers)\n+\n+\n+def loop(screen, bpf, peers):\n+    screen.nodelay(1)\n+    cur_list_pos = 0\n+    win = curses.newwin(30, 70, 2, 7)\n+    win.erase()\n+    win.border(ord(\"|\"), ord(\"|\"), ord(\"-\"), ord(\"-\"),\n+               ord(\"-\"), ord(\"-\"), ord(\"-\"), ord(\"-\"))\n+    info_panel = panel.new_panel(win)\n+    info_panel.hide()\n+\n+    ROWS_AVALIABLE_FOR_LIST = curses.LINES - 5\n+    scroll = 0\n+\n+    while True:\n+        try:\n+            # BCC: poll the perf buffers for new events or timeout after 50ms\n+            bpf.perf_buffer_poll(timeout=50)\n+\n+            ch = screen.getch()\n+            if (ch == curses.KEY_DOWN or ch == ord(\"j\")) and cur_list_pos < len(\n+                    peers.keys()) -1 and info_panel.hidden():\n+                cur_list_pos += 1\n+                if cur_list_pos >= ROWS_AVALIABLE_FOR_LIST:\n+                    scroll += 1\n+            if (ch == curses.KEY_UP or ch == ord(\"k\")) and cur_list_pos > 0 and info_panel.hidden():\n+                cur_list_pos -= 1\n+                if scroll > 0:\n+                    scroll -= 1\n+            if ch == ord('\\n') or ch == ord(' '):\n+                if info_panel.hidden():\n+                    info_panel.show()\n+                else:\n+                    info_panel.hide()\n+            screen.erase()\n+            render(screen, peers, cur_list_pos, scroll, ROWS_AVALIABLE_FOR_LIST, info_panel)\n+            curses.panel.update_panels()\n+            screen.refresh()\n+        except KeyboardInterrupt:\n+            exit()\n+\n+\n+def render(screen, peers, cur_list_pos, scroll, ROWS_AVALIABLE_FOR_LIST, info_panel):\n+    \"\"\" renders the list of peers and details panel\n+\n+    This code is unrelated to USDT, BCC and BPF.\n+    \"\"\"\n+    header_format = \"%6s  %-20s  %-20s  %-22s  %-67s\"\n+    row_format = \"%6s  %-5d %9d byte  %-5d %9d byte  %-22s  %-67s\"\n+\n+    screen.addstr(0, 1, (\" P2P Message Monitor \"), curses.A_REVERSE)\n+    screen.addstr(\n+        1, 0, (\" Navigate with UP/DOWN or J/K and select a peer with ENTER or SPACE to see individual P2P messages\"), curses.A_NORMAL)\n+    screen.addstr(3, 0,\n+                  header_format % (\"PEER\", \"OUTBOUND\", \"INBOUND\", \"TYPE\", \"ADDR\"), curses.A_BOLD | curses.A_UNDERLINE)\n+    peer_list = sorted(peers.keys())[scroll:ROWS_AVALIABLE_FOR_LIST+scroll]\n+    for i, peer_id in enumerate(peer_list):\n+        peer = peers[peer_id]\n+        screen.addstr(i + 4, 0,\n+                      row_format % (peer.id, peer.total_outbound_msgs, peer.total_outbound_bytes,\n+                                    peer.total_inbound_msgs, peer.total_inbound_bytes,\n+                                    peer.connection_type, peer.address),\n+                      curses.A_REVERSE if i + scroll == cur_list_pos else curses.A_NORMAL)\n+        if i + scroll == cur_list_pos:\n+            info_window = info_panel.window()\n+            info_window.erase()\n+            info_window.border(\n+                ord(\"|\"), ord(\"|\"), ord(\"-\"), ord(\"-\"),\n+                ord(\"-\"), ord(\"-\"), ord(\"-\"), ord(\"-\"))\n+\n+            info_window.addstr(\n+                1, 1, f\"PEER {peer.id} ({peer.address})\".center(68), curses.A_REVERSE | curses.A_BOLD)\n+            info_window.addstr(\n+                2, 1, f\" OUR NODE{peer.connection_type:^54}PEER \",\n+                curses.A_BOLD)\n+            for i, msg in enumerate(peer.last_messages):\n+                if msg.inbound:\n+                    info_window.addstr(\n+                        i + 3, 1, \"%68s\" %\n+                        (f\"<--- {msg.msg_type} ({msg.size} bytes) \"), curses.A_NORMAL)\n+                else:\n+                    info_window.addstr(\n+                        i + 3, 1, \" %s (%d byte) --->\" %\n+                        (msg.msg_type, msg.size), curses.A_NORMAL)\n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) < 2:\n+        print(\"USAGE:\", sys.argv[0], \"path/to/bitcoind\")\n+        exit()\n+    path = sys.argv[1]\n+    main(path)"
      },
      {
        "sha": "026946b01881c37d25d2b46e892e0286a8515405",
        "filename": "doc/tracing.md",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/doc/tracing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/doc/tracing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tracing.md?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -53,6 +53,46 @@ be found in [contrib/tracing].\n \n The currently available tracepoints are listed here.\n \n+### Context `net`\n+\n+#### Tracepoint `net:inbound_message`\n+\n+Is called when a message is received from a peer over the P2P network. Passes\n+information about our peer, the connection and the message as arguments.\n+\n+Arguments passed:\n+1. Peer ID as `int64`\n+2. Peer Address and Port (IPv4, IPv6, Tor v3, I2P, ...) as `pointer to C-style String` (max. length 68 characters)\n+3. Connection Type (inbound, feeler, outbound-full-relay, ...) as `pointer to C-style String` (max. length 20 characters)\n+4. Message Type (inv, ping, getdata, addrv2, ...) as `pointer to C-style String` (max. length 20 characters)\n+5. Message Size in bytes as `uint64`\n+6. Message Bytes as `pointer to unsigned chars` (i.e. bytes)\n+\n+Note: The message is passed to the tracepoint in full, however, due to space\n+limitations in the eBPF kernel VM it might not be possible to pass the message\n+to user-space in full. Messages longer than a 32kb might be cut off. This can\n+be detected in tracing scripts by comparing the message size to the length of\n+the passed message.\n+\n+#### Tracepoint `net:outbound_message`\n+\n+Is called when a message is send to a peer over the P2P network. Passes\n+information about our peer, the connection and the message as arguments.\n+\n+Arguments passed:\n+1. Peer ID as `int64`\n+2. Peer Address and Port (IPv4, IPv6, Tor v3, I2P, ...) as `pointer to C-style String` (max. length 68 characters)\n+3. Connection Type (inbound, feeler, outbound-full-relay, ...) as `pointer to C-style String` (max. length 20 characters)\n+4. Message Type (inv, ping, getdata, addrv2, ...) as `pointer to C-style String` (max. length 20 characters)\n+5. Message Size in bytes as `uint64`\n+6. Message Bytes as `pointer to unsigned chars` (i.e. bytes)\n+\n+Note: The message is passed to the tracepoint in full, however, due to space\n+limitations in the eBPF kernel VM it might not be possible to pass the message\n+to user-space in full. Messages longer than a 32kb might be cut off. This can\n+be detected in tracing scripts by comparing the message size to the length of\n+the passed message.\n+\n ## Adding tracepoints to Bitcoin Core\n \n To add a new tracepoint, `#include <util/trace.h>` in the compilation unit where"
      },
      {
        "sha": "8ef770ede22d16ecf6a41b0a8a8394684710e7d4",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -25,6 +25,7 @@\n #include <util/sock.h>\n #include <util/strencodings.h>\n #include <util/thread.h>\n+#include <util/trace.h>\n #include <util/translation.h>\n \n #ifdef WIN32\n@@ -3017,11 +3018,20 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.m_type), nMessageSize, pnode->GetId());\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\", msg.m_type, nMessageSize, pnode->GetId());\n     if (gArgs.GetBoolArg(\"-capturemessages\", false)) {\n         CaptureMessage(pnode->addr, msg.m_type, msg.data, /* incoming */ false);\n     }\n \n+    TRACE6(net, outbound_message,\n+        pnode->GetId(),\n+        pnode->GetAddrName().c_str(),\n+        pnode->ConnectionTypeAsString().c_str(),\n+        msg.m_type.c_str(),\n+        msg.data.size(),\n+        msg.data.data()\n+    );\n+\n     // make sure we use the appropriate network transport format\n     std::vector<unsigned char> serializedHeader;\n     pnode->m_serializer->prepareForTransport(msg, serializedHeader);"
      },
      {
        "sha": "dc36b698023c4431c5826575c6d51a81e65fc0e7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4224dec22baa66547303840707cf1d4f15a49b20/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4224dec22baa66547303840707cf1d4f15a49b20/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4224dec22baa66547303840707cf1d4f15a49b20",
        "patch": "@@ -34,6 +34,7 @@\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n #include <util/system.h>\n+#include <util/trace.h>\n #include <validation.h>\n \n #include <algorithm>\n@@ -4052,6 +4053,15 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n     }\n     CNetMessage& msg(msgs.front());\n \n+    TRACE6(net, inbound_message,\n+        pfrom->GetId(),\n+        pfrom->GetAddrName().c_str(),\n+        pfrom->ConnectionTypeAsString().c_str(),\n+        msg.m_command.c_str(),\n+        msg.m_recv.size(),\n+        msg.m_recv.data()\n+    );\n+\n     if (gArgs.GetBoolArg(\"-capturemessages\", false)) {\n         CaptureMessage(pfrom->addr, msg.m_command, MakeUCharSpan(msg.m_recv), /* incoming */ true);\n     }"
      }
    ]
  },
  {
    "sha": "8f37f5c2a562c38c83fc40234ade9c301fc4e685",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjM3ZjVjMmE1NjJjMzhjODNmYzQwMjM0YWRlOWMzMDFmYzRlNjg1",
    "commit": {
      "author": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-05-20T15:53:24Z"
      },
      "committer": {
        "name": "0xb10c",
        "email": "0xb10c@gmail.com",
        "date": "2021-07-27T15:12:38Z"
      },
      "message": "tracing: Tracepoint for connected blocks\n\nCan, for example, be used to benchmark block connections.",
      "tree": {
        "sha": "61c2e9023432218dcb0031e2e607469db154ee02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61c2e9023432218dcb0031e2e607469db154ee02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f37f5c2a562c38c83fc40234ade9c301fc4e685",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDMuq/Xai7OLM0xQd4v/VsdiMqX0FAmEAImYACgkQ4v/VsdiM\nqX20hBAAk4xGVzXJKeMGNmmMtvfCQrP54CvN5eaAk8qUz9prga01zRzoxsJwUfNt\n2vSEWz2Jvpb0A9iMWNAB7qJ8TKsJmA9DGoy2G+roOsq4c7uj0y0CCsvF1USgFuts\njitrVuiTE+GILfdzHu/xQ2FTEdMjSSF3BtXEm4xZ5Q8WZvR+kN3AQZ9PK7QplSLn\nTZprImjJqBRXTdopm329FU4l3OacoiX9CmY5NCaoJNYFnpCeeIH/N8soorquhsEn\nZhuMC50IQPsycHqsWN3Pn6h1pEOqt9NAAfqF0Pb4N6G0CTdHSHdk/5AYv+QF6s0u\nQ2ffIV6kK9yBWBalZfL4pHLWpqtF7isaKOPY7H1GNcCqRBKpB2ihITuTSsnqoLxf\ndBgpBq0JcmFuoJSa4bEfshKyIfQEYONPx7pl+GZkFy0hgQ3pzuuRjB4V8CGPwh3b\n+uqomY5n9ILaogc/zwx4jDFC7I0ffGM+DZXhmpuf9e+6cGvmxiJ9/BKGa8qg9C6q\nSxZEQGet3AlFPYOFOpR2SZ4CmSQ959PBI0eB7OSyx6V5al4N9YDD0/zySdaDfgEk\nR2+pWQvCzNFxm3kk46egQ/jNcQ4Nl4fOTFoWBOgFpvD3WrwsRF1sM5qVsWPKrkGE\nuQbWID4FbnD7LYjcACOb39cFSMDj5bAxTBkJBH4ItlnTV0rOzOs=\n=BYF3\n-----END PGP SIGNATURE-----",
        "payload": "tree 61c2e9023432218dcb0031e2e607469db154ee02\nparent 4224dec22baa66547303840707cf1d4f15a49b20\nauthor 0xb10c <0xb10c@gmail.com> 1621526004 +0200\ncommitter 0xb10c <0xb10c@gmail.com> 1627398758 +0200\n\ntracing: Tracepoint for connected blocks\n\nCan, for example, be used to benchmark block connections.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f37f5c2a562c38c83fc40234ade9c301fc4e685",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f37f5c2a562c38c83fc40234ade9c301fc4e685",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f37f5c2a562c38c83fc40234ade9c301fc4e685/comments",
    "author": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4224dec22baa66547303840707cf1d4f15a49b20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4224dec22baa66547303840707cf1d4f15a49b20",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4224dec22baa66547303840707cf1d4f15a49b20"
      }
    ],
    "stats": {
      "total": 259,
      "additions": 259,
      "deletions": 0
    },
    "files": [
      {
        "sha": "047354cda17b10b31ada507698b4d372ec8ffc3f",
        "filename": "contrib/tracing/README.md",
        "status": "modified",
        "additions": 76,
        "deletions": 0,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f37f5c2a562c38c83fc40234ade9c301fc4e685/contrib/tracing/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f37f5c2a562c38c83fc40234ade9c301fc4e685/contrib/tracing/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/README.md?ref=8f37f5c2a562c38c83fc40234ade9c301fc4e685",
        "patch": "@@ -163,3 +163,79 @@ Warning: incomplete message (only 32568 out of 53552 bytes)! inbound msg 'tx' fr\n \u2026\n Possibly lost 2 samples\n ```\n+\n+### connectblock_benchmark.bt\n+\n+A `bpftrace` script to benchmark the `ConnectBlock()` function during, for\n+example, a blockchain re-index. Based on the `validation:block_connected` USDT\n+tracepoint.\n+\n+The script takes three positional arguments. The first two arguments, the start,\n+and end height indicate between which blocks the benchmark should be run. The\n+third acts as a duration threshold in milliseconds. When the `ConnectBlock()`\n+function takes longer than the threshold, information about the block, is\n+printed. For more details, see the header comment in the script.\n+\n+By default, `bpftrace` limits strings to 64 bytes due to the limited stack size\n+in the kernel VM. Block hashes as zero-terminated hex strings are 65 bytes which\n+exceed the string limit. The string size limit can be set to 65 bytes with the\n+environment variable `BPFTRACE_STRLEN`.\n+\n+The following command can be used to benchmark, for example, `ConnectBlock()`\n+between height 20000 and 38000 on SigNet while logging all blocks that take\n+longer than 25ms to connect.\n+\n+```\n+$ BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt 20000 38000 25\n+```\n+\n+In a different terminal, starting Bitcoin Core in SigNet mode and with\n+re-indexing enabled.\n+\n+```\n+$ ./src/bitcoind -signet -reindex\n+```\n+\n+This produces the following output.\n+```\n+Attaching 5 probes...\n+ConnectBlock Benchmark between height 20000 and 38000 inclusive\n+Logging blocks taking longer than 25 ms to connect.\n+Starting Connect Block Benchmark between height 20000 and 38000.\n+BENCH   39 blk/s     59 tx/s      59 inputs/s       20 sigops/s (height 20038)\n+Block 20492 (000000f555653bb05e2f3c6e79925e01a20dd57033f4dc7c354b46e34735d32b)    20 tx   2319 ins   2318 sigops  took   38 ms\n+BENCH 1840 blk/s   2117 tx/s    4478 inputs/s     2471 sigops/s (height 21879)\n+BENCH 1816 blk/s   4972 tx/s    4982 inputs/s      125 sigops/s (height 23695)\n+BENCH 2095 blk/s   2890 tx/s    2910 inputs/s      152 sigops/s (height 25790)\n+BENCH 1684 blk/s   3979 tx/s    4053 inputs/s      288 sigops/s (height 27474)\n+BENCH 1155 blk/s   3216 tx/s    3252 inputs/s      115 sigops/s (height 28629)\n+BENCH 1797 blk/s   2488 tx/s    2503 inputs/s      111 sigops/s (height 30426)\n+BENCH 1849 blk/s   6318 tx/s    6569 inputs/s    12189 sigops/s (height 32275)\n+BENCH  946 blk/s  20209 tx/s   20775 inputs/s    83809 sigops/s (height 33221)\n+Block 33406 (0000002adfe4a15cfcd53bd890a89bbae836e5bb7f38bac566f61ad4548c87f6)    25 tx   2045 ins   2090 sigops  took   29 ms\n+Block 33687 (00000073231307a9828e5607ceb8156b402efe56747271a4442e75eb5b77cd36)    52 tx   1797 ins   1826 sigops  took   26 ms\n+BENCH  582 blk/s  21581 tx/s   27673 inputs/s    60345 sigops/s (height 33803)\n+BENCH 1035 blk/s  19735 tx/s   19776 inputs/s    51355 sigops/s (height 34838)\n+Block 35625 (0000006b00b347390c4768ea9df2655e9ff4b120f29d78594a2a702f8a02c997)    20 tx   3374 ins   3371 sigops  took   49 ms\n+BENCH  887 blk/s  17857 tx/s   22191 inputs/s    24404 sigops/s (height 35725)\n+Block 35937 (000000d816d13d6e39b471cd4368db60463a764ba1f29168606b04a22b81ea57)    75 tx   3943 ins   3940 sigops  took   61 ms\n+BENCH  823 blk/s  16298 tx/s   21031 inputs/s    18440 sigops/s (height 36548)\n+Block 36583 (000000c3e260556dbf42968aae3f904dba8b8c1ff96a6f6e3aa5365d2e3ad317)    24 tx   2198 ins   2194 sigops  took   34 ms\n+Block 36700 (000000b3b173de9e65a3cfa738d976af6347aaf83fa17ab3f2a4d2ede3ddfac4)    73 tx   1615 ins   1611 sigops  took   31 ms\n+Block 36832 (0000007859578c02c1ac37dabd1b9ec19b98f350b56935f5dd3a41e9f79f836e)    34 tx   1440 ins   1436 sigops  took   26 ms\n+BENCH  613 blk/s  16718 tx/s   25074 inputs/s    23022 sigops/s (height 37161)\n+Block 37870 (000000f5c1086291ba2d943fb0c3bc82e71c5ee341ee117681d1456fbf6c6c38)    25 tx   1517 ins   1514 sigops  took   29 ms\n+BENCH  811 blk/s  16031 tx/s   20921 inputs/s    18696 sigops/s (height 37972)\n+\n+Took 14055 ms to connect the blocks between height 20000 and 38000.\n+\n+Histogram of block connection times in milliseconds (ms).\n+@durations:\n+[0]                16838 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n+[1]                  882 |@@                                                  |\n+[2, 4)               236 |                                                    |\n+[4, 8)                23 |                                                    |\n+[8, 16)                9 |                                                    |\n+[16, 32)               9 |                                                    |\n+[32, 64)               4 |                                                    |\n+```"
      },
      {
        "sha": "d268eff7f8b8cf2fc1a19951ac60e09279ce7d17",
        "filename": "contrib/tracing/connectblock_benchmark.bt",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f37f5c2a562c38c83fc40234ade9c301fc4e685/contrib/tracing/connectblock_benchmark.bt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f37f5c2a562c38c83fc40234ade9c301fc4e685/contrib/tracing/connectblock_benchmark.bt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/connectblock_benchmark.bt?ref=8f37f5c2a562c38c83fc40234ade9c301fc4e685",
        "patch": "@@ -0,0 +1,150 @@\n+#!/usr/bin/env bpftrace\n+\n+/*\n+\n+  USAGE:\n+\n+  BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt <start height> <end height> <logging threshold in ms>\n+\n+  - The environment variable BPFTRACE_STRLEN needs to be set to 65 chars as\n+    strings are limited to 64 chars by default. Hex strings with Bitcoin block\n+    hashes are 64 hex chars + 1 null-termination char.\n+  - <start height> sets the height at which the benchmark should start. Setting\n+    the start height to 0 starts the benchmark immediately, even before the\n+    first block is connected.\n+  - <end height> sets the height after which the benchmark should end. Setting\n+    the end height to 0 disables the benchmark. The script only logs blocks\n+    over <logging threshold in ms>.\n+  - Threshold <logging threshold in ms>\n+\n+  This script requires a 'bitcoind' binary compiled with eBPF support and the\n+  'validation:block_connected' USDT. By default, it's assumed that 'bitcoind' is\n+  located in './src/bitcoind'. This can be modified in the script below.\n+\n+  EXAMPLES:\n+\n+  BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt 300000 680000 1000\n+\n+  When run together 'bitcoind -reindex', this benchmarks the time it takes to\n+  connect the blocks between height 300.000 and 680.000 (inclusive) and prints\n+  details about all blocks that take longer than 1000ms to connect. Prints a\n+  histogram with block connection times when the benchmark is finished.\n+\n+\n+  BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt 0 0 500\n+\n+  When running together 'bitcoind', all newly connected blocks that\n+  take longer than 500ms to connect are logged. A histogram with block\n+  connection times is shown when the script is terminated.\n+\n+*/\n+\n+BEGIN\n+{\n+  $start_height = $1;\n+  $end_height = $2;\n+  $logging_threshold_ms = $3;\n+\n+  if ($end_height < $start_height) {\n+    printf(\"Error: start height (%d) larger than end height (%d)!\\n\", $start_height, $end_height);\n+    exit();\n+  }\n+\n+  if ($end_height > 0) {\n+    printf(\"ConnectBlock benchmark between height %d and %d inclusive\\n\", $start_height, $end_height);\n+  } else {\n+    printf(\"ConnectBlock logging starting at height %d\\n\", $start_height);\n+  }\n+\n+  if ($logging_threshold_ms > 0) {\n+    printf(\"Logging blocks taking longer than %d ms to connect.\\n\", $3);\n+  }\n+\n+  if ($start_height == 0) {\n+    @start = nsecs;\n+  }\n+}\n+\n+/*\n+  Attaches to the 'validation:block_connected' USDT and collects stats when the\n+  connected block is between the start and end height (or the end height is\n+  unset).\n+*/\n+usdt:./src/bitcoind:validation:block_connected /arg1 >= $1 && (arg1 <= $2 || $2 == 0 )/\n+{\n+  $height = arg1;\n+  $transactions = arg2;\n+  $inputs = arg3;\n+  $sigops =  arg4;\n+  $duration = (uint64) arg5;\n+\n+  @height = $height;\n+\n+  @blocks = @blocks + 1;\n+  @transactions = @transactions + $transactions;\n+  @inputs = @inputs + $inputs;\n+  @sigops = @sigops + $sigops;\n+\n+  @durations = hist($duration / 1000);\n+\n+  if ($height == $1 && $height != 0) {\n+    @start = nsecs;\n+    printf(\"Starting Connect Block Benchmark between height %d and %d.\\n\", $1, $2);\n+  }\n+\n+  if ($2 > 0 && $height >= $2) {\n+    @end = nsecs;\n+    $duration = @end - @start;\n+    printf(\"\\nTook %d ms to connect the blocks between height %d and %d.\\n\", $duration / 1000000, $1, $2);\n+    exit();\n+  }\n+}\n+\n+/*\n+  Attaches to the 'validation:block_connected' USDT and logs information about\n+  blocks where the time it took to connect the block is above the\n+  <logging threshold in ms>.\n+*/\n+usdt:./src/bitcoind:validation:block_connected / (uint64) arg5 / 1000> $3 /\n+{\n+  $hash_str = str(arg0);\n+  $height = (int32) arg1;\n+  $transactions = (uint64) arg2;\n+  $inputs = (int32) arg3;\n+  $sigops = (int64) arg4;\n+  $duration = (int64) arg5;\n+\n+  printf(\"Block %d (%s)  %4d tx  %5d ins  %5d sigops  took %4d ms\\n\", $height, $hash_str, $transactions, $inputs, $sigops, (uint64) $duration / 1000);\n+}\n+\n+\n+/*\n+  Prints stats about the blocks, transactions, inputs, and sigops processed in\n+  the last second (if any).\n+*/\n+interval:s:1 {\n+  if (@blocks > 0) {\n+    printf(\"BENCH %4d blk/s %6d tx/s %7d inputs/s %8d sigops/s (height %d)\\n\", @blocks, @transactions, @inputs, @sigops, @height);\n+\n+    zero(@blocks);\n+    zero(@transactions);\n+    zero(@inputs);\n+    zero(@sigops);\n+  }\n+}\n+\n+END\n+{\n+  printf(\"\\nHistogram of block connection times in milliseconds (ms).\\n\");\n+  print(@durations);\n+\n+  clear(@durations);\n+  clear(@blocks);\n+  clear(@transactions);\n+  clear(@inputs);\n+  clear(@sigops);\n+  clear(@height);\n+  clear(@start);\n+  clear(@end);\n+}\n+"
      },
      {
        "sha": "1242a0d25002b3f4c65e6673584e53cc1094b22b",
        "filename": "doc/tracing.md",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f37f5c2a562c38c83fc40234ade9c301fc4e685/doc/tracing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f37f5c2a562c38c83fc40234ade9c301fc4e685/doc/tracing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tracing.md?ref=8f37f5c2a562c38c83fc40234ade9c301fc4e685",
        "patch": "@@ -93,6 +93,28 @@ to user-space in full. Messages longer than a 32kb might be cut off. This can\n be detected in tracing scripts by comparing the message size to the length of\n the passed message.\n \n+### Context `validation`\n+\n+#### Tracepoint `validation:block_connected`\n+\n+Is called *after* a block is connected to the chain. Can, for example, be used\n+to benchmark block connections together with `-reindex`.\n+\n+Arguments passed:\n+1. Block Header Hash as `pointer to C-style String` (64 characters)\n+2. Block Height as `int32`\n+3. Transactions in the Block as `uint64`\n+4. Inputs spend in the Block as `int32`\n+5. SigOps in the Block (excluding coinbase SigOps) `uint64`\n+6. Time it took to connect the Block in microseconds (\u00b5s) as `uint64`\n+7. Block Header Hash as `pointer to unsigned chars` (i.e. 32 bytes in little-endian)\n+\n+Note: The 7th argument can't be accessed by bpftrace and is purposefully chosen\n+to be the block header hash as bytes. See [bpftrace argument limit] for more\n+details.\n+\n+[bpftrace argument limit]: #bpftrace-argument-limit\n+\n ## Adding tracepoints to Bitcoin Core\n \n To add a new tracepoint, `#include <util/trace.h>` in the compilation unit where"
      },
      {
        "sha": "20d641bf400897421cf86b503a5314749489884e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f37f5c2a562c38c83fc40234ade9c301fc4e685/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f37f5c2a562c38c83fc40234ade9c301fc4e685/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8f37f5c2a562c38c83fc40234ade9c301fc4e685",
        "patch": "@@ -48,6 +48,7 @@\n #include <util/rbf.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n+#include <util/trace.h>\n #include <util/translation.h>\n #include <validationinterface.h>\n #include <warnings.h>\n@@ -1997,6 +1998,16 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     int64_t nTime6 = GetTimeMicros(); nTimeCallbacks += nTime6 - nTime5;\n     LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs (%.2fms/blk)]\\n\", MILLI * (nTime6 - nTime5), nTimeCallbacks * MICRO, nTimeCallbacks * MILLI / nBlocksTotal);\n \n+    TRACE7(validation, block_connected,\n+        block.GetHash().ToString().c_str(),\n+        pindex->nHeight,\n+        block.vtx.size(),\n+        nInputs,\n+        nSigOpsCost,\n+        GetTimeMicros() - nTimeStart, // in microseconds (\u00b5s)\n+        block.GetHash().data()\n+    );\n+\n     return true;\n }\n "
      }
    ]
  }
]