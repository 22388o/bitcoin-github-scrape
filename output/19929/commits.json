[
  {
    "sha": "2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTQwODFlNDg3ZjFiODNhNWM5ZjExOTRhNzNkNWEwMWE0YzM1Y2M2",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-08T19:29:18Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-09T12:01:43Z"
      },
      "message": "sync: use proper TSA attributes\n\nUse the proper attribute from Clang's thread safety analysis for\n`AssertLockHeld()`:\n\n* if `DEBUG_LOCKORDER` is defined then `AssertLockHeld()` will check if\n  the caller owns the given mutex and will `abort()` if not. Clang has\n  an attribute exactly for that - `ASSERT_EXCLUSIVE_LOCK()`, documented\n  as: \"These are attributes on a function or method that does a run-time\n  test to see whether the calling thread holds the given capability. The\n  function is assumed to fail (no return) if the capability is not\n  held.\" [1]\n\n* if `DEBUG_LOCKORDER` is not defined, then `AssertLockHeld()` does\n  nothing, thus don't tag it with any attributes (don't fool the\n  compiler that we do something which we don't).\n\nReplace `LockAssertion` with `AssertLockHeld` and remove the former.\n\nOn the places where Clang cannot deduce that a mutex is held, use\n`NO_THREAD_SAFETY_ANALYSIS`, intended to be used when a code is\n\"too complicated for the analysis to understand\" [2].\n\n[1] https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#requires-requires-shared\n[2] https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#no-thread-safety-analysis",
      "tree": {
        "sha": "bdbb6b6153a53d4b10f9eb05567f19a2a96ec276",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bdbb6b6153a53d4b10f9eb05567f19a2a96ec276"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9YxDUACgkQVN8G9ktV\ny7/iQx//bthv0eavSo3Xym4N+dN0QYM/RngHKYELhUK8UBHmRDAngb6AsI/oUmwG\nCoyddKkq9tdf2Eu6gcZX7vjkWYyf64c4PyduSUiZ/zpcasLf7pcGM6HzrEij0iqz\nGKWkBn/oHLxLO7MCUES+YusNd2b1h1FSN+A45/OWYlwDyw0nocQZ1/M69IYfthwW\nbm6+ouwqWcOXHgF83l5yrAoJMxjKIk8TevxPfXWMiEB6awNb2ZCGEBSrPzClt8ka\nIQVftDlJsbStX5i+jPevWsOL2cF83wI5IlK1KgFmZRckdPuX7EUByyVfAfScgCQ7\n9uWbGzUOI6vlg/lqFaL/QY3h9JJ3BzjrKDapMAmC+mHmLJ73joGHwms5ViMmeqYW\nFinwgsECncyCANBNbaJT1kS39/35VFTFm4zo4DbMgUyRMExcEzNoUZeprAbgQViw\nTwPrkZyseuypHeoDcK2UQGeB4VV/PGLUCiVbhl0HO/NBj2FxkHpUEiQ4r1/oV/I6\n6gmlRmfRNKE5aTU5+omaDzCOTw+CM6ikYjQAkL25neWj7fGBvq8i8FqKjCLUviyI\nUSFS0VC6KRpaGoWa+YJ5wZ2xvFfWSTTqDslJgnKaTTeE1LDwk83tg0Jerf4KPJWj\nYV449z/LIkYc81GWIStkJAERkWBbGUGuMIpQur55CLbZhzVWJoXncrCuwqeXG+iZ\nvj3UECRc/CfyfW4kuf4JORuANZazAgNLq9iwLmRMfdttq07xQm8BAiHXHf2pJjvC\nUty44JFAmMsYDFdIHuaq3cQS8FrOmWsjZggSCNTKwNA2XghTSVYkUEbnHYhoVp1Q\n5lrdWwwkKLgXx0LVf6FflkMRv+PbG6dpudIELsYQFBQQG+xtACLJXwqbP4sY5vCM\nxgakwi7L0lq0Fcxv38imwZWra141nXC3bqXvaj+bT9bJOKZFBvrjwdR/PDFgr1xZ\n1t+/Y+UyFjn60mcZHTAI+yhHs8UiFl7oXnKFgSbrX9gUCxdITDf+Pn9t3D7wzDZN\nM/y3Mx8SrF2vDpPd7GIlmtqH5mqwdea7PZgHmq323u0gYxNTr+RttT16AYtnca0d\n8kNrDXEHn89/mCnVSpkF5QKhOIEOHxv+QXeVEzX7sma/KegtUD7YewSJ0z0rZxBG\nkeGTlt/YFUi2jzW9zQnUrcB4+CHdoCa0612B98pJB7OnZ+9ZwGrX3EtU4Mx7dmCR\ng6A4Qz5uRlaF76XpeDgbGD9LWxOLR/dac4/fNvojNMQ1KKRDLY3/OaQiumnsQPtQ\nxibOZxiET/oqXUXbL3WAjaELxe98yhfrWR7hFk8vdgZF1S8gQ0bnkLYNL5ppPIzV\nBrNIJaPT9gw7ai7XEe9DjSK6OxZ8oQ==\n=mJWc\n-----END PGP SIGNATURE-----",
        "payload": "tree bdbb6b6153a53d4b10f9eb05567f19a2a96ec276\nparent 564e1ab0f3dc573bd3ea60a80f6649c361243df9\nauthor Vasil Dimov <vd@FreeBSD.org> 1599593358 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1599652903 +0200\n\nsync: use proper TSA attributes\n\nUse the proper attribute from Clang's thread safety analysis for\n`AssertLockHeld()`:\n\n* if `DEBUG_LOCKORDER` is defined then `AssertLockHeld()` will check if\n  the caller owns the given mutex and will `abort()` if not. Clang has\n  an attribute exactly for that - `ASSERT_EXCLUSIVE_LOCK()`, documented\n  as: \"These are attributes on a function or method that does a run-time\n  test to see whether the calling thread holds the given capability. The\n  function is assumed to fail (no return) if the capability is not\n  held.\" [1]\n\n* if `DEBUG_LOCKORDER` is not defined, then `AssertLockHeld()` does\n  nothing, thus don't tag it with any attributes (don't fool the\n  compiler that we do something which we don't).\n\nReplace `LockAssertion` with `AssertLockHeld` and remove the former.\n\nOn the places where Clang cannot deduce that a mutex is held, use\n`NO_THREAD_SAFETY_ANALYSIS`, intended to be used when a code is\n\"too complicated for the analysis to understand\" [2].\n\n[1] https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#requires-requires-shared\n[2] https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#no-thread-safety-analysis\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "564e1ab0f3dc573bd3ea60a80f6649c361243df9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/564e1ab0f3dc573bd3ea60a80f6649c361243df9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/564e1ab0f3dc573bd3ea60a80f6649c361243df9"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 15,
      "deletions": 29
    },
    "files": [
      {
        "sha": "d38ee5fedfe72b803d29823219cad7a92a44a38c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6",
        "patch": "@@ -662,8 +662,8 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n                 return;\n             }\n         }\n-        connman.ForNode(nodeid, [&connman](CNode* pfrom){\n-            LockAssertion lock(::cs_main);\n+        connman.ForNode(nodeid, [&connman](CNode* pfrom) NO_THREAD_SAFETY_ANALYSIS {\n+            AssertLockHeld(::cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n@@ -1354,8 +1354,9 @@ void PeerManager::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_\n         fWitnessesPresentInMostRecentCompactBlock = fWitnessEnabled;\n     }\n \n-    m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n-        LockAssertion lock(::cs_main);\n+    m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled,\n+                           &hashBlock](CNode* pnode) NO_THREAD_SAFETY_ANALYSIS {\n+        AssertLockHeld(::cs_main);\n \n         // TODO: Avoid the repeated-serialization here\n         if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n@@ -1488,9 +1489,8 @@ bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED\n \n void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n {\n-    connman.ForEachNode([&txid, &wtxid](CNode* pnode)\n-    {\n-        LockAssertion lock(::cs_main);\n+    connman.ForEachNode([&txid, &wtxid](CNode* pnode) NO_THREAD_SAFETY_ANALYSIS {\n+        AssertLockHeld(::cs_main);\n \n         CNodeState &state = *State(pnode->GetId());\n         if (state.m_wtxid_relay) {\n@@ -3979,8 +3979,8 @@ void PeerManager::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         NodeId worst_peer = -1;\n         int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();\n \n-        m_connman.ForEachNode([&](CNode* pnode) {\n-            LockAssertion lock(::cs_main);\n+        m_connman.ForEachNode([&](CNode* pnode) NO_THREAD_SAFETY_ANALYSIS {\n+            AssertLockHeld(::cs_main);\n \n             // Ignore non-outbound peers, or nodes marked for disconnect already\n             if (!pnode->IsOutboundOrBlockRelayConn() || pnode->fDisconnect) return;\n@@ -3996,8 +3996,8 @@ void PeerManager::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             }\n         });\n         if (worst_peer != -1) {\n-            bool disconnected = m_connman.ForNode(worst_peer, [&](CNode *pnode) {\n-                LockAssertion lock(::cs_main);\n+            bool disconnected = m_connman.ForNode(worst_peer, [&](CNode *pnode) NO_THREAD_SAFETY_ANALYSIS {\n+                AssertLockHeld(::cs_main);\n \n                 // Only disconnect a peer that has been connected to us for\n                 // some reasonable fraction of our check-frequency, to give"
      },
      {
        "sha": "f392204385033dba01f174336453c226ff251216",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 4,
        "deletions": 18,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=2a4081e487f1b83a5c9f1194a73d5a01a4c35cc6",
        "patch": "@@ -53,9 +53,9 @@ void LeaveCritical();\n void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line);\n std::string LocksHeld();\n template <typename MutexType>\n-void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) ASSERT_EXCLUSIVE_LOCK(cs);\n template <typename MutexType>\n-void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) ASSERT_EXCLUSIVE_LOCK(!cs);\n void DeleteLock(void* cs);\n bool LockStackEmpty();\n \n@@ -70,9 +70,9 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n-void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n+void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n@@ -352,18 +352,4 @@ class CSemaphoreGrant\n     }\n };\n \n-// Utility class for indicating to compiler thread analysis that a mutex is\n-// locked (when it couldn't be determined otherwise).\n-struct SCOPED_LOCKABLE LockAssertion\n-{\n-    template <typename Mutex>\n-    explicit LockAssertion(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex)\n-    {\n-#ifdef DEBUG_LOCKORDER\n-        AssertLockHeld(mutex);\n-#endif\n-    }\n-    ~LockAssertion() UNLOCK_FUNCTION() {}\n-};\n-\n #endif // BITCOIN_SYNC_H"
      }
    ]
  }
]