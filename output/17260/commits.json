[
  {
    "sha": "ab053ec6d1e766402f88947d29cd875a285e7280",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYjA1M2VjNmQxZTc2NjQwMmY4ODk0N2QyOWNkODc1YTI4NWU3Mjgw",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-06-20T21:34:33Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-25T23:20:24Z"
      },
      "message": "Move wallet enums to walletutil.h",
      "tree": {
        "sha": "3130d9ffa194baa49a04a35301a4160c0e4f9ec9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3130d9ffa194baa49a04a35301a4160c0e4f9ec9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab053ec6d1e766402f88947d29cd875a285e7280",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab053ec6d1e766402f88947d29cd875a285e7280",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ab053ec6d1e766402f88947d29cd875a285e7280",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab053ec6d1e766402f88947d29cd875a285e7280/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25d7e2e78137d07eb612c44d19b0d496050c947a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25d7e2e78137d07eb612c44d19b0d496050c947a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25d7e2e78137d07eb612c44d19b0d496050c947a"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 48,
      "deletions": 46
    },
    "files": [
      {
        "sha": "9ab9e283fa1b76d338374ff306feec91257f2e70",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 46,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab053ec6d1e766402f88947d29cd875a285e7280/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab053ec6d1e766402f88947d29cd875a285e7280/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=ab053ec6d1e766402f88947d29cd875a285e7280",
        "patch": "@@ -99,58 +99,12 @@ struct FeeCalculation;\n enum class FeeEstimateMode;\n class ReserveDestination;\n \n-/** (client) version numbers for particular wallet features */\n-enum WalletFeature\n-{\n-    FEATURE_BASE = 10500, // the earliest version new wallets supports (only useful for getwalletinfo's clientversion output)\n-\n-    FEATURE_WALLETCRYPT = 40000, // wallet encryption\n-    FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n-\n-    FEATURE_HD = 130000, // Hierarchical key derivation after BIP32 (HD Wallet)\n-\n-    FEATURE_HD_SPLIT = 139900, // Wallet with HD chain split (change outputs will use m/0'/1'/k)\n-\n-    FEATURE_NO_DEFAULT_KEY = 159900, // Wallet without a default key written\n-\n-    FEATURE_PRE_SPLIT_KEYPOOL = 169900, // Upgraded to HD SPLIT and can have a pre-split keypool\n-\n-    FEATURE_LATEST = FEATURE_PRE_SPLIT_KEYPOOL\n-};\n-\n //! Default for -addresstype\n constexpr OutputType DEFAULT_ADDRESS_TYPE{OutputType::BECH32};\n \n //! Default for -changetype\n constexpr OutputType DEFAULT_CHANGE_TYPE{OutputType::CHANGE_AUTO};\n \n-enum WalletFlags : uint64_t {\n-    // wallet flags in the upper section (> 1 << 31) will lead to not opening the wallet if flag is unknown\n-    // unknown wallet flags in the lower section <= (1 << 31) will be tolerated\n-\n-    // will categorize coins as clean (not reused) and dirty (reused), and handle\n-    // them with privacy considerations in mind\n-    WALLET_FLAG_AVOID_REUSE = (1ULL << 0),\n-\n-    // Indicates that the metadata has already been upgraded to contain key origins\n-    WALLET_FLAG_KEY_ORIGIN_METADATA = (1ULL << 1),\n-\n-    // will enforce the rule that the wallet can't contain any private keys (only watch-only/pubkeys)\n-    WALLET_FLAG_DISABLE_PRIVATE_KEYS = (1ULL << 32),\n-\n-    //! Flag set when a wallet contains no HD seed and no private keys, scripts,\n-    //! addresses, and other watch only things, and is therefore \"blank.\"\n-    //!\n-    //! The only function this flag serves is to distinguish a blank wallet from\n-    //! a newly created wallet when the wallet database is loaded, to avoid\n-    //! initialization that should only happen on first run.\n-    //!\n-    //! This flag is also a mandatory flag to prevent previous versions of\n-    //! bitcoin from opening the wallet, thinking it was newly created, and\n-    //! then improperly reinitializing it.\n-    WALLET_FLAG_BLANK_WALLET = (1ULL << 33),\n-};\n-\n static constexpr uint64_t KNOWN_WALLET_FLAGS =\n         WALLET_FLAG_AVOID_REUSE\n     |   WALLET_FLAG_BLANK_WALLET"
      },
      {
        "sha": "044c757e68d803e71f14994fb1e7ef9243140e79",
        "filename": "src/wallet/walletutil.h",
        "status": "modified",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab053ec6d1e766402f88947d29cd875a285e7280/src/wallet/walletutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab053ec6d1e766402f88947d29cd875a285e7280/src/wallet/walletutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletutil.h?ref=ab053ec6d1e766402f88947d29cd875a285e7280",
        "patch": "@@ -9,6 +9,54 @@\n \n #include <vector>\n \n+/** (client) version numbers for particular wallet features */\n+enum WalletFeature\n+{\n+    FEATURE_BASE = 10500, // the earliest version new wallets supports (only useful for getwalletinfo's clientversion output)\n+\n+    FEATURE_WALLETCRYPT = 40000, // wallet encryption\n+    FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n+\n+    FEATURE_HD = 130000, // Hierarchical key derivation after BIP32 (HD Wallet)\n+\n+    FEATURE_HD_SPLIT = 139900, // Wallet with HD chain split (change outputs will use m/0'/1'/k)\n+\n+    FEATURE_NO_DEFAULT_KEY = 159900, // Wallet without a default key written\n+\n+    FEATURE_PRE_SPLIT_KEYPOOL = 169900, // Upgraded to HD SPLIT and can have a pre-split keypool\n+\n+    FEATURE_LATEST = FEATURE_PRE_SPLIT_KEYPOOL\n+};\n+\n+\n+\n+enum WalletFlags : uint64_t {\n+    // wallet flags in the upper section (> 1 << 31) will lead to not opening the wallet if flag is unknown\n+    // unknown wallet flags in the lower section <= (1 << 31) will be tolerated\n+\n+    // will categorize coins as clean (not reused) and dirty (reused), and handle\n+    // them with privacy considerations in mind\n+    WALLET_FLAG_AVOID_REUSE = (1ULL << 0),\n+\n+    // Indicates that the metadata has already been upgraded to contain key origins\n+    WALLET_FLAG_KEY_ORIGIN_METADATA = (1ULL << 1),\n+\n+    // will enforce the rule that the wallet can't contain any private keys (only watch-only/pubkeys)\n+    WALLET_FLAG_DISABLE_PRIVATE_KEYS = (1ULL << 32),\n+\n+    //! Flag set when a wallet contains no HD seed and no private keys, scripts,\n+    //! addresses, and other watch only things, and is therefore \"blank.\"\n+    //!\n+    //! The only function this flag serves is to distinguish a blank wallet from\n+    //! a newly created wallet when the wallet database is loaded, to avoid\n+    //! initialization that should only happen on first run.\n+    //!\n+    //! This flag is also a mandatory flag to prevent previous versions of\n+    //! bitcoin from opening the wallet, thinking it was newly created, and\n+    //! then improperly reinitializing it.\n+    WALLET_FLAG_BLANK_WALLET = (1ULL << 33),\n+};\n+\n //! Get the path of the wallet directory.\n fs::path GetWalletDir();\n "
      }
    ]
  },
  {
    "sha": "6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NzAyMDQ4ZjkxMDg5ZDdhNTY1ZTVjYTVmN2M4ZGNkMmNhNDA1YTg1",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-07T18:11:34Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-25T23:20:24Z"
      },
      "message": "MOVEONLY: Move key handling code out of wallet to keyman file\n\nStart moving wallet and ismine code to scriptpubkeyman.h, scriptpubkeyman.cpp\n\nThe easiest way to review this commit is to run:\n\n   git log -p -n1 --color-moved=dimmed_zebra\n\nAnd check that everything is a move (other than includes and copyrights comments).\n\nThis commit is move-only and doesn't change code or affect behavior.",
      "tree": {
        "sha": "06ce34574f0a51b70967af8cbd6856fb3a7b7199",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/06ce34574f0a51b70967af8cbd6856fb3a7b7199"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ab053ec6d1e766402f88947d29cd875a285e7280",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab053ec6d1e766402f88947d29cd875a285e7280",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ab053ec6d1e766402f88947d29cd875a285e7280"
      }
    ],
    "stats": {
      "total": 2762,
      "additions": 1394,
      "deletions": 1368
    },
    "files": [
      {
        "sha": "342f51793834db369e207233852c86f52d900bab",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -235,6 +235,7 @@ BITCOIN_CORE_H = \\\n   wallet/load.h \\\n   wallet/psbtwallet.h \\\n   wallet/rpcwallet.h \\\n+  wallet/scriptpubkeyman.h \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n   wallet/wallettool.h \\\n@@ -338,11 +339,11 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/db.cpp \\\n   wallet/feebumper.cpp \\\n   wallet/fees.cpp \\\n-  wallet/ismine.cpp \\\n   wallet/load.cpp \\\n   wallet/psbtwallet.cpp \\\n   wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\\n+  wallet/scriptpubkeyman.cpp \\\n   wallet/wallet.cpp \\\n   wallet/walletdb.cpp \\\n   wallet/walletutil.cpp \\"
      },
      {
        "sha": "c40fecac5c737a6a8bc2da568b058d0a167f7776",
        "filename": "src/script/signingprovider.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/script/signingprovider.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/script/signingprovider.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/signingprovider.h?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -63,8 +63,6 @@ FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvide\n class FillableSigningProvider : public SigningProvider\n {\n protected:\n-    mutable CCriticalSection cs_KeyStore;\n-\n     using KeyMap = std::map<CKeyID, CKey>;\n     using ScriptMap = std::map<CScriptID, CScript>;\n \n@@ -74,6 +72,8 @@ class FillableSigningProvider : public SigningProvider\n     void ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n \n public:\n+    mutable CCriticalSection cs_KeyStore;\n+\n     virtual bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     virtual bool AddKey(const CKey &key) { return AddKeyPubKey(key, key.GetPubKey()); }\n     virtual bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;"
      },
      {
        "sha": "fc45da440a5fd542babc63746bb86401158d9f54",
        "filename": "src/util/translation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/util/translation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/util/translation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/translation.h?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -6,7 +6,7 @@\n #define BITCOIN_UTIL_TRANSLATION_H\n \n #include <tinyformat.h>\n-\n+#include <functional>\n \n /**\n  * Bilingual messages:"
      },
      {
        "sha": "c6223188948c2a9d9745fc6877153a1dac769096",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -10,6 +10,7 @@\n #include <util/moneystr.h>\n #include <util/system.h>\n #include <util/translation.h>\n+#include <wallet/scriptpubkeyman.h>\n #include <wallet/wallet.h>\n #include <walletinitinterface.h>\n "
      },
      {
        "sha": "029b9227850af5e5287961ca6133aff3af01f53f",
        "filename": "src/wallet/ismine.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 192,
        "changes": 192,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab053ec6d1e766402f88947d29cd875a285e7280/src/wallet/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab053ec6d1e766402f88947d29cd875a285e7280/src/wallet/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/ismine.cpp?ref=ab053ec6d1e766402f88947d29cd875a285e7280",
        "patch": "@@ -1,192 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2018 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <wallet/ismine.h>\n-\n-#include <key.h>\n-#include <script/script.h>\n-#include <script/signingprovider.h>\n-#include <wallet/wallet.h>\n-\n-typedef std::vector<unsigned char> valtype;\n-\n-namespace {\n-\n-/**\n- * This is an enum that tracks the execution context of a script, similar to\n- * SigVersion in script/interpreter. It is separate however because we want to\n- * distinguish between top-level scriptPubKey execution and P2SH redeemScript\n- * execution (a distinction that has no impact on consensus rules).\n- */\n-enum class IsMineSigVersion\n-{\n-    TOP = 0,        //!< scriptPubKey execution\n-    P2SH = 1,       //!< P2SH redeemScript\n-    WITNESS_V0 = 2, //!< P2WSH witness script execution\n-};\n-\n-/**\n- * This is an internal representation of isminetype + invalidity.\n- * Its order is significant, as we return the max of all explored\n- * possibilities.\n- */\n-enum class IsMineResult\n-{\n-    NO = 0,         //!< Not ours\n-    WATCH_ONLY = 1, //!< Included in watch-only balance\n-    SPENDABLE = 2,  //!< Included in all balances\n-    INVALID = 3,    //!< Not spendable by anyone (uncompressed pubkey in segwit, P2SH inside P2SH or witness, witness inside witness)\n-};\n-\n-bool PermitsUncompressed(IsMineSigVersion sigversion)\n-{\n-    return sigversion == IsMineSigVersion::TOP || sigversion == IsMineSigVersion::P2SH;\n-}\n-\n-bool HaveKeys(const std::vector<valtype>& pubkeys, const CWallet& keystore)\n-{\n-    for (const valtype& pubkey : pubkeys) {\n-        CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (!keystore.HaveKey(keyID)) return false;\n-    }\n-    return true;\n-}\n-\n-IsMineResult IsMineInner(const CWallet& keystore, const CScript& scriptPubKey, IsMineSigVersion sigversion)\n-{\n-    IsMineResult ret = IsMineResult::NO;\n-\n-    std::vector<valtype> vSolutions;\n-    txnouttype whichType = Solver(scriptPubKey, vSolutions);\n-\n-    CKeyID keyID;\n-    switch (whichType)\n-    {\n-    case TX_NONSTANDARD:\n-    case TX_NULL_DATA:\n-    case TX_WITNESS_UNKNOWN:\n-        break;\n-    case TX_PUBKEY:\n-        keyID = CPubKey(vSolutions[0]).GetID();\n-        if (!PermitsUncompressed(sigversion) && vSolutions[0].size() != 33) {\n-            return IsMineResult::INVALID;\n-        }\n-        if (keystore.HaveKey(keyID)) {\n-            ret = std::max(ret, IsMineResult::SPENDABLE);\n-        }\n-        break;\n-    case TX_WITNESS_V0_KEYHASH:\n-    {\n-        if (sigversion == IsMineSigVersion::WITNESS_V0) {\n-            // P2WPKH inside P2WSH is invalid.\n-            return IsMineResult::INVALID;\n-        }\n-        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n-            // We do not support bare witness outputs unless the P2SH version of it would be\n-            // acceptable as well. This protects against matching before segwit activates.\n-            // This also applies to the P2WSH case.\n-            break;\n-        }\n-        ret = std::max(ret, IsMineInner(keystore, GetScriptForDestination(PKHash(uint160(vSolutions[0]))), IsMineSigVersion::WITNESS_V0));\n-        break;\n-    }\n-    case TX_PUBKEYHASH:\n-        keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!PermitsUncompressed(sigversion)) {\n-            CPubKey pubkey;\n-            if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n-                return IsMineResult::INVALID;\n-            }\n-        }\n-        if (keystore.HaveKey(keyID)) {\n-            ret = std::max(ret, IsMineResult::SPENDABLE);\n-        }\n-        break;\n-    case TX_SCRIPTHASH:\n-    {\n-        if (sigversion != IsMineSigVersion::TOP) {\n-            // P2SH inside P2WSH or P2SH is invalid.\n-            return IsMineResult::INVALID;\n-        }\n-        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n-        CScript subscript;\n-        if (keystore.GetCScript(scriptID, subscript)) {\n-            ret = std::max(ret, IsMineInner(keystore, subscript, IsMineSigVersion::P2SH));\n-        }\n-        break;\n-    }\n-    case TX_WITNESS_V0_SCRIPTHASH:\n-    {\n-        if (sigversion == IsMineSigVersion::WITNESS_V0) {\n-            // P2WSH inside P2WSH is invalid.\n-            return IsMineResult::INVALID;\n-        }\n-        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n-            break;\n-        }\n-        uint160 hash;\n-        CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(hash.begin());\n-        CScriptID scriptID = CScriptID(hash);\n-        CScript subscript;\n-        if (keystore.GetCScript(scriptID, subscript)) {\n-            ret = std::max(ret, IsMineInner(keystore, subscript, IsMineSigVersion::WITNESS_V0));\n-        }\n-        break;\n-    }\n-\n-    case TX_MULTISIG:\n-    {\n-        // Never treat bare multisig outputs as ours (they can still be made watchonly-though)\n-        if (sigversion == IsMineSigVersion::TOP) {\n-            break;\n-        }\n-\n-        // Only consider transactions \"mine\" if we own ALL the\n-        // keys involved. Multi-signature transactions that are\n-        // partially owned (somebody else has a key that can spend\n-        // them) enable spend-out-from-under-you attacks, especially\n-        // in shared-wallet situations.\n-        std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n-        if (!PermitsUncompressed(sigversion)) {\n-            for (size_t i = 0; i < keys.size(); i++) {\n-                if (keys[i].size() != 33) {\n-                    return IsMineResult::INVALID;\n-                }\n-            }\n-        }\n-        if (HaveKeys(keys, keystore)) {\n-            ret = std::max(ret, IsMineResult::SPENDABLE);\n-        }\n-        break;\n-    }\n-    }\n-\n-    if (ret == IsMineResult::NO && keystore.HaveWatchOnly(scriptPubKey)) {\n-        ret = std::max(ret, IsMineResult::WATCH_ONLY);\n-    }\n-    return ret;\n-}\n-\n-} // namespace\n-\n-isminetype IsMine(const CWallet& keystore, const CScript& scriptPubKey)\n-{\n-    switch (IsMineInner(keystore, scriptPubKey, IsMineSigVersion::TOP)) {\n-    case IsMineResult::INVALID:\n-    case IsMineResult::NO:\n-        return ISMINE_NO;\n-    case IsMineResult::WATCH_ONLY:\n-        return ISMINE_WATCH_ONLY;\n-    case IsMineResult::SPENDABLE:\n-        return ISMINE_SPENDABLE;\n-    }\n-    assert(false);\n-}\n-\n-isminetype IsMine(const CWallet& keystore, const CTxDestination& dest)\n-{\n-    CScript script = GetScriptForDestination(dest);\n-    return IsMine(keystore, script);\n-}"
      },
      {
        "sha": "77ee8f97cbdb273aeac58d9897a30a534e954dc8",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "added",
        "additions": 1262,
        "deletions": 0,
        "changes": 1262,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -0,0 +1,1262 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <key_io.h>\n+#include <outputtype.h>\n+#include <script/descriptor.h>\n+#include <util/bip32.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h>\n+#include <wallet/scriptpubkeyman.h>\n+#include <wallet/wallet.h>\n+\n+bool CWallet::GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error)\n+{\n+    LOCK(cs_wallet);\n+    error.clear();\n+\n+    TopUpKeyPool();\n+\n+    // Generate a new key that is added to wallet\n+    CPubKey new_key;\n+    if (!GetKeyFromPool(new_key)) {\n+        error = \"Error: Keypool ran out, please call keypoolrefill first\";\n+        return false;\n+    }\n+    LearnRelatedScripts(new_key, type);\n+    dest = GetDestinationForKey(new_key, type);\n+\n+    SetAddressBook(dest, label, \"receive\");\n+    return true;\n+}\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+namespace {\n+\n+/**\n+ * This is an enum that tracks the execution context of a script, similar to\n+ * SigVersion in script/interpreter. It is separate however because we want to\n+ * distinguish between top-level scriptPubKey execution and P2SH redeemScript\n+ * execution (a distinction that has no impact on consensus rules).\n+ */\n+enum class IsMineSigVersion\n+{\n+    TOP = 0,        //!< scriptPubKey execution\n+    P2SH = 1,       //!< P2SH redeemScript\n+    WITNESS_V0 = 2, //!< P2WSH witness script execution\n+};\n+\n+/**\n+ * This is an internal representation of isminetype + invalidity.\n+ * Its order is significant, as we return the max of all explored\n+ * possibilities.\n+ */\n+enum class IsMineResult\n+{\n+    NO = 0,         //!< Not ours\n+    WATCH_ONLY = 1, //!< Included in watch-only balance\n+    SPENDABLE = 2,  //!< Included in all balances\n+    INVALID = 3,    //!< Not spendable by anyone (uncompressed pubkey in segwit, P2SH inside P2SH or witness, witness inside witness)\n+};\n+\n+bool PermitsUncompressed(IsMineSigVersion sigversion)\n+{\n+    return sigversion == IsMineSigVersion::TOP || sigversion == IsMineSigVersion::P2SH;\n+}\n+\n+bool HaveKeys(const std::vector<valtype>& pubkeys, const CWallet& keystore)\n+{\n+    for (const valtype& pubkey : pubkeys) {\n+        CKeyID keyID = CPubKey(pubkey).GetID();\n+        if (!keystore.HaveKey(keyID)) return false;\n+    }\n+    return true;\n+}\n+\n+IsMineResult IsMineInner(const CWallet& keystore, const CScript& scriptPubKey, IsMineSigVersion sigversion)\n+{\n+    IsMineResult ret = IsMineResult::NO;\n+\n+    std::vector<valtype> vSolutions;\n+    txnouttype whichType = Solver(scriptPubKey, vSolutions);\n+\n+    CKeyID keyID;\n+    switch (whichType)\n+    {\n+    case TX_NONSTANDARD:\n+    case TX_NULL_DATA:\n+    case TX_WITNESS_UNKNOWN:\n+        break;\n+    case TX_PUBKEY:\n+        keyID = CPubKey(vSolutions[0]).GetID();\n+        if (!PermitsUncompressed(sigversion) && vSolutions[0].size() != 33) {\n+            return IsMineResult::INVALID;\n+        }\n+        if (keystore.HaveKey(keyID)) {\n+            ret = std::max(ret, IsMineResult::SPENDABLE);\n+        }\n+        break;\n+    case TX_WITNESS_V0_KEYHASH:\n+    {\n+        if (sigversion == IsMineSigVersion::WITNESS_V0) {\n+            // P2WPKH inside P2WSH is invalid.\n+            return IsMineResult::INVALID;\n+        }\n+        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+            // We do not support bare witness outputs unless the P2SH version of it would be\n+            // acceptable as well. This protects against matching before segwit activates.\n+            // This also applies to the P2WSH case.\n+            break;\n+        }\n+        ret = std::max(ret, IsMineInner(keystore, GetScriptForDestination(PKHash(uint160(vSolutions[0]))), IsMineSigVersion::WITNESS_V0));\n+        break;\n+    }\n+    case TX_PUBKEYHASH:\n+        keyID = CKeyID(uint160(vSolutions[0]));\n+        if (!PermitsUncompressed(sigversion)) {\n+            CPubKey pubkey;\n+            if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n+                return IsMineResult::INVALID;\n+            }\n+        }\n+        if (keystore.HaveKey(keyID)) {\n+            ret = std::max(ret, IsMineResult::SPENDABLE);\n+        }\n+        break;\n+    case TX_SCRIPTHASH:\n+    {\n+        if (sigversion != IsMineSigVersion::TOP) {\n+            // P2SH inside P2WSH or P2SH is invalid.\n+            return IsMineResult::INVALID;\n+        }\n+        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n+        CScript subscript;\n+        if (keystore.GetCScript(scriptID, subscript)) {\n+            ret = std::max(ret, IsMineInner(keystore, subscript, IsMineSigVersion::P2SH));\n+        }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH:\n+    {\n+        if (sigversion == IsMineSigVersion::WITNESS_V0) {\n+            // P2WSH inside P2WSH is invalid.\n+            return IsMineResult::INVALID;\n+        }\n+        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+            break;\n+        }\n+        uint160 hash;\n+        CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(hash.begin());\n+        CScriptID scriptID = CScriptID(hash);\n+        CScript subscript;\n+        if (keystore.GetCScript(scriptID, subscript)) {\n+            ret = std::max(ret, IsMineInner(keystore, subscript, IsMineSigVersion::WITNESS_V0));\n+        }\n+        break;\n+    }\n+\n+    case TX_MULTISIG:\n+    {\n+        // Never treat bare multisig outputs as ours (they can still be made watchonly-though)\n+        if (sigversion == IsMineSigVersion::TOP) {\n+            break;\n+        }\n+\n+        // Only consider transactions \"mine\" if we own ALL the\n+        // keys involved. Multi-signature transactions that are\n+        // partially owned (somebody else has a key that can spend\n+        // them) enable spend-out-from-under-you attacks, especially\n+        // in shared-wallet situations.\n+        std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        if (!PermitsUncompressed(sigversion)) {\n+            for (size_t i = 0; i < keys.size(); i++) {\n+                if (keys[i].size() != 33) {\n+                    return IsMineResult::INVALID;\n+                }\n+            }\n+        }\n+        if (HaveKeys(keys, keystore)) {\n+            ret = std::max(ret, IsMineResult::SPENDABLE);\n+        }\n+        break;\n+    }\n+    }\n+\n+    if (ret == IsMineResult::NO && keystore.HaveWatchOnly(scriptPubKey)) {\n+        ret = std::max(ret, IsMineResult::WATCH_ONLY);\n+    }\n+    return ret;\n+}\n+\n+} // namespace\n+\n+isminetype IsMine(const CWallet& keystore, const CScript& scriptPubKey)\n+{\n+    switch (IsMineInner(keystore, scriptPubKey, IsMineSigVersion::TOP)) {\n+    case IsMineResult::INVALID:\n+    case IsMineResult::NO:\n+        return ISMINE_NO;\n+    case IsMineResult::WATCH_ONLY:\n+        return ISMINE_WATCH_ONLY;\n+    case IsMineResult::SPENDABLE:\n+        return ISMINE_SPENDABLE;\n+    }\n+    assert(false);\n+}\n+\n+bool CWallet::Unlock(const CKeyingMaterial& vMasterKeyIn, bool accept_no_keys)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!SetCrypted())\n+            return false;\n+\n+        bool keyPass = mapCryptedKeys.empty(); // Always pass when there are no encrypted keys\n+        bool keyFail = false;\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+        for (; mi != mapCryptedKeys.end(); ++mi)\n+        {\n+            const CPubKey &vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+            CKey key;\n+            if (!DecryptKey(vMasterKeyIn, vchCryptedSecret, vchPubKey, key))\n+            {\n+                keyFail = true;\n+                break;\n+            }\n+            keyPass = true;\n+            if (fDecryptionThoroughlyChecked)\n+                break;\n+        }\n+        if (keyPass && keyFail)\n+        {\n+            LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\\n\");\n+            throw std::runtime_error(\"Error unlocking wallet: some keys decrypt but not all. Your wallet file may be corrupt.\");\n+        }\n+        if (keyFail || (!keyPass && !accept_no_keys))\n+            return false;\n+        vMasterKey = vMasterKeyIn;\n+        fDecryptionThoroughlyChecked = true;\n+    }\n+    NotifyStatusChanged(this);\n+    return true;\n+}\n+\n+bool CWallet::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n+{\n+    LOCK(cs_KeyStore);\n+    if (!mapCryptedKeys.empty() || IsCrypted())\n+        return false;\n+\n+    fUseCrypto = true;\n+    for (const KeyMap::value_type& mKey : mapKeys)\n+    {\n+        const CKey &key = mKey.second;\n+        CPubKey vchPubKey = key.GetPubKey();\n+        CKeyingMaterial vchSecret(key.begin(), key.end());\n+        std::vector<unsigned char> vchCryptedSecret;\n+        if (!EncryptSecret(vMasterKeyIn, vchSecret, vchPubKey.GetHash(), vchCryptedSecret))\n+            return false;\n+        if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n+            return false;\n+    }\n+    mapKeys.clear();\n+    return true;\n+}\n+\n+void CWallet::UpgradeKeyMetadata()\n+{\n+    AssertLockHeld(cs_wallet);\n+    if (IsLocked() || IsWalletFlagSet(WALLET_FLAG_KEY_ORIGIN_METADATA)) {\n+        return;\n+    }\n+\n+    std::unique_ptr<WalletBatch> batch = MakeUnique<WalletBatch>(*database);\n+    for (auto& meta_pair : mapKeyMetadata) {\n+        CKeyMetadata& meta = meta_pair.second;\n+        if (!meta.hd_seed_id.IsNull() && !meta.has_key_origin && meta.hdKeypath != \"s\") { // If the hdKeypath is \"s\", that's the seed and it doesn't have a key origin\n+            CKey key;\n+            GetKey(meta.hd_seed_id, key);\n+            CExtKey masterKey;\n+            masterKey.SetSeed(key.begin(), key.size());\n+            // Add to map\n+            CKeyID master_id = masterKey.key.GetPubKey().GetID();\n+            std::copy(master_id.begin(), master_id.begin() + 4, meta.key_origin.fingerprint);\n+            if (!ParseHDKeypath(meta.hdKeypath, meta.key_origin.path)) {\n+                throw std::runtime_error(\"Invalid stored hdKeypath\");\n+            }\n+            meta.has_key_origin = true;\n+            if (meta.nVersion < CKeyMetadata::VERSION_WITH_KEY_ORIGIN) {\n+                meta.nVersion = CKeyMetadata::VERSION_WITH_KEY_ORIGIN;\n+            }\n+\n+            // Write meta to wallet\n+            CPubKey pubkey;\n+            if (GetPubKey(meta_pair.first, pubkey)) {\n+                batch->WriteKeyMetadata(meta, pubkey, true);\n+            }\n+        }\n+    }\n+    batch.reset(); //write before setting the flag\n+    SetWalletFlag(WALLET_FLAG_KEY_ORIGIN_METADATA);\n+}\n+\n+bool CWallet::IsHDEnabled() const\n+{\n+    return !hdChain.seed_id.IsNull();\n+}\n+\n+bool CWallet::CanGetAddresses(bool internal)\n+{\n+    LOCK(cs_wallet);\n+    // Check if the keypool has keys\n+    bool keypool_has_keys;\n+    if (internal && CanSupportFeature(FEATURE_HD_SPLIT)) {\n+        keypool_has_keys = setInternalKeyPool.size() > 0;\n+    } else {\n+        keypool_has_keys = KeypoolCountExternalKeys() > 0;\n+    }\n+    // If the keypool doesn't have keys, check if we can generate them\n+    if (!keypool_has_keys) {\n+        return CanGenerateKeys();\n+    }\n+    return keypool_has_keys;\n+}\n+\n+static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, WalletBatch& batch) {\n+    if (setKeyPool.empty()) {\n+        return GetTime();\n+    }\n+\n+    CKeyPool keypool;\n+    int64_t nIndex = *(setKeyPool.begin());\n+    if (!batch.ReadPool(nIndex, keypool)) {\n+        throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n+    }\n+    assert(keypool.vchPubKey.IsValid());\n+    return keypool.nTime;\n+}\n+\n+int64_t CWallet::GetOldestKeyPoolTime()\n+{\n+    LOCK(cs_wallet);\n+\n+    WalletBatch batch(*database);\n+\n+    // load oldest key from keypool, get time and return\n+    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, batch);\n+    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n+        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, batch), oldestKey);\n+        if (!set_pre_split_keypool.empty()) {\n+            oldestKey = std::max(GetOldestKeyTimeInPool(set_pre_split_keypool, batch), oldestKey);\n+        }\n+    }\n+\n+    return oldestKey;\n+}\n+\n+size_t CWallet::KeypoolCountExternalKeys()\n+{\n+    AssertLockHeld(cs_wallet);\n+    return setExternalKeyPool.size() + set_pre_split_keypool.size();\n+}\n+\n+/**\n+ * Update wallet first key creation time. This should be called whenever keys\n+ * are added to the wallet, with the oldest key creation time.\n+ */\n+void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n+{\n+    AssertLockHeld(cs_wallet);\n+    if (nCreateTime <= 1) {\n+        // Cannot determine birthday information, so set the wallet birthday to\n+        // the beginning of time.\n+        nTimeFirstKey = 1;\n+    } else if (!nTimeFirstKey || nCreateTime < nTimeFirstKey) {\n+        nTimeFirstKey = nCreateTime;\n+    }\n+}\n+\n+bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+{\n+    WalletBatch batch(*database);\n+    return CWallet::AddKeyPubKeyWithDB(batch, secret, pubkey);\n+}\n+\n+bool CWallet::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const CPubKey& pubkey)\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    // Make sure we aren't adding private keys to private key disabled wallets\n+    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n+\n+    // FillableSigningProvider has no concept of wallet databases, but calls AddCryptedKey\n+    // which is overridden below.  To avoid flushes, the database handle is\n+    // tunneled through to it.\n+    bool needsDB = !encrypted_batch;\n+    if (needsDB) {\n+        encrypted_batch = &batch;\n+    }\n+    if (!AddKeyPubKeyInner(secret, pubkey)) {\n+        if (needsDB) encrypted_batch = nullptr;\n+        return false;\n+    }\n+    if (needsDB) encrypted_batch = nullptr;\n+\n+    // check if we need to remove from watch-only\n+    CScript script;\n+    script = GetScriptForDestination(PKHash(pubkey));\n+    if (HaveWatchOnly(script)) {\n+        RemoveWatchOnly(script);\n+    }\n+    script = GetScriptForRawPubKey(pubkey);\n+    if (HaveWatchOnly(script)) {\n+        RemoveWatchOnly(script);\n+    }\n+\n+    if (!IsCrypted()) {\n+        return batch.WriteKey(pubkey,\n+                                                 secret.GetPrivKey(),\n+                                                 mapKeyMetadata[pubkey.GetID()]);\n+    }\n+    UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n+    return true;\n+}\n+\n+bool CWallet::LoadCScript(const CScript& redeemScript)\n+{\n+    /* A sanity check was added in pull #3843 to avoid adding redeemScripts\n+     * that never can be redeemed. However, old wallets may still contain\n+     * these. Do not add them to the wallet and warn. */\n+    if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n+    {\n+        std::string strAddr = EncodeDestination(ScriptHash(redeemScript));\n+        WalletLogPrintf(\"%s: Warning: This wallet contains a redeemScript of size %i which exceeds maximum size %i thus can never be redeemed. Do not use address %s.\\n\", __func__, redeemScript.size(), MAX_SCRIPT_ELEMENT_SIZE, strAddr);\n+        return true;\n+    }\n+\n+    return FillableSigningProvider::AddCScript(redeemScript);\n+}\n+\n+void CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata& meta)\n+{\n+    AssertLockHeld(cs_wallet);\n+    UpdateTimeFirstKey(meta.nCreateTime);\n+    mapKeyMetadata[keyID] = meta;\n+}\n+\n+void CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata& meta)\n+{\n+    AssertLockHeld(cs_wallet);\n+    UpdateTimeFirstKey(meta.nCreateTime);\n+    m_script_metadata[script_id] = meta;\n+}\n+\n+bool CWallet::AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey)\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted()) {\n+        return FillableSigningProvider::AddKeyPubKey(key, pubkey);\n+    }\n+\n+    if (IsLocked()) {\n+        return false;\n+    }\n+\n+    std::vector<unsigned char> vchCryptedSecret;\n+    CKeyingMaterial vchSecret(key.begin(), key.end());\n+    if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) {\n+        return false;\n+    }\n+\n+    if (!AddCryptedKey(pubkey, vchCryptedSecret)) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+{\n+    return AddCryptedKeyInner(vchPubKey, vchCryptedSecret);\n+}\n+\n+bool CWallet::AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+{\n+    LOCK(cs_KeyStore);\n+    if (!SetCrypted()) {\n+        return false;\n+    }\n+\n+    mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);\n+    ImplicitlyLearnRelatedKeyScripts(vchPubKey);\n+    return true;\n+}\n+\n+bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n+                            const std::vector<unsigned char> &vchCryptedSecret)\n+{\n+    if (!AddCryptedKeyInner(vchPubKey, vchCryptedSecret))\n+        return false;\n+    {\n+        LOCK(cs_wallet);\n+        if (encrypted_batch)\n+            return encrypted_batch->WriteCryptedKey(vchPubKey,\n+                                                        vchCryptedSecret,\n+                                                        mapKeyMetadata[vchPubKey.GetID()]);\n+        else\n+            return WalletBatch(*database).WriteCryptedKey(vchPubKey,\n+                                                            vchCryptedSecret,\n+                                                            mapKeyMetadata[vchPubKey.GetID()]);\n+    }\n+}\n+\n+bool CWallet::HaveWatchOnly(const CScript &dest) const\n+{\n+    LOCK(cs_KeyStore);\n+    return setWatchOnly.count(dest) > 0;\n+}\n+\n+bool CWallet::HaveWatchOnly() const\n+{\n+    LOCK(cs_KeyStore);\n+    return (!setWatchOnly.empty());\n+}\n+\n+static bool ExtractPubKey(const CScript &dest, CPubKey& pubKeyOut)\n+{\n+    std::vector<std::vector<unsigned char>> solutions;\n+    return Solver(dest, solutions) == TX_PUBKEY &&\n+        (pubKeyOut = CPubKey(solutions[0])).IsFullyValid();\n+}\n+\n+bool CWallet::RemoveWatchOnly(const CScript &dest)\n+{\n+    AssertLockHeld(cs_wallet);\n+    {\n+        LOCK(cs_KeyStore);\n+        setWatchOnly.erase(dest);\n+        CPubKey pubKey;\n+        if (ExtractPubKey(dest, pubKey)) {\n+            mapWatchKeys.erase(pubKey.GetID());\n+        }\n+        // Related CScripts are not removed; having superfluous scripts around is\n+        // harmless (see comment in ImplicitlyLearnRelatedKeyScripts).\n+    }\n+\n+    if (!HaveWatchOnly())\n+        NotifyWatchonlyChanged(false);\n+    if (!WalletBatch(*database).EraseWatchOnly(dest))\n+        return false;\n+\n+    return true;\n+}\n+\n+bool CWallet::LoadWatchOnly(const CScript &dest)\n+{\n+    return AddWatchOnlyInMem(dest);\n+}\n+\n+bool CWallet::AddWatchOnlyInMem(const CScript &dest)\n+{\n+    LOCK(cs_KeyStore);\n+    setWatchOnly.insert(dest);\n+    CPubKey pubKey;\n+    if (ExtractPubKey(dest, pubKey)) {\n+        mapWatchKeys[pubKey.GetID()] = pubKey;\n+        ImplicitlyLearnRelatedKeyScripts(pubKey);\n+    }\n+    return true;\n+}\n+\n+bool CWallet::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest)\n+{\n+    if (!AddWatchOnlyInMem(dest))\n+        return false;\n+    const CKeyMetadata& meta = m_script_metadata[CScriptID(dest)];\n+    UpdateTimeFirstKey(meta.nCreateTime);\n+    NotifyWatchonlyChanged(true);\n+    if (batch.WriteWatchOnly(dest, meta)) {\n+        UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CWallet::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest, int64_t create_time)\n+{\n+    m_script_metadata[CScriptID(dest)].nCreateTime = create_time;\n+    return AddWatchOnlyWithDB(batch, dest);\n+}\n+\n+bool CWallet::AddWatchOnly(const CScript& dest)\n+{\n+    WalletBatch batch(*database);\n+    return AddWatchOnlyWithDB(batch, dest);\n+}\n+\n+bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n+{\n+    m_script_metadata[CScriptID(dest)].nCreateTime = nCreateTime;\n+    return AddWatchOnly(dest);\n+}\n+\n+void CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n+{\n+    LOCK(cs_wallet);\n+    if (!memonly && !WalletBatch(*database).WriteHDChain(chain))\n+        throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n+\n+    hdChain = chain;\n+}\n+\n+bool CWallet::HaveKey(const CKeyID &address) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted()) {\n+        return FillableSigningProvider::HaveKey(address);\n+    }\n+    return mapCryptedKeys.count(address) > 0;\n+}\n+\n+bool CWallet::GetKey(const CKeyID &address, CKey& keyOut) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted()) {\n+        return FillableSigningProvider::GetKey(address, keyOut);\n+    }\n+\n+    CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+    if (mi != mapCryptedKeys.end())\n+    {\n+        const CPubKey &vchPubKey = (*mi).second.first;\n+        const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+        return DecryptKey(vMasterKey, vchCryptedSecret, vchPubKey, keyOut);\n+    }\n+    return false;\n+}\n+\n+bool CWallet::GetKeyOrigin(const CKeyID& keyID, KeyOriginInfo& info) const\n+{\n+    CKeyMetadata meta;\n+    {\n+        LOCK(cs_wallet);\n+        auto it = mapKeyMetadata.find(keyID);\n+        if (it != mapKeyMetadata.end()) {\n+            meta = it->second;\n+        }\n+    }\n+    if (meta.has_key_origin) {\n+        std::copy(meta.key_origin.fingerprint, meta.key_origin.fingerprint + 4, info.fingerprint);\n+        info.path = meta.key_origin.path;\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        std::copy(keyID.begin(), keyID.begin() + 4, info.fingerprint);\n+    }\n+    return true;\n+}\n+\n+bool CWallet::GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const\n+{\n+    LOCK(cs_KeyStore);\n+    WatchKeyMap::const_iterator it = mapWatchKeys.find(address);\n+    if (it != mapWatchKeys.end()) {\n+        pubkey_out = it->second;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CWallet::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted()) {\n+        if (!FillableSigningProvider::GetPubKey(address, vchPubKeyOut)) {\n+            return GetWatchPubKey(address, vchPubKeyOut);\n+        }\n+        return true;\n+    }\n+\n+    CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+    if (mi != mapCryptedKeys.end())\n+    {\n+        vchPubKeyOut = (*mi).second.first;\n+        return true;\n+    }\n+    // Check for watch-only pubkeys\n+    return GetWatchPubKey(address, vchPubKeyOut);\n+}\n+\n+CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n+{\n+    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n+    assert(!IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET));\n+    AssertLockHeld(cs_wallet);\n+    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n+\n+    CKey secret;\n+\n+    // Create new metadata\n+    int64_t nCreationTime = GetTime();\n+    CKeyMetadata metadata(nCreationTime);\n+\n+    // use HD key derivation if HD was enabled during wallet creation and a seed is present\n+    if (IsHDEnabled()) {\n+        DeriveNewChildKey(batch, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n+    } else {\n+        secret.MakeNewKey(fCompressed);\n+    }\n+\n+    // Compressed public keys were introduced in version 0.6.0\n+    if (fCompressed) {\n+        SetMinVersion(FEATURE_COMPRPUBKEY);\n+    }\n+\n+    CPubKey pubkey = secret.GetPubKey();\n+    assert(secret.VerifyPubKey(pubkey));\n+\n+    mapKeyMetadata[pubkey.GetID()] = metadata;\n+    UpdateTimeFirstKey(nCreationTime);\n+\n+    if (!AddKeyPubKeyWithDB(batch, secret, pubkey)) {\n+        throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n+    }\n+    return pubkey;\n+}\n+\n+const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n+\n+void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal)\n+{\n+    // for now we use a fixed keypath scheme of m/0'/0'/k\n+    CKey seed;                     //seed (256bit)\n+    CExtKey masterKey;             //hd master key\n+    CExtKey accountKey;            //key at m/0'\n+    CExtKey chainChildKey;         //key at m/0'/0' (external) or m/0'/1' (internal)\n+    CExtKey childKey;              //key at m/0'/0'/<n>'\n+\n+    // try to get the seed\n+    if (!GetKey(hdChain.seed_id, seed))\n+        throw std::runtime_error(std::string(__func__) + \": seed not found\");\n+\n+    masterKey.SetSeed(seed.begin(), seed.size());\n+\n+    // derive m/0'\n+    // use hardened derivation (child keys >= 0x80000000 are hardened after bip32)\n+    masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);\n+\n+    // derive m/0'/0' (external chain) OR m/0'/1' (internal chain)\n+    assert(internal ? CanSupportFeature(FEATURE_HD_SPLIT) : true);\n+    accountKey.Derive(chainChildKey, BIP32_HARDENED_KEY_LIMIT+(internal ? 1 : 0));\n+\n+    // derive child key at next index, skip keys already known to the wallet\n+    do {\n+        // always derive hardened keys\n+        // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range\n+        // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649\n+        if (internal) {\n+            chainChildKey.Derive(childKey, hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.hdKeypath = \"m/0'/1'/\" + std::to_string(hdChain.nInternalChainCounter) + \"'\";\n+            metadata.key_origin.path.push_back(0 | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.key_origin.path.push_back(1 | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.key_origin.path.push_back(hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n+            hdChain.nInternalChainCounter++;\n+        }\n+        else {\n+            chainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.hdKeypath = \"m/0'/0'/\" + std::to_string(hdChain.nExternalChainCounter) + \"'\";\n+            metadata.key_origin.path.push_back(0 | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.key_origin.path.push_back(0 | BIP32_HARDENED_KEY_LIMIT);\n+            metadata.key_origin.path.push_back(hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n+            hdChain.nExternalChainCounter++;\n+        }\n+    } while (HaveKey(childKey.key.GetPubKey().GetID()));\n+    secret = childKey.key;\n+    metadata.hd_seed_id = hdChain.seed_id;\n+    CKeyID master_id = masterKey.key.GetPubKey().GetID();\n+    std::copy(master_id.begin(), master_id.begin() + 4, metadata.key_origin.fingerprint);\n+    metadata.has_key_origin = true;\n+    // update the chain model in the database\n+    if (!batch.WriteHDChain(hdChain))\n+        throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n+}\n+\n+void CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n+{\n+    AssertLockHeld(cs_wallet);\n+    if (keypool.m_pre_split) {\n+        set_pre_split_keypool.insert(nIndex);\n+    } else if (keypool.fInternal) {\n+        setInternalKeyPool.insert(nIndex);\n+    } else {\n+        setExternalKeyPool.insert(nIndex);\n+    }\n+    m_max_keypool_index = std::max(m_max_keypool_index, nIndex);\n+    m_pool_key_to_index[keypool.vchPubKey.GetID()] = nIndex;\n+\n+    // If no metadata exists yet, create a default with the pool key's\n+    // creation time. Note that this may be overwritten by actually\n+    // stored metadata for that key later, which is fine.\n+    CKeyID keyid = keypool.vchPubKey.GetID();\n+    if (mapKeyMetadata.count(keyid) == 0)\n+        mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n+}\n+\n+bool CWallet::CanGenerateKeys()\n+{\n+    // A wallet can generate keys if it has an HD seed (IsHDEnabled) or it is a non-HD wallet (pre FEATURE_HD)\n+    LOCK(cs_wallet);\n+    return IsHDEnabled() || !CanSupportFeature(FEATURE_HD);\n+}\n+\n+CPubKey CWallet::GenerateNewSeed()\n+{\n+    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n+    CKey key;\n+    key.MakeNewKey(true);\n+    return DeriveNewSeed(key);\n+}\n+\n+CPubKey CWallet::DeriveNewSeed(const CKey& key)\n+{\n+    int64_t nCreationTime = GetTime();\n+    CKeyMetadata metadata(nCreationTime);\n+\n+    // calculate the seed\n+    CPubKey seed = key.GetPubKey();\n+    assert(key.VerifyPubKey(seed));\n+\n+    // set the hd keypath to \"s\" -> Seed, refers the seed to itself\n+    metadata.hdKeypath     = \"s\";\n+    metadata.has_key_origin = false;\n+    metadata.hd_seed_id = seed.GetID();\n+\n+    {\n+        LOCK(cs_wallet);\n+\n+        // mem store the metadata\n+        mapKeyMetadata[seed.GetID()] = metadata;\n+\n+        // write the key&metadata to the database\n+        if (!AddKeyPubKey(key, seed))\n+            throw std::runtime_error(std::string(__func__) + \": AddKeyPubKey failed\");\n+    }\n+\n+    return seed;\n+}\n+\n+void CWallet::SetHDSeed(const CPubKey& seed)\n+{\n+    LOCK(cs_wallet);\n+    // store the keyid (hash160) together with\n+    // the child index counter in the database\n+    // as a hdchain object\n+    CHDChain newHdChain;\n+    newHdChain.nVersion = CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n+    newHdChain.seed_id = seed.GetID();\n+    SetHDChain(newHdChain, false);\n+    NotifyCanGetAddressesChanged();\n+    UnsetWalletFlag(WALLET_FLAG_BLANK_WALLET);\n+}\n+\n+/**\n+ * Mark old keypool keys as used,\n+ * and generate all new keys\n+ */\n+bool CWallet::NewKeyPool()\n+{\n+    if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        return false;\n+    }\n+    {\n+        LOCK(cs_wallet);\n+        WalletBatch batch(*database);\n+\n+        for (const int64_t nIndex : setInternalKeyPool) {\n+            batch.ErasePool(nIndex);\n+        }\n+        setInternalKeyPool.clear();\n+\n+        for (const int64_t nIndex : setExternalKeyPool) {\n+            batch.ErasePool(nIndex);\n+        }\n+        setExternalKeyPool.clear();\n+\n+        for (const int64_t nIndex : set_pre_split_keypool) {\n+            batch.ErasePool(nIndex);\n+        }\n+        set_pre_split_keypool.clear();\n+\n+        m_pool_key_to_index.clear();\n+\n+        if (!TopUpKeyPool()) {\n+            return false;\n+        }\n+        WalletLogPrintf(\"CWallet::NewKeyPool rewrote keypool\\n\");\n+    }\n+    return true;\n+}\n+\n+bool CWallet::TopUpKeyPool(unsigned int kpSize)\n+{\n+    if (!CanGenerateKeys()) {\n+        return false;\n+    }\n+    {\n+        LOCK(cs_wallet);\n+\n+        if (IsLocked()) return false;\n+\n+        // Top up key pool\n+        unsigned int nTargetSize;\n+        if (kpSize > 0)\n+            nTargetSize = kpSize;\n+        else\n+            nTargetSize = std::max(gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n+\n+        // count amount of available keys (internal, external)\n+        // make sure the keypool of external and internal keys fits the user selected target (-keypool)\n+        int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setExternalKeyPool.size(), (int64_t) 0);\n+        int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setInternalKeyPool.size(), (int64_t) 0);\n+\n+        if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n+        {\n+            // don't create extra internal keys\n+            missingInternal = 0;\n+        }\n+        bool internal = false;\n+        WalletBatch batch(*database);\n+        for (int64_t i = missingInternal + missingExternal; i--;)\n+        {\n+            if (i < missingInternal) {\n+                internal = true;\n+            }\n+\n+            CPubKey pubkey(GenerateNewKey(batch, internal));\n+            AddKeypoolPubkeyWithDB(pubkey, internal, batch);\n+        }\n+        if (missingInternal + missingExternal > 0) {\n+            WalletLogPrintf(\"keypool added %d keys (%d internal), size=%u (%u internal)\\n\", missingInternal + missingExternal, missingInternal, setInternalKeyPool.size() + setExternalKeyPool.size() + set_pre_split_keypool.size(), setInternalKeyPool.size());\n+        }\n+    }\n+    NotifyCanGetAddressesChanged();\n+    return true;\n+}\n+\n+void CWallet::AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal, WalletBatch& batch)\n+{\n+    LOCK(cs_wallet);\n+    assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n+    int64_t index = ++m_max_keypool_index;\n+    if (!batch.WritePool(index, CKeyPool(pubkey, internal))) {\n+        throw std::runtime_error(std::string(__func__) + \": writing imported pubkey failed\");\n+    }\n+    if (internal) {\n+        setInternalKeyPool.insert(index);\n+    } else {\n+        setExternalKeyPool.insert(index);\n+    }\n+    m_pool_key_to_index[pubkey.GetID()] = index;\n+}\n+\n+void CWallet::KeepKey(int64_t nIndex)\n+{\n+    // Remove from key pool\n+    WalletBatch batch(*database);\n+    batch.ErasePool(nIndex);\n+    WalletLogPrintf(\"keypool keep %d\\n\", nIndex);\n+}\n+\n+void CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n+{\n+    // Return to key pool\n+    {\n+        LOCK(cs_wallet);\n+        if (fInternal) {\n+            setInternalKeyPool.insert(nIndex);\n+        } else if (!set_pre_split_keypool.empty()) {\n+            set_pre_split_keypool.insert(nIndex);\n+        } else {\n+            setExternalKeyPool.insert(nIndex);\n+        }\n+        m_pool_key_to_index[pubkey.GetID()] = nIndex;\n+        NotifyCanGetAddressesChanged();\n+    }\n+    WalletLogPrintf(\"keypool return %d\\n\", nIndex);\n+}\n+\n+bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n+{\n+    if (!CanGetAddresses(internal)) {\n+        return false;\n+    }\n+\n+    CKeyPool keypool;\n+    {\n+        LOCK(cs_wallet);\n+        int64_t nIndex;\n+        if (!ReserveKeyFromKeyPool(nIndex, keypool, internal) && !IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+            if (IsLocked()) return false;\n+            WalletBatch batch(*database);\n+            result = GenerateNewKey(batch, internal);\n+            return true;\n+        }\n+        KeepKey(nIndex);\n+        result = keypool.vchPubKey;\n+    }\n+    return true;\n+}\n+\n+bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n+{\n+    nIndex = -1;\n+    keypool.vchPubKey = CPubKey();\n+    {\n+        LOCK(cs_wallet);\n+\n+        TopUpKeyPool();\n+\n+        bool fReturningInternal = fRequestedInternal;\n+        fReturningInternal &= (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) || IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+        bool use_split_keypool = set_pre_split_keypool.empty();\n+        std::set<int64_t>& setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool;\n+\n+        // Get the oldest key\n+        if (setKeyPool.empty()) {\n+            return false;\n+        }\n+\n+        WalletBatch batch(*database);\n+\n+        auto it = setKeyPool.begin();\n+        nIndex = *it;\n+        setKeyPool.erase(it);\n+        if (!batch.ReadPool(nIndex, keypool)) {\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n+        }\n+        CPubKey pk;\n+        if (!GetPubKey(keypool.vchPubKey.GetID(), pk)) {\n+            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n+        }\n+        // If the key was pre-split keypool, we don't care about what type it is\n+        if (use_split_keypool && keypool.fInternal != fReturningInternal) {\n+            throw std::runtime_error(std::string(__func__) + \": keypool entry misclassified\");\n+        }\n+        if (!keypool.vchPubKey.IsValid()) {\n+            throw std::runtime_error(std::string(__func__) + \": keypool entry invalid\");\n+        }\n+\n+        m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n+        WalletLogPrintf(\"keypool reserve %d\\n\", nIndex);\n+    }\n+    NotifyCanGetAddressesChanged();\n+    return true;\n+}\n+\n+void CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n+{\n+    if (key.IsCompressed() && (type == OutputType::P2SH_SEGWIT || type == OutputType::BECH32)) {\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        // Make sure the resulting program is solvable.\n+        assert(IsSolvable(*this, witprog));\n+        AddCScript(witprog);\n+    }\n+}\n+\n+void CWallet::LearnAllRelatedScripts(const CPubKey& key)\n+{\n+    // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.\n+    LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n+}\n+\n+void CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n+{\n+    AssertLockHeld(cs_wallet);\n+    bool internal = setInternalKeyPool.count(keypool_id);\n+    if (!internal) assert(setExternalKeyPool.count(keypool_id) || set_pre_split_keypool.count(keypool_id));\n+    std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : (set_pre_split_keypool.empty() ? &setExternalKeyPool : &set_pre_split_keypool);\n+    auto it = setKeyPool->begin();\n+\n+    WalletBatch batch(*database);\n+    while (it != std::end(*setKeyPool)) {\n+        const int64_t& index = *(it);\n+        if (index > keypool_id) break; // set*KeyPool is ordered\n+\n+        CKeyPool keypool;\n+        if (batch.ReadPool(index, keypool)) { //TODO: This should be unnecessary\n+            m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n+        }\n+        LearnAllRelatedScripts(keypool.vchPubKey);\n+        batch.ErasePool(index);\n+        WalletLogPrintf(\"keypool index %d removed\\n\", index);\n+        it = setKeyPool->erase(it);\n+    }\n+}\n+\n+std::vector<CKeyID> GetAffectedKeys(const CScript& spk, const SigningProvider& provider)\n+{\n+    std::vector<CScript> dummy;\n+    FlatSigningProvider out;\n+    InferDescriptor(spk, provider)->Expand(0, DUMMY_SIGNING_PROVIDER, dummy, out);\n+    std::vector<CKeyID> ret;\n+    for (const auto& entry : out.pubkeys) {\n+        ret.push_back(entry.first);\n+    }\n+    return ret;\n+}\n+\n+void CWallet::MarkPreSplitKeys()\n+{\n+    WalletBatch batch(*database);\n+    for (auto it = setExternalKeyPool.begin(); it != setExternalKeyPool.end();) {\n+        int64_t index = *it;\n+        CKeyPool keypool;\n+        if (!batch.ReadPool(index, keypool)) {\n+            throw std::runtime_error(std::string(__func__) + \": read keypool entry failed\");\n+        }\n+        keypool.m_pre_split = true;\n+        if (!batch.WritePool(index, keypool)) {\n+            throw std::runtime_error(std::string(__func__) + \": writing modified keypool entry failed\");\n+        }\n+        set_pre_split_keypool.insert(index);\n+        it = setExternalKeyPool.erase(it);\n+    }\n+}\n+\n+bool CWallet::AddCScript(const CScript& redeemScript)\n+{\n+    WalletBatch batch(*database);\n+    return AddCScriptWithDB(batch, redeemScript);\n+}\n+\n+bool CWallet::AddCScriptWithDB(WalletBatch& batch, const CScript& redeemScript)\n+{\n+    if (!FillableSigningProvider::AddCScript(redeemScript))\n+        return false;\n+    if (batch.WriteCScript(Hash160(redeemScript), redeemScript)) {\n+        UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CWallet::AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, const KeyOriginInfo& info)\n+{\n+    LOCK(cs_wallet);\n+    std::copy(info.fingerprint, info.fingerprint + 4, mapKeyMetadata[pubkey.GetID()].key_origin.fingerprint);\n+    mapKeyMetadata[pubkey.GetID()].key_origin.path = info.path;\n+    mapKeyMetadata[pubkey.GetID()].has_key_origin = true;\n+    mapKeyMetadata[pubkey.GetID()].hdKeypath = WriteHDKeypath(info.path);\n+    return batch.WriteKeyMetadata(mapKeyMetadata[pubkey.GetID()], pubkey, true);\n+}\n+\n+bool CWallet::ImportScripts(const std::set<CScript> scripts, int64_t timestamp)\n+{\n+    WalletBatch batch(*database);\n+    for (const auto& entry : scripts) {\n+        CScriptID id(entry);\n+        if (HaveCScript(id)) {\n+            WalletLogPrintf(\"Already have script %s, skipping\\n\", HexStr(entry));\n+            continue;\n+        }\n+        if (!AddCScriptWithDB(batch, entry)) {\n+            return false;\n+        }\n+\n+        if (timestamp > 0) {\n+            m_script_metadata[CScriptID(entry)].nCreateTime = timestamp;\n+        }\n+    }\n+    if (timestamp > 0) {\n+        UpdateTimeFirstKey(timestamp);\n+    }\n+\n+    return true;\n+}\n+\n+bool CWallet::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp)\n+{\n+    WalletBatch batch(*database);\n+    for (const auto& entry : privkey_map) {\n+        const CKey& key = entry.second;\n+        CPubKey pubkey = key.GetPubKey();\n+        const CKeyID& id = entry.first;\n+        assert(key.VerifyPubKey(pubkey));\n+        // Skip if we already have the key\n+        if (HaveKey(id)) {\n+            WalletLogPrintf(\"Already have key with pubkey %s, skipping\\n\", HexStr(pubkey));\n+            continue;\n+        }\n+        mapKeyMetadata[id].nCreateTime = timestamp;\n+        // If the private key is not present in the wallet, insert it.\n+        if (!AddKeyPubKeyWithDB(batch, key, pubkey)) {\n+            return false;\n+        }\n+        UpdateTimeFirstKey(timestamp);\n+    }\n+    return true;\n+}\n+\n+bool CWallet::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n+{\n+    WalletBatch batch(*database);\n+    for (const auto& entry : key_origins) {\n+        AddKeyOriginWithDB(batch, entry.second.first, entry.second.second);\n+    }\n+    for (const CKeyID& id : ordered_pubkeys) {\n+        auto entry = pubkey_map.find(id);\n+        if (entry == pubkey_map.end()) {\n+            continue;\n+        }\n+        const CPubKey& pubkey = entry->second;\n+        CPubKey temp;\n+        if (GetPubKey(id, temp)) {\n+            // Already have pubkey, skipping\n+            WalletLogPrintf(\"Already have pubkey %s, skipping\\n\", HexStr(temp));\n+            continue;\n+        }\n+        if (!AddWatchOnlyWithDB(batch, GetScriptForRawPubKey(pubkey), timestamp)) {\n+            return false;\n+        }\n+        mapKeyMetadata[id].nCreateTime = timestamp;\n+\n+        // Add to keypool only works with pubkeys\n+        if (add_keypool) {\n+            AddKeypoolPubkeyWithDB(pubkey, internal, batch);\n+            NotifyCanGetAddressesChanged();\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp)\n+{\n+    WalletBatch batch(*database);\n+    for (const CScript& script : script_pub_keys) {\n+        if (!have_solving_data || !::IsMine(*this, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+            if (!AddWatchOnlyWithDB(batch, script, timestamp)) {\n+                return false;\n+            }\n+        }\n+        CTxDestination dest;\n+        ExtractDestination(script, dest);\n+        if (apply_label && IsValidDestination(dest)) {\n+            SetAddressBookWithDB(batch, dest, label, \"receive\");\n+        }\n+    }\n+    return true;\n+}\n+\n+std::set<CKeyID> CWallet::GetKeys() const\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted()) {\n+        return FillableSigningProvider::GetKeys();\n+    }\n+    std::set<CKeyID> set_address;\n+    for (const auto& mi : mapCryptedKeys) {\n+        set_address.insert(mi.first);\n+    }\n+    return set_address;\n+}"
      },
      {
        "sha": "f151cec44498568f545e12db6f982c3c5e806ff6",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "added",
        "additions": 115,
        "deletions": 0,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -0,0 +1,115 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_SCRIPTPUBKEYMAN_H\n+#define BITCOIN_WALLET_SCRIPTPUBKEYMAN_H\n+\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <wallet/crypter.h>\n+#include <wallet/ismine.h>\n+#include <wallet/walletdb.h>\n+#include <wallet/walletutil.h>\n+\n+#include <boost/signals2/signal.hpp>\n+\n+enum class OutputType;\n+\n+//! Default for -keypool\n+static const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n+\n+/** A key from a CWallet's keypool\n+ *\n+ * The wallet holds one (for pre HD-split wallets) or several keypools. These\n+ * are sets of keys that have not yet been used to provide addresses or receive\n+ * change.\n+ *\n+ * The Bitcoin Core wallet was originally a collection of unrelated private\n+ * keys with their associated addresses. If a non-HD wallet generated a\n+ * key/address, gave that address out and then restored a backup from before\n+ * that key's generation, then any funds sent to that address would be\n+ * lost definitively.\n+ *\n+ * The keypool was implemented to avoid this scenario (commit: 10384941). The\n+ * wallet would generate a set of keys (100 by default). When a new public key\n+ * was required, either to give out as an address or to use in a change output,\n+ * it would be drawn from the keypool. The keypool would then be topped up to\n+ * maintain 100 keys. This ensured that as long as the wallet hadn't used more\n+ * than 100 keys since the previous backup, all funds would be safe, since a\n+ * restored wallet would be able to scan for all owned addresses.\n+ *\n+ * A keypool also allowed encrypted wallets to give out addresses without\n+ * having to be decrypted to generate a new private key.\n+ *\n+ * With the introduction of HD wallets (commit: f1902510), the keypool\n+ * essentially became an address look-ahead pool. Restoring old backups can no\n+ * longer definitively lose funds as long as the addresses used were from the\n+ * wallet's HD seed (since all private keys can be rederived from the seed).\n+ * However, if many addresses were used since the backup, then the wallet may\n+ * not know how far ahead in the HD chain to look for its addresses. The\n+ * keypool is used to implement a 'gap limit'. The keypool maintains a set of\n+ * keys (by default 1000) ahead of the last used key and scans for the\n+ * addresses of those keys.  This avoids the risk of not seeing transactions\n+ * involving the wallet's addresses, or of re-using the same address.\n+ *\n+ * The HD-split wallet feature added a second keypool (commit: 02592f4c). There\n+ * is an external keypool (for addresses to hand out) and an internal keypool\n+ * (for change addresses).\n+ *\n+ * Keypool keys are stored in the wallet/keystore's keymap. The keypool data is\n+ * stored as sets of indexes in the wallet (setInternalKeyPool,\n+ * setExternalKeyPool and set_pre_split_keypool), and a map from the key to the\n+ * index (m_pool_key_to_index). The CKeyPool object is used to\n+ * serialize/deserialize the pool data to/from the database.\n+ */\n+class CKeyPool\n+{\n+public:\n+    //! The time at which the key was generated. Set in AddKeypoolPubKeyWithDB\n+    int64_t nTime;\n+    //! The public key\n+    CPubKey vchPubKey;\n+    //! Whether this keypool entry is in the internal keypool (for change outputs)\n+    bool fInternal;\n+    //! Whether this key was generated for a keypool before the wallet was upgraded to HD-split\n+    bool m_pre_split;\n+\n+    CKeyPool();\n+    CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn);\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        int nVersion = s.GetVersion();\n+        if (!(s.GetType() & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(nTime);\n+        READWRITE(vchPubKey);\n+        if (ser_action.ForRead()) {\n+            try {\n+                READWRITE(fInternal);\n+            }\n+            catch (std::ios_base::failure&) {\n+                /* flag as external address if we can't read the internal boolean\n+                   (this will be the case for any wallet before the HD chain split version) */\n+                fInternal = false;\n+            }\n+            try {\n+                READWRITE(m_pre_split);\n+            }\n+            catch (std::ios_base::failure&) {\n+                /* flag as postsplit address if we can't read the m_pre_split boolean\n+                   (this will be the case for any wallet that upgrades to HD chain split)*/\n+                m_pre_split = false;\n+            }\n+        }\n+        else {\n+            READWRITE(fInternal);\n+            READWRITE(m_pre_split);\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_WALLET_SCRIPTPUBKEYMAN_H"
      },
      {
        "sha": "a625c4ddeceeedc9c714eac345eee2b382bb721e",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 1077,
        "changes": 1087,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -29,6 +29,7 @@\n #include <util/validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/fees.h>\n+#include <wallet/scriptpubkeyman.h>\n \n #include <algorithm>\n #include <assert.h>\n@@ -224,8 +225,6 @@ WalletCreationStatus CreateWallet(interfaces::Chain& chain, const SecureString&\n     return WalletCreationStatus::SUCCESS;\n }\n \n-const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n-\n const uint256 CWalletTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n \n /** @defgroup mapWallet\n@@ -238,17 +237,7 @@ std::string COutput::ToString() const\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n }\n \n-std::vector<CKeyID> GetAffectedKeys(const CScript& spk, const SigningProvider& provider)\n-{\n-    std::vector<CScript> dummy;\n-    FlatSigningProvider out;\n-    InferDescriptor(spk, provider)->Expand(0, DUMMY_SIGNING_PROVIDER, dummy, out);\n-    std::vector<CKeyID> ret;\n-    for (const auto& entry : out.pubkeys) {\n-        ret.push_back(entry.first);\n-    }\n-    return ret;\n-}\n+std::vector<CKeyID> GetAffectedKeys(const CScript& spk, const SigningProvider& provider);\n \n const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n {\n@@ -259,356 +248,6 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n     return &(it->second);\n }\n \n-CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n-{\n-    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n-    assert(!IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET));\n-    AssertLockHeld(cs_wallet);\n-    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n-\n-    CKey secret;\n-\n-    // Create new metadata\n-    int64_t nCreationTime = GetTime();\n-    CKeyMetadata metadata(nCreationTime);\n-\n-    // use HD key derivation if HD was enabled during wallet creation and a seed is present\n-    if (IsHDEnabled()) {\n-        DeriveNewChildKey(batch, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n-    } else {\n-        secret.MakeNewKey(fCompressed);\n-    }\n-\n-    // Compressed public keys were introduced in version 0.6.0\n-    if (fCompressed) {\n-        SetMinVersion(FEATURE_COMPRPUBKEY);\n-    }\n-\n-    CPubKey pubkey = secret.GetPubKey();\n-    assert(secret.VerifyPubKey(pubkey));\n-\n-    mapKeyMetadata[pubkey.GetID()] = metadata;\n-    UpdateTimeFirstKey(nCreationTime);\n-\n-    if (!AddKeyPubKeyWithDB(batch, secret, pubkey)) {\n-        throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n-    }\n-    return pubkey;\n-}\n-\n-void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal)\n-{\n-    // for now we use a fixed keypath scheme of m/0'/0'/k\n-    CKey seed;                     //seed (256bit)\n-    CExtKey masterKey;             //hd master key\n-    CExtKey accountKey;            //key at m/0'\n-    CExtKey chainChildKey;         //key at m/0'/0' (external) or m/0'/1' (internal)\n-    CExtKey childKey;              //key at m/0'/0'/<n>'\n-\n-    // try to get the seed\n-    if (!GetKey(hdChain.seed_id, seed))\n-        throw std::runtime_error(std::string(__func__) + \": seed not found\");\n-\n-    masterKey.SetSeed(seed.begin(), seed.size());\n-\n-    // derive m/0'\n-    // use hardened derivation (child keys >= 0x80000000 are hardened after bip32)\n-    masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);\n-\n-    // derive m/0'/0' (external chain) OR m/0'/1' (internal chain)\n-    assert(internal ? CanSupportFeature(FEATURE_HD_SPLIT) : true);\n-    accountKey.Derive(chainChildKey, BIP32_HARDENED_KEY_LIMIT+(internal ? 1 : 0));\n-\n-    // derive child key at next index, skip keys already known to the wallet\n-    do {\n-        // always derive hardened keys\n-        // childIndex | BIP32_HARDENED_KEY_LIMIT = derive childIndex in hardened child-index-range\n-        // example: 1 | BIP32_HARDENED_KEY_LIMIT == 0x80000001 == 2147483649\n-        if (internal) {\n-            chainChildKey.Derive(childKey, hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n-            metadata.hdKeypath = \"m/0'/1'/\" + std::to_string(hdChain.nInternalChainCounter) + \"'\";\n-            metadata.key_origin.path.push_back(0 | BIP32_HARDENED_KEY_LIMIT);\n-            metadata.key_origin.path.push_back(1 | BIP32_HARDENED_KEY_LIMIT);\n-            metadata.key_origin.path.push_back(hdChain.nInternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n-            hdChain.nInternalChainCounter++;\n-        }\n-        else {\n-            chainChildKey.Derive(childKey, hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n-            metadata.hdKeypath = \"m/0'/0'/\" + std::to_string(hdChain.nExternalChainCounter) + \"'\";\n-            metadata.key_origin.path.push_back(0 | BIP32_HARDENED_KEY_LIMIT);\n-            metadata.key_origin.path.push_back(0 | BIP32_HARDENED_KEY_LIMIT);\n-            metadata.key_origin.path.push_back(hdChain.nExternalChainCounter | BIP32_HARDENED_KEY_LIMIT);\n-            hdChain.nExternalChainCounter++;\n-        }\n-    } while (HaveKey(childKey.key.GetPubKey().GetID()));\n-    secret = childKey.key;\n-    metadata.hd_seed_id = hdChain.seed_id;\n-    CKeyID master_id = masterKey.key.GetPubKey().GetID();\n-    std::copy(master_id.begin(), master_id.begin() + 4, metadata.key_origin.fingerprint);\n-    metadata.has_key_origin = true;\n-    // update the chain model in the database\n-    if (!batch.WriteHDChain(hdChain))\n-        throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n-}\n-\n-bool CWallet::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const CPubKey& pubkey)\n-{\n-    AssertLockHeld(cs_wallet);\n-\n-    // Make sure we aren't adding private keys to private key disabled wallets\n-    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n-\n-    // FillableSigningProvider has no concept of wallet databases, but calls AddCryptedKey\n-    // which is overridden below.  To avoid flushes, the database handle is\n-    // tunneled through to it.\n-    bool needsDB = !encrypted_batch;\n-    if (needsDB) {\n-        encrypted_batch = &batch;\n-    }\n-    if (!AddKeyPubKeyInner(secret, pubkey)) {\n-        if (needsDB) encrypted_batch = nullptr;\n-        return false;\n-    }\n-    if (needsDB) encrypted_batch = nullptr;\n-\n-    // check if we need to remove from watch-only\n-    CScript script;\n-    script = GetScriptForDestination(PKHash(pubkey));\n-    if (HaveWatchOnly(script)) {\n-        RemoveWatchOnly(script);\n-    }\n-    script = GetScriptForRawPubKey(pubkey);\n-    if (HaveWatchOnly(script)) {\n-        RemoveWatchOnly(script);\n-    }\n-\n-    if (!IsCrypted()) {\n-        return batch.WriteKey(pubkey,\n-                                                 secret.GetPrivKey(),\n-                                                 mapKeyMetadata[pubkey.GetID()]);\n-    }\n-    UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n-    return true;\n-}\n-\n-bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n-{\n-    WalletBatch batch(*database);\n-    return CWallet::AddKeyPubKeyWithDB(batch, secret, pubkey);\n-}\n-\n-bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n-                            const std::vector<unsigned char> &vchCryptedSecret)\n-{\n-    if (!AddCryptedKeyInner(vchPubKey, vchCryptedSecret))\n-        return false;\n-    {\n-        LOCK(cs_wallet);\n-        if (encrypted_batch)\n-            return encrypted_batch->WriteCryptedKey(vchPubKey,\n-                                                        vchCryptedSecret,\n-                                                        mapKeyMetadata[vchPubKey.GetID()]);\n-        else\n-            return WalletBatch(*database).WriteCryptedKey(vchPubKey,\n-                                                            vchCryptedSecret,\n-                                                            mapKeyMetadata[vchPubKey.GetID()]);\n-    }\n-}\n-\n-void CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata& meta)\n-{\n-    AssertLockHeld(cs_wallet);\n-    UpdateTimeFirstKey(meta.nCreateTime);\n-    mapKeyMetadata[keyID] = meta;\n-}\n-\n-void CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata& meta)\n-{\n-    AssertLockHeld(cs_wallet);\n-    UpdateTimeFirstKey(meta.nCreateTime);\n-    m_script_metadata[script_id] = meta;\n-}\n-\n-void CWallet::UpgradeKeyMetadata()\n-{\n-    AssertLockHeld(cs_wallet);\n-    if (IsLocked() || IsWalletFlagSet(WALLET_FLAG_KEY_ORIGIN_METADATA)) {\n-        return;\n-    }\n-\n-    std::unique_ptr<WalletBatch> batch = MakeUnique<WalletBatch>(*database);\n-    for (auto& meta_pair : mapKeyMetadata) {\n-        CKeyMetadata& meta = meta_pair.second;\n-        if (!meta.hd_seed_id.IsNull() && !meta.has_key_origin && meta.hdKeypath != \"s\") { // If the hdKeypath is \"s\", that's the seed and it doesn't have a key origin\n-            CKey key;\n-            GetKey(meta.hd_seed_id, key);\n-            CExtKey masterKey;\n-            masterKey.SetSeed(key.begin(), key.size());\n-            // Add to map\n-            CKeyID master_id = masterKey.key.GetPubKey().GetID();\n-            std::copy(master_id.begin(), master_id.begin() + 4, meta.key_origin.fingerprint);\n-            if (!ParseHDKeypath(meta.hdKeypath, meta.key_origin.path)) {\n-                throw std::runtime_error(\"Invalid stored hdKeypath\");\n-            }\n-            meta.has_key_origin = true;\n-            if (meta.nVersion < CKeyMetadata::VERSION_WITH_KEY_ORIGIN) {\n-                meta.nVersion = CKeyMetadata::VERSION_WITH_KEY_ORIGIN;\n-            }\n-\n-            // Write meta to wallet\n-            CPubKey pubkey;\n-            if (GetPubKey(meta_pair.first, pubkey)) {\n-                batch->WriteKeyMetadata(meta, pubkey, true);\n-            }\n-        }\n-    }\n-    batch.reset(); //write before setting the flag\n-    SetWalletFlag(WALLET_FLAG_KEY_ORIGIN_METADATA);\n-}\n-\n-bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n-{\n-    return AddCryptedKeyInner(vchPubKey, vchCryptedSecret);\n-}\n-\n-/**\n- * Update wallet first key creation time. This should be called whenever keys\n- * are added to the wallet, with the oldest key creation time.\n- */\n-void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n-{\n-    AssertLockHeld(cs_wallet);\n-    if (nCreateTime <= 1) {\n-        // Cannot determine birthday information, so set the wallet birthday to\n-        // the beginning of time.\n-        nTimeFirstKey = 1;\n-    } else if (!nTimeFirstKey || nCreateTime < nTimeFirstKey) {\n-        nTimeFirstKey = nCreateTime;\n-    }\n-}\n-\n-bool CWallet::AddCScript(const CScript& redeemScript)\n-{\n-    WalletBatch batch(*database);\n-    return AddCScriptWithDB(batch, redeemScript);\n-}\n-\n-bool CWallet::AddCScriptWithDB(WalletBatch& batch, const CScript& redeemScript)\n-{\n-    if (!FillableSigningProvider::AddCScript(redeemScript))\n-        return false;\n-    if (batch.WriteCScript(Hash160(redeemScript), redeemScript)) {\n-        UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CWallet::LoadCScript(const CScript& redeemScript)\n-{\n-    /* A sanity check was added in pull #3843 to avoid adding redeemScripts\n-     * that never can be redeemed. However, old wallets may still contain\n-     * these. Do not add them to the wallet and warn. */\n-    if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-    {\n-        std::string strAddr = EncodeDestination(ScriptHash(redeemScript));\n-        WalletLogPrintf(\"%s: Warning: This wallet contains a redeemScript of size %i which exceeds maximum size %i thus can never be redeemed. Do not use address %s.\\n\", __func__, redeemScript.size(), MAX_SCRIPT_ELEMENT_SIZE, strAddr);\n-        return true;\n-    }\n-\n-    return FillableSigningProvider::AddCScript(redeemScript);\n-}\n-\n-static bool ExtractPubKey(const CScript &dest, CPubKey& pubKeyOut)\n-{\n-    std::vector<std::vector<unsigned char>> solutions;\n-    return Solver(dest, solutions) == TX_PUBKEY &&\n-        (pubKeyOut = CPubKey(solutions[0])).IsFullyValid();\n-}\n-\n-bool CWallet::AddWatchOnlyInMem(const CScript &dest)\n-{\n-    LOCK(cs_KeyStore);\n-    setWatchOnly.insert(dest);\n-    CPubKey pubKey;\n-    if (ExtractPubKey(dest, pubKey)) {\n-        mapWatchKeys[pubKey.GetID()] = pubKey;\n-        ImplicitlyLearnRelatedKeyScripts(pubKey);\n-    }\n-    return true;\n-}\n-\n-bool CWallet::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest)\n-{\n-    if (!AddWatchOnlyInMem(dest))\n-        return false;\n-    const CKeyMetadata& meta = m_script_metadata[CScriptID(dest)];\n-    UpdateTimeFirstKey(meta.nCreateTime);\n-    NotifyWatchonlyChanged(true);\n-    if (batch.WriteWatchOnly(dest, meta)) {\n-        UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CWallet::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest, int64_t create_time)\n-{\n-    m_script_metadata[CScriptID(dest)].nCreateTime = create_time;\n-    return AddWatchOnlyWithDB(batch, dest);\n-}\n-\n-bool CWallet::AddWatchOnly(const CScript& dest)\n-{\n-    WalletBatch batch(*database);\n-    return AddWatchOnlyWithDB(batch, dest);\n-}\n-\n-bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n-{\n-    m_script_metadata[CScriptID(dest)].nCreateTime = nCreateTime;\n-    return AddWatchOnly(dest);\n-}\n-\n-bool CWallet::RemoveWatchOnly(const CScript &dest)\n-{\n-    AssertLockHeld(cs_wallet);\n-    {\n-        LOCK(cs_KeyStore);\n-        setWatchOnly.erase(dest);\n-        CPubKey pubKey;\n-        if (ExtractPubKey(dest, pubKey)) {\n-            mapWatchKeys.erase(pubKey.GetID());\n-        }\n-        // Related CScripts are not removed; having superfluous scripts around is\n-        // harmless (see comment in ImplicitlyLearnRelatedKeyScripts).\n-    }\n-\n-    if (!HaveWatchOnly())\n-        NotifyWatchonlyChanged(false);\n-    if (!WalletBatch(*database).EraseWatchOnly(dest))\n-        return false;\n-\n-    return true;\n-}\n-\n-bool CWallet::LoadWatchOnly(const CScript &dest)\n-{\n-    return AddWatchOnlyInMem(dest);\n-}\n-\n-bool CWallet::HaveWatchOnly(const CScript &dest) const\n-{\n-    LOCK(cs_KeyStore);\n-    return setWatchOnly.count(dest) > 0;\n-}\n-\n-bool CWallet::HaveWatchOnly() const\n-{\n-    LOCK(cs_KeyStore);\n-    return (!setWatchOnly.empty());\n-}\n-\n bool CWallet::Unlock(const SecureString& strWalletPassphrase, bool accept_no_keys)\n {\n     CCrypter crypter;\n@@ -1490,6 +1129,12 @@ isminetype CWallet::IsMine(const CTxOut& txout) const\n     return ::IsMine(*this, txout.scriptPubKey);\n }\n \n+isminetype IsMine(const CWallet& keystore, const CTxDestination& dest)\n+{\n+    CScript script = GetScriptForDestination(dest);\n+    return IsMine(keystore, script);\n+}\n+\n CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n {\n     if (!MoneyRange(txout.nValue))\n@@ -1601,94 +1246,6 @@ CAmount CWallet::GetChange(const CTransaction& tx) const\n     return nChange;\n }\n \n-CPubKey CWallet::GenerateNewSeed()\n-{\n-    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n-    CKey key;\n-    key.MakeNewKey(true);\n-    return DeriveNewSeed(key);\n-}\n-\n-CPubKey CWallet::DeriveNewSeed(const CKey& key)\n-{\n-    int64_t nCreationTime = GetTime();\n-    CKeyMetadata metadata(nCreationTime);\n-\n-    // calculate the seed\n-    CPubKey seed = key.GetPubKey();\n-    assert(key.VerifyPubKey(seed));\n-\n-    // set the hd keypath to \"s\" -> Seed, refers the seed to itself\n-    metadata.hdKeypath     = \"s\";\n-    metadata.has_key_origin = false;\n-    metadata.hd_seed_id = seed.GetID();\n-\n-    {\n-        LOCK(cs_wallet);\n-\n-        // mem store the metadata\n-        mapKeyMetadata[seed.GetID()] = metadata;\n-\n-        // write the key&metadata to the database\n-        if (!AddKeyPubKey(key, seed))\n-            throw std::runtime_error(std::string(__func__) + \": AddKeyPubKey failed\");\n-    }\n-\n-    return seed;\n-}\n-\n-void CWallet::SetHDSeed(const CPubKey& seed)\n-{\n-    LOCK(cs_wallet);\n-    // store the keyid (hash160) together with\n-    // the child index counter in the database\n-    // as a hdchain object\n-    CHDChain newHdChain;\n-    newHdChain.nVersion = CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n-    newHdChain.seed_id = seed.GetID();\n-    SetHDChain(newHdChain, false);\n-    NotifyCanGetAddressesChanged();\n-    UnsetWalletFlag(WALLET_FLAG_BLANK_WALLET);\n-}\n-\n-void CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n-{\n-    LOCK(cs_wallet);\n-    if (!memonly && !WalletBatch(*database).WriteHDChain(chain))\n-        throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n-\n-    hdChain = chain;\n-}\n-\n-bool CWallet::IsHDEnabled() const\n-{\n-    return !hdChain.seed_id.IsNull();\n-}\n-\n-bool CWallet::CanGenerateKeys()\n-{\n-    // A wallet can generate keys if it has an HD seed (IsHDEnabled) or it is a non-HD wallet (pre FEATURE_HD)\n-    LOCK(cs_wallet);\n-    return IsHDEnabled() || !CanSupportFeature(FEATURE_HD);\n-}\n-\n-bool CWallet::CanGetAddresses(bool internal)\n-{\n-    LOCK(cs_wallet);\n-    // Check if the keypool has keys\n-    bool keypool_has_keys;\n-    if (internal && CanSupportFeature(FEATURE_HD_SPLIT)) {\n-        keypool_has_keys = setInternalKeyPool.size() > 0;\n-    } else {\n-        keypool_has_keys = KeypoolCountExternalKeys() > 0;\n-    }\n-    // If the keypool doesn't have keys, check if we can generate them\n-    if (!keypool_has_keys) {\n-        return CanGenerateKeys();\n-    }\n-    return keypool_has_keys;\n-}\n-\n void CWallet::SetWalletFlag(uint64_t flags)\n {\n     LOCK(cs_wallet);\n@@ -1768,103 +1325,6 @@ bool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut>\n     return true;\n }\n \n-bool CWallet::ImportScripts(const std::set<CScript> scripts, int64_t timestamp)\n-{\n-    WalletBatch batch(*database);\n-    for (const auto& entry : scripts) {\n-        CScriptID id(entry);\n-        if (HaveCScript(id)) {\n-            WalletLogPrintf(\"Already have script %s, skipping\\n\", HexStr(entry));\n-            continue;\n-        }\n-        if (!AddCScriptWithDB(batch, entry)) {\n-            return false;\n-        }\n-\n-        if (timestamp > 0) {\n-            m_script_metadata[CScriptID(entry)].nCreateTime = timestamp;\n-        }\n-    }\n-    if (timestamp > 0) {\n-        UpdateTimeFirstKey(timestamp);\n-    }\n-\n-    return true;\n-}\n-\n-bool CWallet::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp)\n-{\n-    WalletBatch batch(*database);\n-    for (const auto& entry : privkey_map) {\n-        const CKey& key = entry.second;\n-        CPubKey pubkey = key.GetPubKey();\n-        const CKeyID& id = entry.first;\n-        assert(key.VerifyPubKey(pubkey));\n-        // Skip if we already have the key\n-        if (HaveKey(id)) {\n-            WalletLogPrintf(\"Already have key with pubkey %s, skipping\\n\", HexStr(pubkey));\n-            continue;\n-        }\n-        mapKeyMetadata[id].nCreateTime = timestamp;\n-        // If the private key is not present in the wallet, insert it.\n-        if (!AddKeyPubKeyWithDB(batch, key, pubkey)) {\n-            return false;\n-        }\n-        UpdateTimeFirstKey(timestamp);\n-    }\n-    return true;\n-}\n-\n-bool CWallet::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n-{\n-    WalletBatch batch(*database);\n-    for (const auto& entry : key_origins) {\n-        AddKeyOriginWithDB(batch, entry.second.first, entry.second.second);\n-    }\n-    for (const CKeyID& id : ordered_pubkeys) {\n-        auto entry = pubkey_map.find(id);\n-        if (entry == pubkey_map.end()) {\n-            continue;\n-        }\n-        const CPubKey& pubkey = entry->second;\n-        CPubKey temp;\n-        if (GetPubKey(id, temp)) {\n-            // Already have pubkey, skipping\n-            WalletLogPrintf(\"Already have pubkey %s, skipping\\n\", HexStr(temp));\n-            continue;\n-        }\n-        if (!AddWatchOnlyWithDB(batch, GetScriptForRawPubKey(pubkey), timestamp)) {\n-            return false;\n-        }\n-        mapKeyMetadata[id].nCreateTime = timestamp;\n-\n-        // Add to keypool only works with pubkeys\n-        if (add_keypool) {\n-            AddKeypoolPubkeyWithDB(pubkey, internal, batch);\n-            NotifyCanGetAddressesChanged();\n-        }\n-    }\n-    return true;\n-}\n-\n-bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp)\n-{\n-    WalletBatch batch(*database);\n-    for (const CScript& script : script_pub_keys) {\n-        if (!have_solving_data || !::IsMine(*this, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n-            if (!AddWatchOnlyWithDB(batch, script, timestamp)) {\n-                return false;\n-            }\n-        }\n-        CTxDestination dest;\n-        ExtractDestination(script, dest);\n-        if (apply_label && IsValidDestination(dest)) {\n-            SetAddressBookWithDB(batch, dest, label, \"receive\");\n-        }\n-    }\n-    return true;\n-}\n-\n int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n {\n     std::vector<CTxOut> txouts;\n@@ -3460,250 +2920,9 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n     return WalletBatch(*database).EraseName(EncodeDestination(address));\n }\n \n-/**\n- * Mark old keypool keys as used,\n- * and generate all new keys\n- */\n-bool CWallet::NewKeyPool()\n+bool CWallet::GetNewChangeDestination(const OutputType type, CTxDestination& dest, std::string& error)\n {\n-    if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n-        return false;\n-    }\n-    {\n-        LOCK(cs_wallet);\n-        WalletBatch batch(*database);\n-\n-        for (const int64_t nIndex : setInternalKeyPool) {\n-            batch.ErasePool(nIndex);\n-        }\n-        setInternalKeyPool.clear();\n-\n-        for (const int64_t nIndex : setExternalKeyPool) {\n-            batch.ErasePool(nIndex);\n-        }\n-        setExternalKeyPool.clear();\n-\n-        for (const int64_t nIndex : set_pre_split_keypool) {\n-            batch.ErasePool(nIndex);\n-        }\n-        set_pre_split_keypool.clear();\n-\n-        m_pool_key_to_index.clear();\n-\n-        if (!TopUpKeyPool()) {\n-            return false;\n-        }\n-        WalletLogPrintf(\"CWallet::NewKeyPool rewrote keypool\\n\");\n-    }\n-    return true;\n-}\n-\n-size_t CWallet::KeypoolCountExternalKeys()\n-{\n-    AssertLockHeld(cs_wallet);\n-    return setExternalKeyPool.size() + set_pre_split_keypool.size();\n-}\n-\n-void CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n-{\n-    AssertLockHeld(cs_wallet);\n-    if (keypool.m_pre_split) {\n-        set_pre_split_keypool.insert(nIndex);\n-    } else if (keypool.fInternal) {\n-        setInternalKeyPool.insert(nIndex);\n-    } else {\n-        setExternalKeyPool.insert(nIndex);\n-    }\n-    m_max_keypool_index = std::max(m_max_keypool_index, nIndex);\n-    m_pool_key_to_index[keypool.vchPubKey.GetID()] = nIndex;\n-\n-    // If no metadata exists yet, create a default with the pool key's\n-    // creation time. Note that this may be overwritten by actually\n-    // stored metadata for that key later, which is fine.\n-    CKeyID keyid = keypool.vchPubKey.GetID();\n-    if (mapKeyMetadata.count(keyid) == 0)\n-        mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n-}\n-\n-bool CWallet::TopUpKeyPool(unsigned int kpSize)\n-{\n-    if (!CanGenerateKeys()) {\n-        return false;\n-    }\n-    {\n-        LOCK(cs_wallet);\n-\n-        if (IsLocked()) return false;\n-\n-        // Top up key pool\n-        unsigned int nTargetSize;\n-        if (kpSize > 0)\n-            nTargetSize = kpSize;\n-        else\n-            nTargetSize = std::max(gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n-\n-        // count amount of available keys (internal, external)\n-        // make sure the keypool of external and internal keys fits the user selected target (-keypool)\n-        int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setExternalKeyPool.size(), (int64_t) 0);\n-        int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setInternalKeyPool.size(), (int64_t) 0);\n-\n-        if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n-        {\n-            // don't create extra internal keys\n-            missingInternal = 0;\n-        }\n-        bool internal = false;\n-        WalletBatch batch(*database);\n-        for (int64_t i = missingInternal + missingExternal; i--;)\n-        {\n-            if (i < missingInternal) {\n-                internal = true;\n-            }\n-\n-            CPubKey pubkey(GenerateNewKey(batch, internal));\n-            AddKeypoolPubkeyWithDB(pubkey, internal, batch);\n-        }\n-        if (missingInternal + missingExternal > 0) {\n-            WalletLogPrintf(\"keypool added %d keys (%d internal), size=%u (%u internal)\\n\", missingInternal + missingExternal, missingInternal, setInternalKeyPool.size() + setExternalKeyPool.size() + set_pre_split_keypool.size(), setInternalKeyPool.size());\n-        }\n-    }\n-    NotifyCanGetAddressesChanged();\n-    return true;\n-}\n-\n-void CWallet::AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal, WalletBatch& batch)\n-{\n-    LOCK(cs_wallet);\n-    assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n-    int64_t index = ++m_max_keypool_index;\n-    if (!batch.WritePool(index, CKeyPool(pubkey, internal))) {\n-        throw std::runtime_error(std::string(__func__) + \": writing imported pubkey failed\");\n-    }\n-    if (internal) {\n-        setInternalKeyPool.insert(index);\n-    } else {\n-        setExternalKeyPool.insert(index);\n-    }\n-    m_pool_key_to_index[pubkey.GetID()] = index;\n-}\n-\n-bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n-{\n-    nIndex = -1;\n-    keypool.vchPubKey = CPubKey();\n-    {\n-        LOCK(cs_wallet);\n-\n-        TopUpKeyPool();\n-\n-        bool fReturningInternal = fRequestedInternal;\n-        fReturningInternal &= (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) || IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n-        bool use_split_keypool = set_pre_split_keypool.empty();\n-        std::set<int64_t>& setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool;\n-\n-        // Get the oldest key\n-        if (setKeyPool.empty()) {\n-            return false;\n-        }\n-\n-        WalletBatch batch(*database);\n-\n-        auto it = setKeyPool.begin();\n-        nIndex = *it;\n-        setKeyPool.erase(it);\n-        if (!batch.ReadPool(nIndex, keypool)) {\n-            throw std::runtime_error(std::string(__func__) + \": read failed\");\n-        }\n-        CPubKey pk;\n-        if (!GetPubKey(keypool.vchPubKey.GetID(), pk)) {\n-            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n-        }\n-        // If the key was pre-split keypool, we don't care about what type it is\n-        if (use_split_keypool && keypool.fInternal != fReturningInternal) {\n-            throw std::runtime_error(std::string(__func__) + \": keypool entry misclassified\");\n-        }\n-        if (!keypool.vchPubKey.IsValid()) {\n-            throw std::runtime_error(std::string(__func__) + \": keypool entry invalid\");\n-        }\n-\n-        m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n-        WalletLogPrintf(\"keypool reserve %d\\n\", nIndex);\n-    }\n-    NotifyCanGetAddressesChanged();\n-    return true;\n-}\n-\n-void CWallet::KeepKey(int64_t nIndex)\n-{\n-    // Remove from key pool\n-    WalletBatch batch(*database);\n-    batch.ErasePool(nIndex);\n-    WalletLogPrintf(\"keypool keep %d\\n\", nIndex);\n-}\n-\n-void CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n-{\n-    // Return to key pool\n-    {\n-        LOCK(cs_wallet);\n-        if (fInternal) {\n-            setInternalKeyPool.insert(nIndex);\n-        } else if (!set_pre_split_keypool.empty()) {\n-            set_pre_split_keypool.insert(nIndex);\n-        } else {\n-            setExternalKeyPool.insert(nIndex);\n-        }\n-        m_pool_key_to_index[pubkey.GetID()] = nIndex;\n-        NotifyCanGetAddressesChanged();\n-    }\n-    WalletLogPrintf(\"keypool return %d\\n\", nIndex);\n-}\n-\n-bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n-{\n-    if (!CanGetAddresses(internal)) {\n-        return false;\n-    }\n-\n-    CKeyPool keypool;\n-    {\n-        LOCK(cs_wallet);\n-        int64_t nIndex;\n-        if (!ReserveKeyFromKeyPool(nIndex, keypool, internal) && !IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n-            if (IsLocked()) return false;\n-            WalletBatch batch(*database);\n-            result = GenerateNewKey(batch, internal);\n-            return true;\n-        }\n-        KeepKey(nIndex);\n-        result = keypool.vchPubKey;\n-    }\n-    return true;\n-}\n-\n-bool CWallet::GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error)\n-{\n-    LOCK(cs_wallet);\n-    error.clear();\n-\n-    TopUpKeyPool();\n-\n-    // Generate a new key that is added to wallet\n-    CPubKey new_key;\n-    if (!GetKeyFromPool(new_key)) {\n-        error = \"Error: Keypool ran out, please call keypoolrefill first\";\n-        return false;\n-    }\n-    LearnRelatedScripts(new_key, type);\n-    dest = GetDestinationForKey(new_key, type);\n-\n-    SetAddressBook(dest, label, \"receive\");\n-    return true;\n-}\n-\n-bool CWallet::GetNewChangeDestination(const OutputType type, CTxDestination& dest, std::string& error)\n-{\n-    error.clear();\n+    error.clear();\n \n     TopUpKeyPool();\n \n@@ -3717,38 +2936,6 @@ bool CWallet::GetNewChangeDestination(const OutputType type, CTxDestination& des\n     return true;\n }\n \n-static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, WalletBatch& batch) {\n-    if (setKeyPool.empty()) {\n-        return GetTime();\n-    }\n-\n-    CKeyPool keypool;\n-    int64_t nIndex = *(setKeyPool.begin());\n-    if (!batch.ReadPool(nIndex, keypool)) {\n-        throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n-    }\n-    assert(keypool.vchPubKey.IsValid());\n-    return keypool.nTime;\n-}\n-\n-int64_t CWallet::GetOldestKeyPoolTime()\n-{\n-    LOCK(cs_wallet);\n-\n-    WalletBatch batch(*database);\n-\n-    // load oldest key from keypool, get time and return\n-    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, batch);\n-    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n-        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, batch), oldestKey);\n-        if (!set_pre_split_keypool.empty()) {\n-            oldestKey = std::max(GetOldestKeyTimeInPool(set_pre_split_keypool, batch), oldestKey);\n-        }\n-    }\n-\n-    return oldestKey;\n-}\n-\n std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain::Lock& locked_chain)\n {\n     std::map<CTxDestination, CAmount> balances;\n@@ -3937,30 +3124,6 @@ void ReserveDestination::ReturnDestination()\n     address = CNoDestination();\n }\n \n-void CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n-{\n-    AssertLockHeld(cs_wallet);\n-    bool internal = setInternalKeyPool.count(keypool_id);\n-    if (!internal) assert(setExternalKeyPool.count(keypool_id) || set_pre_split_keypool.count(keypool_id));\n-    std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : (set_pre_split_keypool.empty() ? &setExternalKeyPool : &set_pre_split_keypool);\n-    auto it = setKeyPool->begin();\n-\n-    WalletBatch batch(*database);\n-    while (it != std::end(*setKeyPool)) {\n-        const int64_t& index = *(it);\n-        if (index > keypool_id) break; // set*KeyPool is ordered\n-\n-        CKeyPool keypool;\n-        if (batch.ReadPool(index, keypool)) { //TODO: This should be unnecessary\n-            m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n-        }\n-        LearnAllRelatedScripts(keypool.vchPubKey);\n-        batch.ErasePool(index);\n-        WalletLogPrintf(\"keypool index %d removed\\n\", index);\n-        it = setKeyPool->erase(it);\n-    }\n-}\n-\n void CWallet::LockCoin(const COutPoint& output)\n {\n     AssertLockHeld(cs_wallet);\n@@ -4156,24 +3319,6 @@ std::vector<std::string> CWallet::GetDestValues(const std::string& prefix) const\n     return values;\n }\n \n-void CWallet::MarkPreSplitKeys()\n-{\n-    WalletBatch batch(*database);\n-    for (auto it = setExternalKeyPool.begin(); it != setExternalKeyPool.end();) {\n-        int64_t index = *it;\n-        CKeyPool keypool;\n-        if (!batch.ReadPool(index, keypool)) {\n-            throw std::runtime_error(std::string(__func__) + \": read keypool entry failed\");\n-        }\n-        keypool.m_pre_split = true;\n-        if (!batch.WritePool(index, keypool)) {\n-            throw std::runtime_error(std::string(__func__) + \": writing modified keypool entry failed\");\n-        }\n-        set_pre_split_keypool.insert(index);\n-        it = setExternalKeyPool.erase(it);\n-    }\n-}\n-\n bool CWallet::Verify(interfaces::Chain& chain, const WalletLocation& location, bool salvage_wallet, std::string& error_string, std::vector<std::string>& warnings)\n {\n     // Do some checking on wallet path. It should be either a:\n@@ -4650,23 +3795,6 @@ bool CWalletTx::IsImmatureCoinBase(interfaces::Chain::Lock& locked_chain) const\n     return GetBlocksToMaturity(locked_chain) > 0;\n }\n \n-void CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n-{\n-    if (key.IsCompressed() && (type == OutputType::P2SH_SEGWIT || type == OutputType::BECH32)) {\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        CScript witprog = GetScriptForDestination(witdest);\n-        // Make sure the resulting program is solvable.\n-        assert(IsSolvable(*this, witprog));\n-        AddCScript(witprog);\n-    }\n-}\n-\n-void CWallet::LearnAllRelatedScripts(const CPubKey& key)\n-{\n-    // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.\n-    LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n-}\n-\n std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, bool single_coin) const {\n     std::vector<OutputGroup> groups;\n     std::map<CTxDestination, OutputGroup> gmap;\n@@ -4697,35 +3825,6 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n     return groups;\n }\n \n-bool CWallet::GetKeyOrigin(const CKeyID& keyID, KeyOriginInfo& info) const\n-{\n-    CKeyMetadata meta;\n-    {\n-        LOCK(cs_wallet);\n-        auto it = mapKeyMetadata.find(keyID);\n-        if (it != mapKeyMetadata.end()) {\n-            meta = it->second;\n-        }\n-    }\n-    if (meta.has_key_origin) {\n-        std::copy(meta.key_origin.fingerprint, meta.key_origin.fingerprint + 4, info.fingerprint);\n-        info.path = meta.key_origin.path;\n-    } else { // Single pubkeys get the master fingerprint of themselves\n-        std::copy(keyID.begin(), keyID.begin() + 4, info.fingerprint);\n-    }\n-    return true;\n-}\n-\n-bool CWallet::AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, const KeyOriginInfo& info)\n-{\n-    LOCK(cs_wallet);\n-    std::copy(info.fingerprint, info.fingerprint + 4, mapKeyMetadata[pubkey.GetID()].key_origin.fingerprint);\n-    mapKeyMetadata[pubkey.GetID()].key_origin.path = info.path;\n-    mapKeyMetadata[pubkey.GetID()].has_key_origin = true;\n-    mapKeyMetadata[pubkey.GetID()].hdKeypath = WriteHDKeypath(info.path);\n-    return batch.WriteKeyMetadata(mapKeyMetadata[pubkey.GetID()], pubkey, true);\n-}\n-\n bool CWallet::SetCrypted()\n {\n     LOCK(cs_KeyStore);\n@@ -4759,169 +3858,3 @@ bool CWallet::Lock()\n     NotifyStatusChanged(this);\n     return true;\n }\n-\n-bool CWallet::Unlock(const CKeyingMaterial& vMasterKeyIn, bool accept_no_keys)\n-{\n-    {\n-        LOCK(cs_KeyStore);\n-        if (!SetCrypted())\n-            return false;\n-\n-        bool keyPass = mapCryptedKeys.empty(); // Always pass when there are no encrypted keys\n-        bool keyFail = false;\n-        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n-        for (; mi != mapCryptedKeys.end(); ++mi)\n-        {\n-            const CPubKey &vchPubKey = (*mi).second.first;\n-            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n-            CKey key;\n-            if (!DecryptKey(vMasterKeyIn, vchCryptedSecret, vchPubKey, key))\n-            {\n-                keyFail = true;\n-                break;\n-            }\n-            keyPass = true;\n-            if (fDecryptionThoroughlyChecked)\n-                break;\n-        }\n-        if (keyPass && keyFail)\n-        {\n-            LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\\n\");\n-            throw std::runtime_error(\"Error unlocking wallet: some keys decrypt but not all. Your wallet file may be corrupt.\");\n-        }\n-        if (keyFail || (!keyPass && !accept_no_keys))\n-            return false;\n-        vMasterKey = vMasterKeyIn;\n-        fDecryptionThoroughlyChecked = true;\n-    }\n-    NotifyStatusChanged(this);\n-    return true;\n-}\n-\n-bool CWallet::HaveKey(const CKeyID &address) const\n-{\n-    LOCK(cs_KeyStore);\n-    if (!IsCrypted()) {\n-        return FillableSigningProvider::HaveKey(address);\n-    }\n-    return mapCryptedKeys.count(address) > 0;\n-}\n-\n-bool CWallet::GetKey(const CKeyID &address, CKey& keyOut) const\n-{\n-    LOCK(cs_KeyStore);\n-    if (!IsCrypted()) {\n-        return FillableSigningProvider::GetKey(address, keyOut);\n-    }\n-\n-    CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n-    if (mi != mapCryptedKeys.end())\n-    {\n-        const CPubKey &vchPubKey = (*mi).second.first;\n-        const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n-        return DecryptKey(vMasterKey, vchCryptedSecret, vchPubKey, keyOut);\n-    }\n-    return false;\n-}\n-\n-bool CWallet::GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const\n-{\n-    LOCK(cs_KeyStore);\n-    WatchKeyMap::const_iterator it = mapWatchKeys.find(address);\n-    if (it != mapWatchKeys.end()) {\n-        pubkey_out = it->second;\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool CWallet::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n-{\n-    LOCK(cs_KeyStore);\n-    if (!IsCrypted()) {\n-        if (!FillableSigningProvider::GetPubKey(address, vchPubKeyOut)) {\n-            return GetWatchPubKey(address, vchPubKeyOut);\n-        }\n-        return true;\n-    }\n-\n-    CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n-    if (mi != mapCryptedKeys.end())\n-    {\n-        vchPubKeyOut = (*mi).second.first;\n-        return true;\n-    }\n-    // Check for watch-only pubkeys\n-    return GetWatchPubKey(address, vchPubKeyOut);\n-}\n-\n-std::set<CKeyID> CWallet::GetKeys() const\n-{\n-    LOCK(cs_KeyStore);\n-    if (!IsCrypted()) {\n-        return FillableSigningProvider::GetKeys();\n-    }\n-    std::set<CKeyID> set_address;\n-    for (const auto& mi : mapCryptedKeys) {\n-        set_address.insert(mi.first);\n-    }\n-    return set_address;\n-}\n-\n-bool CWallet::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n-{\n-    LOCK(cs_KeyStore);\n-    if (!mapCryptedKeys.empty() || IsCrypted())\n-        return false;\n-\n-    fUseCrypto = true;\n-    for (const KeyMap::value_type& mKey : mapKeys)\n-    {\n-        const CKey &key = mKey.second;\n-        CPubKey vchPubKey = key.GetPubKey();\n-        CKeyingMaterial vchSecret(key.begin(), key.end());\n-        std::vector<unsigned char> vchCryptedSecret;\n-        if (!EncryptSecret(vMasterKeyIn, vchSecret, vchPubKey.GetHash(), vchCryptedSecret))\n-            return false;\n-        if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n-            return false;\n-    }\n-    mapKeys.clear();\n-    return true;\n-}\n-\n-bool CWallet::AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey)\n-{\n-    LOCK(cs_KeyStore);\n-    if (!IsCrypted()) {\n-        return FillableSigningProvider::AddKeyPubKey(key, pubkey);\n-    }\n-\n-    if (IsLocked()) {\n-        return false;\n-    }\n-\n-    std::vector<unsigned char> vchCryptedSecret;\n-    CKeyingMaterial vchSecret(key.begin(), key.end());\n-    if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret)) {\n-        return false;\n-    }\n-\n-    if (!AddCryptedKey(pubkey, vchCryptedSecret)) {\n-        return false;\n-    }\n-    return true;\n-}\n-\n-\n-bool CWallet::AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n-{\n-    LOCK(cs_KeyStore);\n-    if (!SetCrypted()) {\n-        return false;\n-    }\n-\n-    mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);\n-    ImplicitlyLearnRelatedKeyScripts(vchPubKey);\n-    return true;\n-}"
      },
      {
        "sha": "7a0cdec5ef3fb4d6637cea04b0ca211da93bede3",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 95,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -57,8 +57,6 @@ enum class WalletCreationStatus {\n \n WalletCreationStatus CreateWallet(interfaces::Chain& chain, const SecureString& passphrase, uint64_t wallet_creation_flags, const std::string& name, std::string& error, std::vector<std::string>& warnings, std::shared_ptr<CWallet>& result);\n \n-//! Default for -keypool\n-static const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n //! -paytxfee default\n constexpr CAmount DEFAULT_PAY_TX_FEE = 0;\n //! -fallbackfee default\n@@ -123,99 +121,6 @@ static const std::map<std::string,WalletFlags> WALLET_FLAG_MAP{\n \n extern const std::map<uint64_t,std::string> WALLET_FLAG_CAVEATS;\n \n-/** A key from a CWallet's keypool\n- *\n- * The wallet holds one (for pre HD-split wallets) or several keypools. These\n- * are sets of keys that have not yet been used to provide addresses or receive\n- * change.\n- *\n- * The Bitcoin Core wallet was originally a collection of unrelated private\n- * keys with their associated addresses. If a non-HD wallet generated a\n- * key/address, gave that address out and then restored a backup from before\n- * that key's generation, then any funds sent to that address would be\n- * lost definitively.\n- *\n- * The keypool was implemented to avoid this scenario (commit: 10384941). The\n- * wallet would generate a set of keys (100 by default). When a new public key\n- * was required, either to give out as an address or to use in a change output,\n- * it would be drawn from the keypool. The keypool would then be topped up to\n- * maintain 100 keys. This ensured that as long as the wallet hadn't used more\n- * than 100 keys since the previous backup, all funds would be safe, since a\n- * restored wallet would be able to scan for all owned addresses.\n- *\n- * A keypool also allowed encrypted wallets to give out addresses without\n- * having to be decrypted to generate a new private key.\n- *\n- * With the introduction of HD wallets (commit: f1902510), the keypool\n- * essentially became an address look-ahead pool. Restoring old backups can no\n- * longer definitively lose funds as long as the addresses used were from the\n- * wallet's HD seed (since all private keys can be rederived from the seed).\n- * However, if many addresses were used since the backup, then the wallet may\n- * not know how far ahead in the HD chain to look for its addresses. The\n- * keypool is used to implement a 'gap limit'. The keypool maintains a set of\n- * keys (by default 1000) ahead of the last used key and scans for the\n- * addresses of those keys.  This avoids the risk of not seeing transactions\n- * involving the wallet's addresses, or of re-using the same address.\n- *\n- * The HD-split wallet feature added a second keypool (commit: 02592f4c). There\n- * is an external keypool (for addresses to hand out) and an internal keypool\n- * (for change addresses).\n- *\n- * Keypool keys are stored in the wallet/keystore's keymap. The keypool data is\n- * stored as sets of indexes in the wallet (setInternalKeyPool,\n- * setExternalKeyPool and set_pre_split_keypool), and a map from the key to the\n- * index (m_pool_key_to_index). The CKeyPool object is used to\n- * serialize/deserialize the pool data to/from the database.\n- */\n-class CKeyPool\n-{\n-public:\n-    //! The time at which the key was generated. Set in AddKeypoolPubKeyWithDB\n-    int64_t nTime;\n-    //! The public key\n-    CPubKey vchPubKey;\n-    //! Whether this keypool entry is in the internal keypool (for change outputs)\n-    bool fInternal;\n-    //! Whether this key was generated for a keypool before the wallet was upgraded to HD-split\n-    bool m_pre_split;\n-\n-    CKeyPool();\n-    CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn);\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        int nVersion = s.GetVersion();\n-        if (!(s.GetType() & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(nTime);\n-        READWRITE(vchPubKey);\n-        if (ser_action.ForRead()) {\n-            try {\n-                READWRITE(fInternal);\n-            }\n-            catch (std::ios_base::failure&) {\n-                /* flag as external address if we can't read the internal boolean\n-                   (this will be the case for any wallet before the HD chain split version) */\n-                fInternal = false;\n-            }\n-            try {\n-                READWRITE(m_pre_split);\n-            }\n-            catch (std::ios_base::failure&) {\n-                /* flag as postsplit address if we can't read the m_pre_split boolean\n-                   (this will be the case for any wallet that upgrades to HD chain split)*/\n-                m_pre_split = false;\n-            }\n-        }\n-        else {\n-            READWRITE(fInternal);\n-            READWRITE(m_pre_split);\n-        }\n-    }\n-};\n-\n /** A wrapper to reserve an address from a wallet\n  *\n  * ReserveDestination is used to reserve an address."
      },
      {
        "sha": "edd8bab9ae3441b182e7e395e6910a69018a3f23",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6702048f91089d7a565e5ca5f7c8dcd2ca405a85/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "patch": "@@ -12,6 +12,7 @@\n #include <sync.h>\n #include <util/system.h>\n #include <util/time.h>\n+#include <wallet/scriptpubkeyman.h>\n #include <wallet/wallet.h>\n \n #include <atomic>"
      }
    ]
  },
  {
    "sha": "f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMjAxYmE1OWZmZDJlMDcxYTM2YTY4OGI4MGQyY2ZmOWE5YzQ0YmIy",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-07T18:11:34Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-25T23:20:24Z"
      },
      "message": "Refactor: Split up CWallet and LegacyScriptPubKeyMan and classes\n\nThis moves CWallet members and methods dealing with keys to a new\nLegacyScriptPubKeyMan class, and updates calling code to reference the new\nclass instead of CWallet.\n\nMost of the changes are simple text replacements and variable substitutions\neasily verified with:\n\n    git log -p -n1 -U0 --word-diff-regex=.\n\nThe only nontrivial chunk of code added is the new LegacyScriptPubKeyMan class\ndeclaration, but this code isn't new and is just selectively copied and moved\nfrom the previous CWallet class declaration. This can be verified with:\n\n    git log -p -n1 --color-moved=dimmed_zebra src/wallet/scriptpubkeyman.h src/wallet/wallet.h\n\nor\n\n    git diff HEAD~1:src/wallet/wallet.h HEAD:src/wallet/scriptpubkeyman.h\n\nThis commit does not change behavior.",
      "tree": {
        "sha": "c2edffe4fe20cc412961dd8c09f8f8b16355a355",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2edffe4fe20cc412961dd8c09f8f8b16355a355"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6702048f91089d7a565e5ca5f7c8dcd2ca405a85",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6702048f91089d7a565e5ca5f7c8dcd2ca405a85"
      }
    ],
    "stats": {
      "total": 1441,
      "additions": 901,
      "deletions": 540
    },
    "files": [
      {
        "sha": "6bccde1b8f790f6f89f20dfc08a7db906ad9ce55",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -46,7 +46,7 @@ WalletTx MakeWalletTx(interfaces::Chain::Lock& locked_chain, CWallet& wallet, co\n         result.txout_is_mine.emplace_back(wallet.IsMine(txout));\n         result.txout_address.emplace_back();\n         result.txout_address_is_mine.emplace_back(ExtractDestination(txout.scriptPubKey, result.txout_address.back()) ?\n-                                                      IsMine(wallet, result.txout_address.back()) :\n+                                                      wallet.IsMine(result.txout_address.back()) :\n                                                       ISMINE_NO);\n     }\n     result.credit = wtx.GetCredit(locked_chain, ISMINE_ALL);\n@@ -117,10 +117,17 @@ class WalletImpl : public Wallet\n         std::string error;\n         return m_wallet->GetNewDestination(type, label, dest, error);\n     }\n-    bool getPubKey(const CKeyID& address, CPubKey& pub_key) override { return m_wallet->GetPubKey(address, pub_key); }\n-    bool getPrivKey(const CKeyID& address, CKey& key) override { return m_wallet->GetKey(address, key); }\n-    bool isSpendable(const CTxDestination& dest) override { return IsMine(*m_wallet, dest) & ISMINE_SPENDABLE; }\n-    bool haveWatchOnly() override { return m_wallet->HaveWatchOnly(); };\n+    bool getPubKey(const CKeyID& address, CPubKey& pub_key) override { return m_wallet->GetLegacyScriptPubKeyMan()->GetPubKey(address, pub_key); }\n+    bool getPrivKey(const CKeyID& address, CKey& key) override { return m_wallet->GetLegacyScriptPubKeyMan()->GetKey(address, key); }\n+    bool isSpendable(const CTxDestination& dest) override { return m_wallet->IsMine(dest) & ISMINE_SPENDABLE; }\n+    bool haveWatchOnly() override\n+    {\n+        auto spk_man = m_wallet->GetLegacyScriptPubKeyMan();\n+        if (spk_man) {\n+            return spk_man->HaveWatchOnly();\n+        }\n+        return false;\n+    };\n     bool setAddressBook(const CTxDestination& dest, const std::string& name, const std::string& purpose) override\n     {\n         return m_wallet->SetAddressBook(dest, name, purpose);\n@@ -143,7 +150,7 @@ class WalletImpl : public Wallet\n             *name = it->second.name;\n         }\n         if (is_mine) {\n-            *is_mine = IsMine(*m_wallet, dest);\n+            *is_mine = m_wallet->IsMine(dest);\n         }\n         if (purpose) {\n             *purpose = it->second.purpose;\n@@ -155,11 +162,11 @@ class WalletImpl : public Wallet\n         LOCK(m_wallet->cs_wallet);\n         std::vector<WalletAddress> result;\n         for (const auto& item : m_wallet->mapAddressBook) {\n-            result.emplace_back(item.first, IsMine(*m_wallet, item.first), item.second.name, item.second.purpose);\n+            result.emplace_back(item.first, m_wallet->IsMine(item.first), item.second.name, item.second.purpose);\n         }\n         return result;\n     }\n-    void learnRelatedScripts(const CPubKey& key, OutputType type) override { m_wallet->LearnRelatedScripts(key, type); }\n+    void learnRelatedScripts(const CPubKey& key, OutputType type) override { m_wallet->GetLegacyScriptPubKeyMan()->LearnRelatedScripts(key, type); }\n     bool addDestData(const CTxDestination& dest, const std::string& key, const std::string& value) override\n     {\n         LOCK(m_wallet->cs_wallet);\n@@ -342,7 +349,7 @@ class WalletImpl : public Wallet\n         result.balance = bal.m_mine_trusted;\n         result.unconfirmed_balance = bal.m_mine_untrusted_pending;\n         result.immature_balance = bal.m_mine_immature;\n-        result.have_watch_only = m_wallet->HaveWatchOnly();\n+        result.have_watch_only = haveWatchOnly();\n         if (result.have_watch_only) {\n             result.watch_only_balance = bal.m_watchonly_trusted;\n             result.unconfirmed_watch_only_balance = bal.m_watchonly_untrusted_pending;"
      },
      {
        "sha": "379bd8af88ab4fe90148dd08866cfff662c0a0e6",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -138,9 +138,11 @@ void TestGUI()\n     bool firstRun;\n     wallet->LoadWallet(firstRun);\n     {\n+        auto spk_man = wallet->GetLegacyScriptPubKeyMan();\n         LOCK(wallet->cs_wallet);\n+        AssertLockHeld(spk_man->cs_wallet);\n         wallet->SetAddressBook(GetDestinationForKey(test.coinbaseKey.GetPubKey(), wallet->m_default_address_type), \"\", \"receive\");\n-        wallet->AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());\n+        spk_man->AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());\n     }\n     {\n         auto locked_chain = wallet->chain().lock();"
      },
      {
        "sha": "ed031270f2da779f3e798fbe00974fcc148f0c1f",
        "filename": "src/test/util.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -32,13 +32,15 @@ std::string getnewaddress(CWallet& w)\n \n void importaddress(CWallet& wallet, const std::string& address)\n {\n+    auto spk_man = wallet.GetLegacyScriptPubKeyMan();\n     LOCK(wallet.cs_wallet);\n+    AssertLockHeld(spk_man->cs_wallet);\n     const auto dest = DecodeDestination(address);\n     assert(IsValidDestination(dest));\n     const auto script = GetScriptForDestination(dest);\n     wallet.MarkDirty();\n-    assert(!wallet.HaveWatchOnly(script));\n-    if (!wallet.AddWatchOnly(script, 0 /* nCreateTime */)) assert(false);\n+    assert(!spk_man->HaveWatchOnly(script));\n+    if (!spk_man->AddWatchOnly(script, 0 /* nCreateTime */)) assert(false);\n     wallet.SetAddressBook(dest, /* label */ \"\", \"receive\");\n }\n #endif // ENABLE_WALLET"
      },
      {
        "sha": "3657a157b6a3cac69826dcbd1f1ad48b4ebfda2e",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -10,7 +10,6 @@\n #include <util/moneystr.h>\n #include <util/system.h>\n #include <util/translation.h>\n-#include <wallet/scriptpubkeyman.h>\n #include <wallet/wallet.h>\n #include <walletinitinterface.h>\n "
      },
      {
        "sha": "0bc6c90354accf3b13ab36edfd873d276e796e7c",
        "filename": "src/wallet/ismine.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/ismine.h?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -28,9 +28,6 @@ enum isminetype : unsigned int\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-isminetype IsMine(const CWallet& wallet, const CScript& scriptPubKey);\n-isminetype IsMine(const CWallet& wallet, const CTxDestination& dest);\n-\n /**\n  * Cachable amount subdivided into watchonly and spendable parts.\n  */"
      },
      {
        "sha": "aa13cacca47bbdbd65b5f24ac9d32219c1097882",
        "filename": "src/wallet/psbtwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/psbtwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/psbtwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/psbtwallet.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -39,12 +39,12 @@ TransactionError FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& ps\n             return TransactionError::SIGHASH_MISMATCH;\n         }\n \n-        complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), psbtx, i, sighash_type);\n+        complete &= SignPSBTInput(HidingSigningProvider(pwallet->GetSigningProvider(), !sign, !bip32derivs), psbtx, i, sighash_type);\n     }\n \n     // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n     for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {\n-        UpdatePSBTOutput(HidingSigningProvider(pwallet, true, !bip32derivs), psbtx, i);\n+        UpdatePSBTOutput(HidingSigningProvider(pwallet->GetSigningProvider(), true, !bip32derivs), psbtx, i);\n     }\n \n     return TransactionError::OK;"
      },
      {
        "sha": "0176dc7cdaa4ca866ff7cee2fe1fe5f3760fb56f",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 16,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -67,11 +67,11 @@ static std::string DecodeDumpString(const std::string &str) {\n     return ret.str();\n }\n \n-static bool GetWalletAddressesForKey(CWallet* const pwallet, const CKeyID& keyid, std::string& strAddr, std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, CWallet* const pwallet, const CKeyID& keyid, std::string& strAddr, std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     bool fLabelFound = false;\n     CKey key;\n-    pwallet->GetKey(keyid, key);\n+    spk_man->GetKey(keyid, key);\n     for (const auto& dest : GetAllDestinationsForKey(key.GetPubKey())) {\n         if (pwallet->mapAddressBook.count(dest)) {\n             if (!strAddr.empty()) {\n@@ -138,6 +138,11 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n     }\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     WalletRescanReserver reserver(pwallet);\n     bool fRescan = true;\n     {\n@@ -264,6 +269,10 @@ UniValue importaddress(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n \n     std::string strLabel;\n     if (!request.params[1].isNull())\n@@ -466,6 +475,10 @@ UniValue importpubkey(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n \n     std::string strLabel;\n     if (!request.params[1].isNull())\n@@ -549,6 +562,11 @@ UniValue importwallet(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     if (pwallet->chain().havePruned()) {\n         // Exit early and print an error.\n         // If a block is pruned after this check, we will import the key(s),\n@@ -706,6 +724,11 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n@@ -716,12 +739,12 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n     if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     }\n-    auto keyid = GetKeyForDestination(*pwallet, dest);\n+    auto keyid = GetKeyForDestination(*spk_man, dest);\n     if (keyid.IsNull()) {\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n     }\n     CKey vchSecret;\n-    if (!pwallet->GetKey(keyid, vchSecret)) {\n+    if (!spk_man->GetKey(keyid, vchSecret)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n     }\n     return EncodeSecret(vchSecret);\n@@ -755,8 +778,14 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n+    AssertLockHeld(spk_man->cs_wallet);\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -778,10 +807,10 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n \n     std::map<CKeyID, int64_t> mapKeyBirth;\n-    const std::map<CKeyID, int64_t>& mapKeyPool = pwallet->GetAllReserveKeys();\n+    const std::map<CKeyID, int64_t>& mapKeyPool = spk_man->GetAllReserveKeys();\n     pwallet->GetKeyBirthTimes(*locked_chain, mapKeyBirth);\n \n-    std::set<CScriptID> scripts = pwallet->GetCScripts();\n+    std::set<CScriptID> scripts = spk_man->GetCScripts();\n \n     // sort time/key pairs\n     std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;\n@@ -800,11 +829,11 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     file << \"\\n\";\n \n     // add the base58check encoded extended master if the wallet uses HD\n-    CKeyID seed_id = pwallet->GetHDChain().seed_id;\n+    CKeyID seed_id = spk_man->GetHDChain().seed_id;\n     if (!seed_id.IsNull())\n     {\n         CKey seed;\n-        if (pwallet->GetKey(seed_id, seed)) {\n+        if (spk_man->GetKey(seed_id, seed)) {\n             CExtKey masterKey;\n             masterKey.SetSeed(seed.begin(), seed.size());\n \n@@ -817,20 +846,20 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n         std::string strAddr;\n         std::string strLabel;\n         CKey key;\n-        if (pwallet->GetKey(keyid, key)) {\n+        if (spk_man->GetKey(keyid, key)) {\n             file << strprintf(\"%s %s \", EncodeSecret(key), strTime);\n-            if (GetWalletAddressesForKey(pwallet, keyid, strAddr, strLabel)) {\n+            if (GetWalletAddressesForKey(spk_man, pwallet, keyid, strAddr, strLabel)) {\n                file << strprintf(\"label=%s\", strLabel);\n             } else if (keyid == seed_id) {\n                 file << \"hdseed=1\";\n             } else if (mapKeyPool.count(keyid)) {\n                 file << \"reserve=1\";\n-            } else if (pwallet->mapKeyMetadata[keyid].hdKeypath == \"s\") {\n+            } else if (spk_man->mapKeyMetadata[keyid].hdKeypath == \"s\") {\n                 file << \"inactivehdseed=1\";\n             } else {\n                 file << \"change=1\";\n             }\n-            file << strprintf(\" # addr=%s%s\\n\", strAddr, (pwallet->mapKeyMetadata[keyid].has_key_origin ? \" hdkeypath=\"+WriteHDKeypath(pwallet->mapKeyMetadata[keyid].key_origin.path) : \"\"));\n+            file << strprintf(\" # addr=%s%s\\n\", strAddr, (spk_man->mapKeyMetadata[keyid].has_key_origin ? \" hdkeypath=\"+WriteHDKeypath(spk_man->mapKeyMetadata[keyid].key_origin.path) : \"\"));\n         }\n     }\n     file << \"\\n\";\n@@ -839,11 +868,11 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n         std::string create_time = \"0\";\n         std::string address = EncodeDestination(ScriptHash(scriptid));\n         // get birth times for scripts with metadata\n-        auto it = pwallet->m_script_metadata.find(scriptid);\n-        if (it != pwallet->m_script_metadata.end()) {\n+        auto it = spk_man->m_script_metadata.find(scriptid);\n+        if (it != spk_man->m_script_metadata.end()) {\n             create_time = FormatISO8601DateTime(it->second.nCreateTime);\n         }\n-        if(pwallet->GetCScript(scriptid, script)) {\n+        if(spk_man->GetCScript(scriptid, script)) {\n             file << strprintf(\"%s %s script=1\", HexStr(script.begin(), script.end()), create_time);\n             file << strprintf(\" # addr=%s\\n\", address);\n         }\n@@ -1219,7 +1248,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n \n         // Check whether we have any work to do\n         for (const CScript& script : script_pub_keys) {\n-            if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n+            if (pwallet->IsMine(script) & ISMINE_SPENDABLE) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script (\\\"\" + HexStr(script.begin(), script.end()) + \"\\\")\");\n             }\n         }\n@@ -1339,6 +1368,11 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     RPCTypeCheck(mainRequest.params, {UniValue::VARR, UniValue::VOBJ});\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     const UniValue& requests = mainRequest.params[0];\n \n     //Default options"
      },
      {
        "sha": "7701767bc269aab383009fc31434ea731b4f350a",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 36,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -68,7 +68,7 @@ static bool ParseIncludeWatchonly(const UniValue& include_watchonly, const CWall\n \n \n /** Checks if a CKey is in the given CWallet compressed or otherwise*/\n-bool HaveKey(const CWallet& wallet, const CKey& key)\n+bool HaveKey(const SigningProvider& wallet, const CKey& key)\n {\n     CKey key2;\n     key2.Set(key.begin(), key.end(), !key.IsCompressed());\n@@ -303,7 +303,7 @@ static UniValue setlabel(const JSONRPCRequest& request)\n \n     std::string label = LabelFromValue(request.params[1]);\n \n-    if (IsMine(*pwallet, dest)) {\n+    if (pwallet->IsMine(dest)) {\n         pwallet->SetAddressBook(dest, label, \"receive\");\n     } else {\n         pwallet->SetAddressBook(dest, label, \"send\");\n@@ -550,9 +550,11 @@ static UniValue signmessage(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n     }\n \n+    const SigningProvider* provider = pwallet->GetSigningProvider();\n+\n     CKey key;\n     CKeyID keyID(*pkhash);\n-    if (!pwallet->GetKey(keyID, key)) {\n+    if (!provider->GetKey(keyID, key)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key not available\");\n     }\n \n@@ -610,7 +612,7 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     }\n     CScript scriptPubKey = GetScriptForDestination(dest);\n-    if (!IsMine(*pwallet, scriptPubKey)) {\n+    if (!pwallet->IsMine(scriptPubKey)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Address not found in wallet\");\n     }\n \n@@ -694,7 +696,7 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n         for (const CTxOut& txout : wtx.tx->vout)\n         {\n             CTxDestination address;\n-            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwallet, address) && setAddress.count(address)) {\n+            if (ExtractDestination(txout.scriptPubKey, address) && pwallet->IsMine(address) && setAddress.count(address)) {\n                 if (wtx.GetDepthInMainChain(*locked_chain) >= nMinDepth)\n                     nAmount += txout.nValue;\n             }\n@@ -964,6 +966,11 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n@@ -980,7 +987,7 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n         if (IsHex(keys_or_addrs[i].get_str()) && (keys_or_addrs[i].get_str().length() == 66 || keys_or_addrs[i].get_str().length() == 130)) {\n             pubkeys.push_back(HexToPubKey(keys_or_addrs[i].get_str()));\n         } else {\n-            pubkeys.push_back(AddrToPubKey(pwallet, keys_or_addrs[i].get_str()));\n+            pubkeys.push_back(AddrToPubKey(spk_man, keys_or_addrs[i].get_str()));\n         }\n     }\n \n@@ -993,7 +1000,7 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n \n     // Construct using pay-to-script-hash:\n     CScript inner;\n-    CTxDestination dest = AddAndGetMultisigDestination(required, pubkeys, output_type, *pwallet, inner);\n+    CTxDestination dest = AddAndGetMultisigDestination(required, pubkeys, output_type, *spk_man, inner);\n     pwallet->SetAddressBook(dest, label, \"send\");\n \n     UniValue result(UniValue::VOBJ);\n@@ -1064,7 +1071,7 @@ static UniValue ListReceived(interfaces::Chain::Lock& locked_chain, CWallet * co\n                 continue;\n             }\n \n-            isminefilter mine = IsMine(*pwallet, address);\n+            isminefilter mine = pwallet->IsMine(address);\n             if(!(mine & filter))\n                 continue;\n \n@@ -1288,7 +1295,7 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* con\n         for (const COutputEntry& s : listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n-            if (involvesWatchonly || (::IsMine(*pwallet, s.destination) & ISMINE_WATCH_ONLY)) {\n+            if (involvesWatchonly || (pwallet->IsMine(s.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, s.destination);\n@@ -1319,7 +1326,7 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, CWallet* con\n                 continue;\n             }\n             UniValue entry(UniValue::VOBJ);\n-            if (involvesWatchonly || (::IsMine(*pwallet, r.destination) & ISMINE_WATCH_ONLY)) {\n+            if (involvesWatchonly || (pwallet->IsMine(r.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, r.destination);\n@@ -2379,7 +2386,8 @@ static UniValue getbalances(const JSONRPCRequest& request)\n         }\n         balances.pushKV(\"mine\", balances_mine);\n     }\n-    if (wallet.HaveWatchOnly()) {\n+    auto spk_man = wallet.GetLegacyScriptPubKeyMan();\n+    if (spk_man && spk_man->HaveWatchOnly()) {\n         UniValue balances_watchonly{UniValue::VOBJ};\n         balances_watchonly.pushKV(\"trusted\", ValueFromAmount(bal.m_watchonly_trusted));\n         balances_watchonly.pushKV(\"untrusted_pending\", ValueFromAmount(bal.m_watchonly_untrusted_pending));\n@@ -2449,17 +2457,22 @@ static UniValue getwalletinfo(const JSONRPCRequest& request)\n     obj.pushKV(\"txcount\",       (int)pwallet->mapWallet.size());\n     obj.pushKV(\"keypoololdest\", pwallet->GetOldestKeyPoolTime());\n     obj.pushKV(\"keypoolsize\", (int64_t)kpExternalSize);\n-    CKeyID seed_id = pwallet->GetHDChain().seed_id;\n+\n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (spk_man) {\n+        CKeyID seed_id = spk_man->GetHDChain().seed_id;\n+        if (!seed_id.IsNull()) {\n+            obj.pushKV(\"hdseedid\", seed_id.GetHex());\n+        }\n+    }\n+\n     if (pwallet->CanSupportFeature(FEATURE_HD_SPLIT)) {\n         obj.pushKV(\"keypoolsize_hd_internal\",   (int64_t)(pwallet->GetKeyPoolSize() - kpExternalSize));\n     }\n     if (pwallet->IsCrypted()) {\n         obj.pushKV(\"unlocked_until\", pwallet->nRelockTime);\n     }\n     obj.pushKV(\"paytxfee\", ValueFromAmount(pwallet->m_pay_tx_fee.GetFeePerK()));\n-    if (!seed_id.IsNull()) {\n-        obj.pushKV(\"hdseedid\", seed_id.GetHex());\n-    }\n     obj.pushKV(\"private_keys_enabled\", !pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n     obj.pushKV(\"avoid_reuse\", pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE));\n     if (pwallet->IsScanning()) {\n@@ -2920,10 +2933,11 @@ static UniValue listunspent(const JSONRPCRequest& request)\n                 entry.pushKV(\"label\", i->second.name);\n             }\n \n+            const SigningProvider* provider = pwallet->GetSigningProvider();\n             if (scriptPubKey.IsPayToScriptHash()) {\n                 const CScriptID& hash = CScriptID(boost::get<ScriptHash>(address));\n                 CScript redeemScript;\n-                if (pwallet->GetCScript(hash, redeemScript)) {\n+                if (provider->GetCScript(hash, redeemScript)) {\n                     entry.pushKV(\"redeemScript\", HexStr(redeemScript.begin(), redeemScript.end()));\n                     // Now check if the redeemScript is actually a P2WSH script\n                     CTxDestination witness_destination;\n@@ -2935,7 +2949,7 @@ static UniValue listunspent(const JSONRPCRequest& request)\n                         CScriptID id;\n                         CRIPEMD160().Write(whash.begin(), whash.size()).Finalize(id.begin());\n                         CScript witnessScript;\n-                        if (pwallet->GetCScript(id, witnessScript)) {\n+                        if (provider->GetCScript(id, witnessScript)) {\n                             entry.pushKV(\"witnessScript\", HexStr(witnessScript.begin(), witnessScript.end()));\n                         }\n                     }\n@@ -2945,7 +2959,7 @@ static UniValue listunspent(const JSONRPCRequest& request)\n                 CScriptID id;\n                 CRIPEMD160().Write(whash.begin(), whash.size()).Finalize(id.begin());\n                 CScript witnessScript;\n-                if (pwallet->GetCScript(id, witnessScript)) {\n+                if (provider->GetCScript(id, witnessScript)) {\n                     entry.pushKV(\"witnessScript\", HexStr(witnessScript.begin(), witnessScript.end()));\n                 }\n             }\n@@ -2957,7 +2971,7 @@ static UniValue listunspent(const JSONRPCRequest& request)\n         entry.pushKV(\"spendable\", out.fSpendable);\n         entry.pushKV(\"solvable\", out.fSolvable);\n         if (out.fSolvable) {\n-            auto descriptor = InferDescriptor(scriptPubKey, *pwallet);\n+            auto descriptor = InferDescriptor(scriptPubKey, *pwallet->GetLegacyScriptPubKeyMan());\n             entry.pushKV(\"desc\", descriptor->ToString());\n         }\n         if (avoid_reuse) entry.pushKV(\"reused\", reused);\n@@ -3267,7 +3281,7 @@ UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n     // Parse the prevtxs array\n     ParsePrevouts(request.params[1], nullptr, coins);\n \n-    return SignTransaction(mtx, pwallet, coins, request.params[2]);\n+    return SignTransaction(mtx, &*pwallet->GetLegacyScriptPubKeyMan(), coins, request.params[2]);\n }\n \n static UniValue bumpfee(const JSONRPCRequest& request)\n@@ -3539,7 +3553,7 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n {\n public:\n-    CWallet * const pwallet;\n+    const SigningProvider * const provider;\n \n     void ProcessSubScript(const CScript& subscript, UniValue& obj) const\n     {\n@@ -3575,7 +3589,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n         }\n     }\n \n-    explicit DescribeWalletAddressVisitor(CWallet* _pwallet) : pwallet(_pwallet) {}\n+    explicit DescribeWalletAddressVisitor(const SigningProvider* _provider) : provider(_provider) {}\n \n     UniValue operator()(const CNoDestination& dest) const { return UniValue(UniValue::VOBJ); }\n \n@@ -3584,7 +3598,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n         CKeyID keyID(pkhash);\n         UniValue obj(UniValue::VOBJ);\n         CPubKey vchPubKey;\n-        if (pwallet && pwallet->GetPubKey(keyID, vchPubKey)) {\n+        if (provider && provider->GetPubKey(keyID, vchPubKey)) {\n             obj.pushKV(\"pubkey\", HexStr(vchPubKey));\n             obj.pushKV(\"iscompressed\", vchPubKey.IsCompressed());\n         }\n@@ -3596,7 +3610,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n         CScriptID scriptID(scripthash);\n         UniValue obj(UniValue::VOBJ);\n         CScript subscript;\n-        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n+        if (provider && provider->GetCScript(scriptID, subscript)) {\n             ProcessSubScript(subscript, obj);\n         }\n         return obj;\n@@ -3606,7 +3620,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n     {\n         UniValue obj(UniValue::VOBJ);\n         CPubKey pubkey;\n-        if (pwallet && pwallet->GetPubKey(CKeyID(id), pubkey)) {\n+        if (provider && provider->GetPubKey(CKeyID(id), pubkey)) {\n             obj.pushKV(\"pubkey\", HexStr(pubkey));\n         }\n         return obj;\n@@ -3619,7 +3633,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n         CRIPEMD160 hasher;\n         uint160 hash;\n         hasher.Write(id.begin(), 32).Finalize(hash.begin());\n-        if (pwallet && pwallet->GetCScript(CScriptID(hash), subscript)) {\n+        if (provider && provider->GetCScript(CScriptID(hash), subscript)) {\n             ProcessSubScript(subscript, obj);\n         }\n         return obj;\n@@ -3632,8 +3646,12 @@ static UniValue DescribeWalletAddress(CWallet* pwallet, const CTxDestination& de\n {\n     UniValue ret(UniValue::VOBJ);\n     UniValue detail = DescribeAddress(dest);\n+    const SigningProvider* provider = nullptr;\n+    if (pwallet) {\n+        provider = pwallet->GetSigningProvider();\n+    }\n     ret.pushKVs(detail);\n-    ret.pushKVs(boost::apply_visitor(DescribeWalletAddressVisitor(pwallet), dest));\n+    ret.pushKVs(boost::apply_visitor(DescribeWalletAddressVisitor(provider), dest));\n     return ret;\n }\n \n@@ -3722,13 +3740,14 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n \n     CScript scriptPubKey = GetScriptForDestination(dest);\n     ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n+    const SigningProvider* provider = pwallet->GetSigningProvider();\n \n-    isminetype mine = IsMine(*pwallet, dest);\n+    isminetype mine = pwallet->IsMine(dest);\n     ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n-    bool solvable = IsSolvable(*pwallet, scriptPubKey);\n+    bool solvable = IsSolvable(*provider, scriptPubKey);\n     ret.pushKV(\"solvable\", solvable);\n     if (solvable) {\n-       ret.pushKV(\"desc\", InferDescriptor(scriptPubKey, *pwallet)->ToString());\n+       ret.pushKV(\"desc\", InferDescriptor(scriptPubKey, *provider)->ToString());\n     }\n     ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n     UniValue detail = DescribeWalletAddress(pwallet, dest);\n@@ -3738,7 +3757,7 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n     }\n     ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n     const CKeyMetadata* meta = nullptr;\n-    CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n+    CKeyID key_id = GetKeyForDestination(*provider, dest);\n     if (!key_id.IsNull()) {\n         auto it = pwallet->mapKeyMetadata.find(key_id);\n         if (it != pwallet->mapKeyMetadata.end()) {\n@@ -3916,6 +3935,11 @@ UniValue sethdseed(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n+    LegacyScriptPubKeyMan* spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"This type of wallet does not support this command\");\n+    }\n+\n     if (pwallet->chain().isInitialBlockDownload()) {\n         throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\");\n     }\n@@ -3941,22 +3965,22 @@ UniValue sethdseed(const JSONRPCRequest& request)\n \n     CPubKey master_pub_key;\n     if (request.params[1].isNull()) {\n-        master_pub_key = pwallet->GenerateNewSeed();\n+        master_pub_key = spk_man->GenerateNewSeed();\n     } else {\n         CKey key = DecodeSecret(request.params[1].get_str());\n         if (!key.IsValid()) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n         }\n \n-        if (HaveKey(*pwallet, key)) {\n+        if (HaveKey(*spk_man, key)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key (either as an HD seed or as a loose private key)\");\n         }\n \n-        master_pub_key = pwallet->DeriveNewSeed(key);\n+        master_pub_key = spk_man->DeriveNewSeed(key);\n     }\n \n-    pwallet->SetHDSeed(master_pub_key);\n-    if (flush_key_pool) pwallet->NewKeyPool();\n+    spk_man->SetHDSeed(master_pub_key);\n+    if (flush_key_pool) spk_man->NewKeyPool();\n \n     return NullUniValue;\n }"
      },
      {
        "sha": "c13fddfaf3fea73898a840852bcbfd3460e8d534",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 126,
        "deletions": 114,
        "changes": 240,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -11,11 +11,10 @@\n #include <wallet/scriptpubkeyman.h>\n #include <wallet/wallet.h>\n \n-bool CWallet::GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error)\n+bool LegacyScriptPubKeyMan::GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error)\n {\n     LOCK(cs_wallet);\n     error.clear();\n-\n     TopUpKeyPool();\n \n     // Generate a new key that is added to wallet\n@@ -27,7 +26,7 @@ bool CWallet::GetNewDestination(const OutputType type, const std::string label,\n     LearnRelatedScripts(new_key, type);\n     dest = GetDestinationForKey(new_key, type);\n \n-    SetAddressBook(dest, label, \"receive\");\n+    m_wallet.SetAddressBook(dest, label, \"receive\");\n     return true;\n }\n \n@@ -66,7 +65,7 @@ bool PermitsUncompressed(IsMineSigVersion sigversion)\n     return sigversion == IsMineSigVersion::TOP || sigversion == IsMineSigVersion::P2SH;\n }\n \n-bool HaveKeys(const std::vector<valtype>& pubkeys, const CWallet& keystore)\n+bool HaveKeys(const std::vector<valtype>& pubkeys, const LegacyScriptPubKeyMan& keystore)\n {\n     for (const valtype& pubkey : pubkeys) {\n         CKeyID keyID = CPubKey(pubkey).GetID();\n@@ -75,7 +74,7 @@ bool HaveKeys(const std::vector<valtype>& pubkeys, const CWallet& keystore)\n     return true;\n }\n \n-IsMineResult IsMineInner(const CWallet& keystore, const CScript& scriptPubKey, IsMineSigVersion sigversion)\n+IsMineResult IsMineInner(const LegacyScriptPubKeyMan& keystore, const CScript& scriptPubKey, IsMineSigVersion sigversion)\n {\n     IsMineResult ret = IsMineResult::NO;\n \n@@ -192,9 +191,9 @@ IsMineResult IsMineInner(const CWallet& keystore, const CScript& scriptPubKey, I\n \n } // namespace\n \n-isminetype IsMine(const CWallet& keystore, const CScript& scriptPubKey)\n+isminetype LegacyScriptPubKeyMan::IsMine(const CScript& script) const\n {\n-    switch (IsMineInner(keystore, scriptPubKey, IsMineSigVersion::TOP)) {\n+    switch (IsMineInner(*this, script, IsMineSigVersion::TOP)) {\n     case IsMineResult::INVALID:\n     case IsMineResult::NO:\n         return ISMINE_NO;\n@@ -244,7 +243,7 @@ bool CWallet::Unlock(const CKeyingMaterial& vMasterKeyIn, bool accept_no_keys)\n     return true;\n }\n \n-bool CWallet::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n+bool LegacyScriptPubKeyMan::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n {\n     LOCK(cs_KeyStore);\n     if (!mapCryptedKeys.empty() || IsCrypted())\n@@ -266,14 +265,14 @@ bool CWallet::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n     return true;\n }\n \n-void CWallet::UpgradeKeyMetadata()\n+void LegacyScriptPubKeyMan::UpgradeKeyMetadata()\n {\n     AssertLockHeld(cs_wallet);\n-    if (IsLocked() || IsWalletFlagSet(WALLET_FLAG_KEY_ORIGIN_METADATA)) {\n+    if (m_storage.IsLocked() || m_storage.IsWalletFlagSet(WALLET_FLAG_KEY_ORIGIN_METADATA)) {\n         return;\n     }\n \n-    std::unique_ptr<WalletBatch> batch = MakeUnique<WalletBatch>(*database);\n+    std::unique_ptr<WalletBatch> batch = MakeUnique<WalletBatch>(m_storage.GetDatabase());\n     for (auto& meta_pair : mapKeyMetadata) {\n         CKeyMetadata& meta = meta_pair.second;\n         if (!meta.hd_seed_id.IsNull() && !meta.has_key_origin && meta.hdKeypath != \"s\") { // If the hdKeypath is \"s\", that's the seed and it doesn't have a key origin\n@@ -300,20 +299,20 @@ void CWallet::UpgradeKeyMetadata()\n         }\n     }\n     batch.reset(); //write before setting the flag\n-    SetWalletFlag(WALLET_FLAG_KEY_ORIGIN_METADATA);\n+    m_storage.SetWalletFlag(WALLET_FLAG_KEY_ORIGIN_METADATA);\n }\n \n-bool CWallet::IsHDEnabled() const\n+bool LegacyScriptPubKeyMan::IsHDEnabled() const\n {\n     return !hdChain.seed_id.IsNull();\n }\n \n-bool CWallet::CanGetAddresses(bool internal)\n+bool LegacyScriptPubKeyMan::CanGetAddresses(bool internal)\n {\n     LOCK(cs_wallet);\n     // Check if the keypool has keys\n     bool keypool_has_keys;\n-    if (internal && CanSupportFeature(FEATURE_HD_SPLIT)) {\n+    if (internal && m_storage.CanSupportFeature(FEATURE_HD_SPLIT)) {\n         keypool_has_keys = setInternalKeyPool.size() > 0;\n     } else {\n         keypool_has_keys = KeypoolCountExternalKeys() > 0;\n@@ -339,15 +338,15 @@ static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, Walle\n     return keypool.nTime;\n }\n \n-int64_t CWallet::GetOldestKeyPoolTime()\n+int64_t LegacyScriptPubKeyMan::GetOldestKeyPoolTime()\n {\n     LOCK(cs_wallet);\n \n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n \n     // load oldest key from keypool, get time and return\n     int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, batch);\n-    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n+    if (IsHDEnabled() && m_storage.CanSupportFeature(FEATURE_HD_SPLIT)) {\n         oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, batch), oldestKey);\n         if (!set_pre_split_keypool.empty()) {\n             oldestKey = std::max(GetOldestKeyTimeInPool(set_pre_split_keypool, batch), oldestKey);\n@@ -357,7 +356,7 @@ int64_t CWallet::GetOldestKeyPoolTime()\n     return oldestKey;\n }\n \n-size_t CWallet::KeypoolCountExternalKeys()\n+size_t LegacyScriptPubKeyMan::KeypoolCountExternalKeys()\n {\n     AssertLockHeld(cs_wallet);\n     return setExternalKeyPool.size() + set_pre_split_keypool.size();\n@@ -367,7 +366,7 @@ size_t CWallet::KeypoolCountExternalKeys()\n  * Update wallet first key creation time. This should be called whenever keys\n  * are added to the wallet, with the oldest key creation time.\n  */\n-void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n+void LegacyScriptPubKeyMan::UpdateTimeFirstKey(int64_t nCreateTime)\n {\n     AssertLockHeld(cs_wallet);\n     if (nCreateTime <= 1) {\n@@ -379,18 +378,16 @@ void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n     }\n }\n \n-bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+bool LegacyScriptPubKeyMan::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n {\n-    WalletBatch batch(*database);\n-    return CWallet::AddKeyPubKeyWithDB(batch, secret, pubkey);\n+    WalletBatch batch(m_storage.GetDatabase());\n+    return LegacyScriptPubKeyMan::AddKeyPubKeyWithDB(batch, secret, pubkey);\n }\n \n-bool CWallet::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const CPubKey& pubkey)\n+bool LegacyScriptPubKeyMan::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const CPubKey& pubkey)\n {\n-    AssertLockHeld(cs_wallet);\n-\n     // Make sure we aren't adding private keys to private key disabled wallets\n-    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n+    assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n \n     // FillableSigningProvider has no concept of wallet databases, but calls AddCryptedKey\n     // which is overridden below.  To avoid flushes, the database handle is\n@@ -421,11 +418,11 @@ bool CWallet::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const C\n                                                  secret.GetPrivKey(),\n                                                  mapKeyMetadata[pubkey.GetID()]);\n     }\n-    UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n+    m_storage.UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n     return true;\n }\n \n-bool CWallet::LoadCScript(const CScript& redeemScript)\n+bool LegacyScriptPubKeyMan::LoadCScript(const CScript& redeemScript)\n {\n     /* A sanity check was added in pull #3843 to avoid adding redeemScripts\n      * that never can be redeemed. However, old wallets may still contain\n@@ -440,28 +437,28 @@ bool CWallet::LoadCScript(const CScript& redeemScript)\n     return FillableSigningProvider::AddCScript(redeemScript);\n }\n \n-void CWallet::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata& meta)\n+void LegacyScriptPubKeyMan::LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata& meta)\n {\n     AssertLockHeld(cs_wallet);\n     UpdateTimeFirstKey(meta.nCreateTime);\n     mapKeyMetadata[keyID] = meta;\n }\n \n-void CWallet::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata& meta)\n+void LegacyScriptPubKeyMan::LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata& meta)\n {\n     AssertLockHeld(cs_wallet);\n     UpdateTimeFirstKey(meta.nCreateTime);\n     m_script_metadata[script_id] = meta;\n }\n \n-bool CWallet::AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey)\n+bool LegacyScriptPubKeyMan::AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey)\n {\n     LOCK(cs_KeyStore);\n     if (!IsCrypted()) {\n         return FillableSigningProvider::AddKeyPubKey(key, pubkey);\n     }\n \n-    if (IsLocked()) {\n+    if (m_storage.IsLocked()) {\n         return false;\n     }\n \n@@ -477,12 +474,12 @@ bool CWallet::AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey)\n     return true;\n }\n \n-bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+bool LegacyScriptPubKeyMan::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n {\n     return AddCryptedKeyInner(vchPubKey, vchCryptedSecret);\n }\n \n-bool CWallet::AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+bool LegacyScriptPubKeyMan::AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n {\n     LOCK(cs_KeyStore);\n     if (!SetCrypted()) {\n@@ -494,7 +491,7 @@ bool CWallet::AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<uns\n     return true;\n }\n \n-bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n+bool LegacyScriptPubKeyMan::AddCryptedKey(const CPubKey &vchPubKey,\n                             const std::vector<unsigned char> &vchCryptedSecret)\n {\n     if (!AddCryptedKeyInner(vchPubKey, vchCryptedSecret))\n@@ -506,19 +503,19 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                                                         vchCryptedSecret,\n                                                         mapKeyMetadata[vchPubKey.GetID()]);\n         else\n-            return WalletBatch(*database).WriteCryptedKey(vchPubKey,\n+            return WalletBatch(m_storage.GetDatabase()).WriteCryptedKey(vchPubKey,\n                                                             vchCryptedSecret,\n                                                             mapKeyMetadata[vchPubKey.GetID()]);\n     }\n }\n \n-bool CWallet::HaveWatchOnly(const CScript &dest) const\n+bool LegacyScriptPubKeyMan::HaveWatchOnly(const CScript &dest) const\n {\n     LOCK(cs_KeyStore);\n     return setWatchOnly.count(dest) > 0;\n }\n \n-bool CWallet::HaveWatchOnly() const\n+bool LegacyScriptPubKeyMan::HaveWatchOnly() const\n {\n     LOCK(cs_KeyStore);\n     return (!setWatchOnly.empty());\n@@ -531,7 +528,7 @@ static bool ExtractPubKey(const CScript &dest, CPubKey& pubKeyOut)\n         (pubKeyOut = CPubKey(solutions[0])).IsFullyValid();\n }\n \n-bool CWallet::RemoveWatchOnly(const CScript &dest)\n+bool LegacyScriptPubKeyMan::RemoveWatchOnly(const CScript &dest)\n {\n     AssertLockHeld(cs_wallet);\n     {\n@@ -547,18 +544,18 @@ bool CWallet::RemoveWatchOnly(const CScript &dest)\n \n     if (!HaveWatchOnly())\n         NotifyWatchonlyChanged(false);\n-    if (!WalletBatch(*database).EraseWatchOnly(dest))\n+    if (!WalletBatch(m_storage.GetDatabase()).EraseWatchOnly(dest))\n         return false;\n \n     return true;\n }\n \n-bool CWallet::LoadWatchOnly(const CScript &dest)\n+bool LegacyScriptPubKeyMan::LoadWatchOnly(const CScript &dest)\n {\n     return AddWatchOnlyInMem(dest);\n }\n \n-bool CWallet::AddWatchOnlyInMem(const CScript &dest)\n+bool LegacyScriptPubKeyMan::AddWatchOnlyInMem(const CScript &dest)\n {\n     LOCK(cs_KeyStore);\n     setWatchOnly.insert(dest);\n@@ -570,48 +567,48 @@ bool CWallet::AddWatchOnlyInMem(const CScript &dest)\n     return true;\n }\n \n-bool CWallet::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest)\n+bool LegacyScriptPubKeyMan::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest)\n {\n     if (!AddWatchOnlyInMem(dest))\n         return false;\n     const CKeyMetadata& meta = m_script_metadata[CScriptID(dest)];\n     UpdateTimeFirstKey(meta.nCreateTime);\n     NotifyWatchonlyChanged(true);\n     if (batch.WriteWatchOnly(dest, meta)) {\n-        UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n+        m_storage.UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n         return true;\n     }\n     return false;\n }\n \n-bool CWallet::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest, int64_t create_time)\n+bool LegacyScriptPubKeyMan::AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest, int64_t create_time)\n {\n     m_script_metadata[CScriptID(dest)].nCreateTime = create_time;\n     return AddWatchOnlyWithDB(batch, dest);\n }\n \n-bool CWallet::AddWatchOnly(const CScript& dest)\n+bool LegacyScriptPubKeyMan::AddWatchOnly(const CScript& dest)\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     return AddWatchOnlyWithDB(batch, dest);\n }\n \n-bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n+bool LegacyScriptPubKeyMan::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n {\n     m_script_metadata[CScriptID(dest)].nCreateTime = nCreateTime;\n     return AddWatchOnly(dest);\n }\n \n-void CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n+void LegacyScriptPubKeyMan::SetHDChain(const CHDChain& chain, bool memonly)\n {\n     LOCK(cs_wallet);\n-    if (!memonly && !WalletBatch(*database).WriteHDChain(chain))\n+    if (!memonly && !WalletBatch(m_storage.GetDatabase()).WriteHDChain(chain))\n         throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n \n     hdChain = chain;\n }\n \n-bool CWallet::HaveKey(const CKeyID &address) const\n+bool LegacyScriptPubKeyMan::HaveKey(const CKeyID &address) const\n {\n     LOCK(cs_KeyStore);\n     if (!IsCrypted()) {\n@@ -620,7 +617,7 @@ bool CWallet::HaveKey(const CKeyID &address) const\n     return mapCryptedKeys.count(address) > 0;\n }\n \n-bool CWallet::GetKey(const CKeyID &address, CKey& keyOut) const\n+bool LegacyScriptPubKeyMan::GetKey(const CKeyID &address, CKey& keyOut) const\n {\n     LOCK(cs_KeyStore);\n     if (!IsCrypted()) {\n@@ -637,7 +634,7 @@ bool CWallet::GetKey(const CKeyID &address, CKey& keyOut) const\n     return false;\n }\n \n-bool CWallet::GetKeyOrigin(const CKeyID& keyID, KeyOriginInfo& info) const\n+bool LegacyScriptPubKeyMan::GetKeyOrigin(const CKeyID& keyID, KeyOriginInfo& info) const\n {\n     CKeyMetadata meta;\n     {\n@@ -656,7 +653,7 @@ bool CWallet::GetKeyOrigin(const CKeyID& keyID, KeyOriginInfo& info) const\n     return true;\n }\n \n-bool CWallet::GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const\n+bool LegacyScriptPubKeyMan::GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const\n {\n     LOCK(cs_KeyStore);\n     WatchKeyMap::const_iterator it = mapWatchKeys.find(address);\n@@ -667,7 +664,7 @@ bool CWallet::GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const\n     return false;\n }\n \n-bool CWallet::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+bool LegacyScriptPubKeyMan::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n {\n     LOCK(cs_KeyStore);\n     if (!IsCrypted()) {\n@@ -687,12 +684,12 @@ bool CWallet::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n     return GetWatchPubKey(address, vchPubKeyOut);\n }\n \n-CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n+CPubKey LegacyScriptPubKeyMan::GenerateNewKey(WalletBatch &batch, bool internal)\n {\n-    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n-    assert(!IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET));\n+    assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n+    assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET));\n     AssertLockHeld(cs_wallet);\n-    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n+    bool fCompressed = m_storage.CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     CKey secret;\n \n@@ -702,14 +699,14 @@ CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n \n     // use HD key derivation if HD was enabled during wallet creation and a seed is present\n     if (IsHDEnabled()) {\n-        DeriveNewChildKey(batch, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n+        DeriveNewChildKey(batch, metadata, secret, (m_storage.CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n     } else {\n         secret.MakeNewKey(fCompressed);\n     }\n \n     // Compressed public keys were introduced in version 0.6.0\n     if (fCompressed) {\n-        SetMinVersion(FEATURE_COMPRPUBKEY);\n+        m_storage.SetMinVersion(FEATURE_COMPRPUBKEY);\n     }\n \n     CPubKey pubkey = secret.GetPubKey();\n@@ -726,7 +723,7 @@ CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n \n const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n \n-void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal)\n+void LegacyScriptPubKeyMan::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal)\n {\n     // for now we use a fixed keypath scheme of m/0'/0'/k\n     CKey seed;                     //seed (256bit)\n@@ -746,7 +743,7 @@ void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey\n     masterKey.Derive(accountKey, BIP32_HARDENED_KEY_LIMIT);\n \n     // derive m/0'/0' (external chain) OR m/0'/1' (internal chain)\n-    assert(internal ? CanSupportFeature(FEATURE_HD_SPLIT) : true);\n+    assert(internal ? m_storage.CanSupportFeature(FEATURE_HD_SPLIT) : true);\n     accountKey.Derive(chainChildKey, BIP32_HARDENED_KEY_LIMIT+(internal ? 1 : 0));\n \n     // derive child key at next index, skip keys already known to the wallet\n@@ -781,7 +778,7 @@ void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey\n         throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n }\n \n-void CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n+void LegacyScriptPubKeyMan::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n {\n     AssertLockHeld(cs_wallet);\n     if (keypool.m_pre_split) {\n@@ -802,22 +799,22 @@ void CWallet::LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n         mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n }\n \n-bool CWallet::CanGenerateKeys()\n+bool LegacyScriptPubKeyMan::CanGenerateKeys()\n {\n     // A wallet can generate keys if it has an HD seed (IsHDEnabled) or it is a non-HD wallet (pre FEATURE_HD)\n     LOCK(cs_wallet);\n-    return IsHDEnabled() || !CanSupportFeature(FEATURE_HD);\n+    return IsHDEnabled() || !m_storage.CanSupportFeature(FEATURE_HD);\n }\n \n-CPubKey CWallet::GenerateNewSeed()\n+CPubKey LegacyScriptPubKeyMan::GenerateNewSeed()\n {\n-    assert(!IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n+    assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n     CKey key;\n     key.MakeNewKey(true);\n     return DeriveNewSeed(key);\n }\n \n-CPubKey CWallet::DeriveNewSeed(const CKey& key)\n+CPubKey LegacyScriptPubKeyMan::DeriveNewSeed(const CKey& key)\n {\n     int64_t nCreationTime = GetTime();\n     CKeyMetadata metadata(nCreationTime);\n@@ -845,32 +842,32 @@ CPubKey CWallet::DeriveNewSeed(const CKey& key)\n     return seed;\n }\n \n-void CWallet::SetHDSeed(const CPubKey& seed)\n+void LegacyScriptPubKeyMan::SetHDSeed(const CPubKey& seed)\n {\n     LOCK(cs_wallet);\n     // store the keyid (hash160) together with\n     // the child index counter in the database\n     // as a hdchain object\n     CHDChain newHdChain;\n-    newHdChain.nVersion = CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n+    newHdChain.nVersion = m_storage.CanSupportFeature(FEATURE_HD_SPLIT) ? CHDChain::VERSION_HD_CHAIN_SPLIT : CHDChain::VERSION_HD_BASE;\n     newHdChain.seed_id = seed.GetID();\n     SetHDChain(newHdChain, false);\n     NotifyCanGetAddressesChanged();\n-    UnsetWalletFlag(WALLET_FLAG_BLANK_WALLET);\n+    m_wallet.UnsetWalletFlag(WALLET_FLAG_BLANK_WALLET);\n }\n \n /**\n  * Mark old keypool keys as used,\n  * and generate all new keys\n  */\n-bool CWallet::NewKeyPool()\n+bool LegacyScriptPubKeyMan::NewKeyPool()\n {\n-    if (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+    if (m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         return false;\n     }\n     {\n         LOCK(cs_wallet);\n-        WalletBatch batch(*database);\n+        WalletBatch batch(m_storage.GetDatabase());\n \n         for (const int64_t nIndex : setInternalKeyPool) {\n             batch.ErasePool(nIndex);\n@@ -892,20 +889,20 @@ bool CWallet::NewKeyPool()\n         if (!TopUpKeyPool()) {\n             return false;\n         }\n-        WalletLogPrintf(\"CWallet::NewKeyPool rewrote keypool\\n\");\n+        WalletLogPrintf(\"LegacyScriptPubKeyMan::NewKeyPool rewrote keypool\\n\");\n     }\n     return true;\n }\n \n-bool CWallet::TopUpKeyPool(unsigned int kpSize)\n+bool LegacyScriptPubKeyMan::TopUpKeyPool(unsigned int kpSize)\n {\n     if (!CanGenerateKeys()) {\n         return false;\n     }\n     {\n         LOCK(cs_wallet);\n \n-        if (IsLocked()) return false;\n+        if (m_storage.IsLocked()) return false;\n \n         // Top up key pool\n         unsigned int nTargetSize;\n@@ -919,13 +916,13 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n         int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setExternalKeyPool.size(), (int64_t) 0);\n         int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setInternalKeyPool.size(), (int64_t) 0);\n \n-        if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n+        if (!IsHDEnabled() || !m_storage.CanSupportFeature(FEATURE_HD_SPLIT))\n         {\n             // don't create extra internal keys\n             missingInternal = 0;\n         }\n         bool internal = false;\n-        WalletBatch batch(*database);\n+        WalletBatch batch(m_storage.GetDatabase());\n         for (int64_t i = missingInternal + missingExternal; i--;)\n         {\n             if (i < missingInternal) {\n@@ -943,7 +940,7 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n     return true;\n }\n \n-void CWallet::AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal, WalletBatch& batch)\n+void LegacyScriptPubKeyMan::AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal, WalletBatch& batch)\n {\n     LOCK(cs_wallet);\n     assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n@@ -959,15 +956,15 @@ void CWallet::AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal,\n     m_pool_key_to_index[pubkey.GetID()] = index;\n }\n \n-void CWallet::KeepKey(int64_t nIndex)\n+void LegacyScriptPubKeyMan::KeepKey(int64_t nIndex)\n {\n     // Remove from key pool\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     batch.ErasePool(nIndex);\n     WalletLogPrintf(\"keypool keep %d\\n\", nIndex);\n }\n \n-void CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n+void LegacyScriptPubKeyMan::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n {\n     // Return to key pool\n     {\n@@ -985,7 +982,7 @@ void CWallet::ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey)\n     WalletLogPrintf(\"keypool return %d\\n\", nIndex);\n }\n \n-bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n+bool LegacyScriptPubKeyMan::GetKeyFromPool(CPubKey& result, bool internal)\n {\n     if (!CanGetAddresses(internal)) {\n         return false;\n@@ -995,9 +992,9 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n     {\n         LOCK(cs_wallet);\n         int64_t nIndex;\n-        if (!ReserveKeyFromKeyPool(nIndex, keypool, internal) && !IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n-            if (IsLocked()) return false;\n-            WalletBatch batch(*database);\n+        if (!ReserveKeyFromKeyPool(nIndex, keypool, internal) && !m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+            if (m_storage.IsLocked()) return false;\n+            WalletBatch batch(m_storage.GetDatabase());\n             result = GenerateNewKey(batch, internal);\n             return true;\n         }\n@@ -1007,7 +1004,7 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n     return true;\n }\n \n-bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n+bool LegacyScriptPubKeyMan::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n {\n     nIndex = -1;\n     keypool.vchPubKey = CPubKey();\n@@ -1017,7 +1014,7 @@ bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n         TopUpKeyPool();\n \n         bool fReturningInternal = fRequestedInternal;\n-        fReturningInternal &= (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) || IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+        fReturningInternal &= (IsHDEnabled() && m_storage.CanSupportFeature(FEATURE_HD_SPLIT)) || m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n         bool use_split_keypool = set_pre_split_keypool.empty();\n         std::set<int64_t>& setKeyPool = use_split_keypool ? (fReturningInternal ? setInternalKeyPool : setExternalKeyPool) : set_pre_split_keypool;\n \n@@ -1026,7 +1023,7 @@ bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n             return false;\n         }\n \n-        WalletBatch batch(*database);\n+        WalletBatch batch(m_storage.GetDatabase());\n \n         auto it = setKeyPool.begin();\n         nIndex = *it;\n@@ -1053,7 +1050,7 @@ bool CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n     return true;\n }\n \n-void CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n+void LegacyScriptPubKeyMan::LearnRelatedScripts(const CPubKey& key, OutputType type)\n {\n     if (key.IsCompressed() && (type == OutputType::P2SH_SEGWIT || type == OutputType::BECH32)) {\n         CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n@@ -1064,21 +1061,21 @@ void CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n     }\n }\n \n-void CWallet::LearnAllRelatedScripts(const CPubKey& key)\n+void LegacyScriptPubKeyMan::LearnAllRelatedScripts(const CPubKey& key)\n {\n     // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.\n     LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n }\n \n-void CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n+void LegacyScriptPubKeyMan::MarkReserveKeysAsUsed(int64_t keypool_id)\n {\n     AssertLockHeld(cs_wallet);\n     bool internal = setInternalKeyPool.count(keypool_id);\n     if (!internal) assert(setExternalKeyPool.count(keypool_id) || set_pre_split_keypool.count(keypool_id));\n     std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : (set_pre_split_keypool.empty() ? &setExternalKeyPool : &set_pre_split_keypool);\n     auto it = setKeyPool->begin();\n \n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     while (it != std::end(*setKeyPool)) {\n         const int64_t& index = *(it);\n         if (index > keypool_id) break; // set*KeyPool is ordered\n@@ -1106,9 +1103,9 @@ std::vector<CKeyID> GetAffectedKeys(const CScript& spk, const SigningProvider& p\n     return ret;\n }\n \n-void CWallet::MarkPreSplitKeys()\n+void LegacyScriptPubKeyMan::MarkPreSplitKeys()\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     for (auto it = setExternalKeyPool.begin(); it != setExternalKeyPool.end();) {\n         int64_t index = *it;\n         CKeyPool keypool;\n@@ -1124,24 +1121,24 @@ void CWallet::MarkPreSplitKeys()\n     }\n }\n \n-bool CWallet::AddCScript(const CScript& redeemScript)\n+bool LegacyScriptPubKeyMan::AddCScript(const CScript& redeemScript)\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     return AddCScriptWithDB(batch, redeemScript);\n }\n \n-bool CWallet::AddCScriptWithDB(WalletBatch& batch, const CScript& redeemScript)\n+bool LegacyScriptPubKeyMan::AddCScriptWithDB(WalletBatch& batch, const CScript& redeemScript)\n {\n     if (!FillableSigningProvider::AddCScript(redeemScript))\n         return false;\n     if (batch.WriteCScript(Hash160(redeemScript), redeemScript)) {\n-        UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n+        m_storage.UnsetWalletFlagWithDB(batch, WALLET_FLAG_BLANK_WALLET);\n         return true;\n     }\n     return false;\n }\n \n-bool CWallet::AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, const KeyOriginInfo& info)\n+bool LegacyScriptPubKeyMan::AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, const KeyOriginInfo& info)\n {\n     LOCK(cs_wallet);\n     std::copy(info.fingerprint, info.fingerprint + 4, mapKeyMetadata[pubkey.GetID()].key_origin.fingerprint);\n@@ -1151,9 +1148,9 @@ bool CWallet::AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, cons\n     return batch.WriteKeyMetadata(mapKeyMetadata[pubkey.GetID()], pubkey, true);\n }\n \n-bool CWallet::ImportScripts(const std::set<CScript> scripts, int64_t timestamp)\n+bool LegacyScriptPubKeyMan::ImportScripts(const std::set<CScript> scripts, int64_t timestamp)\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     for (const auto& entry : scripts) {\n         CScriptID id(entry);\n         if (HaveCScript(id)) {\n@@ -1175,9 +1172,9 @@ bool CWallet::ImportScripts(const std::set<CScript> scripts, int64_t timestamp)\n     return true;\n }\n \n-bool CWallet::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp)\n+bool LegacyScriptPubKeyMan::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp)\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     for (const auto& entry : privkey_map) {\n         const CKey& key = entry.second;\n         CPubKey pubkey = key.GetPubKey();\n@@ -1198,9 +1195,9 @@ bool CWallet::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const in\n     return true;\n }\n \n-bool CWallet::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n+bool LegacyScriptPubKeyMan::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     for (const auto& entry : key_origins) {\n         AddKeyOriginWithDB(batch, entry.second.first, entry.second.second);\n     }\n@@ -1230,25 +1227,25 @@ bool CWallet::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const st\n     return true;\n }\n \n-bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp)\n+bool LegacyScriptPubKeyMan::ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp)\n {\n-    WalletBatch batch(*database);\n+    WalletBatch batch(m_storage.GetDatabase());\n     for (const CScript& script : script_pub_keys) {\n-        if (!have_solving_data || !::IsMine(*this, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+        if (!have_solving_data || !IsMine(script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n             if (!AddWatchOnlyWithDB(batch, script, timestamp)) {\n                 return false;\n             }\n         }\n         CTxDestination dest;\n         ExtractDestination(script, dest);\n         if (apply_label && IsValidDestination(dest)) {\n-            SetAddressBookWithDB(batch, dest, label, \"receive\");\n+            m_wallet.SetAddressBookWithDB(batch, dest, label, \"receive\");\n         }\n     }\n     return true;\n }\n \n-std::set<CKeyID> CWallet::GetKeys() const\n+std::set<CKeyID> LegacyScriptPubKeyMan::GetKeys() const\n {\n     LOCK(cs_KeyStore);\n     if (!IsCrypted()) {\n@@ -1260,3 +1257,18 @@ std::set<CKeyID> CWallet::GetKeys() const\n     }\n     return set_address;\n }\n+\n+// Temporary CWallet accessors and aliases.\n+LegacyScriptPubKeyMan::LegacyScriptPubKeyMan(CWallet& wallet)\n+    : ScriptPubKeyMan(wallet),\n+      m_wallet(wallet),\n+      cs_wallet(wallet.cs_wallet),\n+      vMasterKey(wallet.vMasterKey),\n+      fUseCrypto(wallet.fUseCrypto),\n+      fDecryptionThoroughlyChecked(wallet.fDecryptionThoroughlyChecked) {}\n+\n+bool LegacyScriptPubKeyMan::SetCrypted() { return m_wallet.SetCrypted(); }\n+bool LegacyScriptPubKeyMan::IsCrypted() const { return m_wallet.IsCrypted(); }\n+void LegacyScriptPubKeyMan::NotifyWatchonlyChanged(bool fHaveWatchOnly) const { return m_wallet.NotifyWatchonlyChanged(fHaveWatchOnly); }\n+void LegacyScriptPubKeyMan::NotifyCanGetAddressesChanged() const { return m_wallet.NotifyCanGetAddressesChanged(); }\n+template<typename... Params> void LegacyScriptPubKeyMan::WalletLogPrintf(const std::string& fmt, const Params&... parameters) const { return m_wallet.WalletLogPrintf(fmt, parameters...); }"
      },
      {
        "sha": "55184098b74b15f2419745e124a94c779885ff39",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 240,
        "deletions": 0,
        "changes": 240,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -16,6 +16,25 @@\n \n enum class OutputType;\n \n+// Wallet storage things that ScriptPubKeyMans need in order to be able to store things to the wallet database.\n+// It provides access to things that are part of the entire wallet and not specific to a ScriptPubKeyMan such as\n+// wallet flags, wallet version, encryption keys, encryption status, and the database itself. This allows a\n+// ScriptPubKeyMan to have callbacks into CWallet without causing a circular dependency.\n+// WalletStorage should be the same for all ScriptPubKeyMans.\n+class WalletStorage\n+{\n+public:\n+    virtual ~WalletStorage() = default;\n+    virtual const std::string GetDisplayName() const = 0;\n+    virtual WalletDatabase& GetDatabase() = 0;\n+    virtual bool IsWalletFlagSet(uint64_t) const = 0;\n+    virtual void SetWalletFlag(uint64_t) = 0;\n+    virtual void UnsetWalletFlagWithDB(WalletBatch&, uint64_t) = 0;\n+    virtual bool CanSupportFeature(enum WalletFeature) const = 0;\n+    virtual void SetMinVersion(enum WalletFeature, WalletBatch* = nullptr, bool = false) = 0;\n+    virtual bool IsLocked() const = 0;\n+};\n+\n //! Default for -keypool\n static const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n \n@@ -112,4 +131,225 @@ class CKeyPool\n     }\n };\n \n+/*\n+ * A class implementing ScriptPubKeyMan manages some (or all) scriptPubKeys used in a wallet.\n+ * It contains the scripts and keys related to the scriptPubKeys it manages.\n+ * A ScriptPubKeyMan will be able to give out scriptPubKeys to be used, as well as marking\n+ * when a scriptPubKey has been used. It also handles when and how to store a scriptPubKey\n+ * and its related scripts and keys, including encryption.\n+ */\n+class ScriptPubKeyMan\n+{\n+protected:\n+    WalletStorage& m_storage;\n+\n+public:\n+    ScriptPubKeyMan(WalletStorage& storage) : m_storage(storage) {}\n+};\n+\n+class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProvider\n+{\n+private:\n+    using CryptedKeyMap = std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char>>>;\n+    using WatchOnlySet = std::set<CScript>;\n+    using WatchKeyMap = std::map<CKeyID, CPubKey>;\n+\n+    //! will encrypt previously unencrypted keys\n+    bool EncryptKeys(CKeyingMaterial& vMasterKeyIn);\n+\n+    CryptedKeyMap mapCryptedKeys GUARDED_BY(cs_KeyStore);\n+    WatchOnlySet setWatchOnly GUARDED_BY(cs_KeyStore);\n+    WatchKeyMap mapWatchKeys GUARDED_BY(cs_KeyStore);\n+\n+    bool AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    bool AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey);\n+\n+    WalletBatch *encrypted_batch GUARDED_BY(cs_wallet) = nullptr;\n+\n+    /* the HD chain data model (external chain counters) */\n+    CHDChain hdChain;\n+\n+    /* HD derive new child key (on internal or external chain) */\n+    void DeriveNewChildKey(WalletBatch& batch, CKeyMetadata& metadata, CKey& secret, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    std::set<int64_t> setInternalKeyPool GUARDED_BY(cs_wallet);\n+    std::set<int64_t> setExternalKeyPool GUARDED_BY(cs_wallet);\n+    std::set<int64_t> set_pre_split_keypool GUARDED_BY(cs_wallet);\n+    int64_t m_max_keypool_index GUARDED_BY(cs_wallet) = 0;\n+    std::map<CKeyID, int64_t> m_pool_key_to_index;\n+\n+    int64_t nTimeFirstKey GUARDED_BY(cs_wallet) = 0;\n+\n+    /**\n+     * Private version of AddWatchOnly method which does not accept a\n+     * timestamp, and which will reset the wallet's nTimeFirstKey value to 1 if\n+     * the watch key did not previously have a timestamp associated with it.\n+     * Because this is an inherited virtual method, it is accessible despite\n+     * being marked private, but it is marked private anyway to encourage use\n+     * of the other AddWatchOnly which accepts a timestamp and sets\n+     * nTimeFirstKey more intelligently for more efficient rescans.\n+     */\n+    bool AddWatchOnly(const CScript& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool AddWatchOnlyInMem(const CScript &dest);\n+\n+    /** Add a KeyOriginInfo to the wallet */\n+    bool AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, const KeyOriginInfo& info);\n+\n+    //! Adds a key to the store, and saves it to disk.\n+    bool AddKeyPubKeyWithDB(WalletBatch &batch,const CKey& key, const CPubKey &pubkey) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    //! Adds a watch-only address to the store, and saves it to disk.\n+    bool AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest, int64_t create_time) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    void AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal, WalletBatch& batch);\n+\n+    //! Adds a script to the store and saves it to disk\n+    bool AddCScriptWithDB(WalletBatch& batch, const CScript& script);\n+\n+ public:\n+    //! Fetches a key from the keypool\n+    bool GetKeyFromPool(CPubKey &key, bool internal = false);\n+    void LoadKeyPool(int64_t nIndex, const CKeyPool &keypool) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void MarkPreSplitKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    // Map from Key ID to key metadata.\n+    std::map<CKeyID, CKeyMetadata> mapKeyMetadata GUARDED_BY(cs_wallet);\n+\n+    // Map from Script ID to key metadata (for watch-only keys).\n+    std::map<CScriptID, CKeyMetadata> m_script_metadata GUARDED_BY(cs_wallet);\n+\n+    /**\n+     * keystore implementation\n+     * Generate a new key\n+     */\n+    CPubKey GenerateNewKey(WalletBatch& batch, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    //! Adds a key to the store, and saves it to disk.\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n+    bool LoadKey(const CKey& key, const CPubKey &pubkey) { return AddKeyPubKeyInner(key, pubkey); }\n+    //! Load metadata (used by LoadWallet)\n+    void LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata &metadata) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata &metadata) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    //! Upgrade stored CKeyMetadata objects to store key origin info as KeyOriginInfo\n+    void UpgradeKeyMetadata() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void UpdateTimeFirstKey(int64_t nCreateTime) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    //! Adds an encrypted key to the store, and saves it to disk.\n+    bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n+    bool LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    bool GetKey(const CKeyID &address, CKey& keyOut) const override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    bool HaveKey(const CKeyID &address) const override;\n+    std::set<CKeyID> GetKeys() const override;\n+    bool AddCScript(const CScript& redeemScript) override;\n+    bool LoadCScript(const CScript& redeemScript);\n+\n+    //! Adds a watch-only address to the store, and saves it to disk.\n+    bool AddWatchOnly(const CScript& dest, int64_t nCreateTime) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool RemoveWatchOnly(const CScript &dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    //! Adds a watch-only address to the store, without saving it to disk (used by LoadWallet)\n+    bool LoadWatchOnly(const CScript &dest);\n+    //! Returns whether the watch-only script is in the wallet\n+    bool HaveWatchOnly(const CScript &dest) const;\n+    //! Returns whether there are any watch-only things in the wallet\n+    bool HaveWatchOnly() const;\n+    //! Fetches a pubkey from mapWatchKeys if it exists there\n+    bool GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const;\n+\n+    bool ImportScripts(const std::set<CScript> scripts, int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+\n+    bool NewKeyPool();\n+    size_t KeypoolCountExternalKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool TopUpKeyPool(unsigned int kpSize = 0);\n+\n+    /**\n+     * Reserves a key from the keypool and sets nIndex to its index\n+     *\n+     * @param[out] nIndex the index of the key in keypool\n+     * @param[out] keypool the keypool the key was drawn from, which could be the\n+     *     the pre-split pool if present, or the internal or external pool\n+     * @param fRequestedInternal true if the caller would like the key drawn\n+     *     from the internal keypool, false if external is preferred\n+     *\n+     * @return true if succeeded, false if failed due to empty keypool\n+     * @throws std::runtime_error if keypool read failed, key was invalid,\n+     *     was not found in the wallet, or was misclassified in the internal\n+     *     or external keypool\n+     */\n+    bool ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal);\n+    void KeepKey(int64_t nIndex);\n+    void ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey);\n+    int64_t GetOldestKeyPoolTime();\n+    /**\n+     * Marks all keys in the keypool up to and including reserve_key as used.\n+     */\n+    void MarkReserveKeysAsUsed(int64_t keypool_id) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    const std::map<CKeyID, int64_t>& GetAllReserveKeys() const { return m_pool_key_to_index; }\n+    bool GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error);\n+\n+    isminetype IsMine(const CScript& script) const;\n+\n+    /* Set the HD chain model (chain child index counters) */\n+    void SetHDChain(const CHDChain& chain, bool memonly);\n+    const CHDChain& GetHDChain() const { return hdChain; }\n+\n+    /* Returns true if HD is enabled */\n+    bool IsHDEnabled() const;\n+\n+    /* Returns true if the wallet can generate new keys */\n+    bool CanGenerateKeys();\n+\n+    /* Returns true if the wallet can give out new addresses. This means it has keys in the keypool or can generate new keys */\n+    bool CanGetAddresses(bool internal = false);\n+\n+    /* Generates a new HD seed (will not be activated) */\n+    CPubKey GenerateNewSeed();\n+\n+    /* Derives a new HD seed (will not be activated) */\n+    CPubKey DeriveNewSeed(const CKey& key);\n+\n+    /* Set the current HD seed (will reset the chain child index counters)\n+       Sets the seed's version based on the current wallet version (so the\n+       caller must ensure the current wallet version is correct before calling\n+       this function). */\n+    void SetHDSeed(const CPubKey& key);\n+\n+    /**\n+     * Explicitly make the wallet learn the related scripts for outputs to the\n+     * given key. This is purely to make the wallet file compatible with older\n+     * software, as FillableSigningProvider automatically does this implicitly for all\n+     * keys now.\n+     */\n+    void LearnRelatedScripts(const CPubKey& key, OutputType);\n+\n+    /**\n+     * Same as LearnRelatedScripts, but when the OutputType is not known (and could\n+     * be anything).\n+     */\n+    void LearnAllRelatedScripts(const CPubKey& key);\n+\n+    /** Implement lookup of key origin information through wallet key metadata. */\n+    bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const override;\n+\n+    // Temporary CWallet accessors and aliases.\n+    friend class CWallet;\n+    friend class ReserveDestination;\n+    LegacyScriptPubKeyMan(CWallet& wallet);\n+    bool SetCrypted();\n+    bool IsCrypted() const;\n+    void NotifyWatchonlyChanged(bool fHaveWatchOnly) const;\n+    void NotifyCanGetAddressesChanged() const;\n+    template<typename... Params> void WalletLogPrintf(const std::string& fmt, const Params&... parameters) const;\n+    CWallet& m_wallet;\n+    CCriticalSection& cs_wallet;\n+    CKeyingMaterial& vMasterKey GUARDED_BY(cs_KeyStore);\n+    std::atomic<bool>& fUseCrypto;\n+    bool& fDecryptionThoroughlyChecked;\n+};\n+\n #endif // BITCOIN_WALLET_SCRIPTPUBKEYMAN_H"
      },
      {
        "sha": "12355e300acc6f66b0090eb34751f1a0f81e6432",
        "filename": "src/wallet/test/ismine_tests.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 84,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/test/ismine_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/test/ismine_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/ismine_tests.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -38,12 +38,12 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForRawPubKey(pubkeys[0]);\n \n         // Keystore does not have key\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n@@ -54,12 +54,12 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForRawPubKey(uncompressedPubkey);\n \n         // Keystore does not have key\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n@@ -70,12 +70,12 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForDestination(PKHash(pubkeys[0]));\n \n         // Keystore does not have key\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n@@ -86,12 +86,12 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForDestination(PKHash(uncompressedPubkey));\n \n         // Keystore does not have key\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key\n-        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n@@ -104,17 +104,17 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForDestination(ScriptHash(redeemScript));\n \n         // Keystore does not have redeemScript or key\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has redeemScript but no key\n-        BOOST_CHECK(keystore.AddCScript(redeemScript));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemScript));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has redeemScript and key\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n@@ -127,11 +127,11 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         CScript redeemscript = GetScriptForDestination(ScriptHash(redeemscript_inner));\n         scriptPubKey = GetScriptForDestination(ScriptHash(redeemscript));\n \n-        BOOST_CHECK(keystore.AddCScript(redeemscript));\n-        BOOST_CHECK(keystore.AddCScript(redeemscript_inner));\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemscript));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemscript_inner));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n@@ -144,11 +144,11 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         CScript witnessscript = GetScriptForDestination(ScriptHash(redeemscript));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n-        BOOST_CHECK(keystore.AddCScript(witnessscript));\n-        BOOST_CHECK(keystore.AddCScript(redeemscript));\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessscript));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemscript));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n@@ -160,10 +160,10 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         CScript witnessscript = GetScriptForDestination(WitnessV0KeyHash(PKHash(pubkeys[0])));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n-        BOOST_CHECK(keystore.AddCScript(witnessscript));\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessscript));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n@@ -176,43 +176,43 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         CScript witnessscript = GetScriptForDestination(WitnessV0ScriptHash(witnessscript_inner));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n-        BOOST_CHECK(keystore.AddCScript(witnessscript_inner));\n-        BOOST_CHECK(keystore.AddCScript(witnessscript));\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessscript_inner));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessscript));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n     // P2WPKH compressed\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n \n         scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(PKHash(pubkeys[0])));\n \n         // Keystore implicitly has key and P2SH redeemScript\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // P2WPKH uncompressed\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n \n         scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(PKHash(uncompressedPubkey)));\n \n         // Keystore has key, but no P2SH redeemScript\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has key and P2SH redeemScript\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n@@ -224,95 +224,95 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForMultisig(2, {uncompressedPubkey, pubkeys[1]});\n \n         // Keystore does not have any keys\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has 1/2 keys\n-        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has 2/2 keys\n-        BOOST_CHECK(keystore.AddKey(keys[1]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has 2/2 keys and the script\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n     // P2SH multisig\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n-        BOOST_CHECK(keystore.AddKey(keys[1]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n \n         CScript redeemScript = GetScriptForMultisig(2, {uncompressedPubkey, pubkeys[1]});\n         scriptPubKey = GetScriptForDestination(ScriptHash(redeemScript));\n \n         // Keystore has no redeemScript\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has redeemScript\n-        BOOST_CHECK(keystore.AddCScript(redeemScript));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemScript));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // P2WSH multisig with compressed keys\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        BOOST_CHECK(keystore.AddKey(keys[1]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n \n         CScript witnessScript = GetScriptForMultisig(2, {pubkeys[0], pubkeys[1]});\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessScript));\n \n         // Keystore has keys, but no witnessScript or P2SH redeemScript\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys and witnessScript, but no P2SH redeemScript\n-        BOOST_CHECK(keystore.AddCScript(witnessScript));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessScript));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // P2WSH multisig with uncompressed key\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(uncompressedKey));\n-        BOOST_CHECK(keystore.AddKey(keys[1]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n \n         CScript witnessScript = GetScriptForMultisig(2, {uncompressedPubkey, pubkeys[1]});\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessScript));\n \n         // Keystore has keys, but no witnessScript or P2SH redeemScript\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys and witnessScript, but no P2SH redeemScript\n-        BOOST_CHECK(keystore.AddCScript(witnessScript));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessScript));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n-        BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n@@ -326,71 +326,71 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         scriptPubKey = GetScriptForDestination(ScriptHash(redeemScript));\n \n         // Keystore has no witnessScript, P2SH redeemScript, or keys\n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has witnessScript and P2SH redeemScript, but no keys\n-        BOOST_CHECK(keystore.AddCScript(redeemScript));\n-        BOOST_CHECK(keystore.AddCScript(witnessScript));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(redeemScript));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessScript));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n \n         // Keystore has keys, witnessScript, P2SH redeemScript\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n-        BOOST_CHECK(keystore.AddKey(keys[1]));\n-        result = IsMine(keystore, scriptPubKey);\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[1]));\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n     }\n \n     // OP_RETURN\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_RETURN << ToByteVector(pubkeys[0]);\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n     // witness unspendable\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_0 << ToByteVector(ParseHex(\"aabb\"));\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n     // witness unknown\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_16 << ToByteVector(ParseHex(\"aabb\"));\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n \n     // Nonstandard\n     {\n         CWallet keystore(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n         LOCK(keystore.cs_wallet);\n-        BOOST_CHECK(keystore.AddKey(keys[0]));\n+        BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n \n         scriptPubKey.clear();\n         scriptPubKey << OP_9 << OP_ADD << OP_11 << OP_EQUAL;\n \n-        result = IsMine(keystore, scriptPubKey);\n+        result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);\n         BOOST_CHECK_EQUAL(result, ISMINE_NO);\n     }\n }"
      },
      {
        "sha": "27a64ff12f0df2192b9b3650c98851f72e447d23",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -16,6 +16,7 @@ BOOST_FIXTURE_TEST_SUITE(psbt_wallet_tests, WalletTestingSetup)\n \n BOOST_AUTO_TEST_CASE(psbt_updater_test)\n {\n+    auto spk_man = m_wallet.GetLegacyScriptPubKeyMan();\n     LOCK(m_wallet.cs_wallet);\n \n     // Create prevtxs and add to wallet\n@@ -35,23 +36,23 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)\n     CScript rs1;\n     CDataStream s_rs1(ParseHex(\"475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae\"), SER_NETWORK, PROTOCOL_VERSION);\n     s_rs1 >> rs1;\n-    m_wallet.AddCScript(rs1);\n+    spk_man->AddCScript(rs1);\n \n     CScript rs2;\n     CDataStream s_rs2(ParseHex(\"2200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903\"), SER_NETWORK, PROTOCOL_VERSION);\n     s_rs2 >> rs2;\n-    m_wallet.AddCScript(rs2);\n+    spk_man->AddCScript(rs2);\n \n     CScript ws1;\n     CDataStream s_ws1(ParseHex(\"47522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae\"), SER_NETWORK, PROTOCOL_VERSION);\n     s_ws1 >> ws1;\n-    m_wallet.AddCScript(ws1);\n+    spk_man->AddCScript(ws1);\n \n     // Add hd seed\n     CKey key = DecodeSecret(\"5KSSJQ7UNfFGwVgpCZDSHm5rVNhMFcFtvWM3zQ8mW4qNDEN7LFd\"); // Mainnet and uncompressed form of cUkG8i1RFfWGWy5ziR11zJ5V4U4W3viSFCfyJmZnvQaUsd1xuF3T\n-    CPubKey master_pub_key = m_wallet.DeriveNewSeed(key);\n-    m_wallet.SetHDSeed(master_pub_key);\n-    m_wallet.NewKeyPool();\n+    CPubKey master_pub_key = spk_man->DeriveNewSeed(key);\n+    spk_man->SetHDSeed(master_pub_key);\n+    spk_man->NewKeyPool();\n \n     // Call FillPSBT\n     PartiallySignedTransaction psbtx;"
      },
      {
        "sha": "ca4b932915f9f5c6be0cc8a2f50b09dd3bbc1fbc",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 23,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -27,8 +27,10 @@ BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletTestingSetup)\n \n static void AddKey(CWallet& wallet, const CKey& key)\n {\n+    auto spk_man = wallet.GetLegacyScriptPubKeyMan();\n     LOCK(wallet.cs_wallet);\n-    wallet.AddKeyPubKey(key, key.GetPubKey());\n+    AssertLockHeld(spk_man->cs_wallet);\n+    spk_man->AddKeyPubKey(key, key.GetPubKey());\n }\n \n BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n@@ -194,9 +196,11 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n         std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n+        auto spk_man = wallet->GetLegacyScriptPubKeyMan();\n         LOCK(wallet->cs_wallet);\n-        wallet->mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n-        wallet->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n+        AssertLockHeld(spk_man->cs_wallet);\n+        spk_man->mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n+        spk_man->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n \n         JSONRPCRequest request;\n         request.params.setArray();\n@@ -242,22 +246,24 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n     auto chain = interfaces::MakeChain();\n \n     CWallet wallet(chain.get(), WalletLocation(), WalletDatabase::CreateDummy());\n+    auto spk_man = wallet.GetLegacyScriptPubKeyMan();\n     CWalletTx wtx(&wallet, m_coinbase_txns.back());\n \n     auto locked_chain = chain->lock();\n     LockAssertion lock(::cs_main);\n     LOCK(wallet.cs_wallet);\n+    AssertLockHeld(spk_man->cs_wallet);\n \n     wtx.SetConf(CWalletTx::Status::CONFIRMED, ::ChainActive().Tip()->GetBlockHash(), 0);\n \n     // Call GetImmatureCredit() once before adding the key to the wallet to\n     // cache the current immature credit amount, which is 0.\n     BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 0);\n \n-    // Invalidate the cached value, add the key, and make sure a new immature\n+    // Invalidate the cached vanue, add the key, and make sure a new immature\n     // credit amount is calculated.\n     wtx.MarkDirty();\n-    wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n+    BOOST_CHECK(spk_man->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey()));\n     BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(*locked_chain), 50*COIN);\n }\n \n@@ -337,37 +343,38 @@ BOOST_AUTO_TEST_CASE(LoadReceiveRequests)\n     BOOST_CHECK_EQUAL(values[1], \"val_rr1\");\n }\n \n-// Test some watch-only wallet methods by the procedure of loading (LoadWatchOnly),\n+// Test some watch-only LegacyScriptPubKeyMan methods by the procedure of loading (LoadWatchOnly),\n // checking (HaveWatchOnly), getting (GetWatchPubKey) and removing (RemoveWatchOnly) a\n // given PubKey, resp. its corresponding P2PK Script. Results of the the impact on\n // the address -> PubKey map is dependent on whether the PubKey is a point on the curve\n-static void TestWatchOnlyPubKey(CWallet& wallet, const CPubKey& add_pubkey)\n+static void TestWatchOnlyPubKey(LegacyScriptPubKeyMan* spk_man, const CPubKey& add_pubkey)\n {\n     CScript p2pk = GetScriptForRawPubKey(add_pubkey);\n     CKeyID add_address = add_pubkey.GetID();\n     CPubKey found_pubkey;\n-    LOCK(wallet.cs_wallet);\n+    LOCK(spk_man->cs_wallet);\n \n     // all Scripts (i.e. also all PubKeys) are added to the general watch-only set\n-    BOOST_CHECK(!wallet.HaveWatchOnly(p2pk));\n-    wallet.LoadWatchOnly(p2pk);\n-    BOOST_CHECK(wallet.HaveWatchOnly(p2pk));\n+    BOOST_CHECK(!spk_man->HaveWatchOnly(p2pk));\n+    spk_man->LoadWatchOnly(p2pk);\n+    BOOST_CHECK(spk_man->HaveWatchOnly(p2pk));\n \n     // only PubKeys on the curve shall be added to the watch-only address -> PubKey map\n     bool is_pubkey_fully_valid = add_pubkey.IsFullyValid();\n     if (is_pubkey_fully_valid) {\n-        BOOST_CHECK(wallet.GetWatchPubKey(add_address, found_pubkey));\n+        BOOST_CHECK(spk_man->GetWatchPubKey(add_address, found_pubkey));\n         BOOST_CHECK(found_pubkey == add_pubkey);\n     } else {\n-        BOOST_CHECK(!wallet.GetWatchPubKey(add_address, found_pubkey));\n+        BOOST_CHECK(!spk_man->GetWatchPubKey(add_address, found_pubkey));\n         BOOST_CHECK(found_pubkey == CPubKey()); // passed key is unchanged\n     }\n \n-    wallet.RemoveWatchOnly(p2pk);\n-    BOOST_CHECK(!wallet.HaveWatchOnly(p2pk));\n+    AssertLockHeld(spk_man->cs_wallet);\n+    spk_man->RemoveWatchOnly(p2pk);\n+    BOOST_CHECK(!spk_man->HaveWatchOnly(p2pk));\n \n     if (is_pubkey_fully_valid) {\n-        BOOST_CHECK(!wallet.GetWatchPubKey(add_address, found_pubkey));\n+        BOOST_CHECK(!spk_man->GetWatchPubKey(add_address, found_pubkey));\n         BOOST_CHECK(found_pubkey == add_pubkey); // passed key is unchanged\n     }\n }\n@@ -382,37 +389,38 @@ static void PollutePubKey(CPubKey& pubkey)\n     assert(pubkey.IsValid());\n }\n \n-// Test watch-only wallet logic for PubKeys\n+// Test watch-only logic for PubKeys\n BOOST_AUTO_TEST_CASE(WatchOnlyPubKeys)\n {\n     CKey key;\n     CPubKey pubkey;\n+    LegacyScriptPubKeyMan* spk_man = m_wallet.GetLegacyScriptPubKeyMan();\n \n-    BOOST_CHECK(!m_wallet.HaveWatchOnly());\n+    BOOST_CHECK(!spk_man->HaveWatchOnly());\n \n     // uncompressed valid PubKey\n     key.MakeNewKey(false);\n     pubkey = key.GetPubKey();\n     assert(!pubkey.IsCompressed());\n-    TestWatchOnlyPubKey(m_wallet, pubkey);\n+    TestWatchOnlyPubKey(spk_man, pubkey);\n \n     // uncompressed cryptographically invalid PubKey\n     PollutePubKey(pubkey);\n-    TestWatchOnlyPubKey(m_wallet, pubkey);\n+    TestWatchOnlyPubKey(spk_man, pubkey);\n \n     // compressed valid PubKey\n     key.MakeNewKey(true);\n     pubkey = key.GetPubKey();\n     assert(pubkey.IsCompressed());\n-    TestWatchOnlyPubKey(m_wallet, pubkey);\n+    TestWatchOnlyPubKey(spk_man, pubkey);\n \n     // compressed cryptographically invalid PubKey\n     PollutePubKey(pubkey);\n-    TestWatchOnlyPubKey(m_wallet, pubkey);\n+    TestWatchOnlyPubKey(spk_man, pubkey);\n \n     // invalid empty PubKey\n     pubkey = CPubKey();\n-    TestWatchOnlyPubKey(m_wallet, pubkey);\n+    TestWatchOnlyPubKey(spk_man, pubkey);\n }\n \n class ListCoinsTestingSetup : public TestChain100Setup"
      },
      {
        "sha": "4b1adfb38f26be5c9912d613803c570d30f1e37f",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 210,
        "deletions": 50,
        "changes": 260,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -29,7 +29,6 @@\n #include <util/validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/fees.h>\n-#include <wallet/scriptpubkeyman.h>\n \n #include <algorithm>\n #include <assert.h>\n@@ -211,9 +210,9 @@ WalletCreationStatus CreateWallet(interfaces::Chain& chain, const SecureString&\n             }\n \n             // Set a seed for the wallet\n-            CPubKey master_pub_key = wallet->GenerateNewSeed();\n-            wallet->SetHDSeed(master_pub_key);\n-            wallet->NewKeyPool();\n+            CPubKey master_pub_key = wallet->m_spk_man->GenerateNewSeed();\n+            wallet->m_spk_man->SetHDSeed(master_pub_key);\n+            wallet->m_spk_man->NewKeyPool();\n \n             // Relock the wallet\n             wallet->Lock();\n@@ -248,6 +247,14 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n     return &(it->second);\n }\n \n+void CWallet::UpgradeKeyMetadata()\n+{\n+    AssertLockHeld(m_spk_man->cs_wallet);\n+    if (m_spk_man) {\n+        m_spk_man->UpgradeKeyMetadata();\n+    }\n+}\n+\n bool CWallet::Unlock(const SecureString& strWalletPassphrase, bool accept_no_keys)\n {\n     CCrypter crypter;\n@@ -526,14 +533,15 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         }\n         encrypted_batch->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n \n-        if (!EncryptKeys(_vMasterKey))\n-        {\n-            encrypted_batch->TxnAbort();\n-            delete encrypted_batch;\n-            encrypted_batch = nullptr;\n-            // We now probably have half of our keys encrypted in memory, and half not...\n-            // die and let the user reload the unencrypted wallet.\n-            assert(false);\n+        if (auto spk_man = m_spk_man.get()) {\n+            if (!spk_man->EncryptKeys(_vMasterKey)) {\n+                encrypted_batch->TxnAbort();\n+                delete encrypted_batch;\n+                encrypted_batch = nullptr;\n+                // We now probably have half of our keys encrypted in memory, and half not...\n+                // die and let the user reload the unencrypted wallet.\n+                assert(false);\n+            }\n         }\n \n         // Encryption was introduced in version 0.4.0\n@@ -554,11 +562,11 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         Unlock(strWalletPassphrase);\n \n         // if we are using HD, replace the HD seed with a new one\n-        if (IsHDEnabled()) {\n-            SetHDSeed(GenerateNewSeed());\n+        if (m_spk_man->IsHDEnabled()) {\n+            m_spk_man->SetHDSeed(m_spk_man->GenerateNewSeed());\n         }\n \n-        NewKeyPool();\n+        m_spk_man->NewKeyPool();\n         Lock();\n \n         // Need to completely rewrite the wallet file; if we don't, bdb might keep\n@@ -690,7 +698,7 @@ void CWallet::SetUsedDestinationState(const uint256& hash, unsigned int n, bool\n \n     CTxDestination dst;\n     if (ExtractDestination(srctx->tx->vout[n].scriptPubKey, dst)) {\n-        if (::IsMine(*this, dst)) {\n+        if (IsMine(dst)) {\n             LOCK(cs_wallet);\n             if (used && !GetDestData(dst, \"used\", nullptr)) {\n                 AddDestData(dst, \"used\", \"p\"); // p for \"present\", opposite of absent (null)\n@@ -704,7 +712,7 @@ void CWallet::SetUsedDestinationState(const uint256& hash, unsigned int n, bool\n bool CWallet::IsUsedDestination(const CTxDestination& dst) const\n {\n     LOCK(cs_wallet);\n-    return ::IsMine(*this, dst) && GetDestData(dst, \"used\", nullptr);\n+    return IsMine(dst) && GetDestData(dst, \"used\", nullptr);\n }\n \n bool CWallet::IsUsedDestination(const uint256& hash, unsigned int n) const\n@@ -864,13 +872,13 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::St\n             // loop though all outputs\n             for (const CTxOut& txout: tx.vout) {\n                 // extract addresses and check if they match with an unused keypool key\n-                for (const auto& keyid : GetAffectedKeys(txout.scriptPubKey, *this)) {\n-                    std::map<CKeyID, int64_t>::const_iterator mi = m_pool_key_to_index.find(keyid);\n-                    if (mi != m_pool_key_to_index.end()) {\n+                for (const auto& keyid : GetAffectedKeys(txout.scriptPubKey, *m_spk_man)) {\n+                    std::map<CKeyID, int64_t>::const_iterator mi = m_spk_man->m_pool_key_to_index.find(keyid);\n+                    if (mi != m_spk_man->m_pool_key_to_index.end()) {\n                         WalletLogPrintf(\"%s: Detected a used keypool key, mark all keypool key up to this key as used\\n\", __func__);\n                         MarkReserveKeysAsUsed(mi->second);\n \n-                        if (!TopUpKeyPool()) {\n+                        if (!m_spk_man->TopUpKeyPool()) {\n                             WalletLogPrintf(\"%s: Topping up keypool failed (locked wallet)\\n\", __func__);\n                         }\n                     }\n@@ -1126,13 +1134,21 @@ CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n \n isminetype CWallet::IsMine(const CTxOut& txout) const\n {\n-    return ::IsMine(*this, txout.scriptPubKey);\n+    return IsMine(txout.scriptPubKey);\n+}\n+\n+isminetype CWallet::IsMine(const CTxDestination& dest) const\n+{\n+    return IsMine(GetScriptForDestination(dest));\n }\n \n-isminetype IsMine(const CWallet& keystore, const CTxDestination& dest)\n+isminetype CWallet::IsMine(const CScript& script) const\n {\n-    CScript script = GetScriptForDestination(dest);\n-    return IsMine(keystore, script);\n+    isminetype result = ISMINE_NO;\n+    if (auto spk_man = m_spk_man.get()) {\n+        result = spk_man->IsMine(script);\n+    }\n+    return result;\n }\n \n CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n@@ -1156,7 +1172,7 @@ bool CWallet::IsChange(const CScript& script) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    if (::IsMine(*this, script))\n+    if (IsMine(script))\n     {\n         CTxDestination address;\n         if (!ExtractDestination(script, address))\n@@ -1246,6 +1262,26 @@ CAmount CWallet::GetChange(const CTransaction& tx) const\n     return nChange;\n }\n \n+bool CWallet::IsHDEnabled() const\n+{\n+    bool result = true;\n+    if (auto spk_man = m_spk_man.get()) {\n+        result &= spk_man->IsHDEnabled();\n+    }\n+    return result;\n+}\n+\n+bool CWallet::CanGetAddresses(bool internal)\n+{\n+    {\n+        auto spk_man = m_spk_man.get();\n+        if (spk_man && spk_man->CanGetAddresses(internal)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n void CWallet::SetWalletFlag(uint64_t flags)\n {\n     LOCK(cs_wallet);\n@@ -1302,7 +1338,9 @@ bool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout, bool use_max_sig\n     const CScript& scriptPubKey = txout.scriptPubKey;\n     SignatureData sigdata;\n \n-    if (!ProduceSignature(*this, use_max_sig ? DUMMY_MAXIMUM_SIGNATURE_CREATOR : DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata)) {\n+    const SigningProvider* provider = GetSigningProvider();\n+\n+    if (!ProduceSignature(*provider, use_max_sig ? DUMMY_MAXIMUM_SIGNATURE_CREATOR : DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata)) {\n         return false;\n     }\n     UpdateInput(tx_in, sigdata);\n@@ -1325,6 +1363,49 @@ bool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut>\n     return true;\n }\n \n+bool CWallet::ImportScripts(const std::set<CScript> scripts, int64_t timestamp)\n+{\n+    auto spk_man = GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        return false;\n+    }\n+    AssertLockHeld(spk_man->cs_wallet);\n+    return spk_man->ImportScripts(scripts, timestamp);\n+}\n+\n+bool CWallet::ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp)\n+{\n+    auto spk_man = GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        return false;\n+    }\n+    AssertLockHeld(spk_man->cs_wallet);\n+    return spk_man->ImportPrivKeys(privkey_map, timestamp);\n+}\n+\n+bool CWallet::ImportPubKeys(const std::vector<CKeyID>& ordered_pubkeys, const std::map<CKeyID, CPubKey>& pubkey_map, const std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>>& key_origins, const bool add_keypool, const bool internal, const int64_t timestamp)\n+{\n+    auto spk_man = GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        return false;\n+    }\n+    AssertLockHeld(spk_man->cs_wallet);\n+    return spk_man->ImportPubKeys(ordered_pubkeys, pubkey_map, key_origins, add_keypool, internal, timestamp);\n+}\n+\n+bool CWallet::ImportScriptPubKeys(const std::string& label, const std::set<CScript>& script_pub_keys, const bool have_solving_data, const bool apply_label, const int64_t timestamp)\n+{\n+    auto spk_man = GetLegacyScriptPubKeyMan();\n+    if (!spk_man) {\n+        return false;\n+    }\n+    AssertLockHeld(spk_man->cs_wallet);\n+    if (!spk_man->ImportScriptPubKeys(label, script_pub_keys, have_solving_data, apply_label, timestamp)) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n {\n     std::vector<CTxOut> txouts;\n@@ -2001,7 +2082,9 @@ void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<\n                 continue;\n             }\n \n-            bool solvable = IsSolvable(*this, wtx.tx->vout[i].scriptPubKey);\n+            const SigningProvider* provider = GetSigningProvider();\n+\n+            bool solvable = provider ? IsSolvable(*provider, wtx.tx->vout[i].scriptPubKey) : false;\n             bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));\n \n             vCoins.push_back(COutput(&wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n@@ -2235,7 +2318,13 @@ bool CWallet::SignTransaction(CMutableTransaction& tx)\n         const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n         const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n         SignatureData sigdata;\n-        if (!ProduceSignature(*this, MutableTransactionSignatureCreator(&tx, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n+\n+        const SigningProvider* provider = GetSigningProvider();\n+        if (!provider) {\n+            return false;\n+        }\n+\n+        if (!ProduceSignature(*provider, MutableTransactionSignatureCreator(&tx, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n             return false;\n         }\n         UpdateInput(input, sigdata);\n@@ -2693,7 +2782,12 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n                 const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                 SignatureData sigdata;\n \n-                if (!ProduceSignature(*this, MutableTransactionSignatureCreator(&txNew, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n+                const SigningProvider* provider = GetSigningProvider();\n+                if (!provider) {\n+                    return false;\n+                }\n+\n+                if (!ProduceSignature(*provider, MutableTransactionSignatureCreator(&txNew, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                 {\n                     strFailReason = _(\"Signing transaction failed\").translated;\n                     return false;\n@@ -2801,7 +2895,7 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n         {\n             setInternalKeyPool.clear();\n             setExternalKeyPool.clear();\n-            m_pool_key_to_index.clear();\n+            m_spk_man->m_pool_key_to_index.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n             // User will be prompted to unlock wallet the next operation\n             // that requires a new key.\n@@ -2838,7 +2932,7 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n         {\n             setInternalKeyPool.clear();\n             setExternalKeyPool.clear();\n-            m_pool_key_to_index.clear();\n+            m_spk_man->m_pool_key_to_index.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n             // User will be prompted to unlock wallet the next operation\n             // that requires a new key.\n@@ -2863,7 +2957,7 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n             LOCK(cs_wallet);\n             setInternalKeyPool.clear();\n             setExternalKeyPool.clear();\n-            m_pool_key_to_index.clear();\n+            m_spk_man->m_pool_key_to_index.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n             // User will be prompted to unlock wallet the next operation\n             // that requires a new key.\n@@ -2887,7 +2981,7 @@ bool CWallet::SetAddressBookWithDB(WalletBatch& batch, const CTxDestination& add\n         if (!strPurpose.empty()) /* update purpose only if requested */\n             mapAddressBook[address].purpose = strPurpose;\n     }\n-    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n+    NotifyAddressBookChanged(this, address, strName, IsMine(address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n     if (!strPurpose.empty() && !batch.WritePurpose(EncodeDestination(address), strPurpose))\n         return false;\n@@ -2914,17 +3008,50 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n         mapAddressBook.erase(address);\n     }\n \n-    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n+    NotifyAddressBookChanged(this, address, \"\", IsMine(address) != ISMINE_NO, \"\", CT_DELETED);\n \n     WalletBatch(*database).ErasePurpose(EncodeDestination(address));\n     return WalletBatch(*database).EraseName(EncodeDestination(address));\n }\n \n+size_t CWallet::KeypoolCountExternalKeys()\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    unsigned int count = 0;\n+    if (auto spk_man = m_spk_man.get()) {\n+        AssertLockHeld(spk_man->cs_wallet);\n+        count += spk_man->KeypoolCountExternalKeys();\n+    }\n+\n+    return count;\n+}\n+\n+bool CWallet::TopUpKeyPool(unsigned int kpSize)\n+{\n+    bool res = true;\n+    if (auto spk_man = m_spk_man.get()) {\n+        res &= spk_man->TopUpKeyPool(kpSize);\n+    }\n+    return res;\n+}\n+\n+bool CWallet::GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error)\n+{\n+    error.clear();\n+    bool result = false;\n+    auto spk_man = m_spk_man.get();\n+    if (spk_man) {\n+        result = spk_man->GetNewDestination(type, label, dest, error);\n+    }\n+    return result;\n+}\n+\n bool CWallet::GetNewChangeDestination(const OutputType type, CTxDestination& dest, std::string& error)\n {\n     error.clear();\n \n-    TopUpKeyPool();\n+    m_spk_man->TopUpKeyPool();\n \n     ReserveDestination reservedest(this);\n     if (!reservedest.GetReservedDestination(type, dest, true)) {\n@@ -2936,6 +3063,15 @@ bool CWallet::GetNewChangeDestination(const OutputType type, CTxDestination& des\n     return true;\n }\n \n+int64_t CWallet::GetOldestKeyPoolTime()\n+{\n+    int64_t oldestKey = std::numeric_limits<int64_t>::max();\n+    if (auto spk_man = m_spk_man.get()) {\n+        oldestKey = spk_man->GetOldestKeyPoolTime();\n+    }\n+    return oldestKey;\n+}\n+\n std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain::Lock& locked_chain)\n {\n     std::map<CTxDestination, CAmount> balances;\n@@ -3085,21 +3221,26 @@ std::set<CTxDestination> CWallet::GetLabelAddresses(const std::string& label) co\n \n bool ReserveDestination::GetReservedDestination(const OutputType type, CTxDestination& dest, bool internal)\n {\n+    m_spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+    if (!m_spk_man) {\n+        return false;\n+    }\n+\n     if (!pwallet->CanGetAddresses(internal)) {\n         return false;\n     }\n \n     if (nIndex == -1)\n     {\n         CKeyPool keypool;\n-        if (!pwallet->ReserveKeyFromKeyPool(nIndex, keypool, internal)) {\n+        if (!m_spk_man->ReserveKeyFromKeyPool(nIndex, keypool, internal)) {\n             return false;\n         }\n         vchPubKey = keypool.vchPubKey;\n         fInternal = keypool.fInternal;\n     }\n     assert(vchPubKey.IsValid());\n-    pwallet->LearnRelatedScripts(vchPubKey, type);\n+    m_spk_man->LearnRelatedScripts(vchPubKey, type);\n     address = GetDestinationForKey(vchPubKey, type);\n     dest = address;\n     return true;\n@@ -3108,7 +3249,7 @@ bool ReserveDestination::GetReservedDestination(const OutputType type, CTxDestin\n void ReserveDestination::KeepDestination()\n {\n     if (nIndex != -1)\n-        pwallet->KeepKey(nIndex);\n+        m_spk_man->KeepKey(nIndex);\n     nIndex = -1;\n     vchPubKey = CPubKey();\n     address = CNoDestination();\n@@ -3117,7 +3258,7 @@ void ReserveDestination::KeepDestination()\n void ReserveDestination::ReturnDestination()\n {\n     if (nIndex != -1) {\n-        pwallet->ReturnKey(nIndex, fInternal, vchPubKey);\n+        m_spk_man->ReturnKey(nIndex, fInternal, vchPubKey);\n     }\n     nIndex = -1;\n     vchPubKey = CPubKey();\n@@ -3166,8 +3307,12 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n     AssertLockHeld(cs_wallet);\n     mapKeyBirth.clear();\n \n+    LegacyScriptPubKeyMan* spk_man = GetLegacyScriptPubKeyMan();\n+    assert(spk_man != nullptr);\n+    AssertLockHeld(spk_man->cs_wallet);\n+\n     // get birth times for keys with metadata\n-    for (const auto& entry : mapKeyMetadata) {\n+    for (const auto& entry : spk_man->mapKeyMetadata) {\n         if (entry.second.nCreateTime) {\n             mapKeyBirth[entry.first] = entry.second.nCreateTime;\n         }\n@@ -3177,7 +3322,7 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n     const Optional<int> tip_height = locked_chain.getHeight();\n     const int max_height = tip_height && *tip_height > 144 ? *tip_height - 144 : 0; // the tip can be reorganized; use a 144-block safety margin\n     std::map<CKeyID, int> mapKeyFirstBlock;\n-    for (const CKeyID &keyid : GetKeys()) {\n+    for (const CKeyID &keyid : spk_man->GetKeys()) {\n         if (mapKeyBirth.count(keyid) == 0)\n             mapKeyFirstBlock[keyid] = max_height;\n     }\n@@ -3194,7 +3339,7 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n             // ... which are already in a block\n             for (const CTxOut &txout : wtx.tx->vout) {\n                 // iterate over all their outputs\n-                for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *this)) {\n+                for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *spk_man)) {\n                     // ... and all their affected keys\n                     std::map<CKeyID, int>::iterator rit = mapKeyFirstBlock.find(keyid);\n                     if (rit != mapKeyFirstBlock.end() && *height < rit->second)\n@@ -3461,13 +3606,13 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n \n         bool hd_upgrade = false;\n         bool split_upgrade = false;\n-        if (walletInstance->CanSupportFeature(FEATURE_HD) && !walletInstance->IsHDEnabled()) {\n+        if (walletInstance->CanSupportFeature(FEATURE_HD) && !walletInstance->m_spk_man->IsHDEnabled()) {\n             walletInstance->WalletLogPrintf(\"Upgrading wallet to HD\\n\");\n             walletInstance->SetMinVersion(FEATURE_HD);\n \n             // generate a new master key\n-            CPubKey masterPubKey = walletInstance->GenerateNewSeed();\n-            walletInstance->SetHDSeed(masterPubKey);\n+            CPubKey masterPubKey = walletInstance->m_spk_man->GenerateNewSeed();\n+            walletInstance->m_spk_man->SetHDSeed(masterPubKey);\n             hd_upgrade = true;\n         }\n         // Upgrade to HD chain split if necessary\n@@ -3482,7 +3627,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         }\n         // Regenerate the keypool if upgraded to HD\n         if (hd_upgrade) {\n-            if (!walletInstance->TopUpKeyPool()) {\n+            if (!walletInstance->m_spk_man->TopUpKeyPool()) {\n                 error = _(\"Unable to generate keys\").translated;\n                 return nullptr;\n             }\n@@ -3497,12 +3642,12 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         walletInstance->SetWalletFlags(wallet_creation_flags, false);\n         if (!(wallet_creation_flags & (WALLET_FLAG_DISABLE_PRIVATE_KEYS | WALLET_FLAG_BLANK_WALLET))) {\n             // generate a new seed\n-            CPubKey seed = walletInstance->GenerateNewSeed();\n-            walletInstance->SetHDSeed(seed);\n+            CPubKey seed = walletInstance->m_spk_man->GenerateNewSeed();\n+            walletInstance->m_spk_man->SetHDSeed(seed);\n         }\n \n         // Top up the keypool\n-        if (walletInstance->CanGenerateKeys() && !walletInstance->TopUpKeyPool()) {\n+        if (walletInstance->m_spk_man->CanGenerateKeys() && !walletInstance->m_spk_man->TopUpKeyPool()) {\n             error = _(\"Unable to generate initial keys\").translated;\n             return nullptr;\n         }\n@@ -3858,3 +4003,18 @@ bool CWallet::Lock()\n     NotifyStatusChanged(this);\n     return true;\n }\n+\n+ScriptPubKeyMan* CWallet::GetScriptPubKeyMan() const\n+{\n+    return m_spk_man.get();\n+}\n+\n+const SigningProvider* CWallet::GetSigningProvider() const\n+{\n+    return m_spk_man.get();\n+}\n+\n+LegacyScriptPubKeyMan* CWallet::GetLegacyScriptPubKeyMan() const\n+{\n+    return m_spk_man.get();\n+}"
      },
      {
        "sha": "f3b791441c956296dd93c8c1ee0ed5a3800d5f56",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 36,
        "deletions": 173,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -18,7 +18,7 @@\n #include <validationinterface.h>\n #include <wallet/coinselection.h>\n #include <wallet/crypter.h>\n-#include <wallet/ismine.h>\n+#include <wallet/scriptpubkeyman.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n \n@@ -141,6 +141,7 @@ class ReserveDestination\n protected:\n     //! The wallet to reserve from\n     CWallet* pwallet;\n+    LegacyScriptPubKeyMan* m_spk_man{nullptr};\n     //! The index of the address's key in the keypool\n     int64_t nIndex{-1};\n     //! The public key for the address\n@@ -581,10 +582,9 @@ struct CoinSelectionParams\n \n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n /**\n- * A CWallet is an extension of a keystore, which also maintains a set of transactions and balances,\n- * and provides the ability to create new transactions.\n+ * A CWallet maintains a set of transactions and balances, and provides the ability to create new transactions.\n  */\n-class CWallet final : public FillableSigningProvider, private interfaces::Chain::Notifications\n+class CWallet final : public WalletStorage, private interfaces::Chain::Notifications\n {\n private:\n     CKeyingMaterial vMasterKey GUARDED_BY(cs_KeyStore);\n@@ -596,22 +596,8 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     //! keeps track of whether Unlock has run a thorough check before\n     bool fDecryptionThoroughlyChecked;\n \n-    using CryptedKeyMap = std::map<CKeyID, std::pair<CPubKey, std::vector<unsigned char>>>;\n-    using WatchOnlySet = std::set<CScript>;\n-    using WatchKeyMap = std::map<CKeyID, CPubKey>;\n-\n     bool SetCrypted();\n-\n-    //! will encrypt previously unencrypted keys\n-    bool EncryptKeys(CKeyingMaterial& vMasterKeyIn);\n-\n     bool Unlock(const CKeyingMaterial& vMasterKeyIn, bool accept_no_keys = false);\n-    CryptedKeyMap mapCryptedKeys GUARDED_BY(cs_KeyStore);\n-    WatchOnlySet setWatchOnly GUARDED_BY(cs_KeyStore);\n-    WatchKeyMap mapWatchKeys GUARDED_BY(cs_KeyStore);\n-\n-    bool AddCryptedKeyInner(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    bool AddKeyPubKeyInner(const CKey& key, const CPubKey &pubkey);\n \n     std::atomic<bool> fAbortRescan{false};\n     std::atomic<bool> fScanningWallet{false}; // controlled by WalletRescanReserver\n@@ -620,8 +606,6 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     std::mutex mutexScanning;\n     friend class WalletRescanReserver;\n \n-    WalletBatch *encrypted_batch GUARDED_BY(cs_wallet) = nullptr;\n-\n     //! the current wallet version: clients below this version are not able to load the wallet\n     int nWalletVersion GUARDED_BY(cs_wallet){FEATURE_BASE};\n \n@@ -671,52 +655,12 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n      * Should be called with non-zero block_hash and posInBlock if this is for a transaction that is included in a block. */\n     void SyncTransaction(const CTransactionRef& tx, CWalletTx::Status status, const uint256& block_hash, int posInBlock = 0, bool update_tx = true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    /* the HD chain data model (external chain counters) */\n-    CHDChain hdChain;\n-\n-    /* HD derive new child key (on internal or external chain) */\n-    void DeriveNewChildKey(WalletBatch& batch, CKeyMetadata& metadata, CKey& secret, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    std::set<int64_t> setInternalKeyPool GUARDED_BY(cs_wallet);\n-    std::set<int64_t> setExternalKeyPool GUARDED_BY(cs_wallet);\n-    std::set<int64_t> set_pre_split_keypool GUARDED_BY(cs_wallet);\n-    int64_t m_max_keypool_index GUARDED_BY(cs_wallet) = 0;\n-    std::map<CKeyID, int64_t> m_pool_key_to_index;\n     std::atomic<uint64_t> m_wallet_flags{0};\n \n-    int64_t nTimeFirstKey GUARDED_BY(cs_wallet) = 0;\n-\n-    /**\n-     * Private version of AddWatchOnly method which does not accept a\n-     * timestamp, and which will reset the wallet's nTimeFirstKey value to 1 if\n-     * the watch key did not previously have a timestamp associated with it.\n-     * Because this is an inherited virtual method, it is accessible despite\n-     * being marked private, but it is marked private anyway to encourage use\n-     * of the other AddWatchOnly which accepts a timestamp and sets\n-     * nTimeFirstKey more intelligently for more efficient rescans.\n-     */\n-    bool AddWatchOnly(const CScript& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool AddWatchOnlyInMem(const CScript &dest);\n-\n-    /** Add a KeyOriginInfo to the wallet */\n-    bool AddKeyOriginWithDB(WalletBatch& batch, const CPubKey& pubkey, const KeyOriginInfo& info);\n-\n-    //! Adds a key to the store, and saves it to disk.\n-    bool AddKeyPubKeyWithDB(WalletBatch &batch,const CKey& key, const CPubKey &pubkey) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    //! Adds a watch-only address to the store, and saves it to disk.\n-    bool AddWatchOnlyWithDB(WalletBatch &batch, const CScript& dest, int64_t create_time) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    void AddKeypoolPubkeyWithDB(const CPubKey& pubkey, const bool internal, WalletBatch& batch);\n-\n     bool SetAddressBookWithDB(WalletBatch& batch, const CTxDestination& address, const std::string& strName, const std::string& strPurpose);\n \n-    //! Adds a script to the store and saves it to disk\n-    bool AddCScriptWithDB(WalletBatch& batch, const CScript& script);\n-\n     //! Unsets a wallet flag and saves it to disk\n-    void UnsetWalletFlagWithDB(WalletBatch& batch, uint64_t flag);\n+    void UnsetWalletFlagWithDB(WalletBatch& batch, uint64_t flag) override;\n \n     /** Interface for accessing chain state. */\n     interfaces::Chain* m_chain;\n@@ -737,9 +681,6 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n      */\n     uint256 m_last_block_processed GUARDED_BY(cs_wallet);\n \n-    //! Fetches a key from the keypool\n-    bool GetKeyFromPool(CPubKey &key, bool internal = false);\n-\n public:\n     /*\n      * Main wallet lock.\n@@ -754,6 +695,7 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     {\n         return *database;\n     }\n+    WalletDatabase& GetDatabase() override { return *database; }\n \n     /**\n      * Select a set of coins such that nValueRet >= nTargetValue and at least\n@@ -769,15 +711,6 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n      */\n     const std::string& GetName() const { return m_location.GetName(); }\n \n-    void LoadKeyPool(int64_t nIndex, const CKeyPool &keypool) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    void MarkPreSplitKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    // Map from Key ID to key metadata.\n-    std::map<CKeyID, CKeyMetadata> mapKeyMetadata GUARDED_BY(cs_wallet);\n-\n-    // Map from Script ID to key metadata (for watch-only keys).\n-    std::map<CScriptID, CKeyMetadata> m_script_metadata GUARDED_BY(cs_wallet);\n-\n     typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n     MasterKeyMap mapMasterKeys;\n     unsigned int nMasterKeyMaxID = 0;\n@@ -801,7 +734,7 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     }\n \n     bool IsCrypted() const { return fUseCrypto; }\n-    bool IsLocked() const;\n+    bool IsLocked() const override;\n     bool Lock();\n \n     /** Interface to assert chain access and if successful lock it */\n@@ -831,7 +764,7 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     const CWalletTx* GetWalletTx(const uint256& hash) const;\n \n     //! check whether we are allowed to upgrade (or already support) to the named feature\n-    bool CanSupportFeature(enum WalletFeature wf) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n+    bool CanSupportFeature(enum WalletFeature wf) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n \n     /**\n      * populate vCoins with vector of available COutputs.\n@@ -881,34 +814,10 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     int64_t ScanningDuration() const { return fScanningWallet ? GetTimeMillis() - m_scanning_start : 0; }\n     double ScanningProgress() const { return fScanningWallet ? (double) m_scanning_progress : 0; }\n \n-    /**\n-     * keystore implementation\n-     * Generate a new key\n-     */\n-    CPubKey GenerateNewKey(WalletBatch& batch, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    //! Adds a key to the store, and saves it to disk.\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n-    bool LoadKey(const CKey& key, const CPubKey &pubkey) { return AddKeyPubKeyInner(key, pubkey); }\n-    //! Load metadata (used by LoadWallet)\n-    void LoadKeyMetadata(const CKeyID& keyID, const CKeyMetadata &metadata) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    void LoadScriptMetadata(const CScriptID& script_id, const CKeyMetadata &metadata) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     //! Upgrade stored CKeyMetadata objects to store key origin info as KeyOriginInfo\n     void UpgradeKeyMetadata() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     bool LoadMinVersion(int nVersion) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n-    void UpdateTimeFirstKey(int64_t nCreateTime) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    //! Adds an encrypted key to the store, and saves it to disk.\n-    bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n-    bool LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    bool GetKey(const CKeyID &address, CKey& keyOut) const override;\n-    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n-    bool HaveKey(const CKeyID &address) const override;\n-    std::set<CKeyID> GetKeys() const override;\n-    bool AddCScript(const CScript& redeemScript) override;\n-    bool LoadCScript(const CScript& redeemScript);\n \n     //! Adds a destination data tuple to the store, and saves it to disk\n     bool AddDestData(const CTxDestination& dest, const std::string& key, const std::string& value) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -921,18 +830,6 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     //! Get all destination values matching a prefix.\n     std::vector<std::string> GetDestValues(const std::string& prefix) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    //! Adds a watch-only address to the store, and saves it to disk.\n-    bool AddWatchOnly(const CScript& dest, int64_t nCreateTime) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool RemoveWatchOnly(const CScript &dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    //! Adds a watch-only address to the store, without saving it to disk (used by LoadWallet)\n-    bool LoadWatchOnly(const CScript &dest);\n-    //! Returns whether the watch-only script is in the wallet\n-    bool HaveWatchOnly(const CScript &dest) const;\n-    //! Returns whether there are any watch-only things in the wallet\n-    bool HaveWatchOnly() const;\n-    //! Fetches a pubkey from mapWatchKeys if it exists there\n-    bool GetWatchPubKey(const CKeyID &address, CPubKey &pubkey_out) const;\n-\n     //! Holds a timestamp at which point the wallet is scheduled (externally) to be relocked. Caller must arrange for actual relocking to occur via Lock().\n     int64_t nRelockTime = 0;\n \n@@ -1048,33 +945,10 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     /** Absolute maximum transaction fee (in satoshis) used by default for the wallet */\n     CAmount m_default_max_tx_fee{DEFAULT_TRANSACTION_MAXFEE};\n \n-    bool NewKeyPool();\n     size_t KeypoolCountExternalKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool TopUpKeyPool(unsigned int kpSize = 0);\n \n-    /**\n-     * Reserves a key from the keypool and sets nIndex to its index\n-     *\n-     * @param[out] nIndex the index of the key in keypool\n-     * @param[out] keypool the keypool the key was drawn from, which could be the\n-     *     the pre-split pool if present, or the internal or external pool\n-     * @param fRequestedInternal true if the caller would like the key drawn\n-     *     from the internal keypool, false if external is preferred\n-     *\n-     * @return true if succeeded, false if failed due to empty keypool\n-     * @throws std::runtime_error if keypool read failed, key was invalid,\n-     *     was not found in the wallet, or was misclassified in the internal\n-     *     or external keypool\n-     */\n-    bool ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal);\n-    void KeepKey(int64_t nIndex);\n-    void ReturnKey(int64_t nIndex, bool fInternal, const CPubKey& pubkey);\n     int64_t GetOldestKeyPoolTime();\n-    /**\n-     * Marks all keys in the keypool up to and including reserve_key as used.\n-     */\n-    void MarkReserveKeysAsUsed(int64_t keypool_id) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    const std::map<CKeyID, int64_t>& GetAllReserveKeys() const { return m_pool_key_to_index; }\n \n     std::set<std::set<CTxDestination>> GetAddressGroupings() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     std::map<CTxDestination, CAmount> GetAddressBalances(interfaces::Chain::Lock& locked_chain);\n@@ -1084,6 +958,8 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     bool GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error);\n     bool GetNewChangeDestination(const OutputType type, CTxDestination& dest, std::string& error);\n \n+    isminetype IsMine(const CTxDestination& dest) const;\n+    isminetype IsMine(const CScript& script) const;\n     isminetype IsMine(const CTxIn& txin) const;\n     /**\n      * Returns amount of debit if the input matches the\n@@ -1120,7 +996,7 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n     }\n \n     //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n-    void SetMinVersion(enum WalletFeature, WalletBatch* batch_in = nullptr, bool fExplicit = false);\n+    void SetMinVersion(enum WalletFeature, WalletBatch* batch_in = nullptr, bool fExplicit = false) override;\n \n     //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n     bool SetMaxVersion(int nVersion);\n@@ -1199,31 +1075,12 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n \n     bool BackupWallet(const std::string& strDest);\n \n-    /* Set the HD chain model (chain child index counters) */\n-    void SetHDChain(const CHDChain& chain, bool memonly);\n-    const CHDChain& GetHDChain() const { return hdChain; }\n-\n     /* Returns true if HD is enabled */\n     bool IsHDEnabled() const;\n \n-    /* Returns true if the wallet can generate new keys */\n-    bool CanGenerateKeys();\n-\n     /* Returns true if the wallet can give out new addresses. This means it has keys in the keypool or can generate new keys */\n     bool CanGetAddresses(bool internal = false);\n \n-    /* Generates a new HD seed (will not be activated) */\n-    CPubKey GenerateNewSeed();\n-\n-    /* Derives a new HD seed (will not be activated) */\n-    CPubKey DeriveNewSeed(const CKey& key);\n-\n-    /* Set the current HD seed (will reset the chain child index counters)\n-       Sets the seed's version based on the current wallet version (so the\n-       caller must ensure the current wallet version is correct before calling\n-       this function). */\n-    void SetHDSeed(const CPubKey& key);\n-\n     /**\n      * Blocks until the wallet state is up-to-date to /at least/ the current\n      * chain at the time this function is entered\n@@ -1232,35 +1089,21 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n      */\n     void BlockUntilSyncedToCurrentChain() LOCKS_EXCLUDED(cs_main, cs_wallet);\n \n-    /**\n-     * Explicitly make the wallet learn the related scripts for outputs to the\n-     * given key. This is purely to make the wallet file compatible with older\n-     * software, as FillableSigningProvider automatically does this implicitly for all\n-     * keys now.\n-     */\n-    void LearnRelatedScripts(const CPubKey& key, OutputType);\n-\n-    /**\n-     * Same as LearnRelatedScripts, but when the OutputType is not known (and could\n-     * be anything).\n-     */\n-    void LearnAllRelatedScripts(const CPubKey& key);\n-\n     /** set a single wallet flag */\n-    void SetWalletFlag(uint64_t flags);\n+    void SetWalletFlag(uint64_t flags) override;\n \n     /** Unsets a single wallet flag */\n     void UnsetWalletFlag(uint64_t flag);\n \n     /** check if a certain wallet flag is set */\n-    bool IsWalletFlagSet(uint64_t flag) const;\n+    bool IsWalletFlagSet(uint64_t flag) const override;\n \n     /** overwrite all flags by the given uint64_t\n        returns false if unknown, non-tolerable flags are present */\n     bool SetWalletFlags(uint64_t overwriteFlags, bool memOnly);\n \n     /** Returns a bracketed wallet name for displaying in logs, will return [default wallet] if the wallet has no name */\n-    const std::string GetDisplayName() const {\n+    const std::string GetDisplayName() const override {\n         std::string wallet_name = GetName().length() == 0 ? \"default wallet\" : GetName();\n         return strprintf(\"[%s]\", wallet_name);\n     };\n@@ -1271,8 +1114,28 @@ class CWallet final : public FillableSigningProvider, private interfaces::Chain:\n         LogPrintf((\"%s \" + fmt).c_str(), GetDisplayName(), parameters...);\n     };\n \n-    /** Implement lookup of key origin information through wallet key metadata. */\n-    bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const override;\n+    ScriptPubKeyMan* GetScriptPubKeyMan() const;\n+    const SigningProvider* GetSigningProvider() const;\n+    LegacyScriptPubKeyMan* GetLegacyScriptPubKeyMan() const;\n+\n+    // Temporary LegacyScriptPubKeyMan accessors and aliases.\n+    friend class LegacyScriptPubKeyMan;\n+    std::unique_ptr<LegacyScriptPubKeyMan> m_spk_man = MakeUnique<LegacyScriptPubKeyMan>(*this);\n+    CCriticalSection& cs_KeyStore = m_spk_man->cs_KeyStore;\n+    LegacyScriptPubKeyMan::KeyMap& mapKeys GUARDED_BY(cs_KeyStore) = m_spk_man->mapKeys;\n+    LegacyScriptPubKeyMan::ScriptMap& mapScripts GUARDED_BY(cs_KeyStore) = m_spk_man->mapScripts;\n+    LegacyScriptPubKeyMan::CryptedKeyMap& mapCryptedKeys GUARDED_BY(cs_KeyStore) = m_spk_man->mapCryptedKeys;\n+    LegacyScriptPubKeyMan::WatchOnlySet& setWatchOnly GUARDED_BY(cs_KeyStore) = m_spk_man->setWatchOnly;\n+    LegacyScriptPubKeyMan::WatchKeyMap& mapWatchKeys GUARDED_BY(cs_KeyStore) = m_spk_man->mapWatchKeys;\n+    WalletBatch*& encrypted_batch GUARDED_BY(cs_wallet) = m_spk_man->encrypted_batch;\n+    std::set<int64_t>& setInternalKeyPool GUARDED_BY(cs_wallet) = m_spk_man->setInternalKeyPool;\n+    std::set<int64_t>& setExternalKeyPool GUARDED_BY(cs_wallet) = m_spk_man->setExternalKeyPool;\n+    int64_t& nTimeFirstKey GUARDED_BY(cs_wallet) = m_spk_man->nTimeFirstKey;\n+    std::map<CKeyID, CKeyMetadata>& mapKeyMetadata GUARDED_BY(cs_wallet) = m_spk_man->mapKeyMetadata;\n+    std::map<CScriptID, CKeyMetadata>& m_script_metadata GUARDED_BY(cs_wallet) = m_spk_man->m_script_metadata;\n+    void MarkPreSplitKeys() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(m_spk_man->cs_wallet); m_spk_man->MarkPreSplitKeys(); }\n+    void MarkReserveKeysAsUsed(int64_t keypool_id) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(m_spk_man->cs_wallet); m_spk_man->MarkReserveKeysAsUsed(keypool_id); }\n+    using CryptedKeyMap = LegacyScriptPubKeyMan::CryptedKeyMap;\n };\n \n /**"
      },
      {
        "sha": "2ba7cdac360e6eef14876598d593323e7f737510",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 16,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -12,7 +12,6 @@\n #include <sync.h>\n #include <util/system.h>\n #include <util/time.h>\n-#include <wallet/scriptpubkeyman.h>\n #include <wallet/wallet.h>\n \n #include <atomic>\n@@ -197,7 +196,7 @@ class CWalletScanState {\n \n static bool\n ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, std::string& strType, std::string& strErr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+             CWalletScanState &wss, std::string& strType, std::string& strErr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet, pwallet->GetLegacyScriptPubKeyMan()->cs_wallet)\n {\n     try {\n         // Unserialize\n@@ -251,8 +250,9 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssKey >> script;\n             char fYes;\n             ssValue >> fYes;\n-            if (fYes == '1')\n-                pwallet->LoadWatchOnly(script);\n+            if (fYes == '1') {\n+                pwallet->GetLegacyScriptPubKeyMan()->LoadWatchOnly(script);\n+            }\n         } else if (strType == DBKeys::KEY) {\n             CPubKey vchPubKey;\n             ssKey >> vchPubKey;\n@@ -303,12 +303,13 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                 strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                 return false;\n             }\n-            if (!pwallet->LoadKey(key, vchPubKey))\n+            if (!pwallet->GetLegacyScriptPubKeyMan()->LoadKey(key, vchPubKey))\n             {\n-                strErr = \"Error reading wallet database: LoadKey failed\";\n+                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadKey failed\";\n                 return false;\n             }\n         } else if (strType == DBKeys::MASTER_KEY) {\n+            // Master encryption key is loaded into only the wallet and not any of the ScriptPubKeyMans.\n             unsigned int nID;\n             ssKey >> nID;\n             CMasterKey kMasterKey;\n@@ -333,9 +334,9 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssValue >> vchPrivKey;\n             wss.nCKeys++;\n \n-            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n+            if (!pwallet->GetLegacyScriptPubKeyMan()->LoadCryptedKey(vchPubKey, vchPrivKey))\n             {\n-                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n+                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCryptedKey failed\";\n                 return false;\n             }\n             wss.fIsEncrypted = true;\n@@ -345,14 +346,14 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CKeyMetadata keyMeta;\n             ssValue >> keyMeta;\n             wss.nKeyMeta++;\n-            pwallet->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n+            pwallet->GetLegacyScriptPubKeyMan()->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);\n         } else if (strType == DBKeys::WATCHMETA) {\n             CScript script;\n             ssKey >> script;\n             CKeyMetadata keyMeta;\n             ssValue >> keyMeta;\n             wss.nKeyMeta++;\n-            pwallet->LoadScriptMetadata(CScriptID(script), keyMeta);\n+            pwallet->GetLegacyScriptPubKeyMan()->LoadScriptMetadata(CScriptID(script), keyMeta);\n         } else if (strType == DBKeys::DEFAULTKEY) {\n             // We don't want or need the default key, but if there is one set,\n             // we want to make sure that it is valid so that we can detect corruption\n@@ -368,15 +369,15 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CKeyPool keypool;\n             ssValue >> keypool;\n \n-            pwallet->LoadKeyPool(nIndex, keypool);\n+            pwallet->GetLegacyScriptPubKeyMan()->LoadKeyPool(nIndex, keypool);\n         } else if (strType == DBKeys::CSCRIPT) {\n             uint160 hash;\n             ssKey >> hash;\n             CScript script;\n             ssValue >> script;\n-            if (!pwallet->LoadCScript(script))\n+            if (!pwallet->GetLegacyScriptPubKeyMan()->LoadCScript(script))\n             {\n-                strErr = \"Error reading wallet database: LoadCScript failed\";\n+                strErr = \"Error reading wallet database: LegacyScriptPubKeyMan::LoadCScript failed\";\n                 return false;\n             }\n         } else if (strType == DBKeys::ORDERPOSNEXT) {\n@@ -390,7 +391,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         } else if (strType == DBKeys::HDCHAIN) {\n             CHDChain chain;\n             ssValue >> chain;\n-            pwallet->SetHDChain(chain, true);\n+            pwallet->GetLegacyScriptPubKeyMan()->SetHDChain(chain, true);\n         } else if (strType == DBKeys::FLAGS) {\n             uint64_t flags;\n             ssValue >> flags;\n@@ -433,6 +434,7 @@ DBErrors WalletBatch::LoadWallet(CWallet* pwallet)\n     DBErrors result = DBErrors::LOAD_OK;\n \n     LOCK(pwallet->cs_wallet);\n+    AssertLockHeld(pwallet->GetLegacyScriptPubKeyMan()->cs_wallet);\n     try {\n         int nMinVersion = 0;\n         if (m_batch.Read(DBKeys::MINVERSION, nMinVersion)) {\n@@ -513,8 +515,12 @@ DBErrors WalletBatch::LoadWallet(CWallet* pwallet)\n            wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys, wss.m_unknown_records);\n \n     // nTimeFirstKey is only reliable if all keys have metadata\n-    if ((wss.nKeys + wss.nCKeys + wss.nWatchKeys) != wss.nKeyMeta)\n-        pwallet->UpdateTimeFirstKey(1);\n+    if ((wss.nKeys + wss.nCKeys + wss.nWatchKeys) != wss.nKeyMeta) {\n+        auto spk_man = pwallet->GetLegacyScriptPubKeyMan();\n+        if (spk_man) {\n+            spk_man->UpdateTimeFirstKey(1);\n+        }\n+    }\n \n     for (const uint256& hash : wss.vWalletUpgrade)\n         WriteTx(pwallet->mapWallet.at(hash));\n@@ -707,6 +713,7 @@ bool WalletBatch::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, C\n     {\n         // Required in LoadKeyMetadata():\n         LOCK(dummyWallet->cs_wallet);\n+        AssertLockHeld(dummyWallet->GetLegacyScriptPubKeyMan()->cs_wallet);\n         fReadOK = ReadKeyValue(dummyWallet, ssKey, ssValue,\n                                dummyWss, strType, strErr);\n     }"
      },
      {
        "sha": "a6f49536b7bc7acf17f3c0804f30d5ce2a5475c6",
        "filename": "src/wallet/wallettool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/wallettool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/src/wallet/wallettool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallettool.cpp?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -37,8 +37,9 @@ static std::shared_ptr<CWallet> CreateWallet(const std::string& name, const fs::\n     wallet_instance->SetMinVersion(FEATURE_HD_SPLIT);\n \n     // generate a new HD seed\n-    CPubKey seed = wallet_instance->GenerateNewSeed();\n-    wallet_instance->SetHDSeed(seed);\n+    auto spk_man = wallet_instance->GetLegacyScriptPubKeyMan();\n+    CPubKey seed = spk_man->GenerateNewSeed();\n+    spk_man->SetHDSeed(seed);\n \n     tfm::format(std::cout, \"Topping up keypool...\\n\");\n     wallet_instance->TopUpKeyPool();\n@@ -94,7 +95,7 @@ static void WalletShowInfo(CWallet* wallet_instance)\n \n     tfm::format(std::cout, \"Wallet info\\n===========\\n\");\n     tfm::format(std::cout, \"Encrypted: %s\\n\", wallet_instance->IsCrypted() ? \"yes\" : \"no\");\n-    tfm::format(std::cout, \"HD (hd seed available): %s\\n\", wallet_instance->GetHDChain().seed_id.IsNull() ? \"no\" : \"yes\");\n+    tfm::format(std::cout, \"HD (hd seed available): %s\\n\", wallet_instance->IsHDEnabled() ? \"yes\" : \"no\");\n     tfm::format(std::cout, \"Keypool Size: %u\\n\", wallet_instance->GetKeyPoolSize());\n     tfm::format(std::cout, \"Transactions: %zu\\n\", wallet_instance->mapWallet.size());\n     tfm::format(std::cout, \"Address Book: %zu\\n\", wallet_instance->mapAddressBook.size());"
      },
      {
        "sha": "ccd12b58234150f6592ad5703014aafda35d7f6b",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -30,7 +30,7 @@ EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"policy/fees -> txmempool -> validation -> policy/fees\"\n     \"qt/guiutil -> qt/walletmodel -> qt/optionsmodel -> qt/guiutil\"\n     \"txmempool -> validation -> validationinterface -> txmempool\"\n-    \"wallet/ismine -> wallet/wallet -> wallet/ismine\"\n+    \"wallet/scriptpubkeyman -> wallet/wallet -> wallet/scriptpubkeyman\"\n )\n \n EXIT_CODE=0"
      },
      {
        "sha": "99127e01f8088c81846f5792743224103c54d59f",
        "filename": "test/lint/lint-format-strings.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/test/lint/lint-format-strings.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/test/lint/lint-format-strings.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-format-strings.py?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -20,6 +20,9 @@\n     (\"src/wallet/wallet.h\",  \"WalletLogPrintf(std::string fmt, Params... parameters)\"),\n     (\"src/wallet/wallet.h\", \"LogPrintf((\\\"%s \\\" + fmt).c_str(), GetDisplayName(), parameters...)\"),\n     (\"src/logging.h\", \"LogPrintf(const char* fmt, const Args&... args)\"),\n+    (\"src/wallet/scriptpubkeyman.h\", \"WalletLogPrintf(const std::string& fmt, const Params&... parameters)\"),\n+    (\"src/wallet/scriptpubkeyman.cpp\", \"WalletLogPrintf(fmt, parameters...)\"),\n+    (\"src/wallet/scriptpubkeyman.cpp\", \"WalletLogPrintf(const std::string& fmt, const Params&... parameters)\"),\n ]\n \n "
      },
      {
        "sha": "72b6b2e9d55f4da315848ea84d440ff3f0e6a896",
        "filename": "test/lint/lint-logs.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/test/lint/lint-logs.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f201ba59ffd2e071a36a688b80d2cff9a9c44bb2/test/lint/lint-logs.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-logs.sh?ref=f201ba59ffd2e071a36a688b80d2cff9a9c44bb2",
        "patch": "@@ -15,6 +15,7 @@\n export LC_ALL=C\n UNTERMINATED_LOGS=$(git grep --extended-regexp \"LogPrintf?\\(\" -- \"*.cpp\" | \\\n     grep -v '\\\\n\"' | \\\n+    grep -v '\\.\\.\\.' | \\\n     grep -v \"/\\* Continued \\*/\" | \\\n     grep -v \"LogPrint()\" | \\\n     grep -v \"LogPrintf()\")"
      }
    ]
  }
]