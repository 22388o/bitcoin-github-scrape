[
  {
    "sha": "afd4b94b6dabab29dee5a12966ce217700381682",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZmQ0Yjk0YjZkYWJhYjI5ZGVlNWExMjk2NmNlMjE3NzAwMzgxNjgy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-10-30T22:50:15Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2014-12-05T09:57:40Z"
      },
      "message": "Move CMerkleBlock and CPartialMerkleTree to their own file",
      "tree": {
        "sha": "7bc8f939bfcc098341f8f222fe44e039fba3dd00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7bc8f939bfcc098341f8f222fe44e039fba3dd00"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afd4b94b6dabab29dee5a12966ce217700381682",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afd4b94b6dabab29dee5a12966ce217700381682",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/afd4b94b6dabab29dee5a12966ce217700381682",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afd4b94b6dabab29dee5a12966ce217700381682/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a0417b8cc840ff6f49b4fb1f8ceef54f8e3d0df1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0417b8cc840ff6f49b4fb1f8ceef54f8e3d0df1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a0417b8cc840ff6f49b4fb1f8ceef54f8e3d0df1"
      }
    ],
    "stats": {
      "total": 612,
      "additions": 318,
      "deletions": 294
    },
    "files": [
      {
        "sha": "d6ac6e1277627f464edd6e32d7f0780f2ab416c2",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -101,6 +101,7 @@ BITCOIN_CORE_H = \\\n   leveldbwrapper.h \\\n   limitedmap.h \\\n   main.h \\\n+  merkleblock.h \\\n   miner.h \\\n   mruset.h \\\n   netbase.h \\\n@@ -168,6 +169,7 @@ libbitcoin_server_a_SOURCES = \\\n   init.cpp \\\n   leveldbwrapper.cpp \\\n   main.cpp \\\n+  merkleblock.cpp \\\n   miner.cpp \\\n   net.cpp \\\n   noui.cpp \\"
      },
      {
        "sha": "ce66dfbe965cefc27545bf46bb68f05c20e75a36",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -4,15 +4,17 @@\n \n #include \"base58.h\"\n #include \"clientversion.h\"\n+#include \"primitives/block.h\" // for MAX_BLOCK_SIZE\n #include \"primitives/transaction.h\"\n #include \"core_io.h\"\n+#include \"coins.h\"\n #include \"keystore.h\"\n-#include \"main.h\" // for MAX_BLOCK_SIZE\n #include \"script/script.h\"\n #include \"script/sign.h\"\n #include \"ui_interface.h\" // for _(...)\n #include \"univalue/univalue.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n #include \"utilmoneystr.h\"\n \n #include <stdio.h>"
      },
      {
        "sha": "cea2925fe23704c8f4c83bf38ac28d406898309e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 153,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -11,6 +11,7 @@\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n #include \"init.h\"\n+#include \"merkleblock.h\"\n #include \"net.h\"\n #include \"pow.h\"\n #include \"txdb.h\"\n@@ -2720,159 +2721,6 @@ bool TestBlockValidity(CValidationState &state, const CBlock& block, CBlockIndex\n \n \n \n-CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n-{\n-    header = block.GetBlockHeader();\n-\n-    vector<bool> vMatch;\n-    vector<uint256> vHashes;\n-\n-    vMatch.reserve(block.vtx.size());\n-    vHashes.reserve(block.vtx.size());\n-\n-    for (unsigned int i = 0; i < block.vtx.size(); i++)\n-    {\n-        const uint256& hash = block.vtx[i].GetHash();\n-        if (filter.IsRelevantAndUpdate(block.vtx[i]))\n-        {\n-            vMatch.push_back(true);\n-            vMatchedTxn.push_back(make_pair(i, hash));\n-        }\n-        else\n-            vMatch.push_back(false);\n-        vHashes.push_back(hash);\n-    }\n-\n-    txn = CPartialMerkleTree(vHashes, vMatch);\n-}\n-\n-\n-\n-\n-\n-\n-\n-\n-uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid) {\n-    if (height == 0) {\n-        // hash at height 0 is the txids themself\n-        return vTxid[pos];\n-    } else {\n-        // calculate left hash\n-        uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n-        // calculate right hash if not beyond the end of the array - copy left hash otherwise1\n-        if (pos*2+1 < CalcTreeWidth(height-1))\n-            right = CalcHash(height-1, pos*2+1, vTxid);\n-        else\n-            right = left;\n-        // combine subhashes\n-        return Hash(BEGIN(left), END(left), BEGIN(right), END(right));\n-    }\n-}\n-\n-void CPartialMerkleTree::TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch) {\n-    // determine whether this node is the parent of at least one matched txid\n-    bool fParentOfMatch = false;\n-    for (unsigned int p = pos << height; p < (pos+1) << height && p < nTransactions; p++)\n-        fParentOfMatch |= vMatch[p];\n-    // store as flag bit\n-    vBits.push_back(fParentOfMatch);\n-    if (height==0 || !fParentOfMatch) {\n-        // if at height 0, or nothing interesting below, store hash and stop\n-        vHash.push_back(CalcHash(height, pos, vTxid));\n-    } else {\n-        // otherwise, don't store any hash, but descend into the subtrees\n-        TraverseAndBuild(height-1, pos*2, vTxid, vMatch);\n-        if (pos*2+1 < CalcTreeWidth(height-1))\n-            TraverseAndBuild(height-1, pos*2+1, vTxid, vMatch);\n-    }\n-}\n-\n-uint256 CPartialMerkleTree::TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch) {\n-    if (nBitsUsed >= vBits.size()) {\n-        // overflowed the bits array - failure\n-        fBad = true;\n-        return 0;\n-    }\n-    bool fParentOfMatch = vBits[nBitsUsed++];\n-    if (height==0 || !fParentOfMatch) {\n-        // if at height 0, or nothing interesting below, use stored hash and do not descend\n-        if (nHashUsed >= vHash.size()) {\n-            // overflowed the hash array - failure\n-            fBad = true;\n-            return 0;\n-        }\n-        const uint256 &hash = vHash[nHashUsed++];\n-        if (height==0 && fParentOfMatch) // in case of height 0, we have a matched txid\n-            vMatch.push_back(hash);\n-        return hash;\n-    } else {\n-        // otherwise, descend into the subtrees to extract matched txids and hashes\n-        uint256 left = TraverseAndExtract(height-1, pos*2, nBitsUsed, nHashUsed, vMatch), right;\n-        if (pos*2+1 < CalcTreeWidth(height-1))\n-            right = TraverseAndExtract(height-1, pos*2+1, nBitsUsed, nHashUsed, vMatch);\n-        else\n-            right = left;\n-        // and combine them before returning\n-        return Hash(BEGIN(left), END(left), BEGIN(right), END(right));\n-    }\n-}\n-\n-CPartialMerkleTree::CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch) : nTransactions(vTxid.size()), fBad(false) {\n-    // reset state\n-    vBits.clear();\n-    vHash.clear();\n-\n-    // calculate height of tree\n-    int nHeight = 0;\n-    while (CalcTreeWidth(nHeight) > 1)\n-        nHeight++;\n-\n-    // traverse the partial tree\n-    TraverseAndBuild(nHeight, 0, vTxid, vMatch);\n-}\n-\n-CPartialMerkleTree::CPartialMerkleTree() : nTransactions(0), fBad(true) {}\n-\n-uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n-    vMatch.clear();\n-    // An empty set will not work\n-    if (nTransactions == 0)\n-        return 0;\n-    // check for excessively high numbers of transactions\n-    if (nTransactions > MAX_BLOCK_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n-        return 0;\n-    // there can never be more hashes provided than one for every txid\n-    if (vHash.size() > nTransactions)\n-        return 0;\n-    // there must be at least one bit per node in the partial tree, and at least one node per hash\n-    if (vBits.size() < vHash.size())\n-        return 0;\n-    // calculate height of tree\n-    int nHeight = 0;\n-    while (CalcTreeWidth(nHeight) > 1)\n-        nHeight++;\n-    // traverse the partial tree\n-    unsigned int nBitsUsed = 0, nHashUsed = 0;\n-    uint256 hashMerkleRoot = TraverseAndExtract(nHeight, 0, nBitsUsed, nHashUsed, vMatch);\n-    // verify that no problems occured during the tree traversal\n-    if (fBad)\n-        return 0;\n-    // verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)\n-    if ((nBitsUsed+7)/8 != (vBits.size()+7)/8)\n-        return 0;\n-    // verify that all hashes were consumed\n-    if (nHashUsed != vHash.size())\n-        return 0;\n-    return hashMerkleRoot;\n-}\n-\n-\n-\n-\n-\n-\n-\n bool AbortNode(const std::string &strMessage, const std::string &userMessage) {\n     strMiscWarning = strMessage;\n     LogPrintf(\"*** %s\\n\", strMessage);"
      },
      {
        "sha": "dc833673aec2eeb9765ef0bf6d5a71bd2b6eb08f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 0,
        "deletions": 138,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -49,8 +49,6 @@ class CValidationState;\n struct CBlockTemplate;\n struct CNodeStateStats;\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n /** Default for -blockmaxsize and -blockminsize, which control the range of sizes the mining code will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n@@ -352,110 +350,6 @@ class CScriptCheck\n     }\n };\n \n-/** Data structure that represents a partial merkle tree.\n- *\n- * It represents a subset of the txid's of a known block, in a way that\n- * allows recovery of the list of txid's and the merkle root, in an\n- * authenticated way.\n- *\n- * The encoding works as follows: we traverse the tree in depth-first order,\n- * storing a bit for each traversed node, signifying whether the node is the\n- * parent of at least one matched leaf txid (or a matched txid itself). In\n- * case we are at the leaf level, or this bit is 0, its merkle node hash is\n- * stored, and its children are not explorer further. Otherwise, no hash is\n- * stored, but we recurse into both (or the only) child branch. During\n- * decoding, the same depth-first traversal is performed, consuming bits and\n- * hashes as they written during encoding.\n- *\n- * The serialization is fixed and provides a hard guarantee about the\n- * encoded size:\n- *\n- *   SIZE <= 10 + ceil(32.25*N)\n- *\n- * Where N represents the number of leaf nodes of the partial tree. N itself\n- * is bounded by:\n- *\n- *   N <= total_transactions\n- *   N <= 1 + matched_transactions*tree_height\n- *\n- * The serialization format:\n- *  - uint32     total_transactions (4 bytes)\n- *  - varint     number of hashes   (1-3 bytes)\n- *  - uint256[]  hashes in depth-first order (<= 32*N bytes)\n- *  - varint     number of bytes of flag bits (1-3 bytes)\n- *  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (<= 2*N-1 bits)\n- * The size constraints follow from this.\n- */\n-class CPartialMerkleTree\n-{\n-protected:\n-    /** the total number of transactions in the block */\n-    unsigned int nTransactions;\n-\n-    /** node-is-parent-of-matched-txid bits */\n-    std::vector<bool> vBits;\n-\n-    /** txids and internal hashes */\n-    std::vector<uint256> vHash;\n-\n-    /** flag set when encountering invalid data */\n-    bool fBad;\n-\n-    /** helper function to efficiently calculate the number of nodes at given height in the merkle tree */\n-    unsigned int CalcTreeWidth(int height) {\n-        return (nTransactions+(1 << height)-1) >> height;\n-    }\n-\n-    /** calculate the hash of a node in the merkle tree (at leaf level: the txid's themselves) */\n-    uint256 CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid);\n-\n-    /** recursive function that traverses tree nodes, storing the data as bits and hashes */\n-    void TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n-\n-    /**\n-     * recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.\n-     * it returns the hash of the respective node.\n-     */\n-    uint256 TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch);\n-\n-public:\n-\n-    /** serialization implementation */\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(nTransactions);\n-        READWRITE(vHash);\n-        std::vector<unsigned char> vBytes;\n-        if (ser_action.ForRead()) {\n-            READWRITE(vBytes);\n-            CPartialMerkleTree &us = *(const_cast<CPartialMerkleTree*>(this));\n-            us.vBits.resize(vBytes.size() * 8);\n-            for (unsigned int p = 0; p < us.vBits.size(); p++)\n-                us.vBits[p] = (vBytes[p / 8] & (1 << (p % 8))) != 0;\n-            us.fBad = false;\n-        } else {\n-            vBytes.resize((vBits.size()+7)/8);\n-            for (unsigned int p = 0; p < vBits.size(); p++)\n-                vBytes[p / 8] |= vBits[p] << (p % 8);\n-            READWRITE(vBytes);\n-        }\n-    }\n-\n-    /** Construct a partial merkle tree from a list of transaction id's, and a mask that selects a subset of them */\n-    CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n-\n-    CPartialMerkleTree();\n-\n-    /**\n-     * extract the matching txid's represented by this partial merkle tree.\n-     * returns the merkle root, or 0 in case of failure\n-     */\n-    uint256 ExtractMatches(std::vector<uint256> &vMatch);\n-};\n-\n-\n \n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos);\n@@ -646,38 +540,6 @@ struct CBlockTemplate\n \n \n \n-/** \n- * Used to relay blocks as header + vector<merkle branch>\n- * to filtered nodes.\n- */\n-class CMerkleBlock\n-{\n-public:\n-    /** Public only for unit testing */\n-    CBlockHeader header;\n-    CPartialMerkleTree txn;\n-\n-public:\n-    /** Public only for unit testing and relay testing (not relayed) */\n-    std::vector<std::pair<unsigned int, uint256> > vMatchedTxn;\n-\n-    /**\n-     * Create from a CBlock, filtering transactions according to filter\n-     * Note that this will call IsRelevantAndUpdate on the filter for each transaction,\n-     * thus the filter will likely be modified.\n-     */\n-    CMerkleBlock(const CBlock& block, CBloomFilter& filter);\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(header);\n-        READWRITE(txn);\n-    }\n-};\n-\n-\n class CValidationInterface {\n protected:\n     virtual void SyncTransaction(const CTransaction &tx, const CBlock *pblock) {};"
      },
      {
        "sha": "8618e355d74181e631112759224f79a1fd23468d",
        "filename": "src/merkleblock.cpp",
        "status": "added",
        "additions": 152,
        "deletions": 0,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"merkleblock.h\"\n+\n+#include \"hash.h\"\n+#include \"primitives/block.h\" // for MAX_BLOCK_SIZE\n+#include \"utilstrencodings.h\"\n+\n+using namespace std;\n+\n+CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n+{\n+    header = block.GetBlockHeader();\n+\n+    vector<bool> vMatch;\n+    vector<uint256> vHashes;\n+\n+    vMatch.reserve(block.vtx.size());\n+    vHashes.reserve(block.vtx.size());\n+\n+    for (unsigned int i = 0; i < block.vtx.size(); i++)\n+    {\n+        const uint256& hash = block.vtx[i].GetHash();\n+        if (filter.IsRelevantAndUpdate(block.vtx[i]))\n+        {\n+            vMatch.push_back(true);\n+            vMatchedTxn.push_back(make_pair(i, hash));\n+        }\n+        else\n+            vMatch.push_back(false);\n+        vHashes.push_back(hash);\n+    }\n+\n+    txn = CPartialMerkleTree(vHashes, vMatch);\n+}\n+\n+uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid) {\n+    if (height == 0) {\n+        // hash at height 0 is the txids themself\n+        return vTxid[pos];\n+    } else {\n+        // calculate left hash\n+        uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n+        // calculate right hash if not beyond the end of the array - copy left hash otherwise1\n+        if (pos*2+1 < CalcTreeWidth(height-1))\n+            right = CalcHash(height-1, pos*2+1, vTxid);\n+        else\n+            right = left;\n+        // combine subhashes\n+        return Hash(BEGIN(left), END(left), BEGIN(right), END(right));\n+    }\n+}\n+\n+void CPartialMerkleTree::TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch) {\n+    // determine whether this node is the parent of at least one matched txid\n+    bool fParentOfMatch = false;\n+    for (unsigned int p = pos << height; p < (pos+1) << height && p < nTransactions; p++)\n+        fParentOfMatch |= vMatch[p];\n+    // store as flag bit\n+    vBits.push_back(fParentOfMatch);\n+    if (height==0 || !fParentOfMatch) {\n+        // if at height 0, or nothing interesting below, store hash and stop\n+        vHash.push_back(CalcHash(height, pos, vTxid));\n+    } else {\n+        // otherwise, don't store any hash, but descend into the subtrees\n+        TraverseAndBuild(height-1, pos*2, vTxid, vMatch);\n+        if (pos*2+1 < CalcTreeWidth(height-1))\n+            TraverseAndBuild(height-1, pos*2+1, vTxid, vMatch);\n+    }\n+}\n+\n+uint256 CPartialMerkleTree::TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch) {\n+    if (nBitsUsed >= vBits.size()) {\n+        // overflowed the bits array - failure\n+        fBad = true;\n+        return 0;\n+    }\n+    bool fParentOfMatch = vBits[nBitsUsed++];\n+    if (height==0 || !fParentOfMatch) {\n+        // if at height 0, or nothing interesting below, use stored hash and do not descend\n+        if (nHashUsed >= vHash.size()) {\n+            // overflowed the hash array - failure\n+            fBad = true;\n+            return 0;\n+        }\n+        const uint256 &hash = vHash[nHashUsed++];\n+        if (height==0 && fParentOfMatch) // in case of height 0, we have a matched txid\n+            vMatch.push_back(hash);\n+        return hash;\n+    } else {\n+        // otherwise, descend into the subtrees to extract matched txids and hashes\n+        uint256 left = TraverseAndExtract(height-1, pos*2, nBitsUsed, nHashUsed, vMatch), right;\n+        if (pos*2+1 < CalcTreeWidth(height-1))\n+            right = TraverseAndExtract(height-1, pos*2+1, nBitsUsed, nHashUsed, vMatch);\n+        else\n+            right = left;\n+        // and combine them before returning\n+        return Hash(BEGIN(left), END(left), BEGIN(right), END(right));\n+    }\n+}\n+\n+CPartialMerkleTree::CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch) : nTransactions(vTxid.size()), fBad(false) {\n+    // reset state\n+    vBits.clear();\n+    vHash.clear();\n+\n+    // calculate height of tree\n+    int nHeight = 0;\n+    while (CalcTreeWidth(nHeight) > 1)\n+        nHeight++;\n+\n+    // traverse the partial tree\n+    TraverseAndBuild(nHeight, 0, vTxid, vMatch);\n+}\n+\n+CPartialMerkleTree::CPartialMerkleTree() : nTransactions(0), fBad(true) {}\n+\n+uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n+    vMatch.clear();\n+    // An empty set will not work\n+    if (nTransactions == 0)\n+        return 0;\n+    // check for excessively high numbers of transactions\n+    if (nTransactions > MAX_BLOCK_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n+        return 0;\n+    // there can never be more hashes provided than one for every txid\n+    if (vHash.size() > nTransactions)\n+        return 0;\n+    // there must be at least one bit per node in the partial tree, and at least one node per hash\n+    if (vBits.size() < vHash.size())\n+        return 0;\n+    // calculate height of tree\n+    int nHeight = 0;\n+    while (CalcTreeWidth(nHeight) > 1)\n+        nHeight++;\n+    // traverse the partial tree\n+    unsigned int nBitsUsed = 0, nHashUsed = 0;\n+    uint256 hashMerkleRoot = TraverseAndExtract(nHeight, 0, nBitsUsed, nHashUsed, vMatch);\n+    // verify that no problems occured during the tree traversal\n+    if (fBad)\n+        return 0;\n+    // verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)\n+    if ((nBitsUsed+7)/8 != (vBits.size()+7)/8)\n+        return 0;\n+    // verify that all hashes were consumed\n+    if (nHashUsed != vHash.size())\n+        return 0;\n+    return hashMerkleRoot;\n+}"
      },
      {
        "sha": "c549e3cdbab21c36c7dd03498b754701476cf056",
        "filename": "src/merkleblock.h",
        "status": "added",
        "additions": 151,
        "deletions": 0,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -0,0 +1,151 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MERKLEBLOCK_H\n+#define BITCOIN_MERKLEBLOCK_H\n+\n+#include \"serialize.h\"\n+#include \"uint256.h\"\n+#include \"primitives/block.h\"\n+#include \"bloom.h\"\n+\n+#include <vector>\n+\n+/** Data structure that represents a partial merkle tree.\n+ *\n+ * It represents a subset of the txid's of a known block, in a way that\n+ * allows recovery of the list of txid's and the merkle root, in an\n+ * authenticated way.\n+ *\n+ * The encoding works as follows: we traverse the tree in depth-first order,\n+ * storing a bit for each traversed node, signifying whether the node is the\n+ * parent of at least one matched leaf txid (or a matched txid itself). In\n+ * case we are at the leaf level, or this bit is 0, its merkle node hash is\n+ * stored, and its children are not explorer further. Otherwise, no hash is\n+ * stored, but we recurse into both (or the only) child branch. During\n+ * decoding, the same depth-first traversal is performed, consuming bits and\n+ * hashes as they written during encoding.\n+ *\n+ * The serialization is fixed and provides a hard guarantee about the\n+ * encoded size:\n+ *\n+ *   SIZE <= 10 + ceil(32.25*N)\n+ *\n+ * Where N represents the number of leaf nodes of the partial tree. N itself\n+ * is bounded by:\n+ *\n+ *   N <= total_transactions\n+ *   N <= 1 + matched_transactions*tree_height\n+ *\n+ * The serialization format:\n+ *  - uint32     total_transactions (4 bytes)\n+ *  - varint     number of hashes   (1-3 bytes)\n+ *  - uint256[]  hashes in depth-first order (<= 32*N bytes)\n+ *  - varint     number of bytes of flag bits (1-3 bytes)\n+ *  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (<= 2*N-1 bits)\n+ * The size constraints follow from this.\n+ */\n+class CPartialMerkleTree\n+{\n+protected:\n+    /** the total number of transactions in the block */\n+    unsigned int nTransactions;\n+\n+    /** node-is-parent-of-matched-txid bits */\n+    std::vector<bool> vBits;\n+\n+    /** txids and internal hashes */\n+    std::vector<uint256> vHash;\n+\n+    /** flag set when encountering invalid data */\n+    bool fBad;\n+\n+    /** helper function to efficiently calculate the number of nodes at given height in the merkle tree */\n+    unsigned int CalcTreeWidth(int height) {\n+        return (nTransactions+(1 << height)-1) >> height;\n+    }\n+\n+    /** calculate the hash of a node in the merkle tree (at leaf level: the txid's themselves) */\n+    uint256 CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid);\n+\n+    /** recursive function that traverses tree nodes, storing the data as bits and hashes */\n+    void TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n+\n+    /**\n+     * recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.\n+     * it returns the hash of the respective node.\n+     */\n+    uint256 TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch);\n+\n+public:\n+\n+    /** serialization implementation */\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(nTransactions);\n+        READWRITE(vHash);\n+        std::vector<unsigned char> vBytes;\n+        if (ser_action.ForRead()) {\n+            READWRITE(vBytes);\n+            CPartialMerkleTree &us = *(const_cast<CPartialMerkleTree*>(this));\n+            us.vBits.resize(vBytes.size() * 8);\n+            for (unsigned int p = 0; p < us.vBits.size(); p++)\n+                us.vBits[p] = (vBytes[p / 8] & (1 << (p % 8))) != 0;\n+            us.fBad = false;\n+        } else {\n+            vBytes.resize((vBits.size()+7)/8);\n+            for (unsigned int p = 0; p < vBits.size(); p++)\n+                vBytes[p / 8] |= vBits[p] << (p % 8);\n+            READWRITE(vBytes);\n+        }\n+    }\n+\n+    /** Construct a partial merkle tree from a list of transaction id's, and a mask that selects a subset of them */\n+    CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n+\n+    CPartialMerkleTree();\n+\n+    /**\n+     * extract the matching txid's represented by this partial merkle tree.\n+     * returns the merkle root, or 0 in case of failure\n+     */\n+    uint256 ExtractMatches(std::vector<uint256> &vMatch);\n+};\n+\n+\n+/**\n+ * Used to relay blocks as header + vector<merkle branch>\n+ * to filtered nodes.\n+ */\n+class CMerkleBlock\n+{\n+public:\n+    /** Public only for unit testing */\n+    CBlockHeader header;\n+    CPartialMerkleTree txn;\n+\n+public:\n+    /** Public only for unit testing and relay testing (not relayed) */\n+    std::vector<std::pair<unsigned int, uint256> > vMatchedTxn;\n+\n+    /**\n+     * Create from a CBlock, filtering transactions according to filter\n+     * Note that this will call IsRelevantAndUpdate on the filter for each transaction,\n+     * thus the filter will likely be modified.\n+     */\n+    CMerkleBlock(const CBlock& block, CBloomFilter& filter);\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(header);\n+        READWRITE(txn);\n+    }\n+};\n+\n+#endif // BITCOIN_MERKLEBLOCK_H"
      },
      {
        "sha": "a1895925395f3c209f8abd9a29761e4e4af439b4",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -10,6 +10,9 @@\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n+/** The maximum allowed size for a serialized block, in bytes (network rule) */\n+static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block"
      },
      {
        "sha": "2de226fdd653524f7b40400e1b762d21817625bd",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -7,10 +7,12 @@\n #include \"base58.h\"\n #include \"clientversion.h\"\n #include \"key.h\"\n-#include \"main.h\"\n+#include \"merkleblock.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n \n #include <vector>\n "
      },
      {
        "sha": "3b535a84fd8001960882ef000814bed778a01f7a",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afd4b94b6dabab29dee5a12966ce217700381682/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afd4b94b6dabab29dee5a12966ce217700381682/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=afd4b94b6dabab29dee5a12966ce217700381682",
        "patch": "@@ -2,9 +2,11 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"main.h\"\n+#include \"merkleblock.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"uint256.h\"\n+#include \"version.h\"\n \n #include <vector>\n "
      }
    ]
  }
]