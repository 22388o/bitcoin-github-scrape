[
  {
    "sha": "6112a209828c43930f677c45461339cdf68a56e9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTEyYTIwOTgyOGM0MzkzMGY2NzdjNDU0NjEzMzljZGY2OGE1NmU5",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2020-04-01T13:37:20Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2020-04-01T15:30:02Z"
      },
      "message": "test: replace (send_message + sync_with_ping) with send_and_ping",
      "tree": {
        "sha": "137ce782cfbfe549a555e0fb8de171a9fd01321a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/137ce782cfbfe549a555e0fb8de171a9fd01321a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6112a209828c43930f677c45461339cdf68a56e9",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAl6Es38ACgkQT1chs9Dj\nkh37zBAAgtfoyOoVHi4+VYy1tc1MlEllFhswwZt+OnP/hn5LkO84KgYKxdd+Qte7\na72Y3peA0+ql1R65DwPKTizZkKRq4IHiGD6mIBdfL4pUXFa4hLsOKG0Elkw6hHHL\niSjJPPkad/WW3VryHZYlQHXh9pu7ucFjImdRRk031JXdHxklS8WWuo41YovKlb2b\n818fowrMDND0OQpklOvZkX4C/23A0UJDD5cpEGseS6Ui9Pb6FYOx8AjytuTbZQo9\nMIXZe/eMlLE06kMSJfjmKr9+Rvn4StiCvowu4W+fRoHle6ENZJbnk9KNM+ltsKfx\ndk88mAtszezL/DHd21tCOvfsilnJ3RHk8+BuxWQezmHVOLHLXRiBbL38RhiyusvU\nC+L+/u76+TVSuwvlMTjK5VOXtCi3Hsp8Fb2E7S4Tv56a4Q8iKhZDP5JylMcEaR9N\nllYz7nVHgU6I9mZtXQH5h4DWMRJPPxbUO5guNNeAmheCU5Ivmk4O5cYCyKLJ+uwq\nWsgYjQyCTXrs9KUDfT5ge6IWoLWk67oUUPGCdO38UXHSbL8FDakfT/UpggmfXuT/\nXwVKr7hRKCupKiKbvIBcxUrwRnuCF5EGcpudKhxv3ezZzpjs9E96RbvoD7SgeH1f\nM4Xv7OdkiTy62IzO/9r/6wBfi6ArMmDEfZ0mlIU1Sp/3OGupTQU=\n=hhHE\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIGkA6qBPjp0lGTAV8f2xhnEsKqVr/N7cdg6BDUqApnR7CP/wEFBJ6Mg9QCpL\nL6wG5RxbStwI8CCoBqZGdTnCBk+nVFmg/pXzcUVsneZgRtgXfdG/m2rj9wjxBF6E\ns4DwCPezG38I5yMAAIPf4w0u+QyOLCtodHRwczovL2JvYi5idGMuY2FsZW5kYXIu\nb3BlbnRpbWVzdGFtcHMub3Jn//AQej1rM7nTTnPeljheJLpS1gjxBF6Es4DwCEpZ\nSUwA+0SAAIPf4w0u+QyOKShodHRwczovL2Zpbm5leS5jYWxlbmRhci5ldGVybml0\neXdhbGwuY29t//AQm111g9bbC5qVsPvOuMF7bwjwIEeGPVYdxRLCrSPpc40dD0Qb\n6hFpZcNkbvPAugQdNBkgCPEEXoSzgPAIRRxWLBdrHbgAg9/jDS75DI4uLWh0dHBz\nOi8vYWxpY2UuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ/AQveo8ORfV\nJE+AcLURdl4K1AjxBF6Es4HwCLSLgZyAkJUjAIPf4w0u+QyOIyJodHRwczovL2J0\nYy5jYWxlbmRhci5jYXRhbGxheHkuY29t\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 137ce782cfbfe549a555e0fb8de171a9fd01321a\nparent b97e3a73498bb49e81039e90e9cb5acdca9123cc\nauthor Jon Atack <jon@atack.com> 1585748240 +0200\ncommitter Jon Atack <jon@atack.com> 1585755002 +0200\n\ntest: replace (send_message + sync_with_ping) with send_and_ping\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6112a209828c43930f677c45461339cdf68a56e9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6112a209828c43930f677c45461339cdf68a56e9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6112a209828c43930f677c45461339cdf68a56e9/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b97e3a73498bb49e81039e90e9cb5acdca9123cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b97e3a73498bb49e81039e90e9cb5acdca9123cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b97e3a73498bb49e81039e90e9cb5acdca9123cc"
      }
    ],
    "stats": {
      "total": 83,
      "additions": 27,
      "deletions": 56
    },
    "files": [
      {
        "sha": "dc00e03fe76efa9b61b60f0bd8e94120905e48fe",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -94,8 +94,7 @@ def run_test(self):\n         # 576MB will be reserved for relaying new blocks, so expect this to\n         # succeed for ~235 tries.\n         for i in range(success_count):\n-            p2p_conns[0].send_message(getdata_request)\n-            p2p_conns[0].sync_with_ping()\n+            p2p_conns[0].send_and_ping(getdata_request)\n             assert_equal(p2p_conns[0].block_receive_map[big_old_block], i+1)\n \n         assert_equal(len(self.nodes[0].getpeerinfo()), 3)\n@@ -112,8 +111,7 @@ def run_test(self):\n         # We'll try 800 times\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(800):\n-            p2p_conns[1].send_message(getdata_request)\n-            p2p_conns[1].sync_with_ping()\n+            p2p_conns[1].send_and_ping(getdata_request)\n             assert_equal(p2p_conns[1].block_receive_map[big_new_block], i+1)\n \n         self.log.info(\"Peer 1 able to repeatedly download new block\")\n@@ -132,8 +130,7 @@ def run_test(self):\n         # and p2p_conns[2] should be able to retrieve the old block.\n         self.nodes[0].setmocktime(int(time.time()))\n         p2p_conns[2].sync_with_ping()\n-        p2p_conns[2].send_message(getdata_request)\n-        p2p_conns[2].sync_with_ping()\n+        p2p_conns[2].send_and_ping(getdata_request)\n         assert_equal(p2p_conns[2].block_receive_map[big_old_block], 1)\n \n         self.log.info(\"Peer 2 able to download old block\")\n@@ -150,8 +147,7 @@ def run_test(self):\n         #retrieve 20 blocks which should be enough to break the 1MB limit\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(20):\n-            self.nodes[0].p2p.send_message(getdata_request)\n-            self.nodes[0].p2p.sync_with_ping()\n+            self.nodes[0].p2p.send_and_ping(getdata_request)\n             assert_equal(self.nodes[0].p2p.block_receive_map[big_new_block], i+1)\n \n         getdata_request.inv = [CInv(2, big_old_block)]"
      },
      {
        "sha": "2940542e5ebdcdb12385ddcf954a482625d0a63e",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -64,8 +64,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         self.log.info('Add filtered P2P connection to the node')\n         filter_node = self.nodes[0].add_p2p_connection(FilterNode())\n-        filter_node.send_message(filter_node.watch_filter_init)\n-        filter_node.sync_with_ping()\n+        filter_node.send_and_ping(filter_node.watch_filter_init)\n         filter_address = self.nodes[0].decodescript(filter_node.watch_script_pubkey)['addresses'][0]\n \n         self.log.info('Check that we receive merkleblock and tx if the filter matches a tx in a block')\n@@ -99,8 +98,7 @@ def run_test(self):\n         assert not filter_node.merkleblock_received\n \n         self.log.info('Check that after deleting filter all txs get relayed again')\n-        filter_node.send_message(msg_filterclear())\n-        filter_node.sync_with_ping()\n+        filter_node.send_and_ping(msg_filterclear())\n         for _ in range(5):\n             txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 7)\n             filter_node.wait_for_tx(txid)"
      },
      {
        "sha": "c6fcc5e2001dd6c459f86a964d878c06b0665d75",
        "filename": "test/functional/p2p_leak_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_leak_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_leak_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak_tx.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -39,8 +39,7 @@ def run_test(self):\n             want_tx = msg_getdata()\n             want_tx.inv.append(CInv(t=1, h=int(txid, 16)))\n             inbound_peer.last_message.pop('notfound', None)\n-            inbound_peer.send_message(want_tx)\n-            inbound_peer.sync_with_ping()\n+            inbound_peer.send_and_ping(want_tx)\n \n             if inbound_peer.last_message.get('notfound'):\n                 self.log.debug('tx {} was not yet announced to us.'.format(txid))"
      },
      {
        "sha": "118f31382ac051d25fb2ab5fdaf093839cce56b5",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -303,8 +303,7 @@ def test_non_witness_transaction(self):\n \n         block = self.build_next_block(version=1)\n         block.solve()\n-        self.test_node.send_message(msg_no_witness_block(block))\n-        self.test_node.sync_with_ping()  # make sure the block was processed\n+        self.test_node.send_and_ping(msg_no_witness_block(block))  # make sure the block was processed\n         txid = block.vtx[0].sha256\n \n         self.nodes[0].generate(99)  # let the block mature\n@@ -319,8 +318,7 @@ def test_non_witness_transaction(self):\n         # This is a sanity check of our testing framework.\n         assert_equal(msg_no_witness_tx(tx).serialize(), msg_tx(tx).serialize())\n \n-        self.test_node.send_message(msg_tx(tx))\n-        self.test_node.sync_with_ping()  # make sure the tx was processed\n+        self.test_node.send_and_ping(msg_tx(tx))  # make sure the block was processed\n         assert tx.hash in self.nodes[0].getrawmempool()\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n@@ -350,8 +348,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n-        self.test_node.send_message(msg_no_witness_block(block))\n-        self.test_node.sync_with_ping()\n+        self.test_node.send_and_ping(msg_no_witness_block(block))  # make sure the block was processed\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         # Update our utxo list; we spent the first entry.\n@@ -2054,16 +2051,14 @@ def serialize(self):\n         tx = FromHex(CTransaction(), raw)\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, serialize_with_bogus_witness(tx).hex())\n         with self.nodes[0].assert_debug_log(['Superfluous witness record']):\n-            self.nodes[0].p2p.send_message(msg_bogus_tx(tx))\n-            self.nodes[0].p2p.sync_with_ping()\n+            self.nodes[0].p2p.send_and_ping(msg_bogus_tx(tx))\n         raw = self.nodes[0].signrawtransactionwithwallet(raw)\n         assert raw['complete']\n         raw = raw['hex']\n         tx = FromHex(CTransaction(), raw)\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, serialize_with_bogus_witness(tx).hex())\n         with self.nodes[0].assert_debug_log(['Unknown transaction optional data']):\n-            self.nodes[0].p2p.send_message(msg_bogus_tx(tx))\n-            self.nodes[0].p2p.sync_with_ping()\n+            self.nodes[0].p2p.send_and_ping(msg_bogus_tx(tx))\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "e543e647f287e569a8eccbc5e57580dceedb7bbe",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -307,8 +307,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 new_block.solve()\n                 test_node.send_header_for_blocks([new_block])\n                 test_node.wait_for_getdata([new_block.sha256])\n-                test_node.send_message(msg_block(new_block))\n-                test_node.sync_with_ping()  # make sure this block is processed\n+                test_node.send_and_ping(msg_block(new_block))  # make sure this block is processed\n                 wait_until(lambda: inv_node.block_announced, timeout=60, lock=mininode_lock)\n                 inv_node.clear_block_announcements()\n                 test_node.clear_block_announcements()"
      },
      {
        "sha": "b56dc994e7842c31ae20ffe29e853c86d60b70c1",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -65,8 +65,7 @@ def test_tx_requests(self):\n         self.log.info(\"Announce the txid from each incoming peer to node 0\")\n         msg = msg_inv([CInv(t=1, h=txid)])\n         for p in self.nodes[0].p2ps:\n-            p.send_message(msg)\n-            p.sync_with_ping()\n+            p.send_and_ping(msg)\n \n         outstanding_peer_index = [i for i in range(len(self.nodes[0].p2ps))]\n \n@@ -107,8 +106,7 @@ def test_inv_block(self):\n             \"Announce the transaction to all nodes from all {} incoming peers, but never send it\".format(NUM_INBOUND))\n         msg = msg_inv([CInv(t=1, h=txid)])\n         for p in self.peers:\n-            p.send_message(msg)\n-            p.sync_with_ping()\n+            p.send_and_ping(msg)\n \n         self.log.info(\"Put the tx in node 0's mempool\")\n         self.nodes[0].sendrawtransaction(tx)"
      },
      {
        "sha": "d18d4b069aa9ed994f4642b89253af6e4d902d48",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 11,
        "deletions": 24,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -97,11 +97,9 @@ def run_test(self):\n             blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))\n             blocks_h2[i].solve()\n             block_time += 1\n-        test_node.send_message(msg_block(blocks_h2[0]))\n-        min_work_node.send_message(msg_block(blocks_h2[1]))\n+        test_node.send_and_ping(msg_block(blocks_h2[0]))\n+        min_work_node.send_and_ping(msg_block(blocks_h2[1]))\n \n-        for x in [test_node, min_work_node]:\n-            x.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         assert_equal(self.nodes[1].getblockcount(), 1)\n         self.log.info(\"First height 2 block accepted by node0; correctly rejected by node1\")\n@@ -110,9 +108,8 @@ def run_test(self):\n         block_h1f = create_block(int(\"0x\" + self.nodes[0].getblockhash(0), 0), create_coinbase(1), block_time)\n         block_time += 1\n         block_h1f.solve()\n-        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_and_ping(msg_block(block_h1f))\n \n-        test_node.sync_with_ping()\n         tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n             if x['hash'] == block_h1f.hash:\n@@ -125,9 +122,8 @@ def run_test(self):\n         block_h2f = create_block(block_h1f.sha256, create_coinbase(2), block_time)\n         block_time += 1\n         block_h2f.solve()\n-        test_node.send_message(msg_block(block_h2f))\n+        test_node.send_and_ping(msg_block(block_h2f))\n \n-        test_node.sync_with_ping()\n         # Since the earlier block was not processed by node, the new block\n         # can't be fully validated.\n         tip_entry_found = False\n@@ -144,9 +140,8 @@ def run_test(self):\n         # 4b. Now send another block that builds on the forking chain.\n         block_h3 = create_block(block_h2f.sha256, create_coinbase(3), block_h2f.nTime+1)\n         block_h3.solve()\n-        test_node.send_message(msg_block(block_h3))\n+        test_node.send_and_ping(msg_block(block_h3))\n \n-        test_node.sync_with_ping()\n         # Since the earlier block was not processed by node, the new block\n         # can't be fully validated.\n         tip_entry_found = False\n@@ -172,17 +167,15 @@ def run_test(self):\n             tip = next_block\n \n         # Now send the block at height 5 and check that it wasn't accepted (missing header)\n-        test_node.send_message(msg_block(all_blocks[1]))\n-        test_node.sync_with_ping()\n+        test_node.send_and_ping(msg_block(all_blocks[1]))\n         assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblock, all_blocks[1].hash)\n         assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblockheader, all_blocks[1].hash)\n \n         # The block at height 5 should be accepted if we provide the missing header, though\n         headers_message = msg_headers()\n         headers_message.headers.append(CBlockHeader(all_blocks[0]))\n         test_node.send_message(headers_message)\n-        test_node.send_message(msg_block(all_blocks[1]))\n-        test_node.sync_with_ping()\n+        test_node.send_and_ping(msg_block(all_blocks[1]))\n         self.nodes[0].getblock(all_blocks[1].hash)\n \n         # Now send the blocks in all_blocks\n@@ -207,9 +200,7 @@ def run_test(self):\n \n         test_node = self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        test_node.send_message(msg_block(block_h1f))\n-\n-        test_node.sync_with_ping()\n+        test_node.send_and_ping(msg_block(block_h1f))\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         self.log.info(\"Unrequested block that would complete more-work chain was ignored\")\n \n@@ -230,9 +221,7 @@ def run_test(self):\n         self.log.info(\"Inv at tip triggered getdata for unprocessed block\")\n \n         # 7. Send the missing block for the third time (now it is requested)\n-        test_node.send_message(msg_block(block_h1f))\n-\n-        test_node.sync_with_ping()\n+        test_node.send_and_ping(msg_block(block_h1f))\n         assert_equal(self.nodes[0].getblockcount(), 290)\n         self.nodes[0].getblock(all_blocks[286].hash)\n         assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n@@ -259,9 +248,8 @@ def run_test(self):\n         headers_message.headers.append(CBlockHeader(block_290f))\n         headers_message.headers.append(CBlockHeader(block_291))\n         headers_message.headers.append(CBlockHeader(block_292))\n-        test_node.send_message(headers_message)\n+        test_node.send_and_ping(headers_message)\n \n-        test_node.sync_with_ping()\n         tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n             if x['hash'] == block_292.hash:\n@@ -271,9 +259,8 @@ def run_test(self):\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_292.hash)\n \n         test_node.send_message(msg_block(block_289f))\n-        test_node.send_message(msg_block(block_290f))\n+        test_node.send_and_ping(msg_block(block_290f))\n \n-        test_node.sync_with_ping()\n         self.nodes[0].getblock(block_289f.hash)\n         self.nodes[0].getblock(block_290f.hash)\n "
      },
      {
        "sha": "a6eaaa4539d7baadead11ed64efb581f9c5148ff",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6112a209828c43930f677c45461339cdf68a56e9/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6112a209828c43930f677c45461339cdf68a56e9/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=6112a209828c43930f677c45461339cdf68a56e9",
        "patch": "@@ -315,8 +315,7 @@ def _test_waitforblockheight(self):\n         def solve_and_send_block(prevhash, height, time):\n             b = create_block(prevhash, create_coinbase(height), time)\n             b.solve()\n-            node.p2p.send_message(msg_block(b))\n-            node.p2p.sync_with_ping()\n+            node.p2p.send_and_ping(msg_block(b))\n             return b\n \n         b21f = solve_and_send_block(int(b20hash, 16), 21, b20['time'] + 1)"
      }
    ]
  }
]