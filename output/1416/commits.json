[
  {
    "sha": "9b0369c773c1d350a05435d8d3ec4e954828fb82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YjAzNjljNzczYzFkMzUwYTA1NDM1ZDhkM2VjNGU5NTQ4MjhmYjgy",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-02-27T12:19:32Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-06-04T16:36:34Z"
      },
      "message": "Refactor SelectCoinsMinConf() and add unit tests.\n\nAvailableCoins() makes a vector of available outputs which is then passed to SelectCoinsMinConf().  This allows unit tests to test the coin selection algorithm without having the whole blockchain available.",
      "tree": {
        "sha": "43b695e7dd82200c0bcd407b40613ee4501ac2eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/43b695e7dd82200c0bcd407b40613ee4501ac2eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b0369c773c1d350a05435d8d3ec4e954828fb82",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0369c773c1d350a05435d8d3ec4e954828fb82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b0369c773c1d350a05435d8d3ec4e954828fb82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0369c773c1d350a05435d8d3ec4e954828fb82/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "882ba0e7524b54be861b379366b5845a3978b256",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/882ba0e7524b54be861b379366b5845a3978b256",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/882ba0e7524b54be861b379366b5845a3978b256"
      }
    ],
    "stats": {
      "total": 391,
      "additions": 343,
      "deletions": 48
    },
    "files": [
      {
        "sha": "705609464aaea184ca864efdb816117cf10aa676",
        "filename": "src/test/wallet_tests.cpp",
        "status": "added",
        "additions": 256,
        "deletions": 0,
        "changes": 256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0369c773c1d350a05435d8d3ec4e954828fb82/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0369c773c1d350a05435d8d3ec4e954828fb82/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=9b0369c773c1d350a05435d8d3ec4e954828fb82",
        "patch": "@@ -0,0 +1,256 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"main.h\"\n+#include \"wallet.h\"\n+\n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// enables tests which currently fail, due to code which tries too hard to avoid sub-cent change\n+// #define STRICT\n+\n+using namespace std;\n+\n+BOOST_AUTO_TEST_SUITE(wallet_tests)\n+\n+static CWallet wallet;\n+static vector<COutput> vCoins;\n+\n+static void add_coin(int64 nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    static int i;\n+    CTransaction* tx = new CTransaction;\n+    tx->nLockTime = i++;        // so all transactions get different hashes\n+    tx->vout.resize(nInput+1);\n+    tx->vout[nInput].nValue = nValue;\n+    CWalletTx* wtx = new CWalletTx(&wallet, *tx);\n+    delete tx;\n+    if (fIsFromMe)\n+    {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        wtx->vin.resize(1);\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx, nInput, nAge);\n+    vCoins.push_back(output);\n+}\n+\n+static void empty_wallet(void)\n+{\n+    BOOST_FOREACH(COutput output, vCoins)\n+        delete output.tx;\n+    vCoins.clear();\n+}\n+\n+BOOST_AUTO_TEST_CASE(coin_selection_tests)\n+{\n+    static set<pair<const CWalletTx*,unsigned int> > setCoinsRet;\n+    static int64 nValueRet;\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 1 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf( 3 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+\n+        // we can make 3 cents of new  coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 3 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(38 * CENT, 6, 6, vCoins, setCoinsRet, nValueRet));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(37 * CENT, 1, 6, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(38 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(34 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_GT(nValueRet, 34 * CENT);         // but should get more than 34 cents\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  I'd hope to see just 2+5, but 1 gets included too\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+#else\n+        BOOST_CHECK(nValueRet == 7 * CENT || nValueRet == 8 * CENT);\n+        BOOST_CHECK(setCoinsRet.size() == 2 || setCoinsRet.size() == 3);\n+#endif\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( wallet.SelectCoinsMinConf( 9 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // now clear out the wallet and start again to test chosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(71 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!wallet.SelectCoinsMinConf(72 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(16 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we hope for 5+6 but get 5+7 due to fear of sub-cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+#else\n+        BOOST_CHECK(nValueRet == 11 * CENT || nValueRet == 12 * CENT);\n+#endif\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(95 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 bitcoin in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(195 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 bitcoins in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test sub-cent change avoidance\n+        empty_wallet();\n+        add_coin(0.1*CENT);\n+        add_coin(0.2*CENT);\n+        add_coin(0.3*CENT);\n+        add_coin(0.4*CENT);\n+        add_coin(0.5*CENT);\n+\n+        // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 = 1.5 cents\n+        // we'll get sub-cent change whatever happens, so can expect 1.0 exactly\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        // but if we add a bigger coin, making it possible to avoid sub-cent change, things change:\n+        add_coin(1111*CENT);\n+\n+        // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5 cents\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+#else\n+        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 1111 * CENT); // but get a single 1111 cent coin\n+#endif\n+\n+        // if we add more sub-cent coins:\n+        add_coin(0.6*CENT);\n+        add_coin(0.7*CENT);\n+\n+        // and try again to make 1.0 cents, the new coins will be used to make 2.0 cents - leaving 1.0 cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+#else\n+        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 2 * CENT); // but get a bunch of sub-cent coins totalling 2 cents\n+        BOOST_CHECK_GE(setCoinsRet.size(), 4); // 0.7 + 0.6 + 0.5 + 0.2 = 2.0 for example\n+#endif\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int i = 0; i < 20; i++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10); // in ten coins\n+#else\n+        BOOST_CHECK(nValueRet == 500000 * COIN || nValueRet == 550000 * COIN); // but get 50k too much\n+        BOOST_CHECK(setCoinsRet.size() == 10 || setCoinsRet.size() == 11); // in 11 coins\n+#endif\n+\n+        // if there's not enough in the smaller coins to make at least 1 cent change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(0.5 * CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.7 * CENT);\n+        add_coin(1111 * CENT);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(0.4 * CENT);\n+        add_coin(0.6 * CENT);\n+        add_coin(0.8 * CENT);\n+        add_coin(1111 * CENT);\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n+#ifdef STRICT\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2); // in two coins 0.4+0.6\n+#else\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // but since value of smaller coins < target+cent, we get the bigger coin again\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n+#endif\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "f7e931dbbb4dabb07859a12d9fb4a1de2ecb2dd7",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 47,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0369c773c1d350a05435d8d3ec4e954828fb82/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0369c773c1d350a05435d8d3ec4e954828fb82/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=9b0369c773c1d350a05435d8d3ec4e954828fb82",
        "patch": "@@ -889,7 +889,32 @@ int64 CWallet::GetImmatureBalance() const\n     return nTotal;\n }\n \n-bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n+// populate vCoins with vector of spendable (age, (value, (transaction, output_number))) outputs\n+void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n+{\n+    vCoins.clear();\n+\n+    {\n+        LOCK(cs_wallet);\n+        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            const CWalletTx* pcoin = &(*it).second;\n+\n+            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+                continue;\n+\n+            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+                continue;\n+\n+            for (int i = 0; i < pcoin->vout.size(); i++)\n+                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue > 0)\n+                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n+        }\n+    }\n+}\n+\n+bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n+                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -901,54 +926,32 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n     vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n     int64 nTotalLower = 0;\n \n+    BOOST_FOREACH(COutput output, vCoins)\n     {\n-       LOCK(cs_wallet);\n-       vector<const CWalletTx*> vCoins;\n-       vCoins.reserve(mapWallet.size());\n-       for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n-           vCoins.push_back(&(*it).second);\n-       random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n-\n-       BOOST_FOREACH(const CWalletTx* pcoin, vCoins)\n-       {\n-            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n-                continue;\n-\n-            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n-                continue;\n+        const CWalletTx *pcoin = output.tx;\n \n-            int nDepth = pcoin->GetDepthInMainChain();\n-            if (nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n-                continue;\n-\n-            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n-            {\n-                if (pcoin->IsSpent(i) || !IsMine(pcoin->vout[i]))\n-                    continue;\n-\n-                int64 n = pcoin->vout[i].nValue;\n+        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n+            continue;\n \n-                if (n <= 0)\n-                    continue;\n+        int i = output.i;\n+        int64 n = pcoin->vout[i].nValue;\n \n-                pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin,i));\n+        pair<int64,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n \n-                if (n == nTargetValue)\n-                {\n-                    setCoinsRet.insert(coin.second);\n-                    nValueRet += coin.first;\n-                    return true;\n-                }\n-                else if (n < nTargetValue + CENT)\n-                {\n-                    vValue.push_back(coin);\n-                    nTotalLower += n;\n-                }\n-                else if (n < coinLowestLarger.first)\n-                {\n-                    coinLowestLarger = coin;\n-                }\n-            }\n+        if (n == nTargetValue)\n+        {\n+            setCoinsRet.insert(coin.second);\n+            nValueRet += coin.first;\n+            return true;\n+        }\n+        else if (n < nTargetValue + CENT)\n+        {\n+            vValue.push_back(coin);\n+            nTotalLower += n;\n+        }\n+        else if (n < coinLowestLarger.first)\n+        {\n+            coinLowestLarger = coin;\n         }\n     }\n \n@@ -1023,22 +1026,27 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n                 nValueRet += vValue[i].first;\n             }\n \n+#ifdef DEBUG\n         //// debug print\n         printf(\"SelectCoins() best subset: \");\n         for (unsigned int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n                 printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n         printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n+#endif\n     }\n \n     return true;\n }\n \n bool CWallet::SelectCoins(int64 nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n-    return (SelectCoinsMinConf(nTargetValue, 1, 6, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 1, 1, setCoinsRet, nValueRet) ||\n-            SelectCoinsMinConf(nTargetValue, 0, 1, setCoinsRet, nValueRet));\n+    vector<COutput> vCoins;\n+    AvailableCoins(vCoins);\n+\n+    return (SelectCoinsMinConf(nTargetValue, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n+            SelectCoinsMinConf(nTargetValue, 0, 1, vCoins, setCoinsRet, nValueRet));\n }\n \n "
      },
      {
        "sha": "b2e0e5260eb142cb4c4ac3a66690b9afa589afd3",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0369c773c1d350a05435d8d3ec4e954828fb82/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0369c773c1d350a05435d8d3ec4e954828fb82/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=9b0369c773c1d350a05435d8d3ec4e954828fb82",
        "patch": "@@ -14,6 +14,7 @@\n class CWalletTx;\n class CReserveKey;\n class CWalletDB;\n+class COutput;\n \n /** (client) version numbers for particular wallet features */\n enum WalletFeature\n@@ -60,7 +61,7 @@ class CKeyPool\n class CWallet : public CCryptoKeyStore\n {\n private:\n-    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins) const;\n     bool SelectCoins(int64 nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n     CWalletDB *pwalletdbEncryption;\n@@ -112,6 +113,8 @@ class CWallet : public CCryptoKeyStore\n     // check whether we are allowed to upgrade (or already support) to the named feature\n     bool CanSupportFeature(enum WalletFeature wf) { return nWalletMaxVersion >= wf; }\n \n+    bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n+\n     // keystore implementation\n     // Generate a new key\n     CPubKey GenerateNewKey();\n@@ -602,6 +605,34 @@ class CWalletTx : public CMerkleTx\n };\n \n \n+\n+\n+class COutput\n+{\n+public:\n+    const CWalletTx *tx;\n+    int i;\n+    int nDepth;\n+\n+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn;\n+    }\n+\n+    std::string ToString() const\n+    {\n+        return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n+    }\n+\n+    void print() const\n+    {\n+        printf(\"%s\\n\", ToString().c_str());\n+    }\n+};\n+\n+\n+\n+\n /** Private key that includes an expiration date in case it never gets used. */\n class CWalletKey\n {"
      }
    ]
  },
  {
    "sha": "e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzMzYWI1NmQ1YjlmZDZiMDUxMGVmNmI5OGNhYThiZmM1MDU5MDgy",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-04-07T17:52:40Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-06-04T16:36:39Z"
      },
      "message": "Move the random_shuffle call back into SelectCoinsMinConf() so we can unit test it.",
      "tree": {
        "sha": "f5c97d9e926002a326b1882a0187a875b75d430a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f5c97d9e926002a326b1882a0187a875b75d430a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9b0369c773c1d350a05435d8d3ec4e954828fb82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0369c773c1d350a05435d8d3ec4e954828fb82",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9b0369c773c1d350a05435d8d3ec4e954828fb82"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "36dbe7aeb199773b0cf2245aab75ef671fc158c0",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
        "patch": "@@ -926,6 +926,8 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n     vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n     int64 nTotalLower = 0;\n \n+    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n+\n     BOOST_FOREACH(COutput output, vCoins)\n     {\n         const CWalletTx *pcoin = output.tx;"
      }
    ]
  },
  {
    "sha": "4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Y2UxOTBhMDE1NzgzN2RmOWE0YTgwNGY4ZTNmMjk0MWQxZmZhY2Y1",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-04-07T17:55:03Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-06-04T16:36:43Z"
      },
      "message": "Test that the coin selection code is suitably random, and add tests re. sub-cent change.",
      "tree": {
        "sha": "824299c0f8b2b38a0e995f7d90bc9814cafec613",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/824299c0f8b2b38a0e995f7d90bc9814cafec613"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ce190a0157837df9a4a804f8e3f2941d1ffacf5/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e333ab56d5b9fd6b0510ef6b98caa8bfc5059082"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 71,
      "deletions": 1
    },
    "files": [
      {
        "sha": "dc8fe0843995f72c2ea8ee8f1f829394f3ceb76a",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 1,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ce190a0157837df9a4a804f8e3f2941d1ffacf5/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ce190a0157837df9a4a804f8e3f2941d1ffacf5/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
        "patch": "@@ -9,8 +9,14 @@\n // enables tests which currently fail, due to code which tries too hard to avoid sub-cent change\n // #define STRICT\n \n+// some tests fail 1% of the time due to bad luck.\n+// we repeat those tests this many times and only complain if all iterations of the test fail\n+#define RANDOM_REPEATS 5\n+\n using namespace std;\n \n+typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+\n BOOST_AUTO_TEST_SUITE(wallet_tests)\n \n static CWallet wallet;\n@@ -44,9 +50,15 @@ static void empty_wallet(void)\n     vCoins.clear();\n }\n \n+static bool equal_sets(CoinSet a, CoinSet b)\n+{\n+    pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    return ret.first == a.end() && ret.second == b.end();\n+}\n+\n BOOST_AUTO_TEST_CASE(coin_selection_tests)\n {\n-    static set<pair<const CWalletTx*,unsigned int> > setCoinsRet;\n+    static CoinSet setCoinsRet, setCoinsRet2;\n     static int64 nValueRet;\n \n     // test multiple times to allow for differences in the shuffle order\n@@ -250,6 +262,64 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // but since value of smaller coins < target+cent, we get the bigger coin again\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n #endif\n+\n+        // test avoiding sub-cent change\n+        empty_wallet();\n+        add_coin(0.0005 * COIN);\n+        add_coin(0.01 * COIN);\n+        add_coin(1 * COIN);\n+\n+        // trying to make 1.0001 from these three coins\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(1.0001 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.0105 * COIN);   // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);\n+\n+        // but if we try to make 0.999, we should take the bigger of the two small coins to avoid sub-cent change\n+        BOOST_CHECK( wallet.SelectCoinsMinConf(0.999 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1.01 * COIN);   // we should get 1 + 0.01\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n+\n+        // test randomness\n+        {\n+            empty_wallet();\n+            for (int i2 = 0; i2 < 100; i2++)\n+                add_coin(COIN);\n+\n+            // picking 50 from 100 coins doesn't depend on the shuffle,\n+            // but does depend on randomness in the stochastic approximation code\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(wallet.SelectCoinsMinConf(50 * COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n+\n+            int fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(COIN, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+\n+            // add 75 cents in small change.  not enough to make 90 cents,\n+            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n+            // one of which should be picked at random\n+            add_coin( 5*CENT); add_coin(10*CENT); add_coin(15*CENT); add_coin(20*CENT); add_coin(25*CENT);\n+\n+            fails = 0;\n+            for (int i = 0; i < RANDOM_REPEATS; i++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(wallet.SelectCoinsMinConf(90*CENT, 1, 6, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+        }\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "d650f96d5f48a9cc458af9ef644f57973ca7f48b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjUwZjk2ZDVmNDhhOWNjNDU4YWY5ZWY2NDRmNTc5NzNjYTdmNDhi",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-04-07T19:45:39Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-06-04T16:36:46Z"
      },
      "message": "Preserve the shuffled order of coins with equal value to give more randomized coin selection.",
      "tree": {
        "sha": "f3b66f551d46d82e99f2e51b773857b7f9b43ebc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3b66f551d46d82e99f2e51b773857b7f9b43ebc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d650f96d5f48a9cc458af9ef644f57973ca7f48b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d650f96d5f48a9cc458af9ef644f57973ca7f48b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d650f96d5f48a9cc458af9ef644f57973ca7f48b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d650f96d5f48a9cc458af9ef644f57973ca7f48b/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ce190a0157837df9a4a804f8e3f2941d1ffacf5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ce190a0157837df9a4a804f8e3f2941d1ffacf5"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 10,
      "deletions": 1
    },
    "files": [
      {
        "sha": "d190ad924288fc9b599c0ef89a0b7146ed0422b8",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d650f96d5f48a9cc458af9ef644f57973ca7f48b/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d650f96d5f48a9cc458af9ef644f57973ca7f48b/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=d650f96d5f48a9cc458af9ef644f57973ca7f48b",
        "patch": "@@ -17,6 +17,15 @@ using namespace std;\n // mapWallet\n //\n \n+struct CompareValueOnly\n+{\n+    bool operator()(const pair<int64, pair<const CWalletTx*, unsigned int> >& t1,\n+                    const pair<int64, pair<const CWalletTx*, unsigned int> >& t2) const\n+    {\n+        return t1.first < t2.first;\n+    }\n+};\n+\n CPubKey CWallet::GenerateNewKey()\n {\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n@@ -980,7 +989,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         nTargetValue += CENT;\n \n     // Solve subset sum by stochastic approximation\n-    sort(vValue.rbegin(), vValue.rend());\n+    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n     vector<char> vfIncluded;\n     vector<char> vfBest(vValue.size(), true);\n     int64 nBest = nTotalLower;"
      }
    ]
  },
  {
    "sha": "831f59ce8b179bd3180a73499da9b1dc1d5ecaeb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MzFmNTljZThiMTc5YmQzMTgwYTczNDk5ZGE5YjFkYzFkNWVjYWVi",
    "commit": {
      "author": {
        "name": "Chris Moore",
        "email": "dooglus@gmail.com",
        "date": "2012-04-12T23:22:15Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-06-04T16:49:10Z"
      },
      "message": "Fix coin selection to only include change when it's necessary.",
      "tree": {
        "sha": "a7310330f320bd919e2817f2ae120bc613a10e1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a7310330f320bd919e2817f2ae120bc613a10e1d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb/comments",
    "author": {
      "login": "dooglus",
      "id": 573356,
      "node_id": "MDQ6VXNlcjU3MzM1Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dooglus",
      "html_url": "https://github.com/dooglus",
      "followers_url": "https://api.github.com/users/dooglus/followers",
      "following_url": "https://api.github.com/users/dooglus/following{/other_user}",
      "gists_url": "https://api.github.com/users/dooglus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dooglus/subscriptions",
      "organizations_url": "https://api.github.com/users/dooglus/orgs",
      "repos_url": "https://api.github.com/users/dooglus/repos",
      "events_url": "https://api.github.com/users/dooglus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dooglus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d650f96d5f48a9cc458af9ef644f57973ca7f48b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d650f96d5f48a9cc458af9ef644f57973ca7f48b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d650f96d5f48a9cc458af9ef644f57973ca7f48b"
      }
    ],
    "stats": {
      "total": 138,
      "additions": 58,
      "deletions": 80
    },
    "files": [
      {
        "sha": "9b77b284e6b0cfdee9f99909f0127974c94faa26",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 38,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=831f59ce8b179bd3180a73499da9b1dc1d5ecaeb",
        "patch": "@@ -6,9 +6,6 @@\n // how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n #define RUN_TESTS 100\n \n-// enables tests which currently fail, due to code which tries too hard to avoid sub-cent change\n-// #define STRICT\n-\n // some tests fail 1% of the time due to bad luck.\n // we repeat those tests this many times and only complain if all iterations of the test fail\n #define RANDOM_REPEATS 5\n@@ -109,15 +106,10 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         BOOST_CHECK_GT(nValueRet, 34 * CENT);         // but should get more than 34 cents\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n-        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  I'd hope to see just 2+5, but 1 gets included too\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n         BOOST_CHECK( wallet.SelectCoinsMinConf( 7 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n-#else\n-        BOOST_CHECK(nValueRet == 7 * CENT || nValueRet == 8 * CENT);\n-        BOOST_CHECK(setCoinsRet.size() == 2 || setCoinsRet.size() == 3);\n-#endif\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n         BOOST_CHECK( wallet.SelectCoinsMinConf( 8 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n@@ -161,13 +153,9 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1); // because in the event of a tie, the biggest coin wins\n \n-        // now try making 11 cents.  we hope for 5+6 but get 5+7 due to fear of sub-cent change\n+        // now try making 11 cents.  we should get 5+6\n         BOOST_CHECK( wallet.SelectCoinsMinConf(11 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n-#else\n-        BOOST_CHECK(nValueRet == 11 * CENT || nValueRet == 12 * CENT);\n-#endif\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2);\n \n         // check that the smallest bigger coin is used\n@@ -201,24 +189,15 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n \n         // try making 1 cent from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5 cents\n         BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n-#else\n-        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 1111 * CENT); // but get a single 1111 cent coin\n-#endif\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n \n         // if we add more sub-cent coins:\n         add_coin(0.6*CENT);\n         add_coin(0.7*CENT);\n \n-        // and try again to make 1.0 cents, the new coins will be used to make 2.0 cents - leaving 1.0 cent change\n+        // and try again to make 1.0 cents, we can still make 1.0 cents\n         BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n-#else\n-        BOOST_CHECK(nValueRet == 1 * CENT || nValueRet == 2 * CENT); // but get a bunch of sub-cent coins totalling 2 cents\n-        BOOST_CHECK_GE(setCoinsRet.size(), 4); // 0.7 + 0.6 + 0.5 + 0.2 = 2.0 for example\n-#endif\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we should get the exact amount\n \n         // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n         // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n@@ -227,13 +206,8 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n             add_coin(50000 * COIN);\n \n         BOOST_CHECK( wallet.SelectCoinsMinConf(500000 * COIN, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10); // in ten coins\n-#else\n-        BOOST_CHECK(nValueRet == 500000 * COIN || nValueRet == 550000 * COIN); // but get 50k too much\n-        BOOST_CHECK(setCoinsRet.size() == 10 || setCoinsRet.size() == 11); // in 11 coins\n-#endif\n \n         // if there's not enough in the smaller coins to make at least 1 cent change (0.5+0.6+0.7 < 1.0+1.0),\n         // we need to try finding an exact subset anyway\n@@ -255,13 +229,8 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(0.8 * CENT);\n         add_coin(1111 * CENT);\n         BOOST_CHECK( wallet.SelectCoinsMinConf(1 * CENT, 1, 1, vCoins, setCoinsRet, nValueRet));\n-#ifdef STRICT\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT); // we hope for the exact amount\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2); // in two coins 0.4+0.6\n-#else\n-        BOOST_CHECK_EQUAL(nValueRet, 1111 * CENT); // but since value of smaller coins < target+cent, we get the bigger coin again\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1);\n-#endif\n \n         // test avoiding sub-cent change\n         empty_wallet();"
      },
      {
        "sha": "127d580803521b32350a62cb0fc24e4a90a09aec",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 42,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/831f59ce8b179bd3180a73499da9b1dc1d5ecaeb/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=831f59ce8b179bd3180a73499da9b1dc1d5ecaeb",
        "patch": "@@ -898,7 +898,7 @@ int64 CWallet::GetImmatureBalance() const\n     return nTotal;\n }\n \n-// populate vCoins with vector of spendable (age, (value, (transaction, output_number))) outputs\n+// populate vCoins with vector of spendable COutputs\n void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n {\n     vCoins.clear();\n@@ -915,13 +915,51 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n             if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                 continue;\n \n-            for (int i = 0; i < pcoin->vout.size(); i++)\n+            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                 if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue > 0)\n                     vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n         }\n     }\n }\n \n+static void ApproximateBestSubset(vector<pair<int64, pair<const CWalletTx*,unsigned int> > >vValue, int64 nTotalLower, int64 nTargetValue,\n+                                  vector<char>& vfBest, int64& nBest, int iterations = 1000)\n+{\n+    vector<char> vfIncluded;\n+\n+    vfBest.assign(vValue.size(), true);\n+    nBest = nTotalLower;\n+\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n+    {\n+        vfIncluded.assign(vValue.size(), false);\n+        int64 nTotal = 0;\n+        bool fReachedTarget = false;\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        {\n+            for (unsigned int i = 0; i < vValue.size(); i++)\n+            {\n+                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n+                {\n+                    nTotal += vValue[i].first;\n+                    vfIncluded[i] = true;\n+                    if (nTotal >= nTargetValue)\n+                    {\n+                        fReachedTarget = true;\n+                        if (nTotal < nBest)\n+                        {\n+                            nBest = nTotal;\n+                            vfBest = vfIncluded;\n+                        }\n+                        nTotal -= vValue[i].first;\n+                        vfIncluded[i] = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n                                  set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const\n {\n@@ -966,7 +1004,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         }\n     }\n \n-    if (nTotalLower == nTargetValue || nTotalLower == nTargetValue + CENT)\n+    if (nTotalLower == nTargetValue)\n     {\n         for (unsigned int i = 0; i < vValue.size(); ++i)\n         {\n@@ -976,7 +1014,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         return true;\n     }\n \n-    if (nTotalLower < nTargetValue + (coinLowestLarger.second.first ? CENT : 0))\n+    if (nTotalLower < nTargetValue)\n     {\n         if (coinLowestLarger.second.first == NULL)\n             return false;\n@@ -985,46 +1023,19 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         return true;\n     }\n \n-    if (nTotalLower >= nTargetValue + CENT)\n-        nTargetValue += CENT;\n-\n     // Solve subset sum by stochastic approximation\n     sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n-    vector<char> vfIncluded;\n-    vector<char> vfBest(vValue.size(), true);\n-    int64 nBest = nTotalLower;\n+    vector<char> vfBest;\n+    int64 nBest;\n \n-    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)\n-    {\n-        vfIncluded.assign(vValue.size(), false);\n-        int64 nTotal = 0;\n-        bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n-            for (unsigned int i = 0; i < vValue.size(); i++)\n-            {\n-                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n-                {\n-                    nTotal += vValue[i].first;\n-                    vfIncluded[i] = true;\n-                    if (nTotal >= nTargetValue)\n-                    {\n-                        fReachedTarget = true;\n-                        if (nTotal < nBest)\n-                        {\n-                            nBest = nTotal;\n-                            vfBest = vfIncluded;\n-                        }\n-                        nTotal -= vValue[i].first;\n-                        vfIncluded[i] = false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n+    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n+        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n \n-    // If the next larger is still closer, return it\n-    if (coinLowestLarger.second.first && coinLowestLarger.first - nTargetValue <= nBest - nTargetValue)\n+    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n+    //                                   or the next bigger coin is closer), return the bigger coin\n+    if (coinLowestLarger.second.first &&\n+        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n     {\n         setCoinsRet.insert(coinLowestLarger.second);\n         nValueRet += coinLowestLarger.first;\n@@ -1037,14 +1048,12 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n                 nValueRet += vValue[i].first;\n             }\n \n-#ifdef DEBUG\n         //// debug print\n         printf(\"SelectCoins() best subset: \");\n         for (unsigned int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n                 printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n         printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n-#endif\n     }\n \n     return true;"
      }
    ]
  }
]