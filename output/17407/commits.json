[
  {
    "sha": "fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWMwN2YyMDM4YTNjY2Q1ZWRhZGM2ZTYxMjJjMDJmYTMwZTY5N2Jk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-11-08T15:29:41Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-11-15T18:40:00Z"
      },
      "message": "node: Add reference to mempool in NodeContext\n\nCurrently it is an alias to the global ::mempool and should be used as\nfollows.\n\n* Node code (validation and transaction relay) can use either ::mempool\n  or node.mempool, whichever seems a better fit.\n* RPC code should use the added convenience getter EnsureMempool, which\n  makes sure the mempool exists before use. This prepares the RPC code\n  to a future where the mempool might be disabled at runtime or compile\n  time.\n* Test code should use m_node.mempool directly, as the mempool is always\n  initialized for tests.",
      "tree": {
        "sha": "7f115cb94e2b7486efd531b48b6ce42a7b92a5a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f115cb94e2b7486efd531b48b6ce42a7b92a5a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiNDQv7BkmpFT1KTSfyWR85KqBsU0toiU/MUOUatLozJf07UssczcGsCU7eI91b\n9zPuqsEWPEaqi+FMbioZpeag0SBnT7gUc/IHjnTEAYklzCmKgI+1A7jOj3WlqaQE\nbsvZfcBgWVwFM6QDOvjlDdjx/9hLH2c/td3RyAmVnoUjGDhs3ZjkluP6nqd7IgW+\n9LdEzww+mXgZ98NtSNOwSYSj64tgYwvc1LcEIXRTDepxJhxMgJ9w7w0k1HGKfVfv\nfcEbyozOZI4lCsWj2ootomGlkWUwK54yUC7REYD88+SA6C8Qj2UwQLZS/0kka6hK\nM6iePHIzaYyAvhUAx0/LfOkWOLBRZ5nHMuWheFoTv3GxssYlNnVG+DFQWh1FNz8r\nYzV4ZbyFMnn1RnDMUkNyRY2GIDWJGwNpfyEjT09cPELKGzpkj6pkUNP42n43SowY\n23Tlvz/m8RCX22H6WbWTvY2PZNVmkArTtgn++2zBCEH5l2FtINEVsvX3tJiYFz0f\nc24IzTbf\n=wSA4\n-----END PGP SIGNATURE-----",
        "payload": "tree 7f115cb94e2b7486efd531b48b6ce42a7b92a5a7\nparent 270616228bc9a3856a0a82dea26ac3480b7585cd\nauthor MarcoFalke <falke.marco@gmail.com> 1573226981 -0500\ncommitter MarcoFalke <falke.marco@gmail.com> 1573843200 -0500\n\nnode: Add reference to mempool in NodeContext\n\nCurrently it is an alias to the global ::mempool and should be used as\nfollows.\n\n* Node code (validation and transaction relay) can use either ::mempool\n  or node.mempool, whichever seems a better fit.\n* RPC code should use the added convenience getter EnsureMempool, which\n  makes sure the mempool exists before use. This prepares the RPC code\n  to a future where the mempool might be disabled at runtime or compile\n  time.\n* Test code should use m_node.mempool directly, as the mempool is always\n  initialized for tests.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "270616228bc9a3856a0a82dea26ac3480b7585cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/270616228bc9a3856a0a82dea26ac3480b7585cd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/270616228bc9a3856a0a82dea26ac3480b7585cd"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 28,
      "deletions": 5
    },
    "files": [
      {
        "sha": "013f0536b438feb6c85dcbb3f3832065c231f3de",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -284,6 +284,7 @@ void Shutdown(NodeContext& node)\n     GetMainSignals().UnregisterWithMempoolSignals(mempool);\n     globalVerifyHandle.reset();\n     ECC_Stop();\n+    if (node.mempool) node.mempool = nullptr;\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n \n@@ -1632,6 +1633,11 @@ bool AppInitMain(NodeContext& node)\n         return false;\n     }\n \n+    // Now that the chain state is loaded, make mempool generally available in the node context. For example the\n+    // connection manager, wallet, or RPC threads, which are all started after this, may use it from the node context.\n+    assert(!node.mempool);\n+    node.mempool = &::mempool;\n+\n     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n     // Allowed to fail as this file IS missing on first startup."
      },
      {
        "sha": "dab5b5d048d4c8062905ae224484a9a9caade14b",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -10,6 +10,7 @@\n \n class BanMan;\n class CConnman;\n+class CTxMemPool;\n class PeerLogicValidation;\n namespace interfaces {\n class Chain;\n@@ -22,13 +23,13 @@ class ChainClient;\n //! This is used by init, rpc, and test code to pass object references around\n //! without needing to declare the same variables and parameters repeatedly, or\n //! to use globals. More variables could be added to this struct (particularly\n-//! references to validation and mempool objects) to eliminate use of globals\n+//! references to validation objects) to eliminate use of globals\n //! and make code more modular and testable. The struct isn't intended to have\n //! any member functions. It should just be a collection of references that can\n //! be used without pulling in unwanted dependencies or functionality.\n-struct NodeContext\n-{\n+struct NodeContext {\n     std::unique_ptr<CConnman> connman;\n+    CTxMemPool* mempool{nullptr}; // Currently a raw pointer because the memory is not managed by this struct\n     std::unique_ptr<PeerLogicValidation> peer_logic;\n     std::unique_ptr<BanMan> banman;\n     std::unique_ptr<interfaces::Chain> chain;"
      },
      {
        "sha": "374fc9b59b2b4e1411d34108092db37f3bccaef0",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -32,7 +32,6 @@ void RPCNestedTests::rpcNestedTests()\n     // do some test setup\n     // could be moved to a more generic place when we add more tests on QT level\n     tableRPC.appendCommand(\"rpcNestedTest\", &vRPCCommands[0]);\n-    //mempool.setSanityCheck(1.0);\n \n     TestingSetup test;\n "
      },
      {
        "sha": "946152d9aa3836126fef879a1c3e0679eded2b60",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -15,6 +15,7 @@\n #include <hash.h>\n #include <index/blockfilterindex.h>\n #include <node/coinstats.h>\n+#include <node/context.h>\n #include <node/utxo_snapshot.h>\n #include <policy/feerate.h>\n #include <policy/policy.h>\n@@ -53,6 +54,15 @@ static Mutex cs_blockchange;\n static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock;\n \n+CTxMemPool& EnsureMemPool()\n+{\n+    CHECK_NONFATAL(g_rpc_node);\n+    if (!g_rpc_node->mempool) {\n+        throw JSONRPCError(RPC_CLIENT_MEMPOOL_DISABLED, \"Mempool disabled or instance not found\");\n+    }\n+    return *g_rpc_node->mempool;\n+}\n+\n /* Calculate the difficulty for a given block index.\n  */\n double GetDifficulty(const CBlockIndex* blockindex)"
      },
      {
        "sha": "ccb3e3972248ff6231fb868075dc48b7504ef09d",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -52,4 +52,6 @@ void CalculatePercentilesByWeight(CAmount result[NUM_GETBLOCKSTATS_PERCENTILES],\n //! direct way to pass in state to RPC methods without globals.\n extern NodeContext* g_rpc_node;\n \n+CTxMemPool& EnsureMemPool();\n+\n #endif"
      },
      {
        "sha": "ca779497b9d816158238dad4c509a71853822dfd",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -63,6 +63,9 @@ enum RPCErrorCode\n     RPC_CLIENT_INVALID_IP_OR_SUBNET = -30, //!< Invalid IP/Subnet\n     RPC_CLIENT_P2P_DISABLED         = -31, //!< No valid connection manager instance found\n \n+    //! Chain errors\n+    RPC_CLIENT_MEMPOOL_DISABLED     = -33, //!< No mempool instance found\n+\n     //! Wallet errors\n     RPC_WALLET_ERROR                = -4,  //!< Unspecified problem with wallet (key not found etc.)\n     RPC_WALLET_INSUFFICIENT_FUNDS   = -6,  //!< Not enough funds in wallet or account"
      },
      {
        "sha": "86c355fdcd1dad3416cce6c125f21def373f2eaa",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac07f2038a3ccd5edadc6e6122c02fa30e697bd/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "patch": "@@ -107,7 +107,6 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     threadGroup.create_thread(std::bind(&CScheduler::serviceQueue, &scheduler));\n     GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n \n-    mempool.setSanityCheck(1.0);\n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n     g_chainstate = MakeUnique<CChainState>();\n     ::ChainstateActive().InitCoinsDB(\n@@ -131,6 +130,8 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     }\n     g_parallel_script_checks = true;\n \n+    m_node.mempool = &::mempool;\n+    m_node.mempool->setSanityCheck(1.0);\n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n }\n@@ -144,6 +145,7 @@ TestingSetup::~TestingSetup()\n     g_rpc_node = nullptr;\n     m_node.connman.reset();\n     m_node.banman.reset();\n+    m_node.mempool = nullptr;\n     UnloadBlockIndex();\n     g_chainstate.reset();\n     pblocktree.reset();"
      }
    ]
  },
  {
    "sha": "8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ODg4YWQwMmUyMDRiMGZhN2EyZWEyY2ZlZDJmYzNmMjk4Y2YxNjIz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-11-08T16:07:36Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-11-15T18:40:08Z"
      },
      "message": "test: Replace recursive lock with locking annotations\n\nAlso, use m_node.mempool instead of the global",
      "tree": {
        "sha": "7f8eb7835c9bd5452d655f8d77bf1d28c8a78442",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f8eb7835c9bd5452d655f8d77bf1d28c8a78442"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUj4GQwAnc0ZttNuPQ8Vam0vRE8hHI8Vi8PPqw1+3meK3SW26R2cisWaNblIozfQ\nff2jEx7bQ0KmAjEDW8b11pqVjGUlOA4phozlinuhvMrSmj+pTzbxOhbaSMcPQ5Wd\nh1fjAQPR75ZeCidrJlYo9afe+WPskWLXAlHFGgGM9bHaFP1sEDRxPTiiUdRZUZRM\nxMq081pDchHZgaVrldre/ZaoV4QTbuoeQcW8uDnap3PR2kyjz0DWEPKtuXvwMn/J\nCYi0vvYg21GGeBsS+ou5oJfPbbQ404PZOHQ7Gahxk+4G2YTZSN2Q83aZh4HjnPUV\nIt6o2SpgR5VaI0IXnWI8Nn8i7/3dlBSs3d9f/qhM8XtN/BDpxLVwcgHA7DfIb4g2\ndob0AcWBKDKHX8EzBS74mag7I0dAdC5tEDM7rqHqIPemniMJlrUmLrQZSIm77sVi\nqJ81HjQPmzqjwT0f0zKg1H1FmcnyaZG6Uz4TtznbL7JeV66UKtvEKOSaH+OoZVjX\nD2hvPMo6\n=G3+f\n-----END PGP SIGNATURE-----",
        "payload": "tree 7f8eb7835c9bd5452d655f8d77bf1d28c8a78442\nparent fac07f2038a3ccd5edadc6e6122c02fa30e697bd\nauthor MarcoFalke <falke.marco@gmail.com> 1573229256 -0500\ncommitter MarcoFalke <falke.marco@gmail.com> 1573843208 -0500\n\ntest: Replace recursive lock with locking annotations\n\nAlso, use m_node.mempool instead of the global\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac07f2038a3ccd5edadc6e6122c02fa30e697bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fac07f2038a3ccd5edadc6e6122c02fa30e697bd"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 20,
      "deletions": 18
    },
    "files": [
      {
        "sha": "5aae2cccd0dbb64a1be587d3b68a148d449a27b2",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
        "patch": "@@ -23,7 +23,17 @@\n \n #include <boost/test/unit_test.hpp>\n \n-BOOST_FIXTURE_TEST_SUITE(miner_tests, TestingSetup)\n+namespace miner_tests {\n+struct MinerTestingSetup : public TestingSetup {\n+    void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n+    bool TestSequenceLocks(const CTransaction& tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs)\n+    {\n+        return CheckSequenceLocks(*m_node.mempool, tx, flags);\n+    }\n+};\n+} // namespace miner_tests\n+\n+BOOST_FIXTURE_TEST_SUITE(miner_tests, MinerTestingSetup)\n \n // BOOST_CHECK_EXCEPTION predicates to check the specific validation error\n class HasReason {\n@@ -89,16 +99,10 @@ static CBlockIndex CreateBlockIndex(int nHeight) EXCLUSIVE_LOCKS_REQUIRED(cs_mai\n     return index;\n }\n \n-static bool TestSequenceLocks(const CTransaction &tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    LOCK(::mempool.cs);\n-    return CheckSequenceLocks(::mempool, tx, flags);\n-}\n-\n // Test suite for ancestor feerate transaction selection.\n // Implemented as an additional function, rather than a separate test case,\n // to allow reusing the blockchain created in CreateNewBlock_validity.\n-static void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs)\n+void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst)\n {\n     // Test the ancestor feerate transaction selection.\n     TestMemPoolEntryHelper entry;"
      },
      {
        "sha": "49aa344b3388d36ad150a464690532afa8785755",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
        "patch": "@@ -17,16 +17,6 @@ bool CheckInputs(const CTransaction& tx, TxValidationState &state, const CCoinsV\n \n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n-static bool\n-ToMemPool(const CMutableTransaction& tx)\n-{\n-    LOCK(cs_main);\n-\n-    TxValidationState state;\n-    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx),\n-                              nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */);\n-}\n-\n BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n {\n     // Make sure skipping validation of transactions that were\n@@ -35,6 +25,14 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n     CScript scriptPubKey = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n \n+    const auto ToMemPool = [this](const CMutableTransaction& tx) {\n+        LOCK(cs_main);\n+\n+        TxValidationState state;\n+        return AcceptToMemoryPool(*m_node.mempool, state, MakeTransactionRef(tx),\n+            nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */);\n+    };\n+\n     // Create a double-spend of mature coinbase txn:\n     std::vector<CMutableTransaction> spends;\n     spends.resize(2);"
      }
    ]
  },
  {
    "sha": "fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTUzODgxM2IxYzM4MmNmMTM1Y2JmMmEwY2MzZmEwMWYzNjk2NGQ4",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-11-08T16:10:13Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-11-15T18:40:14Z"
      },
      "message": "scripted-diff: Replace ::mempool with m_node.mempool in tests\n\n-BEGIN VERIFY SCRIPT-\n # tx pool member access (mempool followed by dot)\n sed --regexp-extended -i -e 's/(::)?\\<mempool\\>\\.([a-zA-Z])/m_node.mempool->\\2/g' $(git grep -l mempool ./src/test)\n # plain global (mempool not preceeded by dot, but followed by comma)\n sed --regexp-extended -i -e 's/([^\\.])(::)?\\<mempool\\>,/\\1*m_node.mempool,/g'     $(git grep -l mempool ./src/test)\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "2263582cc4ae02e22ba28072a4f527842c54e39f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2263582cc4ae02e22ba28072a4f527842c54e39f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUi12Qv+N3zV9hFUO+M3yrXABP4WGytAUqqmHWaRDJklTII9ZdrhUzn7GthJV1ij\nHDGbVRpXRQ3e2aJ1EvvZ0/fRY1/3+HqzX4srFSlj316KoVhP4ut3Zh3Dl3LQJUN6\nhrpeDlhQpxITx8IuQ/9eyQ9tqOZrdNPR9guvJBZOirJ6bvenJhw2qGaLrpT4oMr3\nhPLi7lYJrwrJfaXsnexHJhEztFRaNoA32+m1juAKLbL1oJxPeD0XUgrE99aOGMHa\nb+ytG1WcnQxUXRSrf6xn9vSIUrZNbbtfE0NLyJguaz0CyvlqrVCDjv8LIaDT0kqM\ngVvyESQ9ZhX0lwa1VtE/s65Jk2p8BEiscnxG3QA/65hny173DbLsZ3QkyEpok9H2\nrEWcLaQo7JEhqb7Oiuzbs9EQLAE7v2a2fJo/H6VT2/XsG8cf8rGrWPDeWkd8Ir+p\nZ0SvRUy79Z+UF71EAqIVmRaWtdsgdrMTiR3dgbh9J/1+JHrR47fTt2TUxXIHm7bz\n0R1Lt7wo\n=cwh7\n-----END PGP SIGNATURE-----",
        "payload": "tree 2263582cc4ae02e22ba28072a4f527842c54e39f\nparent 8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623\nauthor MarcoFalke <falke.marco@gmail.com> 1573229413 -0500\ncommitter MarcoFalke <falke.marco@gmail.com> 1573843214 -0500\n\nscripted-diff: Replace ::mempool with m_node.mempool in tests\n\n-BEGIN VERIFY SCRIPT-\n # tx pool member access (mempool followed by dot)\n sed --regexp-extended -i -e 's/(::)?\\<mempool\\>\\.([a-zA-Z])/m_node.mempool->\\2/g' $(git grep -l mempool ./src/test)\n # plain global (mempool not preceeded by dot, but followed by comma)\n sed --regexp-extended -i -e 's/([^\\.])(::)?\\<mempool\\>,/\\1*m_node.mempool,/g'     $(git grep -l mempool ./src/test)\n-END VERIFY SCRIPT-\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8888ad02e204b0fa7a2ea2cfed2fc3f298cf1623"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 52,
      "deletions": 52
    },
    "files": [
      {
        "sha": "d79a598bf16239d0ed7620816a4f73ff4cbc1306",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 39,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
        "patch": "@@ -118,19 +118,19 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 1000;\n     // This tx has a low fee: 1000 satoshis\n     uint256 hashParentTx = tx.GetHash(); // save this txid for later use\n-    mempool.addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx has a medium fee: 10000 satoshis\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vout[0].nValue = 5000000000LL - 10000;\n     uint256 hashMediumFeeTx = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx has a high fee, but depends on the first transaction\n     tx.vin[0].prevout.hash = hashParentTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000; // 50k satoshi fee\n     uint256 hashHighFeeTx = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n \n     std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);\n@@ -141,7 +141,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.hash = hashHighFeeTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000; // 0 fee\n     uint256 hashFreeTx = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(0).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(0).FromTx(tx));\n     size_t freeTxSize = ::GetSerializeSize(tx, PROTOCOL_VERSION);\n \n     // Calculate a fee on child transaction that will put the package just\n@@ -151,7 +151,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vin[0].prevout.hash = hashFreeTx;\n     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n     uint256 hashLowFeeTx = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));\n     pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     // Verify that the free tx and the low fee tx didn't get selected\n     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n@@ -162,10 +162,10 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     // Test that packages above the min relay fee do get included, even if one\n     // of the transactions is below the min relay fee\n     // Remove the low fee transaction and replace with a higher fee transaction\n-    mempool.removeRecursive(CTransaction(tx), MemPoolRemovalReason::REPLACED);\n+    m_node.mempool->removeRecursive(CTransaction(tx), MemPoolRemovalReason::REPLACED);\n     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n     hashLowFeeTx = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));\n     pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);\n     BOOST_CHECK(pblocktemplate->block.vtx[5]->GetHash() == hashLowFeeTx);\n@@ -178,15 +178,15 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     tx.vout[0].nValue = 5000000000LL - 100000000;\n     tx.vout[1].nValue = 100000000; // 1BTC output\n     uint256 hashFreeTx2 = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n \n     // This tx can't be mined by itself\n     tx.vin[0].prevout.hash = hashFreeTx2;\n     tx.vout.resize(1);\n     feeToUse = blockMinFeeRate.GetFee(freeTxSize);\n     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n     uint256 hashLowFeeTx2 = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n     pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n \n     // Verify that this tx isn't selected.\n@@ -199,7 +199,7 @@ void MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co\n     // as well.\n     tx.vin[0].prevout.n = 1;\n     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n-    mempool.addUnchecked(entry.Fee(10000).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));\n     pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);\n     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);\n }\n@@ -256,7 +256,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     }\n \n     LOCK(cs_main);\n-    LOCK(::mempool.cs);\n+    LOCK(m_node.mempool->cs);\n \n     // Just to make sure we can still make simple blocks\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n@@ -280,12 +280,12 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         hash = tx.GetHash();\n         bool spendsCoinbase = i == 0; // only first tx spends coinbase\n         // If we don't set the # of sig ops in the CTxMemPoolEntry, template creation fails\n-        mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n+        m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n \n     BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-blk-sigops\"));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n     tx.vout[0].nValue = BLOCKSUBSIDY;\n@@ -295,11 +295,11 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         hash = tx.GetHash();\n         bool spendsCoinbase = i == 0; // only first tx spends coinbase\n         // If we do set the # of sig ops in the CTxMemPoolEntry, template creation passes\n-        mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n+        m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     // block size > limit\n     tx.vin[0].scriptSig = CScript();\n@@ -315,59 +315,59 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         tx.vout[0].nValue -= LOWFEE;\n         hash = tx.GetHash();\n         bool spendsCoinbase = i == 0; // only first tx spends coinbase\n-        mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n+        m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n-    // orphan in mempool, template creation fails\n+    // orphan in *m_node.mempool, template creation fails\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));\n     BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     // child with higher feerate than parent\n     tx.vin[0].scriptSig = CScript() << OP_1;\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vout[0].nValue = BLOCKSUBSIDY-HIGHFEE;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     tx.vin[0].prevout.hash = hash;\n     tx.vin.resize(2);\n     tx.vin[1].scriptSig = CScript() << OP_1;\n     tx.vin[1].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[1].prevout.n = 0;\n     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n-    // coinbase in mempool, template creation fails\n+    // coinbase in *m_node.mempool, template creation fails\n     tx.vin.resize(1);\n     tx.vin[0].prevout.SetNull();\n     tx.vin[0].scriptSig = CScript() << OP_0 << OP_1;\n     tx.vout[0].nValue = 0;\n     hash = tx.GetHash();\n     // give it a fee so it'll get mined\n-    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw bad-cb-multiple\n     BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-cb-multiple\"));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n-    // double spend txn pair in mempool, template creation fails\n+    // double spend txn pair in *m_node.mempool, template creation fails\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[0].scriptSig = CScript() << OP_1;\n     tx.vout[0].nValue = BLOCKSUBSIDY-HIGHFEE;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     // subsidy changing\n     int nHeight = ::ChainActive().Height();\n@@ -396,23 +396,23 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     }\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n \n-    // invalid p2sh txn in mempool, template creation fails\n+    // invalid p2sh txn in *m_node.mempool, template creation fails\n     tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[0].prevout.n = 0;\n     tx.vin[0].scriptSig = CScript() << OP_1;\n     tx.vout[0].nValue = BLOCKSUBSIDY-LOWFEE;\n     script = CScript() << OP_0;\n     tx.vout[0].scriptPubKey = GetScriptForDestination(ScriptHash(script));\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     tx.vin[0].prevout.hash = hash;\n     tx.vin[0].scriptSig = CScript() << std::vector<unsigned char>(script.begin(), script.end());\n     tx.vout[0].nValue -= LOWFEE;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n     // Should throw block-validation-failed\n     BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"block-validation-failed\"));\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n     while (::ChainActive().Tip()->nHeight > nHeight) {\n@@ -443,7 +443,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n     tx.nLockTime = 0;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n     BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n     BOOST_CHECK(SequenceLocks(CTransaction(tx), flags, &prevheights, CreateBlockIndex(::ChainActive().Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n@@ -453,7 +453,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((::ChainActive().Tip()->GetMedianTimePast()+1-::ChainActive()[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n     prevheights[0] = baseheight + 2;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(CheckFinalTx(CTransaction(tx), flags)); // Locktime passes\n     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail\n \n@@ -469,7 +469,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     prevheights[0] = baseheight + 3;\n     tx.nLockTime = ::ChainActive().Tip()->nHeight + 1;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n     BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n     BOOST_CHECK(IsFinalTx(CTransaction(tx), ::ChainActive().Tip()->nHeight + 2, ::ChainActive().Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n@@ -480,7 +480,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     prevheights.resize(1);\n     prevheights[0] = baseheight + 4;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));\n+    m_node.mempool->addUnchecked(entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(!CheckFinalTx(CTransaction(tx), flags)); // Locktime fails\n     BOOST_CHECK(TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks pass\n     BOOST_CHECK(IsFinalTx(CTransaction(tx), ::ChainActive().Tip()->nHeight + 2, ::ChainActive().Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n@@ -517,7 +517,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     ::ChainActive().Tip()->nHeight--;\n     SetMockTime(0);\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     TestPackageSelection(chainparams, scriptPubKey, txFirst);\n "
      },
      {
        "sha": "cace75f0938c28296b294813b48b83664acecb47",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
        "patch": "@@ -34,17 +34,17 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n \n     LOCK(cs_main);\n \n-    unsigned int initialPoolSize = mempool.size();\n+    unsigned int initialPoolSize = m_node.mempool->size();\n \n     BOOST_CHECK_EQUAL(\n             false,\n-            AcceptToMemoryPool(mempool, state, MakeTransactionRef(coinbaseTx),\n+            AcceptToMemoryPool(*m_node.mempool, state, MakeTransactionRef(coinbaseTx),\n                 nullptr /* plTxnReplaced */,\n                 true /* bypass_limits */,\n                 0 /* nAbsurdFee */));\n \n     // Check that the transaction hasn't been added to mempool.\n-    BOOST_CHECK_EQUAL(mempool.size(), initialPoolSize);\n+    BOOST_CHECK_EQUAL(m_node.mempool->size(), initialPoolSize);\n \n     // Check that the validation state reflects the unsuccessful attempt.\n     BOOST_CHECK(state.IsInvalid());"
      },
      {
        "sha": "67f45c4ed46dbc581f8360f94784fde50fe83ec1",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
        "patch": "@@ -70,7 +70,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n         LOCK(cs_main);\n         BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() != block.GetHash());\n     }\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n     // Test 3: ... and should be rejected if spend2 is in the memory pool\n     BOOST_CHECK(ToMemPool(spends[1]));\n@@ -79,9 +79,9 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n         LOCK(cs_main);\n         BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() != block.GetHash());\n     }\n-    mempool.clear();\n+    m_node.mempool->clear();\n \n-    // Final sanity test: first spend in mempool, second in block, that's OK:\n+    // Final sanity test: first spend in *m_node.mempool, second in block, that's OK:\n     std::vector<CMutableTransaction> oneSpend;\n     oneSpend.push_back(spends[0]);\n     BOOST_CHECK(ToMemPool(spends[1]));\n@@ -92,7 +92,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     }\n     // spends[1] should have been removed from the mempool when the\n     // block with spends[0] is accepted:\n-    BOOST_CHECK_EQUAL(mempool.size(), 0U);\n+    BOOST_CHECK_EQUAL(m_node.mempool->size(), 0U);\n }\n \n // Run CheckInputs (using CoinsTip()) on the given transaction, for all script"
      },
      {
        "sha": "3431eedff6425582397a0777af56e1aa3b8c7fd1",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa538813b1c382cf135cbf2a0cc3fa01f36964d8/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=fa538813b1c382cf135cbf2a0cc3fa01f36964d8",
        "patch": "@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n             std::list<CTransactionRef> plTxnReplaced;\n             for (const auto& tx : txs) {\n                 BOOST_REQUIRE(AcceptToMemoryPool(\n-                    ::mempool,\n+                    *m_node.mempool,\n                     state,\n                     tx,\n                     &plTxnReplaced,\n@@ -289,8 +289,8 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n \n         // Check that all txs are in the pool\n         {\n-            LOCK(::mempool.cs);\n-            BOOST_CHECK_EQUAL(::mempool.mapTx.size(), txs.size());\n+            LOCK(m_node.mempool->cs);\n+            BOOST_CHECK_EQUAL(m_node.mempool->mapTx.size(), txs.size());\n         }\n \n         // Run a thread that simulates an RPC caller that is polling while\n@@ -300,8 +300,8 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n             // the transactions invalidated by the reorg, or none of them, and\n             // not some intermediate amount.\n             while (true) {\n-                LOCK(::mempool.cs);\n-                if (::mempool.mapTx.size() == 0) {\n+                LOCK(m_node.mempool->cs);\n+                if (m_node.mempool->mapTx.size() == 0) {\n                     // We are done with the reorg\n                     break;\n                 }\n@@ -310,7 +310,7 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n                 // be atomic. So the caller assumes that the returned mempool\n                 // is consistent. That is, it has all txs that were there\n                 // before the reorg.\n-                assert(::mempool.mapTx.size() == txs.size());\n+                assert(m_node.mempool->mapTx.size() == txs.size());\n                 continue;\n             }\n             LOCK(cs_main);"
      }
    ]
  }
]