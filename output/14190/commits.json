[
  {
    "sha": "870178bfb6cf36191cfd1f54854639bd8e1adc64",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NzAxNzhiZmI2Y2YzNjE5MWNmZDFmNTQ4NTQ2MzliZDhlMWFkYzY0",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2018-09-10T17:29:23Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2018-09-10T17:29:23Z"
      },
      "message": "contrib: add ZMQ client example for golang",
      "tree": {
        "sha": "22f5faaa6ef38bd300df82a45d3952055c7ecee1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/22f5faaa6ef38bd300df82a45d3952055c7ecee1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/870178bfb6cf36191cfd1f54854639bd8e1adc64",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/870178bfb6cf36191cfd1f54854639bd8e1adc64",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/870178bfb6cf36191cfd1f54854639bd8e1adc64",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/870178bfb6cf36191cfd1f54854639bd8e1adc64/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "793d2b74306d6628ef5b92dce9a081f8951efc2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/793d2b74306d6628ef5b92dce9a081f8951efc2d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/793d2b74306d6628ef5b92dce9a081f8951efc2d"
      }
    ],
    "stats": {
      "total": 201,
      "additions": 201,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6f2d644690b88e78322a1d0219fa53d90c063eba",
        "filename": "contrib/zmq/zmq_sub.go",
        "status": "added",
        "additions": 201,
        "deletions": 0,
        "changes": 201,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/870178bfb6cf36191cfd1f54854639bd8e1adc64/contrib/zmq/zmq_sub.go",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/870178bfb6cf36191cfd1f54854639bd8e1adc64/contrib/zmq/zmq_sub.go",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.go?ref=870178bfb6cf36191cfd1f54854639bd8e1adc64",
        "patch": "@@ -0,0 +1,201 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// Example client code making use of Bitcoin's ZMQ pubsub functionality. Only specialized handling\n+// for blockhash is implemented, which retrieves the raw block over RPC and then prints it.\n+//\n+// You can test this by starting bitcoind on regtest\n+//\n+//   ./src/bitcoind -zmqpubhashblock=tcp://127.0.0.1:38332 -rpcuser=foo -rpcpassword=bar -regtest -debug=1\n+//\n+// and running this script with\n+//\n+//   go get github.com/btcsuite/btcd\n+//   go get github.com/pebbe/zmq4\n+//   BTC_USER=foo BTC_PASS=bar BTC_RPCPORT=18443 ZMQ_ENDPOINT=tcp://127.0.0.1:38332 go run zmq_sub.go\n+//\n+// then generating some blocks with\n+//\n+//   ./src/bitcoin-cli -regtest -rpcuser=foo -rpcpassword=bar generate 1\n+//\n+\n+package main\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\n+\t\"github.com/btcsuite/btcd/chaincfg/chainhash\"\n+\t\"github.com/btcsuite/btcd/rpcclient\"\n+\t\"github.com/btcsuite/btcd/wire\"\n+\tzmq \"github.com/pebbe/zmq4\"\n+)\n+\n+var rpc *rpcclient.Client\n+\n+// The ZMQ address to subscribe to.\n+var zmqEndpointStr = getEnv(\"ZMQ_ENDPOINT\", \"tcp://127.0.0.1:28332\")\n+\n+// The Bitcoin host address (for use by RPC)\n+var btcHost = getEnv(\"BTC_HOST\", \"127.0.0.1\")\n+\n+// The Bitcoin RPC port\n+var btcRPCPort = getEnv(\"BTC_RPCPORT\", \"8332\")\n+\n+// The Bitcoin RPC username\n+var btcRPCUser = os.Getenv(\"BTC_USER\")\n+\n+// The Bitcoin RPC password\n+var btcRPCPass = os.Getenv(\"BTC_PASS\")\n+\n+// Return the value of an environment variable if it's defined, otherwise return fallback.\n+func getEnv(key, fallback string) string {\n+\tif value, found := os.LookupEnv(key); found {\n+\t\treturn value\n+\t}\n+\treturn fallback\n+}\n+\n+// Listen for Bitcoin notifications over ZMQ. Push matching messages into the provided channels\n+// upon receipt.\n+func listenForNotification(\n+\tnotifyBlockHash chan<- string,\n+\tnotifyBlockRaw chan<- string,\n+\tnotifyTxHash chan<- string,\n+\tnotifyTxRaw chan<- string,\n+\tquit <-chan bool,\n+) {\n+\tsubscriber, _ := zmq.NewSocket(zmq.SUB)\n+\tdefer subscriber.Close()\n+\tsubscriber.Connect(zmqEndpointStr)\n+\n+\tlog.Printf(\"Listening for zmq notifications on %s\\n\", zmqEndpointStr)\n+\n+\t// Optionally filter by message type\n+\t//\n+\t// subscriber.SetSubscribe(\"hashblock\")\n+\t//\n+\tsubscriber.SetSubscribe(\"\")\n+\n+\tnewmsg := make(chan [][]byte)\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tmsg, err := subscriber.RecvMessageBytes(0)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tnewmsg <- msg\n+\t\t}\n+\t}()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase msg := <-newmsg:\n+\t\t\tmsgType := string(msg[0])\n+\t\t\tencoded := hex.EncodeToString(msg[1])\n+\n+\t\t\tswitch msgType {\n+\t\t\tcase \"hashblock\":\n+\t\t\t\tnotifyBlockHash <- encoded\n+\t\t\tcase \"hashtx\":\n+\t\t\t\tnotifyTxHash <- encoded\n+\t\t\tcase \"rawblock\":\n+\t\t\t\tnotifyBlockRaw <- encoded\n+\t\t\tcase \"rawtx\":\n+\t\t\t\tnotifyTxRaw <- encoded\n+\t\t\t}\n+\t\tcase <-quit:\n+\t\t\tlog.Println(\"stopping listenForNotification\")\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// Listen for blockhashes and when we get one, retrieve its raw format from RPC.\n+func handleBlockHash(recv <-chan string) {\n+\tfor {\n+\t\tblockhash, more := <-recv\n+\n+\t\tif more {\n+\t\t\tlog.Printf(\"retrieving block from rpc: %s\\n\", blockhash)\n+\t\t\tblock, err := getBlockFromRPC(blockhash)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Print(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// Likely you'd do something more interesting here.\n+\t\t\tlog.Print(block)\n+\t\t} else {\n+\t\t\tlog.Println(\"stopping handleBlockHash\")\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// Listen for an event and print its payload.\n+func handleGeneric(recv <-chan string, name string) {\n+\tfor {\n+\t\tpayload, more := <-recv\n+\n+\t\tif more {\n+\t\t\tlog.Printf(\"got %s: %s\\n\", name, payload)\n+\t\t} else {\n+\t\t\tlog.Printf(\"stopping handleGeneric(%s)\\n\", name)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// Given a blockhash string, retrieve its raw block over RPC.\n+func getBlockFromRPC(blockhash string) (*wire.MsgBlock, error) {\n+\thash, err := chainhash.NewHashFromStr(blockhash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tblockMsg, err := rpc.GetBlock(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn blockMsg, nil\n+}\n+\n+func main() {\n+\tconnCfg := &rpcclient.ConnConfig{\n+\t\tHost:         fmt.Sprintf(\"%s:%s\", btcHost, btcRPCPort),\n+\t\tUser:         btcRPCUser,\n+\t\tPass:         btcRPCPass,\n+\t\tHTTPPostMode: true,\n+\t\tDisableTLS:   true,\n+\t}\n+\n+\tvar err error\n+\trpc, err = rpcclient.New(connCfg, nil)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer rpc.Shutdown()\n+\n+\tnotifyBlockHash := make(chan string)\n+\tnotifyTxHash := make(chan string)\n+\tnotifyBlockRaw := make(chan string)\n+\tnotifyTxRaw := make(chan string)\n+\tquit := make(chan bool)\n+\n+\tgo handleBlockHash(notifyBlockHash)\n+\tgo handleGeneric(notifyBlockRaw, \"rawblock\")\n+\tgo handleGeneric(notifyTxHash, \"hashtx\")\n+\tgo handleGeneric(notifyTxRaw, \"rawtx\")\n+\n+\tlistenForNotification(\n+\t\tnotifyBlockHash,\n+\t\tnotifyBlockRaw,\n+\t\tnotifyTxHash,\n+\t\tnotifyTxRaw,\n+\t\tquit,\n+\t)\n+}"
      }
    ]
  }
]