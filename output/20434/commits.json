[
  {
    "sha": "634f6ec4eb9997d7bd0f8209fad49a4171d42384",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MzRmNmVjNGViOTk5N2Q3YmQwZjgyMDlmYWQ0OWE0MTcxZDQyMzg0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2020-11-20T08:15:44Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2020-11-22T10:11:32Z"
      },
      "message": "contrib: Parse ELF directly for symbol and security checks\n\nInstead of the ever-messier text parsing of the output of the readelf\ntool (which is clearly meant for human consumption not to be machine\nparseable), parse the ELF binaries directly.\n\nAdd a small dependency-less ELF parser specific to the checks.\n\nThis is slightly more secure, too, because it removes potential\nambiguity due to misparsing and changes in the output format of `elfread`. It\nalso allows for stricter and more specific ELF format checks in the future.\n\nThis removes the build-time dependency for `readelf`.\n\nIt passes the test-security-check for me locally, though I haven't\nchecked on all platforms.",
      "tree": {
        "sha": "0c9e1de57c164790c4b6cc8397c6c8ce0117b983",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c9e1de57c164790c4b6cc8397c6c8ce0117b983"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/634f6ec4eb9997d7bd0f8209fad49a4171d42384",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/634f6ec4eb9997d7bd0f8209fad49a4171d42384",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/634f6ec4eb9997d7bd0f8209fad49a4171d42384",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/634f6ec4eb9997d7bd0f8209fad49a4171d42384/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fdd068507d2694137d72638d87ea961e6f16a753",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdd068507d2694137d72638d87ea961e6f16a753",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fdd068507d2694137d72638d87ea961e6f16a753"
      }
    ],
    "stats": {
      "total": 582,
      "additions": 413,
      "deletions": 169
    },
    "files": [
      {
        "sha": "76dc0dd10aab08ff689962684150ca8f4ac6e5d3",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634f6ec4eb9997d7bd0f8209fad49a4171d42384/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634f6ec4eb9997d7bd0f8209fad49a4171d42384/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "patch": "@@ -52,7 +52,8 @@ DIST_SHARE = \\\n   $(top_srcdir)/share/rpcauth\n \n BIN_CHECKS=$(top_srcdir)/contrib/devtools/symbol-check.py \\\n-           $(top_srcdir)/contrib/devtools/security-check.py\n+           $(top_srcdir)/contrib/devtools/security-check.py \\\n+           $(top_srcdir)/contrib/devtools/pixie.py\n \n WINDOWS_PACKAGING = $(top_srcdir)/share/pixmaps/bitcoin.ico \\\n   $(top_srcdir)/share/pixmaps/nsis-header.bmp \\"
      },
      {
        "sha": "cc2801e97eec58104553b2da33a43d2cb923dee2",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634f6ec4eb9997d7bd0f8209fad49a4171d42384/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634f6ec4eb9997d7bd0f8209fad49a4171d42384/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "patch": "@@ -104,7 +104,6 @@ AC_PATH_PROG([GIT], [git])\n AC_PATH_PROG(CCACHE,ccache)\n AC_PATH_PROG(XGETTEXT,xgettext)\n AC_PATH_PROG(HEXDUMP,hexdump)\n-AC_PATH_TOOL(READELF, readelf)\n AC_PATH_TOOL(CPPFILT, c++filt)\n AC_PATH_TOOL(OBJCOPY, objcopy)\n AC_PATH_PROG(DOXYGEN, doxygen)"
      },
      {
        "sha": "8cf06a799a7e6b1277b7cd79e64830efee971429",
        "filename": "contrib/devtools/pixie.py",
        "status": "added",
        "additions": 323,
        "deletions": 0,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634f6ec4eb9997d7bd0f8209fad49a4171d42384/contrib/devtools/pixie.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634f6ec4eb9997d7bd0f8209fad49a4171d42384/contrib/devtools/pixie.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/pixie.py?ref=634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "patch": "@@ -0,0 +1,323 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 Wladimir J. van der Laan\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+'''\n+Compact, self-contained ELF implementation for bitcoin-core security checks.\n+'''\n+import struct\n+import types\n+from typing import Dict, List, Optional, Union, Tuple\n+\n+# you can find all these values in elf.h\n+EI_NIDENT = 16\n+\n+# Byte indices in e_ident\n+EI_CLASS = 4 # ELFCLASSxx\n+EI_DATA = 5  # ELFDATAxxxx\n+\n+ELFCLASS32 = 1 # 32-bit\n+ELFCLASS64 = 2 # 64-bit\n+\n+ELFDATA2LSB = 1 # little endian\n+ELFDATA2MSB = 2 # big endian\n+\n+# relevant values for e_machine\n+EM_386 = 3\n+EM_PPC64 = 21\n+EM_ARM = 40\n+EM_AARCH64 = 183\n+EM_X86_64 = 62\n+EM_RISCV = 243\n+\n+# relevant values for e_type\n+ET_DYN = 3\n+\n+# relevant values for sh_type\n+SHT_PROGBITS = 1\n+SHT_STRTAB = 3\n+SHT_DYNAMIC = 6\n+SHT_DYNSYM = 11\n+SHT_GNU_verneed = 0x6ffffffe\n+SHT_GNU_versym = 0x6fffffff\n+\n+# relevant values for p_type\n+PT_LOAD = 1\n+PT_GNU_STACK = 0x6474e551\n+PT_GNU_RELRO = 0x6474e552\n+\n+# relevant values for p_flags\n+PF_X = (1 << 0)\n+PF_W = (1 << 1)\n+PF_R = (1 << 2)\n+\n+# relevant values for d_tag\n+DT_NEEDED = 1\n+DT_FLAGS = 30\n+\n+# relevant values of `d_un.d_val' in the DT_FLAGS entry\n+DF_BIND_NOW = 0x00000008\n+\n+# relevant d_tags with string payload\n+STRING_TAGS = {DT_NEEDED}\n+\n+# rrlevant values for ST_BIND subfield of st_info (symbol binding)\n+STB_LOCAL = 0\n+\n+class ELFRecord(types.SimpleNamespace):\n+    '''Unified parsing for ELF records.'''\n+    def __init__(self, data: bytes, offset: int, eh: 'ELFHeader', total_size: Optional[int]) -> None:\n+        hdr_struct = self.STRUCT[eh.ei_class][0][eh.ei_data]\n+        if total_size is not None and hdr_struct.size > total_size:\n+            raise ValueError(f'{self.__class__.__name__} header size too small ({total_size} < {hdr_struct.size})')\n+        for field, value in zip(self.STRUCT[eh.ei_class][1], hdr_struct.unpack(data[offset:offset + hdr_struct.size])):\n+            setattr(self, field, value)\n+\n+def BiStruct(chars: str) -> Dict[int, struct.Struct]:\n+    '''Compile a struct parser for both endians.'''\n+    return {\n+        ELFDATA2LSB: struct.Struct('<' + chars),\n+        ELFDATA2MSB: struct.Struct('>' + chars),\n+    }\n+\n+class ELFHeader(ELFRecord):\n+    FIELDS = ['e_type', 'e_machine', 'e_version', 'e_entry', 'e_phoff', 'e_shoff', 'e_flags', 'e_ehsize', 'e_phentsize', 'e_phnum', 'e_shentsize', 'e_shnum', 'e_shstrndx']\n+    STRUCT = {\n+        ELFCLASS32: (BiStruct('HHIIIIIHHHHHH'), FIELDS),\n+        ELFCLASS64: (BiStruct('HHIQQQIHHHHHH'), FIELDS),\n+    }\n+\n+    def __init__(self, data: bytes, offset: int) -> None:\n+        self.e_ident = data[offset:offset + EI_NIDENT]\n+        if self.e_ident[0:4] != b'\\x7fELF':\n+            raise ValueError('invalid ELF magic')\n+        self.ei_class = self.e_ident[EI_CLASS]\n+        self.ei_data = self.e_ident[EI_DATA]\n+\n+        super().__init__(data, offset + EI_NIDENT, self, None)\n+\n+    def __repr__(self) -> str:\n+        return f'Header(e_ident={self.e_ident!r}, e_type={self.e_type}, e_machine={self.e_machine}, e_version={self.e_version}, e_entry={self.e_entry}, e_phoff={self.e_phoff}, e_shoff={self.e_shoff}, e_flags={self.e_flags}, e_ehsize={self.e_ehsize}, e_phentsize={self.e_phentsize}, e_phnum={self.e_phnum}, e_shentsize={self.e_shentsize}, e_shnum={self.e_shnum}, e_shstrndx={self.e_shstrndx})'\n+\n+class Section(ELFRecord):\n+    name: Optional[bytes] = None\n+    FIELDS = ['sh_name', 'sh_type', 'sh_flags', 'sh_addr', 'sh_offset', 'sh_size', 'sh_link', 'sh_info', 'sh_addralign', 'sh_entsize']\n+    STRUCT = {\n+        ELFCLASS32: (BiStruct('IIIIIIIIII'), FIELDS),\n+        ELFCLASS64: (BiStruct('IIQQQQIIQQ'), FIELDS),\n+    }\n+\n+    def __init__(self, data: bytes, offset: int, eh: ELFHeader) -> None:\n+        super().__init__(data, offset, eh, eh.e_shentsize)\n+        self._data = data\n+\n+    def __repr__(self) -> str:\n+        return f'Section(sh_name={self.sh_name}({self.name!r}), sh_type=0x{self.sh_type:x}, sh_flags={self.sh_flags}, sh_addr=0x{self.sh_addr:x}, sh_offset=0x{self.sh_offset:x}, sh_size={self.sh_size}, sh_link={self.sh_link}, sh_info={self.sh_info}, sh_addralign={self.sh_addralign}, sh_entsize={self.sh_entsize})'\n+\n+    def contents(self) -> bytes:\n+        '''Return section contents.'''\n+        return self._data[self.sh_offset:self.sh_offset + self.sh_size]\n+\n+class ProgramHeader(ELFRecord):\n+    STRUCT = {\n+        # different ELF classes have the same fields, but in a different order to optimize space versus alignment\n+        ELFCLASS32: (BiStruct('IIIIIIII'), ['p_type', 'p_offset', 'p_vaddr', 'p_paddr', 'p_filesz', 'p_memsz', 'p_flags', 'p_align']),\n+        ELFCLASS64: (BiStruct('IIQQQQQQ'), ['p_type', 'p_flags', 'p_offset', 'p_vaddr', 'p_paddr', 'p_filesz', 'p_memsz', 'p_align']),\n+    }\n+\n+    def __init__(self, data: bytes, offset: int, eh: ELFHeader) -> None:\n+        super().__init__(data, offset, eh, eh.e_phentsize)\n+\n+    def __repr__(self) -> str:\n+        return f'ProgramHeader(p_type={self.p_type}, p_offset={self.p_offset}, p_vaddr={self.p_vaddr}, p_paddr={self.p_paddr}, p_filesz={self.p_filesz}, p_memsz={self.p_memsz}, p_flags={self.p_flags}, p_align={self.p_align})'\n+\n+class Symbol(ELFRecord):\n+    STRUCT = {\n+        # different ELF classes have the same fields, but in a different order to optimize space versus alignment\n+        ELFCLASS32: (BiStruct('IIIBBH'), ['st_name', 'st_value', 'st_size', 'st_info', 'st_other', 'st_shndx']),\n+        ELFCLASS64: (BiStruct('IBBHQQ'), ['st_name', 'st_info', 'st_other', 'st_shndx', 'st_value', 'st_size']),\n+    }\n+\n+    def __init__(self, data: bytes, offset: int, eh: ELFHeader, symtab: Section, strings: bytes, version: Optional[bytes]) -> None:\n+        super().__init__(data, offset, eh, symtab.sh_entsize)\n+        self.name = _lookup_string(strings, self.st_name)\n+        self.version = version\n+\n+    def __repr__(self) -> str:\n+        return f'Symbol(st_name={self.st_name}({self.name!r}), st_value={self.st_value}, st_size={self.st_size}, st_info={self.st_info}, st_other={self.st_other}, st_shndx={self.st_shndx}, version={self.version!r})'\n+\n+    @property\n+    def is_import(self) -> bool:\n+        '''Returns whether the symbol is an imported symbol.'''\n+        return self.st_bind != STB_LOCAL and self.st_shndx == 0\n+\n+    @property\n+    def is_export(self) -> bool:\n+        '''Returns whether the symbol is an exported symbol.'''\n+        return self.st_bind != STB_LOCAL and self.st_shndx != 0\n+\n+    @property\n+    def st_bind(self) -> int:\n+        '''Returns STB_*.'''\n+        return self.st_info >> 4\n+\n+class Verneed(ELFRecord):\n+    DEF = (BiStruct('HHIII'), ['vn_version', 'vn_cnt', 'vn_file', 'vn_aux', 'vn_next'])\n+    STRUCT = { ELFCLASS32: DEF, ELFCLASS64: DEF }\n+\n+    def __init__(self, data: bytes, offset: int, eh: ELFHeader) -> None:\n+        super().__init__(data, offset, eh, None)\n+\n+    def __repr__(self) -> str:\n+        return f'Verneed(vn_version={self.vn_version}, vn_cnt={self.vn_cnt}, vn_file={self.vn_file}, vn_aux={self.vn_aux}, vn_next={self.vn_next})'\n+\n+class Vernaux(ELFRecord):\n+    DEF = (BiStruct('IHHII'), ['vna_hash', 'vna_flags', 'vna_other', 'vna_name', 'vna_next'])\n+    STRUCT = { ELFCLASS32: DEF, ELFCLASS64: DEF }\n+\n+    def __init__(self, data: bytes, offset: int, eh: ELFHeader, strings: bytes) -> None:\n+        super().__init__(data, offset, eh, None)\n+        self.name = _lookup_string(strings, self.vna_name)\n+\n+    def __repr__(self) -> str:\n+        return f'Veraux(vna_hash={self.vna_hash}, vna_flags={self.vna_flags}, vna_other={self.vna_other}, vna_name={self.vna_name}({self.name!r}), vna_next={self.vna_next})'\n+\n+class DynTag(ELFRecord):\n+    STRUCT = {\n+        ELFCLASS32: (BiStruct('II'), ['d_tag', 'd_val']),\n+        ELFCLASS64: (BiStruct('QQ'), ['d_tag', 'd_val']),\n+    }\n+\n+    def __init__(self, data: bytes, offset: int, eh: ELFHeader, section: Section) -> None:\n+        super().__init__(data, offset, eh, section.sh_entsize)\n+\n+    def __repr__(self) -> str:\n+        return f'DynTag(d_tag={self.d_tag}, d_val={self.d_val})'\n+\n+def _lookup_string(data: bytes, index: int) -> bytes:\n+    '''Look up string by offset in ELF string table.'''\n+    endx = data.find(b'\\x00', index)\n+    assert endx != -1\n+    return data[index:endx]\n+\n+VERSYM_S = BiStruct('H') # .gnu_version section has a single 16-bit integer per symbol in the linked section\n+def _parse_symbol_table(section: Section, strings: bytes, eh: ELFHeader, versym: bytes, verneed: Dict[int, bytes]) -> List[Symbol]:\n+    '''Parse symbol table, return a list of symbols.'''\n+    data = section.contents()\n+    symbols = []\n+    versym_iter = (verneed.get(v[0]) for v in VERSYM_S[eh.ei_data].iter_unpack(versym))\n+    for ofs, version in zip(range(0, len(data), section.sh_entsize), versym_iter):\n+        symbols.append(Symbol(data, ofs, eh, section, strings, version))\n+    return symbols\n+\n+def _parse_verneed(section: Section, strings: bytes, eh: ELFHeader) -> Dict[int, bytes]:\n+    '''Parse .gnu.version_r section, return a dictionary of {versym: 'GLIBC_...'}.'''\n+    data = section.contents()\n+    ofs = 0\n+    result = {}\n+    while True:\n+        verneed = Verneed(data, ofs, eh)\n+        aofs = verneed.vn_aux\n+        while True:\n+            vernaux = Vernaux(data, aofs, eh, strings)\n+            result[vernaux.vna_other] = vernaux.name\n+            if not vernaux.vna_next:\n+                break\n+            aofs += vernaux.vna_next\n+\n+        if not verneed.vn_next:\n+            break\n+        ofs += verneed.vn_next\n+\n+    return result\n+\n+def _parse_dyn_tags(section: Section, strings: bytes, eh: ELFHeader) -> List[Tuple[int, Union[bytes, int]]]:\n+    '''Parse dynamic tags. Return array of tuples.'''\n+    data = section.contents()\n+    ofs = 0\n+    result = []\n+    for ofs in range(0, len(data), section.sh_entsize):\n+        tag = DynTag(data, ofs, eh, section)\n+        val = _lookup_string(strings, tag.d_val) if tag.d_tag in STRING_TAGS else tag.d_val\n+        result.append((tag.d_tag, val))\n+\n+    return result\n+\n+class ELFFile:\n+    sections: List[Section]\n+    program_headers: List[ProgramHeader]\n+    dyn_symbols: List[Symbol]\n+    dyn_tags: List[Tuple[int, Union[bytes, int]]]\n+\n+    def __init__(self, data: bytes) -> None:\n+        self.data = data\n+        self.hdr = ELFHeader(self.data, 0)\n+        self._load_sections()\n+        self._load_program_headers()\n+        self._load_dyn_symbols()\n+        self._load_dyn_tags()\n+        self._section_to_segment_mapping()\n+\n+    def _load_sections(self) -> None:\n+        self.sections = []\n+        for idx in range(self.hdr.e_shnum):\n+            offset = self.hdr.e_shoff + idx * self.hdr.e_shentsize\n+            self.sections.append(Section(self.data, offset, self.hdr))\n+\n+        shstr = self.sections[self.hdr.e_shstrndx].contents()\n+        for section in self.sections:\n+            section.name = _lookup_string(shstr, section.sh_name)\n+\n+    def _load_program_headers(self) -> None:\n+        self.program_headers = []\n+        for idx in range(self.hdr.e_phnum):\n+            offset = self.hdr.e_phoff + idx * self.hdr.e_phentsize\n+            self.program_headers.append(ProgramHeader(self.data, offset, self.hdr))\n+\n+    def _load_dyn_symbols(self) -> None:\n+        # first, load 'verneed' section\n+        verneed = None\n+        for section in self.sections:\n+            if section.sh_type == SHT_GNU_verneed:\n+                strtab = self.sections[section.sh_link].contents() # associated string table\n+                assert verneed is None # only one section of this kind please\n+                verneed = _parse_verneed(section, strtab, self.hdr)\n+        assert verneed is not None\n+\n+        # then, correlate GNU versym sections with dynamic symbol sections\n+        versym = {}\n+        for section in self.sections:\n+            if section.sh_type == SHT_GNU_versym:\n+                versym[section.sh_link] = section\n+\n+        # finally, load dynsym sections\n+        self.dyn_symbols = []\n+        for idx, section in enumerate(self.sections):\n+            if section.sh_type == SHT_DYNSYM: # find dynamic symbol tables\n+                strtab_data = self.sections[section.sh_link].contents() # associated string table\n+                versym_data = versym[idx].contents() # associated symbol version table\n+                self.dyn_symbols += _parse_symbol_table(section, strtab_data, self.hdr, versym_data, verneed)\n+\n+    def _load_dyn_tags(self) -> None:\n+        self.dyn_tags = []\n+        for idx, section in enumerate(self.sections):\n+            if section.sh_type == SHT_DYNAMIC: # find dynamic tag tables\n+                strtab = self.sections[section.sh_link].contents() # associated string table\n+                self.dyn_tags += _parse_dyn_tags(section, strtab, self.hdr)\n+\n+    def _section_to_segment_mapping(self) -> None:\n+        for ph in self.program_headers:\n+            ph.sections = []\n+            for section in self.sections:\n+                if ph.p_vaddr <= section.sh_addr < (ph.p_vaddr + ph.p_memsz):\n+                    ph.sections.append(section)\n+\n+    def query_dyn_tags(self, tag_in: int) -> List[Union[int, bytes]]:\n+        '''Return the values of all dyn tags with the specified tag.'''\n+        return [val for (tag, val) in self.dyn_tags if tag == tag_in]\n+\n+\n+def load(filename: str) -> ELFFile:\n+    with open(filename, 'rb') as f:\n+        data = f.read()\n+    return ELFFile(data)"
      },
      {
        "sha": "a7eb7f429b40e17690ed1ce16ae5f91ab5525bd3",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 59,
        "deletions": 111,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634f6ec4eb9997d7bd0f8209fad49a4171d42384/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634f6ec4eb9997d7bd0f8209fad49a4171d42384/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "patch": "@@ -6,15 +6,15 @@\n Perform basic security checks on a series of executables.\n Exit status will be 0 if successful, and the program will be silent.\n Otherwise the exit status will be 1 and it will log which executables failed which checks.\n-Needs `readelf` (for ELF), `objdump` (for PE) and `otool` (for MACHO).\n+Needs `objdump` (for PE) and `otool` (for MACHO).\n '''\n import subprocess\n import sys\n import os\n-\n from typing import List, Optional\n \n-READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n+import pixie\n+\n OBJDUMP_CMD = os.getenv('OBJDUMP', '/usr/bin/objdump')\n OTOOL_CMD = os.getenv('OTOOL', '/usr/bin/otool')\n \n@@ -26,75 +26,20 @@ def check_ELF_PIE(executable) -> bool:\n     '''\n     Check for position independent executable (PIE), allowing for address space randomization.\n     '''\n-    stdout = run_command([READELF_CMD, '-h', '-W', executable])\n-\n-    ok = False\n-    for line in stdout.splitlines():\n-        tokens = line.split()\n-        if len(line)>=2 and tokens[0] == 'Type:' and tokens[1] == 'DYN':\n-            ok = True\n-    return ok\n-\n-def get_ELF_program_headers(executable):\n-    '''Return type and flags for ELF program headers'''\n-    stdout = run_command([READELF_CMD, '-l', '-W', executable])\n-\n-    in_headers = False\n-    headers = []\n-    for line in stdout.splitlines():\n-        if line.startswith('Program Headers:'):\n-            in_headers = True\n-            count = 0\n-        if line == '':\n-            in_headers = False\n-        if in_headers:\n-            if count == 1: # header line\n-                header = [x.strip() for x in line.split()]\n-                ofs_typ = header.index('Type')\n-                ofs_flags = header.index('Flg')\n-                # assert readelf output is what we expect\n-                if ofs_typ == -1 or ofs_flags == -1:\n-                    raise ValueError('Cannot parse elfread -lW output')\n-            elif count > 1:\n-                splitline = [x.strip() for x in line.split()]\n-                typ = splitline[ofs_typ]\n-                if not typ.startswith('[R'): # skip [Requesting ...]\n-                    splitline = [x.strip() for x in line.split()]\n-                    flags = splitline[ofs_flags]\n-                    # check for 'R', ' E'\n-                    if splitline[ofs_flags + 1] == 'E':\n-                        flags += ' E'\n-                    headers.append((typ, flags, []))\n-            count += 1\n-\n-        if line.startswith(' Section to Segment mapping:'):\n-            in_mapping = True\n-            count = 0\n-        if line == '':\n-            in_mapping = False\n-        if in_mapping:\n-            if count == 1: # header line\n-                ofs_segment = line.find('Segment')\n-                ofs_sections = line.find('Sections...')\n-                if ofs_segment == -1 or ofs_sections == -1:\n-                    raise ValueError('Cannot parse elfread -lW output')\n-            elif count > 1:\n-                segment = int(line[ofs_segment:ofs_sections].strip())\n-                sections = line[ofs_sections:].strip().split()\n-                headers[segment][2].extend(sections)\n-            count += 1\n-    return headers\n+    elf = pixie.load(executable)\n+    return elf.hdr.e_type == pixie.ET_DYN\n \n def check_ELF_NX(executable) -> bool:\n     '''\n     Check that no sections are writable and executable (including the stack)\n     '''\n+    elf = pixie.load(executable)\n     have_wx = False\n     have_gnu_stack = False\n-    for (typ, flags, _) in get_ELF_program_headers(executable):\n-        if typ == 'GNU_STACK':\n+    for ph in elf.program_headers:\n+        if ph.p_type == pixie.PT_GNU_STACK:\n             have_gnu_stack = True\n-        if 'W' in flags and 'E' in flags: # section is both writable and executable\n+        if (ph.p_flags & pixie.PF_W) != 0 and (ph.p_flags & pixie.PF_X) != 0: # section is both writable and executable\n             have_wx = True\n     return have_gnu_stack and not have_wx\n \n@@ -104,35 +49,34 @@ def check_ELF_RELRO(executable) -> bool:\n     GNU_RELRO program header must exist\n     Dynamic section must have BIND_NOW flag\n     '''\n+    elf = pixie.load(executable)\n     have_gnu_relro = False\n-    for (typ, flags, _) in get_ELF_program_headers(executable):\n-        # Note: not checking flags == 'R': here as linkers set the permission differently\n+    for ph in elf.program_headers:\n+        # Note: not checking p_flags == PF_R: here as linkers set the permission differently\n         # This does not affect security: the permission flags of the GNU_RELRO program\n         # header are ignored, the PT_LOAD header determines the effective permissions.\n         # However, the dynamic linker need to write to this area so these are RW.\n         # Glibc itself takes care of mprotecting this area R after relocations are finished.\n         # See also https://marc.info/?l=binutils&m=1498883354122353\n-        if typ == 'GNU_RELRO':\n+        if ph.p_type == pixie.PT_GNU_RELRO:\n             have_gnu_relro = True\n \n     have_bindnow = False\n-    stdout = run_command([READELF_CMD, '-d', '-W', executable])\n-\n-    for line in stdout.splitlines():\n-        tokens = line.split()\n-        if len(tokens)>1 and tokens[1] == '(BIND_NOW)' or (len(tokens)>2 and tokens[1] == '(FLAGS)' and 'BIND_NOW' in tokens[2:]):\n+    for flags in elf.query_dyn_tags(pixie.DT_FLAGS):\n+        assert isinstance(flags, int)\n+        if flags & pixie.DF_BIND_NOW:\n             have_bindnow = True\n+\n     return have_gnu_relro and have_bindnow\n \n def check_ELF_Canary(executable) -> bool:\n     '''\n     Check for use of stack canary\n     '''\n-    stdout = run_command([READELF_CMD, '--dyn-syms', '-W', executable])\n-\n+    elf = pixie.load(executable)\n     ok = False\n-    for line in stdout.splitlines():\n-        if '__stack_chk_fail' in line:\n+    for symbol in elf.dyn_symbols:\n+        if symbol.name == b'__stack_chk_fail':\n             ok = True\n     return ok\n \n@@ -142,48 +86,52 @@ def check_ELF_separate_code(executable):\n     based on their permissions. This checks for missing -Wl,-z,separate-code\n     and potentially other problems.\n     '''\n+    elf = pixie.load(executable)\n+    R = pixie.PF_R\n+    W = pixie.PF_W\n+    E = pixie.PF_X\n     EXPECTED_FLAGS = {\n         # Read + execute\n-        '.init': 'R E',\n-        '.plt': 'R E',\n-        '.plt.got': 'R E',\n-        '.plt.sec': 'R E',\n-        '.text': 'R E',\n-        '.fini': 'R E',\n+        b'.init': R | E,\n+        b'.plt': R | E,\n+        b'.plt.got': R | E,\n+        b'.plt.sec': R | E,\n+        b'.text': R | E,\n+        b'.fini': R | E,\n         # Read-only data\n-        '.interp': 'R',\n-        '.note.gnu.property': 'R',\n-        '.note.gnu.build-id': 'R',\n-        '.note.ABI-tag': 'R',\n-        '.gnu.hash': 'R',\n-        '.dynsym': 'R',\n-        '.dynstr': 'R',\n-        '.gnu.version': 'R',\n-        '.gnu.version_r': 'R',\n-        '.rela.dyn': 'R',\n-        '.rela.plt': 'R',\n-        '.rodata': 'R',\n-        '.eh_frame_hdr': 'R',\n-        '.eh_frame': 'R',\n-        '.qtmetadata': 'R',\n-        '.gcc_except_table': 'R',\n-        '.stapsdt.base': 'R',\n+        b'.interp': R,\n+        b'.note.gnu.property': R,\n+        b'.note.gnu.build-id': R,\n+        b'.note.ABI-tag': R,\n+        b'.gnu.hash': R,\n+        b'.dynsym': R,\n+        b'.dynstr': R,\n+        b'.gnu.version': R,\n+        b'.gnu.version_r': R,\n+        b'.rela.dyn': R,\n+        b'.rela.plt': R,\n+        b'.rodata': R,\n+        b'.eh_frame_hdr': R,\n+        b'.eh_frame': R,\n+        b'.qtmetadata': R,\n+        b'.gcc_except_table': R,\n+        b'.stapsdt.base': R,\n         # Writable data\n-        '.init_array': 'RW',\n-        '.fini_array': 'RW',\n-        '.dynamic': 'RW',\n-        '.got': 'RW',\n-        '.data': 'RW',\n-        '.bss': 'RW',\n+        b'.init_array': R | W,\n+        b'.fini_array': R | W,\n+        b'.dynamic': R | W,\n+        b'.got': R | W,\n+        b'.data': R | W,\n+        b'.bss': R | W,\n     }\n     # For all LOAD program headers get mapping to the list of sections,\n     # and for each section, remember the flags of the associated program header.\n     flags_per_section = {}\n-    for (typ, flags, sections) in get_ELF_program_headers(executable):\n-        if typ == 'LOAD':\n-            for section in sections:\n-                assert(section not in flags_per_section)\n-                flags_per_section[section] = flags\n+    for ph in elf.program_headers:\n+        if ph.p_type == pixie.PT_LOAD:\n+            for section in ph.sections:\n+                assert(section.name not in flags_per_section)\n+                flags_per_section[section.name] = ph.p_flags\n     # Spot-check ELF LOAD program header flags per section\n     # If these sections exist, check them against the expected R/W/E flags\n     for (section, flags) in flags_per_section.items():\n@@ -236,7 +184,7 @@ def check_PE_NX(executable) -> bool:\n def get_MACHO_executable_flags(executable) -> List[str]:\n     stdout = run_command([OTOOL_CMD, '-vh', executable])\n \n-    flags = []\n+    flags: List[str] = []\n     for line in stdout.splitlines():\n         tokens = line.split()\n         # filter first two header lines"
      },
      {
        "sha": "6ca5076d6fff942937e219d84ea0e8738e65accb",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 27,
        "deletions": 54,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634f6ec4eb9997d7bd0f8209fad49a4171d42384/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634f6ec4eb9997d7bd0f8209fad49a4171d42384/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "patch": "@@ -11,10 +11,11 @@\n     find ../gitian-builder/build -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n '''\n import subprocess\n-import re\n import sys\n import os\n-from typing import List, Optional, Tuple\n+from typing import List, Optional\n+\n+import pixie\n \n # Debian 8 (Jessie) EOL: 2020. https://wiki.debian.org/DebianReleases#Production_Releases\n #\n@@ -50,7 +51,6 @@\n '_edata', '_end', '__end__', '_init', '__bss_start', '__bss_start__', '_bss_end__', '__bss_end__', '_fini', '_IO_stdin_used', 'stdin', 'stdout', 'stderr',\n 'environ', '_environ', '__environ',\n }\n-READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n CPPFILT_CMD = os.getenv('CPPFILT', '/usr/bin/c++filt')\n OBJDUMP_CMD = os.getenv('OBJDUMP', '/usr/bin/objdump')\n OTOOL_CMD = os.getenv('OTOOL', '/usr/bin/otool')\n@@ -76,11 +76,11 @@\n 'libdl.so.2' # programming interface to dynamic linker\n }\n ARCH_MIN_GLIBC_VER = {\n-'80386':  (2,1),\n-'X86-64': (2,2,5),\n-'ARM':    (2,4),\n-'AArch64':(2,17),\n-'RISC-V': (2,27)\n+pixie.EM_386:    (2,1),\n+pixie.EM_X86_64: (2,2,5),\n+pixie.EM_ARM:    (2,4),\n+pixie.EM_AARCH64:(2,17),\n+pixie.EM_RISCV:  (2,27)\n }\n \n MACHO_ALLOWED_LIBRARIES = {\n@@ -140,29 +140,6 @@ def close(self):\n         self.proc.stdout.close()\n         self.proc.wait()\n \n-def read_symbols(executable, imports=True) -> List[Tuple[str, str, str]]:\n-    '''\n-    Parse an ELF executable and return a list of (symbol,version, arch) tuples\n-    for dynamic, imported symbols.\n-    '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', '-h', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n-    (stdout, stderr) = p.communicate()\n-    if p.returncode:\n-        raise IOError('Could not read symbols for {}: {}'.format(executable, stderr.strip()))\n-    syms = []\n-    for line in stdout.splitlines():\n-        line = line.split()\n-        if 'Machine:' in line:\n-            arch = line[-1]\n-        if len(line)>7 and re.match('[0-9]+:$', line[0]):\n-            (sym, _, version) = line[7].partition('@')\n-            is_import = line[6] == 'UND'\n-            if version.startswith('@'):\n-                version = version[1:]\n-            if is_import == imports:\n-                syms.append((sym, version, arch))\n-    return syms\n-\n def check_version(max_versions, version, arch) -> bool:\n     if '_' in version:\n         (lib, _, ver) = version.rpartition('_')\n@@ -174,46 +151,42 @@ def check_version(max_versions, version, arch) -> bool:\n         return False\n     return ver <= max_versions[lib] or lib == 'GLIBC' and ver <= ARCH_MIN_GLIBC_VER[arch]\n \n-def elf_read_libraries(filename) -> List[str]:\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n-    (stdout, stderr) = p.communicate()\n-    if p.returncode:\n-        raise IOError('Error opening file')\n-    libraries = []\n-    for line in stdout.splitlines():\n-        tokens = line.split()\n-        if len(tokens)>2 and tokens[1] == '(NEEDED)':\n-            match = re.match(r'^Shared library: \\[(.*)\\]$', ' '.join(tokens[2:]))\n-            if match:\n-                libraries.append(match.group(1))\n-            else:\n-                raise ValueError('Unparseable (NEEDED) specification')\n-    return libraries\n-\n def check_imported_symbols(filename) -> bool:\n+    elf = pixie.load(filename)\n     cppfilt = CPPFilt()\n     ok = True\n-    for sym, version, arch in read_symbols(filename, True):\n-        if version and not check_version(MAX_VERSIONS, version, arch):\n+\n+    for symbol in elf.dyn_symbols:\n+        if not symbol.is_import:\n+            continue\n+        sym = symbol.name.decode()\n+        version = symbol.version.decode() if symbol.version is not None else None\n+        if version and not check_version(MAX_VERSIONS, version, elf.hdr.e_machine):\n             print('{}: symbol {} from unsupported version {}'.format(filename, cppfilt(sym), version))\n             ok = False\n     return ok\n \n def check_exported_symbols(filename) -> bool:\n+    elf = pixie.load(filename)\n     cppfilt = CPPFilt()\n     ok = True\n-    for sym,version,arch in read_symbols(filename, False):\n-        if arch == 'RISC-V' or sym in IGNORE_EXPORTS:\n+    for symbol in elf.dyn_symbols:\n+        if not symbol.is_export:\n+            continue\n+        sym = symbol.name.decode()\n+        if elf.hdr.e_machine == pixie.EM_RISCV or sym in IGNORE_EXPORTS:\n             continue\n         print('{}: export of symbol {} not allowed'.format(filename, cppfilt(sym)))\n         ok = False\n     return ok\n \n def check_ELF_libraries(filename) -> bool:\n     ok = True\n-    for library_name in elf_read_libraries(filename):\n-        if library_name not in ELF_ALLOWED_LIBRARIES:\n-            print('{}: NEEDED library {} is not allowed'.format(filename, library_name))\n+    elf = pixie.load(filename)\n+    for library_name in elf.query_dyn_tags(pixie.DT_NEEDED):\n+        assert(isinstance(library_name, bytes))\n+        if library_name.decode() not in ELF_ALLOWED_LIBRARIES:\n+            print('{}: NEEDED library {} is not allowed'.format(filename, library_name.decode()))\n             ok = False\n     return ok\n "
      },
      {
        "sha": "8da754eee6350b6c2dc5a1a89bb67a88cd4b8f60",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/634f6ec4eb9997d7bd0f8209fad49a4171d42384/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/634f6ec4eb9997d7bd0f8209fad49a4171d42384/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "patch": "@@ -741,13 +741,13 @@ endif\n \n if GLIBC_BACK_COMPAT\n \t@echo \"Checking glibc back compat...\"\n-\t$(AM_V_at) READELF=$(READELF) CPPFILT=$(CPPFILT) $(PYTHON) $(top_srcdir)/contrib/devtools/symbol-check.py $(bin_PROGRAMS)\n+\t$(AM_V_at) CPPFILT=$(CPPFILT) $(PYTHON) $(top_srcdir)/contrib/devtools/symbol-check.py $(bin_PROGRAMS)\n endif\n \n check-security: $(bin_PROGRAMS)\n if HARDEN\n \t@echo \"Checking binary security...\"\n-\t$(AM_V_at) READELF=$(READELF) OBJDUMP=$(OBJDUMP) OTOOL=$(OTOOL) $(PYTHON) $(top_srcdir)/contrib/devtools/security-check.py $(bin_PROGRAMS)\n+\t$(AM_V_at) OBJDUMP=$(OBJDUMP) OTOOL=$(OTOOL) $(PYTHON) $(top_srcdir)/contrib/devtools/security-check.py $(bin_PROGRAMS)\n endif\n \n if EMBEDDED_LEVELDB"
      }
    ]
  },
  {
    "sha": "a0a771843fc39c3cc2574a51f009c3391e1808e9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMGE3NzE4NDNmYzM5YzNjYzI1NzRhNTFmMDA5YzMzOTFlMTgwOGU5",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2020-11-20T15:08:25Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@protonmail.com",
        "date": "2020-11-22T10:11:32Z"
      },
      "message": "contrib: Changes to checks for PowerPC64\n\nChanges from #14066.",
      "tree": {
        "sha": "3921af7e089724fd64b769391452d96aaec6a508",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3921af7e089724fd64b769391452d96aaec6a508"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a0a771843fc39c3cc2574a51f009c3391e1808e9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0a771843fc39c3cc2574a51f009c3391e1808e9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a0a771843fc39c3cc2574a51f009c3391e1808e9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0a771843fc39c3cc2574a51f009c3391e1808e9/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/634f6ec4eb9997d7bd0f8209fad49a4171d42384",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/634f6ec4eb9997d7bd0f8209fad49a4171d42384"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 6,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7b09c42fdec23b533605390941535ee8b0db4124",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0a771843fc39c3cc2574a51f009c3391e1808e9/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0a771843fc39c3cc2574a51f009c3391e1808e9/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=a0a771843fc39c3cc2574a51f009c3391e1808e9",
        "patch": "@@ -124,6 +124,9 @@ def check_ELF_separate_code(executable):\n         b'.data': R | W,\n         b'.bss': R | W,\n     }\n+    if elf.hdr.e_machine == pixie.EM_PPC64:\n+        # .plt is RW on ppc64 even with separate-code\n+        EXPECTED_FLAGS[b'.plt'] = R | W\n     # For all LOAD program headers get mapping to the list of sections,\n     # and for each section, remember the flags of the associated program header.\n     flags_per_section = {}"
      },
      {
        "sha": "91c7e325784ad897467b703f711648440d2dc7ee",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0a771843fc39c3cc2574a51f009c3391e1808e9/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0a771843fc39c3cc2574a51f009c3391e1808e9/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=a0a771843fc39c3cc2574a51f009c3391e1808e9",
        "patch": "@@ -68,6 +68,8 @@\n 'ld-linux.so.2', # 32-bit dynamic linker\n 'ld-linux-aarch64.so.1', # 64-bit ARM dynamic linker\n 'ld-linux-armhf.so.3', # 32-bit ARM dynamic linker\n+'ld64.so.1', # POWER64 ABIv1 dynamic linker\n+'ld64.so.2', # POWER64 ABIv2 dynamic linker\n 'ld-linux-riscv64-lp64d.so.1', # 64-bit RISC-V dynamic linker\n # bitcoin-qt only\n 'libxcb.so.1', # part of X11\n@@ -80,6 +82,7 @@\n pixie.EM_X86_64: (2,2,5),\n pixie.EM_ARM:    (2,4),\n pixie.EM_AARCH64:(2,17),\n+pixie.EM_PPC64:  (2,17),\n pixie.EM_RISCV:  (2,27)\n }\n "
      }
    ]
  }
]