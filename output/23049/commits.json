[
  {
    "sha": "3451106e23c17f9ee36ab7f801aaea85d409595d",
    "node_id": "C_kwDOABII59oAKDM0NTExMDZlMjNjMTdmOWVlMzZhYjdmODAxYWFlYTg1ZDQwOTU5NWQ",
    "commit": {
      "author": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-08-23T15:41:30Z"
      },
      "committer": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-09-21T15:45:42Z"
      },
      "message": "Add sv2 via guix",
      "tree": {
        "sha": "7849af53bbb884f5e18a5b3957cc6388d02de083",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7849af53bbb884f5e18a5b3957cc6388d02de083"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3451106e23c17f9ee36ab7f801aaea85d409595d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3451106e23c17f9ee36ab7f801aaea85d409595d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3451106e23c17f9ee36ab7f801aaea85d409595d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3451106e23c17f9ee36ab7f801aaea85d409595d/comments",
    "author": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2560b6862b405c72daa03630c463673c3252020d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2560b6862b405c72daa03630c463673c3252020d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2560b6862b405c72daa03630c463673c3252020d"
      }
    ],
    "stats": {
      "total": 10907,
      "additions": 10894,
      "deletions": 13
    },
    "files": [
      {
        "sha": "7829c3f323222a6f6360f77870074ec6b727b8c5",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -14,6 +14,16 @@ src/test/fuzz/fuzz\n src/test/test_bitcoin\n src/qt/test/test_bitcoin-qt\n \n+src/rusty/target\n+src/rusty/sv2-ffi/target\n+src/rusty/binary-sv2/binary-sv2/target\n+src/rusty/binary-sv2/no-serde-sv2/codec/target\n+src/rusty/binary-sv2/no-serde-sv2/derive_codec/target\n+src/rusty/framing-sv2/target\n+src/rusty/codec-sv2/target\n+src/rusty/subprotocols/common-messages/target\n+src/rusty/subprotocols/template-distribution/target\n+\n # autoreconf\n Makefile.in\n aclocal.m4"
      },
      {
        "sha": "f91e5525613da58bccc25c8a00f8c0479a884e4a",
        "filename": "contrib/guix/guix-build",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/contrib/guix/guix-build",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/contrib/guix/guix-build",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-build?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -1,4 +1,9 @@\n #!/usr/bin/env bash\n+\n+## Package all the rust code this step it likely wont be necessary as the rust code will be already\n+## packehed in a remote src or it will be already avaible as a guix package\n+./src/rusty/build-for-guix.sh\n+\n export LC_ALL=C\n set -e -o pipefail\n "
      },
      {
        "sha": "18a18274690a6f4403239d5c22d79cefc25135fe",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -89,6 +89,9 @@ case \"$HOST\" in\n         prepend_to_search_env_var OBJCPLUS_INCLUDE_PATH \"${zlib_store_path}/include\"\n esac\n \n+# TODO should use store_path\n+SV2_FFI_DIR=/gnu/store/`ls /gnu/store/ | grep rust-sv2` \n+\n # Set environment variables to point the CROSS toolchain to the right\n # includes/libs for $HOST\n case \"$HOST\" in\n@@ -252,6 +255,7 @@ esac\n \n # CXXFLAGS\n HOST_CXXFLAGS=\"$HOST_CFLAGS\"\n+HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -I ${SV2_FFI_DIR} ${SV2_FFI_DIR}/libsv2_ffi.a -lpthread -ldl\"\n \n case \"$HOST\" in\n     arm-linux-gnueabihf) HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -Wno-psabi\" ;;"
      },
      {
        "sha": "ed4ccd93d5971f558a51247320f6b222e5514da3",
        "filename": "contrib/guix/manifest.scm",
        "status": "modified",
        "additions": 566,
        "deletions": 0,
        "changes": 566,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/contrib/guix/manifest.scm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/contrib/guix/manifest.scm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/manifest.scm?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -1,3 +1,559 @@\n+;; REDEFINE CARGO WITH THE RIGHT VERSION\n+\n+(use-modules \n+  (guix search-paths)\n+  (guix store)\n+  (guix utils)\n+  (guix derivations)\n+  (guix packages)\n+  (guix build-system)\n+  (guix build-system gnu)\n+  (ice-9 match)\n+  (ice-9 vlist)\n+  (srfi srfi-1)\n+  (srfi srfi-26))\n+\n+(define %crate-base-url\n+  (make-parameter \"https://crates.io\"))\n+(define crate-url\n+  (string-append (%crate-base-url) \"/api/v1/crates/\"))\n+(define crate-url?\n+  (cut string-prefix? crate-url <>))\n+\n+(define (crate-uri name version)\n+  \"Return a URI string for the crate package hosted at crates.io corresponding\n+to NAME and VERSION.\"\n+  (string-append crate-url name \"/\" version \"/download\"))\n+\n+(define (default-rust)\n+  \"Return the default Rust package.\"\n+  ;; Lazily resolve the binding to avoid a circular dependency.\n+  (let ((rust (resolve-interface '(gnu packages rust))))\n+    (module-ref rust 'rust-1.51)))\n+\n+\n+(define %cargo-utils-modules\n+  ;; Build-side modules imported by default.\n+  `((guix build cargo-utils)\n+    ,@%gnu-build-system-modules))\n+\n+(define %cargo-build-system-modules\n+  ;; Build-side modules imported by default.\n+  `((guix build cargo-build-system)\n+    (guix build json)\n+    ,@%cargo-utils-modules))\n+\n+(define* (cargo-build store name inputs\n+                      #:key\n+                      (tests? #t)\n+                      (test-target #f)\n+                      (vendor-dir \"guix-vendor\")\n+                      (cargo-build-flags ''(\"--release\"))\n+                      (cargo-test-flags ''(\"--release\"))\n+                      (cargo-package-flags ''(\"--no-metadata\" \"--no-verify\"))\n+                      (features ''())\n+                      (skip-build? #f)\n+                      (install-source? #t)\n+                      (phases '(@ (guix build cargo-build-system)\n+                                  %standard-phases))\n+                      (outputs '(\"out\"))\n+                      (search-paths '())\n+                      (system (%current-system))\n+                      (guile #f)\n+                      (imported-modules %cargo-build-system-modules)\n+                      (modules '((guix build cargo-build-system)\n+                                 (guix build utils))))\n+  \"Build SOURCE using CARGO, and with INPUTS.\"\n+\n+  (define builder\n+    `(begin\n+       (use-modules ,@modules)\n+       (cargo-build #:name ,name\n+                    #:source ,(match (assoc-ref inputs \"source\")\n+                                (((? derivation? source))\n+                                 (derivation->output-path source))\n+                                ((source)\n+                                 source)\n+                                (source\n+                                 source))\n+                    #:system ,system\n+                    #:test-target ,test-target\n+                    #:vendor-dir ,vendor-dir\n+                    #:cargo-build-flags ,cargo-build-flags\n+                    #:cargo-test-flags ,cargo-test-flags\n+                    #:cargo-package-flags ,cargo-package-flags\n+                    #:features ,features\n+                    #:skip-build? ,skip-build?\n+                    #:install-source? ,install-source?\n+                    #:tests? ,(and tests? (not skip-build?))\n+                    #:phases ,phases\n+                    #:outputs %outputs\n+                    #:search-paths ',(map search-path-specification->sexp\n+                                          search-paths)\n+                    #:inputs %build-inputs)))\n+\n+  (define guile-for-build\n+    (match guile\n+      ((? package?)\n+       (package-derivation store guile system #:graft? #f))\n+      (#f                                         ; the default\n+       (let* ((distro (resolve-interface '(gnu packages commencement)))\n+              (guile  (module-ref distro 'guile-final)))\n+         (package-derivation store guile system #:graft? #f)))))\n+\n+  (build-expression->derivation store name builder\n+                                #:inputs inputs\n+                                #:system system\n+                                #:modules imported-modules\n+                                #:outputs outputs\n+                                #:guile-for-build guile-for-build))\n+\n+(define (package-cargo-inputs p)\n+  (apply\n+    (lambda* (#:key (cargo-inputs '()) #:allow-other-keys)\n+      cargo-inputs)\n+    (package-arguments p)))\n+\n+(define (package-cargo-development-inputs p)\n+  (apply\n+    (lambda* (#:key (cargo-development-inputs '()) #:allow-other-keys)\n+      cargo-development-inputs)\n+    (package-arguments p)))\n+\n+(define (crate-closure inputs)\n+  \"Return the closure of INPUTS when considering the 'cargo-inputs' and\n+'cargod-dev-deps' edges.  Omit duplicate inputs, except for those\n+already present in INPUTS itself.\n+\n+This is implemented as a breadth-first traversal such that INPUTS is\n+preserved, and only duplicate extracted inputs are removed.\n+\n+Forked from ((guix packages) transitive-inputs) since this extraction\n+uses slightly different rules compared to the rest of Guix (i.e. we\n+do not extract the conventional inputs).\"\n+  (define (seen? seen item)\n+    ;; FIXME: We're using pointer identity here, which is extremely sensitive\n+    ;; to memoization in package-producing procedures; see\n+    ;; <https://bugs.gnu.org/30155>.\n+    (vhash-assq item seen))\n+\n+  (let loop ((inputs     inputs)\n+             (result     '())\n+             (propagated '())\n+             (first?     #t)\n+             (seen       vlist-null))\n+    (match inputs\n+      (()\n+       (if (null? propagated)\n+           (reverse result)\n+           (loop (reverse (concatenate propagated)) result '() #f seen)))\n+      (((and input (label (? package? package))) rest ...)\n+       (if (and (not first?) (seen? seen package))\n+           (loop rest result propagated first? seen)\n+           (loop rest\n+                 (cons input result)\n+                 (cons (package-cargo-inputs package)\n+                       propagated)\n+                 first?\n+                 (vhash-consq package package seen))))\n+      ((input rest ...)\n+       (loop rest (cons input result) propagated first? seen)))))\n+\n+(define (expand-crate-sources cargo-inputs cargo-development-inputs)\n+  \"Extract all transitive sources for CARGO-INPUTS and CARGO-DEVELOPMENT-INPUTS\n+along their 'cargo-inputs' edges.\n+\n+Cargo requires all transitive crate dependencies' sources to be available\n+in its index, even if they are optional (this is so it can generate\n+deterministic Cargo.lock files regardless of the target platform or enabled\n+features). Thus we need all transitive crate dependencies for any cargo\n+dev-dependencies, but this is only needed when building/testing a crate directly\n+(i.e. we will never need transitive dev-dependencies for any dependency crates).\n+\n+Another complication arises due potential dependency cycles from Guix's\n+perspective: Although cargo does not permit cyclic dependencies between crates,\n+however, it permits cycles to occur via dev-dependencies. For example, if crate\n+X depends on crate Y, crate Y's tests could pull in crate X to to verify\n+everything builds properly (this is a rare scenario, but it it happens for\n+example with the `proc-macro2` and `quote` crates). This is allowed by cargo\n+because tests are built as a pseudo-crate which happens to depend on the\n+X and Y crates, forming an acyclic graph.\n+\n+We can side step this problem by only considering regular cargo dependencies\n+since they are guaranteed to not have cycles. We can further resolve any\n+potential dev-dependency cycles by extracting package sources (which never have\n+any dependencies and thus no cycles can exist).\n+\n+There are several implications of this decision:\n+* Building a package definition does not require actually building/checking\n+any dependent crates. This can be a benefits:\n+ - For example, sometimes a crate may have an optional dependency on some OS\n+ specific package which cannot be built or run on the current system. This\n+ approach means that the build will not fail if cargo ends up internally ignoring\n+ the dependency.\n+ - It avoids waiting for quadratic builds from source: cargo always builds\n+ dependencies within the current workspace. This is largely due to Rust not\n+ having a stable ABI and other resolutions that cargo applies. This means that\n+ if we have a depencency chain of X -> Y -> Z and we build each definition\n+ independently the following will happen:\n+  * Cargo will build and test crate Z\n+  * Cargo will build crate Z in Y's workspace, then build and test Y\n+  * Cargo will build crates Y and Z in X's workspace, then build and test X\n+* But there are also some downsides with this approach:\n+  - If a dependent crate is subtly broken on the system (i.e. it builds but its\n+  tests fail) the consuming crates may build and test successfully but\n+  actually fail during normal usage (however, the CI will still build all\n+  packages which will give visibility in case packages suddenly break).\n+  - Because crates aren't declared as regular inputs, other Guix facilities\n+  such as tracking package graphs may not work by default (however, this is\n+  something that can always be extended or reworked in the future).\"\n+  (filter-map\n+    (match-lambda\n+      ((label (? package? p))\n+       (list label (package-source p)))\n+      ((label input)\n+       (list label input)))\n+    (crate-closure (append cargo-inputs cargo-development-inputs))))\n+\n+(define* (lower name\n+                #:key source inputs native-inputs outputs system target\n+                (rust (default-rust))\n+                (cargo-inputs '())\n+                (cargo-development-inputs '())\n+                #:allow-other-keys\n+                #:rest arguments)\n+  \"Return a bag for NAME.\"\n+\n+  (define private-keywords\n+    '(#:source #:target #:rust #:inputs #:native-inputs #:outputs\n+      #:cargo-inputs #:cargo-development-inputs))\n+\n+  (and (not target) ;; TODO: support cross-compilation\n+       (bag\n+         (name name)\n+         (system system)\n+         (target target)\n+         (host-inputs `(,@(if source\n+                              `((\"source\" ,source))\n+                              '())\n+                        ,@inputs\n+\n+                        ;; Keep the standard inputs of 'gnu-build-system'\n+                        ,@(standard-packages)))\n+         (build-inputs `((\"cargo\" ,rust \"cargo\")\n+                         (\"rustc\" ,rust)\n+                         ,@(expand-crate-sources cargo-inputs cargo-development-inputs)\n+                         ,@native-inputs))\n+         (outputs outputs)\n+         (build cargo-build)\n+         (arguments (strip-keyword-arguments private-keywords arguments)))))\n+\n+(define cargo-build-system\n+  (build-system\n+    (name 'cargo)\n+    (description\n+     \"Cargo build system, to build Rust crates\")\n+    (lower lower)))\n+\n+;; COMPILE THE RUST PACKEGES\n+\n+(use-modules (gnu)\n+  (guix licenses)\n+  ;(guix build-system cargo2)\n+  (guix build-system copy)\n+  (guix download)\n+  (guix packages)\n+  (gnu packages bash)\n+  (gnu packages crates-io)\n+  (gnu packages rust-apps)\n+  (gnu packages crates-graphics)\n+  (gnu packages documentation)\n+  (gnu packages fontutils)\n+  (gnu packages version-control)\n+  (gnu packages file)\n+  (gnu packages linux)\n+  (gnu packages gawk)\n+  (gnu packages compression)\n+  (gnu packages autotools)\n+  (gnu packages gcc)\n+  (gnu packages pkg-config))\n+\n+\n+\n+(define-public rust-binary_codec_sv2-0.1.1\n+    (package\n+      (name \"rust-binary_codec_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/binary_codec_sv2-0.1.1.crate\")\n+         (sha256\n+          (base32 \"1d9nacfmb6ljp49690q63227l8k87j1h3y9hhb99bw5ispz8idbx\"))))\n+      (build-system cargo-build-system)\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+\n+(define-public rust-derive_codec_sv2-0.1.1\n+    (package\n+      (name \"rust-derive_codec_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/derive_codec_sv2-0.1.1.crate\")\n+         (sha256\n+          (base32 \"0vjy4dv7nvydf6i2nnaiwfvnsfrmkw1vbnmxc75rkp41syp76yqx\"))))\n+      (build-system cargo-build-system)\n+        (arguments\n+         `(\n+           #:cargo-inputs\n+           ((\"binary_codec_sv2\" , rust-binary_codec_sv2-0.1.1)\n+            )))\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+(define-public rust-binary_sv2-0.1.3\n+    (package\n+      (name \"rust-binary_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/binary_sv2-0.1.3.crate\")\n+         (sha256\n+          (base32 \"0nx6y8lsgmq14z9r43vw2paprn3xk1aq81zw1wwkgw9y13q426if\"))))\n+      (build-system cargo-build-system)\n+        (arguments\n+         `(\n+           #:skip-build? #t\n+           #:cargo-inputs\n+           (\n+            (\"binary_codec_sv2\" , rust-binary_codec_sv2-0.1.1)\n+            (\"derive_codec_sv2\" , rust-derive_codec_sv2-0.1.1)\n+            (\"rust-derive_codec_sv2\", rust-derive_codec_sv2-0.1.1 )\n+            )))\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+(define-public rust-const_sv2-0.1.0\n+    (package\n+      (name \"rust-const_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/const_sv2-0.1.0.crate\")\n+         (sha256\n+          (base32 \"1qgr8fpjza8dk7r60nrnaicyazz75w9a99yq34rsv6x8finyrbdi\"))))\n+      (build-system cargo-build-system)\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+(define-public rust-framing_sv2-0.1.3\n+    (package\n+      (name \"rust-framing_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/framing_sv2-0.1.3.crate\")\n+         (sha256\n+          (base32 \"06z8lw10a85cgbx8lw0v6wggddr7w0463vcc05h11rc57cjpbir6\"))))\n+      (build-system cargo-build-system)\n+        (arguments\n+         `(\n+           #:skip-build? #t\n+           #:cargo-inputs\n+           (\n+            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n+            (\"const_sv2\" , rust-const_sv2-0.1.0)\n+            )))\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+(define-public rust-codec_sv2-0.1.3\n+    (package\n+      (name \"rust-codec_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/codec_sv2-0.1.3.crate\")\n+         (sha256\n+          (base32 \"0c10bnpkh96k1m92yjmzxa3qhkpc2wc6kmpgv44v1zfkk016nxyp\"))))\n+      (build-system cargo-build-system)\n+        (arguments\n+         `(\n+           #:skip-build? #t\n+           #:cargo-inputs\n+           (\n+            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n+            (\"const_sv2\" , rust-const_sv2-0.1.0)\n+            (\"framing-sv2\" , rust-framing_sv2-0.1.3)\n+            )))\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+(define-public rust-common_messages_sv2-0.1.3\n+    (package\n+      (name \"rust-common_messages_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/common_messages_sv2-0.1.3.crate\")\n+         (sha256\n+          (base32 \"1wsyy44h3pirrb08brz9gr9g4mshxcpf37i557dxyz79c0gkl3lj\"))))\n+      (build-system cargo-build-system)\n+        (arguments\n+         `(\n+           #:skip-build? #t\n+           #:cargo-inputs\n+           (\n+            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n+            (\"const_sv2\" , rust-const_sv2-0.1.0)\n+            )))\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+(define-public rust-template_distribution_sv2-0.1.3\n+    (package\n+      (name \"rust-template_distribution_sv2\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/template_distribution_sv2-0.1.3.crate\")\n+         (sha256\n+          (base32 \"05dm5si3h09pz05vk7zlg0w0vrkiq5yh9gr043i472rny101x5ki\"))))\n+      (build-system cargo-build-system)\n+        (arguments\n+         `(\n+           #:skip-build? #t\n+           #:cargo-inputs\n+           (\n+            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n+            (\"const_sv2\" , rust-const_sv2-0.1.0)\n+            )))\n+\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+\n+(define-public rust-sv2_ffi-0.1.3\n+    (package\n+      (name \"rust-sv2_ffi\")\n+      (version \"0.1.0\")\n+      (source\n+       (origin\n+         (method url-fetch)\n+         (uri \"./src/rusty/target/package/sv2_ffi-0.1.3.crate\")\n+         (sha256\n+          (base32 \"01a6lj49hv9flxjqnjk01zza0664gj4mm4hh74wi2jch2mfi1yh5\"))))\n+      (build-system cargo-build-system)\n+      (arguments\n+       `(\n+         #:cargo-inputs\n+         (\n+          (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n+          (\"codec_sv2\" , rust-codec_sv2-0.1.3)\n+          (\"const_sv2\" , rust-const_sv2-0.1.0)\n+          (\"common-messages_sv2\" , rust-common_messages_sv2-0.1.3)\n+          (\"template-distribution_sv2\" , rust-template_distribution_sv2-0.1.3)\n+          )\n+         #:phases\n+         (modify-phases %standard-phases\n+              (replace 'install\n+                (lambda* (#:key inputs outputs skip-build? features install-source? #:allow-other-keys)\n+                  (let* ((out (assoc-ref outputs \"out\")))\n+                    (mkdir-p out)\n+                \n+                    (install-file \"./sv2.h\" out)\n+                    (install-file \"./target/release/libsv2_ffi.a\" out)\n+                  #true)))\n+              )\n+       ))\n+      (home-page \"..\")\n+      (synopsis \"..\")\n+      (description\n+       \"..\")\n+      (license gpl3+))\n+    )\n+\n+;;(packages->manifest\n+;; (append\n+;;  (list ;; The Basics\n+;;        bash\n+;;        which\n+;;        coreutils\n+;;        util-linux\n+;;        ;;; File(system) inspection\n+;;        file\n+;;        grep\n+;;        diffutils\n+;;        findutils\n+;;        ;;; File transformation\n+;;        patch\n+;;        gawk\n+;;        sed\n+;;        ;;; Compression and archiving\n+;;        tar\n+;;        bzip2\n+;;        gzip\n+;;        xz\n+;;        zlib\n+;;        ;;; Build tools\n+;;        gnu-make\n+;;        libtool\n+;;        autoconf\n+;;        automake\n+;;        pkg-config\n+;;        ;rust-sv2_example\n+;;        rust-binary_codec_sv2-0.1.1\n+;;        rust-derive_codec_sv2-0.1.1\n+;;        rust-binary_sv2-0.1.3\n+;;        rust-const_sv2-0.1.0\n+;;        rust-framing_sv2-0.1.3\n+;;        rust-codec_sv2-0.1.3\n+;;        rust-common_messages_sv2-0.1.3\n+;;        rust-template_distribution_sv2-0.1.3\n+;;        rust-sv2_ffi-0.1.3\n+;;        gcc\n+;;  )))\n+\n+;; ######################################3\n (use-modules (gnu)\n              (gnu packages)\n              (gnu packages autotools)\n@@ -637,6 +1193,16 @@ inspecting signatures in Mach-O binaries.\")\n         lief\n         ;; Native gcc 7 toolchain\n         gcc-toolchain-7\n+        ;; RUST\n+        rust-binary_codec_sv2-0.1.1\n+        rust-derive_codec_sv2-0.1.1\n+        rust-binary_sv2-0.1.3\n+        rust-const_sv2-0.1.0\n+        rust-framing_sv2-0.1.3\n+        rust-codec_sv2-0.1.3\n+        rust-common_messages_sv2-0.1.3\n+        rust-template_distribution_sv2-0.1.3\n+        rust-sv2_ffi-0.1.3\n         (list gcc-toolchain-7 \"static\"))\n   (let ((target (getenv \"HOST\")))\n     (cond ((string-suffix? \"-mingw32\" target)"
      },
      {
        "sha": "fc230482eea85c27f8b7f79f96220ffa315b0785",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 13,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -247,24 +247,66 @@ static bool AppInit(NodeContext& node, int argc, char* argv[])\n     return fRet;\n }\n \n+#include <sv2.h>\n+\n int main(int argc, char* argv[])\n {\n-#ifdef WIN32\n-    util::WinCmdLineArgs winArgs;\n-    std::tie(argc, argv) = winArgs.get();\n-#endif\n \n-    NodeContext node;\n-    int exit_status;\n-    std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node, argc, argv, exit_status);\n-    if (!init) {\n-        return exit_status;\n-    }\n+    EncoderWrapper * encoder = new_encoder();\n+\n+    const char* error = \"connection can not be created\";\n+    uint8_t* error_ = (uint8_t*) error;\n+  \n+    CVec error_code = cvec_from_buffer(error_, strlen(error));\n+    CSetupConnectionError message;\n+    message.flags = 0;\n+    message.error_code = error_code;\n+  \n+    CSv2Message response;\n+    response.tag = CSv2Message::Tag::SetupConnectionError;\n+    response.setup_connection_error._0 = message;\n+  \n+    CResult<CVec, Sv2Error> encoded = encode(&response, encoder);\n+    switch (encoded.tag) {\n+  \n+    case CResult < CVec, Sv2Error > ::Tag::Ok:\n+      tfm::format(std::cout, \"Ok \\n\");\n+      break;\n+    case CResult < CVec, Sv2Error > ::Tag::Err:\n+      tfm::format(std::cout, \"Err \\n\");\n+      break;\n+    };\n+\n+    CSv2Message response2;\n+    response.tag = CSv2Message::Tag::SetNewPrevHash;\n+    response.setup_connection_error._0 = message;\n+  \n+    CResult<CVec, Sv2Error> encoded2 = encode(&response2, encoder);\n+    switch (encoded2.tag) {\n+  \n+    case CResult < CVec, Sv2Error > ::Tag::Ok:\n+      tfm::format(std::cout, \"Ok \\n\");\n+      break;\n+    case CResult < CVec, Sv2Error > ::Tag::Err:\n+      tfm::format(std::cout, \"Err \\n\");\n+      break;\n+    };\n+//#ifdef WIN32\n+//    util::WinCmdLineArgs winArgs;\n+//    std::tie(argc, argv) = winArgs.get();\n+//#endif\n+\n+    //NodeContext node;\n+    //int exit_status;\n+    //std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node, argc, argv, exit_status);\n+    //if (!init) {\n+    //    return exit_status;\n+    //}\n \n-    SetupEnvironment();\n+    //SetupEnvironment();\n \n     // Connect bitcoind signal handlers\n-    noui_connect();\n+    //noui_connect();\n \n-    return (AppInit(node, argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n+    //return (AppInit(node, argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n }"
      },
      {
        "sha": "793af64d563d5dadd54bcd01498fd8fa28838587",
        "filename": "src/rusty/binary-sv2/binary-sv2/Cargo.toml",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/binary-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/binary-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/binary-sv2/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,20 @@\n+[package]\n+name = \"binary_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 data format\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde_sv2 = {version = \"0.1.0\", path = \"../serde-sv2\", optional = true}\n+serde = { version = \"1.0.89\", features = [\"derive\", \"alloc\"], default-features = false, optional = true }\n+binary_codec_sv2 = {version = \"0.1.1\", path = \"../no-serde-sv2/codec\", optional = true}\n+derive_codec_sv2 = {version = \"0.1.1\", path = \"../no-serde-sv2/derive_codec\", optional = true}\n+\n+[features]\n+default = [\"core\"]\n+core = [\"binary_codec_sv2\", \"derive_codec_sv2\"]\n+with_serde = [\"serde_sv2\", \"serde\"]"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/rusty/binary-sv2/binary-sv2/README.md",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/binary-sv2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/binary-sv2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/binary-sv2/README.md?ref=3451106e23c17f9ee36ab7f801aaea85d409595d"
      },
      {
        "sha": "d9b012ea4f09039f57924ced0af1f028e5bed835",
        "filename": "src/rusty/binary-sv2/binary-sv2/src/lib.rs",
        "status": "added",
        "additions": 687,
        "deletions": 0,
        "changes": 687,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/binary-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/binary-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/binary-sv2/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,687 @@\n+// TODO unify errors from serde_sv2 and no-serde-sv2\n+\n+#[cfg(feature = \"with_serde\")]\n+pub use serde::{self, Deserialize, Serialize};\n+#[cfg(feature = \"with_serde\")]\n+pub use serde_sv2::*;\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use binary_codec_sv2::{self, Decodable as Deserialize, Encodable as Serialize, *};\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use derive_codec_sv2::{Decodable as Deserialize, Encodable as Serialize};\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    mod test_bytes {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Bytes<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_struct() {\n+            let mut bytes = [98; 890];\n+            let a: Bytes = (&mut bytes[..]).try_into().unwrap();\n+            let expected = Test { a };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_struct {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test {\n+            a: u32,\n+            b: u8,\n+            c: U24,\n+        }\n+\n+        #[test]\n+        fn test_struct() {\n+            let expected = Test {\n+                a: 456,\n+                b: 9,\n+                c: 67_u32.try_into().unwrap(),\n+            };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_f32 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test {\n+            a: u8,\n+            b: U24,\n+            c: f32,\n+        }\n+\n+        #[test]\n+        fn test_struct() {\n+            let expected = Test {\n+                c: 0.345,\n+                a: 9,\n+                b: 67_u32.try_into().unwrap(),\n+            };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_str032 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Str032<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_stro32() {\n+            let mut stro32 = format!(\"error-code\").into_bytes();\n+            let stro32: Str032 = (&mut stro32[..]).try_into().unwrap();\n+\n+            let expected = Test { a: stro32 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_b0255 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: B0255<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_b0255() {\n+            let mut b0255 = [6; 3];\n+            let b0255: B0255 = (&mut b0255[..]).try_into().unwrap();\n+\n+            let expected = Test { a: b0255 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_u256 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: U256<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_u256() {\n+            let mut u256 = [6_u8; 32];\n+            let u256: U256 = (&mut u256[..]).try_into().unwrap();\n+\n+            let expected = Test { a: u256 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_signature {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Signature<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_signature() {\n+            let mut s = [6; 64];\n+            let s: Signature = (&mut s[..]).try_into().unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_b016m {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            b: bool,\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: B016M<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_b016m() {\n+            let mut b = [0_u8; 70000];\n+            let b: B016M = (&mut b[..]).try_into().unwrap();\n+            //println!(\"{:?}\", to_bytes(&b).unwrap().len());\n+\n+            let expected = Test { a: b, b: true };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_b064k {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            b: bool,\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: B064K<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_b064k() {\n+            let mut b = [1, 2, 9];\n+            let b: B064K = (&mut b[..])\n+                .try_into()\n+                .expect(\"vector smaller than 64K should not fail\");\n+\n+            let expected = Test { a: b, b: true };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq0255_u256 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, U256<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u256() {\n+            let mut u256_1 = [6; 32];\n+            let mut u256_2 = [5; 32];\n+            let mut u256_3 = [0; 32];\n+            let u256_1: U256 = (&mut u256_1[..]).try_into().unwrap();\n+            let u256_2: U256 = (&mut u256_2[..]).try_into().unwrap();\n+            let u256_3: U256 = (&mut u256_3[..]).try_into().unwrap();\n+\n+            let val = vec![u256_1, u256_2, u256_3];\n+            let s = Seq0255::new(val).unwrap();\n+\n+            let test = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(test.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&test.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let bytes_2 = to_bytes(deserialized.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let bytes_2 = to_bytes(&deserialized.clone()).unwrap();\n+\n+            assert_eq!(bytes, bytes_2);\n+        }\n+    }\n+\n+    mod test_0255_bool {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, bool>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_bool() {\n+            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq0255_u16 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, u16>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u16() {\n+            let s: Seq0255<u16> = Seq0255::new(vec![10, 43, 89]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq_0255_u24 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, U24>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u24() {\n+            let u24_1: U24 = 56_u32.try_into().unwrap();\n+            let u24_2: U24 = 59_u32.try_into().unwrap();\n+            let u24_3: U24 = 70999_u32.try_into().unwrap();\n+\n+            let val = vec![u24_1, u24_2, u24_3];\n+            let s: Seq0255<U24> = Seq0255::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seqo255_u32 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, u32>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u32() {\n+            let s: Seq0255<u32> = Seq0255::new(vec![546, 99999, 87, 32]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq0255_signature {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, Signature<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_signature() {\n+            let mut siganture_1 = [88_u8; 64];\n+            let mut siganture_2 = [99_u8; 64];\n+            let mut siganture_3 = [220_u8; 64];\n+            let siganture_1: Signature = (&mut siganture_1[..]).try_into().unwrap();\n+            let siganture_2: Signature = (&mut siganture_2[..]).try_into().unwrap();\n+            let siganture_3: Signature = (&mut siganture_3[..]).try_into().unwrap();\n+\n+            let val = vec![siganture_1, siganture_2, siganture_3];\n+            let s: Seq0255<Signature> = Seq0255::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq_064_u256 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, U256<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u256() {\n+            let mut u256_1 = [6; 32];\n+            let mut u256_2 = [5; 32];\n+            let mut u256_3 = [0; 32];\n+            let u256_1: U256 = (&mut u256_1[..]).try_into().unwrap();\n+            let u256_2: U256 = (&mut u256_2[..]).try_into().unwrap();\n+            let u256_3: U256 = (&mut u256_3[..]).try_into().unwrap();\n+\n+            let val = vec![u256_1, u256_2, u256_3];\n+            let s = Seq064K::new(val).unwrap();\n+\n+            let test = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(test.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&test.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let bytes_2 = to_bytes(deserialized.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let bytes_2 = to_bytes(&deserialized.clone()).unwrap();\n+\n+            assert_eq!(bytes, bytes_2);\n+        }\n+    }\n+\n+    mod test_064_bool {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, bool>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_bool() {\n+            let s: Seq064K<bool> = Seq064K::new(vec![true, false, true]).unwrap();\n+            let s2: Seq064K<bool> = Seq064K::new(vec![true; 64000]).unwrap();\n+\n+            let expected = Test { a: s };\n+            let expected2 = Test { a: s2 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes2 = to_bytes(expected2.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes2 = to_bytes(&expected2.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+            let deserialized2: Test = from_bytes(&mut bytes2[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+            assert_eq!(deserialized2, expected2);\n+        }\n+    }\n+\n+    mod test_se1o64k_u16 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, u16>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u16() {\n+            let s: Seq064K<u16> = Seq064K::new(vec![10, 43, 89]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq064k_u24 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, U24>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u24() {\n+            let u24_1: U24 = 56_u32.try_into().unwrap();\n+            let u24_2: U24 = 59_u32.try_into().unwrap();\n+            let u24_3: U24 = 70999_u32.try_into().unwrap();\n+\n+            let val = vec![u24_1, u24_2, u24_3];\n+            let s: Seq064K<U24> = Seq064K::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq064k_u32 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, u32>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u32() {\n+            let s: Seq064K<u32> = Seq064K::new(vec![546, 99999, 87, 32]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+    mod test_seq064k_signature {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, Signature<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_signature() {\n+            let mut siganture_1 = [88_u8; 64];\n+            let mut siganture_2 = [99_u8; 64];\n+            let mut siganture_3 = [220_u8; 64];\n+            let siganture_1: Signature = (&mut siganture_1[..]).try_into().unwrap();\n+            let siganture_2: Signature = (&mut siganture_2[..]).try_into().unwrap();\n+            let siganture_3: Signature = (&mut siganture_3[..]).try_into().unwrap();\n+\n+            let val = vec![siganture_1, siganture_2, siganture_3];\n+            let s: Seq064K<Signature> = Seq064K::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+    mod test_seq064k_b016m {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, B016M<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_b016m() {\n+            let mut bytes_1 = [88_u8; 64];\n+            let mut bytes_2 = [99_u8; 64];\n+            let mut bytes_3 = [220_u8; 64];\n+            let bytes_1: B016M = (&mut bytes_1[..]).try_into().unwrap();\n+            let bytes_2: B016M = (&mut bytes_2[..]).try_into().unwrap();\n+            let bytes_3: B016M = (&mut bytes_3[..]).try_into().unwrap();\n+\n+            let val = vec![bytes_1, bytes_2, bytes_3];\n+            let s: Seq064K<B016M> = Seq064K::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "79df158b51cd3b980e4aa4a9dd7d7b023eb046b8",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,5 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"binary_codec_sv2\"\n+version = \"0.1.1\""
      },
      {
        "sha": "99d0430c3bda1949186700dac4adfb2b5cd6395a",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,15 @@\n+[package]\n+name = \"binary_codec_sv2\"\n+version = \"0.1.1\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 data format\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n+[features]\n+no_std = []\n+deafult = [\"no_std\"]"
      },
      {
        "sha": "d3e5e6829ef9f54aead4f09105f641665f59274f",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "status": "added",
        "additions": 293,
        "deletions": 0,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,293 @@\n+use crate::codec::{GetSize, SizeHint};\n+use crate::datatypes::{Bytes, Signature, Sv2DataType, B016M, B0255, B032, B064K, U24, U256};\n+use crate::Error;\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Cursor, Read};\n+\n+/// Implmented by all the decodable structure, it can be derived for every structure composed only\n+/// by primitives or other Decodable.\n+pub trait Decodable<'a>: Sized {\n+    fn get_structure(data: &[u8]) -> Result<Vec<FieldMarker>, Error>;\n+\n+    fn from_decoded_fields(data: Vec<DecodableField<'a>>) -> Result<Self, Error>;\n+\n+    fn from_bytes(data: &'a mut [u8]) -> Result<Self, Error> {\n+        let structure = Self::get_structure(data)?;\n+        let mut fields = Vec::new();\n+        let mut tail = data;\n+\n+        for field in structure {\n+            let field_size = field.size_hint_(tail, 0)?;\n+            let (head, t) = tail.split_at_mut(field_size);\n+            tail = t;\n+            fields.push(field.decode(head)?);\n+        }\n+        Self::from_decoded_fields(fields)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader(reader: &mut impl Read) -> Result<Self, Error> {\n+        let mut data = Vec::new();\n+        reader.read_to_end(&mut data)?;\n+\n+        let structure = Self::get_structure(&data[..])?;\n+\n+        let mut fields = Vec::new();\n+        let mut reader = Cursor::new(data);\n+\n+        for field in structure {\n+            fields.push(field.from_reader(&mut reader)?);\n+        }\n+        Self::from_decoded_fields(fields)\n+    }\n+}\n+\n+/// Passed to a decoder to define the structure of the data to be decoded\n+#[derive(Debug, Clone, Copy)]\n+pub enum PrimitiveMarker {\n+    U8,\n+    U16,\n+    Bool,\n+    U24,\n+    U256,\n+    Signature,\n+    U32,\n+    F32,\n+    U64,\n+    B032,\n+    B0255,\n+    B064K,\n+    B016M,\n+    Bytes,\n+}\n+\n+/// Passed to a decoder to define the structure of the data to be decoded\n+#[derive(Debug, Clone)]\n+pub enum FieldMarker {\n+    Primitive(PrimitiveMarker),\n+    Struct(Vec<FieldMarker>),\n+}\n+pub trait GetMarker {\n+    fn get_marker() -> FieldMarker;\n+}\n+\n+/// Used to contrustuct primitives is returned by the decoder\n+#[derive(Debug)]\n+pub enum DecodablePrimitive<'a> {\n+    U8(u8),\n+    U16(u16),\n+    Bool(bool),\n+    U24(U24),\n+    U256(U256<'a>),\n+    Signature(Signature<'a>),\n+    U32(u32),\n+    F32(f32),\n+    U64(u64),\n+    B032(B032<'a>),\n+    B0255(B0255<'a>),\n+    B064K(B064K<'a>),\n+    B016M(B016M<'a>),\n+    Bytes(Bytes<'a>),\n+}\n+\n+/// Used to contrustuct messages is returned by the decoder\n+#[derive(Debug)]\n+pub enum DecodableField<'a> {\n+    Primitive(DecodablePrimitive<'a>),\n+    Struct(Vec<DecodableField<'a>>),\n+}\n+\n+impl SizeHint for PrimitiveMarker {\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        unimplemented!()\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        match self {\n+            Self::U8 => u8::size_hint(data, offset),\n+            Self::U16 => u16::size_hint(data, offset),\n+            Self::Bool => bool::size_hint(data, offset),\n+            Self::U24 => U24::size_hint(data, offset),\n+            Self::U256 => U256::size_hint(data, offset),\n+            Self::Signature => Signature::size_hint(data, offset),\n+            Self::U32 => u32::size_hint(data, offset),\n+            Self::F32 => f32::size_hint(data, offset),\n+            Self::U64 => u64::size_hint(data, offset),\n+            Self::B032 => B032::size_hint(data, offset),\n+            Self::B0255 => B0255::size_hint(data, offset),\n+            Self::B064K => B064K::size_hint(data, offset),\n+            Self::B016M => B016M::size_hint(data, offset),\n+            Self::Bytes => Bytes::size_hint(data, offset),\n+        }\n+    }\n+}\n+\n+impl SizeHint for FieldMarker {\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        unimplemented!()\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        match self {\n+            Self::Primitive(p) => p.size_hint_(data, offset),\n+            Self::Struct(ps) => {\n+                let mut size = 0;\n+                for p in ps {\n+                    size += p.size_hint_(data, offset + size)?;\n+                }\n+                Ok(size)\n+            }\n+        }\n+    }\n+}\n+\n+impl SizeHint for Vec<FieldMarker> {\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        unimplemented!()\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        let mut size = 0;\n+        for field in self {\n+            let field_size = field.size_hint_(data, offset + size)?;\n+            size += field_size;\n+        }\n+        Ok(size)\n+    }\n+}\n+\n+impl From<PrimitiveMarker> for FieldMarker {\n+    fn from(v: PrimitiveMarker) -> Self {\n+        FieldMarker::Primitive(v)\n+    }\n+}\n+\n+impl From<Vec<FieldMarker>> for FieldMarker {\n+    fn from(mut v: Vec<FieldMarker>) -> Self {\n+        match v.len() {\n+            0 => panic!(\"TODO\"),\n+            1 => v.pop().unwrap(),\n+            _ => FieldMarker::Struct(v),\n+        }\n+    }\n+}\n+\n+impl<'a> From<DecodableField<'a>> for Vec<DecodableField<'a>> {\n+    fn from(v: DecodableField<'a>) -> Self {\n+        match v {\n+            DecodableField::Primitive(p) => vec![DecodableField::Primitive(p)],\n+            DecodableField::Struct(ps) => ps,\n+        }\n+    }\n+}\n+\n+impl PrimitiveMarker {\n+    fn decode<'a>(&self, data: &'a mut [u8], offset: usize) -> DecodablePrimitive<'a> {\n+        match self {\n+            Self::U8 => DecodablePrimitive::U8(u8::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U16 => DecodablePrimitive::U16(u16::from_bytes_unchecked(&mut data[offset..])),\n+            Self::Bool => DecodablePrimitive::Bool(bool::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U24 => DecodablePrimitive::U24(U24::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U256 => DecodablePrimitive::U256(U256::from_bytes_unchecked(&mut data[offset..])),\n+            Self::Signature => {\n+                DecodablePrimitive::Signature(Signature::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::U32 => DecodablePrimitive::U32(u32::from_bytes_unchecked(&mut data[offset..])),\n+            Self::F32 => DecodablePrimitive::F32(f32::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U64 => DecodablePrimitive::U64(u64::from_bytes_unchecked(&mut data[offset..])),\n+            Self::B032 => DecodablePrimitive::B032(B032::from_bytes_unchecked(&mut data[offset..])),\n+            Self::B0255 => {\n+                DecodablePrimitive::B0255(B0255::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::B064K => {\n+                DecodablePrimitive::B064K(B064K::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::B016M => {\n+                DecodablePrimitive::B016M(B016M::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::Bytes => {\n+                DecodablePrimitive::Bytes(Bytes::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader<'a>(&self, reader: &mut impl Read) -> Result<DecodablePrimitive<'a>, Error> {\n+        match self {\n+            Self::U8 => Ok(DecodablePrimitive::U8(u8::from_reader_(reader)?)),\n+            Self::U16 => Ok(DecodablePrimitive::U16(u16::from_reader_(reader)?)),\n+            Self::Bool => Ok(DecodablePrimitive::Bool(bool::from_reader_(reader)?)),\n+            Self::U24 => Ok(DecodablePrimitive::U24(U24::from_reader_(reader)?)),\n+            Self::U256 => Ok(DecodablePrimitive::U256(U256::from_reader_(reader)?)),\n+            Self::Signature => Ok(DecodablePrimitive::Signature(Signature::from_reader_(\n+                reader,\n+            )?)),\n+            Self::U32 => Ok(DecodablePrimitive::U32(u32::from_reader_(reader)?)),\n+            Self::F32 => Ok(DecodablePrimitive::F32(f32::from_reader_(reader)?)),\n+            Self::U64 => Ok(DecodablePrimitive::U64(u64::from_reader_(reader)?)),\n+            Self::B032 => Ok(DecodablePrimitive::B032(B032::from_reader_(reader)?)),\n+            Self::B0255 => Ok(DecodablePrimitive::B0255(B0255::from_reader_(reader)?)),\n+            Self::B064K => Ok(DecodablePrimitive::B064K(B064K::from_reader_(reader)?)),\n+            Self::B016M => Ok(DecodablePrimitive::B016M(B016M::from_reader_(reader)?)),\n+            Self::Bytes => Ok(DecodablePrimitive::Bytes(Bytes::from_reader_(reader)?)),\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for DecodablePrimitive<'a> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            DecodablePrimitive::U8(v) => v.get_size(),\n+            DecodablePrimitive::U16(v) => v.get_size(),\n+            DecodablePrimitive::Bool(v) => v.get_size(),\n+            DecodablePrimitive::U24(v) => v.get_size(),\n+            DecodablePrimitive::U256(v) => v.get_size(),\n+            DecodablePrimitive::Signature(v) => v.get_size(),\n+            DecodablePrimitive::U32(v) => v.get_size(),\n+            DecodablePrimitive::F32(v) => v.get_size(),\n+            DecodablePrimitive::U64(v) => v.get_size(),\n+            DecodablePrimitive::B032(v) => v.get_size(),\n+            DecodablePrimitive::B0255(v) => v.get_size(),\n+            DecodablePrimitive::B064K(v) => v.get_size(),\n+            DecodablePrimitive::B016M(v) => v.get_size(),\n+            DecodablePrimitive::Bytes(v) => v.get_size(),\n+        }\n+    }\n+}\n+\n+impl FieldMarker {\n+    pub(crate) fn decode<'a>(&self, data: &'a mut [u8]) -> Result<DecodableField<'a>, Error> {\n+        match self {\n+            Self::Primitive(p) => Ok(DecodableField::Primitive(p.decode(data, 0))),\n+            Self::Struct(ps) => {\n+                let mut decodeds = Vec::new();\n+                let mut tail = data;\n+                for p in ps {\n+                    let field_size = p.size_hint_(tail, 0)?;\n+                    let (head, t) = tail.split_at_mut(field_size);\n+                    tail = t;\n+                    decodeds.push(p.decode(head)?);\n+                }\n+                Ok(DecodableField::Struct(decodeds))\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    pub(crate) fn from_reader<'a>(\n+        &self,\n+        reader: &mut impl Read,\n+    ) -> Result<DecodableField<'a>, Error> {\n+        match self {\n+            Self::Primitive(p) => Ok(DecodableField::Primitive(p.from_reader(reader)?)),\n+            Self::Struct(ps) => {\n+                let mut decodeds = Vec::new();\n+                for p in ps {\n+                    decodeds.push(p.from_reader(reader)?);\n+                }\n+                Ok(DecodableField::Struct(decodeds))\n+            }\n+        }\n+    }\n+}"
      },
      {
        "sha": "20b400562c6f1fd5c650dfdf6d75ed3bb457a957",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "status": "added",
        "additions": 165,
        "deletions": 0,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,165 @@\n+use crate::codec::GetSize;\n+use crate::datatypes::{Bytes, Signature, Sv2DataType, B016M, B0255, B032, B064K, U24, U256};\n+use crate::Error;\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Write};\n+\n+pub trait Encodable {\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_bytes(self, dst: &mut [u8]) -> Result<usize, Error>;\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_writer(self, dst: &mut impl Write) -> Result<(), E>;\n+}\n+\n+//\n+impl<'a, T: Into<EncodableField<'a>>> Encodable for T {\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_bytes(self, dst: &mut [u8]) -> Result<usize, Error> {\n+        let encoded_field = self.into();\n+        encoded_field.encode(dst, 0)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_writer(self, dst: &mut impl Write) -> Result<(), E> {\n+        let encoded_field = self.into();\n+        encoded_field.to_writer(dst)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum EncodablePrimitive<'a> {\n+    U8(u8),\n+    OwnedU8(u8),\n+    U16(u16),\n+    Bool(bool),\n+    U24(U24),\n+    U256(U256<'a>),\n+    Signature(Signature<'a>),\n+    U32(u32),\n+    F32(f32),\n+    U64(u64),\n+    B032(B032<'a>),\n+    B0255(B0255<'a>),\n+    B064K(B064K<'a>),\n+    B016M(B016M<'a>),\n+    Bytes(Bytes<'a>),\n+}\n+\n+impl<'a> EncodablePrimitive<'a> {\n+    fn encode(&self, dst: &mut [u8]) -> Result<usize, Error> {\n+        match self {\n+            Self::U8(v) => v.to_slice(dst),\n+            Self::OwnedU8(v) => v.to_slice(dst),\n+            Self::U16(v) => v.to_slice(dst),\n+            Self::Bool(v) => v.to_slice(dst),\n+            Self::U24(v) => v.to_slice(dst),\n+            Self::U256(v) => v.to_slice(dst),\n+            Self::Signature(v) => v.to_slice(dst),\n+            Self::U32(v) => v.to_slice(dst),\n+            Self::F32(v) => v.to_slice(dst),\n+            Self::U64(v) => v.to_slice(dst),\n+            Self::B032(v) => v.to_slice(dst),\n+            Self::B0255(v) => v.to_slice(dst),\n+            Self::B064K(v) => v.to_slice(dst),\n+            Self::B016M(v) => v.to_slice(dst),\n+            Self::Bytes(v) => v.to_slice(dst),\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    pub fn write(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            Self::U8(v) => v.to_writer_(writer),\n+            Self::OwnedU8(v) => v.to_writer_(writer),\n+            Self::U16(v) => v.to_writer_(writer),\n+            Self::Bool(v) => v.to_writer_(writer),\n+            Self::U24(v) => v.to_writer_(writer),\n+            Self::U256(v) => v.to_writer_(writer),\n+            Self::Signature(v) => v.to_writer_(writer),\n+            Self::U32(v) => v.to_writer_(writer),\n+            Self::F32(v) => v.to_writer_(writer),\n+            Self::U64(v) => v.to_writer_(writer),\n+            Self::B032(v) => v.to_writer_(writer),\n+            Self::B0255(v) => v.to_writer_(writer),\n+            Self::B064K(v) => v.to_writer_(writer),\n+            Self::B016M(v) => v.to_writer_(writer),\n+            Self::Bytes(v) => v.to_writer_(writer),\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for EncodablePrimitive<'a> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Self::U8(v) => v.get_size(),\n+            Self::OwnedU8(v) => v.get_size(),\n+            Self::U16(v) => v.get_size(),\n+            Self::Bool(v) => v.get_size(),\n+            Self::U24(v) => v.get_size(),\n+            Self::U256(v) => v.get_size(),\n+            Self::Signature(v) => v.get_size(),\n+            Self::U32(v) => v.get_size(),\n+            Self::F32(v) => v.get_size(),\n+            Self::U64(v) => v.get_size(),\n+            Self::B032(v) => v.get_size(),\n+            Self::B0255(v) => v.get_size(),\n+            Self::B064K(v) => v.get_size(),\n+            Self::B016M(v) => v.get_size(),\n+            Self::Bytes(v) => v.get_size(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum EncodableField<'a> {\n+    Primitive(EncodablePrimitive<'a>),\n+    Struct(Vec<EncodableField<'a>>),\n+}\n+\n+impl<'a> EncodableField<'a> {\n+    pub fn encode(&self, dst: &mut [u8], mut offset: usize) -> Result<usize, Error> {\n+        match (self, dst.len() >= offset) {\n+            (Self::Primitive(p), true) => p.encode(&mut dst[offset..]),\n+            (Self::Struct(ps), true) => {\n+                for p in ps {\n+                    let encoded_bytes = p.encode(dst, offset)?;\n+                    offset += encoded_bytes;\n+                }\n+                Ok(offset)\n+            }\n+            _ => Err(Error::WriteError(offset, dst.len())),\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    pub fn to_writer(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            Self::Primitive(p) => p.write(writer),\n+            Self::Struct(ps) => {\n+                for p in ps {\n+                    p.to_writer(writer)?;\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for EncodableField<'a> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Self::Primitive(p) => p.get_size(),\n+            Self::Struct(ps) => {\n+                let mut size = 0;\n+                for p in ps {\n+                    size += p.get_size();\n+                }\n+                size\n+            }\n+        }\n+    }\n+}"
      },
      {
        "sha": "a025b93d753effac312cf40066ea085234aeaf21",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "status": "added",
        "additions": 798,
        "deletions": 0,
        "changes": 798,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,798 @@\n+use crate::codec::decodable::{\n+    Decodable, DecodableField, DecodablePrimitive, FieldMarker, GetMarker, PrimitiveMarker,\n+};\n+use crate::codec::encodable::{EncodableField, EncodablePrimitive};\n+use crate::datatypes::*;\n+use crate::Error;\n+use alloc::vec::Vec;\n+use core::convert::{TryFrom, TryInto};\n+\n+// IMPL GET MARKER FOR PRIMITIVES\n+impl GetMarker for bool {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::Bool)\n+    }\n+}\n+impl GetMarker for u8 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U8)\n+    }\n+}\n+impl GetMarker for u16 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U16)\n+    }\n+}\n+impl GetMarker for U24 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U24)\n+    }\n+}\n+impl GetMarker for u32 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U32)\n+    }\n+}\n+impl GetMarker for f32 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::F32)\n+    }\n+}\n+impl GetMarker for u64 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U64)\n+    }\n+}\n+impl<'a> GetMarker for U256<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U256)\n+    }\n+}\n+impl<'a> GetMarker for Signature<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::Signature)\n+    }\n+}\n+impl<'a> GetMarker for B032<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B032)\n+    }\n+}\n+impl<'a> GetMarker for B0255<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B0255)\n+    }\n+}\n+impl<'a> GetMarker for B064K<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B064K)\n+    }\n+}\n+impl<'a> GetMarker for B016M<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B016M)\n+    }\n+}\n+impl<'a> GetMarker for Bytes<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::Bytes)\n+    }\n+}\n+\n+// IMPL DECODABLE FOR PRIMITIVES\n+\n+impl<'a> Decodable<'a> for u8 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U8.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for u16 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U16.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for u32 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U32.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for f32 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::F32.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for u64 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U64.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for bool {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::Bool.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for U24 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U24.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for U256<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U256.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for Signature<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::Signature.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B032<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B032.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B0255<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B0255.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B064K<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B064K.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B016M<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B016M.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+\n+impl<'a> Decodable<'a> for Bytes<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::Bytes.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+\n+// IMPL TRY_FROM PRIMITIVE FOR PRIMITIVEs\n+\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u8 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U8(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u16 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U16(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U32(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for f32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::F32(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u64 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U64(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for bool {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::Bool(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U24(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for U256<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U256(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for Signature<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::Signature(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B032<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B032(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B0255<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B0255(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B064K<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B064K(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B016M<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B016M(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for Bytes<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::Bytes(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+\n+// IMPL TRY_FROM DECODEC FIELD FOR PRIMITIVES\n+\n+impl<'a> TryFrom<DecodableField<'a>> for u8 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for u16 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for u32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for f32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for u64 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for bool {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for U256<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for Signature<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B032<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B0255<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B064K<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B016M<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for Bytes<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+\n+// IMPL FROM PRIMITIVES FOR ENCODED FIELD\n+\n+impl<'a> From<bool> for EncodableField<'a> {\n+    fn from(v: bool) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::Bool(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for bool {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::Bool(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u8> for EncodableField<'a> {\n+    fn from(v: u8) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U8(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u8 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U8(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u16> for EncodableField<'a> {\n+    fn from(v: u16) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U16(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u16 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U16(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<U24> for EncodableField<'a> {\n+    fn from(v: U24) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U24(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U24(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u32> for EncodableField<'a> {\n+    fn from(v: u32) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U32(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u32 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U32(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<f32> for EncodableField<'a> {\n+    fn from(v: f32) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::F32(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for f32 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::F32(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u64> for EncodableField<'a> {\n+    fn from(v: u64) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U64(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u64 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U64(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<U256<'a>> for EncodableField<'a> {\n+    fn from(v: U256<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U256(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for U256<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U256(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<Signature<'a>> for EncodableField<'a> {\n+    fn from(v: Signature<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::Signature(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for Signature<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::Signature(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<B032<'a>> for EncodableField<'a> {\n+    fn from(v: B032<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B032(v))\n+    }\n+}\n+impl<'a> From<B0255<'a>> for EncodableField<'a> {\n+    fn from(v: B0255<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B0255(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B032<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B032(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B0255<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B0255(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<B064K<'a>> for EncodableField<'a> {\n+    fn from(v: B064K<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B064K(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B064K<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B064K(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<B016M<'a>> for EncodableField<'a> {\n+    fn from(v: B016M<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B016M(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B016M<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B016M(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<Bytes<'a>> for EncodableField<'a> {\n+    fn from(v: Bytes<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::Bytes(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for Bytes<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::Bytes(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+//impl<'a> From<&'a Seq0255<'a, U24>> for EncodableField<'a> {\n+//    fn from(v: &'a Seq0255<'a, U24>) -> Self {\n+//        EncodableField::Primitive(EncodablePrimitive::Seq0255u24(v))\n+//    }\n+//}\n+\n+// IMPL INTO FIELD MARKER FOR PRIMITIVES\n+impl From<bool> for FieldMarker {\n+    fn from(_: bool) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::Bool)\n+    }\n+}\n+impl From<u8> for FieldMarker {\n+    fn from(_: u8) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U8)\n+    }\n+}\n+\n+impl From<u16> for FieldMarker {\n+    fn from(_: u16) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U16)\n+    }\n+}\n+\n+impl From<u32> for FieldMarker {\n+    fn from(_: u32) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U32)\n+    }\n+}\n+\n+impl From<f32> for FieldMarker {\n+    fn from(_: f32) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::F32)\n+    }\n+}\n+\n+impl From<u64> for FieldMarker {\n+    fn from(_: u64) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U64)\n+    }\n+}\n+\n+impl From<U24> for FieldMarker {\n+    fn from(_: U24) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U24)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, true, 32, 0, 0>> for FieldMarker {\n+    fn from(_: Inner<'a, true, 32, 0, 0>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U256)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, true, 64, 0, 0>> for FieldMarker {\n+    fn from(_: Inner<'a, true, 64, 0, 0>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::Signature)\n+    }\n+}\n+\n+impl<'a> From<B032<'a>> for FieldMarker {\n+    fn from(_: B032<'a>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B032)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, false, 1, 1, 255>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 1, 1, 255>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B0255)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, false, 1, 2, { 2_usize.pow(16) - 1 }>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 1, 2, { 2_usize.pow(16) - 1 }>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B064K)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B016M)\n+    }\n+}\n+impl<'a> From<Bytes<'a>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 0, 0, { ((2_usize.pow(63) - 1) * 2) + 1 }>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::Bytes)\n+    }\n+}"
      },
      {
        "sha": "91bef226d3f7fe57c6dcf49f9cef074fa4ce9c23",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,54 @@\n+// At lower level I generally prefer to work with slices as more efficient than Read/Write streams\n+// eg: Read for & [u8] is implemented with memcpy but here is more than enough to just get a\n+// pointer to the original data\n+\n+// ANche se enum decode sarebbe faclie da implementare non viene fatto dato che ogni messaggio puo\n+// essere derivato dal suo numero!\n+use crate::Error;\n+pub mod decodable;\n+pub mod encodable;\n+mod impls;\n+\n+/// Return the encoded byte size or a `Decodable`\n+pub trait SizeHint {\n+    fn size_hint(data: &[u8], offset: usize) -> Result<usize, Error>;\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error>;\n+}\n+\n+/// Return the encoded byte size of an `Encodable` comprehensive of the header, if any\n+pub trait GetSize {\n+    fn get_size(&self) -> usize;\n+}\n+\n+/// Implemented by all the primitives with a fixed size\n+pub trait Fixed {\n+    const SIZE: usize;\n+}\n+\n+pub trait Variable {\n+    const HEADER_SIZE: usize;\n+    //const ELEMENT_SIZE: usize;\n+    const MAX_SIZE: usize;\n+\n+    fn inner_size(&self) -> usize;\n+\n+    // TODO use [u8; HEADER_SIZE] instead of Vec\n+    fn get_header(&self) -> Vec<u8>;\n+}\n+\n+impl<T: Fixed> SizeHint for T {\n+    /// Total size of the encoded data type compreensive of the header when present\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        Ok(Self::SIZE)\n+    }\n+\n+    fn size_hint_(&self, _: &[u8], _offset: usize) -> Result<usize, Error> {\n+        Ok(Self::SIZE)\n+    }\n+}\n+\n+impl<T: Fixed> GetSize for T {\n+    fn get_size(&self) -> usize {\n+        Self::SIZE\n+    }\n+}"
      },
      {
        "sha": "62d23b0faf7938e48c82f62359d8157b85935928",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "status": "added",
        "additions": 177,
        "deletions": 0,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,177 @@\n+//! Copy data types\n+use crate::codec::Fixed;\n+use crate::datatypes::Sv2DataType;\n+use crate::Error;\n+use core::convert::{TryFrom, TryInto};\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Read, Write};\n+\n+// Impl bool as a primitive\n+\n+impl Fixed for bool {\n+    const SIZE: usize = 1;\n+}\n+\n+// Boolean value. Encoded as an unsigned 1-bit integer,\n+// True = 1, False = 0 with 7 additional padding bits in\n+// the high positions.\n+// x\n+// Recipients MUST NOT interpret bits outside of the\n+// least significant bit. Senders MAY set bits outside of\n+// the least significant bit to any value without any\n+// impact on meaning. This allows future use of other\n+// bits as flag bits.\n+impl<'a> Sv2DataType<'a> for bool {\n+    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n+        match data\n+            .get(0)\n+            .map(|x: &u8| x << 7)\n+            .map(|x: u8| x >> 7)\n+            .unwrap()\n+        {\n+            0 => false,\n+            1 => true,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    fn from_vec_(mut data: Vec<u8>) -> Result<Self, Error> {\n+        Self::from_bytes_(&mut data)\n+    }\n+\n+    fn from_vec_unchecked(mut data: Vec<u8>) -> Self {\n+        Self::from_bytes_unchecked(&mut data)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader_(reader: &mut impl Read) -> Result<Self, Error> {\n+        let mut dst = [0_u8; Self::SIZE];\n+        reader.read_exact(&mut dst)?;\n+        Self::from_bytes_(&mut dst)\n+    }\n+\n+    fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n+        match self {\n+            true => dst[0] = 1,\n+            false => dst[0] = 0,\n+        };\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            true => writer.write_all(&[1]),\n+            false => writer.write_all(&[0]),\n+        }\n+    }\n+}\n+\n+// Impl unsigned as a primitives\n+\n+impl Fixed for u8 {\n+    const SIZE: usize = 1;\n+}\n+\n+impl Fixed for u16 {\n+    const SIZE: usize = 2;\n+}\n+\n+impl Fixed for u32 {\n+    const SIZE: usize = 4;\n+}\n+\n+// TODO fix not in the specs\n+impl Fixed for u64 {\n+    const SIZE: usize = 8;\n+}\n+\n+macro_rules! impl_sv2_for_unsigned {\n+    ($a:ty) => {\n+        impl<'a> Sv2DataType<'a> for $a {\n+            fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n+                let a: &[u8; Self::SIZE] = data[0..Self::SIZE].try_into().unwrap();\n+                Self::from_le_bytes(*a)\n+            }\n+\n+            fn from_vec_(mut data: Vec<u8>) -> Result<Self, Error> {\n+                Self::from_bytes_(&mut data)\n+            }\n+\n+            fn from_vec_unchecked(mut data: Vec<u8>) -> Self {\n+                Self::from_bytes_unchecked(&mut data)\n+            }\n+\n+            #[cfg(not(feature = \"no_std\"))]\n+            fn from_reader_(reader: &mut impl Read) -> Result<Self, Error> {\n+                let mut dst = [0_u8; Self::SIZE];\n+                reader.read_exact(&mut dst)?;\n+                Ok(Self::from_bytes_unchecked(&mut dst))\n+            }\n+\n+            fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n+                let dst = &mut dst[0..Self::SIZE];\n+                let src = self.to_le_bytes();\n+                dst.copy_from_slice(&src);\n+            }\n+\n+            #[cfg(not(feature = \"no_std\"))]\n+            fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n+                let bytes = self.to_le_bytes();\n+                writer.write_all(&bytes)\n+            }\n+        }\n+    };\n+}\n+impl_sv2_for_unsigned!(u8);\n+impl_sv2_for_unsigned!(u16);\n+impl_sv2_for_unsigned!(u32);\n+impl_sv2_for_unsigned!(u64);\n+\n+// Impl f32 as a primitives\n+\n+impl Fixed for f32 {\n+    const SIZE: usize = 4;\n+}\n+\n+impl_sv2_for_unsigned!(f32);\n+\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy, Eq, PartialEq)]\n+pub struct U24(pub(crate) u32);\n+\n+impl Fixed for U24 {\n+    const SIZE: usize = 3;\n+}\n+\n+impl U24 {\n+    fn from_le_bytes(b: [u8; Self::SIZE]) -> Self {\n+        let inner = u32::from_le_bytes([b[0], b[1], b[2], 0]);\n+        Self(inner)\n+    }\n+\n+    fn to_le_bytes(self) -> [u8; Self::SIZE] {\n+        let b = self.0.to_le_bytes();\n+        [b[0], b[1], b[2]]\n+    }\n+}\n+\n+impl_sv2_for_unsigned!(U24);\n+\n+impl TryFrom<u32> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: u32) -> Result<Self, Self::Error> {\n+        if value <= 16777215 {\n+            Ok(Self(value))\n+        } else {\n+            Err(Error::InvalidU24(value))\n+        }\n+    }\n+}\n+\n+impl From<U24> for u32 {\n+    fn from(v: U24) -> Self {\n+        v.0\n+    }\n+}"
      },
      {
        "sha": "162c0499e2f844c7885924bd09a9cd849cdc4e24",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,44 @@\n+use crate::codec::{GetSize, SizeHint};\n+use crate::Error;\n+mod non_copy_data_types;\n+\n+mod copy_data_types;\n+use crate::codec::decodable::FieldMarker;\n+pub use copy_data_types::U24;\n+pub use non_copy_data_types::{\n+    Bytes, Inner, PubKey, Seq0255, Seq064K, Signature, Str0255, Str032, B016M, B0255, B032, B064K,\n+    U256,\n+};\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Read, Write};\n+\n+pub trait Sv2DataType<'a>: Sized + SizeHint + GetSize + Into<FieldMarker> {\n+    fn from_bytes_(data: &'a mut [u8]) -> Result<Self, Error> {\n+        Self::size_hint(data, 0)?;\n+        Ok(Self::from_bytes_unchecked(data))\n+    }\n+\n+    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self;\n+\n+    fn from_vec_(data: Vec<u8>) -> Result<Self, Error>;\n+\n+    fn from_vec_unchecked(data: Vec<u8>) -> Self;\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader_(reader: &mut impl Read) -> Result<Self, Error>;\n+\n+    fn to_slice(&'a self, dst: &mut [u8]) -> Result<usize, Error> {\n+        if dst.len() >= self.get_size() {\n+            self.to_slice_unchecked(dst);\n+            Ok(self.get_size())\n+        } else {\n+            Err(Error::WriteError(self.get_size(), dst.len()))\n+        }\n+    }\n+\n+    fn to_slice_unchecked(&'a self, dst: &mut [u8]);\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E>;\n+}"
      },
      {
        "sha": "f889d6f21c0df7ef505787363c51ec384c62520b",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "status": "added",
        "additions": 256,
        "deletions": 0,
        "changes": 256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,256 @@\n+use super::IntoOwned;\n+use crate::codec::{GetSize, SizeHint};\n+use crate::datatypes::Sv2DataType;\n+use crate::Error;\n+use core::convert::TryFrom;\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Read, Write};\n+\n+#[repr(C)]\n+#[derive(Debug, Eq, PartialEq)]\n+pub enum Inner<\n+    'a,\n+    const ISFIXED: bool,\n+    const SIZE: usize,\n+    const HEADERSIZE: usize,\n+    const MAXSIZE: usize,\n+> {\n+    Ref(&'a mut [u8]),\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn expected_lenght(data: &[u8]) -> Result<usize, Error> {\n+        let expected_lenght = match ISFIXED {\n+            true => Self::expected_lenght_fixed(),\n+            false => Self::expected_lenght_variable(data)?,\n+        };\n+        if ISFIXED || expected_lenght <= MAXSIZE {\n+            Ok(expected_lenght)\n+        } else {\n+            Err(Error::ReadError(data.len(), MAXSIZE))\n+        }\n+    }\n+\n+    fn expected_lenght_fixed() -> usize {\n+        SIZE\n+    }\n+\n+    fn expected_lenght_variable(data: &[u8]) -> Result<usize, Error> {\n+        if data.len() >= HEADERSIZE {\n+            let size = match HEADERSIZE {\n+                0 => Ok(data.len()),\n+                1 => Ok(data[0] as usize),\n+                2 => Ok(u16::from_le_bytes([data[0], data[1]]) as usize),\n+                3 => Ok(u32::from_le_bytes([data[0], data[1], data[2], 0]) as usize),\n+                _ => unimplemented!(),\n+            };\n+            size.map(|x| x + HEADERSIZE)\n+        } else {\n+            Err(Error::ReadError(data.len(), HEADERSIZE))\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn expected_lenght_for_reader(mut reader: impl Read) -> Result<usize, Error> {\n+        if ISFIXED {\n+            Ok(SIZE)\n+        } else {\n+            let mut header = [0_u8; HEADERSIZE];\n+            reader.read_exact(&mut header)?;\n+            let expected_lenght = match HEADERSIZE {\n+                1 => header[0] as usize,\n+                2 => u16::from_le_bytes([header[0], header[1]]) as usize,\n+                3 => u32::from_le_bytes([header[0], header[1], header[2], 0]) as usize,\n+                _ => unimplemented!(),\n+            };\n+            if expected_lenght <= MAXSIZE {\n+                Ok(expected_lenght)\n+            } else {\n+                Err(Error::ReadError(expected_lenght, MAXSIZE))\n+            }\n+        }\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        match (self, ISFIXED) {\n+            (Inner::Ref(data), false) => data.len(),\n+            (Inner::Owned(data), false) => data.len(),\n+            (_, true) => 1,\n+        }\n+    }\n+\n+    fn get_header(&self) -> Vec<u8> {\n+        if HEADERSIZE == 0 {\n+            Vec::new()\n+        } else {\n+            let len = self.len();\n+            len.to_le_bytes().into()\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    TryFrom<&'a mut [u8]> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    type Error = Error;\n+\n+    fn try_from(value: &'a mut [u8]) -> Result<Self, Self::Error> {\n+        if ISFIXED && value.len() == SIZE {\n+            Ok(Self::Ref(value))\n+        } else if ISFIXED {\n+            Err(Error::Todo)\n+        } else if value.len() <= MAXSIZE {\n+            Ok(Self::Ref(value))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    TryFrom<Vec<u8>> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    type Error = Error;\n+\n+    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {\n+        if ISFIXED && value.len() == SIZE {\n+            Ok(Self::Owned(value))\n+        } else if ISFIXED {\n+            Err(Error::Todo)\n+        } else if value.len() <= MAXSIZE {\n+            Ok(Self::Owned(value))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    GetSize for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Inner::Ref(data) => data.len() + HEADERSIZE,\n+            Inner::Owned(data) => data.len() + HEADERSIZE,\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const HEADERSIZE: usize, const SIZE: usize, const MAXSIZE: usize>\n+    SizeHint for Inner<'a, ISFIXED, HEADERSIZE, SIZE, MAXSIZE>\n+{\n+    fn size_hint(data: &[u8], offset: usize) -> Result<usize, Error> {\n+        Self::expected_lenght(&data[offset..])\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        Self::expected_lenght(&data[offset..])\n+    }\n+}\n+use crate::codec::decodable::FieldMarker;\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    Sv2DataType<'a> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+where\n+    Self: Into<FieldMarker>,\n+{\n+    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n+        if ISFIXED {\n+            Self::Ref(data)\n+        } else {\n+            Self::Ref(&mut data[HEADERSIZE..])\n+        }\n+    }\n+\n+    fn from_vec_(data: Vec<u8>) -> Result<Self, Error> {\n+        Self::size_hint(&data, 0)?;\n+        Ok(Self::Owned(data))\n+    }\n+\n+    fn from_vec_unchecked(data: Vec<u8>) -> Self {\n+        Self::Owned(data)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader_(mut reader: &mut impl Read) -> Result<Self, Error> {\n+        let size = Self::expected_lenght_for_reader(&mut reader)?;\n+\n+        let mut dst = vec![0; size];\n+\n+        reader.read_exact(&mut dst)?;\n+        Ok(Self::from_vec_unchecked(dst))\n+    }\n+\n+    fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n+        let size = self.get_size();\n+        let header = self.get_header();\n+        dst[0..HEADERSIZE].copy_from_slice(&header[..HEADERSIZE]);\n+        match self {\n+            Inner::Ref(data) => {\n+                let dst = &mut dst[0..size];\n+                dst[HEADERSIZE..].copy_from_slice(data);\n+            }\n+            Inner::Owned(data) => {\n+                let dst = &mut dst[0..size];\n+                dst[HEADERSIZE..].copy_from_slice(data);\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            Inner::Ref(data) => {\n+                writer.write_all(data)?;\n+            }\n+            Inner::Owned(data) => {\n+                writer.write_all(data)?;\n+            }\n+        };\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    IntoOwned for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn into_owned(self) -> Self {\n+        match self {\n+            Inner::Ref(data) => {\n+                let v: Vec<u8> = data.into();\n+                Self::Owned(v)\n+            }\n+            Inner::Owned(_) => self,\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    Clone for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn clone(&self) -> Self {\n+        match self {\n+            Inner::Ref(data) => {\n+                let mut v = Vec::with_capacity(data.len());\n+                v.extend_from_slice(data);\n+                Self::Owned(v)\n+            }\n+            Inner::Owned(data) => Inner::Owned(data.clone()),\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    AsRef<[u8]> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn as_ref(&self) -> &[u8] {\n+        match self {\n+            Inner::Ref(r) => &r[..],\n+            Inner::Owned(r) => &r[..],\n+        }\n+    }\n+}"
      },
      {
        "sha": "483cf3bc6c76500410f3285ba51606ca43138b48",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,26 @@\n+mod inner;\n+mod seq_inner;\n+\n+trait IntoOwned {\n+    fn into_owned(self) -> Self;\n+}\n+\n+pub use inner::Inner;\n+pub use seq_inner::{Seq0255, Seq064K};\n+\n+pub type U256<'a> = Inner<'a, true, 32, 0, 0>;\n+pub type PubKey<'a> = Inner<'a, true, 32, 0, 0>;\n+pub type Signature<'a> = Inner<'a, true, 64, 0, 0>;\n+pub type B032<'a> = Inner<'a, false, 1, 1, 32>;\n+pub type B0255<'a> = Inner<'a, false, 1, 1, 255>;\n+pub type Str032<'a> = Inner<'a, false, 1, 1, 32>;\n+pub type Str0255<'a> = Inner<'a, false, 1, 1, 255>;\n+pub type B064K<'a> = Inner<'a, false, 1, 2, { u16::MAX as usize }>;\n+pub type B016M<'a> = Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>;\n+pub type Bytes<'a> = Inner<'a, false, 0, 0, { usize::MAX }>;\n+\n+impl<'decoder> From<[u8; 32]> for U256<'decoder> {\n+    fn from(v: [u8; 32]) -> Self {\n+        Inner::Owned(v.into())\n+    }\n+}"
      },
      {
        "sha": "3706345a9e5c12eff44ab184d69df2caafd3aae3",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "status": "added",
        "additions": 229,
        "deletions": 0,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,229 @@\n+use crate::codec::decodable::{Decodable, DecodableField, FieldMarker, GetMarker, PrimitiveMarker};\n+use crate::codec::encodable::{EncodableField, EncodablePrimitive};\n+use crate::codec::GetSize;\n+use crate::datatypes::Sv2DataType;\n+use crate::datatypes::*;\n+use crate::Error;\n+use core::marker::PhantomData;\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::Read;\n+\n+/// The liftime is here only for type compatibility with serde-sv2\n+#[repr(C)]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Seq0255<'a, T>(pub(crate) Vec<T>, PhantomData<&'a T>);\n+\n+impl<'a, T: 'a> Seq0255<'a, T> {\n+    const HEADERSIZE: usize = 1;\n+\n+    /// Return the len of the inner vector\n+    fn expected_len(data: &[u8]) -> Result<usize, Error> {\n+        if data.len() >= Self::HEADERSIZE {\n+            Ok(data[0] as usize)\n+        } else {\n+            Err(Error::ReadError(data.len(), Self::HEADERSIZE))\n+        }\n+    }\n+\n+    pub fn new(inner: Vec<T>) -> Result<Self, Error> {\n+        if inner.len() <= 255 {\n+            Ok(Self(inner, PhantomData))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+\n+    //pub fn try_from_slice(inner: &'a mut [T]) -> Result<Self, Error> {\n+    //    if inner.len() <= 255 {\n+    //        let inner_: Vec<T> = vec![];\n+    //        for v in inner {\n+    //            inner_.push(v);\n+    //        }\n+    //        Ok(Self(inner_, PhantomData))\n+    //    } else {\n+    //        Err(Error::Todo)\n+    //    }\n+    //}\n+}\n+\n+impl<'a, T: GetSize> GetSize for Seq0255<'a, T> {\n+    fn get_size(&self) -> usize {\n+        let mut size = Self::HEADERSIZE;\n+        for with_size in &self.0 {\n+            size += with_size.get_size()\n+        }\n+        size\n+    }\n+}\n+\n+/// The liftime is here only for type compatibility with serde-sv2\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Seq064K<'a, T>(pub(crate) Vec<T>, PhantomData<&'a T>);\n+\n+impl<'a, T: 'a> Seq064K<'a, T> {\n+    const HEADERSIZE: usize = 2;\n+\n+    /// Return the len of the inner vector\n+    fn expected_len(data: &[u8]) -> Result<usize, Error> {\n+        if data.len() >= Self::HEADERSIZE {\n+            Ok(u16::from_le_bytes([data[0], data[1]]) as usize)\n+        } else {\n+            Err(Error::ReadError(data.len(), Self::HEADERSIZE))\n+        }\n+    }\n+\n+    pub fn new(inner: Vec<T>) -> Result<Self, Error> {\n+        if inner.len() <= 65535 {\n+            Ok(Self(inner, PhantomData))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+}\n+\n+impl<'a, T: GetSize> GetSize for Seq064K<'a, T> {\n+    fn get_size(&self) -> usize {\n+        let mut size = Self::HEADERSIZE;\n+        for with_size in &self.0 {\n+            size += with_size.get_size()\n+        }\n+        size\n+    }\n+}\n+\n+macro_rules! impl_codec_for_sequence {\n+    ($a:ty) => {\n+        impl<'a, T: 'a + Sv2DataType<'a> + GetMarker + GetSize + Decodable<'a>> Decodable<'a>\n+            for $a\n+        {\n+            fn get_structure(\n+                data: &[u8],\n+            ) -> Result<Vec<crate::codec::decodable::FieldMarker>, Error> {\n+                let len = Self::expected_len(data)?;\n+                let mut inner = Vec::with_capacity(len + Self::HEADERSIZE);\n+                for _ in 0..Self::HEADERSIZE {\n+                    inner.push(FieldMarker::Primitive(PrimitiveMarker::U8));\n+                }\n+                let inner_type = T::get_marker();\n+                inner.resize(len + Self::HEADERSIZE, inner_type);\n+                Ok(inner)\n+            }\n+\n+            fn from_decoded_fields(\n+                data: Vec<crate::codec::decodable::DecodableField<'a>>,\n+            ) -> Result<Self, Error> {\n+                let mut inner: Vec<T> = Vec::with_capacity(data.len());\n+                let mut i = 0;\n+                for element in data {\n+                    if i >= Self::HEADERSIZE {\n+                        match element {\n+                            DecodableField::Primitive(p) => {\n+                                let element =\n+                                    T::from_decoded_fields(vec![DecodableField::Primitive(p)]);\n+                                inner.push(element?)\n+                            }\n+                            DecodableField::Struct(_) => unimplemented!(),\n+                        }\n+                    }\n+                    i += 1;\n+                }\n+                Ok(Self(inner, PhantomData))\n+            }\n+\n+            fn from_bytes(data: &'a mut [u8]) -> Result<Self, Error> {\n+                let len = Self::expected_len(data)?;\n+\n+                let mut inner = Vec::new();\n+                let mut tail = &mut data[Self::HEADERSIZE..];\n+\n+                for _ in 0..len {\n+                    let element_size = T::size_hint(tail, 0)?;\n+                    let (head, t) = tail.split_at_mut(element_size);\n+                    tail = t;\n+                    inner.push(T::from_bytes_unchecked(head));\n+                }\n+                Ok(Self(inner, PhantomData))\n+            }\n+\n+            #[cfg(not(feature = \"no_std\"))]\n+            fn from_reader(reader: &mut impl Read) -> Result<Self, Error> {\n+                let mut header = vec![0; Self::HEADERSIZE];\n+                reader.read_exact(&mut header)?;\n+\n+                let len = Self::expected_len(&header)?;\n+\n+                let mut inner = Vec::new();\n+\n+                for _ in 0..len {\n+                    inner.push(T::from_reader_(reader)?);\n+                }\n+                Ok(Self(inner, PhantomData))\n+            }\n+        }\n+    };\n+}\n+\n+impl_codec_for_sequence!(Seq0255<'a, T>);\n+impl_codec_for_sequence!(Seq064K<'a, T>);\n+\n+macro_rules! impl_into_encodable_field_for_seq {\n+    ($a:ty) => {\n+        impl<'a> From<Seq064K<'a, $a>> for EncodableField<'a> {\n+            fn from(v: Seq064K<'a, $a>) -> Self {\n+                let inner_len = v.0.len() as u16;\n+                let mut as_encodable: Vec<EncodableField> =\n+                    Vec::with_capacity((inner_len + 2) as usize);\n+                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n+                    inner_len.to_le_bytes()[0],\n+                )));\n+                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n+                    inner_len.to_le_bytes()[1],\n+                )));\n+                for element in v.0 {\n+                    as_encodable.push(element.into());\n+                }\n+                EncodableField::Struct(as_encodable)\n+            }\n+        }\n+\n+        impl<'a> From<Seq0255<'a, $a>> for EncodableField<'a> {\n+            fn from(v: Seq0255<$a>) -> Self {\n+                let inner_len = v.0.len() as u8;\n+                let mut as_encodable: Vec<EncodableField> =\n+                    Vec::with_capacity((inner_len + 1) as usize);\n+                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n+                    inner_len,\n+                )));\n+                for element in v.0 {\n+                    as_encodable.push(element.into());\n+                }\n+                EncodableField::Struct(as_encodable)\n+            }\n+        }\n+    };\n+}\n+\n+impl_into_encodable_field_for_seq!(bool);\n+impl_into_encodable_field_for_seq!(u8);\n+impl_into_encodable_field_for_seq!(u16);\n+impl_into_encodable_field_for_seq!(U24);\n+impl_into_encodable_field_for_seq!(u32);\n+impl_into_encodable_field_for_seq!(u64);\n+impl_into_encodable_field_for_seq!(U256<'a>);\n+impl_into_encodable_field_for_seq!(Signature<'a>);\n+impl_into_encodable_field_for_seq!(B0255<'a>);\n+impl_into_encodable_field_for_seq!(B064K<'a>);\n+impl_into_encodable_field_for_seq!(B016M<'a>);\n+\n+impl<'a, T> From<Seq0255<'a, T>> for Vec<T> {\n+    fn from(v: Seq0255<'a, T>) -> Self {\n+        v.0\n+    }\n+}\n+\n+impl<'a, T> From<Seq064K<'a, T>> for Vec<T> {\n+    fn from(v: Seq064K<'a, T>) -> Self {\n+        v.0\n+    }\n+}"
      },
      {
        "sha": "b2c3214582104ac41eb1412082beb417686fa371",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "status": "added",
        "additions": 297,
        "deletions": 0,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,297 @@\n+//! ```txt\n+//! SERDE    <-> Sv2\n+//! bool     <-> BOOL\n+//! u8       <-> U8\n+//! u16      <-> U16\n+//! U24      <-> U24\n+//! u32      <-> u32\n+//! f32      <-> f32 // todo not in the spec but used\n+//! u64      <-> u64 // todo not in the spec but used\n+//! U256     <-> U256\n+//! Str0255  <-> STRO_255\n+//! Str032   <-> STRO_32 // todo not in the spec but used\n+//! Signature<-> SIGNATURE\n+//! B032     <-> B0_32 // todo not in the spec but used\n+//! B0255    <-> B0_255\n+//! B064K    <-> B0_64K\n+//! B016M    <-> B0_16M\n+//! [u8]     <-> BYTES\n+//! Pubkey   <-> PUBKEY\n+//! Seq0255  <-> SEQ0_255[T]\n+//! Seq064K  <-> SEQ0_64K[T]\n+//! ```\n+#![cfg_attr(feature = \"no_std\", no_std)]\n+use core::convert::TryInto;\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, ErrorKind};\n+\n+#[macro_use]\n+extern crate alloc;\n+\n+mod codec;\n+mod datatypes;\n+pub use datatypes::{\n+    Bytes, PubKey, Seq0255, Seq064K, Signature, Str0255, Str032, B016M, B0255, B032, B064K, U24,\n+    U256,\n+};\n+\n+pub use crate::codec::decodable::Decodable;\n+pub use crate::codec::encodable::{Encodable, EncodableField};\n+pub use crate::codec::GetSize;\n+pub use crate::codec::SizeHint;\n+\n+#[allow(clippy::wrong_self_convention)]\n+pub fn to_bytes<T: Encodable + GetSize>(src: T) -> Result<Vec<u8>, Error> {\n+    let mut result = vec![0_u8; src.get_size()];\n+    src.to_bytes(&mut result)?;\n+    Ok(result)\n+}\n+\n+#[allow(clippy::wrong_self_convention)]\n+pub fn to_writer<T: Encodable>(src: T, dst: &mut [u8]) -> Result<(), Error> {\n+    src.to_bytes(dst)?;\n+    Ok(())\n+}\n+\n+pub fn from_bytes<'a, T: Decodable<'a>>(data: &'a mut [u8]) -> Result<T, Error> {\n+    T::from_bytes(data)\n+}\n+\n+pub mod decodable {\n+    pub use crate::codec::decodable::Decodable;\n+    pub use crate::codec::decodable::DecodableField;\n+    pub use crate::codec::decodable::FieldMarker;\n+    //pub use crate::codec::decodable::PrimitiveMarker;\n+}\n+\n+pub mod encodable {\n+    pub use crate::codec::encodable::Encodable;\n+    pub use crate::codec::encodable::EncodableField;\n+}\n+\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    OutOfBound,\n+    NotABool(u8),\n+    /// -> (expected size, actual size)\n+    WriteError(usize, usize),\n+    U24TooBig(u32),\n+    InvalidSignatureSize(usize),\n+    InvalidU256(usize),\n+    InvalidU24(u32),\n+    InvalidB0255Size(usize),\n+    InvalidB064KSize(usize),\n+    InvalidB016MSize(usize),\n+    InvalidSeq0255Size(usize),\n+    PrimitiveConversionError,\n+    DecodableConversionError,\n+    UnInitializedDecoder,\n+    #[cfg(not(feature = \"no_std\"))]\n+    IoError(E),\n+    ReadError(usize, usize),\n+    Todo,\n+}\n+\n+#[cfg(not(feature = \"no_std\"))]\n+impl From<E> for Error {\n+    fn from(v: E) -> Self {\n+        match v.kind() {\n+            ErrorKind::UnexpectedEof => Error::OutOfBound,\n+            _ => Error::IoError(v),\n+        }\n+    }\n+}\n+\n+/// Vec<u8> is used as the Sv2 type Bytes\n+impl GetSize for Vec<u8> {\n+    fn get_size(&self) -> usize {\n+        self.len()\n+    }\n+}\n+\n+impl<'a> From<Vec<u8>> for EncodableField<'a> {\n+    fn from(v: Vec<u8>) -> Self {\n+        let bytes: Bytes = v.try_into().unwrap();\n+        crate::encodable::EncodableField::Primitive(\n+            crate::codec::encodable::EncodablePrimitive::Bytes(bytes),\n+        )\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy)]\n+pub struct CVec {\n+    data: *mut u8,\n+    len: usize,\n+    capacity: usize,\n+}\n+\n+impl CVec {\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        unsafe { core::slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+\n+    /// Used when we need to fill a buffer allocated in rust from C.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function construct a CVec without taking ownership of the pointed buffer so if the\n+    /// owner drop them the CVec will point to garbage.\n+    #[allow(clippy::wrong_self_convention)]\n+    pub fn as_shared_buffer(v: &mut [u8]) -> Self {\n+        let (data, len) = (v.as_mut_ptr(), v.len());\n+        Self {\n+            data,\n+            len,\n+            capacity: len,\n+        }\n+    }\n+}\n+\n+impl From<&[u8]> for CVec {\n+    fn from(v: &[u8]) -> Self {\n+        let mut buffer: Vec<u8> = vec![0; v.len()];\n+        buffer.copy_from_slice(v);\n+\n+        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+        let len = buffer.len();\n+        let ptr = buffer.as_mut_ptr();\n+        std::mem::forget(buffer);\n+\n+        CVec {\n+            data: ptr,\n+            len,\n+            capacity: len,\n+        }\n+    }\n+}\n+\n+/// Given a C allocated buffer return a rust allocated CVec\n+///\n+/// # Safety\n+///\n+/// TODO\n+#[no_mangle]\n+pub unsafe extern \"C\" fn cvec_from_buffer(data: *const u8, len: usize) -> CVec {\n+    let input = std::slice::from_raw_parts(data, len);\n+\n+    let mut buffer: Vec<u8> = vec![0; len];\n+    buffer.copy_from_slice(input);\n+\n+    // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+    let len = buffer.len();\n+    let ptr = buffer.as_mut_ptr();\n+    std::mem::forget(buffer);\n+\n+    CVec {\n+        data: ptr,\n+        len,\n+        capacity: len,\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy)]\n+pub struct CVec2 {\n+    data: *mut CVec,\n+    len: usize,\n+    capacity: usize,\n+}\n+\n+impl CVec2 {\n+    pub fn as_mut_slice(&mut self) -> &mut [CVec] {\n+        unsafe { core::slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+}\n+impl From<CVec2> for Vec<CVec> {\n+    fn from(v: CVec2) -> Self {\n+        unsafe { Vec::from_raw_parts(v.data, v.len, v.capacity) }\n+    }\n+}\n+\n+pub fn free_vec(buf: &mut CVec) {\n+    let _: Vec<u8> = unsafe { Vec::from_raw_parts(buf.data, buf.len, buf.capacity) };\n+}\n+\n+pub fn free_vec_2(buf: &mut CVec2) {\n+    let vs: Vec<CVec> = unsafe { Vec::from_raw_parts(buf.data, buf.len, buf.capacity) };\n+    for mut s in vs {\n+        free_vec(&mut s)\n+    }\n+}\n+\n+impl<'a, const A: bool, const B: usize, const C: usize, const D: usize>\n+    From<datatypes::Inner<'a, A, B, C, D>> for CVec\n+{\n+    fn from(v: datatypes::Inner<'a, A, B, C, D>) -> Self {\n+        let (ptr, len, cap): (*mut u8, usize, usize) = match v {\n+            datatypes::Inner::Ref(inner) => {\n+                // Data is copied in a vector that then will be forgetted from the allocator,\n+                // cause the owner of the data is going to be dropped by rust\n+                let mut inner: Vec<u8> = inner.into();\n+\n+                // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+                let len = inner.len();\n+                let cap = inner.capacity();\n+                let ptr = inner.as_mut_ptr();\n+                std::mem::forget(inner);\n+\n+                (ptr, len, cap)\n+            }\n+            datatypes::Inner::Owned(mut inner) => {\n+                // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+                let len = inner.len();\n+                let cap = inner.capacity();\n+                let ptr = inner.as_mut_ptr();\n+                std::mem::forget(inner);\n+\n+                (ptr, len, cap)\n+            }\n+        };\n+        Self {\n+            data: ptr,\n+            len,\n+            capacity: cap,\n+        }\n+    }\n+}\n+\n+impl<'a, T: Into<CVec>> From<Seq0255<'a, T>> for CVec2 {\n+    fn from(v: Seq0255<'a, T>) -> Self {\n+        let mut v: Vec<CVec> = v.0.into_iter().map(|x| x.into()).collect();\n+        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+        let len = v.len();\n+        let capacity = v.capacity();\n+        let data = v.as_mut_ptr();\n+        std::mem::forget(v);\n+        Self {\n+            data,\n+            len,\n+            capacity,\n+        }\n+    }\n+}\n+impl<'a, T: Into<CVec>> From<Seq064K<'a, T>> for CVec2 {\n+    fn from(v: Seq064K<'a, T>) -> Self {\n+        let mut v: Vec<CVec> = v.0.into_iter().map(|x| x.into()).collect();\n+        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+        let len = v.len();\n+        let capacity = v.capacity();\n+        let data = v.as_mut_ptr();\n+        std::mem::forget(v);\n+        Self {\n+            data,\n+            len,\n+            capacity,\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_u24(_a: U24) {}\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_cvec(_a: CVec) {}\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_cvec2(_a: CVec2) {}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "363bcb5af3b130eee4578a200ae8f850a2000079",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,14 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"binary_codec_sv2\"\n+version = \"0.1.1\"\n+\n+[[package]]\n+name = \"derive_codec_sv2\"\n+version = \"0.1.1\"\n+dependencies = [\n+ \"binary_codec_sv2\",\n+]"
      },
      {
        "sha": "05ac6359403da3c4c08dc1d7a2bf3ebbe3441ef5",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,15 @@\n+[package]\n+name = \"derive_codec_sv2\"\n+version = \"0.1.1\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Derive macro for Sv2 binary format serializer and deserializer\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+binary_codec_sv2 = {version = \"0.1.1\", path=\"../codec\"}\n+\n+[lib]\n+proc-macro = true"
      },
      {
        "sha": "7d16cf152f342fffe8caa07cd972005322c03b85",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "status": "added",
        "additions": 387,
        "deletions": 0,
        "changes": 387,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,387 @@\n+extern crate proc_macro;\n+use core::iter::FromIterator;\n+use proc_macro::{Group, TokenStream, TokenTree};\n+\n+fn remove_attributes(item: TokenStream) -> TokenStream {\n+    let stream = item.into_iter();\n+    let mut is_attribute = false;\n+    let mut result = Vec::new();\n+\n+    for next in stream {\n+        match next.clone() {\n+            TokenTree::Punct(p) => {\n+                if p.to_string() == \"#\" {\n+                    is_attribute = true;\n+                } else {\n+                    result.push(next.clone());\n+                }\n+            }\n+            TokenTree::Group(g) => {\n+                if is_attribute {\n+                    continue;\n+                } else {\n+                    let delimiter = g.delimiter();\n+                    let cleaned_group = remove_attributes(g.stream());\n+                    let cleaned_group = TokenTree::Group(Group::new(delimiter, cleaned_group));\n+                    result.push(cleaned_group);\n+                }\n+            }\n+            _ => {\n+                is_attribute = false;\n+                result.push(next.clone());\n+            }\n+        }\n+    }\n+\n+    TokenStream::from_iter(result)\n+}\n+\n+enum ParserState {\n+    Name,\n+    Type,\n+    //       open angle brackets\n+    Generics(usize),\n+}\n+fn parse_struct_fields(group: Vec<TokenTree>) -> Vec<ParsedField> {\n+    let mut fields = Vec::new();\n+    let mut field_ = ParsedField::new();\n+    let mut field_parser_state = ParserState::Name;\n+    for token in group {\n+        match (token, &field_parser_state) {\n+            (TokenTree::Ident(i), ParserState::Name) => {\n+                if i.to_string() == \"pub\" {\n+                    continue;\n+                } else {\n+                    field_.name = i.to_string();\n+                }\n+            }\n+            (TokenTree::Ident(i), ParserState::Type) => {\n+                field_.type_ = i.to_string();\n+            }\n+            (TokenTree::Ident(i), ParserState::Generics(_)) => {\n+                field_.generics = format!(\"{}{}\", field_.generics, i.to_string());\n+            }\n+            (TokenTree::Punct(p), ParserState::Name) => {\n+                if p.to_string() == \":\" {\n+                    field_parser_state = ParserState::Type\n+                } else {\n+                    panic!(\n+                        \"Unexpected token '{}' in parsing {:#?}\",\n+                        p.to_string(),\n+                        field_\n+                    );\n+                }\n+            }\n+            (TokenTree::Punct(p), ParserState::Type) => match p.to_string().as_ref() {\n+                \",\" => {\n+                    field_parser_state = ParserState::Name;\n+                    fields.push(field_.clone());\n+                    field_ = ParsedField::new();\n+                }\n+                \"<\" => {\n+                    field_.generics = \"<\".to_string();\n+                    field_parser_state = ParserState::Generics(0);\n+                }\n+                _ => panic!(\n+                    \"Unexpected token '{}' in parsing {:#?}\",\n+                    p.to_string(),\n+                    field_\n+                ),\n+            },\n+            (TokenTree::Punct(p), ParserState::Generics(open_brackets)) => {\n+                match p.to_string().as_ref() {\n+                    \"'\" => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                    }\n+                    \"<\" => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                        field_parser_state = ParserState::Generics(open_brackets + 1);\n+                    }\n+                    \">\" => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                        if open_brackets == &0 {\n+                            field_parser_state = ParserState::Type\n+                        } else {\n+                            field_parser_state = ParserState::Generics(open_brackets - 1);\n+                        }\n+                    }\n+                    _ => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                    }\n+                }\n+            }\n+            _ => panic!(\"Unexpected token\"),\n+        }\n+    }\n+    fields\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ParsedField {\n+    name: String,\n+    type_: String,\n+    generics: String,\n+}\n+\n+impl ParsedField {\n+    pub fn new() -> Self {\n+        ParsedField {\n+            name: \"\".to_string(),\n+            type_: \"\".to_string(),\n+            generics: \"\".to_string(),\n+        }\n+    }\n+\n+    pub fn get_generics(&self) -> String {\n+        if self.generics == \"<'decoder>\" || self.generics.is_empty() {\n+            \"\".to_string()\n+        } else {\n+            format!(\"::{}\", self.generics.clone())\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ParsedStruct {\n+    pub name: String,\n+    pub generics: String,\n+    pub fields: Vec<ParsedField>,\n+}\n+\n+// impl ParsedStruct {\n+//     pub fn new() -> Self {\n+//         ParsedStruct {\n+//             name: \"\".to_string(),\n+//             generics: \"\".to_string(),\n+//             fields: Vec::new(),\n+//         }\n+//     }\n+// }\n+\n+fn get_struct_properties(item: TokenStream) -> ParsedStruct {\n+    let item = remove_attributes(item);\n+    let mut stream = item.into_iter();\n+\n+    // Check if the stream is a struct\n+    loop {\n+        match stream.next().expect(\"Stream not a struct\") {\n+            TokenTree::Ident(i) => {\n+                if i.to_string() == \"struct\" {\n+                    break;\n+                }\n+            }\n+            _ => continue,\n+        }\n+    }\n+\n+    // Get the struct name\n+    let struct_name = match stream.next().expect(\"Struct has no name\") {\n+        TokenTree::Ident(i) => i.to_string(),\n+        _ => panic!(\"Strcut has no name\"),\n+    };\n+\n+    let mut struct_generics = \"\".to_string();\n+    let group: Vec<TokenTree>;\n+\n+    // Get the struct generics if any\n+    loop {\n+        match stream\n+            .next()\n+            .unwrap_or_else(|| panic!(\"Struct {} has no fields\", struct_name))\n+        {\n+            TokenTree::Group(g) => {\n+                group = g.stream().into_iter().collect();\n+                break;\n+            }\n+            TokenTree::Punct(p) => {\n+                struct_generics = format!(\"{}{}\", struct_generics, p.to_string());\n+            }\n+            TokenTree::Ident(i) => {\n+                struct_generics = format!(\"{}{}\", struct_generics, i.to_string());\n+            }\n+            _ => panic!(\"Struct {} has no fields\", struct_name),\n+        };\n+    }\n+\n+    let fields = parse_struct_fields(group);\n+\n+    ParsedStruct {\n+        name: struct_name,\n+        generics: struct_generics,\n+        fields,\n+    }\n+}\n+\n+#[proc_macro_derive(Decodable)]\n+pub fn decodable(item: TokenStream) -> TokenStream {\n+    let parsed_struct = get_struct_properties(item);\n+\n+    let mut derive_fields = String::new();\n+\n+    for f in parsed_struct.fields.clone() {\n+        let field = format!(\n+            \"\n+            let {}: Vec<FieldMarker> = {}{}::get_structure(& data[offset..])?;\n+            offset += {}.size_hint_(&data, offset)?;\n+            let {} =  {}.into();\n+            fields.push({});\n+            \",\n+            f.name,\n+            f.type_,\n+            f.get_generics(),\n+            f.name,\n+            f.name,\n+            f.name,\n+            f.name\n+        );\n+        derive_fields.push_str(&field)\n+    }\n+\n+    let mut derive_decoded_fields = String::new();\n+    let mut fields = parsed_struct.fields.clone();\n+\n+    // Reverse the fields as they are popped out from the end of the vector but we want to pop out\n+    // from the front\n+    fields.reverse();\n+\n+    // Create Struct from fields\n+    for f in fields.clone() {\n+        let field = format!(\n+            \"\n+            {}: {}{}::from_decoded_fields(data.pop().unwrap().into())?,\n+            \",\n+            f.name,\n+            f.type_,\n+            f.get_generics()\n+        );\n+        derive_decoded_fields.push_str(&field)\n+    }\n+\n+    let impl_generics = if !parsed_struct.generics.is_empty() {\n+        parsed_struct.clone().generics\n+    } else {\n+        \"<'decoder>\".to_string()\n+    };\n+\n+    let result = format!(\n+        \"mod impl_parse_decodable_{} {{\n+\n+    use super::binary_codec_sv2::{{decodable::DecodableField, decodable::FieldMarker, Decodable, Error, SizeHint}};\n+    use super::*;\n+\n+    impl{} Decodable<'decoder> for {}{} {{\n+        fn get_structure(data: &[u8]) -> Result<Vec<FieldMarker>, Error> {{\n+            let mut fields = Vec::new();\n+            let mut offset = 0;\n+            {}\n+            Ok(fields)\n+        }}\n+\n+        fn from_decoded_fields(mut data: Vec<DecodableField<'decoder>>) -> Result<Self, Error> {{\n+            Ok(Self {{\n+                {}\n+            }})\n+        }}\n+    }}\n+    }}\",\n+        // imports\n+        parsed_struct.name.to_lowercase(),\n+        // derive decodable\n+        impl_generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        derive_fields,\n+        derive_decoded_fields,\n+    );\n+    //println!(\"{}\", result);\n+\n+    result.parse().unwrap()\n+}\n+\n+#[proc_macro_derive(Encodable)]\n+pub fn encodable(item: TokenStream) -> TokenStream {\n+    let parsed_struct = get_struct_properties(item);\n+    let fields = parsed_struct.fields.clone();\n+\n+    let mut field_into_decoded_field = String::new();\n+\n+    // Create DecodableField from fields\n+    for f in fields.clone() {\n+        let field = format!(\n+            \"\n+            let val = v.{};\n+            fields.push(val.into());\n+            \",\n+            f.name\n+        );\n+        field_into_decoded_field.push_str(&field)\n+    }\n+\n+    let mut sizes = String::new();\n+\n+    for f in fields {\n+        let field = format!(\n+            \"\n+            size += self.{}.get_size();\n+            \",\n+            f.name\n+        );\n+        sizes.push_str(&field)\n+    }\n+    let impl_generics = if !parsed_struct.generics.is_empty() {\n+        parsed_struct.clone().generics\n+    } else {\n+        \"<'decoder>\".to_string()\n+    };\n+\n+    let result = format!(\n+        \"mod impl_parse_encodable_{} {{\n+\n+    use super::binary_codec_sv2::{{encodable::EncodableField, GetSize}};\n+    use super::{};\n+    extern crate alloc;\n+    use alloc::vec::Vec;\n+\n+    impl{} From<{}{}> for EncodableField<'decoder> {{\n+        fn from(v: {}{}) -> Self {{\n+            let mut fields: Vec<EncodableField> = Vec::new();\n+            {}\n+            Self::Struct(fields)\n+        }}\n+    }}\n+\n+\n+    impl{} GetSize for {}{} {{\n+        fn get_size(&self) -> usize {{\n+            let mut size = 0;\n+            {}\n+            size\n+        }}\n+    }}\n+\n+    }}\",\n+        // imports\n+        parsed_struct.name.to_lowercase(),\n+        parsed_struct.name,\n+        // impl From<Struct> for DecodableField\n+        impl_generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        field_into_decoded_field,\n+        // impl Encodable for Struct\n+        //impl{} Encodable<'decoder> for {}{} {{}}\n+        //impl_generics,\n+        //parsed_struct.name,\n+        //parsed_struct.generics,\n+        // impl GetSize for Struct\n+        impl_generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        sizes,\n+    );\n+    //println!(\"{}\", result);\n+\n+    result.parse().unwrap()\n+}"
      },
      {
        "sha": "4052c9d216a80d9d851dbb8bbabf90c2ace0e882",
        "filename": "src/rusty/binary-sv2/serde-sv2/Cargo.toml",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"serde_sv2\"\n+version = \"0.1.0\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Serlializer and Deserializer for Stratum V2 data format\"\n+license = \"MIT\"\n+\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", features = [\"derive\", \"alloc\"], default-features = false }\n+buffer_sv2 = {version = \"0.1.0\",  path = \"../../../../utils/buffer\"}"
      },
      {
        "sha": "3132feab88a888bc6a2842a2aa7d0a920a0f37ba",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/de.rs",
        "status": "added",
        "additions": 969,
        "deletions": 0,
        "changes": 969,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/de.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/de.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/de.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,969 @@\n+//! Serde deserializer for [stratum v2][Sv2] implemented following [serde tutorial][tutorial]\n+//!\n+//! [Sv2]: https://docs.google.com/document/d/1FadCWj-57dvhxsnFM_7X806qyvhR0u3i85607bGHxvg/edit\n+//! [tutorial]: https://serde.rs/data-format.html\n+use alloc::vec::Vec;\n+use core::convert::TryInto;\n+\n+use serde::de::{self, DeserializeSeed, SeqAccess, Visitor};\n+use serde::Deserialize;\n+\n+use crate::error::{Error, Result};\n+\n+//enum Sv2Seq {\n+//    S64k,\n+//    S255,\n+//}\n+\n+#[derive(Debug)]\n+pub struct Deserializer<'de> {\n+    input: &'de [u8],\n+    len: u8,\n+}\n+\n+impl<'de> Deserializer<'de> {\n+    fn _new(input: &'de mut [u8]) -> Self {\n+        Deserializer { input, len: 0 }\n+    }\n+\n+    pub fn from_bytes(input: &'de mut [u8]) -> Self {\n+        Self::_new(input)\n+    }\n+}\n+\n+pub fn from_bytes<'a, T>(b: &'a mut [u8]) -> Result<T>\n+where\n+    T: Deserialize<'a>,\n+{\n+    let mut deserializer = Deserializer::from_bytes(b);\n+    let t = T::deserialize(&mut deserializer)?;\n+    Ok(t)\n+}\n+\n+impl<'de> Deserializer<'de> {\n+    fn as_vec(&self) -> Vec<u8> {\n+        self.input.to_vec()\n+    }\n+\n+    #[inline]\n+    fn get_slice(&mut self, len: usize) -> Result<&'de [u8]> {\n+        if self.input.len() < len {\n+            return Err(Error::ReadError);\n+        };\n+\n+        let (sl, rem) = &self.input.split_at(len);\n+        self.input = rem;\n+\n+        Ok(sl)\n+    }\n+\n+    #[inline]\n+    fn parse_bytes(&mut self) -> &'de [u8] {\n+        self.input\n+    }\n+\n+    #[inline]\n+    fn parse_seq0255(&mut self, element_size: u8) -> Result<&'de [u8]> {\n+        let len = self.parse_u8()?;\n+        let len = len as usize * element_size as usize;\n+        self.get_slice(len as usize)\n+    }\n+\n+    #[inline]\n+    fn parse_seq064k(&mut self, element_size: u8) -> Result<&'de [u8]> {\n+        let len = self.parse_u16()?;\n+        let len = len as usize * element_size as usize;\n+        self.get_slice(len as usize)\n+    }\n+\n+    #[inline]\n+    fn parse_seq064k_variable(&mut self, element_size: u8) -> Result<&'de [u8]> {\n+        let element_size = element_size as usize;\n+        let len = self.parse_u16()?;\n+        let mut next_element_index: usize = 0;\n+        for _ in 0..len {\n+            let len = &self.input[next_element_index..next_element_index + element_size];\n+            let len = match element_size {\n+                1 => len[0] as u32,\n+                2 => u32::from_le_bytes([len[0], len[1], 0, 0]),\n+                3 => u32::from_le_bytes([len[0], len[1], len[2], 0]),\n+                _ => unreachable!(),\n+            };\n+            next_element_index += len as usize + element_size;\n+        }\n+        self.get_slice(next_element_index)\n+    }\n+\n+    #[inline]\n+    fn parse_bool(&mut self) -> Result<bool> {\n+        let bool_ = self.get_slice(1)?;\n+        match bool_ {\n+            [0] => Ok(false),\n+            [1] => Ok(true),\n+            _ => Err(Error::InvalidBool(bool_[0])),\n+        }\n+    }\n+\n+    #[inline]\n+    fn parse_u8(&mut self) -> Result<u8> {\n+        let u8_ = self.get_slice(1)?;\n+        Ok(u8_[0])\n+    }\n+\n+    #[inline]\n+    fn parse_u16(&mut self) -> Result<u16> {\n+        let u16_ = self.get_slice(2)?;\n+        Ok(u16::from_le_bytes([u16_[0], u16_[1]]))\n+    }\n+\n+    #[inline]\n+    fn parse_u24(&mut self) -> Result<u32> {\n+        let u24 = self.get_slice(3)?;\n+        Ok(u32::from_le_bytes([u24[0], u24[1], u24[2], 0]))\n+    }\n+\n+    #[inline]\n+    fn parse_u32(&mut self) -> Result<u32> {\n+        let u32_ = self.get_slice(4)?;\n+        Ok(u32::from_le_bytes([u32_[0], u32_[1], u32_[2], u32_[3]]))\n+    }\n+\n+    #[inline]\n+    fn parse_f32(&mut self) -> Result<f32> {\n+        let f32_ = self.get_slice(4)?;\n+        Ok(f32::from_le_bytes([f32_[0], f32_[1], f32_[2], f32_[3]]))\n+    }\n+\n+    #[inline]\n+    fn parse_u256(&mut self) -> Result<&'de [u8; 32]> {\n+        // slice is 32 bytes so unwrap never called\n+        let u256: &[u8; 32] = self.get_slice(32)?.try_into().unwrap();\n+        Ok(u256)\n+    }\n+\n+    #[inline]\n+    fn parse_signature(&mut self) -> Result<&'de [u8; 64]> {\n+        // slice is 64 bytes so unwrap never called\n+        let signature: &[u8; 64] = self.get_slice(64)?.try_into().unwrap();\n+        Ok(signature)\n+    }\n+\n+    #[inline]\n+    fn parse_string(&mut self) -> Result<&'de str> {\n+        let len = self.parse_u8()?;\n+        let str_ = self.get_slice(len as usize)?;\n+        core::str::from_utf8(str_).map_err(|_| Error::InvalidUtf8)\n+    }\n+\n+    #[inline]\n+    fn parse_b016m(&mut self) -> Result<&'de [u8]> {\n+        let len = self.parse_u24()?;\n+        self.get_slice(len as usize)\n+    }\n+\n+    #[inline]\n+    fn parse_b064k(&mut self) -> Result<&'de [u8]> {\n+        let len = self.parse_u16()?;\n+        self.get_slice(len as usize)\n+    }\n+\n+    #[inline]\n+    fn parse_b0255(&mut self) -> Result<&'de [u8]> {\n+        let len = self.parse_u8()?;\n+        self.get_slice(len as usize)\n+    }\n+    #[inline]\n+    fn parse_b032(&mut self) -> Result<&'de [u8]> {\n+        let len = self.parse_u8()?;\n+        self.get_slice(len as usize)\n+    }\n+}\n+\n+impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_u8(self.parse_u8()?)\n+    }\n+\n+    #[inline]\n+    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_u16(self.parse_u16()?)\n+    }\n+\n+    #[inline]\n+    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_u32(self.parse_u32()?)\n+    }\n+\n+    #[inline]\n+    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_str(self.parse_string()?)\n+    }\n+\n+    #[inline]\n+    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        self.deserialize_str(visitor)\n+    }\n+\n+    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        self.deserialize_byte_buf(visitor)\n+    }\n+\n+    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_byte_buf(self.as_vec())\n+    }\n+\n+    #[inline]\n+    fn deserialize_struct<V>(\n+        self,\n+        _name: &'static str,\n+        fields: &'static [&'static str],\n+        visitor: V,\n+    ) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_seq(Struct::new(self, fields.len()))\n+    }\n+\n+    // Each Sv2 primitive type is implemented as a new type struct.\n+    fn deserialize_newtype_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        match _name {\n+            \"U24\" => visitor.visit_u32(self.parse_u24()?),\n+            \"U256\" => visitor.visit_borrowed_bytes(self.parse_u256()?),\n+            \"Signature\" => visitor.visit_borrowed_bytes(self.parse_signature()?),\n+            \"B016M\" => visitor.visit_borrowed_bytes(self.parse_b016m()?),\n+            \"B064K\" => visitor.visit_borrowed_bytes(self.parse_b064k()?),\n+            \"B0255\" => visitor.visit_borrowed_bytes(self.parse_b0255()?),\n+            \"B032\" => visitor.visit_borrowed_bytes(self.parse_b032()?),\n+            \"Seq_0255_U256\" => visitor.visit_borrowed_bytes(self.parse_seq0255(32)?),\n+            \"Seq_0255_Bool\" => visitor.visit_borrowed_bytes(self.parse_seq0255(1)?),\n+            \"Seq_0255_U16\" => visitor.visit_borrowed_bytes(self.parse_seq0255(2)?),\n+            \"Seq_0255_U24\" => visitor.visit_borrowed_bytes(self.parse_seq0255(3)?),\n+            \"Seq_0255_U32\" => visitor.visit_borrowed_bytes(self.parse_seq0255(4)?),\n+            \"Seq_0255_Signature\" => visitor.visit_borrowed_bytes(self.parse_seq0255(64)?),\n+            \"Seq_064K_U256\" => visitor.visit_borrowed_bytes(self.parse_seq064k(32)?),\n+            \"Seq_064K_Bool\" => visitor.visit_borrowed_bytes(self.parse_seq064k(1)?),\n+            \"Seq_064K_U16\" => visitor.visit_borrowed_bytes(self.parse_seq064k(2)?),\n+            \"Seq_064K_U24\" => visitor.visit_borrowed_bytes(self.parse_seq064k(3)?),\n+            \"Seq_064K_U32\" => visitor.visit_borrowed_bytes(self.parse_seq064k(4)?),\n+            \"Seq_064K_U64\" => visitor.visit_borrowed_bytes(self.parse_seq064k(8)?),\n+            \"Seq_064K_Signature\" => visitor.visit_borrowed_bytes(self.parse_seq064k(64)?),\n+            \"Seq_064K_B064K\" => visitor.visit_borrowed_bytes(self.parse_seq064k_variable(2)?),\n+            \"Seq_064K_B016M\" => visitor.visit_borrowed_bytes(self.parse_seq064k_variable(3)?),\n+            \"Bytes\" => visitor.visit_borrowed_bytes(self.parse_bytes()),\n+            _ => unreachable!(\"Invalid type\"),\n+            //_ => visitor.visit_newtype_struct(self),\n+        }\n+    }\n+\n+    #[inline]\n+    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_bool(self.parse_bool()?)\n+    }\n+\n+    ///// UNIMPLEMENTED /////\n+\n+    fn deserialize_option<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_unit<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_unit_struct<V>(self, _name: &'static str, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_i8<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_i16<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_i32<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_i64<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_u64<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_f32(self.parse_f32()?)\n+    }\n+\n+    // Float parsing is stupidly hard.\n+    fn deserialize_f64<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_char<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        todo!()\n+    }\n+\n+    fn deserialize_tuple<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_tuple_struct<V>(\n+        self,\n+        _name: &'static str,\n+        _len: usize,\n+        _visitor: V,\n+    ) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_map<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_enum<V>(\n+        self,\n+        _name: &'static str,\n+        _variants: &'static [&'static str],\n+        _visitor: V,\n+    ) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_identifier<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn deserialize_ignored_any<V>(self, _visitor: V) -> Result<V::Value>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Seq<'de, 'a> {\n+    de: &'a mut Deserializer<'de>,\n+    len: usize,\n+}\n+\n+//impl<'de, 'a> Seq<'de, 'a> {\n+//    fn new(de: &'a mut Deserializer<'de>, type_: Sv2Seq) -> std::result::Result<Self, Error> {\n+//        let len = match type_ {\n+//            Sv2Seq::S255 => de.parse_u8()? as usize,\n+//            Sv2Seq::S64k => de.parse_u16()? as usize,\n+//        };\n+//        Ok(Self { de, len })\n+//    }\n+//}\n+\n+impl<'de, 'a> SeqAccess<'de> for Seq<'de, 'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        // Check if there are no more elements.\n+        if self.len == 0 {\n+            return Ok(None);\n+        }\n+\n+        self.len -= 1;\n+\n+        seed.deserialize(&mut *self.de).map(Some)\n+    }\n+}\n+\n+struct Struct<'de, 'a> {\n+    de: &'a mut Deserializer<'de>,\n+    len: usize,\n+}\n+\n+impl<'de, 'a> Struct<'de, 'a> {\n+    fn new(de: &'a mut Deserializer<'de>, len: usize) -> Self {\n+        Self { de, len }\n+    }\n+}\n+\n+impl<'de, 'a> SeqAccess<'de> for Struct<'de, 'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        // Check if there are no more elements.\n+        if self.len == 0 {\n+            return Ok(None);\n+        }\n+\n+        self.len -= 1;\n+\n+        seed.deserialize(&mut *self.de).map(Some)\n+    }\n+}\n+\n+///// TEST /////\n+\n+#[test]\n+fn test_struct() {\n+    use serde::Serialize;\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test {\n+        a: u32,\n+        b: u8,\n+        c: crate::primitives::U24,\n+    }\n+\n+    let expected = Test {\n+        a: 456,\n+        b: 9,\n+        c: 67_u32.try_into().unwrap(),\n+    };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_b0255() {\n+    use serde::Serialize;\n+\n+    let b0255: crate::primitives::B0255 = (&[6; 3][..]).try_into().unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::B0255<'a>,\n+    }\n+\n+    let expected = Test { a: b0255 };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_u256() {\n+    use serde::Serialize;\n+\n+    let u256: crate::primitives::U256 = (&[6; 32][..]).try_into().unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::U256<'a>,\n+    }\n+\n+    let expected = Test { a: u256 };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_signature() {\n+    use serde::Serialize;\n+\n+    let s: crate::primitives::Signature = (&[6; 64][..]).try_into().unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Signature<'a>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_b016m() {\n+    use serde::Serialize;\n+\n+    let b: crate::primitives::B016M = (&[0; 70000][..]).try_into().unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        b: bool,\n+        #[serde(borrow)]\n+        a: crate::primitives::B016M<'a>,\n+    }\n+\n+    let expected = Test { a: b, b: true };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_b064k() {\n+    use core::convert::TryInto;\n+    use serde::Serialize;\n+\n+    let b: crate::primitives::B064K = (&[1, 2, 9][..])\n+        .try_into()\n+        .expect(\"vector smaller than 64K should not fail\");\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        b: bool,\n+        #[serde(borrow)]\n+        a: crate::primitives::B064K<'a>,\n+    }\n+\n+    let expected = Test { a: b, b: true };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq0255_u256() {\n+    use crate::primitives::Seq0255;\n+    use crate::primitives::U256;\n+    use serde::Serialize;\n+\n+    let u256_1: crate::primitives::U256 = (&[6; 32][..]).try_into().unwrap();\n+    let u256_2: crate::primitives::U256 = (&[5; 32][..]).try_into().unwrap();\n+    let u256_3: crate::primitives::U256 = (&[0; 32][..]).try_into().unwrap();\n+\n+    let val = vec![u256_1, u256_2, u256_3];\n+    let s = Seq0255::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Seq0255<'a, U256<'a>>,\n+    }\n+\n+    let test = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&test).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    let bytes_2 = crate::ser::to_bytes(&deserialized).unwrap();\n+\n+    assert_eq!(bytes, bytes_2);\n+}\n+\n+#[test]\n+fn test_seq0255_bool() {\n+    use crate::primitives::Seq0255;\n+    use serde::Serialize;\n+\n+    let s: crate::primitives::Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Seq0255<'a, bool>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq0255_u16() {\n+    use crate::primitives::Seq0255;\n+    use crate::primitives::U16;\n+    use serde::Serialize;\n+\n+    let s: crate::primitives::Seq0255<U16> = Seq0255::new(vec![10, 43, 89]).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Seq0255<'a, U16>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq0255_u24() {\n+    use crate::primitives::Seq0255;\n+    use crate::primitives::U24;\n+    use serde::Serialize;\n+\n+    let u24_1 = U24(56);\n+    let u24_2 = U24(59);\n+    let u24_3 = U24(70999);\n+\n+    let val = vec![u24_1, u24_2, u24_3];\n+    let s: crate::primitives::Seq0255<U24> = Seq0255::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Seq0255<'a, U24>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq0255_u32() {\n+    use crate::primitives::Seq0255;\n+    use serde::Serialize;\n+\n+    let s: crate::primitives::Seq0255<u32> = Seq0255::new(vec![546, 99999, 87, 32]).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Seq0255<'a, u32>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq0255_signature() {\n+    use crate::primitives::Seq0255;\n+    use crate::primitives::Signature;\n+    use serde::Serialize;\n+\n+    let siganture_1: Signature = (&[88; 64][..]).try_into().unwrap();\n+    let siganture_2: Signature = (&[99; 64][..]).try_into().unwrap();\n+    let siganture_3: Signature = (&[220; 64][..]).try_into().unwrap();\n+\n+    let val = vec![siganture_1, siganture_2, siganture_3];\n+    let s: crate::primitives::Seq0255<Signature> = Seq0255::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: crate::primitives::Seq0255<'a, Signature<'a>>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq064k_u256() {\n+    use crate::primitives::Seq064K;\n+    use crate::primitives::U256;\n+    use serde::Serialize;\n+\n+    let u256_1: crate::primitives::U256 = (&[6; 32][..]).try_into().unwrap();\n+    let u256_2: crate::primitives::U256 = (&[5; 32][..]).try_into().unwrap();\n+    let u256_3: crate::primitives::U256 = (&[0; 32][..]).try_into().unwrap();\n+\n+    let val = vec![u256_1, u256_2, u256_3];\n+    let s = Seq064K::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, U256<'a>>,\n+    }\n+\n+    let test = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&test).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    let bytes_2 = crate::ser::to_bytes(&deserialized).unwrap();\n+\n+    assert_eq!(bytes, bytes_2);\n+}\n+\n+#[test]\n+fn test_seq064k_bool() {\n+    use crate::primitives::Seq064K;\n+    use serde::Serialize;\n+\n+    let s: Seq064K<bool> = Seq064K::new(vec![true, false, true]).unwrap();\n+    let s2: Seq064K<bool> = Seq064K::new(vec![true; 64000]).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, bool>,\n+    }\n+\n+    let expected = Test { a: s };\n+    let expected2 = Test { a: s2 };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let mut bytes2 = crate::ser::to_bytes(&expected2).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+    let deserialized2: Test = from_bytes(&mut bytes2[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+    assert_eq!(deserialized2, expected2);\n+}\n+\n+#[test]\n+fn test_seq064k_u16() {\n+    use crate::primitives::Seq064K;\n+    use crate::primitives::U16;\n+    use serde::Serialize;\n+\n+    let s: Seq064K<U16> = Seq064K::new(vec![10, 43, 89]).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, U16>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq064k_u24() {\n+    use crate::primitives::Seq064K;\n+    use crate::primitives::U24;\n+    use serde::Serialize;\n+\n+    let u24_1 = U24(56);\n+    let u24_2 = U24(59);\n+    let u24_3 = U24(70999);\n+\n+    let val = vec![u24_1, u24_2, u24_3];\n+    let s: Seq064K<U24> = Seq064K::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, U24>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq064k_u32() {\n+    use crate::primitives::Seq064K;\n+    use serde::Serialize;\n+\n+    let s: Seq064K<u32> = Seq064K::new(vec![546, 99999, 87, 32]).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, u32>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq064k_signature() {\n+    use crate::primitives::Seq064K;\n+    use crate::primitives::Signature;\n+    use serde::Serialize;\n+\n+    let siganture_1: Signature = (&[88_u8; 64][..]).try_into().unwrap();\n+    let siganture_2: Signature = (&[99_u8; 64][..]).try_into().unwrap();\n+    let siganture_3: Signature = (&[220_u8; 64][..]).try_into().unwrap();\n+\n+    let val = vec![siganture_1, siganture_2, siganture_3];\n+    let s: Seq064K<Signature> = Seq064K::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, Signature<'a>>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}\n+\n+#[test]\n+fn test_seq064k_b016m() {\n+    use crate::primitives::Seq064K;\n+    use crate::primitives::B016M;\n+    use serde::Serialize;\n+\n+    let bytes_1: B016M = (&[88_u8; 64][..]).try_into().unwrap();\n+    let bytes_2: B016M = (&[99_u8; 64][..]).try_into().unwrap();\n+    let bytes_3: B016M = (&[220_u8; 64][..]).try_into().unwrap();\n+\n+    let val = vec![bytes_1, bytes_2, bytes_3];\n+    let s: Seq064K<B016M> = Seq064K::new(val).unwrap();\n+\n+    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n+    struct Test<'a> {\n+        #[serde(borrow)]\n+        a: Seq064K<'a, B016M<'a>>,\n+    }\n+\n+    let expected = Test { a: s };\n+\n+    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n+\n+    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+    assert_eq!(deserialized, expected);\n+}"
      },
      {
        "sha": "78522f60894465937ee5a8b5c6eb180d7b2f2055",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/error.rs",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/error.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,62 @@\n+use alloc::string::String;\n+use core::fmt::{self, Display};\n+\n+use serde::{de, ser};\n+\n+pub type Result<T> = core::result::Result<T, Error>;\n+\n+// TODO provode additional information in the error type:\n+// 1. byte offset into the input\n+// 2. ??\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum Error {\n+    // One or more variants that can be created by data structures through the\n+    // `ser::Error` and `de::Error` traits. For example the Serialize impl for\n+    // Mutex<T> might return an error because the mutex is poisoned, or the\n+    // Deserialize impl for a struct may return an error because a required\n+    // field is missing.\n+    Message(String),\n+\n+    StringLenBiggerThan256,\n+    InvalidUtf8,\n+    LenBiggerThan16M,\n+    LenBiggerThan255,\n+    LenBiggerThan32,\n+    LenBiggerThan64K,\n+    WriteError,\n+    ReadError,\n+    InvalidBoolSize(usize),\n+    InvalidBool(u8),\n+    InvalidU256(usize),\n+    InvalidSignatureSize(usize),\n+    InvalidU16Size(usize),\n+    InvalidU24Size(usize),\n+    InvalidU32Size(usize),\n+    InvalidU64Size(usize),\n+    U24TooBig(u32),\n+}\n+\n+impl ser::Error for Error {\n+    fn custom<T: Display>(msg: T) -> Self {\n+        Error::Message(format!(\"{}\", msg))\n+    }\n+}\n+\n+impl de::Error for Error {\n+    fn custom<T: Display>(msg: T) -> Self {\n+        Error::Message(format!(\"{}\", msg))\n+    }\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Error::Message(msg) => formatter.write_str(msg),\n+            Error::WriteError => formatter.write_str(\"write error\"),\n+            Error::ReadError => formatter.write_str(\"read error\"),\n+            _ => formatter.write_str(\"TODO display not implemented\"),\n+        }\n+    }\n+}\n+\n+// impl core::error::Error for Error {}"
      },
      {
        "sha": "5071614bad7ad81909bece9a47a186b2545300c1",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/lib.rs",
        "status": "added",
        "additions": 92,
        "deletions": 0,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,92 @@\n+//! Serde serializer/deserializer for [stratum v2][Sv2] implemented following [serde tutorial][tutorial]\n+//!\n+//! ```txt\n+//! SERDE    <-> Sv2\n+//! bool     <-> BOOL\n+//! u8       <-> U8\n+//! u16      <-> U16\n+//! U24      <-> U24\n+//! u32      <-> u32\n+//! f32      <-> f32 // todo not in the spec but used\n+//! u64      <-> u64 // TODO not in the spec but used\n+//! U256     <-> U256\n+//! String   <-> STRO_255\n+//! Signature<-> SIGNATURE\n+//! B032     <-> B0_32 // todo not in the spec but used\n+//! B032     <-> STR0_32 // todo not in the spec but used\n+//! B0255    <-> B0_255\n+//! B064K    <-> B0_64K\n+//! B016M    <-> B0_16M\n+//! [u8]     <-> BYTES\n+//! Pubkey   <-> PUBKEY\n+//! Seq0255  <-> SEQ0_255[T]\n+//! Seq064K  <-> SEQ0_64K[T]\n+//! ```\n+//! Serilalizer and Deserializer are implemented using slices in order to reduce copies:\n+//!\n+//! ## Fixed length primitives:\n+//! Each fixed length Sv2 primitive type when deserialized contains a view in the input buffer so\n+//! no copy is needed to deserialize raw bytes.\n+//!\n+//! ## Non fixed legth primitives\n+//! Non fixed lenght primitives can be diveded in strings, byte sequences and general sequences.\n+//!\n+//! ### Strings\n+//! Strings are automatically handled by Serde\n+//!\n+//! ### Generic sequences\n+//! Non byte sequences `SEQ0_255[T]` and  `SEQ0_64K[T]` are implemented as a\n+//! struct that contains two optional field:\n+//! * an optional view in the input buffer\n+//! * an optional slice of T\n+//!\n+//! When the sequence is constructed from a serialized message we just get a view in the input\n+//! buffer and no data is copyed.\n+//!\n+//! When the sequence is constructed from [T] the sequnce can safely point to them without\n+//! transmute.\n+//!\n+//! ### Bytes sequences\n+//! Byte sequences can be limited lenght sequences or unlimited length sequences, the latter are\n+//! automatically handled by Serde.\n+//! Limited lenght byte sequences are not implemented as a specific new type of generic sequences cause:\n+//! * For the rust type system a serialized byte array and a deserialized byte array are the same\n+//!   thing, that is not true for generic sequences.\n+//! * In order to not copy data around generic sequences need to be implemented as struct containing\n+//!   two optional field, a slice of byte and a slice of T.\n+//! * This dicotomy is not needed for byte sequences so they are implemented as specific smaller\n+//! struct.\n+//!\n+//! ## Why not rkyv?\n+//! [rkyv][rkyv1] is a a zero-copy deserialization framework for Rust. I do not know rkyv but it\n+//! seems that the objective of this library could have been readched with less effort and\n+//! [better][rkyv2] using rykv instad then serder.\n+//!\n+//! Btw Serde is like standard for rust code, very safe and stable. The deserialization/serialization\n+//! part will be in the code that need to be added to bitcoin core, so it must use the most safe and\n+//! stable option. That do not exclude that a serialization/deserialization backend can be implemented\n+//! with rykv and then used by the subprotocols crates via a conditional compilation flag!\n+//!\n+//! [Sv2]: https://docs.google.com/document/d/1FadCWj-57dvhxsnFM_7X806qyvhR0u3i85607bGHxvg/edit\n+//! [tutorial]: https://serde.rs/data-format.html\n+//! [rkyv1]: https://docs.rs/rkyv/0.4.3/rkyv\n+//! [rkyv2]: https://davidkoloski.me/blog/rkyv-is-faster-than/\n+\n+#![no_std]\n+\n+#[macro_use]\n+extern crate alloc;\n+\n+mod de;\n+mod error;\n+mod primitives;\n+mod ser;\n+\n+pub use de::{from_bytes, Deserializer};\n+pub use error::{Error, Result};\n+pub use primitives::{\n+    Bool, Bytes, GetSize, Pubkey, Seq0255, Seq064K, Signature, Str0255, B016M, B0255, B032, B064K,\n+    U16, U24, U256, U32, U64, U8,\n+};\n+pub use ser::{to_bytes, to_writer, Serializer};\n+pub type Str032<'a> = B032<'a>;"
      },
      {
        "sha": "7640786df81e6be7eb534b4a3434614bb9bb85d6",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,137 @@\n+use crate::error::Error;\n+use crate::primitives::GetSize;\n+use alloc::vec::Vec;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a> Inner<'a> {\n+    #[inline]\n+    pub fn len(&self) -> [u8; 3] {\n+        let l = match self {\n+            Self::Ref(v) => v.len().to_le_bytes(),\n+            Self::Owned(v) => v.len().to_le_bytes(),\n+        };\n+        [l[0], l[1], l[2]]\n+    }\n+\n+    #[inline]\n+    pub fn as_ref(&'a self) -> &'a [u8] {\n+        match self {\n+            Self::Ref(v) => v,\n+            Self::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct B016M<'b>(Inner<'b>);\n+\n+impl<'b> TryFrom<&'b [u8]> for B016M<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=16777215 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+impl<'b> TryFrom<&'b mut [u8]> for B016M<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=16777215 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<Vec<u8>> for B016M<'b> {\n+    type Error = Error;\n+\n+    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=16777215 => Ok(Self(Inner::Owned(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+\n+impl<'b> Serialize for B016M<'b> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        let len = self.0.len();\n+        let inner = self.0.as_ref();\n+\n+        // tuple is: (byte array len, byte array)\n+        let tuple = (len, &inner);\n+\n+        let tuple_len = 2;\n+        let mut seq = serializer.serialize_tuple(tuple_len)?;\n+\n+        seq.serialize_element(&tuple.0)?;\n+        seq.serialize_element(tuple.1)?;\n+        seq.end()\n+    }\n+}\n+\n+struct B016MVisitor;\n+\n+impl<'a> Visitor<'a> for B016MVisitor {\n+    type Value = B016M<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a byte array shorter than 16M\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(B016M(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for B016M<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"B016M\", B016MVisitor)\n+    }\n+}\n+\n+impl<'a> GetSize for B016M<'a> {\n+    fn get_size(&self) -> usize {\n+        match &self.0 {\n+            Inner::Ref(v) => v.len() + 3,\n+            Inner::Owned(v) => v.len() + 3,\n+        }\n+    }\n+}\n+\n+impl<'a> B016M<'a> {\n+    pub fn get_elements_number_in_array(a: &[u8]) -> usize {\n+        let total_len = a.len();\n+        let mut next_element_index: usize = 0;\n+        let mut elements_number: usize = 0;\n+        while next_element_index < total_len {\n+            let len = &a[next_element_index..next_element_index + 3];\n+            let len = u32::from_le_bytes([len[0], len[1], len[2], 0]);\n+            next_element_index += len as usize + 3;\n+            elements_number += 1;\n+        }\n+        elements_number\n+    }\n+}"
      },
      {
        "sha": "c93fd05dc8f22cba70db70fed375947dc39068a7",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs",
        "status": "added",
        "additions": 123,
        "deletions": 0,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,123 @@\n+use crate::error::Error;\n+use crate::primitives::GetSize;\n+use alloc::vec::Vec;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a> Inner<'a> {\n+    #[inline]\n+    pub fn len(&self) -> [u8; 1] {\n+        let l = match self {\n+            Self::Ref(v) => v.len().to_le_bytes(),\n+            Self::Owned(v) => v.len().to_le_bytes(),\n+        };\n+        [l[0]]\n+    }\n+\n+    #[inline]\n+    pub fn as_ref(&'a self) -> &'a [u8] {\n+        match self {\n+            Self::Ref(v) => v,\n+            Self::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct B0255<'b>(Inner<'b>);\n+\n+impl<'b> TryFrom<&'b [u8]> for B0255<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=255 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan255),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<&'b mut [u8]> for B0255<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=255 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan255),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<Vec<u8>> for B0255<'b> {\n+    type Error = Error;\n+\n+    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=255 => Ok(Self(Inner::Owned(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+\n+impl<'b> Serialize for B0255<'b> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        let len = self.0.len();\n+        let inner = self.0.as_ref();\n+\n+        // tuple is: (byte array len, byte array)\n+        let tuple = (len, &inner);\n+\n+        let tuple_len = 2;\n+        let mut seq = serializer.serialize_tuple(tuple_len)?;\n+\n+        seq.serialize_element(&tuple.0)?;\n+        seq.serialize_element(tuple.1)?;\n+        seq.end()\n+    }\n+}\n+\n+struct B0255Visitor;\n+\n+impl<'a> Visitor<'a> for B0255Visitor {\n+    type Value = B0255<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a byte array shorter than 255\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(B0255(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for B0255<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"B0255\", B0255Visitor)\n+    }\n+}\n+\n+impl<'a> GetSize for B0255<'a> {\n+    fn get_size(&self) -> usize {\n+        match &self.0 {\n+            Inner::Ref(v) => v.len() + 1,\n+            Inner::Owned(v) => v.len() + 1,\n+        }\n+    }\n+}"
      },
      {
        "sha": "6c2ba5937bf301ce285b4b78c882655f67d96f3b",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs",
        "status": "added",
        "additions": 123,
        "deletions": 0,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,123 @@\n+use crate::error::Error;\n+use crate::primitives::GetSize;\n+use alloc::vec::Vec;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a> Inner<'a> {\n+    #[inline]\n+    pub fn len(&self) -> [u8; 1] {\n+        let l = match self {\n+            Self::Ref(v) => v.len().to_le_bytes(),\n+            Self::Owned(v) => v.len().to_le_bytes(),\n+        };\n+        [l[0]]\n+    }\n+\n+    #[inline]\n+    pub fn as_ref(&'a self) -> &'a [u8] {\n+        match self {\n+            Self::Ref(v) => v,\n+            Self::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct B032<'b>(Inner<'b>);\n+\n+impl<'b> TryFrom<&'b [u8]> for B032<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=32 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan32),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<&'b mut [u8]> for B032<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=32 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan32),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<Vec<u8>> for B032<'b> {\n+    type Error = Error;\n+\n+    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=32 => Ok(Self(Inner::Owned(v))),\n+            _ => Err(Error::LenBiggerThan32),\n+        }\n+    }\n+}\n+\n+impl<'b> Serialize for B032<'b> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        let len = self.0.len();\n+        let inner = self.0.as_ref();\n+\n+        // tuple is: (byte array len, byte array)\n+        let tuple = (len, &inner);\n+\n+        let tuple_len = 2;\n+        let mut seq = serializer.serialize_tuple(tuple_len)?;\n+\n+        seq.serialize_element(&tuple.0)?;\n+        seq.serialize_element(tuple.1)?;\n+        seq.end()\n+    }\n+}\n+\n+struct B032Visitor;\n+\n+impl<'a> Visitor<'a> for B032Visitor {\n+    type Value = B032<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a byte array shorter than 32\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(B032(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for B032<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"B032\", B032Visitor)\n+    }\n+}\n+\n+impl<'a> GetSize for B032<'a> {\n+    fn get_size(&self) -> usize {\n+        match &self.0 {\n+            Inner::Ref(v) => v.len() + 1,\n+            Inner::Owned(v) => v.len() + 1,\n+        }\n+    }\n+}"
      },
      {
        "sha": "0bccbdc04eff7008a54102d15fca06a7806eb711",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs",
        "status": "added",
        "additions": 123,
        "deletions": 0,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,123 @@\n+use crate::error::Error;\n+use crate::primitives::GetSize;\n+use alloc::vec::Vec;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a> Inner<'a> {\n+    #[inline]\n+    pub fn len(&self) -> [u8; 2] {\n+        let l = match self {\n+            Self::Ref(v) => v.len().to_le_bytes(),\n+            Self::Owned(v) => v.len().to_le_bytes(),\n+        };\n+        [l[0], l[1]]\n+    }\n+\n+    #[inline]\n+    pub fn as_ref(&'a self) -> &'a [u8] {\n+        match self {\n+            Self::Ref(v) => v,\n+            Self::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct B064K<'b>(Inner<'b>);\n+\n+impl<'b> TryFrom<&'b [u8]> for B064K<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=65535 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<&'b mut [u8]> for B064K<'b> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=65535 => Ok(Self(Inner::Ref(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+\n+impl<'b> TryFrom<Vec<u8>> for B064K<'b> {\n+    type Error = Error;\n+\n+    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n+        match v.len() {\n+            0..=65535 => Ok(Self(Inner::Owned(v))),\n+            _ => Err(Error::LenBiggerThan16M),\n+        }\n+    }\n+}\n+\n+impl<'b> Serialize for B064K<'b> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        let len = self.0.len();\n+        let inner = self.0.as_ref();\n+\n+        // tuple is: (byte array len, byte array)\n+        let tuple = (len, &inner);\n+\n+        let tuple_len = 2;\n+        let mut seq = serializer.serialize_tuple(tuple_len)?;\n+\n+        seq.serialize_element(&tuple.0)?;\n+        seq.serialize_element(tuple.1)?;\n+        seq.end()\n+    }\n+}\n+\n+struct B064KVisitor;\n+\n+impl<'a> Visitor<'a> for B064KVisitor {\n+    type Value = B064K<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a byte array shorter than 64K\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(B064K(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for B064K<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"B064K\", B064KVisitor)\n+    }\n+}\n+\n+impl<'a> GetSize for B064K<'a> {\n+    fn get_size(&self) -> usize {\n+        match &self.0 {\n+            Inner::Ref(v) => v.len() + 2,\n+            Inner::Owned(v) => v.len() + 2,\n+        }\n+    }\n+}"
      },
      {
        "sha": "3f911a78c5b50060646c89b643cb6ced638b63e1",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,80 @@\n+use crate::primitives::GetSize;\n+use alloc::vec::Vec;\n+use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    #[allow(dead_code)]\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a> Inner<'a> {\n+    #[inline]\n+    pub fn as_ref(&'a self) -> &'a [u8] {\n+        match self {\n+            Self::Ref(v) => v,\n+            Self::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct Bytes<'b>(Inner<'b>);\n+\n+impl<'b> From<&'b [u8]> for Bytes<'b> {\n+    #[inline]\n+    fn from(v: &'b [u8]) -> Self {\n+        Self(Inner::Ref(v))\n+    }\n+}\n+impl<'b> From<&'b mut [u8]> for Bytes<'b> {\n+    #[inline]\n+    fn from(v: &'b mut [u8]) -> Self {\n+        Self(Inner::Ref(v))\n+    }\n+}\n+\n+impl<'b> Serialize for Bytes<'b> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        serializer.serialize_bytes(self.0.as_ref())\n+    }\n+}\n+\n+struct BytesVisitor;\n+\n+impl<'a> Visitor<'a> for BytesVisitor {\n+    type Value = Bytes<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a byte array shorter than 64K\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(Bytes(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Bytes<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"Bytes\", BytesVisitor)\n+    }\n+}\n+\n+impl<'a> GetSize for Bytes<'a> {\n+    fn get_size(&self) -> usize {\n+        match &self.0 {\n+            Inner::Ref(v) => v.len(),\n+            Inner::Owned(v) => v.len(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "3db63a58aa72b647b5d274eac7dc7fc92719cbe9",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,59 @@\n+pub mod b016m;\n+pub mod b0255;\n+pub mod b032;\n+pub mod b064k;\n+pub mod bytes;\n+\n+#[test]\n+fn test_b0_64k() {\n+    use crate::ser::to_bytes;\n+    use core::convert::TryInto;\n+\n+    let test: b064k::B064K = (&[1, 2, 9][..])\n+        .try_into()\n+        .expect(\"vector smaller than 64K should not fail\");\n+\n+    let expected = vec![3, 0, 1, 2, 9];\n+    assert_eq!(to_bytes(&test).unwrap(), expected);\n+}\n+\n+#[test]\n+fn test_b0_64k_2() {\n+    use crate::ser::to_bytes;\n+    use core::convert::TryInto;\n+\n+    let test: b064k::B064K = (&[10; 754][..])\n+        .try_into()\n+        .expect(\"vector smaller than 64K should not fail\");\n+\n+    let mut expected = vec![10; 756];\n+    expected[0] = 242;\n+    expected[1] = 2;\n+    assert_eq!(to_bytes(&test).unwrap(), expected);\n+}\n+\n+#[test]\n+fn test_b0_64k_3() {\n+    use crate::error::Error;\n+    use core::convert::TryInto;\n+\n+    let test: Result<b064k::B064K, Error> = (&[10; 70000][..]).try_into();\n+\n+    match test {\n+        Ok(_) => assert!(false, \"vector bigger than 64K should return an error\"),\n+        Err(_) => assert!(true),\n+    }\n+}\n+\n+#[test]\n+fn test_b0_16m() {\n+    use crate::ser::to_bytes;\n+    use core::convert::TryInto;\n+\n+    let test: b016m::B016M = (&[1 as u8, 2, 9][..])\n+        .try_into()\n+        .expect(\"vector smaller than 64K should not fail\");\n+\n+    let expected = vec![3, 0, 0, 1, 2, 9];\n+    assert_eq!(to_bytes(&test).unwrap(), expected);\n+}"
      },
      {
        "sha": "b5dd75505212e12c046e5fd0d0ca6dc03fe02114",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,81 @@\n+use alloc::{string::String, vec::Vec};\n+mod byte_arrays;\n+mod sequences;\n+mod signature;\n+mod u24;\n+mod u256;\n+\n+pub use byte_arrays::b016m::B016M;\n+pub use byte_arrays::b0255::B0255;\n+pub use byte_arrays::b032::B032;\n+pub use byte_arrays::b064k::B064K;\n+pub use byte_arrays::bytes::Bytes;\n+pub use sequences::seq0255::Seq0255;\n+pub use sequences::seq064k::Seq064K;\n+\n+pub use signature::Signature;\n+pub use u24::U24;\n+pub use u256::U256;\n+\n+pub type Bool = bool;\n+pub type U8 = u8;\n+pub type U16 = u16;\n+pub type U32 = u32;\n+pub type U64 = u64;\n+pub type Pubkey<'u> = U256<'u>;\n+// TODO rust string are valid UTF-8 Sv2 string (STR0255) are raw bytes. So there are Sv2 string not\n+// representable as Str0255. I suggest to define Sv2 STR0255 as 1 byte len + a valid UTF-8 string.\n+pub type Str0255<'a> = B0255<'a>;\n+\n+pub trait GetSize {\n+    fn get_size(&self) -> usize;\n+}\n+\n+pub trait FixedSize {\n+    const FIXED_SIZE: usize;\n+}\n+\n+impl<T: FixedSize> GetSize for T {\n+    fn get_size(&self) -> usize {\n+        T::FIXED_SIZE\n+    }\n+}\n+\n+impl FixedSize for bool {\n+    const FIXED_SIZE: usize = 1;\n+}\n+\n+impl FixedSize for u8 {\n+    const FIXED_SIZE: usize = 1;\n+}\n+\n+impl FixedSize for u16 {\n+    const FIXED_SIZE: usize = 2;\n+}\n+\n+impl FixedSize for u32 {\n+    const FIXED_SIZE: usize = 4;\n+}\n+\n+impl FixedSize for u64 {\n+    const FIXED_SIZE: usize = 8;\n+}\n+\n+impl GetSize for [u8] {\n+    fn get_size(&self) -> usize {\n+        self.len()\n+    }\n+}\n+\n+impl GetSize for String {\n+    fn get_size(&self) -> usize {\n+        // String is Str0255 1 byte len + x bytes\n+        self.len() + 1\n+    }\n+}\n+\n+impl GetSize for Vec<u8> {\n+    fn get_size(&self) -> usize {\n+        self.len()\n+    }\n+}"
      },
      {
        "sha": "dff6f7270408e2e0fadeeeda6fecf2cf90a2e28a",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,197 @@\n+use super::{Signature, B016M, B0255, B064K, U24, U256};\n+use crate::Error;\n+use core::convert::TryInto;\n+use serde::{de::Visitor, Serialize};\n+\n+pub mod seq0255;\n+pub mod seq064k;\n+\n+#[derive(Debug, PartialEq, Clone, Copy)]\n+enum SeqMaxLen {\n+    _1B,\n+    _2B,\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+struct Seq<'s, T: Clone + Serialize + TryFromBSlice<'s>> {\n+    data: &'s [u8],\n+    cursor: usize,\n+    size: u8,\n+    max_len: SeqMaxLen,\n+    _a: core::marker::PhantomData<T>,\n+}\n+\n+struct SeqVisitor<T> {\n+    inner_type_size: u8,\n+    max_len: SeqMaxLen,\n+    _a: core::marker::PhantomData<T>,\n+}\n+\n+impl<'a, T: Clone + Serialize + TryFromBSlice<'a>> Visitor<'a> for SeqVisitor<T> {\n+    type Value = Seq<'a, T>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        let max_len = match self.max_len {\n+            SeqMaxLen::_1B => \"255\",\n+            SeqMaxLen::_2B => \"64K\",\n+        };\n+        formatter.write_str(\n+            format!(\n+                \"an array shorter than {} elements, with elements of {} bytes\",\n+                max_len, self.inner_type_size\n+            )\n+            .as_str(),\n+        )\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(Seq {\n+            data: value,\n+            cursor: 0,\n+            max_len: self.max_len,\n+            size: self.inner_type_size,\n+            _a: core::marker::PhantomData,\n+        })\n+    }\n+}\n+\n+pub trait TryFromBSlice<'a> {\n+    type Error;\n+\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error>\n+    where\n+        Self: core::marker::Sized;\n+}\n+\n+impl<'a> TryFromBSlice<'a> for bool {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        if val.len() != 1 {\n+            return Err(Error::InvalidBoolSize(val.len()));\n+        }\n+        match val[0] {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => Err(Error::InvalidBool(val[0])),\n+        }\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for u16 {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        if val.len() != 2 {\n+            return Err(Error::InvalidU16Size(val.len()));\n+        }\n+        Ok(u16::from_le_bytes([val[0], val[1]]))\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for U24 {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        if val.len() != 3 {\n+            return Err(Error::InvalidU24Size(val.len()));\n+        }\n+        Ok(U24(u32::from_le_bytes([val[0], val[1], val[2], 0])))\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for u32 {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        if val.len() != 4 {\n+            return Err(Error::InvalidU32Size(val.len()));\n+        }\n+        Ok(u32::from_le_bytes([val[0], val[1], val[2], val[3]]))\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for u64 {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        if val.len() != 8 {\n+            return Err(Error::InvalidU64Size(val.len()));\n+        }\n+        Ok(u64::from_le_bytes([\n+            val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7],\n+        ]))\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for U256<'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        val.try_into()\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for Signature<'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        val.try_into()\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for B016M<'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        val.try_into()\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for B064K<'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        val.try_into()\n+    }\n+}\n+\n+impl<'a> TryFromBSlice<'a> for B0255<'a> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n+        val.try_into()\n+    }\n+}\n+\n+//impl<'a, T: TryFromBSlice<'a> + Serialize> Iterator for Seq<'a, T> {\n+//    type Item = T;\n+//\n+//    #[inline]\n+//    fn next(&mut self) -> Option<Self::Item> {\n+//        let start = self.cursor;\n+//        self.cursor += self.size as usize;\n+//        let end = self.cursor;\n+//        if end >= self.data.len() {\n+//            None\n+//        } else {\n+//            // The below should be always valid as there is no way to construct invalid sequences\n+//            // TODO check it\n+//            match T::try_from_slice(&self.data[start..end]) {\n+//                Ok(x) => Some(x),\n+//                Err(_) => None,\n+//            }\n+//        }\n+//    }\n+//}"
      },
      {
        "sha": "46f4c5fb58e844b684e461cfbb1b1f483a834284",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs",
        "status": "added",
        "additions": 200,
        "deletions": 0,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,200 @@\n+use super::super::{Signature, U24, U256};\n+use super::{Seq, SeqMaxLen, SeqVisitor, TryFromBSlice};\n+use crate::primitives::FixedSize;\n+use crate::primitives::GetSize;\n+use crate::Error;\n+use alloc::vec::Vec;\n+use serde::{ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, Clone)]\n+pub struct Seq0255<'s, T: Serialize + TryFromBSlice<'s> + Clone> {\n+    seq: Option<Seq<'s, T>>,\n+    data: Option<Vec<T>>,\n+}\n+\n+impl<'s, T: Clone + Serialize + TryFromBSlice<'s> + core::cmp::PartialEq> PartialEq\n+    for Seq0255<'s, T>\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        match (&self.seq, &self.data, &other.seq, &other.data) {\n+            (Some(seq1), _, Some(seq2), _) => seq1 == seq2,\n+            (_, Some(data1), _, Some(data2)) => data1 == data2,\n+            _ => crate::ser::to_bytes(&self) == crate::ser::to_bytes(&other),\n+        }\n+    }\n+}\n+\n+impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> Seq0255<'s, T> {\n+    #[inline]\n+    pub fn new(data: Vec<T>) -> Result<Self, Error> {\n+        if data.len() > 255 {\n+            Err(Error::LenBiggerThan255)\n+        } else {\n+            Ok(Seq0255 {\n+                seq: None,\n+                data: Some(data),\n+            })\n+        }\n+    }\n+}\n+\n+impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> From<Seq<'s, T>> for Seq0255<'s, T> {\n+    #[inline]\n+    fn from(val: Seq<'s, T>) -> Self {\n+        Self {\n+            seq: Some(val),\n+            data: None,\n+        }\n+    }\n+}\n+\n+impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> Serialize for Seq0255<'s, T> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        match (&self.seq, &self.data) {\n+            (Some(seq), None) => {\n+                let len = seq.data.len() / seq.size as usize;\n+                let tuple = (len as u8, seq.data);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            (None, Some(data)) => {\n+                let tuple = (data.len() as u8, &data[..]);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, U256<'a>> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_0255_U256\",\n+                SeqVisitor {\n+                    inner_type_size: 32,\n+                    max_len: SeqMaxLen::_1B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, bool> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_0255_Bool\",\n+                SeqVisitor {\n+                    inner_type_size: 1,\n+                    max_len: SeqMaxLen::_1B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, u16> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_0255_U16\",\n+                SeqVisitor {\n+                    inner_type_size: 2,\n+                    max_len: SeqMaxLen::_1B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, U24> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_0255_U24\",\n+                SeqVisitor {\n+                    inner_type_size: 3,\n+                    max_len: SeqMaxLen::_1B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, u32> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_0255_U32\",\n+                SeqVisitor {\n+                    inner_type_size: 4,\n+                    max_len: SeqMaxLen::_1B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, Signature<'a>> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_0255_Signature\",\n+                SeqVisitor {\n+                    inner_type_size: 64,\n+                    max_len: SeqMaxLen::_1B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'a, T: Clone + FixedSize + Serialize + TryFromBSlice<'a>> GetSize for Seq0255<'a, T> {\n+    fn get_size(&self) -> usize {\n+        if self.data.is_some() {\n+            (self.data.as_ref().unwrap().len() * T::FIXED_SIZE) + 1\n+        } else {\n+            self.seq.as_ref().unwrap().data.len() + 1\n+        }\n+    }\n+}"
      },
      {
        "sha": "0e5b2e87808bf9e683dd06245dcf10379dffcf7b",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs",
        "status": "added",
        "additions": 343,
        "deletions": 0,
        "changes": 343,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,343 @@\n+use super::super::{Signature, B016M, B064K, U24, U256};\n+use super::{Seq, SeqMaxLen, SeqVisitor, TryFromBSlice};\n+use crate::primitives::FixedSize;\n+use crate::primitives::GetSize;\n+use crate::Error;\n+use alloc::vec::Vec;\n+use serde::{ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, Clone)]\n+pub struct Seq064K<'s, T: Clone + Serialize + TryFromBSlice<'s>> {\n+    seq: Option<Seq<'s, T>>,\n+    data: Option<Vec<T>>,\n+}\n+\n+impl<'s, T: Clone + FixedSize + Serialize + TryFromBSlice<'s> + core::cmp::PartialEq> PartialEq\n+    for Seq064K<'s, T>\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        match (&self.seq, &self.data, &other.seq, &other.data) {\n+            (Some(seq1), _, Some(seq2), _) => seq1 == seq2,\n+            (_, Some(data1), _, Some(data2)) => data1 == data2,\n+            _ => crate::ser::to_bytes(&self) == crate::ser::to_bytes(&other),\n+        }\n+    }\n+}\n+\n+impl<'s> PartialEq for Seq064K<'s, B016M<'s>> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (&self.seq, &self.data, &other.seq, &other.data) {\n+            (Some(seq1), _, Some(seq2), _) => seq1 == seq2,\n+            (_, Some(data1), _, Some(data2)) => data1 == data2,\n+            _ => crate::ser::to_bytes(&self) == crate::ser::to_bytes(&other),\n+        }\n+    }\n+}\n+\n+impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> Seq064K<'s, T> {\n+    #[inline]\n+    pub fn new(data: Vec<T>) -> Result<Self, Error> {\n+        if data.len() > 65536 {\n+            Err(Error::LenBiggerThan64K)\n+        } else {\n+            Ok(Seq064K {\n+                seq: None,\n+                data: Some(data),\n+            })\n+        }\n+    }\n+}\n+\n+impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> From<Seq<'s, T>> for Seq064K<'s, T> {\n+    #[inline]\n+    fn from(val: Seq<'s, T>) -> Self {\n+        Self {\n+            seq: Some(val),\n+            data: None,\n+        }\n+    }\n+}\n+\n+impl<'s, T: Clone + FixedSize + Serialize + TryFromBSlice<'s>> Serialize for Seq064K<'s, T> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        match (&self.seq, &self.data) {\n+            (Some(seq), None) => {\n+                let len = seq.data.len() / seq.size as usize;\n+                let tuple = (len as u16, seq.data);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            (None, Some(data)) => {\n+                let tuple = (data.len() as u16, &data[..]);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+impl<'s> Serialize for Seq064K<'s, B064K<'s>> {\n+    // TODO test this function\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        match (&self.seq, &self.data) {\n+            (Some(seq), None) => {\n+                // TODO is len > than u16::MAX should return an error\n+                let len = B016M::get_elements_number_in_array(seq.data);\n+                let tuple = (len as u16, seq.data);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            (None, Some(data)) => {\n+                // TODO is data.len > than u16::MAX should return an error\n+                let tuple = (data.len() as u16, &data[..]);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+impl<'s> Serialize for Seq064K<'s, B016M<'s>> {\n+    // TODO test this function\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        match (&self.seq, &self.data) {\n+            (Some(seq), None) => {\n+                // TODO is len > than u16::MAX should return an error\n+                let len = B016M::get_elements_number_in_array(seq.data);\n+                let tuple = (len as u16, seq.data);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            (None, Some(data)) => {\n+                // TODO is data.len > than u16::MAX should return an error\n+                let tuple = (data.len() as u16, &data[..]);\n+                let mut seq = serializer.serialize_tuple(2)?;\n+                seq.serialize_element(&tuple.0)?;\n+                seq.serialize_element(tuple.1)?;\n+                seq.end()\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, U256<'a>> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_U256\",\n+                SeqVisitor {\n+                    inner_type_size: 32,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, bool> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_Bool\",\n+                SeqVisitor {\n+                    inner_type_size: 1,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, u16> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_U16\",\n+                SeqVisitor {\n+                    inner_type_size: 2,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, U24> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_U24\",\n+                SeqVisitor {\n+                    inner_type_size: 3,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, u32> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_U32\",\n+                SeqVisitor {\n+                    inner_type_size: 4,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, u64> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_U64\",\n+                SeqVisitor {\n+                    inner_type_size: 8,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, Signature<'a>> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_Signature\",\n+                SeqVisitor {\n+                    inner_type_size: 64,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, B064K<'a>> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_B064K\",\n+                SeqVisitor {\n+                    inner_type_size: 2,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, B016M<'a>> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer\n+            .deserialize_newtype_struct(\n+                \"Seq_064K_B016M\",\n+                SeqVisitor {\n+                    inner_type_size: 3,\n+                    max_len: SeqMaxLen::_2B,\n+                    _a: core::marker::PhantomData,\n+                },\n+            )\n+            .map(|x| x.into())\n+    }\n+}\n+\n+impl<'a, T: Clone + FixedSize + Serialize + TryFromBSlice<'a>> GetSize for Seq064K<'a, T> {\n+    fn get_size(&self) -> usize {\n+        if self.data.is_some() {\n+            (self.data.as_ref().unwrap().len() * T::FIXED_SIZE) + 2\n+        } else {\n+            self.seq.as_ref().unwrap().data.len() + 2\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for Seq064K<'a, B016M<'a>> {\n+    fn get_size(&self) -> usize {\n+        if self.data.is_some() {\n+            (self\n+                .data\n+                .as_ref()\n+                .unwrap()\n+                .iter()\n+                .fold(0, |acc, x| acc + x.get_size()))\n+                + 2\n+        } else {\n+            self.seq.as_ref().unwrap().data.len() + 2\n+        }\n+    }\n+}"
      },
      {
        "sha": "46d066312f93be33709cf6578266092fc3a886b6",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs",
        "status": "added",
        "additions": 94,
        "deletions": 0,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,94 @@\n+use crate::error::Error;\n+use crate::primitives::FixedSize;\n+use alloc::boxed::Box;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    Owned(Box<[u8; 64]>),\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct Signature<'u>(Inner<'u>);\n+\n+impl<'u> TryFrom<&'u [u8]> for Signature<'u> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'u [u8]) -> core::result::Result<Self, Error> {\n+        if v.len() == 64 {\n+            Ok(Self(Inner::Ref(v)))\n+        } else {\n+            Err(Error::InvalidSignatureSize(v.len()))\n+        }\n+    }\n+}\n+impl<'u> TryFrom<&'u mut [u8]> for Signature<'u> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'u mut [u8]) -> core::result::Result<Self, Error> {\n+        if v.len() == 64 {\n+            Ok(Self(Inner::Ref(v)))\n+        } else {\n+            Err(Error::InvalidSignatureSize(v.len()))\n+        }\n+    }\n+}\n+\n+impl<'u> From<[u8; 64]> for Signature<'u> {\n+    fn from(v: [u8; 64]) -> Self {\n+        Signature(Inner::Owned(Box::new(v)))\n+    }\n+}\n+\n+impl<'u> From<&'u Signature<'u>> for &'u [u8] {\n+    #[inline]\n+    fn from(v: &'u Signature<'u>) -> Self {\n+        match &v.0 {\n+            Inner::Ref(v) => v,\n+            Inner::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+impl<'u> Serialize for Signature<'u> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        serializer.serialize_bytes(self.into())\n+    }\n+}\n+\n+struct SignatureVisitor;\n+\n+impl<'a> Visitor<'a> for SignatureVisitor {\n+    type Value = Signature<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a 64 bytes unsigned le int\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(Signature(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for Signature<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"Signature\", SignatureVisitor)\n+    }\n+}\n+\n+impl<'a> FixedSize for Signature<'a> {\n+    const FIXED_SIZE: usize = 64;\n+}"
      },
      {
        "sha": "971bf86d85bffb0f940d7219258227e72075d04f",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,98 @@\n+use crate::primitives::FixedSize;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Copy, Clone)]\n+pub struct U24(pub(crate) u32);\n+\n+impl U24 {\n+    const MAX: u32 = 16777215;\n+}\n+\n+impl From<U24> for u32 {\n+    #[inline]\n+    fn from(v: U24) -> Self {\n+        v.0\n+    }\n+}\n+\n+impl From<&U24> for u32 {\n+    #[inline]\n+    fn from(v: &U24) -> Self {\n+        v.0\n+    }\n+}\n+\n+impl TryFrom<u32> for U24 {\n+    type Error = crate::Error;\n+\n+    fn try_from(v: u32) -> Result<Self, Self::Error> {\n+        match v {\n+            0..=Self::MAX => Ok(Self(v)),\n+            _ => Err(crate::Error::U24TooBig(v)),\n+        }\n+    }\n+}\n+\n+use core::convert::TryInto;\n+\n+impl TryFrom<usize> for U24 {\n+    type Error = crate::Error;\n+\n+    fn try_from(v: usize) -> Result<Self, Self::Error> {\n+        let v: u32 = v\n+            .try_into()\n+            .map_err(|_| crate::Error::U24TooBig(u32::MAX))?;\n+        match v {\n+            0..=Self::MAX => Ok(Self(v)),\n+            _ => Err(crate::Error::U24TooBig(v)),\n+        }\n+    }\n+}\n+\n+impl From<U24> for usize {\n+    fn from(v: U24) -> Self {\n+        v.0 as usize\n+    }\n+}\n+\n+impl Serialize for U24 {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        serializer.serialize_bytes(&self.0.to_le_bytes()[0..=2])\n+    }\n+}\n+\n+struct U24Visitor;\n+\n+impl<'de> Visitor<'de> for U24Visitor {\n+    type Value = U24;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"an integer between 0 and 2^24 3 bytes le\")\n+    }\n+\n+    #[inline]\n+    fn visit_u32<E>(self, value: u32) -> Result<Self::Value, E> {\n+        // This is safe as this struct is deserialized using parse_u24 that can never return a\n+        // value bigger than U24::MAX\n+        Ok(U24(value))\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for U24 {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"U24\", U24Visitor)\n+    }\n+}\n+\n+impl FixedSize for U24 {\n+    const FIXED_SIZE: usize = 3;\n+}"
      },
      {
        "sha": "0ca09427fa29ffdbe6224094cb6c2315e9247a5c",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs",
        "status": "added",
        "additions": 95,
        "deletions": 0,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,95 @@\n+use crate::error::Error;\n+use crate::primitives::FixedSize;\n+use alloc::boxed::Box;\n+use core::convert::TryFrom;\n+use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n+\n+#[derive(Debug, PartialEq, Clone)]\n+enum Inner<'a> {\n+    Ref(&'a [u8]),\n+    Owned(Box<[u8; 32]>),\n+}\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub struct U256<'u>(Inner<'u>);\n+\n+impl<'u> TryFrom<&'u [u8]> for U256<'u> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'u [u8]) -> core::result::Result<Self, Error> {\n+        if v.len() == 32 {\n+            Ok(Self(Inner::Ref(v)))\n+        } else {\n+            Err(Error::InvalidU256(v.len()))\n+        }\n+    }\n+}\n+\n+impl<'u> TryFrom<&'u mut [u8]> for U256<'u> {\n+    type Error = Error;\n+\n+    #[inline]\n+    fn try_from(v: &'u mut [u8]) -> core::result::Result<Self, Error> {\n+        if v.len() == 32 {\n+            Ok(Self(Inner::Ref(v)))\n+        } else {\n+            Err(Error::InvalidU256(v.len()))\n+        }\n+    }\n+}\n+\n+impl<'u> From<[u8; 32]> for U256<'u> {\n+    fn from(v: [u8; 32]) -> Self {\n+        U256(Inner::Owned(Box::new(v)))\n+    }\n+}\n+\n+impl<'u> From<&'u U256<'u>> for &'u [u8] {\n+    #[inline]\n+    fn from(v: &'u U256<'u>) -> Self {\n+        match &v.0 {\n+            Inner::Ref(v) => v,\n+            Inner::Owned(v) => &v[..],\n+        }\n+    }\n+}\n+\n+impl<'u> Serialize for U256<'u> {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n+    where\n+        S: ser::Serializer,\n+    {\n+        serializer.serialize_bytes(self.into())\n+    }\n+}\n+\n+struct U256Visitor;\n+\n+impl<'a> Visitor<'a> for U256Visitor {\n+    type Value = U256<'a>;\n+\n+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        formatter.write_str(\"a 32 bytes unsigned le int\")\n+    }\n+\n+    #[inline]\n+    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n+        Ok(U256(Inner::Ref(value)))\n+    }\n+}\n+\n+impl<'de: 'a, 'a> Deserialize<'de> for U256<'a> {\n+    #[inline]\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        deserializer.deserialize_newtype_struct(\"U256\", U256Visitor)\n+    }\n+}\n+\n+impl<'a> FixedSize for U256<'a> {\n+    const FIXED_SIZE: usize = 32;\n+}"
      },
      {
        "sha": "b79ed5719f65d4b857ded973bb1bad2be1bea6db",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/ser.rs",
        "status": "added",
        "additions": 380,
        "deletions": 0,
        "changes": 380,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/ser.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/binary-sv2/serde-sv2/src/ser.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/ser.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,380 @@\n+//! Serde serializer for [stratum v2][Sv2] implemented following [serde tutorial][tutorial]\n+//!\n+//! Right now trying to serialize a value that is an invalid Sv2 type will result in a panic so\n+//! error are catched as soon as possible.\n+//!\n+//! [Sv2]: https://docs.google.com/document/d/1FadCWj-57dvhxsnFM_7X806qyvhR0u3i85607bGHxvg/edit\n+//! [tutorial]: https://serde.rs/data-format.html\n+//!\n+use crate::error::{Error, Result};\n+use alloc::vec::Vec;\n+use buffer_sv2::Write;\n+use serde::{ser, Serialize};\n+\n+pub struct Serializer<W: Write> {\n+    output: W,\n+}\n+\n+pub fn to_bytes<T>(value: &T) -> Result<Vec<u8>>\n+where\n+    T: Serialize,\n+{\n+    let output: Vec<u8> = vec![];\n+    let mut serializer = Serializer { output };\n+    value.serialize(&mut serializer)?;\n+    Ok(serializer.output)\n+}\n+\n+pub fn to_writer<T, W: Write>(value: &T, writer: W) -> Result<()>\n+where\n+    T: Serialize,\n+{\n+    let mut serializer = Serializer { output: writer };\n+    value.serialize(&mut serializer)?;\n+    Ok(())\n+}\n+\n+impl<'a, W: Write> ser::Serializer for &'a mut Serializer<W> {\n+    type Ok = ();\n+\n+    type Error = Error;\n+\n+    // Associated types for keeping track of additional state while serializing\n+    // compound data structures like sequences and maps. In this case no\n+    // additional state is required beyond what is already stored in the\n+    // Serializer struct.\n+    type SerializeSeq = Self;\n+    type SerializeTuple = Self;\n+    type SerializeTupleStruct = Self;\n+    type SerializeTupleVariant = Self;\n+    type SerializeMap = Self;\n+    type SerializeStruct = Self;\n+    type SerializeStructVariant = Self;\n+\n+    // TODO check endianess\n+    #[inline]\n+    fn serialize_bool(self, v: bool) -> Result<()> {\n+        match v {\n+            true => self.output.write_all(&[1]).map_err(|_| Error::WriteError)?,\n+            false => self.output.write_all(&[0]).map_err(|_| Error::WriteError)?,\n+        };\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn serialize_u8(self, v: u8) -> Result<()> {\n+        self.output.write_all(&[v]).map_err(|_| Error::WriteError)\n+    }\n+\n+    #[inline]\n+    fn serialize_u16(self, v: u16) -> Result<()> {\n+        self.output\n+            .write_all(&v.to_le_bytes())\n+            .map_err(|_| Error::WriteError)\n+    }\n+\n+    #[inline]\n+    fn serialize_u32(self, v: u32) -> Result<()> {\n+        self.output\n+            .write_all(&v.to_le_bytes())\n+            .map_err(|_| Error::WriteError)\n+    }\n+\n+    // Serialize string to STR0_255\n+    #[inline]\n+    fn serialize_str(self, v: &str) -> Result<()> {\n+        match v.len() {\n+            l @ 0..=255 => {\n+                self.output\n+                    .write_all(&[l as u8])\n+                    .map_err(|_| Error::WriteError)?;\n+            }\n+            _ => return Err(Error::StringLenBiggerThan256),\n+        };\n+        self.output\n+            .write_all(v.as_bytes())\n+            .map_err(|_| Error::WriteError)\n+    }\n+\n+    #[inline]\n+    fn serialize_bytes(self, v: &[u8]) -> Result<()> {\n+        self.output.write_all(v).map_err(|_| Error::WriteError)\n+    }\n+\n+    #[inline]\n+    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(self)\n+    }\n+\n+    // serialize_struct should preserve field order TODO verify it\n+    // https://users.rust-lang.org/t/order-of-fields-in-serde-json-to-string/48928/3?u=fi3\n+    #[inline]\n+    fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {\n+        Ok(self)\n+    }\n+\n+    #[inline]\n+    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {\n+        Ok(self)\n+    }\n+\n+    #[inline]\n+    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {\n+        Ok(self)\n+    }\n+\n+    #[inline]\n+    fn serialize_newtype_variant<T>(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        _variant: &'static str,\n+        value: &T,\n+    ) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(self)\n+    }\n+\n+    ///// UNIMPLEMENTED /////\n+\n+    fn serialize_i8(self, _v: i8) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_i16(self, _v: i16) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_i32(self, _v: i32) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_i64(self, _v: i64) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_u64(self, _v: u64) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_f32(self, v: f32) -> Result<()> {\n+        self.output\n+            .write_all(&v.to_le_bytes())\n+            .map_err(|_| Error::WriteError)\n+    }\n+\n+    fn serialize_f64(self, _v: f64) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_char(self, _v: char) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_none(self) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_some<T>(self, _value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_unit(self) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_unit_variant(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        _variant: &'static str,\n+    ) -> Result<()> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_tuple_struct(\n+        self,\n+        _name: &'static str,\n+        _len: usize,\n+    ) -> Result<Self::SerializeTupleStruct> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_tuple_variant(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        _variant: &'static str,\n+        _len: usize,\n+    ) -> Result<Self::SerializeTupleVariant> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_struct_variant(\n+        self,\n+        _name: &'static str,\n+        _variant_index: u32,\n+        _variant: &'static str,\n+        _len: usize,\n+    ) -> Result<Self::SerializeStructVariant> {\n+        todo!()\n+    }\n+}\n+\n+impl<'a, W: Write> ser::SerializeStruct for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    #[inline]\n+    fn serialize_field<T>(&mut self, _key: &'static str, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut **self)\n+    }\n+\n+    #[inline]\n+    fn end(self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, W: Write> ser::SerializeSeq for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    #[inline]\n+    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut **self)\n+    }\n+\n+    #[inline]\n+    fn end(self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, W: Write> ser::SerializeTuple for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    #[inline]\n+    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        value.serialize(&mut **self)\n+    }\n+\n+    #[inline]\n+    fn end(self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+///// UNIMPLEMENTED /////\n+\n+impl<'a, W: Write> ser::SerializeTupleStruct for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, _value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn end(self) -> Result<()> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a, W: Write> ser::SerializeTupleVariant for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, _value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn end(self) -> Result<()> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a, W: Write> ser::SerializeMap for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_key<T>(&mut self, _key: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn serialize_value<T>(&mut self, _value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn end(self) -> Result<()> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a, W: Write> ser::SerializeStructVariant for &'a mut Serializer<W> {\n+    type Ok = ();\n+    type Error = Error;\n+\n+    fn serialize_field<T>(&mut self, _key: &'static str, _value: &T) -> Result<()>\n+    where\n+        T: ?Sized + Serialize,\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn end(self) -> Result<()> {\n+        unimplemented!()\n+    }\n+}\n+\n+///// TEST /////\n+\n+#[test]\n+fn test_struct() {\n+    #[derive(Serialize)]\n+    struct Test {\n+        a: u32,\n+        b: u8,\n+    }\n+\n+    let test = Test { a: 456, b: 9 };\n+    let expected = vec![200, 1, 0, 0, 9];\n+    assert_eq!(to_bytes(&test).unwrap(), expected);\n+}"
      },
      {
        "sha": "73d64237b388146d5ca0bef4e292d6afff8e8cff",
        "filename": "src/rusty/build-for-guix.sh",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/build-for-guix.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/build-for-guix.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/build-for-guix.sh?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,36 @@\n+#! /bin/sh\n+\n+SCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\"\n+\n+rm -rf ${SCRIPT_DIR}/target\n+mkdir ${SCRIPT_DIR}/target\n+mkdir ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/sv2-ffi/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/sv2-ffi/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/binary-sv2/binary-sv2/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/binary-sv2/binary-sv2/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/codec/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/codec/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml --allow-dirty \n+mv ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/derive_codec/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/framing-sv2/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/framing-sv2/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/const-sv2/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/const-sv2/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/codec-sv2/Cargo.toml --allow-dirty --no-verify\n+mv ${SCRIPT_DIR}/codec-sv2/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/subprotocols/common-messages/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/subprotocols/common-messages/target/package/* ${SCRIPT_DIR}/target/package\n+\n+cargo package --manifest-path ${SCRIPT_DIR}/subprotocols/template-distribution/Cargo.toml --allow-dirty\n+mv ${SCRIPT_DIR}/subprotocols/template-distribution/target/package/* ${SCRIPT_DIR}/target/package\n+\n+"
      },
      {
        "sha": "6f86a7ab2b08281e8f60b4dfc1f62ba9a7a08646",
        "filename": "src/rusty/codec-sv2/Cargo.toml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"codec_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 data format\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional = true }\n+framing_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/framing-sv2\" }\n+noise_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/noise-sv2\", optional=true}\n+binary_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/binary-sv2/binary-sv2\"}\n+const_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/const-sv2\"}\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\", \"framing_sv2/with_serde\"]"
      },
      {
        "sha": "3df316f9cfc1b18bebb9d18b439f49c892b7f57f",
        "filename": "src/rusty/codec-sv2/src/buffer.rs",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/buffer.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/buffer.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/buffer.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,71 @@\n+use alloc::vec::Vec;\n+\n+pub trait Buffer {\n+    type Slice: AsMut<[u8]>;\n+\n+    fn get_writable(&mut self, len: usize) -> &mut [u8];\n+\n+    fn get_data_owned(&mut self) -> Self::Slice;\n+\n+    fn get_data_by_ref(&mut self, header_size: usize) -> &mut [u8];\n+\n+    fn len(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+pub struct SlowAndCorrect {\n+    inner: Vec<u8>,\n+    cursor: usize,\n+}\n+\n+impl SlowAndCorrect {\n+    pub fn new() -> Self {\n+        Self {\n+            inner: Vec::new(),\n+            cursor: 0,\n+        }\n+    }\n+}\n+\n+impl Default for SlowAndCorrect {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl Buffer for SlowAndCorrect {\n+    type Slice = Vec<u8>;\n+\n+    #[inline]\n+    fn get_writable(&mut self, len: usize) -> &mut [u8] {\n+        let cursor = self.cursor;\n+        let len = self.cursor + len;\n+\n+        if len > self.inner.len() {\n+            self.inner.resize(len, 0)\n+        };\n+\n+        self.cursor = len;\n+\n+        &mut self.inner[cursor..len]\n+    }\n+\n+    #[inline]\n+    fn get_data_owned(&mut self) -> Vec<u8> {\n+        let mut tail = self.inner.split_off(self.cursor);\n+        core::mem::swap(&mut tail, &mut self.inner);\n+        let head = tail;\n+        self.cursor = 0;\n+        head\n+    }\n+\n+    #[inline]\n+    fn get_data_by_ref(&mut self, header_size: usize) -> &mut [u8] {\n+        &mut self.inner[..usize::min(header_size, self.cursor)]\n+    }\n+\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.cursor\n+    }\n+}"
      },
      {
        "sha": "93c292299e91a4cd0761432781c27f234a0d9abb",
        "filename": "src/rusty/codec-sv2/src/decoder.rs",
        "status": "added",
        "additions": 206,
        "deletions": 0,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/decoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/decoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/decoder.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,206 @@\n+#[cfg(feature = \"noise_sv2\")]\n+use binary_sv2::Deserialize;\n+#[cfg(feature = \"noise_sv2\")]\n+use binary_sv2::GetSize;\n+use binary_sv2::Serialize;\n+use core::marker::PhantomData;\n+use framing_sv2::framing2::{EitherFrame, Frame as F_, Sv2Frame};\n+#[cfg(feature = \"noise_sv2\")]\n+use framing_sv2::framing2::{HandShakeFrame, NoiseFrame};\n+use framing_sv2::header::Header;\n+#[cfg(feature = \"noise_sv2\")]\n+use framing_sv2::header::NoiseHeader;\n+\n+use crate::buffer::{Buffer, SlowAndCorrect};\n+use crate::error::{Error, Result};\n+#[cfg(feature = \"noise_sv2\")]\n+use crate::{State, TransportMode};\n+\n+#[cfg(feature = \"noise_sv2\")]\n+pub type StandardNoiseDecoder<T> = WithNoise<SlowAndCorrect, T>;\n+pub type StandardEitherFrame<T> = EitherFrame<T, <SlowAndCorrect as Buffer>::Slice>;\n+pub type StandardSv2Frame<T> = Sv2Frame<T, <SlowAndCorrect as Buffer>::Slice>;\n+pub type StandardDecoder<T> = WithoutNoise<SlowAndCorrect, T>;\n+\n+#[cfg(feature = \"noise_sv2\")]\n+pub struct WithNoise<B: Buffer, T: Serialize + binary_sv2::GetSize> {\n+    frame: PhantomData<T>,\n+    missing_noise_b: usize,\n+    noise_buffer: B,\n+    sv2_buffer: B,\n+    sv2_frame_size: usize,\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl<'a, T: Serialize + GetSize + Deserialize<'a>, B: Buffer> WithNoise<B, T> {\n+    #[inline]\n+    pub fn next_frame(&mut self, state: &mut State) -> Result<EitherFrame<T, B::Slice>> {\n+        let len = self.noise_buffer.len();\n+        let src = self.noise_buffer.get_data_by_ref(len);\n+        let hint = NoiseFrame::size_hint(src) as usize;\n+\n+        match hint {\n+            0 => {\n+                self.missing_noise_b = NoiseHeader::SIZE;\n+                self.decode_noise_frame(state)\n+            }\n+            _ => {\n+                self.missing_noise_b = hint;\n+                Err(Error::MissingBytes(hint))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn decode_noise_frame(&mut self, state: &mut State) -> Result<EitherFrame<T, B::Slice>> {\n+        match state {\n+            State::Transport(transport_mode) => {\n+                // STRIP THE HEADER FROM THE FRAME AND GET THE ENCRYPTED PAYLOAD\n+                // everything here can not fail as the size has been already checked\n+                let src = self.noise_buffer.get_data_owned().as_mut().to_vec();\n+                let mut noise_frame = NoiseFrame::from_bytes_unchecked(src);\n+                let src = noise_frame.payload();\n+\n+                // DECRYPT THE ENCRYPTED PAYLOAD\n+                let len = TransportMode::size_hint_decrypt(src.len());\n+                let mut decrypted = self.sv2_buffer.get_writable(len);\n+                transport_mode.read(src, &mut decrypted).map_err(|_| ())?;\n+\n+                // IF THE DECODER IS RECEIVING A FRAGMENTED FRAME ADD THE DECRYPTED DATA TO THE\n+                // PARTIAL FRAME AND CHECK IF READY\n+                if self.sv2_frame_size > 0 {\n+                    return Ok(self.handle_fragmented().ok_or(())?);\n+                };\n+\n+                let len = self.sv2_buffer.len();\n+                let src = self.sv2_buffer.get_data_by_ref(len);\n+                let hint = Sv2Frame::<T, B::Slice>::size_hint(src);\n+\n+                // IF HINT IS 0 A COMPLETE SV2 FRAME IS AVAIABLE THIS IS THE HOT PATH AS USUALLY\n+                // THE SIZE OF AN SV2 MESSAGE IS SMALLER THE THE MAX SIZE OF A NOISE FRAME\n+                if hint == 0 {\n+                    let src = self.sv2_buffer.get_data_owned();\n+                    let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n+                    return Ok(frame.into());\n+                }\n+\n+                // IF HINT IS NOT 0 AND MISSING BYTES IS 0 IT MEAN THAT THE FIRST FRAGMENT OF AN\n+                // SV2 HAS BEEN RECEIVED\n+                self.handle_fragmented().ok_or(())?;\n+                Err(Error::MissingBytes(self.missing_noise_b))\n+            }\n+            State::HandShake(_) => Ok(self.while_handshaking()),\n+            State::NotInitialized => Ok(self.while_handshaking()),\n+        }\n+    }\n+\n+    #[inline(never)]\n+    fn handle_fragmented(&mut self) -> Option<EitherFrame<T, B::Slice>> {\n+        // IF IS NOT THE FIRST FRAGMENT CHECK IF A COMPLETE FRAME IS AVAIBLE IF YES RETURN THE\n+        // FRAME IF NOT SET MISSING NOISE BYTES TO NOISE HEADER SIZE SO THE DECODER CAN START TO\n+        // DECODE THE NEXT NOISE FRAME\n+        let len = self.sv2_buffer.len();\n+        let src = self.sv2_buffer.get_data_by_ref(len);\n+        let hint = Sv2Frame::<T, B::Slice>::size_hint(src);\n+        if self.sv2_frame_size != 0 {\n+            if hint == 0 {\n+                let src = self.sv2_buffer.get_data_owned();\n+                let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n+                Some(frame.into())\n+            } else {\n+                self.missing_noise_b = NoiseHeader::SIZE;\n+                None\n+            }\n+\n+        // IF IS THE FIRST FRAGMETN JUST SET THE MISSING SV2 AND NOISE BYTES\n+        } else {\n+            self.sv2_frame_size = hint as usize;\n+            self.missing_noise_b = NoiseHeader::SIZE;\n+\n+            None\n+        }\n+    }\n+\n+    fn while_handshaking(&mut self) -> EitherFrame<T, B::Slice> {\n+        let src = self.noise_buffer.get_data_owned().as_mut().to_vec();\n+\n+        // below is inffalible as noise frame lenght has been already checked\n+        let frame = HandShakeFrame::from_bytes_unchecked(src);\n+\n+        frame.into()\n+    }\n+\n+    #[inline]\n+    pub fn writable(&mut self) -> &mut [u8] {\n+        self.noise_buffer.get_writable(self.missing_noise_b)\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl<T: Serialize + binary_sv2::GetSize> WithNoise<SlowAndCorrect, T> {\n+    pub fn new() -> Self {\n+        Self {\n+            frame: PhantomData,\n+            missing_noise_b: 0,\n+            noise_buffer: SlowAndCorrect::new(),\n+            sv2_buffer: SlowAndCorrect::new(),\n+            sv2_frame_size: 0,\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl<T: Serialize + binary_sv2::GetSize> Default for WithNoise<SlowAndCorrect, T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct WithoutNoise<B: Buffer, T: Serialize + binary_sv2::GetSize> {\n+    frame: PhantomData<T>,\n+    missing_b: usize,\n+    buffer: B,\n+}\n+\n+impl<T: Serialize + binary_sv2::GetSize, B: Buffer> WithoutNoise<B, T> {\n+    #[inline]\n+    pub fn next_frame(&mut self) -> Result<Sv2Frame<T, B::Slice>> {\n+        let len = self.buffer.len();\n+        let src = self.buffer.get_data_by_ref(len);\n+        let hint = Sv2Frame::<T, B::Slice>::size_hint(src) as usize;\n+\n+        match hint {\n+            0 => {\n+                self.missing_b = Header::SIZE;\n+                let src = self.buffer.get_data_owned();\n+                let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n+                Ok(frame)\n+            }\n+            _ => {\n+                self.missing_b = hint;\n+                Err(Error::MissingBytes(self.missing_b))\n+            }\n+        }\n+    }\n+\n+    pub fn writable(&mut self) -> &mut [u8] {\n+        self.buffer.get_writable(self.missing_b)\n+    }\n+}\n+\n+impl<T: Serialize + binary_sv2::GetSize> WithoutNoise<SlowAndCorrect, T> {\n+    pub fn new() -> Self {\n+        Self {\n+            frame: PhantomData,\n+            missing_b: Header::SIZE,\n+            buffer: SlowAndCorrect::new(),\n+        }\n+    }\n+}\n+\n+impl<T: Serialize + binary_sv2::GetSize> Default for WithoutNoise<SlowAndCorrect, T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}"
      },
      {
        "sha": "d87cf3d2dbcdbc1eea2aff4c20b5954a2311ba91",
        "filename": "src/rusty/codec-sv2/src/encoder.rs",
        "status": "added",
        "additions": 198,
        "deletions": 0,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/encoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/encoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/encoder.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,198 @@\n+use alloc::vec::Vec;\n+use binary_sv2::GetSize;\n+use binary_sv2::Serialize;\n+#[cfg(feature = \"noise_sv2\")]\n+use core::cmp::min;\n+#[cfg(feature = \"noise_sv2\")]\n+use core::convert::TryInto;\n+use core::marker::PhantomData;\n+#[cfg(feature = \"noise_sv2\")]\n+use framing_sv2::framing2::{build_noise_frame_header, EitherFrame, HandShakeFrame};\n+use framing_sv2::framing2::{Frame as F_, Sv2Frame};\n+#[cfg(feature = \"noise_sv2\")]\n+use framing_sv2::header::NoiseHeader;\n+\n+#[cfg(feature = \"noise_sv2\")]\n+use crate::{State, TransportMode};\n+\n+#[cfg(feature = \"noise_sv2\")]\n+const TAGLEN: usize = const_sv2::SNOW_TAGLEN;\n+#[cfg(feature = \"noise_sv2\")]\n+const MAX_M_L: usize = const_sv2::NOISE_FRAME_MAX_SIZE;\n+#[cfg(feature = \"noise_sv2\")]\n+const M: usize = MAX_M_L - TAGLEN;\n+\n+#[cfg(feature = \"noise_sv2\")]\n+pub struct NoiseEncoder<T: Serialize + binary_sv2::GetSize> {\n+    noise_buffer: Vec<u8>,\n+    sv2_buffer: Vec<u8>,\n+    frame: PhantomData<T>,\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl<T: Serialize + GetSize> NoiseEncoder<T> {\n+    #[inline]\n+    pub fn encode(\n+        &mut self,\n+        item: EitherFrame<T, Vec<u8>>,\n+        state: &mut State,\n+    ) -> Result<&[u8], crate::Error> {\n+        match state {\n+            State::Transport(transport_mode) => {\n+                let len = item.encoded_length();\n+                self.sv2_buffer.resize(len, 0);\n+\n+                // ENCODE THE SV2 FRAME\n+                let i: Sv2Frame<T, Vec<u8>> = item.try_into().map_err(|_| ())?;\n+                i.serialize(&mut self.sv2_buffer).map_err(|_| ())?;\n+\n+                // IF THE MESSAGE FIT INTO A NOISE FRAME ENCODE IT HOT PATH\n+                if len <= M {\n+                    self.encode_single_frame(transport_mode)?;\n+\n+                // IF LEN IS BIGGER THAN NOISE PAYLOAD MAX SIZE MESSAGE IS ENCODED AS SEVERAL NOISE\n+                // MESSAGES COLD PATH\n+                } else {\n+                    self.encode_multiple_frame(transport_mode)?;\n+                }\n+            }\n+            State::HandShake(_) => self.while_handshaking(item)?,\n+            State::NotInitialized => self.while_handshaking(item)?,\n+        };\n+\n+        Ok(&self.noise_buffer[..])\n+    }\n+\n+    #[inline(always)]\n+    fn encode_single_frame(&mut self, transport_mode: &mut TransportMode) -> Result<(), ()> {\n+        // RESERVE ENAUGH SPACE TO ENCODE THE NOISE MESSAGE\n+        let len = TransportMode::size_hint_encrypt(self.sv2_buffer[..].len());\n+        let len_with_header = len + NoiseHeader::SIZE;\n+\n+        let to_reserve = if self.noise_buffer.len() > len_with_header {\n+            0\n+        } else {\n+            len_with_header - self.noise_buffer.len()\n+        };\n+        self.noise_buffer.reserve(to_reserve);\n+        self.noise_buffer.clear();\n+\n+        // PREPEND THE NOISE FRAME HEADER\n+        build_noise_frame_header(&mut self.noise_buffer, len as u16);\n+\n+        // RESIZE THE BUFFER SO TRANSPORT MODE CAN WRITE IN IT\n+        self.noise_buffer.resize(len_with_header, 0);\n+\n+        // ENCRYPT THE SV2 FRAME AND ENCODE THE NOISE FRAME\n+        transport_mode\n+            .write(\n+                &self.sv2_buffer[..],\n+                &mut self.noise_buffer[NoiseHeader::SIZE..],\n+            )\n+            .map_err(|_| ())\n+    }\n+\n+    #[inline(never)]\n+    fn encode_multiple_frame(&mut self, transport_mode: &mut TransportMode) -> Result<(), ()> {\n+        self.noise_buffer.clear();\n+\n+        let buffer_len: usize = self.sv2_buffer.len();\n+        let mut start: usize = 0;\n+        let mut end: usize = M;\n+\n+        loop {\n+            let last_len = self.noise_buffer.len();\n+\n+            end = min(end, buffer_len);\n+\n+            let buf = &self.sv2_buffer[start..end];\n+\n+            // PREPEND THE NOISE FRAME HEADER\n+            let len = TransportMode::size_hint_encrypt(buf.len());\n+            build_noise_frame_header(&mut self.noise_buffer, len as u16);\n+\n+            // RESIZE THE BUFFER SO TRANSPORT MODE CAN WRITE IN IT\n+            self.noise_buffer.resize(self.noise_buffer.len() + len, 0);\n+\n+            // ENCRYPT THE SV2 FRAGMENT\n+            transport_mode\n+                .write(\n+                    buf,\n+                    &mut self.noise_buffer\n+                        [last_len + NoiseHeader::SIZE..last_len + NoiseHeader::SIZE + len],\n+                )\n+                .map_err(|_| ())?;\n+\n+            if end == buffer_len {\n+                break;\n+            }\n+\n+            start += end;\n+            end += end;\n+        }\n+        Ok(())\n+    }\n+\n+    #[inline(never)]\n+    fn while_handshaking(&mut self, item: EitherFrame<T, Vec<u8>>) -> Result<(), ()> {\n+        // ENCODE THE SV2 FRAME\n+        let i: HandShakeFrame = item.try_into().map_err(|_| ())?;\n+        i.serialize(&mut self.sv2_buffer).map_err(|_| ())?;\n+\n+        self.noise_buffer.clear();\n+        self.noise_buffer.extend_from_slice(&self.sv2_buffer[..]);\n+\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl<T: Serialize + binary_sv2::GetSize> NoiseEncoder<T> {\n+    pub fn new() -> Self {\n+        Self {\n+            // TODO which capacity??\n+            sv2_buffer: Vec::with_capacity(512),\n+            noise_buffer: Vec::with_capacity(512),\n+            frame: core::marker::PhantomData,\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl<T: Serialize + GetSize> Default for NoiseEncoder<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Encoder<T> {\n+    buffer: Vec<u8>,\n+    frame: PhantomData<T>,\n+}\n+\n+impl<T: Serialize + GetSize> Encoder<T> {\n+    pub fn encode(&mut self, item: Sv2Frame<T, Vec<u8>>) -> Result<&[u8], crate::Error> {\n+        let len = item.encoded_length();\n+\n+        self.buffer.resize(len, 0);\n+\n+        item.serialize(&mut self.buffer).map_err(|_| ())?;\n+\n+        Ok(&self.buffer[..])\n+    }\n+\n+    pub fn new() -> Self {\n+        Self {\n+            // TODO which capacity??\n+            buffer: Vec::with_capacity(512),\n+            frame: core::marker::PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T: Serialize + GetSize> Default for Encoder<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}"
      },
      {
        "sha": "9a7a24c04b67b2a22b02c1f077768a34e0a73d88",
        "filename": "src/rusty/codec-sv2/src/error.rs",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/error.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,26 @@\n+#[derive(Debug)]\n+pub enum Error {\n+    MissingBytes(usize),\n+    Todo,\n+}\n+\n+pub type Result<T> = core::result::Result<T, Error>;\n+\n+//#[cfg(not(feature = \"no_std\"))]\n+//impl From<std::io::Error> for Error {\n+//    fn from(_: core::io::Error) -> Self {\n+//        todo!()\n+//    }\n+//}\n+\n+impl From<()> for Error {\n+    fn from(_: ()) -> Self {\n+        Error::Todo\n+    }\n+}\n+\n+impl core::fmt::Display for Error {\n+    fn fmt(&self, _: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n+        Ok(())\n+    }\n+}"
      },
      {
        "sha": "e2b6cb7a64e6da551cadda940ff2f19bd6418f8b",
        "filename": "src/rusty/codec-sv2/src/lib.rs",
        "status": "added",
        "additions": 156,
        "deletions": 0,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/codec-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,156 @@\n+#![no_std]\n+\n+extern crate alloc;\n+\n+#[cfg(feature = \"noise_sv2\")]\n+use alloc::{boxed::Box, vec::Vec};\n+\n+mod buffer;\n+mod decoder;\n+mod encoder;\n+mod error;\n+\n+pub use error::Error;\n+\n+pub use decoder::StandardEitherFrame;\n+pub use decoder::StandardSv2Frame;\n+\n+pub use decoder::StandardDecoder;\n+#[cfg(feature = \"noise_sv2\")]\n+pub use decoder::StandardNoiseDecoder;\n+\n+pub use encoder::Encoder;\n+#[cfg(feature = \"noise_sv2\")]\n+pub use encoder::NoiseEncoder;\n+\n+pub use framing_sv2::framing2::{Frame, Sv2Frame};\n+#[cfg(feature = \"noise_sv2\")]\n+pub use framing_sv2::framing2::{HandShakeFrame, NoiseFrame};\n+\n+#[cfg(feature = \"noise_sv2\")]\n+pub use noise_sv2::{self, handshake::Step, Initiator, Responder, TransportMode};\n+\n+#[cfg(feature = \"noise_sv2\")]\n+#[derive(Debug)]\n+pub enum State {\n+    /// Not yet initialized\n+    NotInitialized,\n+    /// Handshake mode where codec is negotiating keys\n+    HandShake(Box<HandshakeRole>),\n+    /// Transport mode where AEAD is fully operational. The `TransportMode` object in this variant\n+    /// as able to perform encryption and decryption resp.\n+    Transport(TransportMode),\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+#[derive(Debug)]\n+pub enum HandshakeRole {\n+    Initiator(noise_sv2::Initiator),\n+    Responder(noise_sv2::Responder),\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl HandshakeRole {\n+    pub fn step(&mut self, in_msg: Option<Vec<u8>>) -> Result<HandShakeFrame, crate::Error> {\n+        match self {\n+            Self::Initiator(stepper) => {\n+                let message = stepper.step(in_msg).map_err(|_| ())?.inner();\n+                Ok(HandShakeFrame::from_message(message, 0, 0).ok_or(())?)\n+            }\n+\n+            Self::Responder(stepper) => {\n+                let message = stepper.step(in_msg).map_err(|_| ())?.inner();\n+                Ok(HandShakeFrame::from_message(message, 0, 0).ok_or(())?)\n+            }\n+        }\n+    }\n+\n+    pub fn into_transport(self) -> Result<TransportMode, crate::Error> {\n+        match self {\n+            Self::Initiator(stepper) => {\n+                let tp = stepper\n+                    .into_handshake_state()\n+                    .into_transport_mode()\n+                    .map_err(|_| ())?;\n+                Ok(TransportMode::new(tp))\n+            }\n+\n+            Self::Responder(stepper) => {\n+                let tp = stepper\n+                    .into_handshake_state()\n+                    .into_transport_mode()\n+                    .map_err(|_| ())?;\n+                Ok(TransportMode::new(tp))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl State {\n+    #[inline(always)]\n+    pub fn is_in_transport_mode(&self) -> bool {\n+        match self {\n+            Self::NotInitialized => false,\n+            Self::HandShake(_) => false,\n+            Self::Transport(_) => true,\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn is_not_initialized(&self) -> bool {\n+        match self {\n+            Self::NotInitialized => true,\n+            Self::HandShake(_) => false,\n+            Self::Transport(_) => false,\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl State {\n+    pub fn take(&mut self) -> Self {\n+        let mut new_me = Self::NotInitialized;\n+        core::mem::swap(&mut new_me, self);\n+        new_me\n+    }\n+\n+    pub fn new() -> Self {\n+        Self::NotInitialized\n+    }\n+\n+    pub fn initialize(inner: HandshakeRole) -> Self {\n+        Self::HandShake(Box::new(inner))\n+    }\n+\n+    pub fn with_transport_mode(tm: TransportMode) -> Self {\n+        Self::Transport(tm)\n+    }\n+\n+    pub fn step(&mut self, in_msg: Option<Vec<u8>>) -> Result<HandShakeFrame, crate::Error> {\n+        match self {\n+            Self::NotInitialized => Err(Error::Todo),\n+            Self::HandShake(stepper) => stepper.step(in_msg),\n+            Self::Transport(_) => Err(Error::Todo),\n+        }\n+    }\n+\n+    pub fn into_transport_mode(self) -> Result<Self, Error> {\n+        match self {\n+            Self::NotInitialized => Err(Error::Todo),\n+            Self::HandShake(stepper) => {\n+                let tp = stepper.into_transport()?;\n+\n+                Ok(Self::with_transport_mode(tp))\n+            }\n+            Self::Transport(_) => Ok(self),\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"noise_sv2\")]\n+impl Default for State {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}"
      },
      {
        "sha": "7432c3d50c4ae1fdf1ad1714f9d12c3e1322acec",
        "filename": "src/rusty/const-sv2/Cargo.toml",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/const-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/const-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/const-sv2/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"const_sv2\"\n+version = \"0.1.0\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2  constatnts\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n+#[dev-dependencies]\n+#cbindgen = \"0.16.0\""
      },
      {
        "sha": "943f5db0f54be4aff51c1266ce1af9badfeb60f6",
        "filename": "src/rusty/const-sv2/src/lib.rs",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/const-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/const-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/const-sv2/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,34 @@\n+//! Central repository for all the sv2 constants\n+#![no_std]\n+\n+pub const SV2_FRAME_HEADER_SIZE: usize = 6;\n+pub const SV2_FRAME_HEADER_LEN_OFFSET: usize = 3;\n+pub const SV2_FRAME_HEADER_LEN_END: usize = 3;\n+\n+pub const NOISE_FRAME_HEADER_SIZE: usize = 2;\n+pub const NOISE_FRAME_HEADER_LEN_OFFSET: usize = 0;\n+pub const NOISE_FRAME_HEADER_LEN_END: usize = 2;\n+pub const NOISE_FRAME_MAX_SIZE: usize = u16::MAX as usize;\n+\n+pub const NOISE_PARAMS: &str = \"Noise_NX_25519_ChaChaPoly_BLAKE2s\";\n+pub const SNOW_PSKLEN: usize = 32;\n+pub const SNOW_TAGLEN: usize = 16;\n+\n+pub const SV2_MINING_PROTOCOL_DISCRIMINANT: u8 = 0;\n+pub const SV2_JOB_NEG_PROTOCOL_DISCRIMINANT: u8 = 1;\n+pub const SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT: u8 = 2;\n+pub const SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT: u8 = 3;\n+\n+// COMMON MESSAGES TYPES\n+pub const MESSAGE_TYPE_SETUP_CONNECTION: u8 = 0;\n+pub const MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS: u8 = 1;\n+pub const MESSAGE_TYPE_SETUP_CONNECTION_ERROR: u8 = 2;\n+pub const MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES: u8 = 3;\n+// TEMPLATE DISTRIBUTION PROTOCOL MESSAGES TYPES\n+pub const MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE: u8 = 70;\n+pub const MESSAGE_TYPE_NEW_TEMPLATE: u8 = 71;\n+pub const MESSAGE_TYPE_SET_NEW_PREV_HASH: u8 = 72;\n+pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA: u8 = 73;\n+pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS: u8 = 74;\n+pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR: u8 = 75;\n+pub const MESSAGE_TYPE_SUBMIT_SOLUTION: u8 = 76;"
      },
      {
        "sha": "f694f05d7a65ec18c9a74dcab1fa16db30743bd5",
        "filename": "src/rusty/framing-sv2/Cargo.toml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"framing_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 frames\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional = true }\n+const_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/const-sv2\"}\n+binary_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/binary-sv2/binary-sv2\" }\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "7331f4ea5fc692e8f4f937a0805008fcda6808dd",
        "filename": "src/rusty/framing-sv2/src/framing2.rs",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/src/framing2.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/src/framing2.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/src/framing2.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,306 @@\n+use crate::header::Header;\n+use crate::header::NoiseHeader;\n+use alloc::vec::Vec;\n+use binary_sv2::Serialize;\n+use binary_sv2::{to_writer, GetSize};\n+use core::convert::TryFrom;\n+\n+const NOISE_MAX_LEN: usize = const_sv2::NOISE_FRAME_MAX_SIZE;\n+\n+pub trait Frame<'a, T: Serialize + GetSize>: Sized {\n+    type Buffer: AsMut<[u8]>;\n+    type Deserialized;\n+\n+    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n+    /// itself\n+    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error>;\n+\n+    ///fn deserialize(&'a mut self) -> Result<Self::Deserialized, serde_sv2::Error>;\n+    fn payload(&'a mut self) -> &'a mut [u8];\n+\n+    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n+    fn get_header(&self) -> Option<crate::header::Header>;\n+\n+    /// Try to build an Frame frame from raw bytes.\n+    /// It return the frame or the number of the bytes needed to complete the frame\n+    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n+    /// is said about the correctness of the payload\n+    fn from_bytes(bytes: Self::Buffer) -> Result<Self, isize>;\n+\n+    fn from_bytes_unchecked(bytes: Self::Buffer) -> Self;\n+\n+    fn size_hint(bytes: &[u8]) -> isize;\n+\n+    fn encoded_length(&self) -> usize;\n+\n+    /// Try to build an Frame frame from a serializable payload.\n+    /// It return a Frame if the size of the payload fit in the frame, if not it return None\n+    fn from_message(message: T, message_type: u8, extension_type: u16) -> Option<Self>;\n+}\n+\n+#[derive(Debug)]\n+pub struct Sv2Frame<T, B> {\n+    header: Header,\n+    payload: Option<T>,\n+    serialized: Option<B>,\n+}\n+\n+impl<T, B> Default for Sv2Frame<T, B> {\n+    fn default() -> Self {\n+        Sv2Frame {\n+            header: Header::default(),\n+            payload: None,\n+            serialized: None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct NoiseFrame {\n+    header: u16,\n+    payload: Vec<u8>,\n+}\n+\n+pub type HandShakeFrame = NoiseFrame;\n+\n+impl<'a, T: Serialize + GetSize, B: AsMut<[u8]>> Frame<'a, T> for Sv2Frame<T, B> {\n+    type Buffer = B;\n+    type Deserialized = B;\n+\n+    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n+    /// itself\n+    #[inline]\n+    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error> {\n+        if self.serialized.is_some() {\n+            *dst = self.serialized.unwrap();\n+            Ok(())\n+        } else {\n+            #[cfg(not(feature = \"with_serde\"))]\n+            to_writer(self.header, dst.as_mut())?;\n+            #[cfg(not(feature = \"with_serde\"))]\n+            to_writer(self.payload.unwrap(), &mut dst.as_mut()[Header::SIZE..])?;\n+            #[cfg(feature = \"with_serde\")]\n+            to_writer(&self.header, dst.as_mut())?;\n+            #[cfg(feature = \"with_serde\")]\n+            to_writer(&self.payload.unwrap(), &mut dst.as_mut()[Header::SIZE..])?;\n+            Ok(())\n+        }\n+    }\n+\n+    fn payload(&'a mut self) -> &'a mut [u8] {\n+        if self.payload.is_some() {\n+            todo!()\n+        } else {\n+            &mut self.serialized.as_mut().unwrap().as_mut()[Header::SIZE..]\n+        }\n+    }\n+\n+    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n+    fn get_header(&self) -> Option<crate::header::Header> {\n+        Some(self.header)\n+    }\n+\n+    /// Try to build a Frame frame from raw bytes.\n+    /// It return the frame or the number of the bytes needed to complete the frame\n+    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n+    /// is said about the correctness of the payload\n+    #[inline]\n+    fn from_bytes(mut bytes: Self::Buffer) -> Result<Self, isize> {\n+        let hint = Self::size_hint(bytes.as_mut());\n+\n+        if hint == 0 {\n+            Ok(Self::from_bytes_unchecked(bytes))\n+        } else {\n+            Err(hint)\n+        }\n+    }\n+\n+    #[inline]\n+    fn from_bytes_unchecked(mut bytes: Self::Buffer) -> Self {\n+        let header = Header::from_bytes(bytes.as_mut()).unwrap();\n+        Self {\n+            header,\n+            payload: None,\n+            serialized: Some(bytes),\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(bytes: &[u8]) -> isize {\n+        match Header::from_bytes(bytes) {\n+            Err(i) => i,\n+            Ok(header) => {\n+                if bytes.len() - Header::SIZE == header.len() {\n+                    0\n+                } else {\n+                    (bytes.len() - Header::SIZE) as isize + header.len() as isize\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn encoded_length(&self) -> usize {\n+        if self.serialized.is_some() {\n+            unimplemented!()\n+        } else {\n+            self.payload.as_ref().unwrap().get_size() + Header::SIZE\n+        }\n+    }\n+\n+    /// Try to build an Frame frame from a serializable payload.\n+    /// It returns a Frame if the size of the payload fits in the frame, if not it returns None\n+    fn from_message(message: T, message_type: u8, extension_type: u16) -> Option<Self> {\n+        let len = message.get_size() as u32;\n+        Header::from_len(len, message_type, extension_type).map(|header| Self {\n+            header,\n+            payload: Some(message),\n+            serialized: None,\n+        })\n+    }\n+}\n+\n+#[inline]\n+pub fn build_noise_frame_header(frame: &mut Vec<u8>, len: u16) {\n+    frame.push(len.to_le_bytes()[0]);\n+    frame.push(len.to_le_bytes()[1]);\n+}\n+\n+impl<'a> Frame<'a, Vec<u8>> for NoiseFrame {\n+    //impl<T: Serialize + GetSize> Frame<T> for NoiseFrame {\n+\n+    type Buffer = Vec<u8>;\n+    type Deserialized = &'a mut [u8];\n+\n+    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n+    /// itself\n+    #[inline]\n+    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error> {\n+        *dst = self.payload;\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn payload(&'a mut self) -> &'a mut [u8] {\n+        &mut self.payload[NoiseHeader::SIZE..]\n+    }\n+\n+    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n+    fn get_header(&self) -> Option<crate::header::Header> {\n+        None\n+    }\n+\n+    /// Try to build a Frame frame from raw bytes.\n+    /// It return the frame or the number of the bytes needed to complete the frame\n+    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n+    /// is said about the correctness of the payload\n+    fn from_bytes(_bytes: Self::Buffer) -> Result<Self, isize> {\n+        unimplemented!()\n+    }\n+\n+    #[inline]\n+    fn from_bytes_unchecked(bytes: Self::Buffer) -> Self {\n+        let len_b = &bytes[NoiseHeader::LEN_OFFSET..NoiseHeader::SIZE];\n+        let expected_len = u16::from_le_bytes([len_b[0], len_b[1]]) as usize;\n+\n+        Self {\n+            header: expected_len as u16,\n+            payload: bytes,\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(bytes: &[u8]) -> isize {\n+        if bytes.len() < NoiseHeader::SIZE {\n+            return (NoiseHeader::SIZE - bytes.len()) as isize;\n+        };\n+\n+        let len_b = &bytes[NoiseHeader::LEN_OFFSET..NoiseHeader::SIZE];\n+        let expected_len = u16::from_le_bytes([len_b[0], len_b[1]]) as usize;\n+\n+        if bytes.len() - NoiseHeader::SIZE == expected_len {\n+            0\n+        } else {\n+            expected_len as isize - (bytes.len() - NoiseHeader::SIZE) as isize\n+        }\n+    }\n+\n+    #[inline]\n+    fn encoded_length(&self) -> usize {\n+        self.payload.len()\n+    }\n+\n+    /// Try to build a `Frame` frame from a serializable payload.\n+    /// It returns a Frame if the size of the payload fits in the frame, if not it returns None\n+    /// Inneficient should be used only to build `HandShakeFrames`\n+    fn from_message(message: Vec<u8>, _message_type: u8, _extension_type: u16) -> Option<Self> {\n+        if message.len() <= NOISE_MAX_LEN {\n+            let header = message.len() as u16;\n+            let payload = [&header.to_le_bytes()[..], &message[..]].concat();\n+            Some(Self { header, payload })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// A frame can be either\n+/// 1: Sv2Frame\n+/// 2: NoiseFrame\n+/// 3: HandashakeFrame\n+///\n+#[derive(Debug)]\n+pub enum EitherFrame<T, B> {\n+    HandShake(HandShakeFrame),\n+    Sv2(Sv2Frame<T, B>),\n+}\n+\n+impl<T: Serialize + GetSize, B: AsMut<[u8]>> EitherFrame<T, B> {\n+    //pub fn serialize(mut self, dst: &mut B) -> Result<(), serde_sv2::Error> {\n+    //    match self {\n+    //        Self::HandShake(frame) => todo!(),\n+    //        Self::Sv2(frame) => frame.serialize(dst),\n+    //    }\n+    //}\n+\n+    pub fn encoded_length(&self) -> usize {\n+        match &self {\n+            Self::HandShake(frame) => frame.encoded_length(),\n+            Self::Sv2(frame) => frame.encoded_length(),\n+        }\n+    }\n+}\n+\n+impl<T, B> TryFrom<EitherFrame<T, B>> for HandShakeFrame {\n+    type Error = ();\n+\n+    fn try_from(v: EitherFrame<T, B>) -> Result<Self, Self::Error> {\n+        match v {\n+            EitherFrame::HandShake(frame) => Ok(frame),\n+            EitherFrame::Sv2(_) => Err(()),\n+        }\n+    }\n+}\n+\n+impl<T, B> TryFrom<EitherFrame<T, B>> for Sv2Frame<T, B> {\n+    type Error = ();\n+\n+    fn try_from(v: EitherFrame<T, B>) -> Result<Self, Self::Error> {\n+        match v {\n+            EitherFrame::Sv2(frame) => Ok(frame),\n+            EitherFrame::HandShake(_) => Err(()),\n+        }\n+    }\n+}\n+\n+impl<T, B> From<HandShakeFrame> for EitherFrame<T, B> {\n+    fn from(v: HandShakeFrame) -> Self {\n+        Self::HandShake(v)\n+    }\n+}\n+\n+impl<T, B> From<Sv2Frame<T, B>> for EitherFrame<T, B> {\n+    fn from(v: Sv2Frame<T, B>) -> Self {\n+        Self::Sv2(v)\n+    }\n+}"
      },
      {
        "sha": "adc56a3f8d734563750dc5a776cb0667a6860725",
        "filename": "src/rusty/framing-sv2/src/header.rs",
        "status": "added",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/src/header.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/src/header.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/src/header.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,82 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2;\n+use binary_sv2::U24;\n+use binary_sv2::{Deserialize, Serialize};\n+use core::convert::TryInto;\n+\n+#[derive(Debug, Serialize, Deserialize, Copy, Clone)]\n+pub struct Header {\n+    extesion_type: u16, // TODO use specific type?\n+    msg_type: u8,       // TODO use specific type?\n+    msg_length: U24,\n+}\n+\n+impl Default for Header {\n+    fn default() -> Self {\n+        Header {\n+            extesion_type: 0,\n+            msg_type: 0,\n+            msg_length: 0_u32.try_into().unwrap(),\n+        }\n+    }\n+}\n+\n+impl Header {\n+    pub const LEN_OFFSET: usize = const_sv2::SV2_FRAME_HEADER_LEN_OFFSET;\n+    pub const LEN_SIZE: usize = const_sv2::SV2_FRAME_HEADER_LEN_END;\n+    pub const LEN_END: usize = Self::LEN_OFFSET + Self::LEN_SIZE;\n+\n+    pub const SIZE: usize = const_sv2::SV2_FRAME_HEADER_SIZE;\n+\n+    #[inline]\n+    pub fn from_bytes(bytes: &[u8]) -> Result<Self, isize> {\n+        if bytes.len() < Self::SIZE {\n+            return Err((Self::SIZE - bytes.len()) as isize);\n+        };\n+\n+        // TODO remove hardcoded\n+        let extesion_type = u16::from_le_bytes([bytes[0], bytes[1]]);\n+        let msg_type = bytes[2];\n+        let msg_length = u32::from_le_bytes([bytes[3], bytes[4], bytes[5], 0]);\n+\n+        Ok(Self {\n+            extesion_type,\n+            msg_type,\n+            // TODO\n+            msg_length: msg_length.try_into().unwrap(),\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        let inner: u32 = self.msg_length.into();\n+        inner as usize\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        unimplemented!()\n+    }\n+\n+    #[inline]\n+    pub fn from_len(len: u32, message_type: u8, extension_type: u16) -> Option<Header> {\n+        Some(Self {\n+            extesion_type: extension_type,\n+            msg_type: message_type,\n+            msg_length: len.try_into().unwrap(),\n+        })\n+    }\n+\n+    pub fn msg_type(&self) -> u8 {\n+        self.msg_type\n+    }\n+}\n+\n+pub struct NoiseHeader {}\n+\n+impl NoiseHeader {\n+    pub const SIZE: usize = const_sv2::NOISE_FRAME_HEADER_SIZE;\n+    pub const LEN_OFFSET: usize = const_sv2::NOISE_FRAME_HEADER_LEN_OFFSET;\n+    pub const LEN_END: usize = const_sv2::NOISE_FRAME_HEADER_LEN_END;\n+}"
      },
      {
        "sha": "84f9f5ee930834f1e2f3ae9c12045a3217ba59c4",
        "filename": "src/rusty/framing-sv2/src/lib.rs",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/framing-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,23 @@\n+#![no_std]\n+extern crate alloc;\n+\n+///\n+/// Sv2 messages are framed as\n+/// ```txt\n+/// extension type: u16\n+/// msg type: u8\n+/// msg length: u24\n+/// payload: [u8; msg length]\n+/// ```\n+///\n+/// Sv2 messages can be encapsulated in noise messages, noise messages are framed as:\n+///\n+/// ```txt\n+/// msg length: u16\n+/// payload: [u8; msg length]\n+/// ```\n+///\n+///\n+pub mod framing2;\n+\n+pub mod header;"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/subprotocols/common-messages/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/.gitignore?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "0fec15c6257530294f6ae956d03c91b0c1a23900",
        "filename": "src/rusty/subprotocols/common-messages/Cargo.toml",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"common_messages_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 subprotocol common messages\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional= true }\n+binary_sv2 = {version = \"0.1.3\", path = \"../../../../protocols/v2/binary-sv2/binary-sv2\" }\n+const_sv2 = {version = \"0.1.0\", path = \"../../../../protocols/v2/const-sv2\"}\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "1a37e13a35bf8780479d66541102314a8dfd8a71",
        "filename": "src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,19 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2;\n+use binary_sv2::{Deserialize, Serialize};\n+\n+/// ## ChannelEndpointChanged (Server -> Client)\n+/// When a channel\u2019s upstream or downstream endpoint changes and that channel had previously\n+/// sent messages with [channel_msg](TODO) bitset of unknown extension_type, the intermediate proxy\n+/// MUST send a [`ChannelEndpointChanged`] message. Upon receipt thereof, any extension state\n+/// (including version negotiation and the presence of support for a given extension) MUST be\n+/// reset and version/presence negotiation must begin again.\n+///\n+#[repr(C)]\n+#[derive(Serialize, Deserialize, Debug, Copy, Clone)]\n+pub struct ChannelEndpointChanged {\n+    /// The channel which has changed endpoint.\n+    pub channel_id: u32,\n+}"
      },
      {
        "sha": "96f7bee1e0d79227ae9dbdb9008f03601b352a7b",
        "filename": "src/rusty/subprotocols/common-messages/src/lib.rs",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,22 @@\n+#![no_std]\n+\n+//! Common messages for [stratum v2][Sv2]\n+//! The following protocol messages are common across all of the sv2 (sub)protocols.\n+extern crate alloc;\n+mod channel_endpoint_changed;\n+mod setup_connection;\n+\n+pub use channel_endpoint_changed::ChannelEndpointChanged;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use setup_connection::{CSetupConnection, CSetupConnectionError};\n+pub use setup_connection::{\n+    Protocol, SetupConnection, SetupConnectionError, SetupConnectionSuccess,\n+};\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_channel_endpoint_changed(_a: ChannelEndpointChanged) {}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_setup_conn_succ(_a: SetupConnectionSuccess) {}"
      },
      {
        "sha": "9a8341a4b2ece8c945f1f1eb005fd20eaac5e289",
        "filename": "src/rusty/subprotocols/common-messages/src/setup_connection.rs",
        "status": "added",
        "additions": 272,
        "deletions": 0,
        "changes": 272,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/src/setup_connection.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/common-messages/src/setup_connection.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/src/setup_connection.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,272 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+use binary_sv2::Str0255;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::{\n+    binary_codec_sv2, binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n+    free_vec, Error, GetSize,\n+};\n+use binary_sv2::{Deserialize, Serialize};\n+use const_sv2::{\n+    SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT, SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n+    SV2_MINING_PROTOCOL_DISCRIMINANT, SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n+};\n+use core::convert::TryFrom;\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## SetupConnection (Client -> Server)\n+/// Initiates the connection. This MUST be the first message sent by the client on the newly\n+/// opened connection. Server MUST respond with either a [`SetupConnectionSuccess`] or\n+/// [`SetupConnectionError`] message. Clients that are not configured to provide telemetry data to\n+/// the upstream node SHOULD set device_id to 0-length strings. However, they MUST always set\n+/// vendor to a string describing the manufacturer/developer and firmware version and SHOULD\n+/// always set hardware_version to a string describing, at least, the particular hardware/software\n+/// package in use.\n+///\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct SetupConnection<'decoder> {\n+    /// [`Protocol`]\n+    pub protocol: Protocol,\n+    /// The minimum protocol version the client supports (currently must be 2).\n+    pub min_version: u16,\n+    /// The maximum protocol version the client supports (currently must be 2).\n+    pub max_version: u16,\n+    /// Flags indicating optional protocol features the client supports. Each\n+    /// protocol from [`SetupConnection.protocol`] field has its own values/flags.\n+    pub flags: u32,\n+    /// ASCII text indicating the hostname or IP address.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub endpoint_host: Str0255<'decoder>,\n+    /// Connecting port value\n+    pub endpoint_port: u16,\n+    //-- DEVICE INFORMATION --//\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub vendor: Str0255<'decoder>,\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub hardware_version: Str0255<'decoder>,\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub firmware: Str0255<'decoder>,\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub device_id: Str0255<'decoder>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+#[derive(Debug, Clone)]\n+pub struct CSetupConnection {\n+    pub protocol: Protocol,\n+    pub min_version: u16,\n+    pub max_version: u16,\n+    pub flags: u32,\n+    pub endpoint_host: CVec,\n+    pub endpoint_port: u16,\n+    pub vendor: CVec,\n+    pub hardware_version: CVec,\n+    pub firmware: CVec,\n+    pub device_id: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSetupConnection {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetupConnection<'a>, Error> {\n+        let endpoint_host: Str0255 = self.endpoint_host.as_mut_slice().try_into()?;\n+        let vendor: Str0255 = self.vendor.as_mut_slice().try_into()?;\n+        let hardware_version: Str0255 = self.hardware_version.as_mut_slice().try_into()?;\n+        let firmware: Str0255 = self.firmware.as_mut_slice().try_into()?;\n+        let device_id: Str0255 = self.device_id.as_mut_slice().try_into()?;\n+\n+        Ok(SetupConnection {\n+            protocol: self.protocol,\n+            min_version: self.min_version,\n+            max_version: self.max_version,\n+            flags: self.flags,\n+            endpoint_host,\n+            endpoint_port: self.endpoint_port,\n+            vendor,\n+            hardware_version,\n+            firmware,\n+            device_id,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_setup_connection(s: CSetupConnection) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSetupConnection {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.endpoint_host);\n+        free_vec(&mut self.vendor);\n+        free_vec(&mut self.hardware_version);\n+        free_vec(&mut self.firmware);\n+        free_vec(&mut self.device_id);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SetupConnection<'a>> for CSetupConnection {\n+    fn from(v: SetupConnection) -> Self {\n+        Self {\n+            protocol: v.protocol,\n+            min_version: v.min_version,\n+            max_version: v.max_version,\n+            flags: v.flags,\n+            endpoint_host: v.endpoint_host.into(),\n+            endpoint_port: v.endpoint_port,\n+            vendor: v.vendor.into(),\n+            hardware_version: v.hardware_version.into(),\n+            firmware: v.firmware.into(),\n+            device_id: v.device_id.into(),\n+        }\n+    }\n+}\n+\n+/// ## SetupConnection.Success (Server -> Client)\n+/// Response to [`SetupConnection`] message if the server accepts the connection. The client is\n+/// required to verify the set of feature flags that the server supports and act accordingly.\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+#[repr(C)]\n+pub struct SetupConnectionSuccess {\n+    /// Selected version proposed by the connecting node that the upstream\n+    /// node supports. This version will be used on the connection for the rest\n+    /// of its life.\n+    pub used_version: u16,\n+    /// Flags indicating optional protocol features the server supports. Each\n+    /// protocol from [`Protocol`] field has its own values/flags.\n+    pub flags: u32,\n+}\n+\n+/// ## SetupConnection.Error (Server -> Client)\n+/// When protocol version negotiation fails (or there is another reason why the upstream node\n+/// cannot setup the connection) the server sends this message with a particular error code prior\n+/// to closing the connection.\n+/// In order to allow a client to determine the set of available features for a given server (e.g. for\n+/// proxies which dynamically switch between different pools and need to be aware of supported\n+/// options), clients SHOULD send a SetupConnection message with all flags set and examine the\n+/// (potentially) resulting [`SetupConnectionError`] message\u2019s flags field. The Server MUST provide\n+/// the full set of flags which it does not support in each [`SetupConnectionError`] message and\n+/// MUST consistently support the same set of flags across all servers on the same hostname and\n+/// port number. If flags is 0, the error is a result of some condition aside from unsupported flags.\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct SetupConnectionError<'decoder> {\n+    /// Flags indicating features causing an error.\n+    pub flags: u32,\n+    /// Human-readable error code(s). See Error Codes section, [link](TODO).\n+    /// ### Possible error codes:\n+    /// * \u2018unsupported-feature-flags\u2019\n+    /// * \u2018unsupported-protocol\u2019\n+    /// * \u2018protocol-version-mismatch\u2019\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub error_code: Str0255<'decoder>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+#[derive(Debug, Clone)]\n+pub struct CSetupConnectionError {\n+    flags: u32,\n+    error_code: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSetupConnectionError {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetupConnectionError<'a>, Error> {\n+        let error_code: Str0255 = self.error_code.as_mut_slice().try_into()?;\n+\n+        Ok(SetupConnectionError {\n+            flags: self.flags,\n+            error_code,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_setup_connection_error(s: CSetupConnectionError) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSetupConnectionError {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.error_code);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SetupConnectionError<'a>> for CSetupConnectionError {\n+    fn from(v: SetupConnectionError<'a>) -> Self {\n+        Self {\n+            flags: v.flags,\n+            error_code: v.error_code.into(),\n+        }\n+    }\n+}\n+\n+/// MiningProtocol = [`SV2_MINING_PROTOCOL_DISCRIMINANT`],\n+/// JobNegotiationProtocol = [`SV2_JOB_NEG_PROTOCOL_DISCRIMINANT`],\n+/// TemplateDistributionProtocol = [`SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT`],\n+/// JobDistributionProtocol = [`SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT`],\n+#[cfg_attr(feature = \"with_serde\", derive(Serialize, Deserialize))]\n+#[derive(Debug, Clone, Copy)]\n+#[repr(u8)]\n+#[allow(clippy::enum_variant_names)]\n+pub enum Protocol {\n+    MiningProtocol = SV2_MINING_PROTOCOL_DISCRIMINANT,\n+    JobNegotiationProtocol = SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n+    TemplateDistributionProtocol = SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n+    JobDistributionProtocol = SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<Protocol> for binary_sv2::encodable::EncodableField<'a> {\n+    fn from(v: Protocol) -> Self {\n+        let val = v as u8;\n+        val.into()\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'decoder> binary_sv2::Decodable<'decoder> for Protocol {\n+    fn get_structure(\n+        _: &[u8],\n+    ) -> core::result::Result<alloc::vec::Vec<FieldMarker>, binary_sv2::Error> {\n+        let field: FieldMarker = 0_u8.into();\n+        Ok(alloc::vec![field])\n+    }\n+    fn from_decoded_fields(\n+        mut v: alloc::vec::Vec<DecodableField<'decoder>>,\n+    ) -> core::result::Result<Self, binary_sv2::Error> {\n+        let val = v.pop().unwrap();\n+        let val: u8 = val.try_into().unwrap();\n+        Ok(val.try_into().unwrap())\n+    }\n+}\n+\n+impl TryFrom<u8> for Protocol {\n+    type Error = ();\n+\n+    fn try_from(value: u8) -> Result<Self, Self::Error> {\n+        match value {\n+            SV2_MINING_PROTOCOL_DISCRIMINANT => Ok(Protocol::MiningProtocol),\n+            SV2_JOB_NEG_PROTOCOL_DISCRIMINANT => Ok(Protocol::JobNegotiationProtocol),\n+            SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT => Ok(Protocol::TemplateDistributionProtocol),\n+            SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT => Ok(Protocol::JobDistributionProtocol),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl GetSize for Protocol {\n+    fn get_size(&self) -> usize {\n+        1\n+    }\n+}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/subprotocols/template-distribution/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/.gitignore?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "cf1c3df4384d3e28fcbcaa9944adc669a2e6a8d2",
        "filename": "src/rusty/subprotocols/template-distribution/Cargo.toml",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"template_distribution_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 template distribution subprotocol\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional= true }\n+binary_sv2 = { version = \"0.1.3\", path = \"../../../../protocols/v2/binary-sv2/binary-sv2\" }\n+const_sv2 = { version = \"0.1.0\", path = \"../../../../protocols/v2/const-sv2\"}\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "86bf6c11dadd761979feb88ef8eae1034bea7b8c",
        "filename": "src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,27 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2;\n+use binary_sv2::{Deserialize, Serialize};\n+\n+/// ## CoinbaseOutputDataSize (Client -> Server)\n+/// Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and\n+/// other uses, and thus the Template Provider will need to consider this additional block size\n+/// when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\n+/// Thus, this message is used to indicate that some additional space in the block/coinbase\n+/// transaction be reserved for the pool\u2019s use (while always assuming the pool will use the entirety\n+/// of available coinbase space).\n+/// The Job Negotiator MUST discover the maximum serialized size of the additional outputs which\n+/// will be added by the pool(s) it intends to use this work. It then MUST communicate the\n+/// maximum such size to the Template Provider via this message. The Template Provider MUST\n+/// NOT provide NewWork messages which would represent consensus-invalid blocks once this\n+/// additional size \u2014 along with a maximally-sized (100 byte) coinbase field \u2014 is added. Further,\n+/// the Template Provider MUST consider the maximum additional bytes required in the output\n+/// count variable-length integer in the coinbase transaction when complying with the size limits.\n+#[derive(Serialize, Deserialize, Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct CoinbaseOutputDataSize {\n+    /// The maximum additional serialized bytes which the pool will add in\n+    /// coinbase transaction outputs.\n+    pub coinbase_output_max_additional_size: u32,\n+}"
      },
      {
        "sha": "3bb6c5de19c7d20d13604380eb85b94892ee6635",
        "filename": "src/rusty/subprotocols/template-distribution/src/lib.rs",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,49 @@\n+#![no_std]\n+\n+//! # Template Distribution Protocol\n+//! The Template Distribution protocol is used to receive updates of the block template to use in\n+//! mining the next block. It effectively replaces BIPs [22](TODO) and [23](TODO) (getblocktemplate) and provides\n+//! a much more efficient API which allows Bitcoin Core (or some other full node software) to push\n+//! template updates at more appropriate times as well as provide a template which may be\n+//! mined on quickly for the block-after-next. While not recommended, the template update\n+//! protocol can be a remote server, and is thus authenticated and signed in the same way as all\n+//! other protocols ([using the same SetupConnection handshake][TODO]).\n+//! Like the [Job Negotiation](TODO) and [Job Distribution](TODO) (sub)protocols, all Template Distribution messages\n+//! have the channel_msg bit unset, and there is no concept of channels. After the initial common\n+//! handshake, the client MUST immediately send a [`CoinbaseOutputDataSize`] message to indicate\n+//! the space it requires for coinbase output addition, to which the server MUST immediately reply\n+//! with the current best block template it has available to the client. Thereafter, the server\n+//! SHOULD push new block templates to the client whenever the total fee in the current block\n+//! template increases materially, and MUST send updated block templates whenever it learns of\n+//! a new block.\n+//! Template Providers MUST attempt to broadcast blocks which are mined using work they\n+//! provided, and thus MUST track the work which they provided to clients.\n+extern crate alloc;\n+\n+mod coinbase_output_data_size;\n+mod new_template;\n+mod request_transaction_data;\n+mod set_new_prev_hash;\n+mod submit_solution;\n+//\n+pub use coinbase_output_data_size::CoinbaseOutputDataSize;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use new_template::CNewTemplate;\n+pub use new_template::NewTemplate;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use request_transaction_data::{CRequestTransactionDataError, CRequestTransactionDataSuccess};\n+pub use request_transaction_data::{\n+    RequestTransactionData, RequestTransactionDataError, RequestTransactionDataSuccess,\n+};\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use set_new_prev_hash::CSetNewPrevHash;\n+pub use set_new_prev_hash::SetNewPrevHash;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use submit_solution::CSubmitSolution;\n+pub use submit_solution::SubmitSolution;\n+\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_coinbase_out(_a: CoinbaseOutputDataSize) {}\n+\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_req_tx_data(_a: RequestTransactionData) {}"
      },
      {
        "sha": "5a904ecea8bb5ea033b867ed59e0313651cebe46",
        "filename": "src/rusty/subprotocols/template-distribution/src/new_template.rs",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/new_template.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/new_template.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/new_template.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,134 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, free_vec_2, CVec, CVec2};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::{Deserialize, Serialize};\n+use binary_sv2::{Seq0255, B0255, B064K, U256};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## NewTemplate (Server -> Client)\n+/// The primary template-providing function. Note that the coinbase_tx_outputs bytes will appear\n+/// as is at the end of the coinbase transaction.\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct NewTemplate<'decoder> {\n+    /// Server\u2019s identification of the template. Strictly increasing, the\n+    /// current UNIX time may be used in place of an ID.\n+    pub template_id: u64,\n+    /// True if the template is intended for future [`crate::SetNewPrevHash`]\n+    /// message sent on the channel. If False, the job relates to the last\n+    /// sent [`crate::SetNewPrevHash`] message on the channel and the miner\n+    /// should start to work on the job immediately.\n+    pub future_template: bool,\n+    /// Valid header version field that reflects the current network\n+    /// consensus. The general purpose bits (as specified in [BIP320](TODO link)) can\n+    /// be freely manipulated by the downstream node. The downstream\n+    /// node MUST NOT rely on the upstream node to set the BIP320 bits\n+    /// to any particular value.\n+    pub version: u32,\n+    /// The coinbase transaction nVersion field.\n+    pub coinbase_tx_version: u32,\n+    /// Up to 8 bytes (not including the length byte) which are to be placed\n+    /// at the beginning of the coinbase field in the coinbase transaction.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub coinbase_prefix: B0255<'decoder>,\n+    /// The coinbase transaction input\u2019s nSequence field.\n+    pub coinbase_tx_input_sequence: u32,\n+    /// The value, in satoshis, available for spending in coinbase outputs\n+    /// added by the client. Includes both transaction fees and block\n+    /// subsidy.\n+    pub coinbase_tx_value_remaining: u64,\n+    /// The number of transaction outputs included in coinbase_tx_outputs.\n+    pub coinbase_tx_outputs_count: u32,\n+    /// Bitcoin transaction outputs to be included as the last outputs in the\n+    /// coinbase transaction.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub coinbase_tx_outputs: B064K<'decoder>,\n+    /// The locktime field in the coinbase transaction.\n+    pub coinbase_tx_locktime: u32,\n+    /// Merkle path hashes ordered from deepest.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub merkle_path: Seq0255<'decoder, U256<'decoder>>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub struct CNewTemplate {\n+    template_id: u64,\n+    future_template: bool,\n+    version: u32,\n+    coinbase_tx_version: u32,\n+    coinbase_prefix: CVec,\n+    coinbase_tx_input_sequence: u32,\n+    coinbase_tx_value_remaining: u64,\n+    coinbase_tx_outputs_count: u32,\n+    coinbase_tx_outputs: CVec,\n+    coinbase_tx_locktime: u32,\n+    merkle_path: CVec2,\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_new_template(s: CNewTemplate) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CNewTemplate {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.coinbase_prefix);\n+        free_vec(&mut self.coinbase_tx_outputs);\n+        free_vec_2(&mut self.merkle_path);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<NewTemplate<'a>> for CNewTemplate {\n+    fn from(v: NewTemplate<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            future_template: v.future_template,\n+            version: v.version,\n+            coinbase_tx_version: v.coinbase_tx_version,\n+            coinbase_prefix: v.coinbase_prefix.into(),\n+            coinbase_tx_input_sequence: v.coinbase_tx_input_sequence,\n+            coinbase_tx_value_remaining: v.coinbase_tx_value_remaining,\n+            coinbase_tx_outputs_count: v.coinbase_tx_outputs_count,\n+            coinbase_tx_outputs: v.coinbase_tx_outputs.into(),\n+            coinbase_tx_locktime: v.coinbase_tx_locktime,\n+            merkle_path: v.merkle_path.into(),\n+        }\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CNewTemplate {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<NewTemplate<'a>, Error> {\n+        let coinbase_prefix: B0255 = self.coinbase_prefix.as_mut_slice().try_into()?;\n+        let coinbase_tx_outputs: B064K = self.coinbase_tx_outputs.as_mut_slice().try_into()?;\n+\n+        let merkle_path_ = self.merkle_path.as_mut_slice();\n+        let mut merkle_path: Vec<U256> = Vec::new();\n+        for cvec in merkle_path_ {\n+            merkle_path.push(cvec.as_mut_slice().try_into()?);\n+        }\n+\n+        let merkle_path = Seq0255::new(merkle_path)?;\n+        Ok(NewTemplate {\n+            template_id: self.template_id,\n+            future_template: self.future_template,\n+            version: self.version,\n+            coinbase_tx_version: self.coinbase_tx_version,\n+            coinbase_prefix,\n+            coinbase_tx_input_sequence: self.coinbase_tx_input_sequence,\n+            coinbase_tx_value_remaining: self.coinbase_tx_value_remaining,\n+            coinbase_tx_outputs_count: self.coinbase_tx_outputs_count,\n+            coinbase_tx_outputs,\n+            coinbase_tx_locktime: self.coinbase_tx_locktime,\n+            merkle_path,\n+        })\n+    }\n+}"
      },
      {
        "sha": "063745969f5d51a1dc6690cb6d1f116e3fc360e9",
        "filename": "src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs",
        "status": "added",
        "additions": 165,
        "deletions": 0,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,165 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, free_vec_2, CVec, CVec2};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::{Deserialize, Serialize};\n+use binary_sv2::{Seq064K, Str0255, B016M, B064K};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## RequestTransactionData (Client -> Server)\n+/// A request sent by the Job Negotiator to the Template Provider which requests the set of\n+/// transaction data for all transactions (excluding the coinbase transaction) included in a block, as\n+/// well as any additional data which may be required by the Pool to validate the work.\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+#[repr(C)]\n+pub struct RequestTransactionData {\n+    /// The template_id corresponding to a NewTemplate message.\n+    pub template_id: u64,\n+}\n+\n+/// ## RequestTransactionData.Success (Server->Client)\n+/// A response to [`RequestTransactionData`] which contains the set of full transaction data and\n+/// excess data required for validation. For practical purposes, the excess data is usually the\n+/// SegWit commitment, however the Job Negotiator MUST NOT parse or interpret the excess data\n+/// in any way. Note that the transaction data MUST be treated as opaque blobs and MUST include\n+/// any SegWit or other data which the Pool may require to verify the transaction. For practical\n+/// purposes, the transaction data is likely the witness-encoded transaction today. However, to\n+/// ensure backward compatibility, the transaction data MAY be encoded in a way that is different\n+/// from the consensus serialization of Bitcoin transactions.\n+/// Ultimately, having some method of negotiating the specific format of transactions between the\n+/// Template Provider and the Pool\u2019s Template verification node would be overly burdensome,\n+/// thus the following requirements are made explicit. The RequestTransactionData.Success\n+/// sender MUST ensure that the data is provided in a forwards- and backwards-compatible way to\n+/// ensure the end receiver of the data can interpret it, even in the face of new,\n+/// consensus-optional data. This allows significantly more flexibility on both the\n+/// RequestTransactionData.Success-generating and -interpreting sides during upgrades, at the\n+/// cost of breaking some potential optimizations which would require version negotiation to\n+/// provide support for previous versions. For practical purposes, and as a non-normative\n+/// suggested implementation for Bitcoin Core, this implies that additional consensus-optional\n+/// data be appended at the end of transaction data. It will simply be ignored by versions which do\n+/// not understand it.\n+/// To work around the limitation of not being able to negotiate e.g. a transaction compression\n+/// scheme, the format of the opaque data in RequestTransactionData.Success messages MAY be\n+/// changed in non-compatible ways at the time a fork activates, given sufficient time from\n+/// code-release to activation (as any sane fork would have to have) and there being some\n+/// in-Template Negotiation Protocol signaling of support for the new fork (e.g. for soft-forks\n+/// activated using [BIP 9](TODO link)).\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct RequestTransactionDataSuccess<'decoder> {\n+    /// The template_id corresponding to a NewTemplate/RequestTransactionData message.\n+    pub template_id: u64,\n+    /// Extra data which the Pool may require to validate the work.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub excess_data: B064K<'decoder>,\n+    /// The transaction data, serialized as a series of B0_16M byte arrays.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub transaction_list: Seq064K<'decoder, B016M<'decoder>>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub struct CRequestTransactionDataSuccess {\n+    template_id: u64,\n+    excess_data: CVec,\n+    transaction_list: CVec2,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CRequestTransactionDataSuccess {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<RequestTransactionDataSuccess<'a>, Error> {\n+        let excess_data: B064K = self.excess_data.as_mut_slice().try_into()?;\n+        let transaction_list_ = self.transaction_list.as_mut_slice();\n+        let mut transaction_list: Vec<B016M> = Vec::new();\n+        for cvec in transaction_list_ {\n+            transaction_list.push(cvec.as_mut_slice().try_into()?);\n+        }\n+        let transaction_list = Seq064K::new(transaction_list)?;\n+        Ok(RequestTransactionDataSuccess {\n+            template_id: self.template_id,\n+            excess_data,\n+            transaction_list,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_request_tx_data_success(s: CRequestTransactionDataSuccess) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CRequestTransactionDataSuccess {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.excess_data);\n+        free_vec_2(&mut self.transaction_list);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<RequestTransactionDataSuccess<'a>> for CRequestTransactionDataSuccess {\n+    fn from(v: RequestTransactionDataSuccess<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            excess_data: v.excess_data.into(),\n+            transaction_list: v.transaction_list.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct RequestTransactionDataError<'decoder> {\n+    /// The template_id corresponding to a NewTemplate/RequestTransactionData message.\n+    pub template_id: u64,\n+    /// Reason why no transaction data has been provided\n+    /// Possible error codes:\n+    /// * template-id-not-found\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub error_code: Str0255<'decoder>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub struct CRequestTransactionDataError {\n+    template_id: u64,\n+    error_code: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CRequestTransactionDataError {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<RequestTransactionDataError<'a>, Error> {\n+        let error_code: Str0255 = self.error_code.as_mut_slice().try_into()?;\n+        Ok(RequestTransactionDataError {\n+            template_id: self.template_id,\n+            error_code,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_request_tx_data_error(s: CRequestTransactionDataError) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CRequestTransactionDataError {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.error_code);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<RequestTransactionDataError<'a>> for CRequestTransactionDataError {\n+    fn from(v: RequestTransactionDataError<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            error_code: v.error_code.into(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "625cefe3e2763edd13c760bb4aa61ecd992b855f",
        "filename": "src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,90 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, CVec};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::U256;\n+use binary_sv2::{Deserialize, Serialize};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## SetNewPrevHash (Server -> Client)\n+/// Upon successful validation of a new best block, the server MUST immediately provide a\n+/// SetNewPrevHash message. If a [NewWork](TODO link) message has previously been sent with the\n+/// [future_job](TODO link) flag set, which is valid work based on the prev_hash contained in this message, the\n+/// template_id field SHOULD be set to the job_id present in that NewTemplate message\n+/// indicating the client MUST begin mining on that template as soon as possible.\n+/// TODO: Define how many previous works the client has to track (2? 3?), and require that the\n+/// server reference one of those in SetNewPrevHash.\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct SetNewPrevHash<'decoder> {\n+    /// template_id referenced in a previous NewTemplate message.\n+    pub template_id: u64,\n+    /// Previous block\u2019s hash, as it must appear in the next block\u2019s header.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub prev_hash: U256<'decoder>,\n+    /// The nTime field in the block header at which the client should start\n+    /// (usually current time). This is NOT the minimum valid nTime value.\n+    pub header_timestamp: u32,\n+    /// Block header field.\n+    pub n_bits: u32,\n+    /// The maximum double-SHA256 hash value which would represent a valid\n+    /// block. Note that this may be lower than the target implied by nBits in\n+    /// several cases, including weak-block based block propagation.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub target: U256<'decoder>,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[repr(C)]\n+pub struct CSetNewPrevHash {\n+    template_id: u64,\n+    prev_hash: CVec,\n+    header_timestamp: u32,\n+    n_bits: u32,\n+    target: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSetNewPrevHash {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetNewPrevHash<'a>, Error> {\n+        let prev_hash: U256 = self.prev_hash.as_mut_slice().try_into()?;\n+        let target: U256 = self.target.as_mut_slice().try_into()?;\n+\n+        Ok(SetNewPrevHash {\n+            template_id: self.template_id,\n+            prev_hash,\n+            header_timestamp: self.header_timestamp,\n+            n_bits: self.n_bits,\n+            target,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_set_new_prev_hash(s: CSetNewPrevHash) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSetNewPrevHash {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.target);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SetNewPrevHash<'a>> for CSetNewPrevHash {\n+    fn from(v: SetNewPrevHash<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            prev_hash: v.prev_hash.into(),\n+            header_timestamp: v.header_timestamp,\n+            n_bits: v.n_bits,\n+            target: v.target.into(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "dc539d2135a891bb873e6abb55ef89006fe34e25",
        "filename": "src/rusty/subprotocols/template-distribution/src/submit_solution.rs",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/submit_solution.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/subprotocols/template-distribution/src/submit_solution.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/submit_solution.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,88 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, CVec};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::B064K;\n+use binary_sv2::{Deserialize, Serialize};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## SubmitSolution (Client -> Server)\n+/// Upon finding a coinbase transaction/nonce pair which double-SHA256 hashes at or below\n+/// [`crate::SetNewPrevHash.target`], the client MUST immediately send this message, and the server\n+/// MUST then immediately construct the corresponding full block and attempt to propagate it to\n+/// the Bitcoin network.\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+pub struct SubmitSolution<'decoder> {\n+    /// The template_id field as it appeared in NewTemplate.\n+    pub template_id: u64,\n+    /// The version field in the block header. Bits not defined by [BIP320](TODO link) as\n+    /// additional nonce MUST be the same as they appear in the [NewWork](TODO link)\n+    /// message, other bits may be set to any value.\n+    pub version: u32,\n+    /// The nTime field in the block header. This MUST be greater than or equal\n+    /// to the header_timestamp field in the latest [`crate::SetNewPrevHash`] message\n+    /// and lower than or equal to that value plus the number of seconds since\n+    /// the receipt of that message.\n+    pub header_timestamp: u32,\n+    /// The nonce field in the header.\n+    pub header_nonce: u32,\n+    /// The full serialized coinbase transaction, meeting all the requirements of\n+    /// the NewWork message, above.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub coinbase_tx: B064K<'decoder>,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[repr(C)]\n+pub struct CSubmitSolution {\n+    template_id: u64,\n+    version: u32,\n+    header_timestamp: u32,\n+    header_nonce: u32,\n+    coinbase_tx: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSubmitSolution {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SubmitSolution<'a>, Error> {\n+        let coinbase_tx: B064K = self.coinbase_tx.as_mut_slice().try_into()?;\n+\n+        Ok(SubmitSolution {\n+            template_id: self.template_id,\n+            version: self.version,\n+            header_timestamp: self.header_timestamp,\n+            header_nonce: self.header_nonce,\n+            coinbase_tx,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_submit_solution(s: CSubmitSolution) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSubmitSolution {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.coinbase_tx);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SubmitSolution<'a>> for CSubmitSolution {\n+    fn from(v: SubmitSolution<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            version: v.version,\n+            header_timestamp: v.header_timestamp,\n+            header_nonce: v.header_nonce,\n+            coinbase_tx: v.coinbase_tx.into(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "2f47ec23d021af0038adb0e1f1e37f7db8dcf8cb",
        "filename": "src/rusty/sv2-ffi/Cargo.toml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/Cargo.toml?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"sv2_ffi\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+\n+[lib]\n+crate-type = [\"staticlib\"]\n+\n+[dependencies]\n+codec_sv2 = { path = \"../../../protocols/v2/codec-sv2\", version = \"0.1.3\" }\n+const_sv2 = { path = \"../../../protocols/v2/const-sv2\", version = \"0.1.0\" }\n+binary_sv2 = { path = \"../../../protocols/v2/binary-sv2/binary-sv2\", version = \"0.1.3\" }\n+common_messages_sv2 = { path = \"../../../protocols/v2/subprotocols/common-messages\", version = \"0.1.3\" }\n+template_distribution_sv2 = { path = \"../../../protocols/v2/subprotocols/template-distribution\", version = \"0.1.3\"}\n+\n+[features]\n+with_serde = []"
      },
      {
        "sha": "590a57287785c635d95ae3dea95807d376019528",
        "filename": "src/rusty/sv2-ffi/src/lib.rs",
        "status": "added",
        "additions": 377,
        "deletions": 0,
        "changes": 377,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/src/lib.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,377 @@\n+#![cfg(not(feature = \"with_serde\"))]\n+\n+use codec_sv2::{Encoder, Frame, StandardDecoder, StandardSv2Frame};\n+use common_messages_sv2::{\n+    CSetupConnection, CSetupConnectionError, ChannelEndpointChanged, SetupConnection,\n+    SetupConnectionError, SetupConnectionSuccess,\n+};\n+use template_distribution_sv2::{\n+    CNewTemplate, CRequestTransactionDataError, CRequestTransactionDataSuccess, CSetNewPrevHash,\n+    CSubmitSolution, CoinbaseOutputDataSize, NewTemplate, RequestTransactionData,\n+    RequestTransactionDataError, RequestTransactionDataSuccess, SetNewPrevHash, SubmitSolution,\n+};\n+\n+use binary_sv2::{\n+    binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n+    encodable::EncodableField, from_bytes, Deserialize, Error,\n+};\n+\n+use const_sv2::{\n+    MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES, MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n+    MESSAGE_TYPE_NEW_TEMPLATE, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n+    MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS,\n+    MESSAGE_TYPE_SETUP_CONNECTION, MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n+    MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS, MESSAGE_TYPE_SET_NEW_PREV_HASH,\n+    MESSAGE_TYPE_SUBMIT_SOLUTION,\n+};\n+use core::convert::{TryFrom, TryInto};\n+\n+#[derive(Clone, Debug)]\n+pub enum Sv2Message<'a> {\n+    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n+    NewTemplate(NewTemplate<'a>),\n+    RequestTransactionData(RequestTransactionData),\n+    RequestTransactionDataError(RequestTransactionDataError<'a>),\n+    RequestTransactionDataSuccess(RequestTransactionDataSuccess<'a>),\n+    SetNewPrevHash(SetNewPrevHash<'a>),\n+    SubmitSolution(SubmitSolution<'a>),\n+    ChannelEndpointChanged(ChannelEndpointChanged),\n+    SetupConnection(SetupConnection<'a>),\n+    SetupConnectionError(SetupConnectionError<'a>),\n+    SetupConnectionSuccess(SetupConnectionSuccess),\n+}\n+\n+impl<'a> Sv2Message<'a> {\n+    pub fn message_type(&self) -> u8 {\n+        match self {\n+            Sv2Message::CoinbaseOutputDataSize(_) => MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n+            Sv2Message::NewTemplate(_) => MESSAGE_TYPE_NEW_TEMPLATE,\n+            Sv2Message::RequestTransactionData(_) => MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n+            Sv2Message::RequestTransactionDataError(_) => {\n+                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR\n+            }\n+            Sv2Message::RequestTransactionDataSuccess(_) => {\n+                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS\n+            }\n+            Sv2Message::SetNewPrevHash(_) => MESSAGE_TYPE_SET_NEW_PREV_HASH,\n+            Sv2Message::SubmitSolution(_) => MESSAGE_TYPE_SUBMIT_SOLUTION,\n+            Sv2Message::ChannelEndpointChanged(_) => MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES,\n+            Sv2Message::SetupConnection(_) => MESSAGE_TYPE_SETUP_CONNECTION,\n+            Sv2Message::SetupConnectionError(_) => MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n+            Sv2Message::SetupConnectionSuccess(_) => MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS,\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub enum CSv2Message {\n+    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n+    NewTemplate(CNewTemplate),\n+    RequestTransactionData(RequestTransactionData),\n+    RequestTransactionDataError(CRequestTransactionDataError),\n+    RequestTransactionDataSuccess(CRequestTransactionDataSuccess),\n+    SetNewPrevHash(CSetNewPrevHash),\n+    SubmitSolution(CSubmitSolution),\n+    ChannelEndpointChanged(ChannelEndpointChanged),\n+    SetupConnection(CSetupConnection),\n+    SetupConnectionError(CSetupConnectionError),\n+    SetupConnectionSuccess(SetupConnectionSuccess),\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn drop_sv2_message(s: CSv2Message) {\n+    match s {\n+        CSv2Message::CoinbaseOutputDataSize(_) => (),\n+        CSv2Message::NewTemplate(a) => drop(a),\n+        CSv2Message::RequestTransactionData(a) => drop(a),\n+        CSv2Message::RequestTransactionDataError(a) => drop(a),\n+        CSv2Message::RequestTransactionDataSuccess(a) => drop(a),\n+        CSv2Message::SetNewPrevHash(a) => drop(a),\n+        CSv2Message::SubmitSolution(a) => drop(a),\n+        CSv2Message::ChannelEndpointChanged(_) => (),\n+        CSv2Message::SetupConnection(_) => (),\n+        CSv2Message::SetupConnectionError(a) => drop(a),\n+        CSv2Message::SetupConnectionSuccess(a) => drop(a),\n+    }\n+}\n+\n+impl<'a> From<Sv2Message<'a>> for CSv2Message {\n+    fn from(v: Sv2Message<'a>) -> Self {\n+        match v {\n+            Sv2Message::CoinbaseOutputDataSize(a) => Self::CoinbaseOutputDataSize(a),\n+            Sv2Message::NewTemplate(a) => Self::NewTemplate(a.into()),\n+            Sv2Message::RequestTransactionData(a) => Self::RequestTransactionData(a),\n+            Sv2Message::RequestTransactionDataError(a) => {\n+                Self::RequestTransactionDataError(a.into())\n+            }\n+            Sv2Message::RequestTransactionDataSuccess(a) => {\n+                Self::RequestTransactionDataSuccess(a.into())\n+            }\n+            Sv2Message::SetNewPrevHash(a) => Self::SetNewPrevHash(a.into()),\n+            Sv2Message::SubmitSolution(a) => Self::SubmitSolution(a.into()),\n+            Sv2Message::ChannelEndpointChanged(a) => Self::ChannelEndpointChanged(a),\n+            Sv2Message::SetupConnection(a) => Self::SetupConnection(a.into()),\n+            Sv2Message::SetupConnectionError(a) => Self::SetupConnectionError(a.into()),\n+            Sv2Message::SetupConnectionSuccess(a) => Self::SetupConnectionSuccess(a),\n+        }\n+    }\n+}\n+\n+impl<'a> CSv2Message {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<Sv2Message<'a>, Error> {\n+        match self {\n+            //CSv2Message::CoinbaseOutputDataSize(v) => {Ok(Sv2Message::CoinbaseOutputDataSize(*v))}\n+            CSv2Message::NewTemplate(v) => Ok(Sv2Message::NewTemplate(v.to_rust_rep_mut()?)),\n+            //CSv2Message::RequestTransactionData(v) => {Ok(Sv2Message::RequestTransactionData(*v))}\n+            //CSv2Message::RequestTransactionDataError(mut v) => {Ok(Sv2Message::RequestTransactionDataError(v.to_rust_rep_mut()?))}\n+            //CSv2Message::RequestTransactionDataSuccess(mut v) => {Ok(Sv2Message::RequestTransactionDataSuccess(v.to_rust_rep_mut()?))}\n+            CSv2Message::SetNewPrevHash(v) => Ok(Sv2Message::SetNewPrevHash(v.to_rust_rep_mut()?)),\n+            CSv2Message::SubmitSolution(v) => Ok(Sv2Message::SubmitSolution(v.to_rust_rep_mut()?)),\n+            //CSv2Message::ChannelEndpointChanged(v) => {Ok(Sv2Message::ChannelEndpointChanged(*v))}\n+            CSv2Message::SetupConnection(v) => {\n+                Ok(Sv2Message::SetupConnection(v.to_rust_rep_mut()?))\n+            }\n+            CSv2Message::SetupConnectionError(v) => {\n+                Ok(Sv2Message::SetupConnectionError(v.to_rust_rep_mut()?))\n+            }\n+            //CSv2Message::SetupConnectionSuccess(v) => {Ok(Sv2Message::SetupConnectionSuccess(*v))}\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n+impl<'decoder> From<Sv2Message<'decoder>> for EncodableField<'decoder> {\n+    fn from(m: Sv2Message<'decoder>) -> Self {\n+        match m {\n+            Sv2Message::CoinbaseOutputDataSize(a) => a.into(),\n+            Sv2Message::NewTemplate(a) => a.into(),\n+            Sv2Message::RequestTransactionData(a) => a.into(),\n+            Sv2Message::RequestTransactionDataError(a) => a.into(),\n+            Sv2Message::RequestTransactionDataSuccess(a) => a.into(),\n+            Sv2Message::SetNewPrevHash(a) => a.into(),\n+            Sv2Message::SubmitSolution(a) => a.into(),\n+            Sv2Message::ChannelEndpointChanged(a) => a.into(),\n+            Sv2Message::SetupConnection(a) => a.into(),\n+            Sv2Message::SetupConnectionError(a) => a.into(),\n+            Sv2Message::SetupConnectionSuccess(a) => a.into(),\n+        }\n+    }\n+}\n+\n+impl binary_sv2::GetSize for Sv2Message<'_> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Sv2Message::CoinbaseOutputDataSize(a) => a.get_size(),\n+            Sv2Message::NewTemplate(a) => a.get_size(),\n+            Sv2Message::RequestTransactionData(a) => a.get_size(),\n+            Sv2Message::RequestTransactionDataError(a) => a.get_size(),\n+            Sv2Message::RequestTransactionDataSuccess(a) => a.get_size(),\n+            Sv2Message::SetNewPrevHash(a) => a.get_size(),\n+            Sv2Message::SubmitSolution(a) => a.get_size(),\n+            Sv2Message::ChannelEndpointChanged(a) => a.get_size(),\n+            Sv2Message::SetupConnection(a) => a.get_size(),\n+            Sv2Message::SetupConnectionError(a) => a.get_size(),\n+            Sv2Message::SetupConnectionSuccess(a) => a.get_size(),\n+        }\n+    }\n+}\n+\n+impl<'decoder> Deserialize<'decoder> for Sv2Message<'decoder> {\n+    fn get_structure(_v: &[u8]) -> std::result::Result<Vec<FieldMarker>, binary_sv2::Error> {\n+        unimplemented!()\n+    }\n+    fn from_decoded_fields(\n+        _v: Vec<DecodableField<'decoder>>,\n+    ) -> std::result::Result<Self, binary_sv2::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a> TryFrom<(u8, &'a mut [u8])> for Sv2Message<'a> {\n+    type Error = Error;\n+\n+    fn try_from(v: (u8, &'a mut [u8])) -> Result<Self, Self::Error> {\n+        let msg_type = v.0;\n+        match msg_type {\n+            MESSAGE_TYPE_SETUP_CONNECTION => {\n+                let message: SetupConnection<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnection(message))\n+            }\n+            MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS => {\n+                let message: SetupConnectionSuccess = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnectionSuccess(message))\n+            }\n+            MESSAGE_TYPE_SETUP_CONNECTION_ERROR => {\n+                let message: SetupConnectionError<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnectionError(message))\n+            }\n+            MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES => {\n+                let message: ChannelEndpointChanged = from_bytes(v.1)?;\n+                Ok(Sv2Message::ChannelEndpointChanged(message))\n+            }\n+            MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE => {\n+                let message: CoinbaseOutputDataSize = from_bytes(v.1)?;\n+                Ok(Sv2Message::CoinbaseOutputDataSize(message))\n+            }\n+            MESSAGE_TYPE_NEW_TEMPLATE => {\n+                let message: NewTemplate<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::NewTemplate(message))\n+            }\n+            MESSAGE_TYPE_SET_NEW_PREV_HASH => {\n+                let message: SetNewPrevHash<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetNewPrevHash(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA => {\n+                let message: RequestTransactionData = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionData(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS => {\n+                let message: RequestTransactionDataSuccess = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionDataSuccess(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR => {\n+                let message: RequestTransactionDataError = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionDataError(message))\n+            }\n+            MESSAGE_TYPE_SUBMIT_SOLUTION => {\n+                let message: SubmitSolution = from_bytes(v.1)?;\n+                Ok(Sv2Message::SubmitSolution(message))\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub enum CResult<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+\n+#[repr(C)]\n+pub enum Sv2Error {\n+    MissingBytes,\n+    EncoderBusy,\n+    Todo,\n+    Unknown,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn is_ok(cresult: &CResult<CSv2Message, Sv2Error>) -> bool {\n+    match cresult {\n+        CResult::Ok(_) => true,\n+        CResult::Err(_) => false,\n+    }\n+}\n+\n+impl<T, E> From<Result<T, E>> for CResult<T, E> {\n+    fn from(v: Result<T, E>) -> Self {\n+        match v {\n+            Ok(v) => Self::Ok(v),\n+            Err(e) => Self::Err(e),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct EncoderWrapper {\n+    encoder: Encoder<Sv2Message<'static>>,\n+    free: bool,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn new_encoder() -> *mut EncoderWrapper {\n+    let encoder: Encoder<Sv2Message<'static>> = Encoder::new();\n+    let s = Box::new(EncoderWrapper {\n+        encoder,\n+        free: true,\n+    });\n+    Box::into_raw(s)\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn free_encoder(encoder: *mut EncoderWrapper) {\n+    let mut encoder = unsafe { Box::from_raw(encoder) };\n+    encoder.free = true;\n+    Box::into_raw(encoder);\n+}\n+\n+fn encode_(message: &'static mut CSv2Message, encoder: &mut EncoderWrapper) -> Result<CVec, Error> {\n+    let message: Sv2Message = message.to_rust_rep_mut()?;\n+    let m_type = message.message_type();\n+    let frame = StandardSv2Frame::<Sv2Message<'static>>::from_message(message, m_type, 0)\n+        .ok_or(Error::Todo)?;\n+    encoder\n+        .encoder\n+        .encode(frame)\n+        .map_err(|_| Error::Todo)\n+        .map(|x| x.into())\n+}\n+\n+/// # Safety\n+///\n+/// TODO\n+#[no_mangle]\n+pub unsafe extern \"C\" fn encode(\n+    message: &'static mut CSv2Message,\n+    encoder: *mut EncoderWrapper,\n+) -> CResult<CVec, Sv2Error> {\n+    let mut encoder = Box::from_raw(encoder);\n+    if encoder.free {\n+        let result = encode_(message, &mut encoder)\n+            .map_err(|_| Sv2Error::Todo)\n+            .into();\n+        encoder.free = false;\n+        Box::into_raw(encoder);\n+        result\n+    } else {\n+        CResult::Err(Sv2Error::EncoderBusy)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct DecoderWrapper(StandardDecoder<Sv2Message<'static>>);\n+\n+#[no_mangle]\n+pub extern \"C\" fn new_decoder() -> *mut DecoderWrapper {\n+    let s = Box::new(DecoderWrapper(StandardDecoder::new()));\n+    Box::into_raw(s)\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn get_writable(decoder: *mut DecoderWrapper) -> CVec {\n+    let mut decoder = unsafe { Box::from_raw(decoder) };\n+    let writable = decoder.0.writable();\n+    let res = CVec::as_shared_buffer(writable);\n+    Box::into_raw(decoder);\n+    res\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn next_frame(decoder: *mut DecoderWrapper) -> CResult<CSv2Message, Sv2Error> {\n+    let mut decoder = unsafe { Box::from_raw(decoder) };\n+\n+    match decoder.0.next_frame() {\n+        Ok(mut f) => {\n+            let msg_type = f.get_header().unwrap().msg_type();\n+            let payload = f.payload();\n+            let len = payload.len();\n+            let ptr = payload.as_mut_ptr();\n+            let payload = unsafe { std::slice::from_raw_parts_mut(ptr, len) };\n+            Box::into_raw(decoder);\n+            (msg_type, payload)\n+                .try_into()\n+                .map(|x: Sv2Message| x.into())\n+                .map_err(|_| Sv2Error::Unknown)\n+                .into()\n+        }\n+        Err(_) => {\n+            Box::into_raw(decoder);\n+            CResult::Err(Sv2Error::MissingBytes)\n+        }\n+    }\n+}"
      },
      {
        "sha": "bdb4ac3dade628ea43559b24526ad311140ae653",
        "filename": "src/rusty/sv2-ffi/src/lib__.rs",
        "status": "added",
        "additions": 629,
        "deletions": 0,
        "changes": 629,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/src/lib__.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/src/lib__.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/src/lib__.rs?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,629 @@\n+use codec_sv2::{Encoder, Frame, StandardDecoder, StandardSv2Frame};\n+use common_messages_sv2::{\n+    CSetupConnection, CSetupConnectionError, ChannelEndpointChanged, SetupConnection,\n+    SetupConnectionError, SetupConnectionSuccess,\n+};\n+use template_distribution_sv2::{\n+    CNewTemplate, CRequestTransactionDataError, CRequestTransactionDataSuccess, CSetNewPrevHash,\n+    CSubmitSolution, CoinbaseOutputDataSize, NewTemplate, RequestTransactionData,\n+    RequestTransactionDataError, RequestTransactionDataSuccess, SetNewPrevHash, SubmitSolution,\n+};\n+\n+use binary_sv2::{\n+    binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n+    encodable::EncodableField, from_bytes, Deserialize, Error,\n+};\n+\n+use const_sv2::{\n+    MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES, MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n+    MESSAGE_TYPE_NEW_TEMPLATE, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n+    MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS,\n+    MESSAGE_TYPE_SETUP_CONNECTION, MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n+    MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS, MESSAGE_TYPE_SET_NEW_PREV_HASH,\n+    MESSAGE_TYPE_SUBMIT_SOLUTION,\n+};\n+use core::convert::{TryFrom, TryInto};\n+\n+#[derive(Clone, Debug)]\n+pub enum Sv2Message<'a> {\n+    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n+    NewTemplate(NewTemplate<'a>),\n+    RequestTransactionData(RequestTransactionData),\n+    RequestTransactionDataError(RequestTransactionDataError<'a>),\n+    RequestTransactionDataSuccess(RequestTransactionDataSuccess<'a>),\n+    SetNewPrevHash(SetNewPrevHash<'a>),\n+    SubmitSolution(SubmitSolution<'a>),\n+    ChannelEndpointChanged(ChannelEndpointChanged),\n+    SetupConnection(SetupConnection<'a>),\n+    SetupConnectionError(SetupConnectionError<'a>),\n+    SetupConnectionSuccess(SetupConnectionSuccess),\n+}\n+\n+impl<'a> Sv2Message<'a> {\n+    pub fn message_type(&self) -> u8 {\n+        match self {\n+            Sv2Message::CoinbaseOutputDataSize(_) => MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n+            Sv2Message::NewTemplate(_) => MESSAGE_TYPE_NEW_TEMPLATE,\n+            Sv2Message::RequestTransactionData(_) => MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n+            Sv2Message::RequestTransactionDataError(_) => {\n+                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR\n+            }\n+            Sv2Message::RequestTransactionDataSuccess(_) => {\n+                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS\n+            }\n+            Sv2Message::SetNewPrevHash(_) => MESSAGE_TYPE_SET_NEW_PREV_HASH,\n+            Sv2Message::SubmitSolution(_) => MESSAGE_TYPE_SUBMIT_SOLUTION,\n+            Sv2Message::ChannelEndpointChanged(_) => MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES,\n+            Sv2Message::SetupConnection(_) => MESSAGE_TYPE_SETUP_CONNECTION,\n+            Sv2Message::SetupConnectionError(_) => MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n+            Sv2Message::SetupConnectionSuccess(_) => MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS,\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub enum CSv2Message {\n+    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n+    NewTemplate(CNewTemplate),\n+    RequestTransactionData(RequestTransactionData),\n+    RequestTransactionDataError(CRequestTransactionDataError),\n+    RequestTransactionDataSuccess(CRequestTransactionDataSuccess),\n+    SetNewPrevHash(CSetNewPrevHash),\n+    SubmitSolution(CSubmitSolution),\n+    ChannelEndpointChanged(ChannelEndpointChanged),\n+    SetupConnection(CSetupConnection),\n+    SetupConnectionError(CSetupConnectionError),\n+    SetupConnectionSuccess(SetupConnectionSuccess),\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn drop_sv2_message(s: CSv2Message) {\n+    match s {\n+        CSv2Message::CoinbaseOutputDataSize(_) => (),\n+        CSv2Message::NewTemplate(a) => drop(a),\n+        CSv2Message::RequestTransactionData(a) => drop(a),\n+        CSv2Message::RequestTransactionDataError(a) => drop(a),\n+        CSv2Message::RequestTransactionDataSuccess(a) => drop(a),\n+        CSv2Message::SetNewPrevHash(a) => drop(a),\n+        CSv2Message::SubmitSolution(a) => drop(a),\n+        CSv2Message::ChannelEndpointChanged(_) => (),\n+        CSv2Message::SetupConnection(_) => (),\n+        CSv2Message::SetupConnectionError(a) => drop(a),\n+        CSv2Message::SetupConnectionSuccess(a) => drop(a),\n+    }\n+}\n+\n+impl<'a> From<Sv2Message<'a>> for CSv2Message {\n+    fn from(v: Sv2Message<'a>) -> Self {\n+        match v {\n+            Sv2Message::CoinbaseOutputDataSize(a) => Self::CoinbaseOutputDataSize(a),\n+            Sv2Message::NewTemplate(a) => Self::NewTemplate(a.into()),\n+            Sv2Message::RequestTransactionData(a) => Self::RequestTransactionData(a),\n+            Sv2Message::RequestTransactionDataError(a) => {\n+                Self::RequestTransactionDataError(a.into())\n+            }\n+            Sv2Message::RequestTransactionDataSuccess(a) => {\n+                Self::RequestTransactionDataSuccess(a.into())\n+            }\n+            Sv2Message::SetNewPrevHash(a) => Self::SetNewPrevHash(a.into()),\n+            Sv2Message::SubmitSolution(a) => Self::SubmitSolution(a.into()),\n+            Sv2Message::ChannelEndpointChanged(a) => Self::ChannelEndpointChanged(a),\n+            Sv2Message::SetupConnection(a) => Self::SetupConnection(a.into()),\n+            Sv2Message::SetupConnectionError(a) => Self::SetupConnectionError(a.into()),\n+            Sv2Message::SetupConnectionSuccess(a) => Self::SetupConnectionSuccess(a),\n+        }\n+    }\n+}\n+\n+impl<'a> CSv2Message {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<Sv2Message<'a>, Error> {\n+        match self {\n+            //CSv2Message::CoinbaseOutputDataSize(v) => {Ok(Sv2Message::CoinbaseOutputDataSize(*v))}\n+            CSv2Message::NewTemplate(v) => Ok(Sv2Message::NewTemplate(v.to_rust_rep_mut()?)),\n+            //CSv2Message::RequestTransactionData(v) => {Ok(Sv2Message::RequestTransactionData(*v))}\n+            //CSv2Message::RequestTransactionDataError(mut v) => {Ok(Sv2Message::RequestTransactionDataError(v.to_rust_rep_mut()?))}\n+            //CSv2Message::RequestTransactionDataSuccess(mut v) => {Ok(Sv2Message::RequestTransactionDataSuccess(v.to_rust_rep_mut()?))}\n+            CSv2Message::SetNewPrevHash(v) => Ok(Sv2Message::SetNewPrevHash(v.to_rust_rep_mut()?)),\n+            CSv2Message::SubmitSolution(v) => Ok(Sv2Message::SubmitSolution(v.to_rust_rep_mut()?)),\n+            //CSv2Message::ChannelEndpointChanged(v) => {Ok(Sv2Message::ChannelEndpointChanged(*v))}\n+            CSv2Message::SetupConnection(v) => {\n+                Ok(Sv2Message::SetupConnection(v.to_rust_rep_mut()?))\n+            }\n+            CSv2Message::SetupConnectionError(v) => {\n+                Ok(Sv2Message::SetupConnectionError(v.to_rust_rep_mut()?))\n+            }\n+            //CSv2Message::SetupConnectionSuccess(v) => {Ok(Sv2Message::SetupConnectionSuccess(*v))}\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n+impl<'decoder> From<Sv2Message<'decoder>> for EncodableField<'decoder> {\n+    fn from(m: Sv2Message<'decoder>) -> Self {\n+        match m {\n+            Sv2Message::CoinbaseOutputDataSize(a) => a.into(),\n+            Sv2Message::NewTemplate(a) => a.into(),\n+            Sv2Message::RequestTransactionData(a) => a.into(),\n+            Sv2Message::RequestTransactionDataError(a) => a.into(),\n+            Sv2Message::RequestTransactionDataSuccess(a) => a.into(),\n+            Sv2Message::SetNewPrevHash(a) => a.into(),\n+            Sv2Message::SubmitSolution(a) => a.into(),\n+            Sv2Message::ChannelEndpointChanged(a) => a.into(),\n+            Sv2Message::SetupConnection(a) => a.into(),\n+            Sv2Message::SetupConnectionError(a) => a.into(),\n+            Sv2Message::SetupConnectionSuccess(a) => a.into(),\n+        }\n+    }\n+}\n+\n+impl binary_sv2::GetSize for Sv2Message<'_> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Sv2Message::CoinbaseOutputDataSize(a) => a.get_size(),\n+            Sv2Message::NewTemplate(a) => a.get_size(),\n+            Sv2Message::RequestTransactionData(a) => a.get_size(),\n+            Sv2Message::RequestTransactionDataError(a) => a.get_size(),\n+            Sv2Message::RequestTransactionDataSuccess(a) => a.get_size(),\n+            Sv2Message::SetNewPrevHash(a) => a.get_size(),\n+            Sv2Message::SubmitSolution(a) => a.get_size(),\n+            Sv2Message::ChannelEndpointChanged(a) => a.get_size(),\n+            Sv2Message::SetupConnection(a) => a.get_size(),\n+            Sv2Message::SetupConnectionError(a) => a.get_size(),\n+            Sv2Message::SetupConnectionSuccess(a) => a.get_size(),\n+        }\n+    }\n+}\n+\n+impl<'decoder> Deserialize<'decoder> for Sv2Message<'decoder> {\n+    fn get_structure(_v: &[u8]) -> std::result::Result<Vec<FieldMarker>, binary_sv2::Error> {\n+        unimplemented!()\n+    }\n+    fn from_decoded_fields(\n+        _v: Vec<DecodableField<'decoder>>,\n+    ) -> std::result::Result<Self, binary_sv2::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a> TryFrom<(u8, &'a mut [u8])> for Sv2Message<'a> {\n+    type Error = Error;\n+\n+    fn try_from(v: (u8, &'a mut [u8])) -> Result<Self, Self::Error> {\n+        let msg_type = v.0;\n+        match msg_type {\n+            MESSAGE_TYPE_SETUP_CONNECTION => {\n+                let message: SetupConnection<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnection(message))\n+            }\n+            MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS => {\n+                let message: SetupConnectionSuccess = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnectionSuccess(message))\n+            }\n+            MESSAGE_TYPE_SETUP_CONNECTION_ERROR => {\n+                let message: SetupConnectionError<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnectionError(message))\n+            }\n+            MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES => {\n+                let message: ChannelEndpointChanged = from_bytes(v.1)?;\n+                Ok(Sv2Message::ChannelEndpointChanged(message))\n+            }\n+            MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE => {\n+                let message: CoinbaseOutputDataSize = from_bytes(v.1)?;\n+                Ok(Sv2Message::CoinbaseOutputDataSize(message))\n+            }\n+            MESSAGE_TYPE_NEW_TEMPLATE => {\n+                let message: NewTemplate<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::NewTemplate(message))\n+            }\n+            MESSAGE_TYPE_SET_NEW_PREV_HASH => {\n+                let message: SetNewPrevHash<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetNewPrevHash(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA => {\n+                let message: RequestTransactionData = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionData(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS => {\n+                let message: RequestTransactionDataSuccess = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionDataSuccess(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR => {\n+                let message: RequestTransactionDataError = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionDataError(message))\n+            }\n+            MESSAGE_TYPE_SUBMIT_SOLUTION => {\n+                let message: SubmitSolution = from_bytes(v.1)?;\n+                Ok(Sv2Message::SubmitSolution(message))\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub enum CResult<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+\n+#[repr(C)]\n+pub enum Sv2Error {\n+    MissingBytes,\n+    EncoderBusy,\n+    Todo,\n+    Unknown,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn is_ok(cresult: &CResult<CSv2Message, Sv2Error>) -> bool {\n+    match cresult {\n+        CResult::Ok(_) => true,\n+        CResult::Err(_) => false,\n+    }\n+}\n+\n+impl<T, E> From<Result<T, E>> for CResult<T, E> {\n+    fn from(v: Result<T, E>) -> Self {\n+        match v {\n+            Ok(v) => Self::Ok(v),\n+            Err(e) => Self::Err(e),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct EncoderWrapper {\n+    encoder: Encoder<Sv2Message<'static>>,\n+    free: bool,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn new_encoder() -> *mut EncoderWrapper {\n+    let encoder: Encoder<Sv2Message<'static>> = Encoder::new();\n+    let s = Box::new(EncoderWrapper {\n+        encoder,\n+        free: true,\n+    });\n+    Box::into_raw(s)\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn free_encoder(encoder: *mut EncoderWrapper) {\n+    let mut encoder = unsafe { Box::from_raw(encoder) };\n+    encoder.free = true;\n+    Box::into_raw(encoder);\n+}\n+\n+fn encode_(message: &'static mut CSv2Message, encoder: &mut EncoderWrapper) -> Result<CVec, Error> {\n+    let message: Sv2Message = message.to_rust_rep_mut()?;\n+    let m_type = message.message_type();\n+    let frame = StandardSv2Frame::<Sv2Message<'static>>::from_message(message, m_type, 0)\n+        .ok_or(Error::Todo)?;\n+    encoder\n+        .encoder\n+        .encode(frame)\n+        .map_err(|_| Error::Todo)\n+        .map(|x| x.into())\n+}\n+\n+/// # Safety\n+///\n+/// TODO\n+#[no_mangle]\n+pub unsafe extern \"C\" fn encode(\n+    message: &'static mut CSv2Message,\n+    encoder: *mut EncoderWrapper,\n+) -> CResult<CVec, Sv2Error> {\n+    let mut encoder = Box::from_raw(encoder);\n+    if encoder.free {\n+        let result = encode_(message, &mut encoder)\n+            .map_err(|_| Sv2Error::Todo)\n+            .into();\n+        encoder.free = false;\n+        Box::into_raw(encoder);\n+        result\n+    } else {\n+        CResult::Err(Sv2Error::EncoderBusy)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct DecoderWrapper(StandardDecoder<Sv2Message<'static>>);\n+\n+#[no_mangle]\n+pub extern \"C\" fn new_decoder() -> *mut DecoderWrapper {\n+    let s = Box::new(DecoderWrapper(StandardDecoder::new()));\n+    Box::into_raw(s)\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn get_writable(decoder: *mut DecoderWrapper) -> CVec {\n+    let mut decoder = unsafe { Box::from_raw(decoder) };\n+    let writable = decoder.0.writable();\n+    let res = CVec::as_shared_buffer(writable);\n+    Box::into_raw(decoder);\n+    res\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn next_frame(decoder: *mut DecoderWrapper) -> CResult<CSv2Message, Sv2Error> {\n+    let mut decoder = unsafe { Box::from_raw(decoder) };\n+\n+    match decoder.0.next_frame() {\n+        Ok(mut f) => {\n+            let msg_type = f.get_header().unwrap().msg_type();\n+            let payload = f.payload();\n+            let len = payload.len();\n+            let ptr = payload.as_mut_ptr();\n+            let payload = unsafe { std::slice::from_raw_parts_mut(ptr, len) };\n+            Box::into_raw(decoder);\n+            (msg_type, payload)\n+                .try_into()\n+                .map(|x: Sv2Message| x.into())\n+                .map_err(|_| Sv2Error::Unknown)\n+                .into()\n+        }\n+        Err(_) => {\n+            Box::into_raw(decoder);\n+            CResult::Err(Sv2Error::MissingBytes)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use common_messages_sv2::Protocol;\n+\n+    //use quickcheck::{Arbitrary, Gen};\n+\n+    use quickcheck_macros;\n+\n+    fn get_setup_connection() -> SetupConnection<'static> {\n+        let setup_connection = SetupConnection {\n+            protocol: Protocol::TemplateDistributionProtocol, // 2\n+            min_version: 2,\n+            max_version: 2,\n+            flags: 0,\n+            endpoint_host: \"0.0.0.0\".to_string().into_bytes().try_into().unwrap(),\n+            endpoint_port: 8081,\n+            vendor: \"Bitmain\".to_string().into_bytes().try_into().unwrap(),\n+            hardware_version: \"901\".to_string().into_bytes().try_into().unwrap(),\n+            firmware: \"abcX\".to_string().into_bytes().try_into().unwrap(),\n+            device_id: \"89567\".to_string().into_bytes().try_into().unwrap(),\n+        };\n+        return setup_connection;\n+    }\n+\n+    #[test]\n+    fn test_message_type_cb_output_data_size() {\n+        let expected = MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE;\n+        let cb_output_data_size = CoinbaseOutputDataSize {\n+            coinbase_output_max_additional_size: 0,\n+        };\n+        let sv2_message = Sv2Message::CoinbaseOutputDataSize(cb_output_data_size);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expected, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_new_template() {\n+        let expected = MESSAGE_TYPE_NEW_TEMPLATE;\n+        let new_template = NewTemplate {\n+            template_id: 0,\n+            future_template: false,\n+            version: 0x01000000,\n+            coinbase_tx_version: 0x01000000,\n+            coinbase_prefix: \"0\".to_string().into_bytes().try_into().unwrap(),\n+            coinbase_tx_input_sequence: 0xffffffff,\n+            coinbase_tx_value_remaining: 0x00f2052a,\n+            coinbase_tx_outputs_count: 1,\n+            coinbase_tx_outputs: \"0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac\"\n+                .to_string()\n+                .into_bytes()\n+                .try_into()\n+                .unwrap(),\n+            coinbase_tx_locktime: 0x00000000,\n+            merkle_path: binary_sv2::Seq0255::new(Vec::<binary_sv2::U256>::new()).unwrap(),\n+\n+        };\n+        let sv2_message = Sv2Message::NewTemplate(new_template);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expected, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_request_transaction_data() {\n+        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA;\n+        let request_tx_data = RequestTransactionData { template_id: 0 };\n+        let sv2_message = Sv2Message::RequestTransactionData(request_tx_data);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_request_transaction_data_error() {\n+        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR;\n+        let request_tx_data_err = RequestTransactionDataError {\n+            template_id: 0,\n+            error_code: \"an error code\".to_string().into_bytes().try_into().unwrap(),\n+        };\n+        let sv2_message = Sv2Message::RequestTransactionDataError(request_tx_data_err);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_request_transaction_data_success() {\n+        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS;\n+\n+        let request_tx_data_success = RequestTransactionDataSuccess {\n+            template_id: 0,\n+            excess_data: \"some_excess_data\"\n+                .to_string()\n+                .into_bytes()\n+                .try_into()\n+                .unwrap(),\n+            transaction_list: binary_sv2::Seq064K::new(Vec::new()).unwrap(),\n+        };\n+        let sv2_message = Sv2Message::RequestTransactionDataSuccess(request_tx_data_success);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_set_new_prev_hash() {\n+        let expect = MESSAGE_TYPE_SET_NEW_PREV_HASH;\n+\n+        let mut u256 = [0_u8; 32];\n+        let u256_prev_hash: binary_sv2::U256 = (&mut u256[..]).try_into().unwrap();\n+\n+        let mut u256 = [0_u8; 32];\n+        let u256_target: binary_sv2::U256 = (&mut u256[..]).try_into().unwrap();\n+\n+        let set_new_prev_hash = SetNewPrevHash {\n+            template_id: 0,\n+            prev_hash: u256_prev_hash,\n+            header_timestamp: 0x29ab5f49,\n+            n_bits: 0xffff001d,\n+            target: u256_target,\n+        };\n+        let sv2_message = Sv2Message::SetNewPrevHash(set_new_prev_hash);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_submit_solution() {\n+        let expect = MESSAGE_TYPE_SUBMIT_SOLUTION;\n+\n+        let submit_solution = SubmitSolution {\n+            template_id: 0,\n+            version: 0x01000000,\n+            header_timestamp: 0x29ab5f49,\n+            header_nonce: 0x1dac2b7c,\n+            coinbase_tx: \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\"\n+                .to_string()\n+                .into_bytes()\n+                .try_into()\n+                .unwrap(),\n+        };\n+\n+        let sv2_message = Sv2Message::SubmitSolution(submit_solution);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_channel_endpoint_changed() {\n+        let expect = MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES;\n+\n+        let channel_endpoint_changed = ChannelEndpointChanged { channel_id: 0 };\n+\n+        let sv2_message = Sv2Message::ChannelEndpointChanged(channel_endpoint_changed);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_setup_connection() {\n+        let expect = MESSAGE_TYPE_SETUP_CONNECTION;\n+\n+        let setup_connection = get_setup_connection();\n+\n+        let sv2_message = Sv2Message::SetupConnection(setup_connection);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_setup_connection_error() {\n+        let expect = MESSAGE_TYPE_SETUP_CONNECTION_ERROR;\n+\n+        let setup_connection_err = SetupConnectionError {\n+            flags: 0,\n+            error_code: \"an error code\".to_string().into_bytes().try_into().unwrap(),\n+        };\n+\n+        let sv2_message = Sv2Message::SetupConnectionError(setup_connection_err);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_setup_connection_success() {\n+        let expect = MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS;\n+\n+        let setup_connection_success = SetupConnectionSuccess {\n+            used_version: 1,\n+            flags: 0,\n+        };\n+\n+        let sv2_message = Sv2Message::SetupConnectionSuccess(setup_connection_success);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn test_next_frame() {\n+        let decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+        println!(\"DECODER: {:?}\", &decoder);\n+        println!(\"DECODER 2: {:?}\", &decoder);\n+        let mut decoder_wrapper = DecoderWrapper(decoder);\n+        let _res = next_frame(&mut decoder_wrapper);\n+    }\n+\n+    #[test]\n+    fn test_encode() {\n+        let mut encoder = Encoder::<SetupConnection>::new();\n+        let setup_connection = get_setup_connection();\n+        let setup_connection =\n+            StandardSv2Frame::from_message(setup_connection, MESSAGE_TYPE_SETUP_CONNECTION, 0)\n+                .unwrap();\n+        // let setup_connection = Sv2Frame {\n+        //     header: Header {\n+        //         extesion_type: 0,\n+        //         msg_type: 0,\n+        //         msg_length: U24(42),\n+        //     },\n+        //     payload: Some(SetupConnection {\n+        //         protocol: TemplateDistributionProtocol, // 2\n+        //         min_version: 2,\n+        //         max_version: 2,\n+        //         flags: 0,\n+        //         endpoint_host: Owned([48, 46, 48, 46, 48, 46, 48]),\n+        //         endpoint_port: 8081,\n+        //         vendor: Owned([66, 105, 116, 109, 97, 105, 110]),\n+        //         hardware_version: Owned([57, 48, 49]),\n+        //         firmware: Owned([97, 98, 99, 88]),\n+        //         device_id: Owned([56, 57, 53, 54, 55]),\n+        //     }),\n+        //     serialized: None,\n+        // };\n+        let setup_connection = encoder.encode(setup_connection).unwrap();\n+        let expected = [\n+            0, 0, 0, 42, 0, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 7, 48, 46, 48, 46, 48, 46, 48, 145, 31,\n+            7, 66, 105, 116, 109, 97, 105, 110, 3, 57, 48, 49, 4, 97, 98, 99, 88, 5, 56, 57, 53,\n+            54, 55,\n+        ]\n+        .to_vec();\n+        // [0(?), 0 (extension_type), 0 (msg_type), 42 (msg_length), 0 (?), 0 (?), 2 (protocol?), 2 (min_version?),  0 (?), 2 (?), 0 (?), 0 (?), 0 (?), 0 (?), 0 (?), 7 (len), 48 (0), 46(.), 48 (0), 46(.), 48 (0), 46(.), 48 (0), 145 (?), 31 (?), 7 (len),  66 (B), 105 (i), 116 (t), 109 (m), 97 (a), 105(i), 110 (n), 3 (len), 57 (9), 48 (0), 49 (1), 4 (len), 97 (a), 98 (b), 99 (c), 88 (X), 5(len), 56 (8), 57 (9), 53 (5), 54 (6), 55 (7)]\n+        assert_eq!(expected, setup_connection);\n+    }\n+}"
      },
      {
        "sha": "26ee72afc6fcb2ed9bba597c932399031e10941d",
        "filename": "src/rusty/sv2-ffi/sv2.h",
        "status": "added",
        "additions": 386,
        "deletions": 0,
        "changes": 386,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/sv2.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/sv2-ffi/sv2.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/sv2.h?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -0,0 +1,386 @@\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+static const uintptr_t SV2_FRAME_HEADER_SIZE = 6;\n+\n+static const uintptr_t SV2_FRAME_HEADER_LEN_OFFSET = 3;\n+\n+static const uintptr_t SV2_FRAME_HEADER_LEN_END = 3;\n+\n+static const uintptr_t NOISE_FRAME_HEADER_SIZE = 2;\n+\n+static const uintptr_t NOISE_FRAME_HEADER_LEN_OFFSET = 0;\n+\n+static const uintptr_t NOISE_FRAME_HEADER_LEN_END = 2;\n+\n+static const uintptr_t SNOW_PSKLEN = 32;\n+\n+static const uintptr_t SNOW_TAGLEN = 16;\n+\n+static const uint8_t SV2_MINING_PROTOCOL_DISCRIMINANT = 0;\n+\n+static const uint8_t SV2_JOB_NEG_PROTOCOL_DISCRIMINANT = 1;\n+\n+static const uint8_t SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT = 2;\n+\n+static const uint8_t SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT = 3;\n+\n+static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION = 0;\n+\n+static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS = 1;\n+\n+static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION_ERROR = 2;\n+\n+static const uint8_t MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES = 3;\n+\n+static const uint8_t MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE = 70;\n+\n+static const uint8_t MESSAGE_TYPE_NEW_TEMPLATE = 71;\n+\n+static const uint8_t MESSAGE_TYPE_SET_NEW_PREV_HASH = 72;\n+\n+static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA = 73;\n+\n+static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS = 74;\n+\n+static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR = 75;\n+\n+static const uint8_t MESSAGE_TYPE_SUBMIT_SOLUTION = 76;\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+struct CVec {\n+  uint8_t *data;\n+  uintptr_t len;\n+  uintptr_t capacity;\n+};\n+\n+struct U24 {\n+  uint32_t _0;\n+};\n+\n+struct CVec2 {\n+  CVec *data;\n+  uintptr_t len;\n+  uintptr_t capacity;\n+};\n+\n+extern \"C\" {\n+\n+/// Given a C allocated buffer return a rust allocated CVec\n+///\n+/// # Safety\n+///\n+/// TODO\n+CVec cvec_from_buffer(const uint8_t *data, uintptr_t len);\n+\n+void _c_export_u24(U24 _a);\n+\n+void _c_export_cvec(CVec _a);\n+\n+void _c_export_cvec2(CVec2 _a);\n+\n+} // extern \"C\"\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+/// MiningProtocol = [`SV2_MINING_PROTOCOL_DISCRIMINANT`],\n+/// JobNegotiationProtocol = [`SV2_JOB_NEG_PROTOCOL_DISCRIMINANT`],\n+/// TemplateDistributionProtocol = [`SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT`],\n+/// JobDistributionProtocol = [`SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT`],\n+enum class Protocol : uint8_t {\n+  MiningProtocol = SV2_MINING_PROTOCOL_DISCRIMINANT,\n+  JobNegotiationProtocol = SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n+  TemplateDistributionProtocol = SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n+  JobDistributionProtocol = SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT,\n+};\n+\n+/// ## ChannelEndpointChanged (Server -> Client)\n+/// When a channel\u2019s upstream or downstream endpoint changes and that channel had previously\n+/// sent messages with [channel_msg](TODO) bitset of unknown extension_type, the intermediate proxy\n+/// MUST send a [`ChannelEndpointChanged`] message. Upon receipt thereof, any extension state\n+/// (including version negotiation and the presence of support for a given extension) MUST be\n+/// reset and version/presence negotiation must begin again.\n+///\n+struct ChannelEndpointChanged {\n+  /// The channel which has changed endpoint.\n+  uint32_t channel_id;\n+};\n+\n+/// ## SetupConnection.Success (Server -> Client)\n+/// Response to [`SetupConnection`] message if the server accepts the connection. The client is\n+/// required to verify the set of feature flags that the server supports and act accordingly.\n+struct SetupConnectionSuccess {\n+  /// Selected version proposed by the connecting node that the upstream\n+  /// node supports. This version will be used on the connection for the rest\n+  /// of its life.\n+  uint16_t used_version;\n+  /// Flags indicating optional protocol features the server supports. Each\n+  /// protocol from [`Protocol`] field has its own values/flags.\n+  uint32_t flags;\n+};\n+\n+struct CSetupConnection {\n+  Protocol protocol;\n+  uint16_t min_version;\n+  uint16_t max_version;\n+  uint32_t flags;\n+  CVec endpoint_host;\n+  uint16_t endpoint_port;\n+  CVec vendor;\n+  CVec hardware_version;\n+  CVec firmware;\n+  CVec device_id;\n+};\n+\n+struct CSetupConnectionError {\n+  uint32_t flags;\n+  CVec error_code;\n+};\n+\n+extern \"C\" {\n+\n+void _c_export_channel_endpoint_changed(ChannelEndpointChanged _a);\n+\n+void _c_export_setup_conn_succ(SetupConnectionSuccess _a);\n+\n+void free_setup_connection(CSetupConnection s);\n+\n+void free_setup_connection_error(CSetupConnectionError s);\n+\n+} // extern \"C\"\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+/// ## CoinbaseOutputDataSize (Client -> Server)\n+/// Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and\n+/// other uses, and thus the Template Provider will need to consider this additional block size\n+/// when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\n+/// Thus, this message is used to indicate that some additional space in the block/coinbase\n+/// transaction be reserved for the pool\u2019s use (while always assuming the pool will use the entirety\n+/// of available coinbase space).\n+/// The Job Negotiator MUST discover the maximum serialized size of the additional outputs which\n+/// will be added by the pool(s) it intends to use this work. It then MUST communicate the\n+/// maximum such size to the Template Provider via this message. The Template Provider MUST\n+/// NOT provide NewWork messages which would represent consensus-invalid blocks once this\n+/// additional size \u2014 along with a maximally-sized (100 byte) coinbase field \u2014 is added. Further,\n+/// the Template Provider MUST consider the maximum additional bytes required in the output\n+/// count variable-length integer in the coinbase transaction when complying with the size limits.\n+struct CoinbaseOutputDataSize {\n+  /// The maximum additional serialized bytes which the pool will add in\n+  /// coinbase transaction outputs.\n+  uint32_t coinbase_output_max_additional_size;\n+};\n+\n+/// ## RequestTransactionData (Client -> Server)\n+/// A request sent by the Job Negotiator to the Template Provider which requests the set of\n+/// transaction data for all transactions (excluding the coinbase transaction) included in a block, as\n+/// well as any additional data which may be required by the Pool to validate the work.\n+struct RequestTransactionData {\n+  /// The template_id corresponding to a NewTemplate message.\n+  uint64_t template_id;\n+};\n+\n+struct CNewTemplate {\n+  uint64_t template_id;\n+  bool future_template;\n+  uint32_t version;\n+  uint32_t coinbase_tx_version;\n+  CVec coinbase_prefix;\n+  uint32_t coinbase_tx_input_sequence;\n+  uint64_t coinbase_tx_value_remaining;\n+  uint32_t coinbase_tx_outputs_count;\n+  CVec coinbase_tx_outputs;\n+  uint32_t coinbase_tx_locktime;\n+  CVec2 merkle_path;\n+};\n+\n+struct CRequestTransactionDataSuccess {\n+  uint64_t template_id;\n+  CVec excess_data;\n+  CVec2 transaction_list;\n+};\n+\n+struct CRequestTransactionDataError {\n+  uint64_t template_id;\n+  CVec error_code;\n+};\n+\n+struct CSetNewPrevHash {\n+  uint64_t template_id;\n+  CVec prev_hash;\n+  uint32_t header_timestamp;\n+  uint32_t n_bits;\n+  CVec target;\n+};\n+\n+struct CSubmitSolution {\n+  uint64_t template_id;\n+  uint32_t version;\n+  uint32_t header_timestamp;\n+  uint32_t header_nonce;\n+  CVec coinbase_tx;\n+};\n+\n+extern \"C\" {\n+\n+void _c_export_coinbase_out(CoinbaseOutputDataSize _a);\n+\n+void _c_export_req_tx_data(RequestTransactionData _a);\n+\n+void free_new_template(CNewTemplate s);\n+\n+void free_request_tx_data_success(CRequestTransactionDataSuccess s);\n+\n+void free_request_tx_data_error(CRequestTransactionDataError s);\n+\n+void free_set_new_prev_hash(CSetNewPrevHash s);\n+\n+void free_submit_solution(CSubmitSolution s);\n+\n+} // extern \"C\"\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+enum class Sv2Error {\n+  MissingBytes,\n+  EncoderBusy,\n+  Todo,\n+  Unknown,\n+};\n+\n+struct DecoderWrapper;\n+\n+struct EncoderWrapper;\n+\n+struct CSv2Message {\n+  enum class Tag {\n+    CoinbaseOutputDataSize,\n+    NewTemplate,\n+    RequestTransactionData,\n+    RequestTransactionDataError,\n+    RequestTransactionDataSuccess,\n+    SetNewPrevHash,\n+    SubmitSolution,\n+    ChannelEndpointChanged,\n+    SetupConnection,\n+    SetupConnectionError,\n+    SetupConnectionSuccess,\n+  };\n+\n+  struct CoinbaseOutputDataSize_Body {\n+    CoinbaseOutputDataSize _0;\n+  };\n+\n+  struct NewTemplate_Body {\n+    CNewTemplate _0;\n+  };\n+\n+  struct RequestTransactionData_Body {\n+    RequestTransactionData _0;\n+  };\n+\n+  struct RequestTransactionDataError_Body {\n+    CRequestTransactionDataError _0;\n+  };\n+\n+  struct RequestTransactionDataSuccess_Body {\n+    CRequestTransactionDataSuccess _0;\n+  };\n+\n+  struct SetNewPrevHash_Body {\n+    CSetNewPrevHash _0;\n+  };\n+\n+  struct SubmitSolution_Body {\n+    CSubmitSolution _0;\n+  };\n+\n+  struct ChannelEndpointChanged_Body {\n+    ChannelEndpointChanged _0;\n+  };\n+\n+  struct SetupConnection_Body {\n+    CSetupConnection _0;\n+  };\n+\n+  struct SetupConnectionError_Body {\n+    CSetupConnectionError _0;\n+  };\n+\n+  struct SetupConnectionSuccess_Body {\n+    SetupConnectionSuccess _0;\n+  };\n+\n+  Tag tag;\n+  union {\n+    CoinbaseOutputDataSize_Body coinbase_output_data_size;\n+    NewTemplate_Body new_template;\n+    RequestTransactionData_Body request_transaction_data;\n+    RequestTransactionDataError_Body request_transaction_data_error;\n+    RequestTransactionDataSuccess_Body request_transaction_data_success;\n+    SetNewPrevHash_Body set_new_prev_hash;\n+    SubmitSolution_Body submit_solution;\n+    ChannelEndpointChanged_Body channel_endpoint_changed;\n+    SetupConnection_Body setup_connection;\n+    SetupConnectionError_Body setup_connection_error;\n+    SetupConnectionSuccess_Body setup_connection_success;\n+  };\n+};\n+\n+template<typename T, typename E>\n+struct CResult {\n+  enum class Tag {\n+    Ok,\n+    Err,\n+  };\n+\n+  struct Ok_Body {\n+    T _0;\n+  };\n+\n+  struct Err_Body {\n+    E _0;\n+  };\n+\n+  Tag tag;\n+  union {\n+    Ok_Body ok;\n+    Err_Body err;\n+  };\n+};\n+\n+extern \"C\" {\n+\n+void drop_sv2_message(CSv2Message s);\n+\n+bool is_ok(const CResult<CSv2Message, Sv2Error> *cresult);\n+\n+EncoderWrapper *new_encoder();\n+\n+void free_encoder(EncoderWrapper *encoder);\n+\n+CResult<CVec, Sv2Error> encode(CSv2Message *message, EncoderWrapper *encoder);\n+\n+DecoderWrapper *new_decoder();\n+\n+CVec get_writable(DecoderWrapper *decoder);\n+\n+CResult<CSv2Message, Sv2Error> next_frame(DecoderWrapper *decoder);\n+\n+} // extern \"C\""
      }
    ]
  },
  {
    "sha": "fa92ed6a80878d7685012699a4f18b38a40258b3",
    "node_id": "C_kwDOABII59oAKGZhOTJlZDZhODA4NzhkNzY4NTAxMjY5OWE0ZjE4YjM4YTQwMjU4YjM",
    "commit": {
      "author": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-09-21T14:44:55Z"
      },
      "committer": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-09-21T15:45:42Z"
      },
      "message": "Remove cargo dependency",
      "tree": {
        "sha": "c9fd909a412fa55895903079f90a1cbf4c68b555",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c9fd909a412fa55895903079f90a1cbf4c68b555"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa92ed6a80878d7685012699a4f18b38a40258b3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa92ed6a80878d7685012699a4f18b38a40258b3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa92ed6a80878d7685012699a4f18b38a40258b3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa92ed6a80878d7685012699a4f18b38a40258b3/comments",
    "author": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3451106e23c17f9ee36ab7f801aaea85d409595d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3451106e23c17f9ee36ab7f801aaea85d409595d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3451106e23c17f9ee36ab7f801aaea85d409595d"
      }
    ],
    "stats": {
      "total": 787,
      "additions": 177,
      "deletions": 610
    },
    "files": [
      {
        "sha": "01673ea57f70cf9633b94414902cb867b73515d3",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -161,3 +161,5 @@ dist/\n *.background.tiff\n \n /guix-build-*\n+\n+/deps"
      },
      {
        "sha": "b90a46898542b3345875df4e76868068d17496e1",
        "filename": "contrib/guix/guix-build",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/contrib/guix/guix-build",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/contrib/guix/guix-build",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-build?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,9 +1,5 @@\n #!/usr/bin/env bash\n \n-## Package all the rust code this step it likely wont be necessary as the rust code will be already\n-## packehed in a remote src or it will be already avaible as a guix package\n-./src/rusty/build-for-guix.sh\n-\n export LC_ALL=C\n set -e -o pipefail\n "
      },
      {
        "sha": "4387c00c30f58a6ad6a615b9724f97a9d9127b46",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -3,6 +3,13 @@ export LC_ALL=C\n set -e -o pipefail\n export TZ=UTC\n \n+# Build rust library\n+ls /bitcoin/rust-build\n+/bitcoin/rust-build/rust-build-script.sh /bitcoin/src/rusty /bitcoin/rust-build\n+\n+SV2_FFI_LIB=/bitcoin/rust-build\n+SV2_FFI_HEADER=/bitcoin/src/rusty/sv2-ffi/\n+\n # Although Guix _does_ set umask when building its own packages (in our case,\n # this is all packages in manifest.scm), it does not set it for `guix\n # environment`. It does make sense for at least `guix environment --container`\n@@ -89,9 +96,6 @@ case \"$HOST\" in\n         prepend_to_search_env_var OBJCPLUS_INCLUDE_PATH \"${zlib_store_path}/include\"\n esac\n \n-# TODO should use store_path\n-SV2_FFI_DIR=/gnu/store/`ls /gnu/store/ | grep rust-sv2` \n-\n # Set environment variables to point the CROSS toolchain to the right\n # includes/libs for $HOST\n case \"$HOST\" in\n@@ -255,7 +259,7 @@ esac\n \n # CXXFLAGS\n HOST_CXXFLAGS=\"$HOST_CFLAGS\"\n-HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -I ${SV2_FFI_DIR} ${SV2_FFI_DIR}/libsv2_ffi.a -lpthread -ldl\"\n+HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -I ${SV2_FFI_HEADER} ${SV2_FFI_LIB}/libsv2_ffi.a -lpthread -ldl\"\n \n case \"$HOST\" in\n     arm-linux-gnueabihf) HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -Wno-psabi\" ;;"
      },
      {
        "sha": "bc1d5a0daab8a155c378d6b7e79033c436d8074a",
        "filename": "contrib/guix/manifest.scm",
        "status": "modified",
        "additions": 2,
        "deletions": 566,
        "changes": 568,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/contrib/guix/manifest.scm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/contrib/guix/manifest.scm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/manifest.scm?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,559 +1,3 @@\n-;; REDEFINE CARGO WITH THE RIGHT VERSION\n-\n-(use-modules \n-  (guix search-paths)\n-  (guix store)\n-  (guix utils)\n-  (guix derivations)\n-  (guix packages)\n-  (guix build-system)\n-  (guix build-system gnu)\n-  (ice-9 match)\n-  (ice-9 vlist)\n-  (srfi srfi-1)\n-  (srfi srfi-26))\n-\n-(define %crate-base-url\n-  (make-parameter \"https://crates.io\"))\n-(define crate-url\n-  (string-append (%crate-base-url) \"/api/v1/crates/\"))\n-(define crate-url?\n-  (cut string-prefix? crate-url <>))\n-\n-(define (crate-uri name version)\n-  \"Return a URI string for the crate package hosted at crates.io corresponding\n-to NAME and VERSION.\"\n-  (string-append crate-url name \"/\" version \"/download\"))\n-\n-(define (default-rust)\n-  \"Return the default Rust package.\"\n-  ;; Lazily resolve the binding to avoid a circular dependency.\n-  (let ((rust (resolve-interface '(gnu packages rust))))\n-    (module-ref rust 'rust-1.51)))\n-\n-\n-(define %cargo-utils-modules\n-  ;; Build-side modules imported by default.\n-  `((guix build cargo-utils)\n-    ,@%gnu-build-system-modules))\n-\n-(define %cargo-build-system-modules\n-  ;; Build-side modules imported by default.\n-  `((guix build cargo-build-system)\n-    (guix build json)\n-    ,@%cargo-utils-modules))\n-\n-(define* (cargo-build store name inputs\n-                      #:key\n-                      (tests? #t)\n-                      (test-target #f)\n-                      (vendor-dir \"guix-vendor\")\n-                      (cargo-build-flags ''(\"--release\"))\n-                      (cargo-test-flags ''(\"--release\"))\n-                      (cargo-package-flags ''(\"--no-metadata\" \"--no-verify\"))\n-                      (features ''())\n-                      (skip-build? #f)\n-                      (install-source? #t)\n-                      (phases '(@ (guix build cargo-build-system)\n-                                  %standard-phases))\n-                      (outputs '(\"out\"))\n-                      (search-paths '())\n-                      (system (%current-system))\n-                      (guile #f)\n-                      (imported-modules %cargo-build-system-modules)\n-                      (modules '((guix build cargo-build-system)\n-                                 (guix build utils))))\n-  \"Build SOURCE using CARGO, and with INPUTS.\"\n-\n-  (define builder\n-    `(begin\n-       (use-modules ,@modules)\n-       (cargo-build #:name ,name\n-                    #:source ,(match (assoc-ref inputs \"source\")\n-                                (((? derivation? source))\n-                                 (derivation->output-path source))\n-                                ((source)\n-                                 source)\n-                                (source\n-                                 source))\n-                    #:system ,system\n-                    #:test-target ,test-target\n-                    #:vendor-dir ,vendor-dir\n-                    #:cargo-build-flags ,cargo-build-flags\n-                    #:cargo-test-flags ,cargo-test-flags\n-                    #:cargo-package-flags ,cargo-package-flags\n-                    #:features ,features\n-                    #:skip-build? ,skip-build?\n-                    #:install-source? ,install-source?\n-                    #:tests? ,(and tests? (not skip-build?))\n-                    #:phases ,phases\n-                    #:outputs %outputs\n-                    #:search-paths ',(map search-path-specification->sexp\n-                                          search-paths)\n-                    #:inputs %build-inputs)))\n-\n-  (define guile-for-build\n-    (match guile\n-      ((? package?)\n-       (package-derivation store guile system #:graft? #f))\n-      (#f                                         ; the default\n-       (let* ((distro (resolve-interface '(gnu packages commencement)))\n-              (guile  (module-ref distro 'guile-final)))\n-         (package-derivation store guile system #:graft? #f)))))\n-\n-  (build-expression->derivation store name builder\n-                                #:inputs inputs\n-                                #:system system\n-                                #:modules imported-modules\n-                                #:outputs outputs\n-                                #:guile-for-build guile-for-build))\n-\n-(define (package-cargo-inputs p)\n-  (apply\n-    (lambda* (#:key (cargo-inputs '()) #:allow-other-keys)\n-      cargo-inputs)\n-    (package-arguments p)))\n-\n-(define (package-cargo-development-inputs p)\n-  (apply\n-    (lambda* (#:key (cargo-development-inputs '()) #:allow-other-keys)\n-      cargo-development-inputs)\n-    (package-arguments p)))\n-\n-(define (crate-closure inputs)\n-  \"Return the closure of INPUTS when considering the 'cargo-inputs' and\n-'cargod-dev-deps' edges.  Omit duplicate inputs, except for those\n-already present in INPUTS itself.\n-\n-This is implemented as a breadth-first traversal such that INPUTS is\n-preserved, and only duplicate extracted inputs are removed.\n-\n-Forked from ((guix packages) transitive-inputs) since this extraction\n-uses slightly different rules compared to the rest of Guix (i.e. we\n-do not extract the conventional inputs).\"\n-  (define (seen? seen item)\n-    ;; FIXME: We're using pointer identity here, which is extremely sensitive\n-    ;; to memoization in package-producing procedures; see\n-    ;; <https://bugs.gnu.org/30155>.\n-    (vhash-assq item seen))\n-\n-  (let loop ((inputs     inputs)\n-             (result     '())\n-             (propagated '())\n-             (first?     #t)\n-             (seen       vlist-null))\n-    (match inputs\n-      (()\n-       (if (null? propagated)\n-           (reverse result)\n-           (loop (reverse (concatenate propagated)) result '() #f seen)))\n-      (((and input (label (? package? package))) rest ...)\n-       (if (and (not first?) (seen? seen package))\n-           (loop rest result propagated first? seen)\n-           (loop rest\n-                 (cons input result)\n-                 (cons (package-cargo-inputs package)\n-                       propagated)\n-                 first?\n-                 (vhash-consq package package seen))))\n-      ((input rest ...)\n-       (loop rest (cons input result) propagated first? seen)))))\n-\n-(define (expand-crate-sources cargo-inputs cargo-development-inputs)\n-  \"Extract all transitive sources for CARGO-INPUTS and CARGO-DEVELOPMENT-INPUTS\n-along their 'cargo-inputs' edges.\n-\n-Cargo requires all transitive crate dependencies' sources to be available\n-in its index, even if they are optional (this is so it can generate\n-deterministic Cargo.lock files regardless of the target platform or enabled\n-features). Thus we need all transitive crate dependencies for any cargo\n-dev-dependencies, but this is only needed when building/testing a crate directly\n-(i.e. we will never need transitive dev-dependencies for any dependency crates).\n-\n-Another complication arises due potential dependency cycles from Guix's\n-perspective: Although cargo does not permit cyclic dependencies between crates,\n-however, it permits cycles to occur via dev-dependencies. For example, if crate\n-X depends on crate Y, crate Y's tests could pull in crate X to to verify\n-everything builds properly (this is a rare scenario, but it it happens for\n-example with the `proc-macro2` and `quote` crates). This is allowed by cargo\n-because tests are built as a pseudo-crate which happens to depend on the\n-X and Y crates, forming an acyclic graph.\n-\n-We can side step this problem by only considering regular cargo dependencies\n-since they are guaranteed to not have cycles. We can further resolve any\n-potential dev-dependency cycles by extracting package sources (which never have\n-any dependencies and thus no cycles can exist).\n-\n-There are several implications of this decision:\n-* Building a package definition does not require actually building/checking\n-any dependent crates. This can be a benefits:\n- - For example, sometimes a crate may have an optional dependency on some OS\n- specific package which cannot be built or run on the current system. This\n- approach means that the build will not fail if cargo ends up internally ignoring\n- the dependency.\n- - It avoids waiting for quadratic builds from source: cargo always builds\n- dependencies within the current workspace. This is largely due to Rust not\n- having a stable ABI and other resolutions that cargo applies. This means that\n- if we have a depencency chain of X -> Y -> Z and we build each definition\n- independently the following will happen:\n-  * Cargo will build and test crate Z\n-  * Cargo will build crate Z in Y's workspace, then build and test Y\n-  * Cargo will build crates Y and Z in X's workspace, then build and test X\n-* But there are also some downsides with this approach:\n-  - If a dependent crate is subtly broken on the system (i.e. it builds but its\n-  tests fail) the consuming crates may build and test successfully but\n-  actually fail during normal usage (however, the CI will still build all\n-  packages which will give visibility in case packages suddenly break).\n-  - Because crates aren't declared as regular inputs, other Guix facilities\n-  such as tracking package graphs may not work by default (however, this is\n-  something that can always be extended or reworked in the future).\"\n-  (filter-map\n-    (match-lambda\n-      ((label (? package? p))\n-       (list label (package-source p)))\n-      ((label input)\n-       (list label input)))\n-    (crate-closure (append cargo-inputs cargo-development-inputs))))\n-\n-(define* (lower name\n-                #:key source inputs native-inputs outputs system target\n-                (rust (default-rust))\n-                (cargo-inputs '())\n-                (cargo-development-inputs '())\n-                #:allow-other-keys\n-                #:rest arguments)\n-  \"Return a bag for NAME.\"\n-\n-  (define private-keywords\n-    '(#:source #:target #:rust #:inputs #:native-inputs #:outputs\n-      #:cargo-inputs #:cargo-development-inputs))\n-\n-  (and (not target) ;; TODO: support cross-compilation\n-       (bag\n-         (name name)\n-         (system system)\n-         (target target)\n-         (host-inputs `(,@(if source\n-                              `((\"source\" ,source))\n-                              '())\n-                        ,@inputs\n-\n-                        ;; Keep the standard inputs of 'gnu-build-system'\n-                        ,@(standard-packages)))\n-         (build-inputs `((\"cargo\" ,rust \"cargo\")\n-                         (\"rustc\" ,rust)\n-                         ,@(expand-crate-sources cargo-inputs cargo-development-inputs)\n-                         ,@native-inputs))\n-         (outputs outputs)\n-         (build cargo-build)\n-         (arguments (strip-keyword-arguments private-keywords arguments)))))\n-\n-(define cargo-build-system\n-  (build-system\n-    (name 'cargo)\n-    (description\n-     \"Cargo build system, to build Rust crates\")\n-    (lower lower)))\n-\n-;; COMPILE THE RUST PACKEGES\n-\n-(use-modules (gnu)\n-  (guix licenses)\n-  ;(guix build-system cargo2)\n-  (guix build-system copy)\n-  (guix download)\n-  (guix packages)\n-  (gnu packages bash)\n-  (gnu packages crates-io)\n-  (gnu packages rust-apps)\n-  (gnu packages crates-graphics)\n-  (gnu packages documentation)\n-  (gnu packages fontutils)\n-  (gnu packages version-control)\n-  (gnu packages file)\n-  (gnu packages linux)\n-  (gnu packages gawk)\n-  (gnu packages compression)\n-  (gnu packages autotools)\n-  (gnu packages gcc)\n-  (gnu packages pkg-config))\n-\n-\n-\n-(define-public rust-binary_codec_sv2-0.1.1\n-    (package\n-      (name \"rust-binary_codec_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/binary_codec_sv2-0.1.1.crate\")\n-         (sha256\n-          (base32 \"1d9nacfmb6ljp49690q63227l8k87j1h3y9hhb99bw5ispz8idbx\"))))\n-      (build-system cargo-build-system)\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-\n-(define-public rust-derive_codec_sv2-0.1.1\n-    (package\n-      (name \"rust-derive_codec_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/derive_codec_sv2-0.1.1.crate\")\n-         (sha256\n-          (base32 \"0vjy4dv7nvydf6i2nnaiwfvnsfrmkw1vbnmxc75rkp41syp76yqx\"))))\n-      (build-system cargo-build-system)\n-        (arguments\n-         `(\n-           #:cargo-inputs\n-           ((\"binary_codec_sv2\" , rust-binary_codec_sv2-0.1.1)\n-            )))\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-(define-public rust-binary_sv2-0.1.3\n-    (package\n-      (name \"rust-binary_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/binary_sv2-0.1.3.crate\")\n-         (sha256\n-          (base32 \"0nx6y8lsgmq14z9r43vw2paprn3xk1aq81zw1wwkgw9y13q426if\"))))\n-      (build-system cargo-build-system)\n-        (arguments\n-         `(\n-           #:skip-build? #t\n-           #:cargo-inputs\n-           (\n-            (\"binary_codec_sv2\" , rust-binary_codec_sv2-0.1.1)\n-            (\"derive_codec_sv2\" , rust-derive_codec_sv2-0.1.1)\n-            (\"rust-derive_codec_sv2\", rust-derive_codec_sv2-0.1.1 )\n-            )))\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-(define-public rust-const_sv2-0.1.0\n-    (package\n-      (name \"rust-const_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/const_sv2-0.1.0.crate\")\n-         (sha256\n-          (base32 \"1qgr8fpjza8dk7r60nrnaicyazz75w9a99yq34rsv6x8finyrbdi\"))))\n-      (build-system cargo-build-system)\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-(define-public rust-framing_sv2-0.1.3\n-    (package\n-      (name \"rust-framing_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/framing_sv2-0.1.3.crate\")\n-         (sha256\n-          (base32 \"06z8lw10a85cgbx8lw0v6wggddr7w0463vcc05h11rc57cjpbir6\"))))\n-      (build-system cargo-build-system)\n-        (arguments\n-         `(\n-           #:skip-build? #t\n-           #:cargo-inputs\n-           (\n-            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n-            (\"const_sv2\" , rust-const_sv2-0.1.0)\n-            )))\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-(define-public rust-codec_sv2-0.1.3\n-    (package\n-      (name \"rust-codec_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/codec_sv2-0.1.3.crate\")\n-         (sha256\n-          (base32 \"0c10bnpkh96k1m92yjmzxa3qhkpc2wc6kmpgv44v1zfkk016nxyp\"))))\n-      (build-system cargo-build-system)\n-        (arguments\n-         `(\n-           #:skip-build? #t\n-           #:cargo-inputs\n-           (\n-            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n-            (\"const_sv2\" , rust-const_sv2-0.1.0)\n-            (\"framing-sv2\" , rust-framing_sv2-0.1.3)\n-            )))\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-(define-public rust-common_messages_sv2-0.1.3\n-    (package\n-      (name \"rust-common_messages_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/common_messages_sv2-0.1.3.crate\")\n-         (sha256\n-          (base32 \"1wsyy44h3pirrb08brz9gr9g4mshxcpf37i557dxyz79c0gkl3lj\"))))\n-      (build-system cargo-build-system)\n-        (arguments\n-         `(\n-           #:skip-build? #t\n-           #:cargo-inputs\n-           (\n-            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n-            (\"const_sv2\" , rust-const_sv2-0.1.0)\n-            )))\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-(define-public rust-template_distribution_sv2-0.1.3\n-    (package\n-      (name \"rust-template_distribution_sv2\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/template_distribution_sv2-0.1.3.crate\")\n-         (sha256\n-          (base32 \"05dm5si3h09pz05vk7zlg0w0vrkiq5yh9gr043i472rny101x5ki\"))))\n-      (build-system cargo-build-system)\n-        (arguments\n-         `(\n-           #:skip-build? #t\n-           #:cargo-inputs\n-           (\n-            (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n-            (\"const_sv2\" , rust-const_sv2-0.1.0)\n-            )))\n-\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-\n-(define-public rust-sv2_ffi-0.1.3\n-    (package\n-      (name \"rust-sv2_ffi\")\n-      (version \"0.1.0\")\n-      (source\n-       (origin\n-         (method url-fetch)\n-         (uri \"./src/rusty/target/package/sv2_ffi-0.1.3.crate\")\n-         (sha256\n-          (base32 \"01a6lj49hv9flxjqnjk01zza0664gj4mm4hh74wi2jch2mfi1yh5\"))))\n-      (build-system cargo-build-system)\n-      (arguments\n-       `(\n-         #:cargo-inputs\n-         (\n-          (\"binary_sv2\" , rust-binary_sv2-0.1.3)\n-          (\"codec_sv2\" , rust-codec_sv2-0.1.3)\n-          (\"const_sv2\" , rust-const_sv2-0.1.0)\n-          (\"common-messages_sv2\" , rust-common_messages_sv2-0.1.3)\n-          (\"template-distribution_sv2\" , rust-template_distribution_sv2-0.1.3)\n-          )\n-         #:phases\n-         (modify-phases %standard-phases\n-              (replace 'install\n-                (lambda* (#:key inputs outputs skip-build? features install-source? #:allow-other-keys)\n-                  (let* ((out (assoc-ref outputs \"out\")))\n-                    (mkdir-p out)\n-                \n-                    (install-file \"./sv2.h\" out)\n-                    (install-file \"./target/release/libsv2_ffi.a\" out)\n-                  #true)))\n-              )\n-       ))\n-      (home-page \"..\")\n-      (synopsis \"..\")\n-      (description\n-       \"..\")\n-      (license gpl3+))\n-    )\n-\n-;;(packages->manifest\n-;; (append\n-;;  (list ;; The Basics\n-;;        bash\n-;;        which\n-;;        coreutils\n-;;        util-linux\n-;;        ;;; File(system) inspection\n-;;        file\n-;;        grep\n-;;        diffutils\n-;;        findutils\n-;;        ;;; File transformation\n-;;        patch\n-;;        gawk\n-;;        sed\n-;;        ;;; Compression and archiving\n-;;        tar\n-;;        bzip2\n-;;        gzip\n-;;        xz\n-;;        zlib\n-;;        ;;; Build tools\n-;;        gnu-make\n-;;        libtool\n-;;        autoconf\n-;;        automake\n-;;        pkg-config\n-;;        ;rust-sv2_example\n-;;        rust-binary_codec_sv2-0.1.1\n-;;        rust-derive_codec_sv2-0.1.1\n-;;        rust-binary_sv2-0.1.3\n-;;        rust-const_sv2-0.1.0\n-;;        rust-framing_sv2-0.1.3\n-;;        rust-codec_sv2-0.1.3\n-;;        rust-common_messages_sv2-0.1.3\n-;;        rust-template_distribution_sv2-0.1.3\n-;;        rust-sv2_ffi-0.1.3\n-;;        gcc\n-;;  )))\n-\n-;; ######################################3\n (use-modules (gnu)\n              (gnu packages)\n              (gnu packages autotools)\n@@ -586,6 +30,7 @@ any dependent crates. This can be a benefits:\n              (gnu packages shells)\n              (gnu packages tls)\n              (gnu packages version-control)\n+             (gnu packages rust)\n              (guix build-system font)\n              (guix build-system gnu)\n              (guix build-system python)\n@@ -1184,6 +629,7 @@ inspecting signatures in Mach-O binaries.\")\n         automake\n         pkg-config\n         bison\n+        rust-1.51\n         ;; Scripting\n         perl\n         python-3\n@@ -1193,16 +639,6 @@ inspecting signatures in Mach-O binaries.\")\n         lief\n         ;; Native gcc 7 toolchain\n         gcc-toolchain-7\n-        ;; RUST\n-        rust-binary_codec_sv2-0.1.1\n-        rust-derive_codec_sv2-0.1.1\n-        rust-binary_sv2-0.1.3\n-        rust-const_sv2-0.1.0\n-        rust-framing_sv2-0.1.3\n-        rust-codec_sv2-0.1.3\n-        rust-common_messages_sv2-0.1.3\n-        rust-template_distribution_sv2-0.1.3\n-        rust-sv2_ffi-0.1.3\n         (list gcc-toolchain-7 \"static\"))\n   (let ((target (getenv \"HOST\")))\n     (cond ((string-suffix? \"-mingw32\" target)"
      },
      {
        "sha": "8ed8c7570949c119b6bc0079f1798ea96d9bea45",
        "filename": "rust-build/.gitignore",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/rust-build/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/rust-build/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/rust-build/.gitignore?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -0,0 +1,2 @@\n+./deps\n+./libsv2_ffi.a"
      },
      {
        "sha": "35139926113e56e3f4bbd712a7e1f2e7747aced7",
        "filename": "rust-build/rust-build-script.sh",
        "status": "added",
        "additions": 163,
        "deletions": 0,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/rust-build/rust-build-script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/rust-build/rust-build-script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/rust-build/rust-build-script.sh?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -0,0 +1,163 @@\n+#! /bin/sh\n+\n+ROOT=$1\n+OUT_DIR=$2\n+\n+DEPS=\"./deps\"\n+\n+rm -rf $DEPS\n+\n+mkdir $DEPS\n+\n+rustc \\\n+        --crate-name binary_codec_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/binary-sv2/no-serde-sv2/codec/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C embed-bitcode=no \\\n+        -C debug-assertions=off \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS\n+\n+rustc \\\n+        --crate-name binary_codec_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/binary-sv2/no-serde-sv2/codec/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi,artifacts \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS\n+\n+rustc \\\n+        --crate-name const_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/const-sv2/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi,artifacts \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS\n+\n+rustc \\\n+        --crate-name derive_codec_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi \\\n+        --crate-type proc-macro \\\n+        --emit=dep-info,link \\\n+        -C prefer-dynamic \\\n+        -C embed-bitcode=no \\\n+        -C debug-assertions=off \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS \\\n+        --extern binary_codec_sv2=$DEPS/libbinary_codec_sv2.rlib \\\n+        --extern proc_macro\n+\n+rustc \\\n+        --crate-name binary_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/binary-sv2/binary-sv2/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi,artifacts \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --cfg 'feature=\"binary_codec_sv2\"' \\\n+        --cfg 'feature=\"core\"' \\\n+        --cfg 'feature=\"default\"' \\\n+        --cfg 'feature=\"derive_codec_sv2\"' \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS \\\n+        --extern binary_codec_sv2=$DEPS/libbinary_codec_sv2.rmeta \\\n+        --extern derive_codec_sv2=$DEPS/libderive_codec_sv2.so\n+\n+rustc \\\n+        --crate-name framing_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/framing-sv2/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi,artifacts \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS \\\n+        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$DEPS/libconst_sv2.rmeta\n+\n+rustc \\\n+        --crate-name common_messages_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/subprotocols/common-messages/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS \\\n+        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$DEPS/libconst_sv2.rmeta\n+\n+rustc \\\n+        --crate-name template_distribution_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/subprotocols/template-distribution/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS \\\n+        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$DEPS/libconst_sv2.rmeta\n+\n+rustc \\\n+        --crate-name codec_sv2 \\\n+        --edition=2018 \\\n+        $ROOT/codec-sv2/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $DEPS \\\n+        -L dependency=$DEPS \\\n+        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$DEPS/libconst_sv2.rmeta \\\n+        --extern framing_sv2=$DEPS/libframing_sv2.rmeta\n+\n+rustc \\\n+        --crate-name sv2_ffi \\\n+        --edition=2018 \\\n+        $ROOT/sv2-ffi/src/lib.rs \\\n+        --error-format=json \\\n+        --json=diagnostic-rendered-ansi \\\n+        --crate-type staticlib \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $OUT_DIR  \\\n+        -L dependency=$DEPS \\\n+        --extern binary_sv2=$DEPS/libbinary_sv2.rlib \\\n+        --extern codec_sv2=$DEPS/libcodec_sv2.rlib \\\n+        --extern common_messages_sv2=$DEPS/libcommon_messages_sv2.rlib \\\n+        --extern const_sv2=$DEPS/libconst_sv2.rlib \\\n+        --extern template_distribution_sv2=$DEPS/libtemplate_distribution_sv2.rlib\n+"
      },
      {
        "sha": "73d64237b388146d5ca0bef4e292d6afff8e8cff",
        "filename": "src/rusty/build-for-guix.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 36,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/build-for-guix.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3451106e23c17f9ee36ab7f801aaea85d409595d/src/rusty/build-for-guix.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/build-for-guix.sh?ref=3451106e23c17f9ee36ab7f801aaea85d409595d",
        "patch": "@@ -1,36 +0,0 @@\n-#! /bin/sh\n-\n-SCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\"\n-\n-rm -rf ${SCRIPT_DIR}/target\n-mkdir ${SCRIPT_DIR}/target\n-mkdir ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/sv2-ffi/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/sv2-ffi/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/binary-sv2/binary-sv2/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/binary-sv2/binary-sv2/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/codec/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/codec/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml --allow-dirty \n-mv ${SCRIPT_DIR}/binary-sv2/no-serde-sv2/derive_codec/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/framing-sv2/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/framing-sv2/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/const-sv2/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/const-sv2/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/codec-sv2/Cargo.toml --allow-dirty --no-verify\n-mv ${SCRIPT_DIR}/codec-sv2/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/subprotocols/common-messages/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/subprotocols/common-messages/target/package/* ${SCRIPT_DIR}/target/package\n-\n-cargo package --manifest-path ${SCRIPT_DIR}/subprotocols/template-distribution/Cargo.toml --allow-dirty\n-mv ${SCRIPT_DIR}/subprotocols/template-distribution/target/package/* ${SCRIPT_DIR}/target/package\n-\n-"
      }
    ]
  },
  {
    "sha": "c9cab9f17113c876f153ec740a9ac26aec7f06e4",
    "node_id": "C_kwDOABII59oAKGM5Y2FiOWYxNzExM2M4NzZmMTUzZWM3NDBhOWFjMjZhZWM3ZjA2ZTQ",
    "commit": {
      "author": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-09-21T15:10:28Z"
      },
      "committer": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-09-21T15:45:42Z"
      },
      "message": "Remove unneccesary sources",
      "tree": {
        "sha": "921240fe3d269e87b56c27d41e2958b6045b5674",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/921240fe3d269e87b56c27d41e2958b6045b5674"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9cab9f17113c876f153ec740a9ac26aec7f06e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9cab9f17113c876f153ec740a9ac26aec7f06e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c9cab9f17113c876f153ec740a9ac26aec7f06e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9cab9f17113c876f153ec740a9ac26aec7f06e4/comments",
    "author": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa92ed6a80878d7685012699a4f18b38a40258b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa92ed6a80878d7685012699a4f18b38a40258b3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa92ed6a80878d7685012699a4f18b38a40258b3"
      }
    ],
    "stats": {
      "total": 4355,
      "additions": 0,
      "deletions": 4355
    },
    "files": [
      {
        "sha": "4052c9d216a80d9d851dbb8bbabf90c2ace0e882",
        "filename": "src/rusty/binary-sv2/serde-sv2/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/Cargo.toml?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,14 +0,0 @@\n-[package]\n-name = \"serde_sv2\"\n-version = \"0.1.0\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Serlializer and Deserializer for Stratum V2 data format\"\n-license = \"MIT\"\n-\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-serde = { version = \"1.0.89\", features = [\"derive\", \"alloc\"], default-features = false }\n-buffer_sv2 = {version = \"0.1.0\",  path = \"../../../../utils/buffer\"}"
      },
      {
        "sha": "3132feab88a888bc6a2842a2aa7d0a920a0f37ba",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/de.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 969,
        "changes": 969,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/de.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/de.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/de.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,969 +0,0 @@\n-//! Serde deserializer for [stratum v2][Sv2] implemented following [serde tutorial][tutorial]\n-//!\n-//! [Sv2]: https://docs.google.com/document/d/1FadCWj-57dvhxsnFM_7X806qyvhR0u3i85607bGHxvg/edit\n-//! [tutorial]: https://serde.rs/data-format.html\n-use alloc::vec::Vec;\n-use core::convert::TryInto;\n-\n-use serde::de::{self, DeserializeSeed, SeqAccess, Visitor};\n-use serde::Deserialize;\n-\n-use crate::error::{Error, Result};\n-\n-//enum Sv2Seq {\n-//    S64k,\n-//    S255,\n-//}\n-\n-#[derive(Debug)]\n-pub struct Deserializer<'de> {\n-    input: &'de [u8],\n-    len: u8,\n-}\n-\n-impl<'de> Deserializer<'de> {\n-    fn _new(input: &'de mut [u8]) -> Self {\n-        Deserializer { input, len: 0 }\n-    }\n-\n-    pub fn from_bytes(input: &'de mut [u8]) -> Self {\n-        Self::_new(input)\n-    }\n-}\n-\n-pub fn from_bytes<'a, T>(b: &'a mut [u8]) -> Result<T>\n-where\n-    T: Deserialize<'a>,\n-{\n-    let mut deserializer = Deserializer::from_bytes(b);\n-    let t = T::deserialize(&mut deserializer)?;\n-    Ok(t)\n-}\n-\n-impl<'de> Deserializer<'de> {\n-    fn as_vec(&self) -> Vec<u8> {\n-        self.input.to_vec()\n-    }\n-\n-    #[inline]\n-    fn get_slice(&mut self, len: usize) -> Result<&'de [u8]> {\n-        if self.input.len() < len {\n-            return Err(Error::ReadError);\n-        };\n-\n-        let (sl, rem) = &self.input.split_at(len);\n-        self.input = rem;\n-\n-        Ok(sl)\n-    }\n-\n-    #[inline]\n-    fn parse_bytes(&mut self) -> &'de [u8] {\n-        self.input\n-    }\n-\n-    #[inline]\n-    fn parse_seq0255(&mut self, element_size: u8) -> Result<&'de [u8]> {\n-        let len = self.parse_u8()?;\n-        let len = len as usize * element_size as usize;\n-        self.get_slice(len as usize)\n-    }\n-\n-    #[inline]\n-    fn parse_seq064k(&mut self, element_size: u8) -> Result<&'de [u8]> {\n-        let len = self.parse_u16()?;\n-        let len = len as usize * element_size as usize;\n-        self.get_slice(len as usize)\n-    }\n-\n-    #[inline]\n-    fn parse_seq064k_variable(&mut self, element_size: u8) -> Result<&'de [u8]> {\n-        let element_size = element_size as usize;\n-        let len = self.parse_u16()?;\n-        let mut next_element_index: usize = 0;\n-        for _ in 0..len {\n-            let len = &self.input[next_element_index..next_element_index + element_size];\n-            let len = match element_size {\n-                1 => len[0] as u32,\n-                2 => u32::from_le_bytes([len[0], len[1], 0, 0]),\n-                3 => u32::from_le_bytes([len[0], len[1], len[2], 0]),\n-                _ => unreachable!(),\n-            };\n-            next_element_index += len as usize + element_size;\n-        }\n-        self.get_slice(next_element_index)\n-    }\n-\n-    #[inline]\n-    fn parse_bool(&mut self) -> Result<bool> {\n-        let bool_ = self.get_slice(1)?;\n-        match bool_ {\n-            [0] => Ok(false),\n-            [1] => Ok(true),\n-            _ => Err(Error::InvalidBool(bool_[0])),\n-        }\n-    }\n-\n-    #[inline]\n-    fn parse_u8(&mut self) -> Result<u8> {\n-        let u8_ = self.get_slice(1)?;\n-        Ok(u8_[0])\n-    }\n-\n-    #[inline]\n-    fn parse_u16(&mut self) -> Result<u16> {\n-        let u16_ = self.get_slice(2)?;\n-        Ok(u16::from_le_bytes([u16_[0], u16_[1]]))\n-    }\n-\n-    #[inline]\n-    fn parse_u24(&mut self) -> Result<u32> {\n-        let u24 = self.get_slice(3)?;\n-        Ok(u32::from_le_bytes([u24[0], u24[1], u24[2], 0]))\n-    }\n-\n-    #[inline]\n-    fn parse_u32(&mut self) -> Result<u32> {\n-        let u32_ = self.get_slice(4)?;\n-        Ok(u32::from_le_bytes([u32_[0], u32_[1], u32_[2], u32_[3]]))\n-    }\n-\n-    #[inline]\n-    fn parse_f32(&mut self) -> Result<f32> {\n-        let f32_ = self.get_slice(4)?;\n-        Ok(f32::from_le_bytes([f32_[0], f32_[1], f32_[2], f32_[3]]))\n-    }\n-\n-    #[inline]\n-    fn parse_u256(&mut self) -> Result<&'de [u8; 32]> {\n-        // slice is 32 bytes so unwrap never called\n-        let u256: &[u8; 32] = self.get_slice(32)?.try_into().unwrap();\n-        Ok(u256)\n-    }\n-\n-    #[inline]\n-    fn parse_signature(&mut self) -> Result<&'de [u8; 64]> {\n-        // slice is 64 bytes so unwrap never called\n-        let signature: &[u8; 64] = self.get_slice(64)?.try_into().unwrap();\n-        Ok(signature)\n-    }\n-\n-    #[inline]\n-    fn parse_string(&mut self) -> Result<&'de str> {\n-        let len = self.parse_u8()?;\n-        let str_ = self.get_slice(len as usize)?;\n-        core::str::from_utf8(str_).map_err(|_| Error::InvalidUtf8)\n-    }\n-\n-    #[inline]\n-    fn parse_b016m(&mut self) -> Result<&'de [u8]> {\n-        let len = self.parse_u24()?;\n-        self.get_slice(len as usize)\n-    }\n-\n-    #[inline]\n-    fn parse_b064k(&mut self) -> Result<&'de [u8]> {\n-        let len = self.parse_u16()?;\n-        self.get_slice(len as usize)\n-    }\n-\n-    #[inline]\n-    fn parse_b0255(&mut self) -> Result<&'de [u8]> {\n-        let len = self.parse_u8()?;\n-        self.get_slice(len as usize)\n-    }\n-    #[inline]\n-    fn parse_b032(&mut self) -> Result<&'de [u8]> {\n-        let len = self.parse_u8()?;\n-        self.get_slice(len as usize)\n-    }\n-}\n-\n-impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_u8(self.parse_u8()?)\n-    }\n-\n-    #[inline]\n-    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_u16(self.parse_u16()?)\n-    }\n-\n-    #[inline]\n-    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_u32(self.parse_u32()?)\n-    }\n-\n-    #[inline]\n-    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_str(self.parse_string()?)\n-    }\n-\n-    #[inline]\n-    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        self.deserialize_str(visitor)\n-    }\n-\n-    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        self.deserialize_byte_buf(visitor)\n-    }\n-\n-    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_byte_buf(self.as_vec())\n-    }\n-\n-    #[inline]\n-    fn deserialize_struct<V>(\n-        self,\n-        _name: &'static str,\n-        fields: &'static [&'static str],\n-        visitor: V,\n-    ) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_seq(Struct::new(self, fields.len()))\n-    }\n-\n-    // Each Sv2 primitive type is implemented as a new type struct.\n-    fn deserialize_newtype_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        match _name {\n-            \"U24\" => visitor.visit_u32(self.parse_u24()?),\n-            \"U256\" => visitor.visit_borrowed_bytes(self.parse_u256()?),\n-            \"Signature\" => visitor.visit_borrowed_bytes(self.parse_signature()?),\n-            \"B016M\" => visitor.visit_borrowed_bytes(self.parse_b016m()?),\n-            \"B064K\" => visitor.visit_borrowed_bytes(self.parse_b064k()?),\n-            \"B0255\" => visitor.visit_borrowed_bytes(self.parse_b0255()?),\n-            \"B032\" => visitor.visit_borrowed_bytes(self.parse_b032()?),\n-            \"Seq_0255_U256\" => visitor.visit_borrowed_bytes(self.parse_seq0255(32)?),\n-            \"Seq_0255_Bool\" => visitor.visit_borrowed_bytes(self.parse_seq0255(1)?),\n-            \"Seq_0255_U16\" => visitor.visit_borrowed_bytes(self.parse_seq0255(2)?),\n-            \"Seq_0255_U24\" => visitor.visit_borrowed_bytes(self.parse_seq0255(3)?),\n-            \"Seq_0255_U32\" => visitor.visit_borrowed_bytes(self.parse_seq0255(4)?),\n-            \"Seq_0255_Signature\" => visitor.visit_borrowed_bytes(self.parse_seq0255(64)?),\n-            \"Seq_064K_U256\" => visitor.visit_borrowed_bytes(self.parse_seq064k(32)?),\n-            \"Seq_064K_Bool\" => visitor.visit_borrowed_bytes(self.parse_seq064k(1)?),\n-            \"Seq_064K_U16\" => visitor.visit_borrowed_bytes(self.parse_seq064k(2)?),\n-            \"Seq_064K_U24\" => visitor.visit_borrowed_bytes(self.parse_seq064k(3)?),\n-            \"Seq_064K_U32\" => visitor.visit_borrowed_bytes(self.parse_seq064k(4)?),\n-            \"Seq_064K_U64\" => visitor.visit_borrowed_bytes(self.parse_seq064k(8)?),\n-            \"Seq_064K_Signature\" => visitor.visit_borrowed_bytes(self.parse_seq064k(64)?),\n-            \"Seq_064K_B064K\" => visitor.visit_borrowed_bytes(self.parse_seq064k_variable(2)?),\n-            \"Seq_064K_B016M\" => visitor.visit_borrowed_bytes(self.parse_seq064k_variable(3)?),\n-            \"Bytes\" => visitor.visit_borrowed_bytes(self.parse_bytes()),\n-            _ => unreachable!(\"Invalid type\"),\n-            //_ => visitor.visit_newtype_struct(self),\n-        }\n-    }\n-\n-    #[inline]\n-    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_bool(self.parse_bool()?)\n-    }\n-\n-    ///// UNIMPLEMENTED /////\n-\n-    fn deserialize_option<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_unit<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_unit_struct<V>(self, _name: &'static str, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_i8<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_i16<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_i32<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_i64<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_u64<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        visitor.visit_f32(self.parse_f32()?)\n-    }\n-\n-    // Float parsing is stupidly hard.\n-    fn deserialize_f64<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_char<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        todo!()\n-    }\n-\n-    fn deserialize_tuple<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_tuple_struct<V>(\n-        self,\n-        _name: &'static str,\n-        _len: usize,\n-        _visitor: V,\n-    ) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_map<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_enum<V>(\n-        self,\n-        _name: &'static str,\n-        _variants: &'static [&'static str],\n-        _visitor: V,\n-    ) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_identifier<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn deserialize_ignored_any<V>(self, _visitor: V) -> Result<V::Value>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        unimplemented!()\n-    }\n-}\n-\n-struct Seq<'de, 'a> {\n-    de: &'a mut Deserializer<'de>,\n-    len: usize,\n-}\n-\n-//impl<'de, 'a> Seq<'de, 'a> {\n-//    fn new(de: &'a mut Deserializer<'de>, type_: Sv2Seq) -> std::result::Result<Self, Error> {\n-//        let len = match type_ {\n-//            Sv2Seq::S255 => de.parse_u8()? as usize,\n-//            Sv2Seq::S64k => de.parse_u16()? as usize,\n-//        };\n-//        Ok(Self { de, len })\n-//    }\n-//}\n-\n-impl<'de, 'a> SeqAccess<'de> for Seq<'de, 'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n-    where\n-        T: DeserializeSeed<'de>,\n-    {\n-        // Check if there are no more elements.\n-        if self.len == 0 {\n-            return Ok(None);\n-        }\n-\n-        self.len -= 1;\n-\n-        seed.deserialize(&mut *self.de).map(Some)\n-    }\n-}\n-\n-struct Struct<'de, 'a> {\n-    de: &'a mut Deserializer<'de>,\n-    len: usize,\n-}\n-\n-impl<'de, 'a> Struct<'de, 'a> {\n-    fn new(de: &'a mut Deserializer<'de>, len: usize) -> Self {\n-        Self { de, len }\n-    }\n-}\n-\n-impl<'de, 'a> SeqAccess<'de> for Struct<'de, 'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n-    where\n-        T: DeserializeSeed<'de>,\n-    {\n-        // Check if there are no more elements.\n-        if self.len == 0 {\n-            return Ok(None);\n-        }\n-\n-        self.len -= 1;\n-\n-        seed.deserialize(&mut *self.de).map(Some)\n-    }\n-}\n-\n-///// TEST /////\n-\n-#[test]\n-fn test_struct() {\n-    use serde::Serialize;\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test {\n-        a: u32,\n-        b: u8,\n-        c: crate::primitives::U24,\n-    }\n-\n-    let expected = Test {\n-        a: 456,\n-        b: 9,\n-        c: 67_u32.try_into().unwrap(),\n-    };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_b0255() {\n-    use serde::Serialize;\n-\n-    let b0255: crate::primitives::B0255 = (&[6; 3][..]).try_into().unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::B0255<'a>,\n-    }\n-\n-    let expected = Test { a: b0255 };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_u256() {\n-    use serde::Serialize;\n-\n-    let u256: crate::primitives::U256 = (&[6; 32][..]).try_into().unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::U256<'a>,\n-    }\n-\n-    let expected = Test { a: u256 };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_signature() {\n-    use serde::Serialize;\n-\n-    let s: crate::primitives::Signature = (&[6; 64][..]).try_into().unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Signature<'a>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_b016m() {\n-    use serde::Serialize;\n-\n-    let b: crate::primitives::B016M = (&[0; 70000][..]).try_into().unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        b: bool,\n-        #[serde(borrow)]\n-        a: crate::primitives::B016M<'a>,\n-    }\n-\n-    let expected = Test { a: b, b: true };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_b064k() {\n-    use core::convert::TryInto;\n-    use serde::Serialize;\n-\n-    let b: crate::primitives::B064K = (&[1, 2, 9][..])\n-        .try_into()\n-        .expect(\"vector smaller than 64K should not fail\");\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        b: bool,\n-        #[serde(borrow)]\n-        a: crate::primitives::B064K<'a>,\n-    }\n-\n-    let expected = Test { a: b, b: true };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq0255_u256() {\n-    use crate::primitives::Seq0255;\n-    use crate::primitives::U256;\n-    use serde::Serialize;\n-\n-    let u256_1: crate::primitives::U256 = (&[6; 32][..]).try_into().unwrap();\n-    let u256_2: crate::primitives::U256 = (&[5; 32][..]).try_into().unwrap();\n-    let u256_3: crate::primitives::U256 = (&[0; 32][..]).try_into().unwrap();\n-\n-    let val = vec![u256_1, u256_2, u256_3];\n-    let s = Seq0255::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Seq0255<'a, U256<'a>>,\n-    }\n-\n-    let test = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&test).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    let bytes_2 = crate::ser::to_bytes(&deserialized).unwrap();\n-\n-    assert_eq!(bytes, bytes_2);\n-}\n-\n-#[test]\n-fn test_seq0255_bool() {\n-    use crate::primitives::Seq0255;\n-    use serde::Serialize;\n-\n-    let s: crate::primitives::Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Seq0255<'a, bool>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq0255_u16() {\n-    use crate::primitives::Seq0255;\n-    use crate::primitives::U16;\n-    use serde::Serialize;\n-\n-    let s: crate::primitives::Seq0255<U16> = Seq0255::new(vec![10, 43, 89]).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Seq0255<'a, U16>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq0255_u24() {\n-    use crate::primitives::Seq0255;\n-    use crate::primitives::U24;\n-    use serde::Serialize;\n-\n-    let u24_1 = U24(56);\n-    let u24_2 = U24(59);\n-    let u24_3 = U24(70999);\n-\n-    let val = vec![u24_1, u24_2, u24_3];\n-    let s: crate::primitives::Seq0255<U24> = Seq0255::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Seq0255<'a, U24>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq0255_u32() {\n-    use crate::primitives::Seq0255;\n-    use serde::Serialize;\n-\n-    let s: crate::primitives::Seq0255<u32> = Seq0255::new(vec![546, 99999, 87, 32]).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Seq0255<'a, u32>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq0255_signature() {\n-    use crate::primitives::Seq0255;\n-    use crate::primitives::Signature;\n-    use serde::Serialize;\n-\n-    let siganture_1: Signature = (&[88; 64][..]).try_into().unwrap();\n-    let siganture_2: Signature = (&[99; 64][..]).try_into().unwrap();\n-    let siganture_3: Signature = (&[220; 64][..]).try_into().unwrap();\n-\n-    let val = vec![siganture_1, siganture_2, siganture_3];\n-    let s: crate::primitives::Seq0255<Signature> = Seq0255::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: crate::primitives::Seq0255<'a, Signature<'a>>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq064k_u256() {\n-    use crate::primitives::Seq064K;\n-    use crate::primitives::U256;\n-    use serde::Serialize;\n-\n-    let u256_1: crate::primitives::U256 = (&[6; 32][..]).try_into().unwrap();\n-    let u256_2: crate::primitives::U256 = (&[5; 32][..]).try_into().unwrap();\n-    let u256_3: crate::primitives::U256 = (&[0; 32][..]).try_into().unwrap();\n-\n-    let val = vec![u256_1, u256_2, u256_3];\n-    let s = Seq064K::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, U256<'a>>,\n-    }\n-\n-    let test = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&test).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    let bytes_2 = crate::ser::to_bytes(&deserialized).unwrap();\n-\n-    assert_eq!(bytes, bytes_2);\n-}\n-\n-#[test]\n-fn test_seq064k_bool() {\n-    use crate::primitives::Seq064K;\n-    use serde::Serialize;\n-\n-    let s: Seq064K<bool> = Seq064K::new(vec![true, false, true]).unwrap();\n-    let s2: Seq064K<bool> = Seq064K::new(vec![true; 64000]).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, bool>,\n-    }\n-\n-    let expected = Test { a: s };\n-    let expected2 = Test { a: s2 };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let mut bytes2 = crate::ser::to_bytes(&expected2).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-    let deserialized2: Test = from_bytes(&mut bytes2[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-    assert_eq!(deserialized2, expected2);\n-}\n-\n-#[test]\n-fn test_seq064k_u16() {\n-    use crate::primitives::Seq064K;\n-    use crate::primitives::U16;\n-    use serde::Serialize;\n-\n-    let s: Seq064K<U16> = Seq064K::new(vec![10, 43, 89]).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, U16>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq064k_u24() {\n-    use crate::primitives::Seq064K;\n-    use crate::primitives::U24;\n-    use serde::Serialize;\n-\n-    let u24_1 = U24(56);\n-    let u24_2 = U24(59);\n-    let u24_3 = U24(70999);\n-\n-    let val = vec![u24_1, u24_2, u24_3];\n-    let s: Seq064K<U24> = Seq064K::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, U24>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq064k_u32() {\n-    use crate::primitives::Seq064K;\n-    use serde::Serialize;\n-\n-    let s: Seq064K<u32> = Seq064K::new(vec![546, 99999, 87, 32]).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, u32>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq064k_signature() {\n-    use crate::primitives::Seq064K;\n-    use crate::primitives::Signature;\n-    use serde::Serialize;\n-\n-    let siganture_1: Signature = (&[88_u8; 64][..]).try_into().unwrap();\n-    let siganture_2: Signature = (&[99_u8; 64][..]).try_into().unwrap();\n-    let siganture_3: Signature = (&[220_u8; 64][..]).try_into().unwrap();\n-\n-    let val = vec![siganture_1, siganture_2, siganture_3];\n-    let s: Seq064K<Signature> = Seq064K::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, Signature<'a>>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}\n-\n-#[test]\n-fn test_seq064k_b016m() {\n-    use crate::primitives::Seq064K;\n-    use crate::primitives::B016M;\n-    use serde::Serialize;\n-\n-    let bytes_1: B016M = (&[88_u8; 64][..]).try_into().unwrap();\n-    let bytes_2: B016M = (&[99_u8; 64][..]).try_into().unwrap();\n-    let bytes_3: B016M = (&[220_u8; 64][..]).try_into().unwrap();\n-\n-    let val = vec![bytes_1, bytes_2, bytes_3];\n-    let s: Seq064K<B016M> = Seq064K::new(val).unwrap();\n-\n-    #[derive(Deserialize, Serialize, PartialEq, Debug)]\n-    struct Test<'a> {\n-        #[serde(borrow)]\n-        a: Seq064K<'a, B016M<'a>>,\n-    }\n-\n-    let expected = Test { a: s };\n-\n-    let mut bytes = crate::ser::to_bytes(&expected).unwrap();\n-\n-    let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-    assert_eq!(deserialized, expected);\n-}"
      },
      {
        "sha": "78522f60894465937ee5a8b5c6eb180d7b2f2055",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/error.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 62,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/error.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,62 +0,0 @@\n-use alloc::string::String;\n-use core::fmt::{self, Display};\n-\n-use serde::{de, ser};\n-\n-pub type Result<T> = core::result::Result<T, Error>;\n-\n-// TODO provode additional information in the error type:\n-// 1. byte offset into the input\n-// 2. ??\n-#[derive(Clone, Debug, PartialEq)]\n-pub enum Error {\n-    // One or more variants that can be created by data structures through the\n-    // `ser::Error` and `de::Error` traits. For example the Serialize impl for\n-    // Mutex<T> might return an error because the mutex is poisoned, or the\n-    // Deserialize impl for a struct may return an error because a required\n-    // field is missing.\n-    Message(String),\n-\n-    StringLenBiggerThan256,\n-    InvalidUtf8,\n-    LenBiggerThan16M,\n-    LenBiggerThan255,\n-    LenBiggerThan32,\n-    LenBiggerThan64K,\n-    WriteError,\n-    ReadError,\n-    InvalidBoolSize(usize),\n-    InvalidBool(u8),\n-    InvalidU256(usize),\n-    InvalidSignatureSize(usize),\n-    InvalidU16Size(usize),\n-    InvalidU24Size(usize),\n-    InvalidU32Size(usize),\n-    InvalidU64Size(usize),\n-    U24TooBig(u32),\n-}\n-\n-impl ser::Error for Error {\n-    fn custom<T: Display>(msg: T) -> Self {\n-        Error::Message(format!(\"{}\", msg))\n-    }\n-}\n-\n-impl de::Error for Error {\n-    fn custom<T: Display>(msg: T) -> Self {\n-        Error::Message(format!(\"{}\", msg))\n-    }\n-}\n-\n-impl Display for Error {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            Error::Message(msg) => formatter.write_str(msg),\n-            Error::WriteError => formatter.write_str(\"write error\"),\n-            Error::ReadError => formatter.write_str(\"read error\"),\n-            _ => formatter.write_str(\"TODO display not implemented\"),\n-        }\n-    }\n-}\n-\n-// impl core::error::Error for Error {}"
      },
      {
        "sha": "5071614bad7ad81909bece9a47a186b2545300c1",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 92,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/lib.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,92 +0,0 @@\n-//! Serde serializer/deserializer for [stratum v2][Sv2] implemented following [serde tutorial][tutorial]\n-//!\n-//! ```txt\n-//! SERDE    <-> Sv2\n-//! bool     <-> BOOL\n-//! u8       <-> U8\n-//! u16      <-> U16\n-//! U24      <-> U24\n-//! u32      <-> u32\n-//! f32      <-> f32 // todo not in the spec but used\n-//! u64      <-> u64 // TODO not in the spec but used\n-//! U256     <-> U256\n-//! String   <-> STRO_255\n-//! Signature<-> SIGNATURE\n-//! B032     <-> B0_32 // todo not in the spec but used\n-//! B032     <-> STR0_32 // todo not in the spec but used\n-//! B0255    <-> B0_255\n-//! B064K    <-> B0_64K\n-//! B016M    <-> B0_16M\n-//! [u8]     <-> BYTES\n-//! Pubkey   <-> PUBKEY\n-//! Seq0255  <-> SEQ0_255[T]\n-//! Seq064K  <-> SEQ0_64K[T]\n-//! ```\n-//! Serilalizer and Deserializer are implemented using slices in order to reduce copies:\n-//!\n-//! ## Fixed length primitives:\n-//! Each fixed length Sv2 primitive type when deserialized contains a view in the input buffer so\n-//! no copy is needed to deserialize raw bytes.\n-//!\n-//! ## Non fixed legth primitives\n-//! Non fixed lenght primitives can be diveded in strings, byte sequences and general sequences.\n-//!\n-//! ### Strings\n-//! Strings are automatically handled by Serde\n-//!\n-//! ### Generic sequences\n-//! Non byte sequences `SEQ0_255[T]` and  `SEQ0_64K[T]` are implemented as a\n-//! struct that contains two optional field:\n-//! * an optional view in the input buffer\n-//! * an optional slice of T\n-//!\n-//! When the sequence is constructed from a serialized message we just get a view in the input\n-//! buffer and no data is copyed.\n-//!\n-//! When the sequence is constructed from [T] the sequnce can safely point to them without\n-//! transmute.\n-//!\n-//! ### Bytes sequences\n-//! Byte sequences can be limited lenght sequences or unlimited length sequences, the latter are\n-//! automatically handled by Serde.\n-//! Limited lenght byte sequences are not implemented as a specific new type of generic sequences cause:\n-//! * For the rust type system a serialized byte array and a deserialized byte array are the same\n-//!   thing, that is not true for generic sequences.\n-//! * In order to not copy data around generic sequences need to be implemented as struct containing\n-//!   two optional field, a slice of byte and a slice of T.\n-//! * This dicotomy is not needed for byte sequences so they are implemented as specific smaller\n-//! struct.\n-//!\n-//! ## Why not rkyv?\n-//! [rkyv][rkyv1] is a a zero-copy deserialization framework for Rust. I do not know rkyv but it\n-//! seems that the objective of this library could have been readched with less effort and\n-//! [better][rkyv2] using rykv instad then serder.\n-//!\n-//! Btw Serde is like standard for rust code, very safe and stable. The deserialization/serialization\n-//! part will be in the code that need to be added to bitcoin core, so it must use the most safe and\n-//! stable option. That do not exclude that a serialization/deserialization backend can be implemented\n-//! with rykv and then used by the subprotocols crates via a conditional compilation flag!\n-//!\n-//! [Sv2]: https://docs.google.com/document/d/1FadCWj-57dvhxsnFM_7X806qyvhR0u3i85607bGHxvg/edit\n-//! [tutorial]: https://serde.rs/data-format.html\n-//! [rkyv1]: https://docs.rs/rkyv/0.4.3/rkyv\n-//! [rkyv2]: https://davidkoloski.me/blog/rkyv-is-faster-than/\n-\n-#![no_std]\n-\n-#[macro_use]\n-extern crate alloc;\n-\n-mod de;\n-mod error;\n-mod primitives;\n-mod ser;\n-\n-pub use de::{from_bytes, Deserializer};\n-pub use error::{Error, Result};\n-pub use primitives::{\n-    Bool, Bytes, GetSize, Pubkey, Seq0255, Seq064K, Signature, Str0255, B016M, B0255, B032, B064K,\n-    U16, U24, U256, U32, U64, U8,\n-};\n-pub use ser::{to_bytes, to_writer, Serializer};\n-pub type Str032<'a> = B032<'a>;"
      },
      {
        "sha": "7640786df81e6be7eb534b4a3434614bb9bb85d6",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 137,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b016m.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,137 +0,0 @@\n-use crate::error::Error;\n-use crate::primitives::GetSize;\n-use alloc::vec::Vec;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    Owned(Vec<u8>),\n-}\n-\n-impl<'a> Inner<'a> {\n-    #[inline]\n-    pub fn len(&self) -> [u8; 3] {\n-        let l = match self {\n-            Self::Ref(v) => v.len().to_le_bytes(),\n-            Self::Owned(v) => v.len().to_le_bytes(),\n-        };\n-        [l[0], l[1], l[2]]\n-    }\n-\n-    #[inline]\n-    pub fn as_ref(&'a self) -> &'a [u8] {\n-        match self {\n-            Self::Ref(v) => v,\n-            Self::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct B016M<'b>(Inner<'b>);\n-\n-impl<'b> TryFrom<&'b [u8]> for B016M<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=16777215 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-impl<'b> TryFrom<&'b mut [u8]> for B016M<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=16777215 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<Vec<u8>> for B016M<'b> {\n-    type Error = Error;\n-\n-    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=16777215 => Ok(Self(Inner::Owned(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-\n-impl<'b> Serialize for B016M<'b> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        let len = self.0.len();\n-        let inner = self.0.as_ref();\n-\n-        // tuple is: (byte array len, byte array)\n-        let tuple = (len, &inner);\n-\n-        let tuple_len = 2;\n-        let mut seq = serializer.serialize_tuple(tuple_len)?;\n-\n-        seq.serialize_element(&tuple.0)?;\n-        seq.serialize_element(tuple.1)?;\n-        seq.end()\n-    }\n-}\n-\n-struct B016MVisitor;\n-\n-impl<'a> Visitor<'a> for B016MVisitor {\n-    type Value = B016M<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a byte array shorter than 16M\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(B016M(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for B016M<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"B016M\", B016MVisitor)\n-    }\n-}\n-\n-impl<'a> GetSize for B016M<'a> {\n-    fn get_size(&self) -> usize {\n-        match &self.0 {\n-            Inner::Ref(v) => v.len() + 3,\n-            Inner::Owned(v) => v.len() + 3,\n-        }\n-    }\n-}\n-\n-impl<'a> B016M<'a> {\n-    pub fn get_elements_number_in_array(a: &[u8]) -> usize {\n-        let total_len = a.len();\n-        let mut next_element_index: usize = 0;\n-        let mut elements_number: usize = 0;\n-        while next_element_index < total_len {\n-            let len = &a[next_element_index..next_element_index + 3];\n-            let len = u32::from_le_bytes([len[0], len[1], len[2], 0]);\n-            next_element_index += len as usize + 3;\n-            elements_number += 1;\n-        }\n-        elements_number\n-    }\n-}"
      },
      {
        "sha": "c93fd05dc8f22cba70db70fed375947dc39068a7",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 123,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b0255.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,123 +0,0 @@\n-use crate::error::Error;\n-use crate::primitives::GetSize;\n-use alloc::vec::Vec;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    Owned(Vec<u8>),\n-}\n-\n-impl<'a> Inner<'a> {\n-    #[inline]\n-    pub fn len(&self) -> [u8; 1] {\n-        let l = match self {\n-            Self::Ref(v) => v.len().to_le_bytes(),\n-            Self::Owned(v) => v.len().to_le_bytes(),\n-        };\n-        [l[0]]\n-    }\n-\n-    #[inline]\n-    pub fn as_ref(&'a self) -> &'a [u8] {\n-        match self {\n-            Self::Ref(v) => v,\n-            Self::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct B0255<'b>(Inner<'b>);\n-\n-impl<'b> TryFrom<&'b [u8]> for B0255<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=255 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan255),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<&'b mut [u8]> for B0255<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=255 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan255),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<Vec<u8>> for B0255<'b> {\n-    type Error = Error;\n-\n-    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=255 => Ok(Self(Inner::Owned(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-\n-impl<'b> Serialize for B0255<'b> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        let len = self.0.len();\n-        let inner = self.0.as_ref();\n-\n-        // tuple is: (byte array len, byte array)\n-        let tuple = (len, &inner);\n-\n-        let tuple_len = 2;\n-        let mut seq = serializer.serialize_tuple(tuple_len)?;\n-\n-        seq.serialize_element(&tuple.0)?;\n-        seq.serialize_element(tuple.1)?;\n-        seq.end()\n-    }\n-}\n-\n-struct B0255Visitor;\n-\n-impl<'a> Visitor<'a> for B0255Visitor {\n-    type Value = B0255<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a byte array shorter than 255\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(B0255(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for B0255<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"B0255\", B0255Visitor)\n-    }\n-}\n-\n-impl<'a> GetSize for B0255<'a> {\n-    fn get_size(&self) -> usize {\n-        match &self.0 {\n-            Inner::Ref(v) => v.len() + 1,\n-            Inner::Owned(v) => v.len() + 1,\n-        }\n-    }\n-}"
      },
      {
        "sha": "6c2ba5937bf301ce285b4b78c882655f67d96f3b",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 123,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b032.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,123 +0,0 @@\n-use crate::error::Error;\n-use crate::primitives::GetSize;\n-use alloc::vec::Vec;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    Owned(Vec<u8>),\n-}\n-\n-impl<'a> Inner<'a> {\n-    #[inline]\n-    pub fn len(&self) -> [u8; 1] {\n-        let l = match self {\n-            Self::Ref(v) => v.len().to_le_bytes(),\n-            Self::Owned(v) => v.len().to_le_bytes(),\n-        };\n-        [l[0]]\n-    }\n-\n-    #[inline]\n-    pub fn as_ref(&'a self) -> &'a [u8] {\n-        match self {\n-            Self::Ref(v) => v,\n-            Self::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct B032<'b>(Inner<'b>);\n-\n-impl<'b> TryFrom<&'b [u8]> for B032<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=32 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan32),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<&'b mut [u8]> for B032<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=32 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan32),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<Vec<u8>> for B032<'b> {\n-    type Error = Error;\n-\n-    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=32 => Ok(Self(Inner::Owned(v))),\n-            _ => Err(Error::LenBiggerThan32),\n-        }\n-    }\n-}\n-\n-impl<'b> Serialize for B032<'b> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        let len = self.0.len();\n-        let inner = self.0.as_ref();\n-\n-        // tuple is: (byte array len, byte array)\n-        let tuple = (len, &inner);\n-\n-        let tuple_len = 2;\n-        let mut seq = serializer.serialize_tuple(tuple_len)?;\n-\n-        seq.serialize_element(&tuple.0)?;\n-        seq.serialize_element(tuple.1)?;\n-        seq.end()\n-    }\n-}\n-\n-struct B032Visitor;\n-\n-impl<'a> Visitor<'a> for B032Visitor {\n-    type Value = B032<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a byte array shorter than 32\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(B032(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for B032<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"B032\", B032Visitor)\n-    }\n-}\n-\n-impl<'a> GetSize for B032<'a> {\n-    fn get_size(&self) -> usize {\n-        match &self.0 {\n-            Inner::Ref(v) => v.len() + 1,\n-            Inner::Owned(v) => v.len() + 1,\n-        }\n-    }\n-}"
      },
      {
        "sha": "0bccbdc04eff7008a54102d15fca06a7806eb711",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 123,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/b064k.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,123 +0,0 @@\n-use crate::error::Error;\n-use crate::primitives::GetSize;\n-use alloc::vec::Vec;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    Owned(Vec<u8>),\n-}\n-\n-impl<'a> Inner<'a> {\n-    #[inline]\n-    pub fn len(&self) -> [u8; 2] {\n-        let l = match self {\n-            Self::Ref(v) => v.len().to_le_bytes(),\n-            Self::Owned(v) => v.len().to_le_bytes(),\n-        };\n-        [l[0], l[1]]\n-    }\n-\n-    #[inline]\n-    pub fn as_ref(&'a self) -> &'a [u8] {\n-        match self {\n-            Self::Ref(v) => v,\n-            Self::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct B064K<'b>(Inner<'b>);\n-\n-impl<'b> TryFrom<&'b [u8]> for B064K<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=65535 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<&'b mut [u8]> for B064K<'b> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'b mut [u8]) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=65535 => Ok(Self(Inner::Ref(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-\n-impl<'b> TryFrom<Vec<u8>> for B064K<'b> {\n-    type Error = Error;\n-\n-    fn try_from(v: Vec<u8>) -> core::result::Result<Self, Self::Error> {\n-        match v.len() {\n-            0..=65535 => Ok(Self(Inner::Owned(v))),\n-            _ => Err(Error::LenBiggerThan16M),\n-        }\n-    }\n-}\n-\n-impl<'b> Serialize for B064K<'b> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        let len = self.0.len();\n-        let inner = self.0.as_ref();\n-\n-        // tuple is: (byte array len, byte array)\n-        let tuple = (len, &inner);\n-\n-        let tuple_len = 2;\n-        let mut seq = serializer.serialize_tuple(tuple_len)?;\n-\n-        seq.serialize_element(&tuple.0)?;\n-        seq.serialize_element(tuple.1)?;\n-        seq.end()\n-    }\n-}\n-\n-struct B064KVisitor;\n-\n-impl<'a> Visitor<'a> for B064KVisitor {\n-    type Value = B064K<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a byte array shorter than 64K\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(B064K(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for B064K<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"B064K\", B064KVisitor)\n-    }\n-}\n-\n-impl<'a> GetSize for B064K<'a> {\n-    fn get_size(&self) -> usize {\n-        match &self.0 {\n-            Inner::Ref(v) => v.len() + 2,\n-            Inner::Owned(v) => v.len() + 2,\n-        }\n-    }\n-}"
      },
      {
        "sha": "3f911a78c5b50060646c89b643cb6ced638b63e1",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 80,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/bytes.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,80 +0,0 @@\n-use crate::primitives::GetSize;\n-use alloc::vec::Vec;\n-use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    #[allow(dead_code)]\n-    Owned(Vec<u8>),\n-}\n-\n-impl<'a> Inner<'a> {\n-    #[inline]\n-    pub fn as_ref(&'a self) -> &'a [u8] {\n-        match self {\n-            Self::Ref(v) => v,\n-            Self::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct Bytes<'b>(Inner<'b>);\n-\n-impl<'b> From<&'b [u8]> for Bytes<'b> {\n-    #[inline]\n-    fn from(v: &'b [u8]) -> Self {\n-        Self(Inner::Ref(v))\n-    }\n-}\n-impl<'b> From<&'b mut [u8]> for Bytes<'b> {\n-    #[inline]\n-    fn from(v: &'b mut [u8]) -> Self {\n-        Self(Inner::Ref(v))\n-    }\n-}\n-\n-impl<'b> Serialize for Bytes<'b> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        serializer.serialize_bytes(self.0.as_ref())\n-    }\n-}\n-\n-struct BytesVisitor;\n-\n-impl<'a> Visitor<'a> for BytesVisitor {\n-    type Value = Bytes<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a byte array shorter than 64K\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(Bytes(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Bytes<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"Bytes\", BytesVisitor)\n-    }\n-}\n-\n-impl<'a> GetSize for Bytes<'a> {\n-    fn get_size(&self) -> usize {\n-        match &self.0 {\n-            Inner::Ref(v) => v.len(),\n-            Inner::Owned(v) => v.len(),\n-        }\n-    }\n-}"
      },
      {
        "sha": "3db63a58aa72b647b5d274eac7dc7fc92719cbe9",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 59,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/byte_arrays/mod.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,59 +0,0 @@\n-pub mod b016m;\n-pub mod b0255;\n-pub mod b032;\n-pub mod b064k;\n-pub mod bytes;\n-\n-#[test]\n-fn test_b0_64k() {\n-    use crate::ser::to_bytes;\n-    use core::convert::TryInto;\n-\n-    let test: b064k::B064K = (&[1, 2, 9][..])\n-        .try_into()\n-        .expect(\"vector smaller than 64K should not fail\");\n-\n-    let expected = vec![3, 0, 1, 2, 9];\n-    assert_eq!(to_bytes(&test).unwrap(), expected);\n-}\n-\n-#[test]\n-fn test_b0_64k_2() {\n-    use crate::ser::to_bytes;\n-    use core::convert::TryInto;\n-\n-    let test: b064k::B064K = (&[10; 754][..])\n-        .try_into()\n-        .expect(\"vector smaller than 64K should not fail\");\n-\n-    let mut expected = vec![10; 756];\n-    expected[0] = 242;\n-    expected[1] = 2;\n-    assert_eq!(to_bytes(&test).unwrap(), expected);\n-}\n-\n-#[test]\n-fn test_b0_64k_3() {\n-    use crate::error::Error;\n-    use core::convert::TryInto;\n-\n-    let test: Result<b064k::B064K, Error> = (&[10; 70000][..]).try_into();\n-\n-    match test {\n-        Ok(_) => assert!(false, \"vector bigger than 64K should return an error\"),\n-        Err(_) => assert!(true),\n-    }\n-}\n-\n-#[test]\n-fn test_b0_16m() {\n-    use crate::ser::to_bytes;\n-    use core::convert::TryInto;\n-\n-    let test: b016m::B016M = (&[1 as u8, 2, 9][..])\n-        .try_into()\n-        .expect(\"vector smaller than 64K should not fail\");\n-\n-    let expected = vec![3, 0, 0, 1, 2, 9];\n-    assert_eq!(to_bytes(&test).unwrap(), expected);\n-}"
      },
      {
        "sha": "b5dd75505212e12c046e5fd0d0ca6dc03fe02114",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 81,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/mod.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,81 +0,0 @@\n-use alloc::{string::String, vec::Vec};\n-mod byte_arrays;\n-mod sequences;\n-mod signature;\n-mod u24;\n-mod u256;\n-\n-pub use byte_arrays::b016m::B016M;\n-pub use byte_arrays::b0255::B0255;\n-pub use byte_arrays::b032::B032;\n-pub use byte_arrays::b064k::B064K;\n-pub use byte_arrays::bytes::Bytes;\n-pub use sequences::seq0255::Seq0255;\n-pub use sequences::seq064k::Seq064K;\n-\n-pub use signature::Signature;\n-pub use u24::U24;\n-pub use u256::U256;\n-\n-pub type Bool = bool;\n-pub type U8 = u8;\n-pub type U16 = u16;\n-pub type U32 = u32;\n-pub type U64 = u64;\n-pub type Pubkey<'u> = U256<'u>;\n-// TODO rust string are valid UTF-8 Sv2 string (STR0255) are raw bytes. So there are Sv2 string not\n-// representable as Str0255. I suggest to define Sv2 STR0255 as 1 byte len + a valid UTF-8 string.\n-pub type Str0255<'a> = B0255<'a>;\n-\n-pub trait GetSize {\n-    fn get_size(&self) -> usize;\n-}\n-\n-pub trait FixedSize {\n-    const FIXED_SIZE: usize;\n-}\n-\n-impl<T: FixedSize> GetSize for T {\n-    fn get_size(&self) -> usize {\n-        T::FIXED_SIZE\n-    }\n-}\n-\n-impl FixedSize for bool {\n-    const FIXED_SIZE: usize = 1;\n-}\n-\n-impl FixedSize for u8 {\n-    const FIXED_SIZE: usize = 1;\n-}\n-\n-impl FixedSize for u16 {\n-    const FIXED_SIZE: usize = 2;\n-}\n-\n-impl FixedSize for u32 {\n-    const FIXED_SIZE: usize = 4;\n-}\n-\n-impl FixedSize for u64 {\n-    const FIXED_SIZE: usize = 8;\n-}\n-\n-impl GetSize for [u8] {\n-    fn get_size(&self) -> usize {\n-        self.len()\n-    }\n-}\n-\n-impl GetSize for String {\n-    fn get_size(&self) -> usize {\n-        // String is Str0255 1 byte len + x bytes\n-        self.len() + 1\n-    }\n-}\n-\n-impl GetSize for Vec<u8> {\n-    fn get_size(&self) -> usize {\n-        self.len()\n-    }\n-}"
      },
      {
        "sha": "dff6f7270408e2e0fadeeeda6fecf2cf90a2e28a",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 197,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/mod.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,197 +0,0 @@\n-use super::{Signature, B016M, B0255, B064K, U24, U256};\n-use crate::Error;\n-use core::convert::TryInto;\n-use serde::{de::Visitor, Serialize};\n-\n-pub mod seq0255;\n-pub mod seq064k;\n-\n-#[derive(Debug, PartialEq, Clone, Copy)]\n-enum SeqMaxLen {\n-    _1B,\n-    _2B,\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-struct Seq<'s, T: Clone + Serialize + TryFromBSlice<'s>> {\n-    data: &'s [u8],\n-    cursor: usize,\n-    size: u8,\n-    max_len: SeqMaxLen,\n-    _a: core::marker::PhantomData<T>,\n-}\n-\n-struct SeqVisitor<T> {\n-    inner_type_size: u8,\n-    max_len: SeqMaxLen,\n-    _a: core::marker::PhantomData<T>,\n-}\n-\n-impl<'a, T: Clone + Serialize + TryFromBSlice<'a>> Visitor<'a> for SeqVisitor<T> {\n-    type Value = Seq<'a, T>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        let max_len = match self.max_len {\n-            SeqMaxLen::_1B => \"255\",\n-            SeqMaxLen::_2B => \"64K\",\n-        };\n-        formatter.write_str(\n-            format!(\n-                \"an array shorter than {} elements, with elements of {} bytes\",\n-                max_len, self.inner_type_size\n-            )\n-            .as_str(),\n-        )\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(Seq {\n-            data: value,\n-            cursor: 0,\n-            max_len: self.max_len,\n-            size: self.inner_type_size,\n-            _a: core::marker::PhantomData,\n-        })\n-    }\n-}\n-\n-pub trait TryFromBSlice<'a> {\n-    type Error;\n-\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error>\n-    where\n-        Self: core::marker::Sized;\n-}\n-\n-impl<'a> TryFromBSlice<'a> for bool {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        if val.len() != 1 {\n-            return Err(Error::InvalidBoolSize(val.len()));\n-        }\n-        match val[0] {\n-            0 => Ok(false),\n-            1 => Ok(true),\n-            _ => Err(Error::InvalidBool(val[0])),\n-        }\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for u16 {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        if val.len() != 2 {\n-            return Err(Error::InvalidU16Size(val.len()));\n-        }\n-        Ok(u16::from_le_bytes([val[0], val[1]]))\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for U24 {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        if val.len() != 3 {\n-            return Err(Error::InvalidU24Size(val.len()));\n-        }\n-        Ok(U24(u32::from_le_bytes([val[0], val[1], val[2], 0])))\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for u32 {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        if val.len() != 4 {\n-            return Err(Error::InvalidU32Size(val.len()));\n-        }\n-        Ok(u32::from_le_bytes([val[0], val[1], val[2], val[3]]))\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for u64 {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        if val.len() != 8 {\n-            return Err(Error::InvalidU64Size(val.len()));\n-        }\n-        Ok(u64::from_le_bytes([\n-            val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7],\n-        ]))\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for U256<'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        val.try_into()\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for Signature<'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        val.try_into()\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for B016M<'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        val.try_into()\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for B064K<'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        val.try_into()\n-    }\n-}\n-\n-impl<'a> TryFromBSlice<'a> for B0255<'a> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from_slice(val: &'a [u8]) -> Result<Self, Error> {\n-        val.try_into()\n-    }\n-}\n-\n-//impl<'a, T: TryFromBSlice<'a> + Serialize> Iterator for Seq<'a, T> {\n-//    type Item = T;\n-//\n-//    #[inline]\n-//    fn next(&mut self) -> Option<Self::Item> {\n-//        let start = self.cursor;\n-//        self.cursor += self.size as usize;\n-//        let end = self.cursor;\n-//        if end >= self.data.len() {\n-//            None\n-//        } else {\n-//            // The below should be always valid as there is no way to construct invalid sequences\n-//            // TODO check it\n-//            match T::try_from_slice(&self.data[start..end]) {\n-//                Ok(x) => Some(x),\n-//                Err(_) => None,\n-//            }\n-//        }\n-//    }\n-//}"
      },
      {
        "sha": "46f4c5fb58e844b684e461cfbb1b1f483a834284",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 200,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq0255.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,200 +0,0 @@\n-use super::super::{Signature, U24, U256};\n-use super::{Seq, SeqMaxLen, SeqVisitor, TryFromBSlice};\n-use crate::primitives::FixedSize;\n-use crate::primitives::GetSize;\n-use crate::Error;\n-use alloc::vec::Vec;\n-use serde::{ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, Clone)]\n-pub struct Seq0255<'s, T: Serialize + TryFromBSlice<'s> + Clone> {\n-    seq: Option<Seq<'s, T>>,\n-    data: Option<Vec<T>>,\n-}\n-\n-impl<'s, T: Clone + Serialize + TryFromBSlice<'s> + core::cmp::PartialEq> PartialEq\n-    for Seq0255<'s, T>\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        match (&self.seq, &self.data, &other.seq, &other.data) {\n-            (Some(seq1), _, Some(seq2), _) => seq1 == seq2,\n-            (_, Some(data1), _, Some(data2)) => data1 == data2,\n-            _ => crate::ser::to_bytes(&self) == crate::ser::to_bytes(&other),\n-        }\n-    }\n-}\n-\n-impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> Seq0255<'s, T> {\n-    #[inline]\n-    pub fn new(data: Vec<T>) -> Result<Self, Error> {\n-        if data.len() > 255 {\n-            Err(Error::LenBiggerThan255)\n-        } else {\n-            Ok(Seq0255 {\n-                seq: None,\n-                data: Some(data),\n-            })\n-        }\n-    }\n-}\n-\n-impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> From<Seq<'s, T>> for Seq0255<'s, T> {\n-    #[inline]\n-    fn from(val: Seq<'s, T>) -> Self {\n-        Self {\n-            seq: Some(val),\n-            data: None,\n-        }\n-    }\n-}\n-\n-impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> Serialize for Seq0255<'s, T> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        match (&self.seq, &self.data) {\n-            (Some(seq), None) => {\n-                let len = seq.data.len() / seq.size as usize;\n-                let tuple = (len as u8, seq.data);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            (None, Some(data)) => {\n-                let tuple = (data.len() as u8, &data[..]);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, U256<'a>> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_0255_U256\",\n-                SeqVisitor {\n-                    inner_type_size: 32,\n-                    max_len: SeqMaxLen::_1B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, bool> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_0255_Bool\",\n-                SeqVisitor {\n-                    inner_type_size: 1,\n-                    max_len: SeqMaxLen::_1B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, u16> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_0255_U16\",\n-                SeqVisitor {\n-                    inner_type_size: 2,\n-                    max_len: SeqMaxLen::_1B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, U24> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_0255_U24\",\n-                SeqVisitor {\n-                    inner_type_size: 3,\n-                    max_len: SeqMaxLen::_1B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, u32> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_0255_U32\",\n-                SeqVisitor {\n-                    inner_type_size: 4,\n-                    max_len: SeqMaxLen::_1B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq0255<'a, Signature<'a>> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_0255_Signature\",\n-                SeqVisitor {\n-                    inner_type_size: 64,\n-                    max_len: SeqMaxLen::_1B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'a, T: Clone + FixedSize + Serialize + TryFromBSlice<'a>> GetSize for Seq0255<'a, T> {\n-    fn get_size(&self) -> usize {\n-        if self.data.is_some() {\n-            (self.data.as_ref().unwrap().len() * T::FIXED_SIZE) + 1\n-        } else {\n-            self.seq.as_ref().unwrap().data.len() + 1\n-        }\n-    }\n-}"
      },
      {
        "sha": "0e5b2e87808bf9e683dd06245dcf10379dffcf7b",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 343,
        "changes": 343,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/sequences/seq064k.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,343 +0,0 @@\n-use super::super::{Signature, B016M, B064K, U24, U256};\n-use super::{Seq, SeqMaxLen, SeqVisitor, TryFromBSlice};\n-use crate::primitives::FixedSize;\n-use crate::primitives::GetSize;\n-use crate::Error;\n-use alloc::vec::Vec;\n-use serde::{ser, ser::SerializeTuple, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, Clone)]\n-pub struct Seq064K<'s, T: Clone + Serialize + TryFromBSlice<'s>> {\n-    seq: Option<Seq<'s, T>>,\n-    data: Option<Vec<T>>,\n-}\n-\n-impl<'s, T: Clone + FixedSize + Serialize + TryFromBSlice<'s> + core::cmp::PartialEq> PartialEq\n-    for Seq064K<'s, T>\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        match (&self.seq, &self.data, &other.seq, &other.data) {\n-            (Some(seq1), _, Some(seq2), _) => seq1 == seq2,\n-            (_, Some(data1), _, Some(data2)) => data1 == data2,\n-            _ => crate::ser::to_bytes(&self) == crate::ser::to_bytes(&other),\n-        }\n-    }\n-}\n-\n-impl<'s> PartialEq for Seq064K<'s, B016M<'s>> {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (&self.seq, &self.data, &other.seq, &other.data) {\n-            (Some(seq1), _, Some(seq2), _) => seq1 == seq2,\n-            (_, Some(data1), _, Some(data2)) => data1 == data2,\n-            _ => crate::ser::to_bytes(&self) == crate::ser::to_bytes(&other),\n-        }\n-    }\n-}\n-\n-impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> Seq064K<'s, T> {\n-    #[inline]\n-    pub fn new(data: Vec<T>) -> Result<Self, Error> {\n-        if data.len() > 65536 {\n-            Err(Error::LenBiggerThan64K)\n-        } else {\n-            Ok(Seq064K {\n-                seq: None,\n-                data: Some(data),\n-            })\n-        }\n-    }\n-}\n-\n-impl<'s, T: Clone + Serialize + TryFromBSlice<'s>> From<Seq<'s, T>> for Seq064K<'s, T> {\n-    #[inline]\n-    fn from(val: Seq<'s, T>) -> Self {\n-        Self {\n-            seq: Some(val),\n-            data: None,\n-        }\n-    }\n-}\n-\n-impl<'s, T: Clone + FixedSize + Serialize + TryFromBSlice<'s>> Serialize for Seq064K<'s, T> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        match (&self.seq, &self.data) {\n-            (Some(seq), None) => {\n-                let len = seq.data.len() / seq.size as usize;\n-                let tuple = (len as u16, seq.data);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            (None, Some(data)) => {\n-                let tuple = (data.len() as u16, &data[..]);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-impl<'s> Serialize for Seq064K<'s, B064K<'s>> {\n-    // TODO test this function\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        match (&self.seq, &self.data) {\n-            (Some(seq), None) => {\n-                // TODO is len > than u16::MAX should return an error\n-                let len = B016M::get_elements_number_in_array(seq.data);\n-                let tuple = (len as u16, seq.data);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            (None, Some(data)) => {\n-                // TODO is data.len > than u16::MAX should return an error\n-                let tuple = (data.len() as u16, &data[..]);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-impl<'s> Serialize for Seq064K<'s, B016M<'s>> {\n-    // TODO test this function\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        match (&self.seq, &self.data) {\n-            (Some(seq), None) => {\n-                // TODO is len > than u16::MAX should return an error\n-                let len = B016M::get_elements_number_in_array(seq.data);\n-                let tuple = (len as u16, seq.data);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            (None, Some(data)) => {\n-                // TODO is data.len > than u16::MAX should return an error\n-                let tuple = (data.len() as u16, &data[..]);\n-                let mut seq = serializer.serialize_tuple(2)?;\n-                seq.serialize_element(&tuple.0)?;\n-                seq.serialize_element(tuple.1)?;\n-                seq.end()\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, U256<'a>> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_U256\",\n-                SeqVisitor {\n-                    inner_type_size: 32,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, bool> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_Bool\",\n-                SeqVisitor {\n-                    inner_type_size: 1,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, u16> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_U16\",\n-                SeqVisitor {\n-                    inner_type_size: 2,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, U24> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_U24\",\n-                SeqVisitor {\n-                    inner_type_size: 3,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, u32> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_U32\",\n-                SeqVisitor {\n-                    inner_type_size: 4,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, u64> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_U64\",\n-                SeqVisitor {\n-                    inner_type_size: 8,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, Signature<'a>> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_Signature\",\n-                SeqVisitor {\n-                    inner_type_size: 64,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, B064K<'a>> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_B064K\",\n-                SeqVisitor {\n-                    inner_type_size: 2,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Seq064K<'a, B016M<'a>> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer\n-            .deserialize_newtype_struct(\n-                \"Seq_064K_B016M\",\n-                SeqVisitor {\n-                    inner_type_size: 3,\n-                    max_len: SeqMaxLen::_2B,\n-                    _a: core::marker::PhantomData,\n-                },\n-            )\n-            .map(|x| x.into())\n-    }\n-}\n-\n-impl<'a, T: Clone + FixedSize + Serialize + TryFromBSlice<'a>> GetSize for Seq064K<'a, T> {\n-    fn get_size(&self) -> usize {\n-        if self.data.is_some() {\n-            (self.data.as_ref().unwrap().len() * T::FIXED_SIZE) + 2\n-        } else {\n-            self.seq.as_ref().unwrap().data.len() + 2\n-        }\n-    }\n-}\n-\n-impl<'a> GetSize for Seq064K<'a, B016M<'a>> {\n-    fn get_size(&self) -> usize {\n-        if self.data.is_some() {\n-            (self\n-                .data\n-                .as_ref()\n-                .unwrap()\n-                .iter()\n-                .fold(0, |acc, x| acc + x.get_size()))\n-                + 2\n-        } else {\n-            self.seq.as_ref().unwrap().data.len() + 2\n-        }\n-    }\n-}"
      },
      {
        "sha": "46d066312f93be33709cf6578266092fc3a886b6",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 94,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/signature.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,94 +0,0 @@\n-use crate::error::Error;\n-use crate::primitives::FixedSize;\n-use alloc::boxed::Box;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    Owned(Box<[u8; 64]>),\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct Signature<'u>(Inner<'u>);\n-\n-impl<'u> TryFrom<&'u [u8]> for Signature<'u> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'u [u8]) -> core::result::Result<Self, Error> {\n-        if v.len() == 64 {\n-            Ok(Self(Inner::Ref(v)))\n-        } else {\n-            Err(Error::InvalidSignatureSize(v.len()))\n-        }\n-    }\n-}\n-impl<'u> TryFrom<&'u mut [u8]> for Signature<'u> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'u mut [u8]) -> core::result::Result<Self, Error> {\n-        if v.len() == 64 {\n-            Ok(Self(Inner::Ref(v)))\n-        } else {\n-            Err(Error::InvalidSignatureSize(v.len()))\n-        }\n-    }\n-}\n-\n-impl<'u> From<[u8; 64]> for Signature<'u> {\n-    fn from(v: [u8; 64]) -> Self {\n-        Signature(Inner::Owned(Box::new(v)))\n-    }\n-}\n-\n-impl<'u> From<&'u Signature<'u>> for &'u [u8] {\n-    #[inline]\n-    fn from(v: &'u Signature<'u>) -> Self {\n-        match &v.0 {\n-            Inner::Ref(v) => v,\n-            Inner::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-impl<'u> Serialize for Signature<'u> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        serializer.serialize_bytes(self.into())\n-    }\n-}\n-\n-struct SignatureVisitor;\n-\n-impl<'a> Visitor<'a> for SignatureVisitor {\n-    type Value = Signature<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a 64 bytes unsigned le int\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(Signature(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for Signature<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"Signature\", SignatureVisitor)\n-    }\n-}\n-\n-impl<'a> FixedSize for Signature<'a> {\n-    const FIXED_SIZE: usize = 64;\n-}"
      },
      {
        "sha": "971bf86d85bffb0f940d7219258227e72075d04f",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 98,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/u24.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,98 +0,0 @@\n-use crate::primitives::FixedSize;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Copy, Clone)]\n-pub struct U24(pub(crate) u32);\n-\n-impl U24 {\n-    const MAX: u32 = 16777215;\n-}\n-\n-impl From<U24> for u32 {\n-    #[inline]\n-    fn from(v: U24) -> Self {\n-        v.0\n-    }\n-}\n-\n-impl From<&U24> for u32 {\n-    #[inline]\n-    fn from(v: &U24) -> Self {\n-        v.0\n-    }\n-}\n-\n-impl TryFrom<u32> for U24 {\n-    type Error = crate::Error;\n-\n-    fn try_from(v: u32) -> Result<Self, Self::Error> {\n-        match v {\n-            0..=Self::MAX => Ok(Self(v)),\n-            _ => Err(crate::Error::U24TooBig(v)),\n-        }\n-    }\n-}\n-\n-use core::convert::TryInto;\n-\n-impl TryFrom<usize> for U24 {\n-    type Error = crate::Error;\n-\n-    fn try_from(v: usize) -> Result<Self, Self::Error> {\n-        let v: u32 = v\n-            .try_into()\n-            .map_err(|_| crate::Error::U24TooBig(u32::MAX))?;\n-        match v {\n-            0..=Self::MAX => Ok(Self(v)),\n-            _ => Err(crate::Error::U24TooBig(v)),\n-        }\n-    }\n-}\n-\n-impl From<U24> for usize {\n-    fn from(v: U24) -> Self {\n-        v.0 as usize\n-    }\n-}\n-\n-impl Serialize for U24 {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        serializer.serialize_bytes(&self.0.to_le_bytes()[0..=2])\n-    }\n-}\n-\n-struct U24Visitor;\n-\n-impl<'de> Visitor<'de> for U24Visitor {\n-    type Value = U24;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"an integer between 0 and 2^24 3 bytes le\")\n-    }\n-\n-    #[inline]\n-    fn visit_u32<E>(self, value: u32) -> Result<Self::Value, E> {\n-        // This is safe as this struct is deserialized using parse_u24 that can never return a\n-        // value bigger than U24::MAX\n-        Ok(U24(value))\n-    }\n-}\n-\n-impl<'de> Deserialize<'de> for U24 {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"U24\", U24Visitor)\n-    }\n-}\n-\n-impl FixedSize for U24 {\n-    const FIXED_SIZE: usize = 3;\n-}"
      },
      {
        "sha": "0ca09427fa29ffdbe6224094cb6c2315e9247a5c",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 95,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/primitives/u256.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,95 +0,0 @@\n-use crate::error::Error;\n-use crate::primitives::FixedSize;\n-use alloc::boxed::Box;\n-use core::convert::TryFrom;\n-use serde::{de::Visitor, ser, Deserialize, Deserializer, Serialize};\n-\n-#[derive(Debug, PartialEq, Clone)]\n-enum Inner<'a> {\n-    Ref(&'a [u8]),\n-    Owned(Box<[u8; 32]>),\n-}\n-\n-#[derive(Debug, PartialEq, Clone)]\n-pub struct U256<'u>(Inner<'u>);\n-\n-impl<'u> TryFrom<&'u [u8]> for U256<'u> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'u [u8]) -> core::result::Result<Self, Error> {\n-        if v.len() == 32 {\n-            Ok(Self(Inner::Ref(v)))\n-        } else {\n-            Err(Error::InvalidU256(v.len()))\n-        }\n-    }\n-}\n-\n-impl<'u> TryFrom<&'u mut [u8]> for U256<'u> {\n-    type Error = Error;\n-\n-    #[inline]\n-    fn try_from(v: &'u mut [u8]) -> core::result::Result<Self, Error> {\n-        if v.len() == 32 {\n-            Ok(Self(Inner::Ref(v)))\n-        } else {\n-            Err(Error::InvalidU256(v.len()))\n-        }\n-    }\n-}\n-\n-impl<'u> From<[u8; 32]> for U256<'u> {\n-    fn from(v: [u8; 32]) -> Self {\n-        U256(Inner::Owned(Box::new(v)))\n-    }\n-}\n-\n-impl<'u> From<&'u U256<'u>> for &'u [u8] {\n-    #[inline]\n-    fn from(v: &'u U256<'u>) -> Self {\n-        match &v.0 {\n-            Inner::Ref(v) => v,\n-            Inner::Owned(v) => &v[..],\n-        }\n-    }\n-}\n-\n-impl<'u> Serialize for U256<'u> {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>\n-    where\n-        S: ser::Serializer,\n-    {\n-        serializer.serialize_bytes(self.into())\n-    }\n-}\n-\n-struct U256Visitor;\n-\n-impl<'a> Visitor<'a> for U256Visitor {\n-    type Value = U256<'a>;\n-\n-    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        formatter.write_str(\"a 32 bytes unsigned le int\")\n-    }\n-\n-    #[inline]\n-    fn visit_borrowed_bytes<E>(self, value: &'a [u8]) -> Result<Self::Value, E> {\n-        Ok(U256(Inner::Ref(value)))\n-    }\n-}\n-\n-impl<'de: 'a, 'a> Deserialize<'de> for U256<'a> {\n-    #[inline]\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        deserializer.deserialize_newtype_struct(\"U256\", U256Visitor)\n-    }\n-}\n-\n-impl<'a> FixedSize for U256<'a> {\n-    const FIXED_SIZE: usize = 32;\n-}"
      },
      {
        "sha": "b79ed5719f65d4b857ded973bb1bad2be1bea6db",
        "filename": "src/rusty/binary-sv2/serde-sv2/src/ser.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 380,
        "changes": 380,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/ser.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/binary-sv2/serde-sv2/src/ser.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/serde-sv2/src/ser.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,380 +0,0 @@\n-//! Serde serializer for [stratum v2][Sv2] implemented following [serde tutorial][tutorial]\n-//!\n-//! Right now trying to serialize a value that is an invalid Sv2 type will result in a panic so\n-//! error are catched as soon as possible.\n-//!\n-//! [Sv2]: https://docs.google.com/document/d/1FadCWj-57dvhxsnFM_7X806qyvhR0u3i85607bGHxvg/edit\n-//! [tutorial]: https://serde.rs/data-format.html\n-//!\n-use crate::error::{Error, Result};\n-use alloc::vec::Vec;\n-use buffer_sv2::Write;\n-use serde::{ser, Serialize};\n-\n-pub struct Serializer<W: Write> {\n-    output: W,\n-}\n-\n-pub fn to_bytes<T>(value: &T) -> Result<Vec<u8>>\n-where\n-    T: Serialize,\n-{\n-    let output: Vec<u8> = vec![];\n-    let mut serializer = Serializer { output };\n-    value.serialize(&mut serializer)?;\n-    Ok(serializer.output)\n-}\n-\n-pub fn to_writer<T, W: Write>(value: &T, writer: W) -> Result<()>\n-where\n-    T: Serialize,\n-{\n-    let mut serializer = Serializer { output: writer };\n-    value.serialize(&mut serializer)?;\n-    Ok(())\n-}\n-\n-impl<'a, W: Write> ser::Serializer for &'a mut Serializer<W> {\n-    type Ok = ();\n-\n-    type Error = Error;\n-\n-    // Associated types for keeping track of additional state while serializing\n-    // compound data structures like sequences and maps. In this case no\n-    // additional state is required beyond what is already stored in the\n-    // Serializer struct.\n-    type SerializeSeq = Self;\n-    type SerializeTuple = Self;\n-    type SerializeTupleStruct = Self;\n-    type SerializeTupleVariant = Self;\n-    type SerializeMap = Self;\n-    type SerializeStruct = Self;\n-    type SerializeStructVariant = Self;\n-\n-    // TODO check endianess\n-    #[inline]\n-    fn serialize_bool(self, v: bool) -> Result<()> {\n-        match v {\n-            true => self.output.write_all(&[1]).map_err(|_| Error::WriteError)?,\n-            false => self.output.write_all(&[0]).map_err(|_| Error::WriteError)?,\n-        };\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn serialize_u8(self, v: u8) -> Result<()> {\n-        self.output.write_all(&[v]).map_err(|_| Error::WriteError)\n-    }\n-\n-    #[inline]\n-    fn serialize_u16(self, v: u16) -> Result<()> {\n-        self.output\n-            .write_all(&v.to_le_bytes())\n-            .map_err(|_| Error::WriteError)\n-    }\n-\n-    #[inline]\n-    fn serialize_u32(self, v: u32) -> Result<()> {\n-        self.output\n-            .write_all(&v.to_le_bytes())\n-            .map_err(|_| Error::WriteError)\n-    }\n-\n-    // Serialize string to STR0_255\n-    #[inline]\n-    fn serialize_str(self, v: &str) -> Result<()> {\n-        match v.len() {\n-            l @ 0..=255 => {\n-                self.output\n-                    .write_all(&[l as u8])\n-                    .map_err(|_| Error::WriteError)?;\n-            }\n-            _ => return Err(Error::StringLenBiggerThan256),\n-        };\n-        self.output\n-            .write_all(v.as_bytes())\n-            .map_err(|_| Error::WriteError)\n-    }\n-\n-    #[inline]\n-    fn serialize_bytes(self, v: &[u8]) -> Result<()> {\n-        self.output.write_all(v).map_err(|_| Error::WriteError)\n-    }\n-\n-    #[inline]\n-    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        value.serialize(self)\n-    }\n-\n-    // serialize_struct should preserve field order TODO verify it\n-    // https://users.rust-lang.org/t/order-of-fields-in-serde-json-to-string/48928/3?u=fi3\n-    #[inline]\n-    fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {\n-        Ok(self)\n-    }\n-\n-    #[inline]\n-    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {\n-        Ok(self)\n-    }\n-\n-    #[inline]\n-    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {\n-        Ok(self)\n-    }\n-\n-    #[inline]\n-    fn serialize_newtype_variant<T>(\n-        self,\n-        _name: &'static str,\n-        _variant_index: u32,\n-        _variant: &'static str,\n-        value: &T,\n-    ) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        value.serialize(self)\n-    }\n-\n-    ///// UNIMPLEMENTED /////\n-\n-    fn serialize_i8(self, _v: i8) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_i16(self, _v: i16) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_i32(self, _v: i32) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_i64(self, _v: i64) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_u64(self, _v: u64) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_f32(self, v: f32) -> Result<()> {\n-        self.output\n-            .write_all(&v.to_le_bytes())\n-            .map_err(|_| Error::WriteError)\n-    }\n-\n-    fn serialize_f64(self, _v: f64) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_char(self, _v: char) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_none(self) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_some<T>(self, _value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_unit(self) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_unit_variant(\n-        self,\n-        _name: &'static str,\n-        _variant_index: u32,\n-        _variant: &'static str,\n-    ) -> Result<()> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_tuple_struct(\n-        self,\n-        _name: &'static str,\n-        _len: usize,\n-    ) -> Result<Self::SerializeTupleStruct> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_tuple_variant(\n-        self,\n-        _name: &'static str,\n-        _variant_index: u32,\n-        _variant: &'static str,\n-        _len: usize,\n-    ) -> Result<Self::SerializeTupleVariant> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_struct_variant(\n-        self,\n-        _name: &'static str,\n-        _variant_index: u32,\n-        _variant: &'static str,\n-        _len: usize,\n-    ) -> Result<Self::SerializeStructVariant> {\n-        todo!()\n-    }\n-}\n-\n-impl<'a, W: Write> ser::SerializeStruct for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    #[inline]\n-    fn serialize_field<T>(&mut self, _key: &'static str, value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        value.serialize(&mut **self)\n-    }\n-\n-    #[inline]\n-    fn end(self) -> Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, W: Write> ser::SerializeSeq for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    #[inline]\n-    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        value.serialize(&mut **self)\n-    }\n-\n-    #[inline]\n-    fn end(self) -> Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, W: Write> ser::SerializeTuple for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    #[inline]\n-    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        value.serialize(&mut **self)\n-    }\n-\n-    #[inline]\n-    fn end(self) -> Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-///// UNIMPLEMENTED /////\n-\n-impl<'a, W: Write> ser::SerializeTupleStruct for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    fn serialize_field<T>(&mut self, _value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn end(self) -> Result<()> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<'a, W: Write> ser::SerializeTupleVariant for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    fn serialize_field<T>(&mut self, _value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn end(self) -> Result<()> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<'a, W: Write> ser::SerializeMap for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    fn serialize_key<T>(&mut self, _key: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn serialize_value<T>(&mut self, _value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn end(self) -> Result<()> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<'a, W: Write> ser::SerializeStructVariant for &'a mut Serializer<W> {\n-    type Ok = ();\n-    type Error = Error;\n-\n-    fn serialize_field<T>(&mut self, _key: &'static str, _value: &T) -> Result<()>\n-    where\n-        T: ?Sized + Serialize,\n-    {\n-        unimplemented!()\n-    }\n-\n-    fn end(self) -> Result<()> {\n-        unimplemented!()\n-    }\n-}\n-\n-///// TEST /////\n-\n-#[test]\n-fn test_struct() {\n-    #[derive(Serialize)]\n-    struct Test {\n-        a: u32,\n-        b: u8,\n-    }\n-\n-    let test = Test { a: 456, b: 9 };\n-    let expected = vec![200, 1, 0, 0, 9];\n-    assert_eq!(to_bytes(&test).unwrap(), expected);\n-}"
      },
      {
        "sha": "8cd6c81457b94b428098bb7a6f0571e8a07738ff",
        "filename": "src/rusty/codec-sv2/src/decoder.rs",
        "status": "modified",
        "additions": 0,
        "deletions": 146,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/decoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/decoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/decoder.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,161 +1,15 @@\n-#[cfg(feature = \"noise_sv2\")]\n-use binary_sv2::Deserialize;\n-#[cfg(feature = \"noise_sv2\")]\n-use binary_sv2::GetSize;\n use binary_sv2::Serialize;\n use core::marker::PhantomData;\n use framing_sv2::framing2::{EitherFrame, Frame as F_, Sv2Frame};\n-#[cfg(feature = \"noise_sv2\")]\n-use framing_sv2::framing2::{HandShakeFrame, NoiseFrame};\n use framing_sv2::header::Header;\n-#[cfg(feature = \"noise_sv2\")]\n-use framing_sv2::header::NoiseHeader;\n \n use crate::buffer::{Buffer, SlowAndCorrect};\n use crate::error::{Error, Result};\n-#[cfg(feature = \"noise_sv2\")]\n-use crate::{State, TransportMode};\n \n-#[cfg(feature = \"noise_sv2\")]\n-pub type StandardNoiseDecoder<T> = WithNoise<SlowAndCorrect, T>;\n pub type StandardEitherFrame<T> = EitherFrame<T, <SlowAndCorrect as Buffer>::Slice>;\n pub type StandardSv2Frame<T> = Sv2Frame<T, <SlowAndCorrect as Buffer>::Slice>;\n pub type StandardDecoder<T> = WithoutNoise<SlowAndCorrect, T>;\n \n-#[cfg(feature = \"noise_sv2\")]\n-pub struct WithNoise<B: Buffer, T: Serialize + binary_sv2::GetSize> {\n-    frame: PhantomData<T>,\n-    missing_noise_b: usize,\n-    noise_buffer: B,\n-    sv2_buffer: B,\n-    sv2_frame_size: usize,\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl<'a, T: Serialize + GetSize + Deserialize<'a>, B: Buffer> WithNoise<B, T> {\n-    #[inline]\n-    pub fn next_frame(&mut self, state: &mut State) -> Result<EitherFrame<T, B::Slice>> {\n-        let len = self.noise_buffer.len();\n-        let src = self.noise_buffer.get_data_by_ref(len);\n-        let hint = NoiseFrame::size_hint(src) as usize;\n-\n-        match hint {\n-            0 => {\n-                self.missing_noise_b = NoiseHeader::SIZE;\n-                self.decode_noise_frame(state)\n-            }\n-            _ => {\n-                self.missing_noise_b = hint;\n-                Err(Error::MissingBytes(hint))\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn decode_noise_frame(&mut self, state: &mut State) -> Result<EitherFrame<T, B::Slice>> {\n-        match state {\n-            State::Transport(transport_mode) => {\n-                // STRIP THE HEADER FROM THE FRAME AND GET THE ENCRYPTED PAYLOAD\n-                // everything here can not fail as the size has been already checked\n-                let src = self.noise_buffer.get_data_owned().as_mut().to_vec();\n-                let mut noise_frame = NoiseFrame::from_bytes_unchecked(src);\n-                let src = noise_frame.payload();\n-\n-                // DECRYPT THE ENCRYPTED PAYLOAD\n-                let len = TransportMode::size_hint_decrypt(src.len());\n-                let mut decrypted = self.sv2_buffer.get_writable(len);\n-                transport_mode.read(src, &mut decrypted).map_err(|_| ())?;\n-\n-                // IF THE DECODER IS RECEIVING A FRAGMENTED FRAME ADD THE DECRYPTED DATA TO THE\n-                // PARTIAL FRAME AND CHECK IF READY\n-                if self.sv2_frame_size > 0 {\n-                    return Ok(self.handle_fragmented().ok_or(())?);\n-                };\n-\n-                let len = self.sv2_buffer.len();\n-                let src = self.sv2_buffer.get_data_by_ref(len);\n-                let hint = Sv2Frame::<T, B::Slice>::size_hint(src);\n-\n-                // IF HINT IS 0 A COMPLETE SV2 FRAME IS AVAIABLE THIS IS THE HOT PATH AS USUALLY\n-                // THE SIZE OF AN SV2 MESSAGE IS SMALLER THE THE MAX SIZE OF A NOISE FRAME\n-                if hint == 0 {\n-                    let src = self.sv2_buffer.get_data_owned();\n-                    let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n-                    return Ok(frame.into());\n-                }\n-\n-                // IF HINT IS NOT 0 AND MISSING BYTES IS 0 IT MEAN THAT THE FIRST FRAGMENT OF AN\n-                // SV2 HAS BEEN RECEIVED\n-                self.handle_fragmented().ok_or(())?;\n-                Err(Error::MissingBytes(self.missing_noise_b))\n-            }\n-            State::HandShake(_) => Ok(self.while_handshaking()),\n-            State::NotInitialized => Ok(self.while_handshaking()),\n-        }\n-    }\n-\n-    #[inline(never)]\n-    fn handle_fragmented(&mut self) -> Option<EitherFrame<T, B::Slice>> {\n-        // IF IS NOT THE FIRST FRAGMENT CHECK IF A COMPLETE FRAME IS AVAIBLE IF YES RETURN THE\n-        // FRAME IF NOT SET MISSING NOISE BYTES TO NOISE HEADER SIZE SO THE DECODER CAN START TO\n-        // DECODE THE NEXT NOISE FRAME\n-        let len = self.sv2_buffer.len();\n-        let src = self.sv2_buffer.get_data_by_ref(len);\n-        let hint = Sv2Frame::<T, B::Slice>::size_hint(src);\n-        if self.sv2_frame_size != 0 {\n-            if hint == 0 {\n-                let src = self.sv2_buffer.get_data_owned();\n-                let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n-                Some(frame.into())\n-            } else {\n-                self.missing_noise_b = NoiseHeader::SIZE;\n-                None\n-            }\n-\n-        // IF IS THE FIRST FRAGMETN JUST SET THE MISSING SV2 AND NOISE BYTES\n-        } else {\n-            self.sv2_frame_size = hint as usize;\n-            self.missing_noise_b = NoiseHeader::SIZE;\n-\n-            None\n-        }\n-    }\n-\n-    fn while_handshaking(&mut self) -> EitherFrame<T, B::Slice> {\n-        let src = self.noise_buffer.get_data_owned().as_mut().to_vec();\n-\n-        // below is inffalible as noise frame lenght has been already checked\n-        let frame = HandShakeFrame::from_bytes_unchecked(src);\n-\n-        frame.into()\n-    }\n-\n-    #[inline]\n-    pub fn writable(&mut self) -> &mut [u8] {\n-        self.noise_buffer.get_writable(self.missing_noise_b)\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl<T: Serialize + binary_sv2::GetSize> WithNoise<SlowAndCorrect, T> {\n-    pub fn new() -> Self {\n-        Self {\n-            frame: PhantomData,\n-            missing_noise_b: 0,\n-            noise_buffer: SlowAndCorrect::new(),\n-            sv2_buffer: SlowAndCorrect::new(),\n-            sv2_frame_size: 0,\n-        }\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl<T: Serialize + binary_sv2::GetSize> Default for WithNoise<SlowAndCorrect, T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct WithoutNoise<B: Buffer, T: Serialize + binary_sv2::GetSize> {\n     frame: PhantomData<T>,"
      },
      {
        "sha": "73b1665f5579539cd3fa8b47b098db02ffebeeea",
        "filename": "src/rusty/codec-sv2/src/encoder.rs",
        "status": "modified",
        "additions": 0,
        "deletions": 160,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/encoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/encoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/encoder.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,169 +1,9 @@\n use alloc::vec::Vec;\n use binary_sv2::GetSize;\n use binary_sv2::Serialize;\n-#[cfg(feature = \"noise_sv2\")]\n-use core::cmp::min;\n-#[cfg(feature = \"noise_sv2\")]\n-use core::convert::TryInto;\n use core::marker::PhantomData;\n-#[cfg(feature = \"noise_sv2\")]\n-use framing_sv2::framing2::{build_noise_frame_header, EitherFrame, HandShakeFrame};\n use framing_sv2::framing2::{Frame as F_, Sv2Frame};\n-#[cfg(feature = \"noise_sv2\")]\n-use framing_sv2::header::NoiseHeader;\n \n-#[cfg(feature = \"noise_sv2\")]\n-use crate::{State, TransportMode};\n-\n-#[cfg(feature = \"noise_sv2\")]\n-const TAGLEN: usize = const_sv2::SNOW_TAGLEN;\n-#[cfg(feature = \"noise_sv2\")]\n-const MAX_M_L: usize = const_sv2::NOISE_FRAME_MAX_SIZE;\n-#[cfg(feature = \"noise_sv2\")]\n-const M: usize = MAX_M_L - TAGLEN;\n-\n-#[cfg(feature = \"noise_sv2\")]\n-pub struct NoiseEncoder<T: Serialize + binary_sv2::GetSize> {\n-    noise_buffer: Vec<u8>,\n-    sv2_buffer: Vec<u8>,\n-    frame: PhantomData<T>,\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl<T: Serialize + GetSize> NoiseEncoder<T> {\n-    #[inline]\n-    pub fn encode(\n-        &mut self,\n-        item: EitherFrame<T, Vec<u8>>,\n-        state: &mut State,\n-    ) -> Result<&[u8], crate::Error> {\n-        match state {\n-            State::Transport(transport_mode) => {\n-                let len = item.encoded_length();\n-                self.sv2_buffer.resize(len, 0);\n-\n-                // ENCODE THE SV2 FRAME\n-                let i: Sv2Frame<T, Vec<u8>> = item.try_into().map_err(|_| ())?;\n-                i.serialize(&mut self.sv2_buffer).map_err(|_| ())?;\n-\n-                // IF THE MESSAGE FIT INTO A NOISE FRAME ENCODE IT HOT PATH\n-                if len <= M {\n-                    self.encode_single_frame(transport_mode)?;\n-\n-                // IF LEN IS BIGGER THAN NOISE PAYLOAD MAX SIZE MESSAGE IS ENCODED AS SEVERAL NOISE\n-                // MESSAGES COLD PATH\n-                } else {\n-                    self.encode_multiple_frame(transport_mode)?;\n-                }\n-            }\n-            State::HandShake(_) => self.while_handshaking(item)?,\n-            State::NotInitialized => self.while_handshaking(item)?,\n-        };\n-\n-        Ok(&self.noise_buffer[..])\n-    }\n-\n-    #[inline(always)]\n-    fn encode_single_frame(&mut self, transport_mode: &mut TransportMode) -> Result<(), ()> {\n-        // RESERVE ENAUGH SPACE TO ENCODE THE NOISE MESSAGE\n-        let len = TransportMode::size_hint_encrypt(self.sv2_buffer[..].len());\n-        let len_with_header = len + NoiseHeader::SIZE;\n-\n-        let to_reserve = if self.noise_buffer.len() > len_with_header {\n-            0\n-        } else {\n-            len_with_header - self.noise_buffer.len()\n-        };\n-        self.noise_buffer.reserve(to_reserve);\n-        self.noise_buffer.clear();\n-\n-        // PREPEND THE NOISE FRAME HEADER\n-        build_noise_frame_header(&mut self.noise_buffer, len as u16);\n-\n-        // RESIZE THE BUFFER SO TRANSPORT MODE CAN WRITE IN IT\n-        self.noise_buffer.resize(len_with_header, 0);\n-\n-        // ENCRYPT THE SV2 FRAME AND ENCODE THE NOISE FRAME\n-        transport_mode\n-            .write(\n-                &self.sv2_buffer[..],\n-                &mut self.noise_buffer[NoiseHeader::SIZE..],\n-            )\n-            .map_err(|_| ())\n-    }\n-\n-    #[inline(never)]\n-    fn encode_multiple_frame(&mut self, transport_mode: &mut TransportMode) -> Result<(), ()> {\n-        self.noise_buffer.clear();\n-\n-        let buffer_len: usize = self.sv2_buffer.len();\n-        let mut start: usize = 0;\n-        let mut end: usize = M;\n-\n-        loop {\n-            let last_len = self.noise_buffer.len();\n-\n-            end = min(end, buffer_len);\n-\n-            let buf = &self.sv2_buffer[start..end];\n-\n-            // PREPEND THE NOISE FRAME HEADER\n-            let len = TransportMode::size_hint_encrypt(buf.len());\n-            build_noise_frame_header(&mut self.noise_buffer, len as u16);\n-\n-            // RESIZE THE BUFFER SO TRANSPORT MODE CAN WRITE IN IT\n-            self.noise_buffer.resize(self.noise_buffer.len() + len, 0);\n-\n-            // ENCRYPT THE SV2 FRAGMENT\n-            transport_mode\n-                .write(\n-                    buf,\n-                    &mut self.noise_buffer\n-                        [last_len + NoiseHeader::SIZE..last_len + NoiseHeader::SIZE + len],\n-                )\n-                .map_err(|_| ())?;\n-\n-            if end == buffer_len {\n-                break;\n-            }\n-\n-            start += end;\n-            end += end;\n-        }\n-        Ok(())\n-    }\n-\n-    #[inline(never)]\n-    fn while_handshaking(&mut self, item: EitherFrame<T, Vec<u8>>) -> Result<(), ()> {\n-        // ENCODE THE SV2 FRAME\n-        let i: HandShakeFrame = item.try_into().map_err(|_| ())?;\n-        i.serialize(&mut self.sv2_buffer).map_err(|_| ())?;\n-\n-        self.noise_buffer.clear();\n-        self.noise_buffer.extend_from_slice(&self.sv2_buffer[..]);\n-\n-        Ok(())\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl<T: Serialize + binary_sv2::GetSize> NoiseEncoder<T> {\n-    pub fn new() -> Self {\n-        Self {\n-            // TODO which capacity??\n-            sv2_buffer: Vec::with_capacity(512),\n-            noise_buffer: Vec::with_capacity(512),\n-            frame: core::marker::PhantomData,\n-        }\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl<T: Serialize + GetSize> Default for NoiseEncoder<T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n \n #[derive(Debug)]\n pub struct Encoder<T> {"
      },
      {
        "sha": "2e689b515d0f3c110878c784ebd1c4bda2d7f013",
        "filename": "src/rusty/codec-sv2/src/error.rs",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/error.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -6,13 +6,6 @@ pub enum Error {\n \n pub type Result<T> = core::result::Result<T, Error>;\n \n-//#[cfg(not(feature = \"no_std\"))]\n-//impl From<std::io::Error> for Error {\n-//    fn from(_: core::io::Error) -> Self {\n-//        todo!()\n-//    }\n-//}\n-\n impl From<()> for Error {\n     fn from(_: ()) -> Self {\n         Error::Todo"
      },
      {
        "sha": "03e6c69153c5bd65ec0a92b1cade39042964e8f3",
        "filename": "src/rusty/codec-sv2/src/lib.rs",
        "status": "modified",
        "additions": 0,
        "deletions": 137,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -2,9 +2,6 @@\n \n extern crate alloc;\n \n-#[cfg(feature = \"noise_sv2\")]\n-use alloc::{boxed::Box, vec::Vec};\n-\n mod buffer;\n mod decoder;\n mod encoder;\n@@ -16,141 +13,7 @@ pub use decoder::StandardEitherFrame;\n pub use decoder::StandardSv2Frame;\n \n pub use decoder::StandardDecoder;\n-#[cfg(feature = \"noise_sv2\")]\n-pub use decoder::StandardNoiseDecoder;\n \n pub use encoder::Encoder;\n-#[cfg(feature = \"noise_sv2\")]\n-pub use encoder::NoiseEncoder;\n \n pub use framing_sv2::framing2::{Frame, Sv2Frame};\n-#[cfg(feature = \"noise_sv2\")]\n-pub use framing_sv2::framing2::{HandShakeFrame, NoiseFrame};\n-\n-#[cfg(feature = \"noise_sv2\")]\n-pub use noise_sv2::{self, handshake::Step, Initiator, Responder, TransportMode};\n-\n-#[cfg(feature = \"noise_sv2\")]\n-#[derive(Debug)]\n-pub enum State {\n-    /// Not yet initialized\n-    NotInitialized,\n-    /// Handshake mode where codec is negotiating keys\n-    HandShake(Box<HandshakeRole>),\n-    /// Transport mode where AEAD is fully operational. The `TransportMode` object in this variant\n-    /// as able to perform encryption and decryption resp.\n-    Transport(TransportMode),\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-#[derive(Debug)]\n-pub enum HandshakeRole {\n-    Initiator(noise_sv2::Initiator),\n-    Responder(noise_sv2::Responder),\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl HandshakeRole {\n-    pub fn step(&mut self, in_msg: Option<Vec<u8>>) -> Result<HandShakeFrame, crate::Error> {\n-        match self {\n-            Self::Initiator(stepper) => {\n-                let message = stepper.step(in_msg).map_err(|_| ())?.inner();\n-                Ok(HandShakeFrame::from_message(message, 0, 0).ok_or(())?)\n-            }\n-\n-            Self::Responder(stepper) => {\n-                let message = stepper.step(in_msg).map_err(|_| ())?.inner();\n-                Ok(HandShakeFrame::from_message(message, 0, 0).ok_or(())?)\n-            }\n-        }\n-    }\n-\n-    pub fn into_transport(self) -> Result<TransportMode, crate::Error> {\n-        match self {\n-            Self::Initiator(stepper) => {\n-                let tp = stepper\n-                    .into_handshake_state()\n-                    .into_transport_mode()\n-                    .map_err(|_| ())?;\n-                Ok(TransportMode::new(tp))\n-            }\n-\n-            Self::Responder(stepper) => {\n-                let tp = stepper\n-                    .into_handshake_state()\n-                    .into_transport_mode()\n-                    .map_err(|_| ())?;\n-                Ok(TransportMode::new(tp))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl State {\n-    #[inline(always)]\n-    pub fn is_in_transport_mode(&self) -> bool {\n-        match self {\n-            Self::NotInitialized => false,\n-            Self::HandShake(_) => false,\n-            Self::Transport(_) => true,\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn is_not_initialized(&self) -> bool {\n-        match self {\n-            Self::NotInitialized => true,\n-            Self::HandShake(_) => false,\n-            Self::Transport(_) => false,\n-        }\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl State {\n-    pub fn take(&mut self) -> Self {\n-        let mut new_me = Self::NotInitialized;\n-        core::mem::swap(&mut new_me, self);\n-        new_me\n-    }\n-\n-    pub fn new() -> Self {\n-        Self::NotInitialized\n-    }\n-\n-    pub fn initialize(inner: HandshakeRole) -> Self {\n-        Self::HandShake(Box::new(inner))\n-    }\n-\n-    pub fn with_transport_mode(tm: TransportMode) -> Self {\n-        Self::Transport(tm)\n-    }\n-\n-    pub fn step(&mut self, in_msg: Option<Vec<u8>>) -> Result<HandShakeFrame, crate::Error> {\n-        match self {\n-            Self::NotInitialized => Err(Error::Todo),\n-            Self::HandShake(stepper) => stepper.step(in_msg),\n-            Self::Transport(_) => Err(Error::Todo),\n-        }\n-    }\n-\n-    pub fn into_transport_mode(self) -> Result<Self, Error> {\n-        match self {\n-            Self::NotInitialized => Err(Error::Todo),\n-            Self::HandShake(stepper) => {\n-                let tp = stepper.into_transport()?;\n-\n-                Ok(Self::with_transport_mode(tp))\n-            }\n-            Self::Transport(_) => Ok(self),\n-        }\n-    }\n-}\n-\n-#[cfg(feature = \"noise_sv2\")]\n-impl Default for State {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}"
      },
      {
        "sha": "d2a2f365df5d06b32b408c735037ed948f48a200",
        "filename": "src/rusty/sv2-ffi/src/lib.rs",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -121,21 +121,15 @@ impl<'a> CSv2Message {\n     #[cfg(not(feature = \"with_serde\"))]\n     pub fn to_rust_rep_mut(&'a mut self) -> Result<Sv2Message<'a>, Error> {\n         match self {\n-            //CSv2Message::CoinbaseOutputDataSize(v) => {Ok(Sv2Message::CoinbaseOutputDataSize(*v))}\n             CSv2Message::NewTemplate(v) => Ok(Sv2Message::NewTemplate(v.to_rust_rep_mut()?)),\n-            //CSv2Message::RequestTransactionData(v) => {Ok(Sv2Message::RequestTransactionData(*v))}\n-            //CSv2Message::RequestTransactionDataError(mut v) => {Ok(Sv2Message::RequestTransactionDataError(v.to_rust_rep_mut()?))}\n-            //CSv2Message::RequestTransactionDataSuccess(mut v) => {Ok(Sv2Message::RequestTransactionDataSuccess(v.to_rust_rep_mut()?))}\n             CSv2Message::SetNewPrevHash(v) => Ok(Sv2Message::SetNewPrevHash(v.to_rust_rep_mut()?)),\n             CSv2Message::SubmitSolution(v) => Ok(Sv2Message::SubmitSolution(v.to_rust_rep_mut()?)),\n-            //CSv2Message::ChannelEndpointChanged(v) => {Ok(Sv2Message::ChannelEndpointChanged(*v))}\n             CSv2Message::SetupConnection(v) => {\n                 Ok(Sv2Message::SetupConnection(v.to_rust_rep_mut()?))\n             }\n             CSv2Message::SetupConnectionError(v) => {\n                 Ok(Sv2Message::SetupConnectionError(v.to_rust_rep_mut()?))\n             }\n-            //CSv2Message::SetupConnectionSuccess(v) => {Ok(Sv2Message::SetupConnectionSuccess(*v))}\n             _ => todo!(),\n         }\n     }"
      },
      {
        "sha": "bdb4ac3dade628ea43559b24526ad311140ae653",
        "filename": "src/rusty/sv2-ffi/src/lib__.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 629,
        "changes": 629,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/sv2-ffi/src/lib__.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa92ed6a80878d7685012699a4f18b38a40258b3/src/rusty/sv2-ffi/src/lib__.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/src/lib__.rs?ref=fa92ed6a80878d7685012699a4f18b38a40258b3",
        "patch": "@@ -1,629 +0,0 @@\n-use codec_sv2::{Encoder, Frame, StandardDecoder, StandardSv2Frame};\n-use common_messages_sv2::{\n-    CSetupConnection, CSetupConnectionError, ChannelEndpointChanged, SetupConnection,\n-    SetupConnectionError, SetupConnectionSuccess,\n-};\n-use template_distribution_sv2::{\n-    CNewTemplate, CRequestTransactionDataError, CRequestTransactionDataSuccess, CSetNewPrevHash,\n-    CSubmitSolution, CoinbaseOutputDataSize, NewTemplate, RequestTransactionData,\n-    RequestTransactionDataError, RequestTransactionDataSuccess, SetNewPrevHash, SubmitSolution,\n-};\n-\n-use binary_sv2::{\n-    binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n-    encodable::EncodableField, from_bytes, Deserialize, Error,\n-};\n-\n-use const_sv2::{\n-    MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES, MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n-    MESSAGE_TYPE_NEW_TEMPLATE, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n-    MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS,\n-    MESSAGE_TYPE_SETUP_CONNECTION, MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n-    MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS, MESSAGE_TYPE_SET_NEW_PREV_HASH,\n-    MESSAGE_TYPE_SUBMIT_SOLUTION,\n-};\n-use core::convert::{TryFrom, TryInto};\n-\n-#[derive(Clone, Debug)]\n-pub enum Sv2Message<'a> {\n-    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n-    NewTemplate(NewTemplate<'a>),\n-    RequestTransactionData(RequestTransactionData),\n-    RequestTransactionDataError(RequestTransactionDataError<'a>),\n-    RequestTransactionDataSuccess(RequestTransactionDataSuccess<'a>),\n-    SetNewPrevHash(SetNewPrevHash<'a>),\n-    SubmitSolution(SubmitSolution<'a>),\n-    ChannelEndpointChanged(ChannelEndpointChanged),\n-    SetupConnection(SetupConnection<'a>),\n-    SetupConnectionError(SetupConnectionError<'a>),\n-    SetupConnectionSuccess(SetupConnectionSuccess),\n-}\n-\n-impl<'a> Sv2Message<'a> {\n-    pub fn message_type(&self) -> u8 {\n-        match self {\n-            Sv2Message::CoinbaseOutputDataSize(_) => MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n-            Sv2Message::NewTemplate(_) => MESSAGE_TYPE_NEW_TEMPLATE,\n-            Sv2Message::RequestTransactionData(_) => MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n-            Sv2Message::RequestTransactionDataError(_) => {\n-                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR\n-            }\n-            Sv2Message::RequestTransactionDataSuccess(_) => {\n-                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS\n-            }\n-            Sv2Message::SetNewPrevHash(_) => MESSAGE_TYPE_SET_NEW_PREV_HASH,\n-            Sv2Message::SubmitSolution(_) => MESSAGE_TYPE_SUBMIT_SOLUTION,\n-            Sv2Message::ChannelEndpointChanged(_) => MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES,\n-            Sv2Message::SetupConnection(_) => MESSAGE_TYPE_SETUP_CONNECTION,\n-            Sv2Message::SetupConnectionError(_) => MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n-            Sv2Message::SetupConnectionSuccess(_) => MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS,\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub enum CSv2Message {\n-    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n-    NewTemplate(CNewTemplate),\n-    RequestTransactionData(RequestTransactionData),\n-    RequestTransactionDataError(CRequestTransactionDataError),\n-    RequestTransactionDataSuccess(CRequestTransactionDataSuccess),\n-    SetNewPrevHash(CSetNewPrevHash),\n-    SubmitSolution(CSubmitSolution),\n-    ChannelEndpointChanged(ChannelEndpointChanged),\n-    SetupConnection(CSetupConnection),\n-    SetupConnectionError(CSetupConnectionError),\n-    SetupConnectionSuccess(SetupConnectionSuccess),\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn drop_sv2_message(s: CSv2Message) {\n-    match s {\n-        CSv2Message::CoinbaseOutputDataSize(_) => (),\n-        CSv2Message::NewTemplate(a) => drop(a),\n-        CSv2Message::RequestTransactionData(a) => drop(a),\n-        CSv2Message::RequestTransactionDataError(a) => drop(a),\n-        CSv2Message::RequestTransactionDataSuccess(a) => drop(a),\n-        CSv2Message::SetNewPrevHash(a) => drop(a),\n-        CSv2Message::SubmitSolution(a) => drop(a),\n-        CSv2Message::ChannelEndpointChanged(_) => (),\n-        CSv2Message::SetupConnection(_) => (),\n-        CSv2Message::SetupConnectionError(a) => drop(a),\n-        CSv2Message::SetupConnectionSuccess(a) => drop(a),\n-    }\n-}\n-\n-impl<'a> From<Sv2Message<'a>> for CSv2Message {\n-    fn from(v: Sv2Message<'a>) -> Self {\n-        match v {\n-            Sv2Message::CoinbaseOutputDataSize(a) => Self::CoinbaseOutputDataSize(a),\n-            Sv2Message::NewTemplate(a) => Self::NewTemplate(a.into()),\n-            Sv2Message::RequestTransactionData(a) => Self::RequestTransactionData(a),\n-            Sv2Message::RequestTransactionDataError(a) => {\n-                Self::RequestTransactionDataError(a.into())\n-            }\n-            Sv2Message::RequestTransactionDataSuccess(a) => {\n-                Self::RequestTransactionDataSuccess(a.into())\n-            }\n-            Sv2Message::SetNewPrevHash(a) => Self::SetNewPrevHash(a.into()),\n-            Sv2Message::SubmitSolution(a) => Self::SubmitSolution(a.into()),\n-            Sv2Message::ChannelEndpointChanged(a) => Self::ChannelEndpointChanged(a),\n-            Sv2Message::SetupConnection(a) => Self::SetupConnection(a.into()),\n-            Sv2Message::SetupConnectionError(a) => Self::SetupConnectionError(a.into()),\n-            Sv2Message::SetupConnectionSuccess(a) => Self::SetupConnectionSuccess(a),\n-        }\n-    }\n-}\n-\n-impl<'a> CSv2Message {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<Sv2Message<'a>, Error> {\n-        match self {\n-            //CSv2Message::CoinbaseOutputDataSize(v) => {Ok(Sv2Message::CoinbaseOutputDataSize(*v))}\n-            CSv2Message::NewTemplate(v) => Ok(Sv2Message::NewTemplate(v.to_rust_rep_mut()?)),\n-            //CSv2Message::RequestTransactionData(v) => {Ok(Sv2Message::RequestTransactionData(*v))}\n-            //CSv2Message::RequestTransactionDataError(mut v) => {Ok(Sv2Message::RequestTransactionDataError(v.to_rust_rep_mut()?))}\n-            //CSv2Message::RequestTransactionDataSuccess(mut v) => {Ok(Sv2Message::RequestTransactionDataSuccess(v.to_rust_rep_mut()?))}\n-            CSv2Message::SetNewPrevHash(v) => Ok(Sv2Message::SetNewPrevHash(v.to_rust_rep_mut()?)),\n-            CSv2Message::SubmitSolution(v) => Ok(Sv2Message::SubmitSolution(v.to_rust_rep_mut()?)),\n-            //CSv2Message::ChannelEndpointChanged(v) => {Ok(Sv2Message::ChannelEndpointChanged(*v))}\n-            CSv2Message::SetupConnection(v) => {\n-                Ok(Sv2Message::SetupConnection(v.to_rust_rep_mut()?))\n-            }\n-            CSv2Message::SetupConnectionError(v) => {\n-                Ok(Sv2Message::SetupConnectionError(v.to_rust_rep_mut()?))\n-            }\n-            //CSv2Message::SetupConnectionSuccess(v) => {Ok(Sv2Message::SetupConnectionSuccess(*v))}\n-            _ => todo!(),\n-        }\n-    }\n-}\n-\n-impl<'decoder> From<Sv2Message<'decoder>> for EncodableField<'decoder> {\n-    fn from(m: Sv2Message<'decoder>) -> Self {\n-        match m {\n-            Sv2Message::CoinbaseOutputDataSize(a) => a.into(),\n-            Sv2Message::NewTemplate(a) => a.into(),\n-            Sv2Message::RequestTransactionData(a) => a.into(),\n-            Sv2Message::RequestTransactionDataError(a) => a.into(),\n-            Sv2Message::RequestTransactionDataSuccess(a) => a.into(),\n-            Sv2Message::SetNewPrevHash(a) => a.into(),\n-            Sv2Message::SubmitSolution(a) => a.into(),\n-            Sv2Message::ChannelEndpointChanged(a) => a.into(),\n-            Sv2Message::SetupConnection(a) => a.into(),\n-            Sv2Message::SetupConnectionError(a) => a.into(),\n-            Sv2Message::SetupConnectionSuccess(a) => a.into(),\n-        }\n-    }\n-}\n-\n-impl binary_sv2::GetSize for Sv2Message<'_> {\n-    fn get_size(&self) -> usize {\n-        match self {\n-            Sv2Message::CoinbaseOutputDataSize(a) => a.get_size(),\n-            Sv2Message::NewTemplate(a) => a.get_size(),\n-            Sv2Message::RequestTransactionData(a) => a.get_size(),\n-            Sv2Message::RequestTransactionDataError(a) => a.get_size(),\n-            Sv2Message::RequestTransactionDataSuccess(a) => a.get_size(),\n-            Sv2Message::SetNewPrevHash(a) => a.get_size(),\n-            Sv2Message::SubmitSolution(a) => a.get_size(),\n-            Sv2Message::ChannelEndpointChanged(a) => a.get_size(),\n-            Sv2Message::SetupConnection(a) => a.get_size(),\n-            Sv2Message::SetupConnectionError(a) => a.get_size(),\n-            Sv2Message::SetupConnectionSuccess(a) => a.get_size(),\n-        }\n-    }\n-}\n-\n-impl<'decoder> Deserialize<'decoder> for Sv2Message<'decoder> {\n-    fn get_structure(_v: &[u8]) -> std::result::Result<Vec<FieldMarker>, binary_sv2::Error> {\n-        unimplemented!()\n-    }\n-    fn from_decoded_fields(\n-        _v: Vec<DecodableField<'decoder>>,\n-    ) -> std::result::Result<Self, binary_sv2::Error> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<'a> TryFrom<(u8, &'a mut [u8])> for Sv2Message<'a> {\n-    type Error = Error;\n-\n-    fn try_from(v: (u8, &'a mut [u8])) -> Result<Self, Self::Error> {\n-        let msg_type = v.0;\n-        match msg_type {\n-            MESSAGE_TYPE_SETUP_CONNECTION => {\n-                let message: SetupConnection<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetupConnection(message))\n-            }\n-            MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS => {\n-                let message: SetupConnectionSuccess = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetupConnectionSuccess(message))\n-            }\n-            MESSAGE_TYPE_SETUP_CONNECTION_ERROR => {\n-                let message: SetupConnectionError<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetupConnectionError(message))\n-            }\n-            MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES => {\n-                let message: ChannelEndpointChanged = from_bytes(v.1)?;\n-                Ok(Sv2Message::ChannelEndpointChanged(message))\n-            }\n-            MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE => {\n-                let message: CoinbaseOutputDataSize = from_bytes(v.1)?;\n-                Ok(Sv2Message::CoinbaseOutputDataSize(message))\n-            }\n-            MESSAGE_TYPE_NEW_TEMPLATE => {\n-                let message: NewTemplate<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::NewTemplate(message))\n-            }\n-            MESSAGE_TYPE_SET_NEW_PREV_HASH => {\n-                let message: SetNewPrevHash<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetNewPrevHash(message))\n-            }\n-            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA => {\n-                let message: RequestTransactionData = from_bytes(v.1)?;\n-                Ok(Sv2Message::RequestTransactionData(message))\n-            }\n-            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS => {\n-                let message: RequestTransactionDataSuccess = from_bytes(v.1)?;\n-                Ok(Sv2Message::RequestTransactionDataSuccess(message))\n-            }\n-            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR => {\n-                let message: RequestTransactionDataError = from_bytes(v.1)?;\n-                Ok(Sv2Message::RequestTransactionDataError(message))\n-            }\n-            MESSAGE_TYPE_SUBMIT_SOLUTION => {\n-                let message: SubmitSolution = from_bytes(v.1)?;\n-                Ok(Sv2Message::SubmitSolution(message))\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub enum CResult<T, E> {\n-    Ok(T),\n-    Err(E),\n-}\n-\n-#[repr(C)]\n-pub enum Sv2Error {\n-    MissingBytes,\n-    EncoderBusy,\n-    Todo,\n-    Unknown,\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn is_ok(cresult: &CResult<CSv2Message, Sv2Error>) -> bool {\n-    match cresult {\n-        CResult::Ok(_) => true,\n-        CResult::Err(_) => false,\n-    }\n-}\n-\n-impl<T, E> From<Result<T, E>> for CResult<T, E> {\n-    fn from(v: Result<T, E>) -> Self {\n-        match v {\n-            Ok(v) => Self::Ok(v),\n-            Err(e) => Self::Err(e),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct EncoderWrapper {\n-    encoder: Encoder<Sv2Message<'static>>,\n-    free: bool,\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn new_encoder() -> *mut EncoderWrapper {\n-    let encoder: Encoder<Sv2Message<'static>> = Encoder::new();\n-    let s = Box::new(EncoderWrapper {\n-        encoder,\n-        free: true,\n-    });\n-    Box::into_raw(s)\n-}\n-\n-#[no_mangle]\n-#[allow(clippy::not_unsafe_ptr_arg_deref)]\n-pub extern \"C\" fn free_encoder(encoder: *mut EncoderWrapper) {\n-    let mut encoder = unsafe { Box::from_raw(encoder) };\n-    encoder.free = true;\n-    Box::into_raw(encoder);\n-}\n-\n-fn encode_(message: &'static mut CSv2Message, encoder: &mut EncoderWrapper) -> Result<CVec, Error> {\n-    let message: Sv2Message = message.to_rust_rep_mut()?;\n-    let m_type = message.message_type();\n-    let frame = StandardSv2Frame::<Sv2Message<'static>>::from_message(message, m_type, 0)\n-        .ok_or(Error::Todo)?;\n-    encoder\n-        .encoder\n-        .encode(frame)\n-        .map_err(|_| Error::Todo)\n-        .map(|x| x.into())\n-}\n-\n-/// # Safety\n-///\n-/// TODO\n-#[no_mangle]\n-pub unsafe extern \"C\" fn encode(\n-    message: &'static mut CSv2Message,\n-    encoder: *mut EncoderWrapper,\n-) -> CResult<CVec, Sv2Error> {\n-    let mut encoder = Box::from_raw(encoder);\n-    if encoder.free {\n-        let result = encode_(message, &mut encoder)\n-            .map_err(|_| Sv2Error::Todo)\n-            .into();\n-        encoder.free = false;\n-        Box::into_raw(encoder);\n-        result\n-    } else {\n-        CResult::Err(Sv2Error::EncoderBusy)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct DecoderWrapper(StandardDecoder<Sv2Message<'static>>);\n-\n-#[no_mangle]\n-pub extern \"C\" fn new_decoder() -> *mut DecoderWrapper {\n-    let s = Box::new(DecoderWrapper(StandardDecoder::new()));\n-    Box::into_raw(s)\n-}\n-\n-#[no_mangle]\n-#[allow(clippy::not_unsafe_ptr_arg_deref)]\n-pub extern \"C\" fn get_writable(decoder: *mut DecoderWrapper) -> CVec {\n-    let mut decoder = unsafe { Box::from_raw(decoder) };\n-    let writable = decoder.0.writable();\n-    let res = CVec::as_shared_buffer(writable);\n-    Box::into_raw(decoder);\n-    res\n-}\n-\n-#[no_mangle]\n-#[allow(clippy::not_unsafe_ptr_arg_deref)]\n-pub extern \"C\" fn next_frame(decoder: *mut DecoderWrapper) -> CResult<CSv2Message, Sv2Error> {\n-    let mut decoder = unsafe { Box::from_raw(decoder) };\n-\n-    match decoder.0.next_frame() {\n-        Ok(mut f) => {\n-            let msg_type = f.get_header().unwrap().msg_type();\n-            let payload = f.payload();\n-            let len = payload.len();\n-            let ptr = payload.as_mut_ptr();\n-            let payload = unsafe { std::slice::from_raw_parts_mut(ptr, len) };\n-            Box::into_raw(decoder);\n-            (msg_type, payload)\n-                .try_into()\n-                .map(|x: Sv2Message| x.into())\n-                .map_err(|_| Sv2Error::Unknown)\n-                .into()\n-        }\n-        Err(_) => {\n-            Box::into_raw(decoder);\n-            CResult::Err(Sv2Error::MissingBytes)\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use common_messages_sv2::Protocol;\n-\n-    //use quickcheck::{Arbitrary, Gen};\n-\n-    use quickcheck_macros;\n-\n-    fn get_setup_connection() -> SetupConnection<'static> {\n-        let setup_connection = SetupConnection {\n-            protocol: Protocol::TemplateDistributionProtocol, // 2\n-            min_version: 2,\n-            max_version: 2,\n-            flags: 0,\n-            endpoint_host: \"0.0.0.0\".to_string().into_bytes().try_into().unwrap(),\n-            endpoint_port: 8081,\n-            vendor: \"Bitmain\".to_string().into_bytes().try_into().unwrap(),\n-            hardware_version: \"901\".to_string().into_bytes().try_into().unwrap(),\n-            firmware: \"abcX\".to_string().into_bytes().try_into().unwrap(),\n-            device_id: \"89567\".to_string().into_bytes().try_into().unwrap(),\n-        };\n-        return setup_connection;\n-    }\n-\n-    #[test]\n-    fn test_message_type_cb_output_data_size() {\n-        let expected = MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE;\n-        let cb_output_data_size = CoinbaseOutputDataSize {\n-            coinbase_output_max_additional_size: 0,\n-        };\n-        let sv2_message = Sv2Message::CoinbaseOutputDataSize(cb_output_data_size);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expected, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_new_template() {\n-        let expected = MESSAGE_TYPE_NEW_TEMPLATE;\n-        let new_template = NewTemplate {\n-            template_id: 0,\n-            future_template: false,\n-            version: 0x01000000,\n-            coinbase_tx_version: 0x01000000,\n-            coinbase_prefix: \"0\".to_string().into_bytes().try_into().unwrap(),\n-            coinbase_tx_input_sequence: 0xffffffff,\n-            coinbase_tx_value_remaining: 0x00f2052a,\n-            coinbase_tx_outputs_count: 1,\n-            coinbase_tx_outputs: \"0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac\"\n-                .to_string()\n-                .into_bytes()\n-                .try_into()\n-                .unwrap(),\n-            coinbase_tx_locktime: 0x00000000,\n-            merkle_path: binary_sv2::Seq0255::new(Vec::<binary_sv2::U256>::new()).unwrap(),\n-\n-        };\n-        let sv2_message = Sv2Message::NewTemplate(new_template);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expected, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_request_transaction_data() {\n-        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA;\n-        let request_tx_data = RequestTransactionData { template_id: 0 };\n-        let sv2_message = Sv2Message::RequestTransactionData(request_tx_data);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_request_transaction_data_error() {\n-        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR;\n-        let request_tx_data_err = RequestTransactionDataError {\n-            template_id: 0,\n-            error_code: \"an error code\".to_string().into_bytes().try_into().unwrap(),\n-        };\n-        let sv2_message = Sv2Message::RequestTransactionDataError(request_tx_data_err);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_request_transaction_data_success() {\n-        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS;\n-\n-        let request_tx_data_success = RequestTransactionDataSuccess {\n-            template_id: 0,\n-            excess_data: \"some_excess_data\"\n-                .to_string()\n-                .into_bytes()\n-                .try_into()\n-                .unwrap(),\n-            transaction_list: binary_sv2::Seq064K::new(Vec::new()).unwrap(),\n-        };\n-        let sv2_message = Sv2Message::RequestTransactionDataSuccess(request_tx_data_success);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_set_new_prev_hash() {\n-        let expect = MESSAGE_TYPE_SET_NEW_PREV_HASH;\n-\n-        let mut u256 = [0_u8; 32];\n-        let u256_prev_hash: binary_sv2::U256 = (&mut u256[..]).try_into().unwrap();\n-\n-        let mut u256 = [0_u8; 32];\n-        let u256_target: binary_sv2::U256 = (&mut u256[..]).try_into().unwrap();\n-\n-        let set_new_prev_hash = SetNewPrevHash {\n-            template_id: 0,\n-            prev_hash: u256_prev_hash,\n-            header_timestamp: 0x29ab5f49,\n-            n_bits: 0xffff001d,\n-            target: u256_target,\n-        };\n-        let sv2_message = Sv2Message::SetNewPrevHash(set_new_prev_hash);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_submit_solution() {\n-        let expect = MESSAGE_TYPE_SUBMIT_SOLUTION;\n-\n-        let submit_solution = SubmitSolution {\n-            template_id: 0,\n-            version: 0x01000000,\n-            header_timestamp: 0x29ab5f49,\n-            header_nonce: 0x1dac2b7c,\n-            coinbase_tx: \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\"\n-                .to_string()\n-                .into_bytes()\n-                .try_into()\n-                .unwrap(),\n-        };\n-\n-        let sv2_message = Sv2Message::SubmitSolution(submit_solution);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_channel_endpoint_changed() {\n-        let expect = MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES;\n-\n-        let channel_endpoint_changed = ChannelEndpointChanged { channel_id: 0 };\n-\n-        let sv2_message = Sv2Message::ChannelEndpointChanged(channel_endpoint_changed);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_setup_connection() {\n-        let expect = MESSAGE_TYPE_SETUP_CONNECTION;\n-\n-        let setup_connection = get_setup_connection();\n-\n-        let sv2_message = Sv2Message::SetupConnection(setup_connection);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_setup_connection_error() {\n-        let expect = MESSAGE_TYPE_SETUP_CONNECTION_ERROR;\n-\n-        let setup_connection_err = SetupConnectionError {\n-            flags: 0,\n-            error_code: \"an error code\".to_string().into_bytes().try_into().unwrap(),\n-        };\n-\n-        let sv2_message = Sv2Message::SetupConnectionError(setup_connection_err);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    fn test_message_type_setup_connection_success() {\n-        let expect = MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS;\n-\n-        let setup_connection_success = SetupConnectionSuccess {\n-            used_version: 1,\n-            flags: 0,\n-        };\n-\n-        let sv2_message = Sv2Message::SetupConnectionSuccess(setup_connection_success);\n-        let actual = sv2_message.message_type();\n-\n-        assert_eq!(expect, actual);\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn test_next_frame() {\n-        let decoder = StandardDecoder::<Sv2Message<'static>>::new();\n-        println!(\"DECODER: {:?}\", &decoder);\n-        println!(\"DECODER 2: {:?}\", &decoder);\n-        let mut decoder_wrapper = DecoderWrapper(decoder);\n-        let _res = next_frame(&mut decoder_wrapper);\n-    }\n-\n-    #[test]\n-    fn test_encode() {\n-        let mut encoder = Encoder::<SetupConnection>::new();\n-        let setup_connection = get_setup_connection();\n-        let setup_connection =\n-            StandardSv2Frame::from_message(setup_connection, MESSAGE_TYPE_SETUP_CONNECTION, 0)\n-                .unwrap();\n-        // let setup_connection = Sv2Frame {\n-        //     header: Header {\n-        //         extesion_type: 0,\n-        //         msg_type: 0,\n-        //         msg_length: U24(42),\n-        //     },\n-        //     payload: Some(SetupConnection {\n-        //         protocol: TemplateDistributionProtocol, // 2\n-        //         min_version: 2,\n-        //         max_version: 2,\n-        //         flags: 0,\n-        //         endpoint_host: Owned([48, 46, 48, 46, 48, 46, 48]),\n-        //         endpoint_port: 8081,\n-        //         vendor: Owned([66, 105, 116, 109, 97, 105, 110]),\n-        //         hardware_version: Owned([57, 48, 49]),\n-        //         firmware: Owned([97, 98, 99, 88]),\n-        //         device_id: Owned([56, 57, 53, 54, 55]),\n-        //     }),\n-        //     serialized: None,\n-        // };\n-        let setup_connection = encoder.encode(setup_connection).unwrap();\n-        let expected = [\n-            0, 0, 0, 42, 0, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 7, 48, 46, 48, 46, 48, 46, 48, 145, 31,\n-            7, 66, 105, 116, 109, 97, 105, 110, 3, 57, 48, 49, 4, 97, 98, 99, 88, 5, 56, 57, 53,\n-            54, 55,\n-        ]\n-        .to_vec();\n-        // [0(?), 0 (extension_type), 0 (msg_type), 42 (msg_length), 0 (?), 0 (?), 2 (protocol?), 2 (min_version?),  0 (?), 2 (?), 0 (?), 0 (?), 0 (?), 0 (?), 0 (?), 7 (len), 48 (0), 46(.), 48 (0), 46(.), 48 (0), 46(.), 48 (0), 145 (?), 31 (?), 7 (len),  66 (B), 105 (i), 116 (t), 109 (m), 97 (a), 105(i), 110 (n), 3 (len), 57 (9), 48 (0), 49 (1), 4 (len), 97 (a), 98 (b), 99 (c), 88 (X), 5(len), 56 (8), 57 (9), 53 (5), 54 (6), 55 (7)]\n-        assert_eq!(expected, setup_connection);\n-    }\n-}"
      }
    ]
  },
  {
    "sha": "069adee1afe3a87a1eb93d054235322062e88402",
    "node_id": "C_kwDOABII59oAKDA2OWFkZWUxYWZlM2E4N2ExZWI5M2QwNTQyMzUzMjIwNjJlODg0MDI",
    "commit": {
      "author": {
        "name": "RJ Rybarczyk",
        "email": "rj@rybar.tech",
        "date": "2021-09-21T18:41:15Z"
      },
      "committer": {
        "name": "RJ Rybarczyk",
        "email": "rj@rybar.tech",
        "date": "2021-09-21T18:41:15Z"
      },
      "message": "Remove local TP rust crates to be replaced by a git subtree",
      "tree": {
        "sha": "32087352def7d1abe0be619e72b466b5f26380a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32087352def7d1abe0be619e72b466b5f26380a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/069adee1afe3a87a1eb93d054235322062e88402",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/069adee1afe3a87a1eb93d054235322062e88402",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/069adee1afe3a87a1eb93d054235322062e88402",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/069adee1afe3a87a1eb93d054235322062e88402/comments",
    "author": {
      "login": "rrybarczyk",
      "id": 29670338,
      "node_id": "MDQ6VXNlcjI5NjcwMzM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/29670338?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rrybarczyk",
      "html_url": "https://github.com/rrybarczyk",
      "followers_url": "https://api.github.com/users/rrybarczyk/followers",
      "following_url": "https://api.github.com/users/rrybarczyk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rrybarczyk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rrybarczyk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rrybarczyk/subscriptions",
      "organizations_url": "https://api.github.com/users/rrybarczyk/orgs",
      "repos_url": "https://api.github.com/users/rrybarczyk/repos",
      "events_url": "https://api.github.com/users/rrybarczyk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rrybarczyk/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rrybarczyk",
      "id": 29670338,
      "node_id": "MDQ6VXNlcjI5NjcwMzM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/29670338?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rrybarczyk",
      "html_url": "https://github.com/rrybarczyk",
      "followers_url": "https://api.github.com/users/rrybarczyk/followers",
      "following_url": "https://api.github.com/users/rrybarczyk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rrybarczyk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rrybarczyk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rrybarczyk/subscriptions",
      "organizations_url": "https://api.github.com/users/rrybarczyk/orgs",
      "repos_url": "https://api.github.com/users/rrybarczyk/repos",
      "events_url": "https://api.github.com/users/rrybarczyk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rrybarczyk/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c9cab9f17113c876f153ec740a9ac26aec7f06e4"
      }
    ],
    "stats": {
      "total": 5863,
      "additions": 0,
      "deletions": 5863
    },
    "files": [
      {
        "sha": "793af64d563d5dadd54bcd01498fd8fa28838587",
        "filename": "src/rusty/binary-sv2/binary-sv2/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/binary-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/binary-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/binary-sv2/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,20 +0,0 @@\n-[package]\n-name = \"binary_sv2\"\n-version = \"0.1.3\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2 data format\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-serde_sv2 = {version = \"0.1.0\", path = \"../serde-sv2\", optional = true}\n-serde = { version = \"1.0.89\", features = [\"derive\", \"alloc\"], default-features = false, optional = true }\n-binary_codec_sv2 = {version = \"0.1.1\", path = \"../no-serde-sv2/codec\", optional = true}\n-derive_codec_sv2 = {version = \"0.1.1\", path = \"../no-serde-sv2/derive_codec\", optional = true}\n-\n-[features]\n-default = [\"core\"]\n-core = [\"binary_codec_sv2\", \"derive_codec_sv2\"]\n-with_serde = [\"serde_sv2\", \"serde\"]"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/rusty/binary-sv2/binary-sv2/README.md",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/binary-sv2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/binary-sv2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/binary-sv2/README.md?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4"
      },
      {
        "sha": "d9b012ea4f09039f57924ced0af1f028e5bed835",
        "filename": "src/rusty/binary-sv2/binary-sv2/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 687,
        "changes": 687,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/binary-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/binary-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/binary-sv2/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,687 +0,0 @@\n-// TODO unify errors from serde_sv2 and no-serde-sv2\n-\n-#[cfg(feature = \"with_serde\")]\n-pub use serde::{self, Deserialize, Serialize};\n-#[cfg(feature = \"with_serde\")]\n-pub use serde_sv2::*;\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use binary_codec_sv2::{self, Decodable as Deserialize, Encodable as Serialize, *};\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use derive_codec_sv2::{Decodable as Deserialize, Encodable as Serialize};\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    mod test_bytes {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Bytes<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_struct() {\n-            let mut bytes = [98; 890];\n-            let a: Bytes = (&mut bytes[..]).try_into().unwrap();\n-            let expected = Test { a };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_struct {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n-        struct Test {\n-            a: u32,\n-            b: u8,\n-            c: U24,\n-        }\n-\n-        #[test]\n-        fn test_struct() {\n-            let expected = Test {\n-                a: 456,\n-                b: 9,\n-                c: 67_u32.try_into().unwrap(),\n-            };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_f32 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n-        struct Test {\n-            a: u8,\n-            b: U24,\n-            c: f32,\n-        }\n-\n-        #[test]\n-        fn test_struct() {\n-            let expected = Test {\n-                c: 0.345,\n-                a: 9,\n-                b: 67_u32.try_into().unwrap(),\n-            };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_str032 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Str032<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_stro32() {\n-            let mut stro32 = format!(\"error-code\").into_bytes();\n-            let stro32: Str032 = (&mut stro32[..]).try_into().unwrap();\n-\n-            let expected = Test { a: stro32 };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_b0255 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: B0255<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_b0255() {\n-            let mut b0255 = [6; 3];\n-            let b0255: B0255 = (&mut b0255[..]).try_into().unwrap();\n-\n-            let expected = Test { a: b0255 };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_u256 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: U256<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_u256() {\n-            let mut u256 = [6_u8; 32];\n-            let u256: U256 = (&mut u256[..]).try_into().unwrap();\n-\n-            let expected = Test { a: u256 };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_signature {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Signature<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_signature() {\n-            let mut s = [6; 64];\n-            let s: Signature = (&mut s[..]).try_into().unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_b016m {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            b: bool,\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: B016M<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_b016m() {\n-            let mut b = [0_u8; 70000];\n-            let b: B016M = (&mut b[..]).try_into().unwrap();\n-            //println!(\"{:?}\", to_bytes(&b).unwrap().len());\n-\n-            let expected = Test { a: b, b: true };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_b064k {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            b: bool,\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: B064K<'decoder>,\n-        }\n-\n-        #[test]\n-        fn test_b064k() {\n-            let mut b = [1, 2, 9];\n-            let b: B064K = (&mut b[..])\n-                .try_into()\n-                .expect(\"vector smaller than 64K should not fail\");\n-\n-            let expected = Test { a: b, b: true };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq0255_u256 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq0255<'decoder, U256<'decoder>>,\n-        }\n-\n-        #[test]\n-        fn test_seq0255_u256() {\n-            let mut u256_1 = [6; 32];\n-            let mut u256_2 = [5; 32];\n-            let mut u256_3 = [0; 32];\n-            let u256_1: U256 = (&mut u256_1[..]).try_into().unwrap();\n-            let u256_2: U256 = (&mut u256_2[..]).try_into().unwrap();\n-            let u256_3: U256 = (&mut u256_3[..]).try_into().unwrap();\n-\n-            let val = vec![u256_1, u256_2, u256_3];\n-            let s = Seq0255::new(val).unwrap();\n-\n-            let test = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(test.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&test.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let bytes_2 = to_bytes(deserialized.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let bytes_2 = to_bytes(&deserialized.clone()).unwrap();\n-\n-            assert_eq!(bytes, bytes_2);\n-        }\n-    }\n-\n-    mod test_0255_bool {\n-        use super::*;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq0255<'decoder, bool>,\n-        }\n-\n-        #[test]\n-        fn test_seq0255_bool() {\n-            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq0255_u16 {\n-        use super::*;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq0255<'decoder, u16>,\n-        }\n-\n-        #[test]\n-        fn test_seq0255_u16() {\n-            let s: Seq0255<u16> = Seq0255::new(vec![10, 43, 89]).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq_0255_u24 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq0255<'decoder, U24>,\n-        }\n-\n-        #[test]\n-        fn test_seq0255_u24() {\n-            let u24_1: U24 = 56_u32.try_into().unwrap();\n-            let u24_2: U24 = 59_u32.try_into().unwrap();\n-            let u24_3: U24 = 70999_u32.try_into().unwrap();\n-\n-            let val = vec![u24_1, u24_2, u24_3];\n-            let s: Seq0255<U24> = Seq0255::new(val).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seqo255_u32 {\n-        use super::*;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq0255<'decoder, u32>,\n-        }\n-\n-        #[test]\n-        fn test_seq0255_u32() {\n-            let s: Seq0255<u32> = Seq0255::new(vec![546, 99999, 87, 32]).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq0255_signature {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq0255<'decoder, Signature<'decoder>>,\n-        }\n-\n-        #[test]\n-        fn test_seq0255_signature() {\n-            let mut siganture_1 = [88_u8; 64];\n-            let mut siganture_2 = [99_u8; 64];\n-            let mut siganture_3 = [220_u8; 64];\n-            let siganture_1: Signature = (&mut siganture_1[..]).try_into().unwrap();\n-            let siganture_2: Signature = (&mut siganture_2[..]).try_into().unwrap();\n-            let siganture_3: Signature = (&mut siganture_3[..]).try_into().unwrap();\n-\n-            let val = vec![siganture_1, siganture_2, siganture_3];\n-            let s: Seq0255<Signature> = Seq0255::new(val).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq_064_u256 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, U256<'decoder>>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_u256() {\n-            let mut u256_1 = [6; 32];\n-            let mut u256_2 = [5; 32];\n-            let mut u256_3 = [0; 32];\n-            let u256_1: U256 = (&mut u256_1[..]).try_into().unwrap();\n-            let u256_2: U256 = (&mut u256_2[..]).try_into().unwrap();\n-            let u256_3: U256 = (&mut u256_3[..]).try_into().unwrap();\n-\n-            let val = vec![u256_1, u256_2, u256_3];\n-            let s = Seq064K::new(val).unwrap();\n-\n-            let test = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(test.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&test.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let bytes_2 = to_bytes(deserialized.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let bytes_2 = to_bytes(&deserialized.clone()).unwrap();\n-\n-            assert_eq!(bytes, bytes_2);\n-        }\n-    }\n-\n-    mod test_064_bool {\n-        use super::*;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, bool>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_bool() {\n-            let s: Seq064K<bool> = Seq064K::new(vec![true, false, true]).unwrap();\n-            let s2: Seq064K<bool> = Seq064K::new(vec![true; 64000]).unwrap();\n-\n-            let expected = Test { a: s };\n-            let expected2 = Test { a: s2 };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes2 = to_bytes(expected2.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes2 = to_bytes(&expected2.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-            let deserialized2: Test = from_bytes(&mut bytes2[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-            assert_eq!(deserialized2, expected2);\n-        }\n-    }\n-\n-    mod test_se1o64k_u16 {\n-        use super::*;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, u16>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_u16() {\n-            let s: Seq064K<u16> = Seq064K::new(vec![10, 43, 89]).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq064k_u24 {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, U24>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_u24() {\n-            let u24_1: U24 = 56_u32.try_into().unwrap();\n-            let u24_2: U24 = 59_u32.try_into().unwrap();\n-            let u24_3: U24 = 70999_u32.try_into().unwrap();\n-\n-            let val = vec![u24_1, u24_2, u24_3];\n-            let s: Seq064K<U24> = Seq064K::new(val).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-\n-    mod test_seq064k_u32 {\n-        use super::*;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, u32>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_u32() {\n-            let s: Seq064K<u32> = Seq064K::new(vec![546, 99999, 87, 32]).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-    mod test_seq064k_signature {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, Signature<'decoder>>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_signature() {\n-            let mut siganture_1 = [88_u8; 64];\n-            let mut siganture_2 = [99_u8; 64];\n-            let mut siganture_3 = [220_u8; 64];\n-            let siganture_1: Signature = (&mut siganture_1[..]).try_into().unwrap();\n-            let siganture_2: Signature = (&mut siganture_2[..]).try_into().unwrap();\n-            let siganture_3: Signature = (&mut siganture_3[..]).try_into().unwrap();\n-\n-            let val = vec![siganture_1, siganture_2, siganture_3];\n-            let s: Seq064K<Signature> = Seq064K::new(val).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-    mod test_seq064k_b016m {\n-        use super::*;\n-        use core::convert::TryInto;\n-\n-        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n-        struct Test<'decoder> {\n-            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-            a: Seq064K<'decoder, B016M<'decoder>>,\n-        }\n-\n-        #[test]\n-        fn test_seq064k_b016m() {\n-            let mut bytes_1 = [88_u8; 64];\n-            let mut bytes_2 = [99_u8; 64];\n-            let mut bytes_3 = [220_u8; 64];\n-            let bytes_1: B016M = (&mut bytes_1[..]).try_into().unwrap();\n-            let bytes_2: B016M = (&mut bytes_2[..]).try_into().unwrap();\n-            let bytes_3: B016M = (&mut bytes_3[..]).try_into().unwrap();\n-\n-            let val = vec![bytes_1, bytes_2, bytes_3];\n-            let s: Seq064K<B016M> = Seq064K::new(val).unwrap();\n-\n-            let expected = Test { a: s };\n-\n-            #[cfg(not(feature = \"with_serde\"))]\n-            let mut bytes = to_bytes(expected.clone()).unwrap();\n-            #[cfg(feature = \"with_serde\")]\n-            let mut bytes = to_bytes(&expected.clone()).unwrap();\n-\n-            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n-\n-            assert_eq!(deserialized, expected);\n-        }\n-    }\n-}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/.gitignore?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1 +0,0 @@\n-/target"
      },
      {
        "sha": "79df158b51cd3b980e4aa4a9dd7d7b023eb046b8",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "status": "removed",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.lock?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,5 +0,0 @@\n-# This file is automatically @generated by Cargo.\n-# It is not intended for manual editing.\n-[[package]]\n-name = \"binary_codec_sv2\"\n-version = \"0.1.1\""
      },
      {
        "sha": "99d0430c3bda1949186700dac4adfb2b5cd6395a",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,15 +0,0 @@\n-[package]\n-name = \"binary_codec_sv2\"\n-version = \"0.1.1\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2 data format\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-\n-[features]\n-no_std = []\n-deafult = [\"no_std\"]"
      },
      {
        "sha": "d3e5e6829ef9f54aead4f09105f641665f59274f",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 293,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,293 +0,0 @@\n-use crate::codec::{GetSize, SizeHint};\n-use crate::datatypes::{Bytes, Signature, Sv2DataType, B016M, B0255, B032, B064K, U24, U256};\n-use crate::Error;\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::{Cursor, Read};\n-\n-/// Implmented by all the decodable structure, it can be derived for every structure composed only\n-/// by primitives or other Decodable.\n-pub trait Decodable<'a>: Sized {\n-    fn get_structure(data: &[u8]) -> Result<Vec<FieldMarker>, Error>;\n-\n-    fn from_decoded_fields(data: Vec<DecodableField<'a>>) -> Result<Self, Error>;\n-\n-    fn from_bytes(data: &'a mut [u8]) -> Result<Self, Error> {\n-        let structure = Self::get_structure(data)?;\n-        let mut fields = Vec::new();\n-        let mut tail = data;\n-\n-        for field in structure {\n-            let field_size = field.size_hint_(tail, 0)?;\n-            let (head, t) = tail.split_at_mut(field_size);\n-            tail = t;\n-            fields.push(field.decode(head)?);\n-        }\n-        Self::from_decoded_fields(fields)\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn from_reader(reader: &mut impl Read) -> Result<Self, Error> {\n-        let mut data = Vec::new();\n-        reader.read_to_end(&mut data)?;\n-\n-        let structure = Self::get_structure(&data[..])?;\n-\n-        let mut fields = Vec::new();\n-        let mut reader = Cursor::new(data);\n-\n-        for field in structure {\n-            fields.push(field.from_reader(&mut reader)?);\n-        }\n-        Self::from_decoded_fields(fields)\n-    }\n-}\n-\n-/// Passed to a decoder to define the structure of the data to be decoded\n-#[derive(Debug, Clone, Copy)]\n-pub enum PrimitiveMarker {\n-    U8,\n-    U16,\n-    Bool,\n-    U24,\n-    U256,\n-    Signature,\n-    U32,\n-    F32,\n-    U64,\n-    B032,\n-    B0255,\n-    B064K,\n-    B016M,\n-    Bytes,\n-}\n-\n-/// Passed to a decoder to define the structure of the data to be decoded\n-#[derive(Debug, Clone)]\n-pub enum FieldMarker {\n-    Primitive(PrimitiveMarker),\n-    Struct(Vec<FieldMarker>),\n-}\n-pub trait GetMarker {\n-    fn get_marker() -> FieldMarker;\n-}\n-\n-/// Used to contrustuct primitives is returned by the decoder\n-#[derive(Debug)]\n-pub enum DecodablePrimitive<'a> {\n-    U8(u8),\n-    U16(u16),\n-    Bool(bool),\n-    U24(U24),\n-    U256(U256<'a>),\n-    Signature(Signature<'a>),\n-    U32(u32),\n-    F32(f32),\n-    U64(u64),\n-    B032(B032<'a>),\n-    B0255(B0255<'a>),\n-    B064K(B064K<'a>),\n-    B016M(B016M<'a>),\n-    Bytes(Bytes<'a>),\n-}\n-\n-/// Used to contrustuct messages is returned by the decoder\n-#[derive(Debug)]\n-pub enum DecodableField<'a> {\n-    Primitive(DecodablePrimitive<'a>),\n-    Struct(Vec<DecodableField<'a>>),\n-}\n-\n-impl SizeHint for PrimitiveMarker {\n-    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n-        match self {\n-            Self::U8 => u8::size_hint(data, offset),\n-            Self::U16 => u16::size_hint(data, offset),\n-            Self::Bool => bool::size_hint(data, offset),\n-            Self::U24 => U24::size_hint(data, offset),\n-            Self::U256 => U256::size_hint(data, offset),\n-            Self::Signature => Signature::size_hint(data, offset),\n-            Self::U32 => u32::size_hint(data, offset),\n-            Self::F32 => f32::size_hint(data, offset),\n-            Self::U64 => u64::size_hint(data, offset),\n-            Self::B032 => B032::size_hint(data, offset),\n-            Self::B0255 => B0255::size_hint(data, offset),\n-            Self::B064K => B064K::size_hint(data, offset),\n-            Self::B016M => B016M::size_hint(data, offset),\n-            Self::Bytes => Bytes::size_hint(data, offset),\n-        }\n-    }\n-}\n-\n-impl SizeHint for FieldMarker {\n-    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n-        match self {\n-            Self::Primitive(p) => p.size_hint_(data, offset),\n-            Self::Struct(ps) => {\n-                let mut size = 0;\n-                for p in ps {\n-                    size += p.size_hint_(data, offset + size)?;\n-                }\n-                Ok(size)\n-            }\n-        }\n-    }\n-}\n-\n-impl SizeHint for Vec<FieldMarker> {\n-    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n-        let mut size = 0;\n-        for field in self {\n-            let field_size = field.size_hint_(data, offset + size)?;\n-            size += field_size;\n-        }\n-        Ok(size)\n-    }\n-}\n-\n-impl From<PrimitiveMarker> for FieldMarker {\n-    fn from(v: PrimitiveMarker) -> Self {\n-        FieldMarker::Primitive(v)\n-    }\n-}\n-\n-impl From<Vec<FieldMarker>> for FieldMarker {\n-    fn from(mut v: Vec<FieldMarker>) -> Self {\n-        match v.len() {\n-            0 => panic!(\"TODO\"),\n-            1 => v.pop().unwrap(),\n-            _ => FieldMarker::Struct(v),\n-        }\n-    }\n-}\n-\n-impl<'a> From<DecodableField<'a>> for Vec<DecodableField<'a>> {\n-    fn from(v: DecodableField<'a>) -> Self {\n-        match v {\n-            DecodableField::Primitive(p) => vec![DecodableField::Primitive(p)],\n-            DecodableField::Struct(ps) => ps,\n-        }\n-    }\n-}\n-\n-impl PrimitiveMarker {\n-    fn decode<'a>(&self, data: &'a mut [u8], offset: usize) -> DecodablePrimitive<'a> {\n-        match self {\n-            Self::U8 => DecodablePrimitive::U8(u8::from_bytes_unchecked(&mut data[offset..])),\n-            Self::U16 => DecodablePrimitive::U16(u16::from_bytes_unchecked(&mut data[offset..])),\n-            Self::Bool => DecodablePrimitive::Bool(bool::from_bytes_unchecked(&mut data[offset..])),\n-            Self::U24 => DecodablePrimitive::U24(U24::from_bytes_unchecked(&mut data[offset..])),\n-            Self::U256 => DecodablePrimitive::U256(U256::from_bytes_unchecked(&mut data[offset..])),\n-            Self::Signature => {\n-                DecodablePrimitive::Signature(Signature::from_bytes_unchecked(&mut data[offset..]))\n-            }\n-            Self::U32 => DecodablePrimitive::U32(u32::from_bytes_unchecked(&mut data[offset..])),\n-            Self::F32 => DecodablePrimitive::F32(f32::from_bytes_unchecked(&mut data[offset..])),\n-            Self::U64 => DecodablePrimitive::U64(u64::from_bytes_unchecked(&mut data[offset..])),\n-            Self::B032 => DecodablePrimitive::B032(B032::from_bytes_unchecked(&mut data[offset..])),\n-            Self::B0255 => {\n-                DecodablePrimitive::B0255(B0255::from_bytes_unchecked(&mut data[offset..]))\n-            }\n-            Self::B064K => {\n-                DecodablePrimitive::B064K(B064K::from_bytes_unchecked(&mut data[offset..]))\n-            }\n-            Self::B016M => {\n-                DecodablePrimitive::B016M(B016M::from_bytes_unchecked(&mut data[offset..]))\n-            }\n-            Self::Bytes => {\n-                DecodablePrimitive::Bytes(Bytes::from_bytes_unchecked(&mut data[offset..]))\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn from_reader<'a>(&self, reader: &mut impl Read) -> Result<DecodablePrimitive<'a>, Error> {\n-        match self {\n-            Self::U8 => Ok(DecodablePrimitive::U8(u8::from_reader_(reader)?)),\n-            Self::U16 => Ok(DecodablePrimitive::U16(u16::from_reader_(reader)?)),\n-            Self::Bool => Ok(DecodablePrimitive::Bool(bool::from_reader_(reader)?)),\n-            Self::U24 => Ok(DecodablePrimitive::U24(U24::from_reader_(reader)?)),\n-            Self::U256 => Ok(DecodablePrimitive::U256(U256::from_reader_(reader)?)),\n-            Self::Signature => Ok(DecodablePrimitive::Signature(Signature::from_reader_(\n-                reader,\n-            )?)),\n-            Self::U32 => Ok(DecodablePrimitive::U32(u32::from_reader_(reader)?)),\n-            Self::F32 => Ok(DecodablePrimitive::F32(f32::from_reader_(reader)?)),\n-            Self::U64 => Ok(DecodablePrimitive::U64(u64::from_reader_(reader)?)),\n-            Self::B032 => Ok(DecodablePrimitive::B032(B032::from_reader_(reader)?)),\n-            Self::B0255 => Ok(DecodablePrimitive::B0255(B0255::from_reader_(reader)?)),\n-            Self::B064K => Ok(DecodablePrimitive::B064K(B064K::from_reader_(reader)?)),\n-            Self::B016M => Ok(DecodablePrimitive::B016M(B016M::from_reader_(reader)?)),\n-            Self::Bytes => Ok(DecodablePrimitive::Bytes(Bytes::from_reader_(reader)?)),\n-        }\n-    }\n-}\n-\n-impl<'a> GetSize for DecodablePrimitive<'a> {\n-    fn get_size(&self) -> usize {\n-        match self {\n-            DecodablePrimitive::U8(v) => v.get_size(),\n-            DecodablePrimitive::U16(v) => v.get_size(),\n-            DecodablePrimitive::Bool(v) => v.get_size(),\n-            DecodablePrimitive::U24(v) => v.get_size(),\n-            DecodablePrimitive::U256(v) => v.get_size(),\n-            DecodablePrimitive::Signature(v) => v.get_size(),\n-            DecodablePrimitive::U32(v) => v.get_size(),\n-            DecodablePrimitive::F32(v) => v.get_size(),\n-            DecodablePrimitive::U64(v) => v.get_size(),\n-            DecodablePrimitive::B032(v) => v.get_size(),\n-            DecodablePrimitive::B0255(v) => v.get_size(),\n-            DecodablePrimitive::B064K(v) => v.get_size(),\n-            DecodablePrimitive::B016M(v) => v.get_size(),\n-            DecodablePrimitive::Bytes(v) => v.get_size(),\n-        }\n-    }\n-}\n-\n-impl FieldMarker {\n-    pub(crate) fn decode<'a>(&self, data: &'a mut [u8]) -> Result<DecodableField<'a>, Error> {\n-        match self {\n-            Self::Primitive(p) => Ok(DecodableField::Primitive(p.decode(data, 0))),\n-            Self::Struct(ps) => {\n-                let mut decodeds = Vec::new();\n-                let mut tail = data;\n-                for p in ps {\n-                    let field_size = p.size_hint_(tail, 0)?;\n-                    let (head, t) = tail.split_at_mut(field_size);\n-                    tail = t;\n-                    decodeds.push(p.decode(head)?);\n-                }\n-                Ok(DecodableField::Struct(decodeds))\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    pub(crate) fn from_reader<'a>(\n-        &self,\n-        reader: &mut impl Read,\n-    ) -> Result<DecodableField<'a>, Error> {\n-        match self {\n-            Self::Primitive(p) => Ok(DecodableField::Primitive(p.from_reader(reader)?)),\n-            Self::Struct(ps) => {\n-                let mut decodeds = Vec::new();\n-                for p in ps {\n-                    decodeds.push(p.from_reader(reader)?);\n-                }\n-                Ok(DecodableField::Struct(decodeds))\n-            }\n-        }\n-    }\n-}"
      },
      {
        "sha": "20b400562c6f1fd5c650dfdf6d75ed3bb457a957",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 165,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,165 +0,0 @@\n-use crate::codec::GetSize;\n-use crate::datatypes::{Bytes, Signature, Sv2DataType, B016M, B0255, B032, B064K, U24, U256};\n-use crate::Error;\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::{Error as E, Write};\n-\n-pub trait Encodable {\n-    #[allow(clippy::wrong_self_convention)]\n-    fn to_bytes(self, dst: &mut [u8]) -> Result<usize, Error>;\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    #[allow(clippy::wrong_self_convention)]\n-    fn to_writer(self, dst: &mut impl Write) -> Result<(), E>;\n-}\n-\n-//\n-impl<'a, T: Into<EncodableField<'a>>> Encodable for T {\n-    #[allow(clippy::wrong_self_convention)]\n-    fn to_bytes(self, dst: &mut [u8]) -> Result<usize, Error> {\n-        let encoded_field = self.into();\n-        encoded_field.encode(dst, 0)\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    #[allow(clippy::wrong_self_convention)]\n-    fn to_writer(self, dst: &mut impl Write) -> Result<(), E> {\n-        let encoded_field = self.into();\n-        encoded_field.to_writer(dst)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub enum EncodablePrimitive<'a> {\n-    U8(u8),\n-    OwnedU8(u8),\n-    U16(u16),\n-    Bool(bool),\n-    U24(U24),\n-    U256(U256<'a>),\n-    Signature(Signature<'a>),\n-    U32(u32),\n-    F32(f32),\n-    U64(u64),\n-    B032(B032<'a>),\n-    B0255(B0255<'a>),\n-    B064K(B064K<'a>),\n-    B016M(B016M<'a>),\n-    Bytes(Bytes<'a>),\n-}\n-\n-impl<'a> EncodablePrimitive<'a> {\n-    fn encode(&self, dst: &mut [u8]) -> Result<usize, Error> {\n-        match self {\n-            Self::U8(v) => v.to_slice(dst),\n-            Self::OwnedU8(v) => v.to_slice(dst),\n-            Self::U16(v) => v.to_slice(dst),\n-            Self::Bool(v) => v.to_slice(dst),\n-            Self::U24(v) => v.to_slice(dst),\n-            Self::U256(v) => v.to_slice(dst),\n-            Self::Signature(v) => v.to_slice(dst),\n-            Self::U32(v) => v.to_slice(dst),\n-            Self::F32(v) => v.to_slice(dst),\n-            Self::U64(v) => v.to_slice(dst),\n-            Self::B032(v) => v.to_slice(dst),\n-            Self::B0255(v) => v.to_slice(dst),\n-            Self::B064K(v) => v.to_slice(dst),\n-            Self::B016M(v) => v.to_slice(dst),\n-            Self::Bytes(v) => v.to_slice(dst),\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    pub fn write(&self, writer: &mut impl Write) -> Result<(), E> {\n-        match self {\n-            Self::U8(v) => v.to_writer_(writer),\n-            Self::OwnedU8(v) => v.to_writer_(writer),\n-            Self::U16(v) => v.to_writer_(writer),\n-            Self::Bool(v) => v.to_writer_(writer),\n-            Self::U24(v) => v.to_writer_(writer),\n-            Self::U256(v) => v.to_writer_(writer),\n-            Self::Signature(v) => v.to_writer_(writer),\n-            Self::U32(v) => v.to_writer_(writer),\n-            Self::F32(v) => v.to_writer_(writer),\n-            Self::U64(v) => v.to_writer_(writer),\n-            Self::B032(v) => v.to_writer_(writer),\n-            Self::B0255(v) => v.to_writer_(writer),\n-            Self::B064K(v) => v.to_writer_(writer),\n-            Self::B016M(v) => v.to_writer_(writer),\n-            Self::Bytes(v) => v.to_writer_(writer),\n-        }\n-    }\n-}\n-\n-impl<'a> GetSize for EncodablePrimitive<'a> {\n-    fn get_size(&self) -> usize {\n-        match self {\n-            Self::U8(v) => v.get_size(),\n-            Self::OwnedU8(v) => v.get_size(),\n-            Self::U16(v) => v.get_size(),\n-            Self::Bool(v) => v.get_size(),\n-            Self::U24(v) => v.get_size(),\n-            Self::U256(v) => v.get_size(),\n-            Self::Signature(v) => v.get_size(),\n-            Self::U32(v) => v.get_size(),\n-            Self::F32(v) => v.get_size(),\n-            Self::U64(v) => v.get_size(),\n-            Self::B032(v) => v.get_size(),\n-            Self::B0255(v) => v.get_size(),\n-            Self::B064K(v) => v.get_size(),\n-            Self::B016M(v) => v.get_size(),\n-            Self::Bytes(v) => v.get_size(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub enum EncodableField<'a> {\n-    Primitive(EncodablePrimitive<'a>),\n-    Struct(Vec<EncodableField<'a>>),\n-}\n-\n-impl<'a> EncodableField<'a> {\n-    pub fn encode(&self, dst: &mut [u8], mut offset: usize) -> Result<usize, Error> {\n-        match (self, dst.len() >= offset) {\n-            (Self::Primitive(p), true) => p.encode(&mut dst[offset..]),\n-            (Self::Struct(ps), true) => {\n-                for p in ps {\n-                    let encoded_bytes = p.encode(dst, offset)?;\n-                    offset += encoded_bytes;\n-                }\n-                Ok(offset)\n-            }\n-            _ => Err(Error::WriteError(offset, dst.len())),\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    pub fn to_writer(&self, writer: &mut impl Write) -> Result<(), E> {\n-        match self {\n-            Self::Primitive(p) => p.write(writer),\n-            Self::Struct(ps) => {\n-                for p in ps {\n-                    p.to_writer(writer)?;\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> GetSize for EncodableField<'a> {\n-    fn get_size(&self) -> usize {\n-        match self {\n-            Self::Primitive(p) => p.get_size(),\n-            Self::Struct(ps) => {\n-                let mut size = 0;\n-                for p in ps {\n-                    size += p.get_size();\n-                }\n-                size\n-            }\n-        }\n-    }\n-}"
      },
      {
        "sha": "a025b93d753effac312cf40066ea085234aeaf21",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 798,
        "changes": 798,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,798 +0,0 @@\n-use crate::codec::decodable::{\n-    Decodable, DecodableField, DecodablePrimitive, FieldMarker, GetMarker, PrimitiveMarker,\n-};\n-use crate::codec::encodable::{EncodableField, EncodablePrimitive};\n-use crate::datatypes::*;\n-use crate::Error;\n-use alloc::vec::Vec;\n-use core::convert::{TryFrom, TryInto};\n-\n-// IMPL GET MARKER FOR PRIMITIVES\n-impl GetMarker for bool {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::Bool)\n-    }\n-}\n-impl GetMarker for u8 {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::U8)\n-    }\n-}\n-impl GetMarker for u16 {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::U16)\n-    }\n-}\n-impl GetMarker for U24 {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::U24)\n-    }\n-}\n-impl GetMarker for u32 {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::U32)\n-    }\n-}\n-impl GetMarker for f32 {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::F32)\n-    }\n-}\n-impl GetMarker for u64 {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::U64)\n-    }\n-}\n-impl<'a> GetMarker for U256<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::U256)\n-    }\n-}\n-impl<'a> GetMarker for Signature<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::Signature)\n-    }\n-}\n-impl<'a> GetMarker for B032<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::B032)\n-    }\n-}\n-impl<'a> GetMarker for B0255<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::B0255)\n-    }\n-}\n-impl<'a> GetMarker for B064K<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::B064K)\n-    }\n-}\n-impl<'a> GetMarker for B016M<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::B016M)\n-    }\n-}\n-impl<'a> GetMarker for Bytes<'a> {\n-    fn get_marker() -> FieldMarker {\n-        FieldMarker::Primitive(PrimitiveMarker::Bytes)\n-    }\n-}\n-\n-// IMPL DECODABLE FOR PRIMITIVES\n-\n-impl<'a> Decodable<'a> for u8 {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::U8.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for u16 {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::U16.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for u32 {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::U32.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for f32 {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::F32.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for u64 {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::U64.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for bool {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::Bool.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for U24 {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::U24.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for U256<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::U256.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for Signature<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::Signature.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for B032<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::B032.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for B0255<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::B0255.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for B064K<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::B064K.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-impl<'a> Decodable<'a> for B016M<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::B016M.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-\n-impl<'a> Decodable<'a> for Bytes<'a> {\n-    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n-        Ok(vec![PrimitiveMarker::Bytes.into()])\n-    }\n-\n-    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n-        data.pop().unwrap().try_into()\n-    }\n-}\n-\n-// IMPL TRY_FROM PRIMITIVE FOR PRIMITIVEs\n-\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for u8 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::U8(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for u16 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::U16(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for u32 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::U32(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for f32 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::F32(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for u64 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::U64(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for bool {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::Bool(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for U24 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::U24(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for U256<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::U256(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for Signature<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::Signature(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for B032<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::B032(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for B0255<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::B0255(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for B064K<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::B064K(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for B016M<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::B016M(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodablePrimitive<'a>> for Bytes<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodablePrimitive::Bytes(val) => Ok(val),\n-            _ => Err(Error::PrimitiveConversionError),\n-        }\n-    }\n-}\n-\n-// IMPL TRY_FROM DECODEC FIELD FOR PRIMITIVES\n-\n-impl<'a> TryFrom<DecodableField<'a>> for u8 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for u16 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for u32 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for f32 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for u64 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for bool {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for U24 {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for U256<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for Signature<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for B032<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for B0255<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for B064K<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for B016M<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<DecodableField<'a>> for Bytes<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            DecodableField::Primitive(p) => p.try_into(),\n-            _ => Err(Error::DecodableConversionError),\n-        }\n-    }\n-}\n-\n-// IMPL FROM PRIMITIVES FOR ENCODED FIELD\n-\n-impl<'a> From<bool> for EncodableField<'a> {\n-    fn from(v: bool) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::Bool(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for bool {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::Bool(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<u8> for EncodableField<'a> {\n-    fn from(v: u8) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::U8(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for u8 {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::U8(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<u16> for EncodableField<'a> {\n-    fn from(v: u16) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::U16(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for u16 {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::U16(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<U24> for EncodableField<'a> {\n-    fn from(v: U24) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::U24(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for U24 {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::U24(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<u32> for EncodableField<'a> {\n-    fn from(v: u32) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::U32(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for u32 {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::U32(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<f32> for EncodableField<'a> {\n-    fn from(v: f32) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::F32(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for f32 {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::F32(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<u64> for EncodableField<'a> {\n-    fn from(v: u64) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::U64(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for u64 {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::U64(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<U256<'a>> for EncodableField<'a> {\n-    fn from(v: U256<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::U256(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for U256<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::U256(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<Signature<'a>> for EncodableField<'a> {\n-    fn from(v: Signature<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::Signature(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for Signature<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::Signature(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<B032<'a>> for EncodableField<'a> {\n-    fn from(v: B032<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::B032(v))\n-    }\n-}\n-impl<'a> From<B0255<'a>> for EncodableField<'a> {\n-    fn from(v: B0255<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::B0255(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for B032<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::B032(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for B0255<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::B0255(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<B064K<'a>> for EncodableField<'a> {\n-    fn from(v: B064K<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::B064K(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for B064K<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::B064K(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<B016M<'a>> for EncodableField<'a> {\n-    fn from(v: B016M<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::B016M(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for B016M<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::B016M(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-impl<'a> From<Bytes<'a>> for EncodableField<'a> {\n-    fn from(v: Bytes<'a>) -> Self {\n-        EncodableField::Primitive(EncodablePrimitive::Bytes(v))\n-    }\n-}\n-impl<'a> TryFrom<EncodableField<'a>> for Bytes<'a> {\n-    type Error = Error;\n-\n-    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n-        match value {\n-            EncodableField::Primitive(EncodablePrimitive::Bytes(v)) => Ok(v),\n-            _ => Err(Error::Todo),\n-        }\n-    }\n-}\n-//impl<'a> From<&'a Seq0255<'a, U24>> for EncodableField<'a> {\n-//    fn from(v: &'a Seq0255<'a, U24>) -> Self {\n-//        EncodableField::Primitive(EncodablePrimitive::Seq0255u24(v))\n-//    }\n-//}\n-\n-// IMPL INTO FIELD MARKER FOR PRIMITIVES\n-impl From<bool> for FieldMarker {\n-    fn from(_: bool) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::Bool)\n-    }\n-}\n-impl From<u8> for FieldMarker {\n-    fn from(_: u8) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::U8)\n-    }\n-}\n-\n-impl From<u16> for FieldMarker {\n-    fn from(_: u16) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::U16)\n-    }\n-}\n-\n-impl From<u32> for FieldMarker {\n-    fn from(_: u32) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::U32)\n-    }\n-}\n-\n-impl From<f32> for FieldMarker {\n-    fn from(_: f32) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::F32)\n-    }\n-}\n-\n-impl From<u64> for FieldMarker {\n-    fn from(_: u64) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::U64)\n-    }\n-}\n-\n-impl From<U24> for FieldMarker {\n-    fn from(_: U24) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::U24)\n-    }\n-}\n-\n-impl<'a> From<Inner<'a, true, 32, 0, 0>> for FieldMarker {\n-    fn from(_: Inner<'a, true, 32, 0, 0>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::U256)\n-    }\n-}\n-\n-impl<'a> From<Inner<'a, true, 64, 0, 0>> for FieldMarker {\n-    fn from(_: Inner<'a, true, 64, 0, 0>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::Signature)\n-    }\n-}\n-\n-impl<'a> From<B032<'a>> for FieldMarker {\n-    fn from(_: B032<'a>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::B032)\n-    }\n-}\n-\n-impl<'a> From<Inner<'a, false, 1, 1, 255>> for FieldMarker {\n-    fn from(_: Inner<'a, false, 1, 1, 255>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::B0255)\n-    }\n-}\n-\n-impl<'a> From<Inner<'a, false, 1, 2, { 2_usize.pow(16) - 1 }>> for FieldMarker {\n-    fn from(_: Inner<'a, false, 1, 2, { 2_usize.pow(16) - 1 }>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::B064K)\n-    }\n-}\n-\n-impl<'a> From<Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>> for FieldMarker {\n-    fn from(_: Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::B016M)\n-    }\n-}\n-impl<'a> From<Bytes<'a>> for FieldMarker {\n-    fn from(_: Inner<'a, false, 0, 0, { ((2_usize.pow(63) - 1) * 2) + 1 }>) -> Self {\n-        FieldMarker::Primitive(PrimitiveMarker::Bytes)\n-    }\n-}"
      },
      {
        "sha": "91bef226d3f7fe57c6dcf49f9cef074fa4ce9c23",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 54,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,54 +0,0 @@\n-// At lower level I generally prefer to work with slices as more efficient than Read/Write streams\n-// eg: Read for & [u8] is implemented with memcpy but here is more than enough to just get a\n-// pointer to the original data\n-\n-// ANche se enum decode sarebbe faclie da implementare non viene fatto dato che ogni messaggio puo\n-// essere derivato dal suo numero!\n-use crate::Error;\n-pub mod decodable;\n-pub mod encodable;\n-mod impls;\n-\n-/// Return the encoded byte size or a `Decodable`\n-pub trait SizeHint {\n-    fn size_hint(data: &[u8], offset: usize) -> Result<usize, Error>;\n-    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error>;\n-}\n-\n-/// Return the encoded byte size of an `Encodable` comprehensive of the header, if any\n-pub trait GetSize {\n-    fn get_size(&self) -> usize;\n-}\n-\n-/// Implemented by all the primitives with a fixed size\n-pub trait Fixed {\n-    const SIZE: usize;\n-}\n-\n-pub trait Variable {\n-    const HEADER_SIZE: usize;\n-    //const ELEMENT_SIZE: usize;\n-    const MAX_SIZE: usize;\n-\n-    fn inner_size(&self) -> usize;\n-\n-    // TODO use [u8; HEADER_SIZE] instead of Vec\n-    fn get_header(&self) -> Vec<u8>;\n-}\n-\n-impl<T: Fixed> SizeHint for T {\n-    /// Total size of the encoded data type compreensive of the header when present\n-    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n-        Ok(Self::SIZE)\n-    }\n-\n-    fn size_hint_(&self, _: &[u8], _offset: usize) -> Result<usize, Error> {\n-        Ok(Self::SIZE)\n-    }\n-}\n-\n-impl<T: Fixed> GetSize for T {\n-    fn get_size(&self) -> usize {\n-        Self::SIZE\n-    }\n-}"
      },
      {
        "sha": "62d23b0faf7938e48c82f62359d8157b85935928",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 177,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,177 +0,0 @@\n-//! Copy data types\n-use crate::codec::Fixed;\n-use crate::datatypes::Sv2DataType;\n-use crate::Error;\n-use core::convert::{TryFrom, TryInto};\n-\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::{Error as E, Read, Write};\n-\n-// Impl bool as a primitive\n-\n-impl Fixed for bool {\n-    const SIZE: usize = 1;\n-}\n-\n-// Boolean value. Encoded as an unsigned 1-bit integer,\n-// True = 1, False = 0 with 7 additional padding bits in\n-// the high positions.\n-// x\n-// Recipients MUST NOT interpret bits outside of the\n-// least significant bit. Senders MAY set bits outside of\n-// the least significant bit to any value without any\n-// impact on meaning. This allows future use of other\n-// bits as flag bits.\n-impl<'a> Sv2DataType<'a> for bool {\n-    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n-        match data\n-            .get(0)\n-            .map(|x: &u8| x << 7)\n-            .map(|x: u8| x >> 7)\n-            .unwrap()\n-        {\n-            0 => false,\n-            1 => true,\n-            _ => panic!(),\n-        }\n-    }\n-\n-    fn from_vec_(mut data: Vec<u8>) -> Result<Self, Error> {\n-        Self::from_bytes_(&mut data)\n-    }\n-\n-    fn from_vec_unchecked(mut data: Vec<u8>) -> Self {\n-        Self::from_bytes_unchecked(&mut data)\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn from_reader_(reader: &mut impl Read) -> Result<Self, Error> {\n-        let mut dst = [0_u8; Self::SIZE];\n-        reader.read_exact(&mut dst)?;\n-        Self::from_bytes_(&mut dst)\n-    }\n-\n-    fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n-        match self {\n-            true => dst[0] = 1,\n-            false => dst[0] = 0,\n-        };\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n-        match self {\n-            true => writer.write_all(&[1]),\n-            false => writer.write_all(&[0]),\n-        }\n-    }\n-}\n-\n-// Impl unsigned as a primitives\n-\n-impl Fixed for u8 {\n-    const SIZE: usize = 1;\n-}\n-\n-impl Fixed for u16 {\n-    const SIZE: usize = 2;\n-}\n-\n-impl Fixed for u32 {\n-    const SIZE: usize = 4;\n-}\n-\n-// TODO fix not in the specs\n-impl Fixed for u64 {\n-    const SIZE: usize = 8;\n-}\n-\n-macro_rules! impl_sv2_for_unsigned {\n-    ($a:ty) => {\n-        impl<'a> Sv2DataType<'a> for $a {\n-            fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n-                let a: &[u8; Self::SIZE] = data[0..Self::SIZE].try_into().unwrap();\n-                Self::from_le_bytes(*a)\n-            }\n-\n-            fn from_vec_(mut data: Vec<u8>) -> Result<Self, Error> {\n-                Self::from_bytes_(&mut data)\n-            }\n-\n-            fn from_vec_unchecked(mut data: Vec<u8>) -> Self {\n-                Self::from_bytes_unchecked(&mut data)\n-            }\n-\n-            #[cfg(not(feature = \"no_std\"))]\n-            fn from_reader_(reader: &mut impl Read) -> Result<Self, Error> {\n-                let mut dst = [0_u8; Self::SIZE];\n-                reader.read_exact(&mut dst)?;\n-                Ok(Self::from_bytes_unchecked(&mut dst))\n-            }\n-\n-            fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n-                let dst = &mut dst[0..Self::SIZE];\n-                let src = self.to_le_bytes();\n-                dst.copy_from_slice(&src);\n-            }\n-\n-            #[cfg(not(feature = \"no_std\"))]\n-            fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n-                let bytes = self.to_le_bytes();\n-                writer.write_all(&bytes)\n-            }\n-        }\n-    };\n-}\n-impl_sv2_for_unsigned!(u8);\n-impl_sv2_for_unsigned!(u16);\n-impl_sv2_for_unsigned!(u32);\n-impl_sv2_for_unsigned!(u64);\n-\n-// Impl f32 as a primitives\n-\n-impl Fixed for f32 {\n-    const SIZE: usize = 4;\n-}\n-\n-impl_sv2_for_unsigned!(f32);\n-\n-#[repr(C)]\n-#[derive(Debug, Clone, Copy, Eq, PartialEq)]\n-pub struct U24(pub(crate) u32);\n-\n-impl Fixed for U24 {\n-    const SIZE: usize = 3;\n-}\n-\n-impl U24 {\n-    fn from_le_bytes(b: [u8; Self::SIZE]) -> Self {\n-        let inner = u32::from_le_bytes([b[0], b[1], b[2], 0]);\n-        Self(inner)\n-    }\n-\n-    fn to_le_bytes(self) -> [u8; Self::SIZE] {\n-        let b = self.0.to_le_bytes();\n-        [b[0], b[1], b[2]]\n-    }\n-}\n-\n-impl_sv2_for_unsigned!(U24);\n-\n-impl TryFrom<u32> for U24 {\n-    type Error = Error;\n-\n-    fn try_from(value: u32) -> Result<Self, Self::Error> {\n-        if value <= 16777215 {\n-            Ok(Self(value))\n-        } else {\n-            Err(Error::InvalidU24(value))\n-        }\n-    }\n-}\n-\n-impl From<U24> for u32 {\n-    fn from(v: U24) -> Self {\n-        v.0\n-    }\n-}"
      },
      {
        "sha": "162c0499e2f844c7885924bd09a9cd849cdc4e24",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 44,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,44 +0,0 @@\n-use crate::codec::{GetSize, SizeHint};\n-use crate::Error;\n-mod non_copy_data_types;\n-\n-mod copy_data_types;\n-use crate::codec::decodable::FieldMarker;\n-pub use copy_data_types::U24;\n-pub use non_copy_data_types::{\n-    Bytes, Inner, PubKey, Seq0255, Seq064K, Signature, Str0255, Str032, B016M, B0255, B032, B064K,\n-    U256,\n-};\n-\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::{Error as E, Read, Write};\n-\n-pub trait Sv2DataType<'a>: Sized + SizeHint + GetSize + Into<FieldMarker> {\n-    fn from_bytes_(data: &'a mut [u8]) -> Result<Self, Error> {\n-        Self::size_hint(data, 0)?;\n-        Ok(Self::from_bytes_unchecked(data))\n-    }\n-\n-    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self;\n-\n-    fn from_vec_(data: Vec<u8>) -> Result<Self, Error>;\n-\n-    fn from_vec_unchecked(data: Vec<u8>) -> Self;\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn from_reader_(reader: &mut impl Read) -> Result<Self, Error>;\n-\n-    fn to_slice(&'a self, dst: &mut [u8]) -> Result<usize, Error> {\n-        if dst.len() >= self.get_size() {\n-            self.to_slice_unchecked(dst);\n-            Ok(self.get_size())\n-        } else {\n-            Err(Error::WriteError(self.get_size(), dst.len()))\n-        }\n-    }\n-\n-    fn to_slice_unchecked(&'a self, dst: &mut [u8]);\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E>;\n-}"
      },
      {
        "sha": "f889d6f21c0df7ef505787363c51ec384c62520b",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 256,
        "changes": 256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,256 +0,0 @@\n-use super::IntoOwned;\n-use crate::codec::{GetSize, SizeHint};\n-use crate::datatypes::Sv2DataType;\n-use crate::Error;\n-use core::convert::TryFrom;\n-\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::{Error as E, Read, Write};\n-\n-#[repr(C)]\n-#[derive(Debug, Eq, PartialEq)]\n-pub enum Inner<\n-    'a,\n-    const ISFIXED: bool,\n-    const SIZE: usize,\n-    const HEADERSIZE: usize,\n-    const MAXSIZE: usize,\n-> {\n-    Ref(&'a mut [u8]),\n-    Owned(Vec<u8>),\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    fn expected_lenght(data: &[u8]) -> Result<usize, Error> {\n-        let expected_lenght = match ISFIXED {\n-            true => Self::expected_lenght_fixed(),\n-            false => Self::expected_lenght_variable(data)?,\n-        };\n-        if ISFIXED || expected_lenght <= MAXSIZE {\n-            Ok(expected_lenght)\n-        } else {\n-            Err(Error::ReadError(data.len(), MAXSIZE))\n-        }\n-    }\n-\n-    fn expected_lenght_fixed() -> usize {\n-        SIZE\n-    }\n-\n-    fn expected_lenght_variable(data: &[u8]) -> Result<usize, Error> {\n-        if data.len() >= HEADERSIZE {\n-            let size = match HEADERSIZE {\n-                0 => Ok(data.len()),\n-                1 => Ok(data[0] as usize),\n-                2 => Ok(u16::from_le_bytes([data[0], data[1]]) as usize),\n-                3 => Ok(u32::from_le_bytes([data[0], data[1], data[2], 0]) as usize),\n-                _ => unimplemented!(),\n-            };\n-            size.map(|x| x + HEADERSIZE)\n-        } else {\n-            Err(Error::ReadError(data.len(), HEADERSIZE))\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn expected_lenght_for_reader(mut reader: impl Read) -> Result<usize, Error> {\n-        if ISFIXED {\n-            Ok(SIZE)\n-        } else {\n-            let mut header = [0_u8; HEADERSIZE];\n-            reader.read_exact(&mut header)?;\n-            let expected_lenght = match HEADERSIZE {\n-                1 => header[0] as usize,\n-                2 => u16::from_le_bytes([header[0], header[1]]) as usize,\n-                3 => u32::from_le_bytes([header[0], header[1], header[2], 0]) as usize,\n-                _ => unimplemented!(),\n-            };\n-            if expected_lenght <= MAXSIZE {\n-                Ok(expected_lenght)\n-            } else {\n-                Err(Error::ReadError(expected_lenght, MAXSIZE))\n-            }\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        match (self, ISFIXED) {\n-            (Inner::Ref(data), false) => data.len(),\n-            (Inner::Owned(data), false) => data.len(),\n-            (_, true) => 1,\n-        }\n-    }\n-\n-    fn get_header(&self) -> Vec<u8> {\n-        if HEADERSIZE == 0 {\n-            Vec::new()\n-        } else {\n-            let len = self.len();\n-            len.to_le_bytes().into()\n-        }\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    TryFrom<&'a mut [u8]> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    type Error = Error;\n-\n-    fn try_from(value: &'a mut [u8]) -> Result<Self, Self::Error> {\n-        if ISFIXED && value.len() == SIZE {\n-            Ok(Self::Ref(value))\n-        } else if ISFIXED {\n-            Err(Error::Todo)\n-        } else if value.len() <= MAXSIZE {\n-            Ok(Self::Ref(value))\n-        } else {\n-            Err(Error::Todo)\n-        }\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    TryFrom<Vec<u8>> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    type Error = Error;\n-\n-    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {\n-        if ISFIXED && value.len() == SIZE {\n-            Ok(Self::Owned(value))\n-        } else if ISFIXED {\n-            Err(Error::Todo)\n-        } else if value.len() <= MAXSIZE {\n-            Ok(Self::Owned(value))\n-        } else {\n-            Err(Error::Todo)\n-        }\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    GetSize for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    fn get_size(&self) -> usize {\n-        match self {\n-            Inner::Ref(data) => data.len() + HEADERSIZE,\n-            Inner::Owned(data) => data.len() + HEADERSIZE,\n-        }\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const HEADERSIZE: usize, const SIZE: usize, const MAXSIZE: usize>\n-    SizeHint for Inner<'a, ISFIXED, HEADERSIZE, SIZE, MAXSIZE>\n-{\n-    fn size_hint(data: &[u8], offset: usize) -> Result<usize, Error> {\n-        Self::expected_lenght(&data[offset..])\n-    }\n-\n-    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n-        Self::expected_lenght(&data[offset..])\n-    }\n-}\n-use crate::codec::decodable::FieldMarker;\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    Sv2DataType<'a> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-where\n-    Self: Into<FieldMarker>,\n-{\n-    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n-        if ISFIXED {\n-            Self::Ref(data)\n-        } else {\n-            Self::Ref(&mut data[HEADERSIZE..])\n-        }\n-    }\n-\n-    fn from_vec_(data: Vec<u8>) -> Result<Self, Error> {\n-        Self::size_hint(&data, 0)?;\n-        Ok(Self::Owned(data))\n-    }\n-\n-    fn from_vec_unchecked(data: Vec<u8>) -> Self {\n-        Self::Owned(data)\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn from_reader_(mut reader: &mut impl Read) -> Result<Self, Error> {\n-        let size = Self::expected_lenght_for_reader(&mut reader)?;\n-\n-        let mut dst = vec![0; size];\n-\n-        reader.read_exact(&mut dst)?;\n-        Ok(Self::from_vec_unchecked(dst))\n-    }\n-\n-    fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n-        let size = self.get_size();\n-        let header = self.get_header();\n-        dst[0..HEADERSIZE].copy_from_slice(&header[..HEADERSIZE]);\n-        match self {\n-            Inner::Ref(data) => {\n-                let dst = &mut dst[0..size];\n-                dst[HEADERSIZE..].copy_from_slice(data);\n-            }\n-            Inner::Owned(data) => {\n-                let dst = &mut dst[0..size];\n-                dst[HEADERSIZE..].copy_from_slice(data);\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"no_std\"))]\n-    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n-        match self {\n-            Inner::Ref(data) => {\n-                writer.write_all(data)?;\n-            }\n-            Inner::Owned(data) => {\n-                writer.write_all(data)?;\n-            }\n-        };\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    IntoOwned for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    fn into_owned(self) -> Self {\n-        match self {\n-            Inner::Ref(data) => {\n-                let v: Vec<u8> = data.into();\n-                Self::Owned(v)\n-            }\n-            Inner::Owned(_) => self,\n-        }\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    Clone for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    fn clone(&self) -> Self {\n-        match self {\n-            Inner::Ref(data) => {\n-                let mut v = Vec::with_capacity(data.len());\n-                v.extend_from_slice(data);\n-                Self::Owned(v)\n-            }\n-            Inner::Owned(data) => Inner::Owned(data.clone()),\n-        }\n-    }\n-}\n-\n-impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n-    AsRef<[u8]> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n-{\n-    fn as_ref(&self) -> &[u8] {\n-        match self {\n-            Inner::Ref(r) => &r[..],\n-            Inner::Owned(r) => &r[..],\n-        }\n-    }\n-}"
      },
      {
        "sha": "483cf3bc6c76500410f3285ba51606ca43138b48",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 26,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,26 +0,0 @@\n-mod inner;\n-mod seq_inner;\n-\n-trait IntoOwned {\n-    fn into_owned(self) -> Self;\n-}\n-\n-pub use inner::Inner;\n-pub use seq_inner::{Seq0255, Seq064K};\n-\n-pub type U256<'a> = Inner<'a, true, 32, 0, 0>;\n-pub type PubKey<'a> = Inner<'a, true, 32, 0, 0>;\n-pub type Signature<'a> = Inner<'a, true, 64, 0, 0>;\n-pub type B032<'a> = Inner<'a, false, 1, 1, 32>;\n-pub type B0255<'a> = Inner<'a, false, 1, 1, 255>;\n-pub type Str032<'a> = Inner<'a, false, 1, 1, 32>;\n-pub type Str0255<'a> = Inner<'a, false, 1, 1, 255>;\n-pub type B064K<'a> = Inner<'a, false, 1, 2, { u16::MAX as usize }>;\n-pub type B016M<'a> = Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>;\n-pub type Bytes<'a> = Inner<'a, false, 0, 0, { usize::MAX }>;\n-\n-impl<'decoder> From<[u8; 32]> for U256<'decoder> {\n-    fn from(v: [u8; 32]) -> Self {\n-        Inner::Owned(v.into())\n-    }\n-}"
      },
      {
        "sha": "3706345a9e5c12eff44ab184d69df2caafd3aae3",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 229,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,229 +0,0 @@\n-use crate::codec::decodable::{Decodable, DecodableField, FieldMarker, GetMarker, PrimitiveMarker};\n-use crate::codec::encodable::{EncodableField, EncodablePrimitive};\n-use crate::codec::GetSize;\n-use crate::datatypes::Sv2DataType;\n-use crate::datatypes::*;\n-use crate::Error;\n-use core::marker::PhantomData;\n-\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::Read;\n-\n-/// The liftime is here only for type compatibility with serde-sv2\n-#[repr(C)]\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct Seq0255<'a, T>(pub(crate) Vec<T>, PhantomData<&'a T>);\n-\n-impl<'a, T: 'a> Seq0255<'a, T> {\n-    const HEADERSIZE: usize = 1;\n-\n-    /// Return the len of the inner vector\n-    fn expected_len(data: &[u8]) -> Result<usize, Error> {\n-        if data.len() >= Self::HEADERSIZE {\n-            Ok(data[0] as usize)\n-        } else {\n-            Err(Error::ReadError(data.len(), Self::HEADERSIZE))\n-        }\n-    }\n-\n-    pub fn new(inner: Vec<T>) -> Result<Self, Error> {\n-        if inner.len() <= 255 {\n-            Ok(Self(inner, PhantomData))\n-        } else {\n-            Err(Error::Todo)\n-        }\n-    }\n-\n-    //pub fn try_from_slice(inner: &'a mut [T]) -> Result<Self, Error> {\n-    //    if inner.len() <= 255 {\n-    //        let inner_: Vec<T> = vec![];\n-    //        for v in inner {\n-    //            inner_.push(v);\n-    //        }\n-    //        Ok(Self(inner_, PhantomData))\n-    //    } else {\n-    //        Err(Error::Todo)\n-    //    }\n-    //}\n-}\n-\n-impl<'a, T: GetSize> GetSize for Seq0255<'a, T> {\n-    fn get_size(&self) -> usize {\n-        let mut size = Self::HEADERSIZE;\n-        for with_size in &self.0 {\n-            size += with_size.get_size()\n-        }\n-        size\n-    }\n-}\n-\n-/// The liftime is here only for type compatibility with serde-sv2\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct Seq064K<'a, T>(pub(crate) Vec<T>, PhantomData<&'a T>);\n-\n-impl<'a, T: 'a> Seq064K<'a, T> {\n-    const HEADERSIZE: usize = 2;\n-\n-    /// Return the len of the inner vector\n-    fn expected_len(data: &[u8]) -> Result<usize, Error> {\n-        if data.len() >= Self::HEADERSIZE {\n-            Ok(u16::from_le_bytes([data[0], data[1]]) as usize)\n-        } else {\n-            Err(Error::ReadError(data.len(), Self::HEADERSIZE))\n-        }\n-    }\n-\n-    pub fn new(inner: Vec<T>) -> Result<Self, Error> {\n-        if inner.len() <= 65535 {\n-            Ok(Self(inner, PhantomData))\n-        } else {\n-            Err(Error::Todo)\n-        }\n-    }\n-}\n-\n-impl<'a, T: GetSize> GetSize for Seq064K<'a, T> {\n-    fn get_size(&self) -> usize {\n-        let mut size = Self::HEADERSIZE;\n-        for with_size in &self.0 {\n-            size += with_size.get_size()\n-        }\n-        size\n-    }\n-}\n-\n-macro_rules! impl_codec_for_sequence {\n-    ($a:ty) => {\n-        impl<'a, T: 'a + Sv2DataType<'a> + GetMarker + GetSize + Decodable<'a>> Decodable<'a>\n-            for $a\n-        {\n-            fn get_structure(\n-                data: &[u8],\n-            ) -> Result<Vec<crate::codec::decodable::FieldMarker>, Error> {\n-                let len = Self::expected_len(data)?;\n-                let mut inner = Vec::with_capacity(len + Self::HEADERSIZE);\n-                for _ in 0..Self::HEADERSIZE {\n-                    inner.push(FieldMarker::Primitive(PrimitiveMarker::U8));\n-                }\n-                let inner_type = T::get_marker();\n-                inner.resize(len + Self::HEADERSIZE, inner_type);\n-                Ok(inner)\n-            }\n-\n-            fn from_decoded_fields(\n-                data: Vec<crate::codec::decodable::DecodableField<'a>>,\n-            ) -> Result<Self, Error> {\n-                let mut inner: Vec<T> = Vec::with_capacity(data.len());\n-                let mut i = 0;\n-                for element in data {\n-                    if i >= Self::HEADERSIZE {\n-                        match element {\n-                            DecodableField::Primitive(p) => {\n-                                let element =\n-                                    T::from_decoded_fields(vec![DecodableField::Primitive(p)]);\n-                                inner.push(element?)\n-                            }\n-                            DecodableField::Struct(_) => unimplemented!(),\n-                        }\n-                    }\n-                    i += 1;\n-                }\n-                Ok(Self(inner, PhantomData))\n-            }\n-\n-            fn from_bytes(data: &'a mut [u8]) -> Result<Self, Error> {\n-                let len = Self::expected_len(data)?;\n-\n-                let mut inner = Vec::new();\n-                let mut tail = &mut data[Self::HEADERSIZE..];\n-\n-                for _ in 0..len {\n-                    let element_size = T::size_hint(tail, 0)?;\n-                    let (head, t) = tail.split_at_mut(element_size);\n-                    tail = t;\n-                    inner.push(T::from_bytes_unchecked(head));\n-                }\n-                Ok(Self(inner, PhantomData))\n-            }\n-\n-            #[cfg(not(feature = \"no_std\"))]\n-            fn from_reader(reader: &mut impl Read) -> Result<Self, Error> {\n-                let mut header = vec![0; Self::HEADERSIZE];\n-                reader.read_exact(&mut header)?;\n-\n-                let len = Self::expected_len(&header)?;\n-\n-                let mut inner = Vec::new();\n-\n-                for _ in 0..len {\n-                    inner.push(T::from_reader_(reader)?);\n-                }\n-                Ok(Self(inner, PhantomData))\n-            }\n-        }\n-    };\n-}\n-\n-impl_codec_for_sequence!(Seq0255<'a, T>);\n-impl_codec_for_sequence!(Seq064K<'a, T>);\n-\n-macro_rules! impl_into_encodable_field_for_seq {\n-    ($a:ty) => {\n-        impl<'a> From<Seq064K<'a, $a>> for EncodableField<'a> {\n-            fn from(v: Seq064K<'a, $a>) -> Self {\n-                let inner_len = v.0.len() as u16;\n-                let mut as_encodable: Vec<EncodableField> =\n-                    Vec::with_capacity((inner_len + 2) as usize);\n-                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n-                    inner_len.to_le_bytes()[0],\n-                )));\n-                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n-                    inner_len.to_le_bytes()[1],\n-                )));\n-                for element in v.0 {\n-                    as_encodable.push(element.into());\n-                }\n-                EncodableField::Struct(as_encodable)\n-            }\n-        }\n-\n-        impl<'a> From<Seq0255<'a, $a>> for EncodableField<'a> {\n-            fn from(v: Seq0255<$a>) -> Self {\n-                let inner_len = v.0.len() as u8;\n-                let mut as_encodable: Vec<EncodableField> =\n-                    Vec::with_capacity((inner_len + 1) as usize);\n-                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n-                    inner_len,\n-                )));\n-                for element in v.0 {\n-                    as_encodable.push(element.into());\n-                }\n-                EncodableField::Struct(as_encodable)\n-            }\n-        }\n-    };\n-}\n-\n-impl_into_encodable_field_for_seq!(bool);\n-impl_into_encodable_field_for_seq!(u8);\n-impl_into_encodable_field_for_seq!(u16);\n-impl_into_encodable_field_for_seq!(U24);\n-impl_into_encodable_field_for_seq!(u32);\n-impl_into_encodable_field_for_seq!(u64);\n-impl_into_encodable_field_for_seq!(U256<'a>);\n-impl_into_encodable_field_for_seq!(Signature<'a>);\n-impl_into_encodable_field_for_seq!(B0255<'a>);\n-impl_into_encodable_field_for_seq!(B064K<'a>);\n-impl_into_encodable_field_for_seq!(B016M<'a>);\n-\n-impl<'a, T> From<Seq0255<'a, T>> for Vec<T> {\n-    fn from(v: Seq0255<'a, T>) -> Self {\n-        v.0\n-    }\n-}\n-\n-impl<'a, T> From<Seq064K<'a, T>> for Vec<T> {\n-    fn from(v: Seq064K<'a, T>) -> Self {\n-        v.0\n-    }\n-}"
      },
      {
        "sha": "b2c3214582104ac41eb1412082beb417686fa371",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 297,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/codec/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,297 +0,0 @@\n-//! ```txt\n-//! SERDE    <-> Sv2\n-//! bool     <-> BOOL\n-//! u8       <-> U8\n-//! u16      <-> U16\n-//! U24      <-> U24\n-//! u32      <-> u32\n-//! f32      <-> f32 // todo not in the spec but used\n-//! u64      <-> u64 // todo not in the spec but used\n-//! U256     <-> U256\n-//! Str0255  <-> STRO_255\n-//! Str032   <-> STRO_32 // todo not in the spec but used\n-//! Signature<-> SIGNATURE\n-//! B032     <-> B0_32 // todo not in the spec but used\n-//! B0255    <-> B0_255\n-//! B064K    <-> B0_64K\n-//! B016M    <-> B0_16M\n-//! [u8]     <-> BYTES\n-//! Pubkey   <-> PUBKEY\n-//! Seq0255  <-> SEQ0_255[T]\n-//! Seq064K  <-> SEQ0_64K[T]\n-//! ```\n-#![cfg_attr(feature = \"no_std\", no_std)]\n-use core::convert::TryInto;\n-\n-#[cfg(not(feature = \"no_std\"))]\n-use std::io::{Error as E, ErrorKind};\n-\n-#[macro_use]\n-extern crate alloc;\n-\n-mod codec;\n-mod datatypes;\n-pub use datatypes::{\n-    Bytes, PubKey, Seq0255, Seq064K, Signature, Str0255, Str032, B016M, B0255, B032, B064K, U24,\n-    U256,\n-};\n-\n-pub use crate::codec::decodable::Decodable;\n-pub use crate::codec::encodable::{Encodable, EncodableField};\n-pub use crate::codec::GetSize;\n-pub use crate::codec::SizeHint;\n-\n-#[allow(clippy::wrong_self_convention)]\n-pub fn to_bytes<T: Encodable + GetSize>(src: T) -> Result<Vec<u8>, Error> {\n-    let mut result = vec![0_u8; src.get_size()];\n-    src.to_bytes(&mut result)?;\n-    Ok(result)\n-}\n-\n-#[allow(clippy::wrong_self_convention)]\n-pub fn to_writer<T: Encodable>(src: T, dst: &mut [u8]) -> Result<(), Error> {\n-    src.to_bytes(dst)?;\n-    Ok(())\n-}\n-\n-pub fn from_bytes<'a, T: Decodable<'a>>(data: &'a mut [u8]) -> Result<T, Error> {\n-    T::from_bytes(data)\n-}\n-\n-pub mod decodable {\n-    pub use crate::codec::decodable::Decodable;\n-    pub use crate::codec::decodable::DecodableField;\n-    pub use crate::codec::decodable::FieldMarker;\n-    //pub use crate::codec::decodable::PrimitiveMarker;\n-}\n-\n-pub mod encodable {\n-    pub use crate::codec::encodable::Encodable;\n-    pub use crate::codec::encodable::EncodableField;\n-}\n-\n-\n-#[derive(Debug)]\n-pub enum Error {\n-    OutOfBound,\n-    NotABool(u8),\n-    /// -> (expected size, actual size)\n-    WriteError(usize, usize),\n-    U24TooBig(u32),\n-    InvalidSignatureSize(usize),\n-    InvalidU256(usize),\n-    InvalidU24(u32),\n-    InvalidB0255Size(usize),\n-    InvalidB064KSize(usize),\n-    InvalidB016MSize(usize),\n-    InvalidSeq0255Size(usize),\n-    PrimitiveConversionError,\n-    DecodableConversionError,\n-    UnInitializedDecoder,\n-    #[cfg(not(feature = \"no_std\"))]\n-    IoError(E),\n-    ReadError(usize, usize),\n-    Todo,\n-}\n-\n-#[cfg(not(feature = \"no_std\"))]\n-impl From<E> for Error {\n-    fn from(v: E) -> Self {\n-        match v.kind() {\n-            ErrorKind::UnexpectedEof => Error::OutOfBound,\n-            _ => Error::IoError(v),\n-        }\n-    }\n-}\n-\n-/// Vec<u8> is used as the Sv2 type Bytes\n-impl GetSize for Vec<u8> {\n-    fn get_size(&self) -> usize {\n-        self.len()\n-    }\n-}\n-\n-impl<'a> From<Vec<u8>> for EncodableField<'a> {\n-    fn from(v: Vec<u8>) -> Self {\n-        let bytes: Bytes = v.try_into().unwrap();\n-        crate::encodable::EncodableField::Primitive(\n-            crate::codec::encodable::EncodablePrimitive::Bytes(bytes),\n-        )\n-    }\n-}\n-\n-#[repr(C)]\n-#[derive(Debug, Clone, Copy)]\n-pub struct CVec {\n-    data: *mut u8,\n-    len: usize,\n-    capacity: usize,\n-}\n-\n-impl CVec {\n-    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe { core::slice::from_raw_parts_mut(self.data, self.len) }\n-    }\n-\n-    /// Used when we need to fill a buffer allocated in rust from C.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function construct a CVec without taking ownership of the pointed buffer so if the\n-    /// owner drop them the CVec will point to garbage.\n-    #[allow(clippy::wrong_self_convention)]\n-    pub fn as_shared_buffer(v: &mut [u8]) -> Self {\n-        let (data, len) = (v.as_mut_ptr(), v.len());\n-        Self {\n-            data,\n-            len,\n-            capacity: len,\n-        }\n-    }\n-}\n-\n-impl From<&[u8]> for CVec {\n-    fn from(v: &[u8]) -> Self {\n-        let mut buffer: Vec<u8> = vec![0; v.len()];\n-        buffer.copy_from_slice(v);\n-\n-        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n-        let len = buffer.len();\n-        let ptr = buffer.as_mut_ptr();\n-        std::mem::forget(buffer);\n-\n-        CVec {\n-            data: ptr,\n-            len,\n-            capacity: len,\n-        }\n-    }\n-}\n-\n-/// Given a C allocated buffer return a rust allocated CVec\n-///\n-/// # Safety\n-///\n-/// TODO\n-#[no_mangle]\n-pub unsafe extern \"C\" fn cvec_from_buffer(data: *const u8, len: usize) -> CVec {\n-    let input = std::slice::from_raw_parts(data, len);\n-\n-    let mut buffer: Vec<u8> = vec![0; len];\n-    buffer.copy_from_slice(input);\n-\n-    // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n-    let len = buffer.len();\n-    let ptr = buffer.as_mut_ptr();\n-    std::mem::forget(buffer);\n-\n-    CVec {\n-        data: ptr,\n-        len,\n-        capacity: len,\n-    }\n-}\n-\n-#[repr(C)]\n-#[derive(Debug, Clone, Copy)]\n-pub struct CVec2 {\n-    data: *mut CVec,\n-    len: usize,\n-    capacity: usize,\n-}\n-\n-impl CVec2 {\n-    pub fn as_mut_slice(&mut self) -> &mut [CVec] {\n-        unsafe { core::slice::from_raw_parts_mut(self.data, self.len) }\n-    }\n-}\n-impl From<CVec2> for Vec<CVec> {\n-    fn from(v: CVec2) -> Self {\n-        unsafe { Vec::from_raw_parts(v.data, v.len, v.capacity) }\n-    }\n-}\n-\n-pub fn free_vec(buf: &mut CVec) {\n-    let _: Vec<u8> = unsafe { Vec::from_raw_parts(buf.data, buf.len, buf.capacity) };\n-}\n-\n-pub fn free_vec_2(buf: &mut CVec2) {\n-    let vs: Vec<CVec> = unsafe { Vec::from_raw_parts(buf.data, buf.len, buf.capacity) };\n-    for mut s in vs {\n-        free_vec(&mut s)\n-    }\n-}\n-\n-impl<'a, const A: bool, const B: usize, const C: usize, const D: usize>\n-    From<datatypes::Inner<'a, A, B, C, D>> for CVec\n-{\n-    fn from(v: datatypes::Inner<'a, A, B, C, D>) -> Self {\n-        let (ptr, len, cap): (*mut u8, usize, usize) = match v {\n-            datatypes::Inner::Ref(inner) => {\n-                // Data is copied in a vector that then will be forgetted from the allocator,\n-                // cause the owner of the data is going to be dropped by rust\n-                let mut inner: Vec<u8> = inner.into();\n-\n-                // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n-                let len = inner.len();\n-                let cap = inner.capacity();\n-                let ptr = inner.as_mut_ptr();\n-                std::mem::forget(inner);\n-\n-                (ptr, len, cap)\n-            }\n-            datatypes::Inner::Owned(mut inner) => {\n-                // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n-                let len = inner.len();\n-                let cap = inner.capacity();\n-                let ptr = inner.as_mut_ptr();\n-                std::mem::forget(inner);\n-\n-                (ptr, len, cap)\n-            }\n-        };\n-        Self {\n-            data: ptr,\n-            len,\n-            capacity: cap,\n-        }\n-    }\n-}\n-\n-impl<'a, T: Into<CVec>> From<Seq0255<'a, T>> for CVec2 {\n-    fn from(v: Seq0255<'a, T>) -> Self {\n-        let mut v: Vec<CVec> = v.0.into_iter().map(|x| x.into()).collect();\n-        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n-        let len = v.len();\n-        let capacity = v.capacity();\n-        let data = v.as_mut_ptr();\n-        std::mem::forget(v);\n-        Self {\n-            data,\n-            len,\n-            capacity,\n-        }\n-    }\n-}\n-impl<'a, T: Into<CVec>> From<Seq064K<'a, T>> for CVec2 {\n-    fn from(v: Seq064K<'a, T>) -> Self {\n-        let mut v: Vec<CVec> = v.0.into_iter().map(|x| x.into()).collect();\n-        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n-        let len = v.len();\n-        let capacity = v.capacity();\n-        let data = v.as_mut_ptr();\n-        std::mem::forget(v);\n-        Self {\n-            data,\n-            len,\n-            capacity,\n-        }\n-    }\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_u24(_a: U24) {}\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_cvec(_a: CVec) {}\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_cvec2(_a: CVec2) {}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/.gitignore?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1 +0,0 @@\n-/target"
      },
      {
        "sha": "363bcb5af3b130eee4578a200ae8f850a2000079",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "status": "removed",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,14 +0,0 @@\n-# This file is automatically @generated by Cargo.\n-# It is not intended for manual editing.\n-version = 3\n-\n-[[package]]\n-name = \"binary_codec_sv2\"\n-version = \"0.1.1\"\n-\n-[[package]]\n-name = \"derive_codec_sv2\"\n-version = \"0.1.1\"\n-dependencies = [\n- \"binary_codec_sv2\",\n-]"
      },
      {
        "sha": "05ac6359403da3c4c08dc1d7a2bf3ebbe3441ef5",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,15 +0,0 @@\n-[package]\n-name = \"derive_codec_sv2\"\n-version = \"0.1.1\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Derive macro for Sv2 binary format serializer and deserializer\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-binary_codec_sv2 = {version = \"0.1.1\", path=\"../codec\"}\n-\n-[lib]\n-proc-macro = true"
      },
      {
        "sha": "7d16cf152f342fffe8caa07cd972005322c03b85",
        "filename": "src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 387,
        "changes": 387,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,387 +0,0 @@\n-extern crate proc_macro;\n-use core::iter::FromIterator;\n-use proc_macro::{Group, TokenStream, TokenTree};\n-\n-fn remove_attributes(item: TokenStream) -> TokenStream {\n-    let stream = item.into_iter();\n-    let mut is_attribute = false;\n-    let mut result = Vec::new();\n-\n-    for next in stream {\n-        match next.clone() {\n-            TokenTree::Punct(p) => {\n-                if p.to_string() == \"#\" {\n-                    is_attribute = true;\n-                } else {\n-                    result.push(next.clone());\n-                }\n-            }\n-            TokenTree::Group(g) => {\n-                if is_attribute {\n-                    continue;\n-                } else {\n-                    let delimiter = g.delimiter();\n-                    let cleaned_group = remove_attributes(g.stream());\n-                    let cleaned_group = TokenTree::Group(Group::new(delimiter, cleaned_group));\n-                    result.push(cleaned_group);\n-                }\n-            }\n-            _ => {\n-                is_attribute = false;\n-                result.push(next.clone());\n-            }\n-        }\n-    }\n-\n-    TokenStream::from_iter(result)\n-}\n-\n-enum ParserState {\n-    Name,\n-    Type,\n-    //       open angle brackets\n-    Generics(usize),\n-}\n-fn parse_struct_fields(group: Vec<TokenTree>) -> Vec<ParsedField> {\n-    let mut fields = Vec::new();\n-    let mut field_ = ParsedField::new();\n-    let mut field_parser_state = ParserState::Name;\n-    for token in group {\n-        match (token, &field_parser_state) {\n-            (TokenTree::Ident(i), ParserState::Name) => {\n-                if i.to_string() == \"pub\" {\n-                    continue;\n-                } else {\n-                    field_.name = i.to_string();\n-                }\n-            }\n-            (TokenTree::Ident(i), ParserState::Type) => {\n-                field_.type_ = i.to_string();\n-            }\n-            (TokenTree::Ident(i), ParserState::Generics(_)) => {\n-                field_.generics = format!(\"{}{}\", field_.generics, i.to_string());\n-            }\n-            (TokenTree::Punct(p), ParserState::Name) => {\n-                if p.to_string() == \":\" {\n-                    field_parser_state = ParserState::Type\n-                } else {\n-                    panic!(\n-                        \"Unexpected token '{}' in parsing {:#?}\",\n-                        p.to_string(),\n-                        field_\n-                    );\n-                }\n-            }\n-            (TokenTree::Punct(p), ParserState::Type) => match p.to_string().as_ref() {\n-                \",\" => {\n-                    field_parser_state = ParserState::Name;\n-                    fields.push(field_.clone());\n-                    field_ = ParsedField::new();\n-                }\n-                \"<\" => {\n-                    field_.generics = \"<\".to_string();\n-                    field_parser_state = ParserState::Generics(0);\n-                }\n-                _ => panic!(\n-                    \"Unexpected token '{}' in parsing {:#?}\",\n-                    p.to_string(),\n-                    field_\n-                ),\n-            },\n-            (TokenTree::Punct(p), ParserState::Generics(open_brackets)) => {\n-                match p.to_string().as_ref() {\n-                    \"'\" => {\n-                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n-                    }\n-                    \"<\" => {\n-                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n-                        field_parser_state = ParserState::Generics(open_brackets + 1);\n-                    }\n-                    \">\" => {\n-                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n-                        if open_brackets == &0 {\n-                            field_parser_state = ParserState::Type\n-                        } else {\n-                            field_parser_state = ParserState::Generics(open_brackets - 1);\n-                        }\n-                    }\n-                    _ => {\n-                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n-                    }\n-                }\n-            }\n-            _ => panic!(\"Unexpected token\"),\n-        }\n-    }\n-    fields\n-}\n-\n-#[derive(Clone, Debug)]\n-struct ParsedField {\n-    name: String,\n-    type_: String,\n-    generics: String,\n-}\n-\n-impl ParsedField {\n-    pub fn new() -> Self {\n-        ParsedField {\n-            name: \"\".to_string(),\n-            type_: \"\".to_string(),\n-            generics: \"\".to_string(),\n-        }\n-    }\n-\n-    pub fn get_generics(&self) -> String {\n-        if self.generics == \"<'decoder>\" || self.generics.is_empty() {\n-            \"\".to_string()\n-        } else {\n-            format!(\"::{}\", self.generics.clone())\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-struct ParsedStruct {\n-    pub name: String,\n-    pub generics: String,\n-    pub fields: Vec<ParsedField>,\n-}\n-\n-// impl ParsedStruct {\n-//     pub fn new() -> Self {\n-//         ParsedStruct {\n-//             name: \"\".to_string(),\n-//             generics: \"\".to_string(),\n-//             fields: Vec::new(),\n-//         }\n-//     }\n-// }\n-\n-fn get_struct_properties(item: TokenStream) -> ParsedStruct {\n-    let item = remove_attributes(item);\n-    let mut stream = item.into_iter();\n-\n-    // Check if the stream is a struct\n-    loop {\n-        match stream.next().expect(\"Stream not a struct\") {\n-            TokenTree::Ident(i) => {\n-                if i.to_string() == \"struct\" {\n-                    break;\n-                }\n-            }\n-            _ => continue,\n-        }\n-    }\n-\n-    // Get the struct name\n-    let struct_name = match stream.next().expect(\"Struct has no name\") {\n-        TokenTree::Ident(i) => i.to_string(),\n-        _ => panic!(\"Strcut has no name\"),\n-    };\n-\n-    let mut struct_generics = \"\".to_string();\n-    let group: Vec<TokenTree>;\n-\n-    // Get the struct generics if any\n-    loop {\n-        match stream\n-            .next()\n-            .unwrap_or_else(|| panic!(\"Struct {} has no fields\", struct_name))\n-        {\n-            TokenTree::Group(g) => {\n-                group = g.stream().into_iter().collect();\n-                break;\n-            }\n-            TokenTree::Punct(p) => {\n-                struct_generics = format!(\"{}{}\", struct_generics, p.to_string());\n-            }\n-            TokenTree::Ident(i) => {\n-                struct_generics = format!(\"{}{}\", struct_generics, i.to_string());\n-            }\n-            _ => panic!(\"Struct {} has no fields\", struct_name),\n-        };\n-    }\n-\n-    let fields = parse_struct_fields(group);\n-\n-    ParsedStruct {\n-        name: struct_name,\n-        generics: struct_generics,\n-        fields,\n-    }\n-}\n-\n-#[proc_macro_derive(Decodable)]\n-pub fn decodable(item: TokenStream) -> TokenStream {\n-    let parsed_struct = get_struct_properties(item);\n-\n-    let mut derive_fields = String::new();\n-\n-    for f in parsed_struct.fields.clone() {\n-        let field = format!(\n-            \"\n-            let {}: Vec<FieldMarker> = {}{}::get_structure(& data[offset..])?;\n-            offset += {}.size_hint_(&data, offset)?;\n-            let {} =  {}.into();\n-            fields.push({});\n-            \",\n-            f.name,\n-            f.type_,\n-            f.get_generics(),\n-            f.name,\n-            f.name,\n-            f.name,\n-            f.name\n-        );\n-        derive_fields.push_str(&field)\n-    }\n-\n-    let mut derive_decoded_fields = String::new();\n-    let mut fields = parsed_struct.fields.clone();\n-\n-    // Reverse the fields as they are popped out from the end of the vector but we want to pop out\n-    // from the front\n-    fields.reverse();\n-\n-    // Create Struct from fields\n-    for f in fields.clone() {\n-        let field = format!(\n-            \"\n-            {}: {}{}::from_decoded_fields(data.pop().unwrap().into())?,\n-            \",\n-            f.name,\n-            f.type_,\n-            f.get_generics()\n-        );\n-        derive_decoded_fields.push_str(&field)\n-    }\n-\n-    let impl_generics = if !parsed_struct.generics.is_empty() {\n-        parsed_struct.clone().generics\n-    } else {\n-        \"<'decoder>\".to_string()\n-    };\n-\n-    let result = format!(\n-        \"mod impl_parse_decodable_{} {{\n-\n-    use super::binary_codec_sv2::{{decodable::DecodableField, decodable::FieldMarker, Decodable, Error, SizeHint}};\n-    use super::*;\n-\n-    impl{} Decodable<'decoder> for {}{} {{\n-        fn get_structure(data: &[u8]) -> Result<Vec<FieldMarker>, Error> {{\n-            let mut fields = Vec::new();\n-            let mut offset = 0;\n-            {}\n-            Ok(fields)\n-        }}\n-\n-        fn from_decoded_fields(mut data: Vec<DecodableField<'decoder>>) -> Result<Self, Error> {{\n-            Ok(Self {{\n-                {}\n-            }})\n-        }}\n-    }}\n-    }}\",\n-        // imports\n-        parsed_struct.name.to_lowercase(),\n-        // derive decodable\n-        impl_generics,\n-        parsed_struct.name,\n-        parsed_struct.generics,\n-        derive_fields,\n-        derive_decoded_fields,\n-    );\n-    //println!(\"{}\", result);\n-\n-    result.parse().unwrap()\n-}\n-\n-#[proc_macro_derive(Encodable)]\n-pub fn encodable(item: TokenStream) -> TokenStream {\n-    let parsed_struct = get_struct_properties(item);\n-    let fields = parsed_struct.fields.clone();\n-\n-    let mut field_into_decoded_field = String::new();\n-\n-    // Create DecodableField from fields\n-    for f in fields.clone() {\n-        let field = format!(\n-            \"\n-            let val = v.{};\n-            fields.push(val.into());\n-            \",\n-            f.name\n-        );\n-        field_into_decoded_field.push_str(&field)\n-    }\n-\n-    let mut sizes = String::new();\n-\n-    for f in fields {\n-        let field = format!(\n-            \"\n-            size += self.{}.get_size();\n-            \",\n-            f.name\n-        );\n-        sizes.push_str(&field)\n-    }\n-    let impl_generics = if !parsed_struct.generics.is_empty() {\n-        parsed_struct.clone().generics\n-    } else {\n-        \"<'decoder>\".to_string()\n-    };\n-\n-    let result = format!(\n-        \"mod impl_parse_encodable_{} {{\n-\n-    use super::binary_codec_sv2::{{encodable::EncodableField, GetSize}};\n-    use super::{};\n-    extern crate alloc;\n-    use alloc::vec::Vec;\n-\n-    impl{} From<{}{}> for EncodableField<'decoder> {{\n-        fn from(v: {}{}) -> Self {{\n-            let mut fields: Vec<EncodableField> = Vec::new();\n-            {}\n-            Self::Struct(fields)\n-        }}\n-    }}\n-\n-\n-    impl{} GetSize for {}{} {{\n-        fn get_size(&self) -> usize {{\n-            let mut size = 0;\n-            {}\n-            size\n-        }}\n-    }}\n-\n-    }}\",\n-        // imports\n-        parsed_struct.name.to_lowercase(),\n-        parsed_struct.name,\n-        // impl From<Struct> for DecodableField\n-        impl_generics,\n-        parsed_struct.name,\n-        parsed_struct.generics,\n-        parsed_struct.name,\n-        parsed_struct.generics,\n-        field_into_decoded_field,\n-        // impl Encodable for Struct\n-        //impl{} Encodable<'decoder> for {}{} {{}}\n-        //impl_generics,\n-        //parsed_struct.name,\n-        //parsed_struct.generics,\n-        // impl GetSize for Struct\n-        impl_generics,\n-        parsed_struct.name,\n-        parsed_struct.generics,\n-        sizes,\n-    );\n-    //println!(\"{}\", result);\n-\n-    result.parse().unwrap()\n-}"
      },
      {
        "sha": "6f86a7ab2b08281e8f60b4dfc1f62ba9a7a08646",
        "filename": "src/rusty/codec-sv2/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 18,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,18 +0,0 @@\n-[package]\n-name = \"codec_sv2\"\n-version = \"0.1.3\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2 data format\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-[dependencies]\n-serde = { version = \"1.0.89\", default-features = false, optional = true }\n-framing_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/framing-sv2\" }\n-noise_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/noise-sv2\", optional=true}\n-binary_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/binary-sv2/binary-sv2\"}\n-const_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/const-sv2\"}\n-\n-[features]\n-with_serde = [\"binary_sv2/with_serde\", \"serde\", \"framing_sv2/with_serde\"]"
      },
      {
        "sha": "3df316f9cfc1b18bebb9d18b439f49c892b7f57f",
        "filename": "src/rusty/codec-sv2/src/buffer.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 71,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/buffer.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/buffer.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/buffer.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,71 +0,0 @@\n-use alloc::vec::Vec;\n-\n-pub trait Buffer {\n-    type Slice: AsMut<[u8]>;\n-\n-    fn get_writable(&mut self, len: usize) -> &mut [u8];\n-\n-    fn get_data_owned(&mut self) -> Self::Slice;\n-\n-    fn get_data_by_ref(&mut self, header_size: usize) -> &mut [u8];\n-\n-    fn len(&self) -> usize;\n-}\n-\n-#[derive(Debug)]\n-pub struct SlowAndCorrect {\n-    inner: Vec<u8>,\n-    cursor: usize,\n-}\n-\n-impl SlowAndCorrect {\n-    pub fn new() -> Self {\n-        Self {\n-            inner: Vec::new(),\n-            cursor: 0,\n-        }\n-    }\n-}\n-\n-impl Default for SlowAndCorrect {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl Buffer for SlowAndCorrect {\n-    type Slice = Vec<u8>;\n-\n-    #[inline]\n-    fn get_writable(&mut self, len: usize) -> &mut [u8] {\n-        let cursor = self.cursor;\n-        let len = self.cursor + len;\n-\n-        if len > self.inner.len() {\n-            self.inner.resize(len, 0)\n-        };\n-\n-        self.cursor = len;\n-\n-        &mut self.inner[cursor..len]\n-    }\n-\n-    #[inline]\n-    fn get_data_owned(&mut self) -> Vec<u8> {\n-        let mut tail = self.inner.split_off(self.cursor);\n-        core::mem::swap(&mut tail, &mut self.inner);\n-        let head = tail;\n-        self.cursor = 0;\n-        head\n-    }\n-\n-    #[inline]\n-    fn get_data_by_ref(&mut self, header_size: usize) -> &mut [u8] {\n-        &mut self.inner[..usize::min(header_size, self.cursor)]\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> usize {\n-        self.cursor\n-    }\n-}"
      },
      {
        "sha": "8cd6c81457b94b428098bb7a6f0571e8a07738ff",
        "filename": "src/rusty/codec-sv2/src/decoder.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 60,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/decoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/decoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/decoder.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,60 +0,0 @@\n-use binary_sv2::Serialize;\n-use core::marker::PhantomData;\n-use framing_sv2::framing2::{EitherFrame, Frame as F_, Sv2Frame};\n-use framing_sv2::header::Header;\n-\n-use crate::buffer::{Buffer, SlowAndCorrect};\n-use crate::error::{Error, Result};\n-\n-pub type StandardEitherFrame<T> = EitherFrame<T, <SlowAndCorrect as Buffer>::Slice>;\n-pub type StandardSv2Frame<T> = Sv2Frame<T, <SlowAndCorrect as Buffer>::Slice>;\n-pub type StandardDecoder<T> = WithoutNoise<SlowAndCorrect, T>;\n-\n-#[derive(Debug)]\n-pub struct WithoutNoise<B: Buffer, T: Serialize + binary_sv2::GetSize> {\n-    frame: PhantomData<T>,\n-    missing_b: usize,\n-    buffer: B,\n-}\n-\n-impl<T: Serialize + binary_sv2::GetSize, B: Buffer> WithoutNoise<B, T> {\n-    #[inline]\n-    pub fn next_frame(&mut self) -> Result<Sv2Frame<T, B::Slice>> {\n-        let len = self.buffer.len();\n-        let src = self.buffer.get_data_by_ref(len);\n-        let hint = Sv2Frame::<T, B::Slice>::size_hint(src) as usize;\n-\n-        match hint {\n-            0 => {\n-                self.missing_b = Header::SIZE;\n-                let src = self.buffer.get_data_owned();\n-                let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n-                Ok(frame)\n-            }\n-            _ => {\n-                self.missing_b = hint;\n-                Err(Error::MissingBytes(self.missing_b))\n-            }\n-        }\n-    }\n-\n-    pub fn writable(&mut self) -> &mut [u8] {\n-        self.buffer.get_writable(self.missing_b)\n-    }\n-}\n-\n-impl<T: Serialize + binary_sv2::GetSize> WithoutNoise<SlowAndCorrect, T> {\n-    pub fn new() -> Self {\n-        Self {\n-            frame: PhantomData,\n-            missing_b: Header::SIZE,\n-            buffer: SlowAndCorrect::new(),\n-        }\n-    }\n-}\n-\n-impl<T: Serialize + binary_sv2::GetSize> Default for WithoutNoise<SlowAndCorrect, T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}"
      },
      {
        "sha": "73b1665f5579539cd3fa8b47b098db02ffebeeea",
        "filename": "src/rusty/codec-sv2/src/encoder.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 38,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/encoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/encoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/encoder.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,38 +0,0 @@\n-use alloc::vec::Vec;\n-use binary_sv2::GetSize;\n-use binary_sv2::Serialize;\n-use core::marker::PhantomData;\n-use framing_sv2::framing2::{Frame as F_, Sv2Frame};\n-\n-\n-#[derive(Debug)]\n-pub struct Encoder<T> {\n-    buffer: Vec<u8>,\n-    frame: PhantomData<T>,\n-}\n-\n-impl<T: Serialize + GetSize> Encoder<T> {\n-    pub fn encode(&mut self, item: Sv2Frame<T, Vec<u8>>) -> Result<&[u8], crate::Error> {\n-        let len = item.encoded_length();\n-\n-        self.buffer.resize(len, 0);\n-\n-        item.serialize(&mut self.buffer).map_err(|_| ())?;\n-\n-        Ok(&self.buffer[..])\n-    }\n-\n-    pub fn new() -> Self {\n-        Self {\n-            // TODO which capacity??\n-            buffer: Vec::with_capacity(512),\n-            frame: core::marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<T: Serialize + GetSize> Default for Encoder<T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}"
      },
      {
        "sha": "2e689b515d0f3c110878c784ebd1c4bda2d7f013",
        "filename": "src/rusty/codec-sv2/src/error.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/error.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,19 +0,0 @@\n-#[derive(Debug)]\n-pub enum Error {\n-    MissingBytes(usize),\n-    Todo,\n-}\n-\n-pub type Result<T> = core::result::Result<T, Error>;\n-\n-impl From<()> for Error {\n-    fn from(_: ()) -> Self {\n-        Error::Todo\n-    }\n-}\n-\n-impl core::fmt::Display for Error {\n-    fn fmt(&self, _: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n-        Ok(())\n-    }\n-}"
      },
      {
        "sha": "03e6c69153c5bd65ec0a92b1cade39042964e8f3",
        "filename": "src/rusty/codec-sv2/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/codec-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/codec-sv2/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,19 +0,0 @@\n-#![no_std]\n-\n-extern crate alloc;\n-\n-mod buffer;\n-mod decoder;\n-mod encoder;\n-mod error;\n-\n-pub use error::Error;\n-\n-pub use decoder::StandardEitherFrame;\n-pub use decoder::StandardSv2Frame;\n-\n-pub use decoder::StandardDecoder;\n-\n-pub use encoder::Encoder;\n-\n-pub use framing_sv2::framing2::{Frame, Sv2Frame};"
      },
      {
        "sha": "7432c3d50c4ae1fdf1ad1714f9d12c3e1322acec",
        "filename": "src/rusty/const-sv2/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/const-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/const-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/const-sv2/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,14 +0,0 @@\n-[package]\n-name = \"const_sv2\"\n-version = \"0.1.0\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2  constatnts\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-\n-#[dev-dependencies]\n-#cbindgen = \"0.16.0\""
      },
      {
        "sha": "943f5db0f54be4aff51c1266ce1af9badfeb60f6",
        "filename": "src/rusty/const-sv2/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 34,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/const-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/const-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/const-sv2/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,34 +0,0 @@\n-//! Central repository for all the sv2 constants\n-#![no_std]\n-\n-pub const SV2_FRAME_HEADER_SIZE: usize = 6;\n-pub const SV2_FRAME_HEADER_LEN_OFFSET: usize = 3;\n-pub const SV2_FRAME_HEADER_LEN_END: usize = 3;\n-\n-pub const NOISE_FRAME_HEADER_SIZE: usize = 2;\n-pub const NOISE_FRAME_HEADER_LEN_OFFSET: usize = 0;\n-pub const NOISE_FRAME_HEADER_LEN_END: usize = 2;\n-pub const NOISE_FRAME_MAX_SIZE: usize = u16::MAX as usize;\n-\n-pub const NOISE_PARAMS: &str = \"Noise_NX_25519_ChaChaPoly_BLAKE2s\";\n-pub const SNOW_PSKLEN: usize = 32;\n-pub const SNOW_TAGLEN: usize = 16;\n-\n-pub const SV2_MINING_PROTOCOL_DISCRIMINANT: u8 = 0;\n-pub const SV2_JOB_NEG_PROTOCOL_DISCRIMINANT: u8 = 1;\n-pub const SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT: u8 = 2;\n-pub const SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT: u8 = 3;\n-\n-// COMMON MESSAGES TYPES\n-pub const MESSAGE_TYPE_SETUP_CONNECTION: u8 = 0;\n-pub const MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS: u8 = 1;\n-pub const MESSAGE_TYPE_SETUP_CONNECTION_ERROR: u8 = 2;\n-pub const MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES: u8 = 3;\n-// TEMPLATE DISTRIBUTION PROTOCOL MESSAGES TYPES\n-pub const MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE: u8 = 70;\n-pub const MESSAGE_TYPE_NEW_TEMPLATE: u8 = 71;\n-pub const MESSAGE_TYPE_SET_NEW_PREV_HASH: u8 = 72;\n-pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA: u8 = 73;\n-pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS: u8 = 74;\n-pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR: u8 = 75;\n-pub const MESSAGE_TYPE_SUBMIT_SOLUTION: u8 = 76;"
      },
      {
        "sha": "f694f05d7a65ec18c9a74dcab1fa16db30743bd5",
        "filename": "src/rusty/framing-sv2/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 18,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,18 +0,0 @@\n-[package]\n-name = \"framing_sv2\"\n-version = \"0.1.3\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2 frames\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-\n-[dependencies]\n-serde = { version = \"1.0.89\", default-features = false, optional = true }\n-const_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/const-sv2\"}\n-binary_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/binary-sv2/binary-sv2\" }\n-\n-[features]\n-with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "7331f4ea5fc692e8f4f937a0805008fcda6808dd",
        "filename": "src/rusty/framing-sv2/src/framing2.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 306,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/src/framing2.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/src/framing2.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/src/framing2.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,306 +0,0 @@\n-use crate::header::Header;\n-use crate::header::NoiseHeader;\n-use alloc::vec::Vec;\n-use binary_sv2::Serialize;\n-use binary_sv2::{to_writer, GetSize};\n-use core::convert::TryFrom;\n-\n-const NOISE_MAX_LEN: usize = const_sv2::NOISE_FRAME_MAX_SIZE;\n-\n-pub trait Frame<'a, T: Serialize + GetSize>: Sized {\n-    type Buffer: AsMut<[u8]>;\n-    type Deserialized;\n-\n-    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n-    /// itself\n-    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error>;\n-\n-    ///fn deserialize(&'a mut self) -> Result<Self::Deserialized, serde_sv2::Error>;\n-    fn payload(&'a mut self) -> &'a mut [u8];\n-\n-    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n-    fn get_header(&self) -> Option<crate::header::Header>;\n-\n-    /// Try to build an Frame frame from raw bytes.\n-    /// It return the frame or the number of the bytes needed to complete the frame\n-    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n-    /// is said about the correctness of the payload\n-    fn from_bytes(bytes: Self::Buffer) -> Result<Self, isize>;\n-\n-    fn from_bytes_unchecked(bytes: Self::Buffer) -> Self;\n-\n-    fn size_hint(bytes: &[u8]) -> isize;\n-\n-    fn encoded_length(&self) -> usize;\n-\n-    /// Try to build an Frame frame from a serializable payload.\n-    /// It return a Frame if the size of the payload fit in the frame, if not it return None\n-    fn from_message(message: T, message_type: u8, extension_type: u16) -> Option<Self>;\n-}\n-\n-#[derive(Debug)]\n-pub struct Sv2Frame<T, B> {\n-    header: Header,\n-    payload: Option<T>,\n-    serialized: Option<B>,\n-}\n-\n-impl<T, B> Default for Sv2Frame<T, B> {\n-    fn default() -> Self {\n-        Sv2Frame {\n-            header: Header::default(),\n-            payload: None,\n-            serialized: None,\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct NoiseFrame {\n-    header: u16,\n-    payload: Vec<u8>,\n-}\n-\n-pub type HandShakeFrame = NoiseFrame;\n-\n-impl<'a, T: Serialize + GetSize, B: AsMut<[u8]>> Frame<'a, T> for Sv2Frame<T, B> {\n-    type Buffer = B;\n-    type Deserialized = B;\n-\n-    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n-    /// itself\n-    #[inline]\n-    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error> {\n-        if self.serialized.is_some() {\n-            *dst = self.serialized.unwrap();\n-            Ok(())\n-        } else {\n-            #[cfg(not(feature = \"with_serde\"))]\n-            to_writer(self.header, dst.as_mut())?;\n-            #[cfg(not(feature = \"with_serde\"))]\n-            to_writer(self.payload.unwrap(), &mut dst.as_mut()[Header::SIZE..])?;\n-            #[cfg(feature = \"with_serde\")]\n-            to_writer(&self.header, dst.as_mut())?;\n-            #[cfg(feature = \"with_serde\")]\n-            to_writer(&self.payload.unwrap(), &mut dst.as_mut()[Header::SIZE..])?;\n-            Ok(())\n-        }\n-    }\n-\n-    fn payload(&'a mut self) -> &'a mut [u8] {\n-        if self.payload.is_some() {\n-            todo!()\n-        } else {\n-            &mut self.serialized.as_mut().unwrap().as_mut()[Header::SIZE..]\n-        }\n-    }\n-\n-    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n-    fn get_header(&self) -> Option<crate::header::Header> {\n-        Some(self.header)\n-    }\n-\n-    /// Try to build a Frame frame from raw bytes.\n-    /// It return the frame or the number of the bytes needed to complete the frame\n-    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n-    /// is said about the correctness of the payload\n-    #[inline]\n-    fn from_bytes(mut bytes: Self::Buffer) -> Result<Self, isize> {\n-        let hint = Self::size_hint(bytes.as_mut());\n-\n-        if hint == 0 {\n-            Ok(Self::from_bytes_unchecked(bytes))\n-        } else {\n-            Err(hint)\n-        }\n-    }\n-\n-    #[inline]\n-    fn from_bytes_unchecked(mut bytes: Self::Buffer) -> Self {\n-        let header = Header::from_bytes(bytes.as_mut()).unwrap();\n-        Self {\n-            header,\n-            payload: None,\n-            serialized: Some(bytes),\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(bytes: &[u8]) -> isize {\n-        match Header::from_bytes(bytes) {\n-            Err(i) => i,\n-            Ok(header) => {\n-                if bytes.len() - Header::SIZE == header.len() {\n-                    0\n-                } else {\n-                    (bytes.len() - Header::SIZE) as isize + header.len() as isize\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn encoded_length(&self) -> usize {\n-        if self.serialized.is_some() {\n-            unimplemented!()\n-        } else {\n-            self.payload.as_ref().unwrap().get_size() + Header::SIZE\n-        }\n-    }\n-\n-    /// Try to build an Frame frame from a serializable payload.\n-    /// It returns a Frame if the size of the payload fits in the frame, if not it returns None\n-    fn from_message(message: T, message_type: u8, extension_type: u16) -> Option<Self> {\n-        let len = message.get_size() as u32;\n-        Header::from_len(len, message_type, extension_type).map(|header| Self {\n-            header,\n-            payload: Some(message),\n-            serialized: None,\n-        })\n-    }\n-}\n-\n-#[inline]\n-pub fn build_noise_frame_header(frame: &mut Vec<u8>, len: u16) {\n-    frame.push(len.to_le_bytes()[0]);\n-    frame.push(len.to_le_bytes()[1]);\n-}\n-\n-impl<'a> Frame<'a, Vec<u8>> for NoiseFrame {\n-    //impl<T: Serialize + GetSize> Frame<T> for NoiseFrame {\n-\n-    type Buffer = Vec<u8>;\n-    type Deserialized = &'a mut [u8];\n-\n-    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n-    /// itself\n-    #[inline]\n-    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error> {\n-        *dst = self.payload;\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn payload(&'a mut self) -> &'a mut [u8] {\n-        &mut self.payload[NoiseHeader::SIZE..]\n-    }\n-\n-    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n-    fn get_header(&self) -> Option<crate::header::Header> {\n-        None\n-    }\n-\n-    /// Try to build a Frame frame from raw bytes.\n-    /// It return the frame or the number of the bytes needed to complete the frame\n-    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n-    /// is said about the correctness of the payload\n-    fn from_bytes(_bytes: Self::Buffer) -> Result<Self, isize> {\n-        unimplemented!()\n-    }\n-\n-    #[inline]\n-    fn from_bytes_unchecked(bytes: Self::Buffer) -> Self {\n-        let len_b = &bytes[NoiseHeader::LEN_OFFSET..NoiseHeader::SIZE];\n-        let expected_len = u16::from_le_bytes([len_b[0], len_b[1]]) as usize;\n-\n-        Self {\n-            header: expected_len as u16,\n-            payload: bytes,\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(bytes: &[u8]) -> isize {\n-        if bytes.len() < NoiseHeader::SIZE {\n-            return (NoiseHeader::SIZE - bytes.len()) as isize;\n-        };\n-\n-        let len_b = &bytes[NoiseHeader::LEN_OFFSET..NoiseHeader::SIZE];\n-        let expected_len = u16::from_le_bytes([len_b[0], len_b[1]]) as usize;\n-\n-        if bytes.len() - NoiseHeader::SIZE == expected_len {\n-            0\n-        } else {\n-            expected_len as isize - (bytes.len() - NoiseHeader::SIZE) as isize\n-        }\n-    }\n-\n-    #[inline]\n-    fn encoded_length(&self) -> usize {\n-        self.payload.len()\n-    }\n-\n-    /// Try to build a `Frame` frame from a serializable payload.\n-    /// It returns a Frame if the size of the payload fits in the frame, if not it returns None\n-    /// Inneficient should be used only to build `HandShakeFrames`\n-    fn from_message(message: Vec<u8>, _message_type: u8, _extension_type: u16) -> Option<Self> {\n-        if message.len() <= NOISE_MAX_LEN {\n-            let header = message.len() as u16;\n-            let payload = [&header.to_le_bytes()[..], &message[..]].concat();\n-            Some(Self { header, payload })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// A frame can be either\n-/// 1: Sv2Frame\n-/// 2: NoiseFrame\n-/// 3: HandashakeFrame\n-///\n-#[derive(Debug)]\n-pub enum EitherFrame<T, B> {\n-    HandShake(HandShakeFrame),\n-    Sv2(Sv2Frame<T, B>),\n-}\n-\n-impl<T: Serialize + GetSize, B: AsMut<[u8]>> EitherFrame<T, B> {\n-    //pub fn serialize(mut self, dst: &mut B) -> Result<(), serde_sv2::Error> {\n-    //    match self {\n-    //        Self::HandShake(frame) => todo!(),\n-    //        Self::Sv2(frame) => frame.serialize(dst),\n-    //    }\n-    //}\n-\n-    pub fn encoded_length(&self) -> usize {\n-        match &self {\n-            Self::HandShake(frame) => frame.encoded_length(),\n-            Self::Sv2(frame) => frame.encoded_length(),\n-        }\n-    }\n-}\n-\n-impl<T, B> TryFrom<EitherFrame<T, B>> for HandShakeFrame {\n-    type Error = ();\n-\n-    fn try_from(v: EitherFrame<T, B>) -> Result<Self, Self::Error> {\n-        match v {\n-            EitherFrame::HandShake(frame) => Ok(frame),\n-            EitherFrame::Sv2(_) => Err(()),\n-        }\n-    }\n-}\n-\n-impl<T, B> TryFrom<EitherFrame<T, B>> for Sv2Frame<T, B> {\n-    type Error = ();\n-\n-    fn try_from(v: EitherFrame<T, B>) -> Result<Self, Self::Error> {\n-        match v {\n-            EitherFrame::Sv2(frame) => Ok(frame),\n-            EitherFrame::HandShake(_) => Err(()),\n-        }\n-    }\n-}\n-\n-impl<T, B> From<HandShakeFrame> for EitherFrame<T, B> {\n-    fn from(v: HandShakeFrame) -> Self {\n-        Self::HandShake(v)\n-    }\n-}\n-\n-impl<T, B> From<Sv2Frame<T, B>> for EitherFrame<T, B> {\n-    fn from(v: Sv2Frame<T, B>) -> Self {\n-        Self::Sv2(v)\n-    }\n-}"
      },
      {
        "sha": "adc56a3f8d734563750dc5a776cb0667a6860725",
        "filename": "src/rusty/framing-sv2/src/header.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 82,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/src/header.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/src/header.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/src/header.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,82 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2;\n-use binary_sv2::U24;\n-use binary_sv2::{Deserialize, Serialize};\n-use core::convert::TryInto;\n-\n-#[derive(Debug, Serialize, Deserialize, Copy, Clone)]\n-pub struct Header {\n-    extesion_type: u16, // TODO use specific type?\n-    msg_type: u8,       // TODO use specific type?\n-    msg_length: U24,\n-}\n-\n-impl Default for Header {\n-    fn default() -> Self {\n-        Header {\n-            extesion_type: 0,\n-            msg_type: 0,\n-            msg_length: 0_u32.try_into().unwrap(),\n-        }\n-    }\n-}\n-\n-impl Header {\n-    pub const LEN_OFFSET: usize = const_sv2::SV2_FRAME_HEADER_LEN_OFFSET;\n-    pub const LEN_SIZE: usize = const_sv2::SV2_FRAME_HEADER_LEN_END;\n-    pub const LEN_END: usize = Self::LEN_OFFSET + Self::LEN_SIZE;\n-\n-    pub const SIZE: usize = const_sv2::SV2_FRAME_HEADER_SIZE;\n-\n-    #[inline]\n-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, isize> {\n-        if bytes.len() < Self::SIZE {\n-            return Err((Self::SIZE - bytes.len()) as isize);\n-        };\n-\n-        // TODO remove hardcoded\n-        let extesion_type = u16::from_le_bytes([bytes[0], bytes[1]]);\n-        let msg_type = bytes[2];\n-        let msg_length = u32::from_le_bytes([bytes[3], bytes[4], bytes[5], 0]);\n-\n-        Ok(Self {\n-            extesion_type,\n-            msg_type,\n-            // TODO\n-            msg_length: msg_length.try_into().unwrap(),\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        let inner: u32 = self.msg_length.into();\n-        inner as usize\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        unimplemented!()\n-    }\n-\n-    #[inline]\n-    pub fn from_len(len: u32, message_type: u8, extension_type: u16) -> Option<Header> {\n-        Some(Self {\n-            extesion_type: extension_type,\n-            msg_type: message_type,\n-            msg_length: len.try_into().unwrap(),\n-        })\n-    }\n-\n-    pub fn msg_type(&self) -> u8 {\n-        self.msg_type\n-    }\n-}\n-\n-pub struct NoiseHeader {}\n-\n-impl NoiseHeader {\n-    pub const SIZE: usize = const_sv2::NOISE_FRAME_HEADER_SIZE;\n-    pub const LEN_OFFSET: usize = const_sv2::NOISE_FRAME_HEADER_LEN_OFFSET;\n-    pub const LEN_END: usize = const_sv2::NOISE_FRAME_HEADER_LEN_END;\n-}"
      },
      {
        "sha": "84f9f5ee930834f1e2f3ae9c12045a3217ba59c4",
        "filename": "src/rusty/framing-sv2/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/framing-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/framing-sv2/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,23 +0,0 @@\n-#![no_std]\n-extern crate alloc;\n-\n-///\n-/// Sv2 messages are framed as\n-/// ```txt\n-/// extension type: u16\n-/// msg type: u8\n-/// msg length: u24\n-/// payload: [u8; msg length]\n-/// ```\n-///\n-/// Sv2 messages can be encapsulated in noise messages, noise messages are framed as:\n-///\n-/// ```txt\n-/// msg length: u16\n-/// payload: [u8; msg length]\n-/// ```\n-///\n-///\n-pub mod framing2;\n-\n-pub mod header;"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/subprotocols/common-messages/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/.gitignore?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1 +0,0 @@\n-/target"
      },
      {
        "sha": "0fec15c6257530294f6ae956d03c91b0c1a23900",
        "filename": "src/rusty/subprotocols/common-messages/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,17 +0,0 @@\n-[package]\n-name = \"common_messages_sv2\"\n-version = \"0.1.3\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2 subprotocol common messages\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-serde = { version = \"1.0.89\", default-features = false, optional= true }\n-binary_sv2 = {version = \"0.1.3\", path = \"../../../../protocols/v2/binary-sv2/binary-sv2\" }\n-const_sv2 = {version = \"0.1.0\", path = \"../../../../protocols/v2/const-sv2\"}\n-\n-[features]\n-with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "1a37e13a35bf8780479d66541102314a8dfd8a71",
        "filename": "src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/src/channel_endpoint_changed.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,19 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2;\n-use binary_sv2::{Deserialize, Serialize};\n-\n-/// ## ChannelEndpointChanged (Server -> Client)\n-/// When a channel\u2019s upstream or downstream endpoint changes and that channel had previously\n-/// sent messages with [channel_msg](TODO) bitset of unknown extension_type, the intermediate proxy\n-/// MUST send a [`ChannelEndpointChanged`] message. Upon receipt thereof, any extension state\n-/// (including version negotiation and the presence of support for a given extension) MUST be\n-/// reset and version/presence negotiation must begin again.\n-///\n-#[repr(C)]\n-#[derive(Serialize, Deserialize, Debug, Copy, Clone)]\n-pub struct ChannelEndpointChanged {\n-    /// The channel which has changed endpoint.\n-    pub channel_id: u32,\n-}"
      },
      {
        "sha": "96f7bee1e0d79227ae9dbdb9008f03601b352a7b",
        "filename": "src/rusty/subprotocols/common-messages/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,22 +0,0 @@\n-#![no_std]\n-\n-//! Common messages for [stratum v2][Sv2]\n-//! The following protocol messages are common across all of the sv2 (sub)protocols.\n-extern crate alloc;\n-mod channel_endpoint_changed;\n-mod setup_connection;\n-\n-pub use channel_endpoint_changed::ChannelEndpointChanged;\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use setup_connection::{CSetupConnection, CSetupConnectionError};\n-pub use setup_connection::{\n-    Protocol, SetupConnection, SetupConnectionError, SetupConnectionSuccess,\n-};\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_channel_endpoint_changed(_a: ChannelEndpointChanged) {}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_setup_conn_succ(_a: SetupConnectionSuccess) {}"
      },
      {
        "sha": "9a8341a4b2ece8c945f1f1eb005fd20eaac5e289",
        "filename": "src/rusty/subprotocols/common-messages/src/setup_connection.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 272,
        "changes": 272,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/src/setup_connection.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/common-messages/src/setup_connection.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/common-messages/src/setup_connection.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,272 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-use binary_sv2::Str0255;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::{\n-    binary_codec_sv2, binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n-    free_vec, Error, GetSize,\n-};\n-use binary_sv2::{Deserialize, Serialize};\n-use const_sv2::{\n-    SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT, SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n-    SV2_MINING_PROTOCOL_DISCRIMINANT, SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n-};\n-use core::convert::TryFrom;\n-#[cfg(not(feature = \"with_serde\"))]\n-use core::convert::TryInto;\n-\n-/// ## SetupConnection (Client -> Server)\n-/// Initiates the connection. This MUST be the first message sent by the client on the newly\n-/// opened connection. Server MUST respond with either a [`SetupConnectionSuccess`] or\n-/// [`SetupConnectionError`] message. Clients that are not configured to provide telemetry data to\n-/// the upstream node SHOULD set device_id to 0-length strings. However, they MUST always set\n-/// vendor to a string describing the manufacturer/developer and firmware version and SHOULD\n-/// always set hardware_version to a string describing, at least, the particular hardware/software\n-/// package in use.\n-///\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct SetupConnection<'decoder> {\n-    /// [`Protocol`]\n-    pub protocol: Protocol,\n-    /// The minimum protocol version the client supports (currently must be 2).\n-    pub min_version: u16,\n-    /// The maximum protocol version the client supports (currently must be 2).\n-    pub max_version: u16,\n-    /// Flags indicating optional protocol features the client supports. Each\n-    /// protocol from [`SetupConnection.protocol`] field has its own values/flags.\n-    pub flags: u32,\n-    /// ASCII text indicating the hostname or IP address.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub endpoint_host: Str0255<'decoder>,\n-    /// Connecting port value\n-    pub endpoint_port: u16,\n-    //-- DEVICE INFORMATION --//\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub vendor: Str0255<'decoder>,\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub hardware_version: Str0255<'decoder>,\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub firmware: Str0255<'decoder>,\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub device_id: Str0255<'decoder>,\n-}\n-\n-#[repr(C)]\n-#[cfg(not(feature = \"with_serde\"))]\n-#[derive(Debug, Clone)]\n-pub struct CSetupConnection {\n-    pub protocol: Protocol,\n-    pub min_version: u16,\n-    pub max_version: u16,\n-    pub flags: u32,\n-    pub endpoint_host: CVec,\n-    pub endpoint_port: u16,\n-    pub vendor: CVec,\n-    pub hardware_version: CVec,\n-    pub firmware: CVec,\n-    pub device_id: CVec,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CSetupConnection {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetupConnection<'a>, Error> {\n-        let endpoint_host: Str0255 = self.endpoint_host.as_mut_slice().try_into()?;\n-        let vendor: Str0255 = self.vendor.as_mut_slice().try_into()?;\n-        let hardware_version: Str0255 = self.hardware_version.as_mut_slice().try_into()?;\n-        let firmware: Str0255 = self.firmware.as_mut_slice().try_into()?;\n-        let device_id: Str0255 = self.device_id.as_mut_slice().try_into()?;\n-\n-        Ok(SetupConnection {\n-            protocol: self.protocol,\n-            min_version: self.min_version,\n-            max_version: self.max_version,\n-            flags: self.flags,\n-            endpoint_host,\n-            endpoint_port: self.endpoint_port,\n-            vendor,\n-            hardware_version,\n-            firmware,\n-            device_id,\n-        })\n-    }\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_setup_connection(s: CSetupConnection) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CSetupConnection {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.endpoint_host);\n-        free_vec(&mut self.vendor);\n-        free_vec(&mut self.hardware_version);\n-        free_vec(&mut self.firmware);\n-        free_vec(&mut self.device_id);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<SetupConnection<'a>> for CSetupConnection {\n-    fn from(v: SetupConnection) -> Self {\n-        Self {\n-            protocol: v.protocol,\n-            min_version: v.min_version,\n-            max_version: v.max_version,\n-            flags: v.flags,\n-            endpoint_host: v.endpoint_host.into(),\n-            endpoint_port: v.endpoint_port,\n-            vendor: v.vendor.into(),\n-            hardware_version: v.hardware_version.into(),\n-            firmware: v.firmware.into(),\n-            device_id: v.device_id.into(),\n-        }\n-    }\n-}\n-\n-/// ## SetupConnection.Success (Server -> Client)\n-/// Response to [`SetupConnection`] message if the server accepts the connection. The client is\n-/// required to verify the set of feature flags that the server supports and act accordingly.\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-#[repr(C)]\n-pub struct SetupConnectionSuccess {\n-    /// Selected version proposed by the connecting node that the upstream\n-    /// node supports. This version will be used on the connection for the rest\n-    /// of its life.\n-    pub used_version: u16,\n-    /// Flags indicating optional protocol features the server supports. Each\n-    /// protocol from [`Protocol`] field has its own values/flags.\n-    pub flags: u32,\n-}\n-\n-/// ## SetupConnection.Error (Server -> Client)\n-/// When protocol version negotiation fails (or there is another reason why the upstream node\n-/// cannot setup the connection) the server sends this message with a particular error code prior\n-/// to closing the connection.\n-/// In order to allow a client to determine the set of available features for a given server (e.g. for\n-/// proxies which dynamically switch between different pools and need to be aware of supported\n-/// options), clients SHOULD send a SetupConnection message with all flags set and examine the\n-/// (potentially) resulting [`SetupConnectionError`] message\u2019s flags field. The Server MUST provide\n-/// the full set of flags which it does not support in each [`SetupConnectionError`] message and\n-/// MUST consistently support the same set of flags across all servers on the same hostname and\n-/// port number. If flags is 0, the error is a result of some condition aside from unsupported flags.\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct SetupConnectionError<'decoder> {\n-    /// Flags indicating features causing an error.\n-    pub flags: u32,\n-    /// Human-readable error code(s). See Error Codes section, [link](TODO).\n-    /// ### Possible error codes:\n-    /// * \u2018unsupported-feature-flags\u2019\n-    /// * \u2018unsupported-protocol\u2019\n-    /// * \u2018protocol-version-mismatch\u2019\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub error_code: Str0255<'decoder>,\n-}\n-\n-#[repr(C)]\n-#[cfg(not(feature = \"with_serde\"))]\n-#[derive(Debug, Clone)]\n-pub struct CSetupConnectionError {\n-    flags: u32,\n-    error_code: CVec,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CSetupConnectionError {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetupConnectionError<'a>, Error> {\n-        let error_code: Str0255 = self.error_code.as_mut_slice().try_into()?;\n-\n-        Ok(SetupConnectionError {\n-            flags: self.flags,\n-            error_code,\n-        })\n-    }\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_setup_connection_error(s: CSetupConnectionError) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CSetupConnectionError {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.error_code);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<SetupConnectionError<'a>> for CSetupConnectionError {\n-    fn from(v: SetupConnectionError<'a>) -> Self {\n-        Self {\n-            flags: v.flags,\n-            error_code: v.error_code.into(),\n-        }\n-    }\n-}\n-\n-/// MiningProtocol = [`SV2_MINING_PROTOCOL_DISCRIMINANT`],\n-/// JobNegotiationProtocol = [`SV2_JOB_NEG_PROTOCOL_DISCRIMINANT`],\n-/// TemplateDistributionProtocol = [`SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT`],\n-/// JobDistributionProtocol = [`SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT`],\n-#[cfg_attr(feature = \"with_serde\", derive(Serialize, Deserialize))]\n-#[derive(Debug, Clone, Copy)]\n-#[repr(u8)]\n-#[allow(clippy::enum_variant_names)]\n-pub enum Protocol {\n-    MiningProtocol = SV2_MINING_PROTOCOL_DISCRIMINANT,\n-    JobNegotiationProtocol = SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n-    TemplateDistributionProtocol = SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n-    JobDistributionProtocol = SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<Protocol> for binary_sv2::encodable::EncodableField<'a> {\n-    fn from(v: Protocol) -> Self {\n-        let val = v as u8;\n-        val.into()\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'decoder> binary_sv2::Decodable<'decoder> for Protocol {\n-    fn get_structure(\n-        _: &[u8],\n-    ) -> core::result::Result<alloc::vec::Vec<FieldMarker>, binary_sv2::Error> {\n-        let field: FieldMarker = 0_u8.into();\n-        Ok(alloc::vec![field])\n-    }\n-    fn from_decoded_fields(\n-        mut v: alloc::vec::Vec<DecodableField<'decoder>>,\n-    ) -> core::result::Result<Self, binary_sv2::Error> {\n-        let val = v.pop().unwrap();\n-        let val: u8 = val.try_into().unwrap();\n-        Ok(val.try_into().unwrap())\n-    }\n-}\n-\n-impl TryFrom<u8> for Protocol {\n-    type Error = ();\n-\n-    fn try_from(value: u8) -> Result<Self, Self::Error> {\n-        match value {\n-            SV2_MINING_PROTOCOL_DISCRIMINANT => Ok(Protocol::MiningProtocol),\n-            SV2_JOB_NEG_PROTOCOL_DISCRIMINANT => Ok(Protocol::JobNegotiationProtocol),\n-            SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT => Ok(Protocol::TemplateDistributionProtocol),\n-            SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT => Ok(Protocol::JobDistributionProtocol),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl GetSize for Protocol {\n-    fn get_size(&self) -> usize {\n-        1\n-    }\n-}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/subprotocols/template-distribution/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/.gitignore?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1 +0,0 @@\n-/target"
      },
      {
        "sha": "cf1c3df4384d3e28fcbcaa9944adc669a2e6a8d2",
        "filename": "src/rusty/subprotocols/template-distribution/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,17 +0,0 @@\n-[package]\n-name = \"template_distribution_sv2\"\n-version = \"0.1.3\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-description = \"Sv2 template distribution subprotocol\"\n-license = \"MIT\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-serde = { version = \"1.0.89\", default-features = false, optional= true }\n-binary_sv2 = { version = \"0.1.3\", path = \"../../../../protocols/v2/binary-sv2/binary-sv2\" }\n-const_sv2 = { version = \"0.1.0\", path = \"../../../../protocols/v2/const-sv2\"}\n-\n-[features]\n-with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "86bf6c11dadd761979feb88ef8eae1034bea7b8c",
        "filename": "src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 27,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/coinbase_output_data_size.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,27 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2;\n-use binary_sv2::{Deserialize, Serialize};\n-\n-/// ## CoinbaseOutputDataSize (Client -> Server)\n-/// Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and\n-/// other uses, and thus the Template Provider will need to consider this additional block size\n-/// when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\n-/// Thus, this message is used to indicate that some additional space in the block/coinbase\n-/// transaction be reserved for the pool\u2019s use (while always assuming the pool will use the entirety\n-/// of available coinbase space).\n-/// The Job Negotiator MUST discover the maximum serialized size of the additional outputs which\n-/// will be added by the pool(s) it intends to use this work. It then MUST communicate the\n-/// maximum such size to the Template Provider via this message. The Template Provider MUST\n-/// NOT provide NewWork messages which would represent consensus-invalid blocks once this\n-/// additional size \u2014 along with a maximally-sized (100 byte) coinbase field \u2014 is added. Further,\n-/// the Template Provider MUST consider the maximum additional bytes required in the output\n-/// count variable-length integer in the coinbase transaction when complying with the size limits.\n-#[derive(Serialize, Deserialize, Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct CoinbaseOutputDataSize {\n-    /// The maximum additional serialized bytes which the pool will add in\n-    /// coinbase transaction outputs.\n-    pub coinbase_output_max_additional_size: u32,\n-}"
      },
      {
        "sha": "3bb6c5de19c7d20d13604380eb85b94892ee6635",
        "filename": "src/rusty/subprotocols/template-distribution/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 49,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,49 +0,0 @@\n-#![no_std]\n-\n-//! # Template Distribution Protocol\n-//! The Template Distribution protocol is used to receive updates of the block template to use in\n-//! mining the next block. It effectively replaces BIPs [22](TODO) and [23](TODO) (getblocktemplate) and provides\n-//! a much more efficient API which allows Bitcoin Core (or some other full node software) to push\n-//! template updates at more appropriate times as well as provide a template which may be\n-//! mined on quickly for the block-after-next. While not recommended, the template update\n-//! protocol can be a remote server, and is thus authenticated and signed in the same way as all\n-//! other protocols ([using the same SetupConnection handshake][TODO]).\n-//! Like the [Job Negotiation](TODO) and [Job Distribution](TODO) (sub)protocols, all Template Distribution messages\n-//! have the channel_msg bit unset, and there is no concept of channels. After the initial common\n-//! handshake, the client MUST immediately send a [`CoinbaseOutputDataSize`] message to indicate\n-//! the space it requires for coinbase output addition, to which the server MUST immediately reply\n-//! with the current best block template it has available to the client. Thereafter, the server\n-//! SHOULD push new block templates to the client whenever the total fee in the current block\n-//! template increases materially, and MUST send updated block templates whenever it learns of\n-//! a new block.\n-//! Template Providers MUST attempt to broadcast blocks which are mined using work they\n-//! provided, and thus MUST track the work which they provided to clients.\n-extern crate alloc;\n-\n-mod coinbase_output_data_size;\n-mod new_template;\n-mod request_transaction_data;\n-mod set_new_prev_hash;\n-mod submit_solution;\n-//\n-pub use coinbase_output_data_size::CoinbaseOutputDataSize;\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use new_template::CNewTemplate;\n-pub use new_template::NewTemplate;\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use request_transaction_data::{CRequestTransactionDataError, CRequestTransactionDataSuccess};\n-pub use request_transaction_data::{\n-    RequestTransactionData, RequestTransactionDataError, RequestTransactionDataSuccess,\n-};\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use set_new_prev_hash::CSetNewPrevHash;\n-pub use set_new_prev_hash::SetNewPrevHash;\n-#[cfg(not(feature = \"with_serde\"))]\n-pub use submit_solution::CSubmitSolution;\n-pub use submit_solution::SubmitSolution;\n-\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_coinbase_out(_a: CoinbaseOutputDataSize) {}\n-\n-#[no_mangle]\n-pub extern \"C\" fn _c_export_req_tx_data(_a: RequestTransactionData) {}"
      },
      {
        "sha": "5a904ecea8bb5ea033b867ed59e0313651cebe46",
        "filename": "src/rusty/subprotocols/template-distribution/src/new_template.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 134,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/new_template.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/new_template.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/new_template.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,134 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2::{self, free_vec, free_vec_2, CVec, CVec2};\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::Error;\n-use binary_sv2::{Deserialize, Serialize};\n-use binary_sv2::{Seq0255, B0255, B064K, U256};\n-#[cfg(not(feature = \"with_serde\"))]\n-use core::convert::TryInto;\n-\n-/// ## NewTemplate (Server -> Client)\n-/// The primary template-providing function. Note that the coinbase_tx_outputs bytes will appear\n-/// as is at the end of the coinbase transaction.\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct NewTemplate<'decoder> {\n-    /// Server\u2019s identification of the template. Strictly increasing, the\n-    /// current UNIX time may be used in place of an ID.\n-    pub template_id: u64,\n-    /// True if the template is intended for future [`crate::SetNewPrevHash`]\n-    /// message sent on the channel. If False, the job relates to the last\n-    /// sent [`crate::SetNewPrevHash`] message on the channel and the miner\n-    /// should start to work on the job immediately.\n-    pub future_template: bool,\n-    /// Valid header version field that reflects the current network\n-    /// consensus. The general purpose bits (as specified in [BIP320](TODO link)) can\n-    /// be freely manipulated by the downstream node. The downstream\n-    /// node MUST NOT rely on the upstream node to set the BIP320 bits\n-    /// to any particular value.\n-    pub version: u32,\n-    /// The coinbase transaction nVersion field.\n-    pub coinbase_tx_version: u32,\n-    /// Up to 8 bytes (not including the length byte) which are to be placed\n-    /// at the beginning of the coinbase field in the coinbase transaction.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub coinbase_prefix: B0255<'decoder>,\n-    /// The coinbase transaction input\u2019s nSequence field.\n-    pub coinbase_tx_input_sequence: u32,\n-    /// The value, in satoshis, available for spending in coinbase outputs\n-    /// added by the client. Includes both transaction fees and block\n-    /// subsidy.\n-    pub coinbase_tx_value_remaining: u64,\n-    /// The number of transaction outputs included in coinbase_tx_outputs.\n-    pub coinbase_tx_outputs_count: u32,\n-    /// Bitcoin transaction outputs to be included as the last outputs in the\n-    /// coinbase transaction.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub coinbase_tx_outputs: B064K<'decoder>,\n-    /// The locktime field in the coinbase transaction.\n-    pub coinbase_tx_locktime: u32,\n-    /// Merkle path hashes ordered from deepest.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub merkle_path: Seq0255<'decoder, U256<'decoder>>,\n-}\n-\n-#[repr(C)]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub struct CNewTemplate {\n-    template_id: u64,\n-    future_template: bool,\n-    version: u32,\n-    coinbase_tx_version: u32,\n-    coinbase_prefix: CVec,\n-    coinbase_tx_input_sequence: u32,\n-    coinbase_tx_value_remaining: u64,\n-    coinbase_tx_outputs_count: u32,\n-    coinbase_tx_outputs: CVec,\n-    coinbase_tx_locktime: u32,\n-    merkle_path: CVec2,\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_new_template(s: CNewTemplate) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CNewTemplate {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.coinbase_prefix);\n-        free_vec(&mut self.coinbase_tx_outputs);\n-        free_vec_2(&mut self.merkle_path);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<NewTemplate<'a>> for CNewTemplate {\n-    fn from(v: NewTemplate<'a>) -> Self {\n-        Self {\n-            template_id: v.template_id,\n-            future_template: v.future_template,\n-            version: v.version,\n-            coinbase_tx_version: v.coinbase_tx_version,\n-            coinbase_prefix: v.coinbase_prefix.into(),\n-            coinbase_tx_input_sequence: v.coinbase_tx_input_sequence,\n-            coinbase_tx_value_remaining: v.coinbase_tx_value_remaining,\n-            coinbase_tx_outputs_count: v.coinbase_tx_outputs_count,\n-            coinbase_tx_outputs: v.coinbase_tx_outputs.into(),\n-            coinbase_tx_locktime: v.coinbase_tx_locktime,\n-            merkle_path: v.merkle_path.into(),\n-        }\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CNewTemplate {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<NewTemplate<'a>, Error> {\n-        let coinbase_prefix: B0255 = self.coinbase_prefix.as_mut_slice().try_into()?;\n-        let coinbase_tx_outputs: B064K = self.coinbase_tx_outputs.as_mut_slice().try_into()?;\n-\n-        let merkle_path_ = self.merkle_path.as_mut_slice();\n-        let mut merkle_path: Vec<U256> = Vec::new();\n-        for cvec in merkle_path_ {\n-            merkle_path.push(cvec.as_mut_slice().try_into()?);\n-        }\n-\n-        let merkle_path = Seq0255::new(merkle_path)?;\n-        Ok(NewTemplate {\n-            template_id: self.template_id,\n-            future_template: self.future_template,\n-            version: self.version,\n-            coinbase_tx_version: self.coinbase_tx_version,\n-            coinbase_prefix,\n-            coinbase_tx_input_sequence: self.coinbase_tx_input_sequence,\n-            coinbase_tx_value_remaining: self.coinbase_tx_value_remaining,\n-            coinbase_tx_outputs_count: self.coinbase_tx_outputs_count,\n-            coinbase_tx_outputs,\n-            coinbase_tx_locktime: self.coinbase_tx_locktime,\n-            merkle_path,\n-        })\n-    }\n-}"
      },
      {
        "sha": "063745969f5d51a1dc6690cb6d1f116e3fc360e9",
        "filename": "src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 165,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/request_transaction_data.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,165 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2::{self, free_vec, free_vec_2, CVec, CVec2};\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::Error;\n-use binary_sv2::{Deserialize, Serialize};\n-use binary_sv2::{Seq064K, Str0255, B016M, B064K};\n-#[cfg(not(feature = \"with_serde\"))]\n-use core::convert::TryInto;\n-\n-/// ## RequestTransactionData (Client -> Server)\n-/// A request sent by the Job Negotiator to the Template Provider which requests the set of\n-/// transaction data for all transactions (excluding the coinbase transaction) included in a block, as\n-/// well as any additional data which may be required by the Pool to validate the work.\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-#[repr(C)]\n-pub struct RequestTransactionData {\n-    /// The template_id corresponding to a NewTemplate message.\n-    pub template_id: u64,\n-}\n-\n-/// ## RequestTransactionData.Success (Server->Client)\n-/// A response to [`RequestTransactionData`] which contains the set of full transaction data and\n-/// excess data required for validation. For practical purposes, the excess data is usually the\n-/// SegWit commitment, however the Job Negotiator MUST NOT parse or interpret the excess data\n-/// in any way. Note that the transaction data MUST be treated as opaque blobs and MUST include\n-/// any SegWit or other data which the Pool may require to verify the transaction. For practical\n-/// purposes, the transaction data is likely the witness-encoded transaction today. However, to\n-/// ensure backward compatibility, the transaction data MAY be encoded in a way that is different\n-/// from the consensus serialization of Bitcoin transactions.\n-/// Ultimately, having some method of negotiating the specific format of transactions between the\n-/// Template Provider and the Pool\u2019s Template verification node would be overly burdensome,\n-/// thus the following requirements are made explicit. The RequestTransactionData.Success\n-/// sender MUST ensure that the data is provided in a forwards- and backwards-compatible way to\n-/// ensure the end receiver of the data can interpret it, even in the face of new,\n-/// consensus-optional data. This allows significantly more flexibility on both the\n-/// RequestTransactionData.Success-generating and -interpreting sides during upgrades, at the\n-/// cost of breaking some potential optimizations which would require version negotiation to\n-/// provide support for previous versions. For practical purposes, and as a non-normative\n-/// suggested implementation for Bitcoin Core, this implies that additional consensus-optional\n-/// data be appended at the end of transaction data. It will simply be ignored by versions which do\n-/// not understand it.\n-/// To work around the limitation of not being able to negotiate e.g. a transaction compression\n-/// scheme, the format of the opaque data in RequestTransactionData.Success messages MAY be\n-/// changed in non-compatible ways at the time a fork activates, given sufficient time from\n-/// code-release to activation (as any sane fork would have to have) and there being some\n-/// in-Template Negotiation Protocol signaling of support for the new fork (e.g. for soft-forks\n-/// activated using [BIP 9](TODO link)).\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct RequestTransactionDataSuccess<'decoder> {\n-    /// The template_id corresponding to a NewTemplate/RequestTransactionData message.\n-    pub template_id: u64,\n-    /// Extra data which the Pool may require to validate the work.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub excess_data: B064K<'decoder>,\n-    /// The transaction data, serialized as a series of B0_16M byte arrays.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub transaction_list: Seq064K<'decoder, B016M<'decoder>>,\n-}\n-\n-#[repr(C)]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub struct CRequestTransactionDataSuccess {\n-    template_id: u64,\n-    excess_data: CVec,\n-    transaction_list: CVec2,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CRequestTransactionDataSuccess {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<RequestTransactionDataSuccess<'a>, Error> {\n-        let excess_data: B064K = self.excess_data.as_mut_slice().try_into()?;\n-        let transaction_list_ = self.transaction_list.as_mut_slice();\n-        let mut transaction_list: Vec<B016M> = Vec::new();\n-        for cvec in transaction_list_ {\n-            transaction_list.push(cvec.as_mut_slice().try_into()?);\n-        }\n-        let transaction_list = Seq064K::new(transaction_list)?;\n-        Ok(RequestTransactionDataSuccess {\n-            template_id: self.template_id,\n-            excess_data,\n-            transaction_list,\n-        })\n-    }\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_request_tx_data_success(s: CRequestTransactionDataSuccess) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CRequestTransactionDataSuccess {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.excess_data);\n-        free_vec_2(&mut self.transaction_list);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<RequestTransactionDataSuccess<'a>> for CRequestTransactionDataSuccess {\n-    fn from(v: RequestTransactionDataSuccess<'a>) -> Self {\n-        Self {\n-            template_id: v.template_id,\n-            excess_data: v.excess_data.into(),\n-            transaction_list: v.transaction_list.into(),\n-        }\n-    }\n-}\n-\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct RequestTransactionDataError<'decoder> {\n-    /// The template_id corresponding to a NewTemplate/RequestTransactionData message.\n-    pub template_id: u64,\n-    /// Reason why no transaction data has been provided\n-    /// Possible error codes:\n-    /// * template-id-not-found\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub error_code: Str0255<'decoder>,\n-}\n-\n-#[repr(C)]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub struct CRequestTransactionDataError {\n-    template_id: u64,\n-    error_code: CVec,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CRequestTransactionDataError {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<RequestTransactionDataError<'a>, Error> {\n-        let error_code: Str0255 = self.error_code.as_mut_slice().try_into()?;\n-        Ok(RequestTransactionDataError {\n-            template_id: self.template_id,\n-            error_code,\n-        })\n-    }\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_request_tx_data_error(s: CRequestTransactionDataError) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CRequestTransactionDataError {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.error_code);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<RequestTransactionDataError<'a>> for CRequestTransactionDataError {\n-    fn from(v: RequestTransactionDataError<'a>) -> Self {\n-        Self {\n-            template_id: v.template_id,\n-            error_code: v.error_code.into(),\n-        }\n-    }\n-}"
      },
      {
        "sha": "625cefe3e2763edd13c760bb4aa61ecd992b855f",
        "filename": "src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 90,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/set_new_prev_hash.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,90 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2::{self, free_vec, CVec};\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::Error;\n-use binary_sv2::U256;\n-use binary_sv2::{Deserialize, Serialize};\n-#[cfg(not(feature = \"with_serde\"))]\n-use core::convert::TryInto;\n-\n-/// ## SetNewPrevHash (Server -> Client)\n-/// Upon successful validation of a new best block, the server MUST immediately provide a\n-/// SetNewPrevHash message. If a [NewWork](TODO link) message has previously been sent with the\n-/// [future_job](TODO link) flag set, which is valid work based on the prev_hash contained in this message, the\n-/// template_id field SHOULD be set to the job_id present in that NewTemplate message\n-/// indicating the client MUST begin mining on that template as soon as possible.\n-/// TODO: Define how many previous works the client has to track (2? 3?), and require that the\n-/// server reference one of those in SetNewPrevHash.\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct SetNewPrevHash<'decoder> {\n-    /// template_id referenced in a previous NewTemplate message.\n-    pub template_id: u64,\n-    /// Previous block\u2019s hash, as it must appear in the next block\u2019s header.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub prev_hash: U256<'decoder>,\n-    /// The nTime field in the block header at which the client should start\n-    /// (usually current time). This is NOT the minimum valid nTime value.\n-    pub header_timestamp: u32,\n-    /// Block header field.\n-    pub n_bits: u32,\n-    /// The maximum double-SHA256 hash value which would represent a valid\n-    /// block. Note that this may be lower than the target implied by nBits in\n-    /// several cases, including weak-block based block propagation.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub target: U256<'decoder>,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-#[repr(C)]\n-pub struct CSetNewPrevHash {\n-    template_id: u64,\n-    prev_hash: CVec,\n-    header_timestamp: u32,\n-    n_bits: u32,\n-    target: CVec,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CSetNewPrevHash {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetNewPrevHash<'a>, Error> {\n-        let prev_hash: U256 = self.prev_hash.as_mut_slice().try_into()?;\n-        let target: U256 = self.target.as_mut_slice().try_into()?;\n-\n-        Ok(SetNewPrevHash {\n-            template_id: self.template_id,\n-            prev_hash,\n-            header_timestamp: self.header_timestamp,\n-            n_bits: self.n_bits,\n-            target,\n-        })\n-    }\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_set_new_prev_hash(s: CSetNewPrevHash) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CSetNewPrevHash {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.target);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<SetNewPrevHash<'a>> for CSetNewPrevHash {\n-    fn from(v: SetNewPrevHash<'a>) -> Self {\n-        Self {\n-            template_id: v.template_id,\n-            prev_hash: v.prev_hash.into(),\n-            header_timestamp: v.header_timestamp,\n-            n_bits: v.n_bits,\n-            target: v.target.into(),\n-        }\n-    }\n-}"
      },
      {
        "sha": "dc539d2135a891bb873e6abb55ef89006fe34e25",
        "filename": "src/rusty/subprotocols/template-distribution/src/submit_solution.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 88,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/submit_solution.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/subprotocols/template-distribution/src/submit_solution.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/subprotocols/template-distribution/src/submit_solution.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,88 +0,0 @@\n-#[cfg(not(feature = \"with_serde\"))]\n-use alloc::vec::Vec;\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::binary_codec_sv2::{self, free_vec, CVec};\n-#[cfg(not(feature = \"with_serde\"))]\n-use binary_sv2::Error;\n-use binary_sv2::B064K;\n-use binary_sv2::{Deserialize, Serialize};\n-#[cfg(not(feature = \"with_serde\"))]\n-use core::convert::TryInto;\n-\n-/// ## SubmitSolution (Client -> Server)\n-/// Upon finding a coinbase transaction/nonce pair which double-SHA256 hashes at or below\n-/// [`crate::SetNewPrevHash.target`], the client MUST immediately send this message, and the server\n-/// MUST then immediately construct the corresponding full block and attempt to propagate it to\n-/// the Bitcoin network.\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-pub struct SubmitSolution<'decoder> {\n-    /// The template_id field as it appeared in NewTemplate.\n-    pub template_id: u64,\n-    /// The version field in the block header. Bits not defined by [BIP320](TODO link) as\n-    /// additional nonce MUST be the same as they appear in the [NewWork](TODO link)\n-    /// message, other bits may be set to any value.\n-    pub version: u32,\n-    /// The nTime field in the block header. This MUST be greater than or equal\n-    /// to the header_timestamp field in the latest [`crate::SetNewPrevHash`] message\n-    /// and lower than or equal to that value plus the number of seconds since\n-    /// the receipt of that message.\n-    pub header_timestamp: u32,\n-    /// The nonce field in the header.\n-    pub header_nonce: u32,\n-    /// The full serialized coinbase transaction, meeting all the requirements of\n-    /// the NewWork message, above.\n-    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n-    pub coinbase_tx: B064K<'decoder>,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-#[repr(C)]\n-pub struct CSubmitSolution {\n-    template_id: u64,\n-    version: u32,\n-    header_timestamp: u32,\n-    header_nonce: u32,\n-    coinbase_tx: CVec,\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> CSubmitSolution {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<SubmitSolution<'a>, Error> {\n-        let coinbase_tx: B064K = self.coinbase_tx.as_mut_slice().try_into()?;\n-\n-        Ok(SubmitSolution {\n-            template_id: self.template_id,\n-            version: self.version,\n-            header_timestamp: self.header_timestamp,\n-            header_nonce: self.header_nonce,\n-            coinbase_tx,\n-        })\n-    }\n-}\n-\n-#[no_mangle]\n-#[cfg(not(feature = \"with_serde\"))]\n-pub extern \"C\" fn free_submit_solution(s: CSubmitSolution) {\n-    drop(s)\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl Drop for CSubmitSolution {\n-    fn drop(&mut self) {\n-        free_vec(&mut self.coinbase_tx);\n-    }\n-}\n-\n-#[cfg(not(feature = \"with_serde\"))]\n-impl<'a> From<SubmitSolution<'a>> for CSubmitSolution {\n-    fn from(v: SubmitSolution<'a>) -> Self {\n-        Self {\n-            template_id: v.template_id,\n-            version: v.version,\n-            header_timestamp: v.header_timestamp,\n-            header_nonce: v.header_nonce,\n-            coinbase_tx: v.coinbase_tx.into(),\n-        }\n-    }\n-}"
      },
      {
        "sha": "2f47ec23d021af0038adb0e1f1e37f7db8dcf8cb",
        "filename": "src/rusty/sv2-ffi/Cargo.toml",
        "status": "removed",
        "additions": 0,
        "deletions": 18,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/Cargo.toml?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,18 +0,0 @@\n-[package]\n-name = \"sv2_ffi\"\n-version = \"0.1.3\"\n-authors = [\"fi3 <email@email.org>\"]\n-edition = \"2018\"\n-\n-[lib]\n-crate-type = [\"staticlib\"]\n-\n-[dependencies]\n-codec_sv2 = { path = \"../../../protocols/v2/codec-sv2\", version = \"0.1.3\" }\n-const_sv2 = { path = \"../../../protocols/v2/const-sv2\", version = \"0.1.0\" }\n-binary_sv2 = { path = \"../../../protocols/v2/binary-sv2/binary-sv2\", version = \"0.1.3\" }\n-common_messages_sv2 = { path = \"../../../protocols/v2/subprotocols/common-messages\", version = \"0.1.3\" }\n-template_distribution_sv2 = { path = \"../../../protocols/v2/subprotocols/template-distribution\", version = \"0.1.3\"}\n-\n-[features]\n-with_serde = []"
      },
      {
        "sha": "d2a2f365df5d06b32b408c735037ed948f48a200",
        "filename": "src/rusty/sv2-ffi/src/lib.rs",
        "status": "removed",
        "additions": 0,
        "deletions": 371,
        "changes": 371,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/src/lib.rs?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,371 +0,0 @@\n-#![cfg(not(feature = \"with_serde\"))]\n-\n-use codec_sv2::{Encoder, Frame, StandardDecoder, StandardSv2Frame};\n-use common_messages_sv2::{\n-    CSetupConnection, CSetupConnectionError, ChannelEndpointChanged, SetupConnection,\n-    SetupConnectionError, SetupConnectionSuccess,\n-};\n-use template_distribution_sv2::{\n-    CNewTemplate, CRequestTransactionDataError, CRequestTransactionDataSuccess, CSetNewPrevHash,\n-    CSubmitSolution, CoinbaseOutputDataSize, NewTemplate, RequestTransactionData,\n-    RequestTransactionDataError, RequestTransactionDataSuccess, SetNewPrevHash, SubmitSolution,\n-};\n-\n-use binary_sv2::{\n-    binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n-    encodable::EncodableField, from_bytes, Deserialize, Error,\n-};\n-\n-use const_sv2::{\n-    MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES, MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n-    MESSAGE_TYPE_NEW_TEMPLATE, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n-    MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS,\n-    MESSAGE_TYPE_SETUP_CONNECTION, MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n-    MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS, MESSAGE_TYPE_SET_NEW_PREV_HASH,\n-    MESSAGE_TYPE_SUBMIT_SOLUTION,\n-};\n-use core::convert::{TryFrom, TryInto};\n-\n-#[derive(Clone, Debug)]\n-pub enum Sv2Message<'a> {\n-    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n-    NewTemplate(NewTemplate<'a>),\n-    RequestTransactionData(RequestTransactionData),\n-    RequestTransactionDataError(RequestTransactionDataError<'a>),\n-    RequestTransactionDataSuccess(RequestTransactionDataSuccess<'a>),\n-    SetNewPrevHash(SetNewPrevHash<'a>),\n-    SubmitSolution(SubmitSolution<'a>),\n-    ChannelEndpointChanged(ChannelEndpointChanged),\n-    SetupConnection(SetupConnection<'a>),\n-    SetupConnectionError(SetupConnectionError<'a>),\n-    SetupConnectionSuccess(SetupConnectionSuccess),\n-}\n-\n-impl<'a> Sv2Message<'a> {\n-    pub fn message_type(&self) -> u8 {\n-        match self {\n-            Sv2Message::CoinbaseOutputDataSize(_) => MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n-            Sv2Message::NewTemplate(_) => MESSAGE_TYPE_NEW_TEMPLATE,\n-            Sv2Message::RequestTransactionData(_) => MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n-            Sv2Message::RequestTransactionDataError(_) => {\n-                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR\n-            }\n-            Sv2Message::RequestTransactionDataSuccess(_) => {\n-                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS\n-            }\n-            Sv2Message::SetNewPrevHash(_) => MESSAGE_TYPE_SET_NEW_PREV_HASH,\n-            Sv2Message::SubmitSolution(_) => MESSAGE_TYPE_SUBMIT_SOLUTION,\n-            Sv2Message::ChannelEndpointChanged(_) => MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES,\n-            Sv2Message::SetupConnection(_) => MESSAGE_TYPE_SETUP_CONNECTION,\n-            Sv2Message::SetupConnectionError(_) => MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n-            Sv2Message::SetupConnectionSuccess(_) => MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS,\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub enum CSv2Message {\n-    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n-    NewTemplate(CNewTemplate),\n-    RequestTransactionData(RequestTransactionData),\n-    RequestTransactionDataError(CRequestTransactionDataError),\n-    RequestTransactionDataSuccess(CRequestTransactionDataSuccess),\n-    SetNewPrevHash(CSetNewPrevHash),\n-    SubmitSolution(CSubmitSolution),\n-    ChannelEndpointChanged(ChannelEndpointChanged),\n-    SetupConnection(CSetupConnection),\n-    SetupConnectionError(CSetupConnectionError),\n-    SetupConnectionSuccess(SetupConnectionSuccess),\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn drop_sv2_message(s: CSv2Message) {\n-    match s {\n-        CSv2Message::CoinbaseOutputDataSize(_) => (),\n-        CSv2Message::NewTemplate(a) => drop(a),\n-        CSv2Message::RequestTransactionData(a) => drop(a),\n-        CSv2Message::RequestTransactionDataError(a) => drop(a),\n-        CSv2Message::RequestTransactionDataSuccess(a) => drop(a),\n-        CSv2Message::SetNewPrevHash(a) => drop(a),\n-        CSv2Message::SubmitSolution(a) => drop(a),\n-        CSv2Message::ChannelEndpointChanged(_) => (),\n-        CSv2Message::SetupConnection(_) => (),\n-        CSv2Message::SetupConnectionError(a) => drop(a),\n-        CSv2Message::SetupConnectionSuccess(a) => drop(a),\n-    }\n-}\n-\n-impl<'a> From<Sv2Message<'a>> for CSv2Message {\n-    fn from(v: Sv2Message<'a>) -> Self {\n-        match v {\n-            Sv2Message::CoinbaseOutputDataSize(a) => Self::CoinbaseOutputDataSize(a),\n-            Sv2Message::NewTemplate(a) => Self::NewTemplate(a.into()),\n-            Sv2Message::RequestTransactionData(a) => Self::RequestTransactionData(a),\n-            Sv2Message::RequestTransactionDataError(a) => {\n-                Self::RequestTransactionDataError(a.into())\n-            }\n-            Sv2Message::RequestTransactionDataSuccess(a) => {\n-                Self::RequestTransactionDataSuccess(a.into())\n-            }\n-            Sv2Message::SetNewPrevHash(a) => Self::SetNewPrevHash(a.into()),\n-            Sv2Message::SubmitSolution(a) => Self::SubmitSolution(a.into()),\n-            Sv2Message::ChannelEndpointChanged(a) => Self::ChannelEndpointChanged(a),\n-            Sv2Message::SetupConnection(a) => Self::SetupConnection(a.into()),\n-            Sv2Message::SetupConnectionError(a) => Self::SetupConnectionError(a.into()),\n-            Sv2Message::SetupConnectionSuccess(a) => Self::SetupConnectionSuccess(a),\n-        }\n-    }\n-}\n-\n-impl<'a> CSv2Message {\n-    #[cfg(not(feature = \"with_serde\"))]\n-    pub fn to_rust_rep_mut(&'a mut self) -> Result<Sv2Message<'a>, Error> {\n-        match self {\n-            CSv2Message::NewTemplate(v) => Ok(Sv2Message::NewTemplate(v.to_rust_rep_mut()?)),\n-            CSv2Message::SetNewPrevHash(v) => Ok(Sv2Message::SetNewPrevHash(v.to_rust_rep_mut()?)),\n-            CSv2Message::SubmitSolution(v) => Ok(Sv2Message::SubmitSolution(v.to_rust_rep_mut()?)),\n-            CSv2Message::SetupConnection(v) => {\n-                Ok(Sv2Message::SetupConnection(v.to_rust_rep_mut()?))\n-            }\n-            CSv2Message::SetupConnectionError(v) => {\n-                Ok(Sv2Message::SetupConnectionError(v.to_rust_rep_mut()?))\n-            }\n-            _ => todo!(),\n-        }\n-    }\n-}\n-\n-impl<'decoder> From<Sv2Message<'decoder>> for EncodableField<'decoder> {\n-    fn from(m: Sv2Message<'decoder>) -> Self {\n-        match m {\n-            Sv2Message::CoinbaseOutputDataSize(a) => a.into(),\n-            Sv2Message::NewTemplate(a) => a.into(),\n-            Sv2Message::RequestTransactionData(a) => a.into(),\n-            Sv2Message::RequestTransactionDataError(a) => a.into(),\n-            Sv2Message::RequestTransactionDataSuccess(a) => a.into(),\n-            Sv2Message::SetNewPrevHash(a) => a.into(),\n-            Sv2Message::SubmitSolution(a) => a.into(),\n-            Sv2Message::ChannelEndpointChanged(a) => a.into(),\n-            Sv2Message::SetupConnection(a) => a.into(),\n-            Sv2Message::SetupConnectionError(a) => a.into(),\n-            Sv2Message::SetupConnectionSuccess(a) => a.into(),\n-        }\n-    }\n-}\n-\n-impl binary_sv2::GetSize for Sv2Message<'_> {\n-    fn get_size(&self) -> usize {\n-        match self {\n-            Sv2Message::CoinbaseOutputDataSize(a) => a.get_size(),\n-            Sv2Message::NewTemplate(a) => a.get_size(),\n-            Sv2Message::RequestTransactionData(a) => a.get_size(),\n-            Sv2Message::RequestTransactionDataError(a) => a.get_size(),\n-            Sv2Message::RequestTransactionDataSuccess(a) => a.get_size(),\n-            Sv2Message::SetNewPrevHash(a) => a.get_size(),\n-            Sv2Message::SubmitSolution(a) => a.get_size(),\n-            Sv2Message::ChannelEndpointChanged(a) => a.get_size(),\n-            Sv2Message::SetupConnection(a) => a.get_size(),\n-            Sv2Message::SetupConnectionError(a) => a.get_size(),\n-            Sv2Message::SetupConnectionSuccess(a) => a.get_size(),\n-        }\n-    }\n-}\n-\n-impl<'decoder> Deserialize<'decoder> for Sv2Message<'decoder> {\n-    fn get_structure(_v: &[u8]) -> std::result::Result<Vec<FieldMarker>, binary_sv2::Error> {\n-        unimplemented!()\n-    }\n-    fn from_decoded_fields(\n-        _v: Vec<DecodableField<'decoder>>,\n-    ) -> std::result::Result<Self, binary_sv2::Error> {\n-        unimplemented!()\n-    }\n-}\n-\n-impl<'a> TryFrom<(u8, &'a mut [u8])> for Sv2Message<'a> {\n-    type Error = Error;\n-\n-    fn try_from(v: (u8, &'a mut [u8])) -> Result<Self, Self::Error> {\n-        let msg_type = v.0;\n-        match msg_type {\n-            MESSAGE_TYPE_SETUP_CONNECTION => {\n-                let message: SetupConnection<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetupConnection(message))\n-            }\n-            MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS => {\n-                let message: SetupConnectionSuccess = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetupConnectionSuccess(message))\n-            }\n-            MESSAGE_TYPE_SETUP_CONNECTION_ERROR => {\n-                let message: SetupConnectionError<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetupConnectionError(message))\n-            }\n-            MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES => {\n-                let message: ChannelEndpointChanged = from_bytes(v.1)?;\n-                Ok(Sv2Message::ChannelEndpointChanged(message))\n-            }\n-            MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE => {\n-                let message: CoinbaseOutputDataSize = from_bytes(v.1)?;\n-                Ok(Sv2Message::CoinbaseOutputDataSize(message))\n-            }\n-            MESSAGE_TYPE_NEW_TEMPLATE => {\n-                let message: NewTemplate<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::NewTemplate(message))\n-            }\n-            MESSAGE_TYPE_SET_NEW_PREV_HASH => {\n-                let message: SetNewPrevHash<'a> = from_bytes(v.1)?;\n-                Ok(Sv2Message::SetNewPrevHash(message))\n-            }\n-            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA => {\n-                let message: RequestTransactionData = from_bytes(v.1)?;\n-                Ok(Sv2Message::RequestTransactionData(message))\n-            }\n-            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS => {\n-                let message: RequestTransactionDataSuccess = from_bytes(v.1)?;\n-                Ok(Sv2Message::RequestTransactionDataSuccess(message))\n-            }\n-            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR => {\n-                let message: RequestTransactionDataError = from_bytes(v.1)?;\n-                Ok(Sv2Message::RequestTransactionDataError(message))\n-            }\n-            MESSAGE_TYPE_SUBMIT_SOLUTION => {\n-                let message: SubmitSolution = from_bytes(v.1)?;\n-                Ok(Sv2Message::SubmitSolution(message))\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub enum CResult<T, E> {\n-    Ok(T),\n-    Err(E),\n-}\n-\n-#[repr(C)]\n-pub enum Sv2Error {\n-    MissingBytes,\n-    EncoderBusy,\n-    Todo,\n-    Unknown,\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn is_ok(cresult: &CResult<CSv2Message, Sv2Error>) -> bool {\n-    match cresult {\n-        CResult::Ok(_) => true,\n-        CResult::Err(_) => false,\n-    }\n-}\n-\n-impl<T, E> From<Result<T, E>> for CResult<T, E> {\n-    fn from(v: Result<T, E>) -> Self {\n-        match v {\n-            Ok(v) => Self::Ok(v),\n-            Err(e) => Self::Err(e),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct EncoderWrapper {\n-    encoder: Encoder<Sv2Message<'static>>,\n-    free: bool,\n-}\n-\n-#[no_mangle]\n-pub extern \"C\" fn new_encoder() -> *mut EncoderWrapper {\n-    let encoder: Encoder<Sv2Message<'static>> = Encoder::new();\n-    let s = Box::new(EncoderWrapper {\n-        encoder,\n-        free: true,\n-    });\n-    Box::into_raw(s)\n-}\n-\n-#[no_mangle]\n-#[allow(clippy::not_unsafe_ptr_arg_deref)]\n-pub extern \"C\" fn free_encoder(encoder: *mut EncoderWrapper) {\n-    let mut encoder = unsafe { Box::from_raw(encoder) };\n-    encoder.free = true;\n-    Box::into_raw(encoder);\n-}\n-\n-fn encode_(message: &'static mut CSv2Message, encoder: &mut EncoderWrapper) -> Result<CVec, Error> {\n-    let message: Sv2Message = message.to_rust_rep_mut()?;\n-    let m_type = message.message_type();\n-    let frame = StandardSv2Frame::<Sv2Message<'static>>::from_message(message, m_type, 0)\n-        .ok_or(Error::Todo)?;\n-    encoder\n-        .encoder\n-        .encode(frame)\n-        .map_err(|_| Error::Todo)\n-        .map(|x| x.into())\n-}\n-\n-/// # Safety\n-///\n-/// TODO\n-#[no_mangle]\n-pub unsafe extern \"C\" fn encode(\n-    message: &'static mut CSv2Message,\n-    encoder: *mut EncoderWrapper,\n-) -> CResult<CVec, Sv2Error> {\n-    let mut encoder = Box::from_raw(encoder);\n-    if encoder.free {\n-        let result = encode_(message, &mut encoder)\n-            .map_err(|_| Sv2Error::Todo)\n-            .into();\n-        encoder.free = false;\n-        Box::into_raw(encoder);\n-        result\n-    } else {\n-        CResult::Err(Sv2Error::EncoderBusy)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct DecoderWrapper(StandardDecoder<Sv2Message<'static>>);\n-\n-#[no_mangle]\n-pub extern \"C\" fn new_decoder() -> *mut DecoderWrapper {\n-    let s = Box::new(DecoderWrapper(StandardDecoder::new()));\n-    Box::into_raw(s)\n-}\n-\n-#[no_mangle]\n-#[allow(clippy::not_unsafe_ptr_arg_deref)]\n-pub extern \"C\" fn get_writable(decoder: *mut DecoderWrapper) -> CVec {\n-    let mut decoder = unsafe { Box::from_raw(decoder) };\n-    let writable = decoder.0.writable();\n-    let res = CVec::as_shared_buffer(writable);\n-    Box::into_raw(decoder);\n-    res\n-}\n-\n-#[no_mangle]\n-#[allow(clippy::not_unsafe_ptr_arg_deref)]\n-pub extern \"C\" fn next_frame(decoder: *mut DecoderWrapper) -> CResult<CSv2Message, Sv2Error> {\n-    let mut decoder = unsafe { Box::from_raw(decoder) };\n-\n-    match decoder.0.next_frame() {\n-        Ok(mut f) => {\n-            let msg_type = f.get_header().unwrap().msg_type();\n-            let payload = f.payload();\n-            let len = payload.len();\n-            let ptr = payload.as_mut_ptr();\n-            let payload = unsafe { std::slice::from_raw_parts_mut(ptr, len) };\n-            Box::into_raw(decoder);\n-            (msg_type, payload)\n-                .try_into()\n-                .map(|x: Sv2Message| x.into())\n-                .map_err(|_| Sv2Error::Unknown)\n-                .into()\n-        }\n-        Err(_) => {\n-            Box::into_raw(decoder);\n-            CResult::Err(Sv2Error::MissingBytes)\n-        }\n-    }\n-}"
      },
      {
        "sha": "26ee72afc6fcb2ed9bba597c932399031e10941d",
        "filename": "src/rusty/sv2-ffi/sv2.h",
        "status": "removed",
        "additions": 0,
        "deletions": 386,
        "changes": 386,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/sv2.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9cab9f17113c876f153ec740a9ac26aec7f06e4/src/rusty/sv2-ffi/sv2.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/sv2-ffi/sv2.h?ref=c9cab9f17113c876f153ec740a9ac26aec7f06e4",
        "patch": "@@ -1,386 +0,0 @@\n-#include <cstdarg>\n-#include <cstdint>\n-#include <cstdlib>\n-#include <ostream>\n-#include <new>\n-\n-static const uintptr_t SV2_FRAME_HEADER_SIZE = 6;\n-\n-static const uintptr_t SV2_FRAME_HEADER_LEN_OFFSET = 3;\n-\n-static const uintptr_t SV2_FRAME_HEADER_LEN_END = 3;\n-\n-static const uintptr_t NOISE_FRAME_HEADER_SIZE = 2;\n-\n-static const uintptr_t NOISE_FRAME_HEADER_LEN_OFFSET = 0;\n-\n-static const uintptr_t NOISE_FRAME_HEADER_LEN_END = 2;\n-\n-static const uintptr_t SNOW_PSKLEN = 32;\n-\n-static const uintptr_t SNOW_TAGLEN = 16;\n-\n-static const uint8_t SV2_MINING_PROTOCOL_DISCRIMINANT = 0;\n-\n-static const uint8_t SV2_JOB_NEG_PROTOCOL_DISCRIMINANT = 1;\n-\n-static const uint8_t SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT = 2;\n-\n-static const uint8_t SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT = 3;\n-\n-static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION = 0;\n-\n-static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS = 1;\n-\n-static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION_ERROR = 2;\n-\n-static const uint8_t MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES = 3;\n-\n-static const uint8_t MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE = 70;\n-\n-static const uint8_t MESSAGE_TYPE_NEW_TEMPLATE = 71;\n-\n-static const uint8_t MESSAGE_TYPE_SET_NEW_PREV_HASH = 72;\n-\n-static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA = 73;\n-\n-static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS = 74;\n-\n-static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR = 75;\n-\n-static const uint8_t MESSAGE_TYPE_SUBMIT_SOLUTION = 76;\n-#include <cstdarg>\n-#include <cstdint>\n-#include <cstdlib>\n-#include <ostream>\n-#include <new>\n-\n-struct CVec {\n-  uint8_t *data;\n-  uintptr_t len;\n-  uintptr_t capacity;\n-};\n-\n-struct U24 {\n-  uint32_t _0;\n-};\n-\n-struct CVec2 {\n-  CVec *data;\n-  uintptr_t len;\n-  uintptr_t capacity;\n-};\n-\n-extern \"C\" {\n-\n-/// Given a C allocated buffer return a rust allocated CVec\n-///\n-/// # Safety\n-///\n-/// TODO\n-CVec cvec_from_buffer(const uint8_t *data, uintptr_t len);\n-\n-void _c_export_u24(U24 _a);\n-\n-void _c_export_cvec(CVec _a);\n-\n-void _c_export_cvec2(CVec2 _a);\n-\n-} // extern \"C\"\n-#include <cstdarg>\n-#include <cstdint>\n-#include <cstdlib>\n-#include <ostream>\n-#include <new>\n-\n-/// MiningProtocol = [`SV2_MINING_PROTOCOL_DISCRIMINANT`],\n-/// JobNegotiationProtocol = [`SV2_JOB_NEG_PROTOCOL_DISCRIMINANT`],\n-/// TemplateDistributionProtocol = [`SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT`],\n-/// JobDistributionProtocol = [`SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT`],\n-enum class Protocol : uint8_t {\n-  MiningProtocol = SV2_MINING_PROTOCOL_DISCRIMINANT,\n-  JobNegotiationProtocol = SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n-  TemplateDistributionProtocol = SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n-  JobDistributionProtocol = SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT,\n-};\n-\n-/// ## ChannelEndpointChanged (Server -> Client)\n-/// When a channel\u2019s upstream or downstream endpoint changes and that channel had previously\n-/// sent messages with [channel_msg](TODO) bitset of unknown extension_type, the intermediate proxy\n-/// MUST send a [`ChannelEndpointChanged`] message. Upon receipt thereof, any extension state\n-/// (including version negotiation and the presence of support for a given extension) MUST be\n-/// reset and version/presence negotiation must begin again.\n-///\n-struct ChannelEndpointChanged {\n-  /// The channel which has changed endpoint.\n-  uint32_t channel_id;\n-};\n-\n-/// ## SetupConnection.Success (Server -> Client)\n-/// Response to [`SetupConnection`] message if the server accepts the connection. The client is\n-/// required to verify the set of feature flags that the server supports and act accordingly.\n-struct SetupConnectionSuccess {\n-  /// Selected version proposed by the connecting node that the upstream\n-  /// node supports. This version will be used on the connection for the rest\n-  /// of its life.\n-  uint16_t used_version;\n-  /// Flags indicating optional protocol features the server supports. Each\n-  /// protocol from [`Protocol`] field has its own values/flags.\n-  uint32_t flags;\n-};\n-\n-struct CSetupConnection {\n-  Protocol protocol;\n-  uint16_t min_version;\n-  uint16_t max_version;\n-  uint32_t flags;\n-  CVec endpoint_host;\n-  uint16_t endpoint_port;\n-  CVec vendor;\n-  CVec hardware_version;\n-  CVec firmware;\n-  CVec device_id;\n-};\n-\n-struct CSetupConnectionError {\n-  uint32_t flags;\n-  CVec error_code;\n-};\n-\n-extern \"C\" {\n-\n-void _c_export_channel_endpoint_changed(ChannelEndpointChanged _a);\n-\n-void _c_export_setup_conn_succ(SetupConnectionSuccess _a);\n-\n-void free_setup_connection(CSetupConnection s);\n-\n-void free_setup_connection_error(CSetupConnectionError s);\n-\n-} // extern \"C\"\n-#include <cstdarg>\n-#include <cstdint>\n-#include <cstdlib>\n-#include <ostream>\n-#include <new>\n-\n-/// ## CoinbaseOutputDataSize (Client -> Server)\n-/// Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and\n-/// other uses, and thus the Template Provider will need to consider this additional block size\n-/// when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\n-/// Thus, this message is used to indicate that some additional space in the block/coinbase\n-/// transaction be reserved for the pool\u2019s use (while always assuming the pool will use the entirety\n-/// of available coinbase space).\n-/// The Job Negotiator MUST discover the maximum serialized size of the additional outputs which\n-/// will be added by the pool(s) it intends to use this work. It then MUST communicate the\n-/// maximum such size to the Template Provider via this message. The Template Provider MUST\n-/// NOT provide NewWork messages which would represent consensus-invalid blocks once this\n-/// additional size \u2014 along with a maximally-sized (100 byte) coinbase field \u2014 is added. Further,\n-/// the Template Provider MUST consider the maximum additional bytes required in the output\n-/// count variable-length integer in the coinbase transaction when complying with the size limits.\n-struct CoinbaseOutputDataSize {\n-  /// The maximum additional serialized bytes which the pool will add in\n-  /// coinbase transaction outputs.\n-  uint32_t coinbase_output_max_additional_size;\n-};\n-\n-/// ## RequestTransactionData (Client -> Server)\n-/// A request sent by the Job Negotiator to the Template Provider which requests the set of\n-/// transaction data for all transactions (excluding the coinbase transaction) included in a block, as\n-/// well as any additional data which may be required by the Pool to validate the work.\n-struct RequestTransactionData {\n-  /// The template_id corresponding to a NewTemplate message.\n-  uint64_t template_id;\n-};\n-\n-struct CNewTemplate {\n-  uint64_t template_id;\n-  bool future_template;\n-  uint32_t version;\n-  uint32_t coinbase_tx_version;\n-  CVec coinbase_prefix;\n-  uint32_t coinbase_tx_input_sequence;\n-  uint64_t coinbase_tx_value_remaining;\n-  uint32_t coinbase_tx_outputs_count;\n-  CVec coinbase_tx_outputs;\n-  uint32_t coinbase_tx_locktime;\n-  CVec2 merkle_path;\n-};\n-\n-struct CRequestTransactionDataSuccess {\n-  uint64_t template_id;\n-  CVec excess_data;\n-  CVec2 transaction_list;\n-};\n-\n-struct CRequestTransactionDataError {\n-  uint64_t template_id;\n-  CVec error_code;\n-};\n-\n-struct CSetNewPrevHash {\n-  uint64_t template_id;\n-  CVec prev_hash;\n-  uint32_t header_timestamp;\n-  uint32_t n_bits;\n-  CVec target;\n-};\n-\n-struct CSubmitSolution {\n-  uint64_t template_id;\n-  uint32_t version;\n-  uint32_t header_timestamp;\n-  uint32_t header_nonce;\n-  CVec coinbase_tx;\n-};\n-\n-extern \"C\" {\n-\n-void _c_export_coinbase_out(CoinbaseOutputDataSize _a);\n-\n-void _c_export_req_tx_data(RequestTransactionData _a);\n-\n-void free_new_template(CNewTemplate s);\n-\n-void free_request_tx_data_success(CRequestTransactionDataSuccess s);\n-\n-void free_request_tx_data_error(CRequestTransactionDataError s);\n-\n-void free_set_new_prev_hash(CSetNewPrevHash s);\n-\n-void free_submit_solution(CSubmitSolution s);\n-\n-} // extern \"C\"\n-#include <cstdarg>\n-#include <cstdint>\n-#include <cstdlib>\n-#include <ostream>\n-#include <new>\n-\n-enum class Sv2Error {\n-  MissingBytes,\n-  EncoderBusy,\n-  Todo,\n-  Unknown,\n-};\n-\n-struct DecoderWrapper;\n-\n-struct EncoderWrapper;\n-\n-struct CSv2Message {\n-  enum class Tag {\n-    CoinbaseOutputDataSize,\n-    NewTemplate,\n-    RequestTransactionData,\n-    RequestTransactionDataError,\n-    RequestTransactionDataSuccess,\n-    SetNewPrevHash,\n-    SubmitSolution,\n-    ChannelEndpointChanged,\n-    SetupConnection,\n-    SetupConnectionError,\n-    SetupConnectionSuccess,\n-  };\n-\n-  struct CoinbaseOutputDataSize_Body {\n-    CoinbaseOutputDataSize _0;\n-  };\n-\n-  struct NewTemplate_Body {\n-    CNewTemplate _0;\n-  };\n-\n-  struct RequestTransactionData_Body {\n-    RequestTransactionData _0;\n-  };\n-\n-  struct RequestTransactionDataError_Body {\n-    CRequestTransactionDataError _0;\n-  };\n-\n-  struct RequestTransactionDataSuccess_Body {\n-    CRequestTransactionDataSuccess _0;\n-  };\n-\n-  struct SetNewPrevHash_Body {\n-    CSetNewPrevHash _0;\n-  };\n-\n-  struct SubmitSolution_Body {\n-    CSubmitSolution _0;\n-  };\n-\n-  struct ChannelEndpointChanged_Body {\n-    ChannelEndpointChanged _0;\n-  };\n-\n-  struct SetupConnection_Body {\n-    CSetupConnection _0;\n-  };\n-\n-  struct SetupConnectionError_Body {\n-    CSetupConnectionError _0;\n-  };\n-\n-  struct SetupConnectionSuccess_Body {\n-    SetupConnectionSuccess _0;\n-  };\n-\n-  Tag tag;\n-  union {\n-    CoinbaseOutputDataSize_Body coinbase_output_data_size;\n-    NewTemplate_Body new_template;\n-    RequestTransactionData_Body request_transaction_data;\n-    RequestTransactionDataError_Body request_transaction_data_error;\n-    RequestTransactionDataSuccess_Body request_transaction_data_success;\n-    SetNewPrevHash_Body set_new_prev_hash;\n-    SubmitSolution_Body submit_solution;\n-    ChannelEndpointChanged_Body channel_endpoint_changed;\n-    SetupConnection_Body setup_connection;\n-    SetupConnectionError_Body setup_connection_error;\n-    SetupConnectionSuccess_Body setup_connection_success;\n-  };\n-};\n-\n-template<typename T, typename E>\n-struct CResult {\n-  enum class Tag {\n-    Ok,\n-    Err,\n-  };\n-\n-  struct Ok_Body {\n-    T _0;\n-  };\n-\n-  struct Err_Body {\n-    E _0;\n-  };\n-\n-  Tag tag;\n-  union {\n-    Ok_Body ok;\n-    Err_Body err;\n-  };\n-};\n-\n-extern \"C\" {\n-\n-void drop_sv2_message(CSv2Message s);\n-\n-bool is_ok(const CResult<CSv2Message, Sv2Error> *cresult);\n-\n-EncoderWrapper *new_encoder();\n-\n-void free_encoder(EncoderWrapper *encoder);\n-\n-CResult<CVec, Sv2Error> encode(CSv2Message *message, EncoderWrapper *encoder);\n-\n-DecoderWrapper *new_decoder();\n-\n-CVec get_writable(DecoderWrapper *decoder);\n-\n-CResult<CSv2Message, Sv2Error> next_frame(DecoderWrapper *decoder);\n-\n-} // extern \"C\""
      }
    ]
  },
  {
    "sha": "70d314fff39127f98c3f0aafd4213ea0fab194ac",
    "node_id": "C_kwDOABII59oAKDcwZDMxNGZmZjM5MTI3Zjk4YzNmMGFhZmQ0MjEzZWEwZmFiMTk0YWM",
    "commit": {
      "author": {
        "name": "RJ Rybarczyk",
        "email": "rj@rybar.tech",
        "date": "2021-09-21T18:43:52Z"
      },
      "committer": {
        "name": "RJ Rybarczyk",
        "email": "rj@rybar.tech",
        "date": "2021-09-21T18:43:52Z"
      },
      "message": "Add sv2 Rust crates for TP implementation",
      "tree": {
        "sha": "9b0f558343387a02b2b523725e22966f5dabe8ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b0f558343387a02b2b523725e22966f5dabe8ed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/70d314fff39127f98c3f0aafd4213ea0fab194ac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70d314fff39127f98c3f0aafd4213ea0fab194ac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/70d314fff39127f98c3f0aafd4213ea0fab194ac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70d314fff39127f98c3f0aafd4213ea0fab194ac/comments",
    "author": {
      "login": "rrybarczyk",
      "id": 29670338,
      "node_id": "MDQ6VXNlcjI5NjcwMzM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/29670338?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rrybarczyk",
      "html_url": "https://github.com/rrybarczyk",
      "followers_url": "https://api.github.com/users/rrybarczyk/followers",
      "following_url": "https://api.github.com/users/rrybarczyk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rrybarczyk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rrybarczyk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rrybarczyk/subscriptions",
      "organizations_url": "https://api.github.com/users/rrybarczyk/orgs",
      "repos_url": "https://api.github.com/users/rrybarczyk/repos",
      "events_url": "https://api.github.com/users/rrybarczyk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rrybarczyk/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rrybarczyk",
      "id": 29670338,
      "node_id": "MDQ6VXNlcjI5NjcwMzM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/29670338?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rrybarczyk",
      "html_url": "https://github.com/rrybarczyk",
      "followers_url": "https://api.github.com/users/rrybarczyk/followers",
      "following_url": "https://api.github.com/users/rrybarczyk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rrybarczyk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rrybarczyk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rrybarczyk/subscriptions",
      "organizations_url": "https://api.github.com/users/rrybarczyk/orgs",
      "repos_url": "https://api.github.com/users/rrybarczyk/repos",
      "events_url": "https://api.github.com/users/rrybarczyk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rrybarczyk/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "069adee1afe3a87a1eb93d054235322062e88402",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/069adee1afe3a87a1eb93d054235322062e88402",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/069adee1afe3a87a1eb93d054235322062e88402"
      }
    ],
    "stats": {
      "total": 6913,
      "additions": 6913,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/.gitignore?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "96f129bfb9ea017b94335ceb1f2109649dd17cda",
        "filename": "src/rusty/protocols/v2/binary-sv2/binary-sv2/Cargo.toml",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/binary-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/binary-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/binary-sv2/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,21 @@\n+[package]\n+name = \"binary_sv2\"\n+version = \"0.1.4\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 data format\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde_sv2 = {version = \"0.1.0\", path = \"../serde-sv2\", optional = true}\n+serde = { version = \"1.0.89\", features = [\"derive\", \"alloc\"], default-features = false, optional = true }\n+binary_codec_sv2 = {version = \"0.1.*\", path = \"../no-serde-sv2/codec\", optional = true}\n+derive_codec_sv2 = {version = \"0.1.1\", path = \"../no-serde-sv2/derive_codec\", optional = true}\n+\n+[features]\n+default = [\"core\"]\n+core = [\"binary_codec_sv2\", \"derive_codec_sv2\"]\n+with_serde = [\"serde_sv2\", \"serde\"]\n+prop_test = [\"binary_codec_sv2/prop_test\", \"derive_codec_sv2\"]"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/rusty/protocols/v2/binary-sv2/binary-sv2/README.md",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/binary-sv2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/binary-sv2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/binary-sv2/README.md?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac"
      },
      {
        "sha": "d9b012ea4f09039f57924ced0af1f028e5bed835",
        "filename": "src/rusty/protocols/v2/binary-sv2/binary-sv2/src/lib.rs",
        "status": "added",
        "additions": 687,
        "deletions": 0,
        "changes": 687,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/binary-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/binary-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/binary-sv2/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,687 @@\n+// TODO unify errors from serde_sv2 and no-serde-sv2\n+\n+#[cfg(feature = \"with_serde\")]\n+pub use serde::{self, Deserialize, Serialize};\n+#[cfg(feature = \"with_serde\")]\n+pub use serde_sv2::*;\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use binary_codec_sv2::{self, Decodable as Deserialize, Encodable as Serialize, *};\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use derive_codec_sv2::{Decodable as Deserialize, Encodable as Serialize};\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    mod test_bytes {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Bytes<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_struct() {\n+            let mut bytes = [98; 890];\n+            let a: Bytes = (&mut bytes[..]).try_into().unwrap();\n+            let expected = Test { a };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_struct {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test {\n+            a: u32,\n+            b: u8,\n+            c: U24,\n+        }\n+\n+        #[test]\n+        fn test_struct() {\n+            let expected = Test {\n+                a: 456,\n+                b: 9,\n+                c: 67_u32.try_into().unwrap(),\n+            };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_f32 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test {\n+            a: u8,\n+            b: U24,\n+            c: f32,\n+        }\n+\n+        #[test]\n+        fn test_struct() {\n+            let expected = Test {\n+                c: 0.345,\n+                a: 9,\n+                b: 67_u32.try_into().unwrap(),\n+            };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_str032 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Str032<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_stro32() {\n+            let mut stro32 = format!(\"error-code\").into_bytes();\n+            let stro32: Str032 = (&mut stro32[..]).try_into().unwrap();\n+\n+            let expected = Test { a: stro32 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_b0255 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: B0255<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_b0255() {\n+            let mut b0255 = [6; 3];\n+            let b0255: B0255 = (&mut b0255[..]).try_into().unwrap();\n+\n+            let expected = Test { a: b0255 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_u256 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Clone, Deserialize, Serialize, PartialEq, Debug)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: U256<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_u256() {\n+            let mut u256 = [6_u8; 32];\n+            let u256: U256 = (&mut u256[..]).try_into().unwrap();\n+\n+            let expected = Test { a: u256 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_signature {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Signature<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_signature() {\n+            let mut s = [6; 64];\n+            let s: Signature = (&mut s[..]).try_into().unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_b016m {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            b: bool,\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: B016M<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_b016m() {\n+            let mut b = [0_u8; 70000];\n+            let b: B016M = (&mut b[..]).try_into().unwrap();\n+            //println!(\"{:?}\", to_bytes(&b).unwrap().len());\n+\n+            let expected = Test { a: b, b: true };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_b064k {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            b: bool,\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: B064K<'decoder>,\n+        }\n+\n+        #[test]\n+        fn test_b064k() {\n+            let mut b = [1, 2, 9];\n+            let b: B064K = (&mut b[..])\n+                .try_into()\n+                .expect(\"vector smaller than 64K should not fail\");\n+\n+            let expected = Test { a: b, b: true };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq0255_u256 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, U256<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u256() {\n+            let mut u256_1 = [6; 32];\n+            let mut u256_2 = [5; 32];\n+            let mut u256_3 = [0; 32];\n+            let u256_1: U256 = (&mut u256_1[..]).try_into().unwrap();\n+            let u256_2: U256 = (&mut u256_2[..]).try_into().unwrap();\n+            let u256_3: U256 = (&mut u256_3[..]).try_into().unwrap();\n+\n+            let val = vec![u256_1, u256_2, u256_3];\n+            let s = Seq0255::new(val).unwrap();\n+\n+            let test = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(test.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&test.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let bytes_2 = to_bytes(deserialized.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let bytes_2 = to_bytes(&deserialized.clone()).unwrap();\n+\n+            assert_eq!(bytes, bytes_2);\n+        }\n+    }\n+\n+    mod test_0255_bool {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, bool>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_bool() {\n+            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq0255_u16 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, u16>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u16() {\n+            let s: Seq0255<u16> = Seq0255::new(vec![10, 43, 89]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq_0255_u24 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, U24>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u24() {\n+            let u24_1: U24 = 56_u32.try_into().unwrap();\n+            let u24_2: U24 = 59_u32.try_into().unwrap();\n+            let u24_3: U24 = 70999_u32.try_into().unwrap();\n+\n+            let val = vec![u24_1, u24_2, u24_3];\n+            let s: Seq0255<U24> = Seq0255::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seqo255_u32 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, u32>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_u32() {\n+            let s: Seq0255<u32> = Seq0255::new(vec![546, 99999, 87, 32]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq0255_signature {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq0255<'decoder, Signature<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq0255_signature() {\n+            let mut siganture_1 = [88_u8; 64];\n+            let mut siganture_2 = [99_u8; 64];\n+            let mut siganture_3 = [220_u8; 64];\n+            let siganture_1: Signature = (&mut siganture_1[..]).try_into().unwrap();\n+            let siganture_2: Signature = (&mut siganture_2[..]).try_into().unwrap();\n+            let siganture_3: Signature = (&mut siganture_3[..]).try_into().unwrap();\n+\n+            let val = vec![siganture_1, siganture_2, siganture_3];\n+            let s: Seq0255<Signature> = Seq0255::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq_064_u256 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, U256<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u256() {\n+            let mut u256_1 = [6; 32];\n+            let mut u256_2 = [5; 32];\n+            let mut u256_3 = [0; 32];\n+            let u256_1: U256 = (&mut u256_1[..]).try_into().unwrap();\n+            let u256_2: U256 = (&mut u256_2[..]).try_into().unwrap();\n+            let u256_3: U256 = (&mut u256_3[..]).try_into().unwrap();\n+\n+            let val = vec![u256_1, u256_2, u256_3];\n+            let s = Seq064K::new(val).unwrap();\n+\n+            let test = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(test.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&test.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let bytes_2 = to_bytes(deserialized.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let bytes_2 = to_bytes(&deserialized.clone()).unwrap();\n+\n+            assert_eq!(bytes, bytes_2);\n+        }\n+    }\n+\n+    mod test_064_bool {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, bool>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_bool() {\n+            let s: Seq064K<bool> = Seq064K::new(vec![true, false, true]).unwrap();\n+            let s2: Seq064K<bool> = Seq064K::new(vec![true; 64000]).unwrap();\n+\n+            let expected = Test { a: s };\n+            let expected2 = Test { a: s2 };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes2 = to_bytes(expected2.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes2 = to_bytes(&expected2.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+            let deserialized2: Test = from_bytes(&mut bytes2[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+            assert_eq!(deserialized2, expected2);\n+        }\n+    }\n+\n+    mod test_se1o64k_u16 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, u16>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u16() {\n+            let s: Seq064K<u16> = Seq064K::new(vec![10, 43, 89]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq064k_u24 {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, U24>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u24() {\n+            let u24_1: U24 = 56_u32.try_into().unwrap();\n+            let u24_2: U24 = 59_u32.try_into().unwrap();\n+            let u24_3: U24 = 70999_u32.try_into().unwrap();\n+\n+            let val = vec![u24_1, u24_2, u24_3];\n+            let s: Seq064K<U24> = Seq064K::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+\n+    mod test_seq064k_u32 {\n+        use super::*;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, u32>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_u32() {\n+            let s: Seq064K<u32> = Seq064K::new(vec![546, 99999, 87, 32]).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+    mod test_seq064k_signature {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, Signature<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_signature() {\n+            let mut siganture_1 = [88_u8; 64];\n+            let mut siganture_2 = [99_u8; 64];\n+            let mut siganture_3 = [220_u8; 64];\n+            let siganture_1: Signature = (&mut siganture_1[..]).try_into().unwrap();\n+            let siganture_2: Signature = (&mut siganture_2[..]).try_into().unwrap();\n+            let siganture_3: Signature = (&mut siganture_3[..]).try_into().unwrap();\n+\n+            let val = vec![siganture_1, siganture_2, siganture_3];\n+            let s: Seq064K<Signature> = Seq064K::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+    mod test_seq064k_b016m {\n+        use super::*;\n+        use core::convert::TryInto;\n+\n+        #[derive(Deserialize, Serialize, PartialEq, Debug, Clone)]\n+        struct Test<'decoder> {\n+            #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+            a: Seq064K<'decoder, B016M<'decoder>>,\n+        }\n+\n+        #[test]\n+        fn test_seq064k_b016m() {\n+            let mut bytes_1 = [88_u8; 64];\n+            let mut bytes_2 = [99_u8; 64];\n+            let mut bytes_3 = [220_u8; 64];\n+            let bytes_1: B016M = (&mut bytes_1[..]).try_into().unwrap();\n+            let bytes_2: B016M = (&mut bytes_2[..]).try_into().unwrap();\n+            let bytes_3: B016M = (&mut bytes_3[..]).try_into().unwrap();\n+\n+            let val = vec![bytes_1, bytes_2, bytes_3];\n+            let s: Seq064K<B016M> = Seq064K::new(val).unwrap();\n+\n+            let expected = Test { a: s };\n+\n+            #[cfg(not(feature = \"with_serde\"))]\n+            let mut bytes = to_bytes(expected.clone()).unwrap();\n+            #[cfg(feature = \"with_serde\")]\n+            let mut bytes = to_bytes(&expected.clone()).unwrap();\n+\n+            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();\n+\n+            assert_eq!(deserialized, expected);\n+        }\n+    }\n+}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/.gitignore?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "57cd9c2bb0669d74671e7de61174d054ba77bb4b",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.lock",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.lock?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,5 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"parse\"\n+version = \"0.1.0\""
      },
      {
        "sha": "18b1a47089de1ec5a073e747517f18343efd6b8a",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"binary_codec_sv2\"\n+version = \"0.1.2\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 data format\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+quickcheck = {version = \"1.0.0\", optional = true}\n+\n+\n+[features]\n+no_std = []\n+deafult = [\"no_std\"]\n+prop_test = [\"quickcheck\"]"
      },
      {
        "sha": "d3e5e6829ef9f54aead4f09105f641665f59274f",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "status": "added",
        "additions": 293,
        "deletions": 0,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/decodable.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,293 @@\n+use crate::codec::{GetSize, SizeHint};\n+use crate::datatypes::{Bytes, Signature, Sv2DataType, B016M, B0255, B032, B064K, U24, U256};\n+use crate::Error;\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Cursor, Read};\n+\n+/// Implmented by all the decodable structure, it can be derived for every structure composed only\n+/// by primitives or other Decodable.\n+pub trait Decodable<'a>: Sized {\n+    fn get_structure(data: &[u8]) -> Result<Vec<FieldMarker>, Error>;\n+\n+    fn from_decoded_fields(data: Vec<DecodableField<'a>>) -> Result<Self, Error>;\n+\n+    fn from_bytes(data: &'a mut [u8]) -> Result<Self, Error> {\n+        let structure = Self::get_structure(data)?;\n+        let mut fields = Vec::new();\n+        let mut tail = data;\n+\n+        for field in structure {\n+            let field_size = field.size_hint_(tail, 0)?;\n+            let (head, t) = tail.split_at_mut(field_size);\n+            tail = t;\n+            fields.push(field.decode(head)?);\n+        }\n+        Self::from_decoded_fields(fields)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader(reader: &mut impl Read) -> Result<Self, Error> {\n+        let mut data = Vec::new();\n+        reader.read_to_end(&mut data)?;\n+\n+        let structure = Self::get_structure(&data[..])?;\n+\n+        let mut fields = Vec::new();\n+        let mut reader = Cursor::new(data);\n+\n+        for field in structure {\n+            fields.push(field.from_reader(&mut reader)?);\n+        }\n+        Self::from_decoded_fields(fields)\n+    }\n+}\n+\n+/// Passed to a decoder to define the structure of the data to be decoded\n+#[derive(Debug, Clone, Copy)]\n+pub enum PrimitiveMarker {\n+    U8,\n+    U16,\n+    Bool,\n+    U24,\n+    U256,\n+    Signature,\n+    U32,\n+    F32,\n+    U64,\n+    B032,\n+    B0255,\n+    B064K,\n+    B016M,\n+    Bytes,\n+}\n+\n+/// Passed to a decoder to define the structure of the data to be decoded\n+#[derive(Debug, Clone)]\n+pub enum FieldMarker {\n+    Primitive(PrimitiveMarker),\n+    Struct(Vec<FieldMarker>),\n+}\n+pub trait GetMarker {\n+    fn get_marker() -> FieldMarker;\n+}\n+\n+/// Used to contrustuct primitives is returned by the decoder\n+#[derive(Debug)]\n+pub enum DecodablePrimitive<'a> {\n+    U8(u8),\n+    U16(u16),\n+    Bool(bool),\n+    U24(U24),\n+    U256(U256<'a>),\n+    Signature(Signature<'a>),\n+    U32(u32),\n+    F32(f32),\n+    U64(u64),\n+    B032(B032<'a>),\n+    B0255(B0255<'a>),\n+    B064K(B064K<'a>),\n+    B016M(B016M<'a>),\n+    Bytes(Bytes<'a>),\n+}\n+\n+/// Used to contrustuct messages is returned by the decoder\n+#[derive(Debug)]\n+pub enum DecodableField<'a> {\n+    Primitive(DecodablePrimitive<'a>),\n+    Struct(Vec<DecodableField<'a>>),\n+}\n+\n+impl SizeHint for PrimitiveMarker {\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        unimplemented!()\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        match self {\n+            Self::U8 => u8::size_hint(data, offset),\n+            Self::U16 => u16::size_hint(data, offset),\n+            Self::Bool => bool::size_hint(data, offset),\n+            Self::U24 => U24::size_hint(data, offset),\n+            Self::U256 => U256::size_hint(data, offset),\n+            Self::Signature => Signature::size_hint(data, offset),\n+            Self::U32 => u32::size_hint(data, offset),\n+            Self::F32 => f32::size_hint(data, offset),\n+            Self::U64 => u64::size_hint(data, offset),\n+            Self::B032 => B032::size_hint(data, offset),\n+            Self::B0255 => B0255::size_hint(data, offset),\n+            Self::B064K => B064K::size_hint(data, offset),\n+            Self::B016M => B016M::size_hint(data, offset),\n+            Self::Bytes => Bytes::size_hint(data, offset),\n+        }\n+    }\n+}\n+\n+impl SizeHint for FieldMarker {\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        unimplemented!()\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        match self {\n+            Self::Primitive(p) => p.size_hint_(data, offset),\n+            Self::Struct(ps) => {\n+                let mut size = 0;\n+                for p in ps {\n+                    size += p.size_hint_(data, offset + size)?;\n+                }\n+                Ok(size)\n+            }\n+        }\n+    }\n+}\n+\n+impl SizeHint for Vec<FieldMarker> {\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        unimplemented!()\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        let mut size = 0;\n+        for field in self {\n+            let field_size = field.size_hint_(data, offset + size)?;\n+            size += field_size;\n+        }\n+        Ok(size)\n+    }\n+}\n+\n+impl From<PrimitiveMarker> for FieldMarker {\n+    fn from(v: PrimitiveMarker) -> Self {\n+        FieldMarker::Primitive(v)\n+    }\n+}\n+\n+impl From<Vec<FieldMarker>> for FieldMarker {\n+    fn from(mut v: Vec<FieldMarker>) -> Self {\n+        match v.len() {\n+            0 => panic!(\"TODO\"),\n+            1 => v.pop().unwrap(),\n+            _ => FieldMarker::Struct(v),\n+        }\n+    }\n+}\n+\n+impl<'a> From<DecodableField<'a>> for Vec<DecodableField<'a>> {\n+    fn from(v: DecodableField<'a>) -> Self {\n+        match v {\n+            DecodableField::Primitive(p) => vec![DecodableField::Primitive(p)],\n+            DecodableField::Struct(ps) => ps,\n+        }\n+    }\n+}\n+\n+impl PrimitiveMarker {\n+    fn decode<'a>(&self, data: &'a mut [u8], offset: usize) -> DecodablePrimitive<'a> {\n+        match self {\n+            Self::U8 => DecodablePrimitive::U8(u8::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U16 => DecodablePrimitive::U16(u16::from_bytes_unchecked(&mut data[offset..])),\n+            Self::Bool => DecodablePrimitive::Bool(bool::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U24 => DecodablePrimitive::U24(U24::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U256 => DecodablePrimitive::U256(U256::from_bytes_unchecked(&mut data[offset..])),\n+            Self::Signature => {\n+                DecodablePrimitive::Signature(Signature::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::U32 => DecodablePrimitive::U32(u32::from_bytes_unchecked(&mut data[offset..])),\n+            Self::F32 => DecodablePrimitive::F32(f32::from_bytes_unchecked(&mut data[offset..])),\n+            Self::U64 => DecodablePrimitive::U64(u64::from_bytes_unchecked(&mut data[offset..])),\n+            Self::B032 => DecodablePrimitive::B032(B032::from_bytes_unchecked(&mut data[offset..])),\n+            Self::B0255 => {\n+                DecodablePrimitive::B0255(B0255::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::B064K => {\n+                DecodablePrimitive::B064K(B064K::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::B016M => {\n+                DecodablePrimitive::B016M(B016M::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+            Self::Bytes => {\n+                DecodablePrimitive::Bytes(Bytes::from_bytes_unchecked(&mut data[offset..]))\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader<'a>(&self, reader: &mut impl Read) -> Result<DecodablePrimitive<'a>, Error> {\n+        match self {\n+            Self::U8 => Ok(DecodablePrimitive::U8(u8::from_reader_(reader)?)),\n+            Self::U16 => Ok(DecodablePrimitive::U16(u16::from_reader_(reader)?)),\n+            Self::Bool => Ok(DecodablePrimitive::Bool(bool::from_reader_(reader)?)),\n+            Self::U24 => Ok(DecodablePrimitive::U24(U24::from_reader_(reader)?)),\n+            Self::U256 => Ok(DecodablePrimitive::U256(U256::from_reader_(reader)?)),\n+            Self::Signature => Ok(DecodablePrimitive::Signature(Signature::from_reader_(\n+                reader,\n+            )?)),\n+            Self::U32 => Ok(DecodablePrimitive::U32(u32::from_reader_(reader)?)),\n+            Self::F32 => Ok(DecodablePrimitive::F32(f32::from_reader_(reader)?)),\n+            Self::U64 => Ok(DecodablePrimitive::U64(u64::from_reader_(reader)?)),\n+            Self::B032 => Ok(DecodablePrimitive::B032(B032::from_reader_(reader)?)),\n+            Self::B0255 => Ok(DecodablePrimitive::B0255(B0255::from_reader_(reader)?)),\n+            Self::B064K => Ok(DecodablePrimitive::B064K(B064K::from_reader_(reader)?)),\n+            Self::B016M => Ok(DecodablePrimitive::B016M(B016M::from_reader_(reader)?)),\n+            Self::Bytes => Ok(DecodablePrimitive::Bytes(Bytes::from_reader_(reader)?)),\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for DecodablePrimitive<'a> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            DecodablePrimitive::U8(v) => v.get_size(),\n+            DecodablePrimitive::U16(v) => v.get_size(),\n+            DecodablePrimitive::Bool(v) => v.get_size(),\n+            DecodablePrimitive::U24(v) => v.get_size(),\n+            DecodablePrimitive::U256(v) => v.get_size(),\n+            DecodablePrimitive::Signature(v) => v.get_size(),\n+            DecodablePrimitive::U32(v) => v.get_size(),\n+            DecodablePrimitive::F32(v) => v.get_size(),\n+            DecodablePrimitive::U64(v) => v.get_size(),\n+            DecodablePrimitive::B032(v) => v.get_size(),\n+            DecodablePrimitive::B0255(v) => v.get_size(),\n+            DecodablePrimitive::B064K(v) => v.get_size(),\n+            DecodablePrimitive::B016M(v) => v.get_size(),\n+            DecodablePrimitive::Bytes(v) => v.get_size(),\n+        }\n+    }\n+}\n+\n+impl FieldMarker {\n+    pub(crate) fn decode<'a>(&self, data: &'a mut [u8]) -> Result<DecodableField<'a>, Error> {\n+        match self {\n+            Self::Primitive(p) => Ok(DecodableField::Primitive(p.decode(data, 0))),\n+            Self::Struct(ps) => {\n+                let mut decodeds = Vec::new();\n+                let mut tail = data;\n+                for p in ps {\n+                    let field_size = p.size_hint_(tail, 0)?;\n+                    let (head, t) = tail.split_at_mut(field_size);\n+                    tail = t;\n+                    decodeds.push(p.decode(head)?);\n+                }\n+                Ok(DecodableField::Struct(decodeds))\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    pub(crate) fn from_reader<'a>(\n+        &self,\n+        reader: &mut impl Read,\n+    ) -> Result<DecodableField<'a>, Error> {\n+        match self {\n+            Self::Primitive(p) => Ok(DecodableField::Primitive(p.from_reader(reader)?)),\n+            Self::Struct(ps) => {\n+                let mut decodeds = Vec::new();\n+                for p in ps {\n+                    decodeds.push(p.from_reader(reader)?);\n+                }\n+                Ok(DecodableField::Struct(decodeds))\n+            }\n+        }\n+    }\n+}"
      },
      {
        "sha": "20b400562c6f1fd5c650dfdf6d75ed3bb457a957",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "status": "added",
        "additions": 165,
        "deletions": 0,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/encodable.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,165 @@\n+use crate::codec::GetSize;\n+use crate::datatypes::{Bytes, Signature, Sv2DataType, B016M, B0255, B032, B064K, U24, U256};\n+use crate::Error;\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Write};\n+\n+pub trait Encodable {\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_bytes(self, dst: &mut [u8]) -> Result<usize, Error>;\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_writer(self, dst: &mut impl Write) -> Result<(), E>;\n+}\n+\n+//\n+impl<'a, T: Into<EncodableField<'a>>> Encodable for T {\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_bytes(self, dst: &mut [u8]) -> Result<usize, Error> {\n+        let encoded_field = self.into();\n+        encoded_field.encode(dst, 0)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    #[allow(clippy::wrong_self_convention)]\n+    fn to_writer(self, dst: &mut impl Write) -> Result<(), E> {\n+        let encoded_field = self.into();\n+        encoded_field.to_writer(dst)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum EncodablePrimitive<'a> {\n+    U8(u8),\n+    OwnedU8(u8),\n+    U16(u16),\n+    Bool(bool),\n+    U24(U24),\n+    U256(U256<'a>),\n+    Signature(Signature<'a>),\n+    U32(u32),\n+    F32(f32),\n+    U64(u64),\n+    B032(B032<'a>),\n+    B0255(B0255<'a>),\n+    B064K(B064K<'a>),\n+    B016M(B016M<'a>),\n+    Bytes(Bytes<'a>),\n+}\n+\n+impl<'a> EncodablePrimitive<'a> {\n+    fn encode(&self, dst: &mut [u8]) -> Result<usize, Error> {\n+        match self {\n+            Self::U8(v) => v.to_slice(dst),\n+            Self::OwnedU8(v) => v.to_slice(dst),\n+            Self::U16(v) => v.to_slice(dst),\n+            Self::Bool(v) => v.to_slice(dst),\n+            Self::U24(v) => v.to_slice(dst),\n+            Self::U256(v) => v.to_slice(dst),\n+            Self::Signature(v) => v.to_slice(dst),\n+            Self::U32(v) => v.to_slice(dst),\n+            Self::F32(v) => v.to_slice(dst),\n+            Self::U64(v) => v.to_slice(dst),\n+            Self::B032(v) => v.to_slice(dst),\n+            Self::B0255(v) => v.to_slice(dst),\n+            Self::B064K(v) => v.to_slice(dst),\n+            Self::B016M(v) => v.to_slice(dst),\n+            Self::Bytes(v) => v.to_slice(dst),\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    pub fn write(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            Self::U8(v) => v.to_writer_(writer),\n+            Self::OwnedU8(v) => v.to_writer_(writer),\n+            Self::U16(v) => v.to_writer_(writer),\n+            Self::Bool(v) => v.to_writer_(writer),\n+            Self::U24(v) => v.to_writer_(writer),\n+            Self::U256(v) => v.to_writer_(writer),\n+            Self::Signature(v) => v.to_writer_(writer),\n+            Self::U32(v) => v.to_writer_(writer),\n+            Self::F32(v) => v.to_writer_(writer),\n+            Self::U64(v) => v.to_writer_(writer),\n+            Self::B032(v) => v.to_writer_(writer),\n+            Self::B0255(v) => v.to_writer_(writer),\n+            Self::B064K(v) => v.to_writer_(writer),\n+            Self::B016M(v) => v.to_writer_(writer),\n+            Self::Bytes(v) => v.to_writer_(writer),\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for EncodablePrimitive<'a> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Self::U8(v) => v.get_size(),\n+            Self::OwnedU8(v) => v.get_size(),\n+            Self::U16(v) => v.get_size(),\n+            Self::Bool(v) => v.get_size(),\n+            Self::U24(v) => v.get_size(),\n+            Self::U256(v) => v.get_size(),\n+            Self::Signature(v) => v.get_size(),\n+            Self::U32(v) => v.get_size(),\n+            Self::F32(v) => v.get_size(),\n+            Self::U64(v) => v.get_size(),\n+            Self::B032(v) => v.get_size(),\n+            Self::B0255(v) => v.get_size(),\n+            Self::B064K(v) => v.get_size(),\n+            Self::B016M(v) => v.get_size(),\n+            Self::Bytes(v) => v.get_size(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum EncodableField<'a> {\n+    Primitive(EncodablePrimitive<'a>),\n+    Struct(Vec<EncodableField<'a>>),\n+}\n+\n+impl<'a> EncodableField<'a> {\n+    pub fn encode(&self, dst: &mut [u8], mut offset: usize) -> Result<usize, Error> {\n+        match (self, dst.len() >= offset) {\n+            (Self::Primitive(p), true) => p.encode(&mut dst[offset..]),\n+            (Self::Struct(ps), true) => {\n+                for p in ps {\n+                    let encoded_bytes = p.encode(dst, offset)?;\n+                    offset += encoded_bytes;\n+                }\n+                Ok(offset)\n+            }\n+            _ => Err(Error::WriteError(offset, dst.len())),\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    pub fn to_writer(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            Self::Primitive(p) => p.write(writer),\n+            Self::Struct(ps) => {\n+                for p in ps {\n+                    p.to_writer(writer)?;\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> GetSize for EncodableField<'a> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Self::Primitive(p) => p.get_size(),\n+            Self::Struct(ps) => {\n+                let mut size = 0;\n+                for p in ps {\n+                    size += p.get_size();\n+                }\n+                size\n+            }\n+        }\n+    }\n+}"
      },
      {
        "sha": "a025b93d753effac312cf40066ea085234aeaf21",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "status": "added",
        "additions": 798,
        "deletions": 0,
        "changes": 798,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/impls.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,798 @@\n+use crate::codec::decodable::{\n+    Decodable, DecodableField, DecodablePrimitive, FieldMarker, GetMarker, PrimitiveMarker,\n+};\n+use crate::codec::encodable::{EncodableField, EncodablePrimitive};\n+use crate::datatypes::*;\n+use crate::Error;\n+use alloc::vec::Vec;\n+use core::convert::{TryFrom, TryInto};\n+\n+// IMPL GET MARKER FOR PRIMITIVES\n+impl GetMarker for bool {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::Bool)\n+    }\n+}\n+impl GetMarker for u8 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U8)\n+    }\n+}\n+impl GetMarker for u16 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U16)\n+    }\n+}\n+impl GetMarker for U24 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U24)\n+    }\n+}\n+impl GetMarker for u32 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U32)\n+    }\n+}\n+impl GetMarker for f32 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::F32)\n+    }\n+}\n+impl GetMarker for u64 {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U64)\n+    }\n+}\n+impl<'a> GetMarker for U256<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::U256)\n+    }\n+}\n+impl<'a> GetMarker for Signature<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::Signature)\n+    }\n+}\n+impl<'a> GetMarker for B032<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B032)\n+    }\n+}\n+impl<'a> GetMarker for B0255<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B0255)\n+    }\n+}\n+impl<'a> GetMarker for B064K<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B064K)\n+    }\n+}\n+impl<'a> GetMarker for B016M<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::B016M)\n+    }\n+}\n+impl<'a> GetMarker for Bytes<'a> {\n+    fn get_marker() -> FieldMarker {\n+        FieldMarker::Primitive(PrimitiveMarker::Bytes)\n+    }\n+}\n+\n+// IMPL DECODABLE FOR PRIMITIVES\n+\n+impl<'a> Decodable<'a> for u8 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U8.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for u16 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U16.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for u32 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U32.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for f32 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::F32.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for u64 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U64.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for bool {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::Bool.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for U24 {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U24.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for U256<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::U256.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for Signature<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::Signature.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B032<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B032.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B0255<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B0255.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B064K<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B064K.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+impl<'a> Decodable<'a> for B016M<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::B016M.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+\n+impl<'a> Decodable<'a> for Bytes<'a> {\n+    fn get_structure(_: &[u8]) -> Result<Vec<FieldMarker>, Error> {\n+        Ok(vec![PrimitiveMarker::Bytes.into()])\n+    }\n+\n+    fn from_decoded_fields(mut data: Vec<DecodableField<'a>>) -> Result<Self, Error> {\n+        data.pop().unwrap().try_into()\n+    }\n+}\n+\n+// IMPL TRY_FROM PRIMITIVE FOR PRIMITIVEs\n+\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u8 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U8(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u16 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U16(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U32(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for f32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::F32(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for u64 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U64(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for bool {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::Bool(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U24(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for U256<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::U256(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for Signature<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::Signature(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B032<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B032(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B0255<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B0255(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B064K<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B064K(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for B016M<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::B016M(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodablePrimitive<'a>> for Bytes<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodablePrimitive<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodablePrimitive::Bytes(val) => Ok(val),\n+            _ => Err(Error::PrimitiveConversionError),\n+        }\n+    }\n+}\n+\n+// IMPL TRY_FROM DECODEC FIELD FOR PRIMITIVES\n+\n+impl<'a> TryFrom<DecodableField<'a>> for u8 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for u16 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for u32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for f32 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for u64 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for bool {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for U256<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for Signature<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B032<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B0255<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B064K<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for B016M<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<DecodableField<'a>> for Bytes<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: DecodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            DecodableField::Primitive(p) => p.try_into(),\n+            _ => Err(Error::DecodableConversionError),\n+        }\n+    }\n+}\n+\n+// IMPL FROM PRIMITIVES FOR ENCODED FIELD\n+\n+impl<'a> From<bool> for EncodableField<'a> {\n+    fn from(v: bool) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::Bool(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for bool {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::Bool(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u8> for EncodableField<'a> {\n+    fn from(v: u8) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U8(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u8 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U8(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u16> for EncodableField<'a> {\n+    fn from(v: u16) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U16(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u16 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U16(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<U24> for EncodableField<'a> {\n+    fn from(v: U24) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U24(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U24(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u32> for EncodableField<'a> {\n+    fn from(v: u32) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U32(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u32 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U32(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<f32> for EncodableField<'a> {\n+    fn from(v: f32) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::F32(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for f32 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::F32(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<u64> for EncodableField<'a> {\n+    fn from(v: u64) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U64(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for u64 {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U64(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<U256<'a>> for EncodableField<'a> {\n+    fn from(v: U256<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::U256(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for U256<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::U256(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<Signature<'a>> for EncodableField<'a> {\n+    fn from(v: Signature<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::Signature(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for Signature<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::Signature(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<B032<'a>> for EncodableField<'a> {\n+    fn from(v: B032<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B032(v))\n+    }\n+}\n+impl<'a> From<B0255<'a>> for EncodableField<'a> {\n+    fn from(v: B0255<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B0255(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B032<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B032(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B0255<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B0255(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<B064K<'a>> for EncodableField<'a> {\n+    fn from(v: B064K<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B064K(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B064K<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B064K(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<B016M<'a>> for EncodableField<'a> {\n+    fn from(v: B016M<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::B016M(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for B016M<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::B016M(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+impl<'a> From<Bytes<'a>> for EncodableField<'a> {\n+    fn from(v: Bytes<'a>) -> Self {\n+        EncodableField::Primitive(EncodablePrimitive::Bytes(v))\n+    }\n+}\n+impl<'a> TryFrom<EncodableField<'a>> for Bytes<'a> {\n+    type Error = Error;\n+\n+    fn try_from(value: EncodableField<'a>) -> Result<Self, Self::Error> {\n+        match value {\n+            EncodableField::Primitive(EncodablePrimitive::Bytes(v)) => Ok(v),\n+            _ => Err(Error::Todo),\n+        }\n+    }\n+}\n+//impl<'a> From<&'a Seq0255<'a, U24>> for EncodableField<'a> {\n+//    fn from(v: &'a Seq0255<'a, U24>) -> Self {\n+//        EncodableField::Primitive(EncodablePrimitive::Seq0255u24(v))\n+//    }\n+//}\n+\n+// IMPL INTO FIELD MARKER FOR PRIMITIVES\n+impl From<bool> for FieldMarker {\n+    fn from(_: bool) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::Bool)\n+    }\n+}\n+impl From<u8> for FieldMarker {\n+    fn from(_: u8) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U8)\n+    }\n+}\n+\n+impl From<u16> for FieldMarker {\n+    fn from(_: u16) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U16)\n+    }\n+}\n+\n+impl From<u32> for FieldMarker {\n+    fn from(_: u32) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U32)\n+    }\n+}\n+\n+impl From<f32> for FieldMarker {\n+    fn from(_: f32) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::F32)\n+    }\n+}\n+\n+impl From<u64> for FieldMarker {\n+    fn from(_: u64) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U64)\n+    }\n+}\n+\n+impl From<U24> for FieldMarker {\n+    fn from(_: U24) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U24)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, true, 32, 0, 0>> for FieldMarker {\n+    fn from(_: Inner<'a, true, 32, 0, 0>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::U256)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, true, 64, 0, 0>> for FieldMarker {\n+    fn from(_: Inner<'a, true, 64, 0, 0>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::Signature)\n+    }\n+}\n+\n+impl<'a> From<B032<'a>> for FieldMarker {\n+    fn from(_: B032<'a>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B032)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, false, 1, 1, 255>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 1, 1, 255>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B0255)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, false, 1, 2, { 2_usize.pow(16) - 1 }>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 1, 2, { 2_usize.pow(16) - 1 }>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B064K)\n+    }\n+}\n+\n+impl<'a> From<Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::B016M)\n+    }\n+}\n+impl<'a> From<Bytes<'a>> for FieldMarker {\n+    fn from(_: Inner<'a, false, 0, 0, { ((2_usize.pow(63) - 1) * 2) + 1 }>) -> Self {\n+        FieldMarker::Primitive(PrimitiveMarker::Bytes)\n+    }\n+}"
      },
      {
        "sha": "91bef226d3f7fe57c6dcf49f9cef074fa4ce9c23",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/codec/mod.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,54 @@\n+// At lower level I generally prefer to work with slices as more efficient than Read/Write streams\n+// eg: Read for & [u8] is implemented with memcpy but here is more than enough to just get a\n+// pointer to the original data\n+\n+// ANche se enum decode sarebbe faclie da implementare non viene fatto dato che ogni messaggio puo\n+// essere derivato dal suo numero!\n+use crate::Error;\n+pub mod decodable;\n+pub mod encodable;\n+mod impls;\n+\n+/// Return the encoded byte size or a `Decodable`\n+pub trait SizeHint {\n+    fn size_hint(data: &[u8], offset: usize) -> Result<usize, Error>;\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error>;\n+}\n+\n+/// Return the encoded byte size of an `Encodable` comprehensive of the header, if any\n+pub trait GetSize {\n+    fn get_size(&self) -> usize;\n+}\n+\n+/// Implemented by all the primitives with a fixed size\n+pub trait Fixed {\n+    const SIZE: usize;\n+}\n+\n+pub trait Variable {\n+    const HEADER_SIZE: usize;\n+    //const ELEMENT_SIZE: usize;\n+    const MAX_SIZE: usize;\n+\n+    fn inner_size(&self) -> usize;\n+\n+    // TODO use [u8; HEADER_SIZE] instead of Vec\n+    fn get_header(&self) -> Vec<u8>;\n+}\n+\n+impl<T: Fixed> SizeHint for T {\n+    /// Total size of the encoded data type compreensive of the header when present\n+    fn size_hint(_data: &[u8], _offset: usize) -> Result<usize, Error> {\n+        Ok(Self::SIZE)\n+    }\n+\n+    fn size_hint_(&self, _: &[u8], _offset: usize) -> Result<usize, Error> {\n+        Ok(Self::SIZE)\n+    }\n+}\n+\n+impl<T: Fixed> GetSize for T {\n+    fn get_size(&self) -> usize {\n+        Self::SIZE\n+    }\n+}"
      },
      {
        "sha": "62d23b0faf7938e48c82f62359d8157b85935928",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "status": "added",
        "additions": 177,
        "deletions": 0,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/copy_data_types.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,177 @@\n+//! Copy data types\n+use crate::codec::Fixed;\n+use crate::datatypes::Sv2DataType;\n+use crate::Error;\n+use core::convert::{TryFrom, TryInto};\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Read, Write};\n+\n+// Impl bool as a primitive\n+\n+impl Fixed for bool {\n+    const SIZE: usize = 1;\n+}\n+\n+// Boolean value. Encoded as an unsigned 1-bit integer,\n+// True = 1, False = 0 with 7 additional padding bits in\n+// the high positions.\n+// x\n+// Recipients MUST NOT interpret bits outside of the\n+// least significant bit. Senders MAY set bits outside of\n+// the least significant bit to any value without any\n+// impact on meaning. This allows future use of other\n+// bits as flag bits.\n+impl<'a> Sv2DataType<'a> for bool {\n+    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n+        match data\n+            .get(0)\n+            .map(|x: &u8| x << 7)\n+            .map(|x: u8| x >> 7)\n+            .unwrap()\n+        {\n+            0 => false,\n+            1 => true,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    fn from_vec_(mut data: Vec<u8>) -> Result<Self, Error> {\n+        Self::from_bytes_(&mut data)\n+    }\n+\n+    fn from_vec_unchecked(mut data: Vec<u8>) -> Self {\n+        Self::from_bytes_unchecked(&mut data)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader_(reader: &mut impl Read) -> Result<Self, Error> {\n+        let mut dst = [0_u8; Self::SIZE];\n+        reader.read_exact(&mut dst)?;\n+        Self::from_bytes_(&mut dst)\n+    }\n+\n+    fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n+        match self {\n+            true => dst[0] = 1,\n+            false => dst[0] = 0,\n+        };\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            true => writer.write_all(&[1]),\n+            false => writer.write_all(&[0]),\n+        }\n+    }\n+}\n+\n+// Impl unsigned as a primitives\n+\n+impl Fixed for u8 {\n+    const SIZE: usize = 1;\n+}\n+\n+impl Fixed for u16 {\n+    const SIZE: usize = 2;\n+}\n+\n+impl Fixed for u32 {\n+    const SIZE: usize = 4;\n+}\n+\n+// TODO fix not in the specs\n+impl Fixed for u64 {\n+    const SIZE: usize = 8;\n+}\n+\n+macro_rules! impl_sv2_for_unsigned {\n+    ($a:ty) => {\n+        impl<'a> Sv2DataType<'a> for $a {\n+            fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n+                let a: &[u8; Self::SIZE] = data[0..Self::SIZE].try_into().unwrap();\n+                Self::from_le_bytes(*a)\n+            }\n+\n+            fn from_vec_(mut data: Vec<u8>) -> Result<Self, Error> {\n+                Self::from_bytes_(&mut data)\n+            }\n+\n+            fn from_vec_unchecked(mut data: Vec<u8>) -> Self {\n+                Self::from_bytes_unchecked(&mut data)\n+            }\n+\n+            #[cfg(not(feature = \"no_std\"))]\n+            fn from_reader_(reader: &mut impl Read) -> Result<Self, Error> {\n+                let mut dst = [0_u8; Self::SIZE];\n+                reader.read_exact(&mut dst)?;\n+                Ok(Self::from_bytes_unchecked(&mut dst))\n+            }\n+\n+            fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n+                let dst = &mut dst[0..Self::SIZE];\n+                let src = self.to_le_bytes();\n+                dst.copy_from_slice(&src);\n+            }\n+\n+            #[cfg(not(feature = \"no_std\"))]\n+            fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n+                let bytes = self.to_le_bytes();\n+                writer.write_all(&bytes)\n+            }\n+        }\n+    };\n+}\n+impl_sv2_for_unsigned!(u8);\n+impl_sv2_for_unsigned!(u16);\n+impl_sv2_for_unsigned!(u32);\n+impl_sv2_for_unsigned!(u64);\n+\n+// Impl f32 as a primitives\n+\n+impl Fixed for f32 {\n+    const SIZE: usize = 4;\n+}\n+\n+impl_sv2_for_unsigned!(f32);\n+\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy, Eq, PartialEq)]\n+pub struct U24(pub(crate) u32);\n+\n+impl Fixed for U24 {\n+    const SIZE: usize = 3;\n+}\n+\n+impl U24 {\n+    fn from_le_bytes(b: [u8; Self::SIZE]) -> Self {\n+        let inner = u32::from_le_bytes([b[0], b[1], b[2], 0]);\n+        Self(inner)\n+    }\n+\n+    fn to_le_bytes(self) -> [u8; Self::SIZE] {\n+        let b = self.0.to_le_bytes();\n+        [b[0], b[1], b[2]]\n+    }\n+}\n+\n+impl_sv2_for_unsigned!(U24);\n+\n+impl TryFrom<u32> for U24 {\n+    type Error = Error;\n+\n+    fn try_from(value: u32) -> Result<Self, Self::Error> {\n+        if value <= 16777215 {\n+            Ok(Self(value))\n+        } else {\n+            Err(Error::InvalidU24(value))\n+        }\n+    }\n+}\n+\n+impl From<U24> for u32 {\n+    fn from(v: U24) -> Self {\n+        v.0\n+    }\n+}"
      },
      {
        "sha": "162c0499e2f844c7885924bd09a9cd849cdc4e24",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/mod.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,44 @@\n+use crate::codec::{GetSize, SizeHint};\n+use crate::Error;\n+mod non_copy_data_types;\n+\n+mod copy_data_types;\n+use crate::codec::decodable::FieldMarker;\n+pub use copy_data_types::U24;\n+pub use non_copy_data_types::{\n+    Bytes, Inner, PubKey, Seq0255, Seq064K, Signature, Str0255, Str032, B016M, B0255, B032, B064K,\n+    U256,\n+};\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Read, Write};\n+\n+pub trait Sv2DataType<'a>: Sized + SizeHint + GetSize + Into<FieldMarker> {\n+    fn from_bytes_(data: &'a mut [u8]) -> Result<Self, Error> {\n+        Self::size_hint(data, 0)?;\n+        Ok(Self::from_bytes_unchecked(data))\n+    }\n+\n+    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self;\n+\n+    fn from_vec_(data: Vec<u8>) -> Result<Self, Error>;\n+\n+    fn from_vec_unchecked(data: Vec<u8>) -> Self;\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader_(reader: &mut impl Read) -> Result<Self, Error>;\n+\n+    fn to_slice(&'a self, dst: &mut [u8]) -> Result<usize, Error> {\n+        if dst.len() >= self.get_size() {\n+            self.to_slice_unchecked(dst);\n+            Ok(self.get_size())\n+        } else {\n+            Err(Error::WriteError(self.get_size(), dst.len()))\n+        }\n+    }\n+\n+    fn to_slice_unchecked(&'a self, dst: &mut [u8]);\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E>;\n+}"
      },
      {
        "sha": "46930d4e4b8337e6548bffe45936d03dc93154e6",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "status": "added",
        "additions": 274,
        "deletions": 0,
        "changes": 274,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/inner.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,274 @@\n+use super::IntoOwned;\n+use crate::codec::{GetSize, SizeHint};\n+use crate::datatypes::Sv2DataType;\n+use crate::Error;\n+use core::convert::TryFrom;\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, Read, Write};\n+\n+#[repr(C)]\n+#[derive(Debug)]\n+pub enum Inner<\n+    'a,\n+    const ISFIXED: bool,\n+    const SIZE: usize,\n+    const HEADERSIZE: usize,\n+    const MAXSIZE: usize,\n+> {\n+    Ref(&'a mut [u8]),\n+    Owned(Vec<u8>),\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    PartialEq for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Inner::Ref(b), Inner::Owned(a)) => *b == &a[..],\n+            (Inner::Owned(b), Inner::Ref(a)) => *a == &b[..],\n+            (Inner::Owned(b), Inner::Owned(a)) => b == a,\n+            (Inner::Ref(b), Inner::Ref(a)) => b == a,\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize> Eq\n+    for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn expected_length(data: &[u8]) -> Result<usize, Error> {\n+        let expected_length = match ISFIXED {\n+            true => Self::expected_length_fixed(),\n+            false => Self::expected_length_variable(data)?,\n+        };\n+        if ISFIXED || expected_length <= MAXSIZE {\n+            Ok(expected_length)\n+        } else {\n+            Err(Error::ReadError(data.len(), MAXSIZE))\n+        }\n+    }\n+\n+    fn expected_length_fixed() -> usize {\n+        SIZE\n+    }\n+\n+    fn expected_length_variable(data: &[u8]) -> Result<usize, Error> {\n+        if data.len() >= HEADERSIZE {\n+            let size = match HEADERSIZE {\n+                0 => Ok(data.len()),\n+                1 => Ok(data[0] as usize),\n+                2 => Ok(u16::from_le_bytes([data[0], data[1]]) as usize),\n+                3 => Ok(u32::from_le_bytes([data[0], data[1], data[2], 0]) as usize),\n+                _ => unimplemented!(),\n+            };\n+            size.map(|x| x + HEADERSIZE)\n+        } else {\n+            Err(Error::ReadError(data.len(), HEADERSIZE))\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn expected_length_for_reader(mut reader: impl Read) -> Result<usize, Error> {\n+        if ISFIXED {\n+            Ok(SIZE)\n+        } else {\n+            let mut header = [0_u8; HEADERSIZE];\n+            reader.read_exact(&mut header)?;\n+            let expected_length = match HEADERSIZE {\n+                1 => header[0] as usize,\n+                2 => u16::from_le_bytes([header[0], header[1]]) as usize,\n+                3 => u32::from_le_bytes([header[0], header[1], header[2], 0]) as usize,\n+                _ => unimplemented!(),\n+            };\n+            if expected_length <= MAXSIZE {\n+                Ok(expected_length)\n+            } else {\n+                Err(Error::ReadError(expected_length, MAXSIZE))\n+            }\n+        }\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        match (self, ISFIXED) {\n+            (Inner::Ref(data), false) => data.len(),\n+            (Inner::Owned(data), false) => data.len(),\n+            (_, true) => 1,\n+        }\n+    }\n+\n+    fn get_header(&self) -> Vec<u8> {\n+        if HEADERSIZE == 0 {\n+            Vec::new()\n+        } else {\n+            let len = self.len();\n+            len.to_le_bytes().into()\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    TryFrom<&'a mut [u8]> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    type Error = Error;\n+\n+    fn try_from(value: &'a mut [u8]) -> Result<Self, Self::Error> {\n+        if ISFIXED && value.len() == SIZE {\n+            Ok(Self::Ref(value))\n+        } else if ISFIXED {\n+            Err(Error::Todo)\n+        } else if value.len() <= MAXSIZE {\n+            Ok(Self::Ref(value))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    TryFrom<Vec<u8>> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    type Error = Error;\n+\n+    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {\n+        if ISFIXED && value.len() == SIZE {\n+            Ok(Self::Owned(value))\n+        } else if ISFIXED {\n+            Err(Error::Todo)\n+        } else if value.len() <= MAXSIZE {\n+            Ok(Self::Owned(value))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    GetSize for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Inner::Ref(data) => data.len() + HEADERSIZE,\n+            Inner::Owned(data) => data.len() + HEADERSIZE,\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const HEADERSIZE: usize, const SIZE: usize, const MAXSIZE: usize>\n+    SizeHint for Inner<'a, ISFIXED, HEADERSIZE, SIZE, MAXSIZE>\n+{\n+    fn size_hint(data: &[u8], offset: usize) -> Result<usize, Error> {\n+        Self::expected_length(&data[offset..])\n+    }\n+\n+    fn size_hint_(&self, data: &[u8], offset: usize) -> Result<usize, Error> {\n+        Self::expected_length(&data[offset..])\n+    }\n+}\n+use crate::codec::decodable::FieldMarker;\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    Sv2DataType<'a> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+where\n+    Self: Into<FieldMarker>,\n+{\n+    fn from_bytes_unchecked(data: &'a mut [u8]) -> Self {\n+        if ISFIXED {\n+            Self::Ref(data)\n+        } else {\n+            Self::Ref(&mut data[HEADERSIZE..])\n+        }\n+    }\n+\n+    fn from_vec_(data: Vec<u8>) -> Result<Self, Error> {\n+        Self::size_hint(&data, 0)?;\n+        Ok(Self::Owned(data))\n+    }\n+\n+    fn from_vec_unchecked(data: Vec<u8>) -> Self {\n+        Self::Owned(data)\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn from_reader_(mut reader: &mut impl Read) -> Result<Self, Error> {\n+        let size = Self::expected_length_for_reader(&mut reader)?;\n+\n+        let mut dst = vec![0; size];\n+\n+        reader.read_exact(&mut dst)?;\n+        Ok(Self::from_vec_unchecked(dst))\n+    }\n+\n+    fn to_slice_unchecked(&'a self, dst: &mut [u8]) {\n+        let size = self.get_size();\n+        let header = self.get_header();\n+        dst[0..HEADERSIZE].copy_from_slice(&header[..HEADERSIZE]);\n+        match self {\n+            Inner::Ref(data) => {\n+                let dst = &mut dst[0..size];\n+                dst[HEADERSIZE..].copy_from_slice(data);\n+            }\n+            Inner::Owned(data) => {\n+                let dst = &mut dst[0..size];\n+                dst[HEADERSIZE..].copy_from_slice(data);\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"no_std\"))]\n+    fn to_writer_(&self, writer: &mut impl Write) -> Result<(), E> {\n+        match self {\n+            Inner::Ref(data) => {\n+                writer.write_all(data)?;\n+            }\n+            Inner::Owned(data) => {\n+                writer.write_all(data)?;\n+            }\n+        };\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    IntoOwned for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn into_owned(self) -> Self {\n+        match self {\n+            Inner::Ref(data) => {\n+                let v: Vec<u8> = data.into();\n+                Self::Owned(v)\n+            }\n+            Inner::Owned(_) => self,\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    Clone for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn clone(&self) -> Self {\n+        match self {\n+            Inner::Ref(data) => {\n+                let mut v = Vec::with_capacity(data.len());\n+                v.extend_from_slice(data);\n+                Self::Owned(v)\n+            }\n+            Inner::Owned(data) => Inner::Owned(data.clone()),\n+        }\n+    }\n+}\n+\n+impl<'a, const ISFIXED: bool, const SIZE: usize, const HEADERSIZE: usize, const MAXSIZE: usize>\n+    AsRef<[u8]> for Inner<'a, ISFIXED, SIZE, HEADERSIZE, MAXSIZE>\n+{\n+    fn as_ref(&self) -> &[u8] {\n+        match self {\n+            Inner::Ref(r) => &r[..],\n+            Inner::Owned(r) => &r[..],\n+        }\n+    }\n+}"
      },
      {
        "sha": "e0a8a29dbaaef564da0e7ad6e80475e47e085dc9",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/mod.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,50 @@\n+#[cfg(feature = \"prop_test\")]\n+use core::convert::TryInto;\n+#[cfg(feature = \"prop_test\")]\n+use quickcheck::{Arbitrary, Gen};\n+\n+mod inner;\n+mod seq_inner;\n+\n+trait IntoOwned {\n+    fn into_owned(self) -> Self;\n+}\n+\n+pub use inner::Inner;\n+pub use seq_inner::{Seq0255, Seq064K};\n+\n+pub type U256<'a> = Inner<'a, true, 32, 0, 0>;\n+pub type PubKey<'a> = Inner<'a, true, 32, 0, 0>;\n+pub type Signature<'a> = Inner<'a, true, 64, 0, 0>;\n+pub type B032<'a> = Inner<'a, false, 1, 1, 32>;\n+pub type B0255<'a> = Inner<'a, false, 1, 1, 255>;\n+pub type Str032<'a> = Inner<'a, false, 1, 1, 32>;\n+pub type Str0255<'a> = Inner<'a, false, 1, 1, 255>;\n+pub type B064K<'a> = Inner<'a, false, 1, 2, { u16::MAX as usize }>;\n+pub type B016M<'a> = Inner<'a, false, 1, 3, { 2_usize.pow(24) - 1 }>;\n+pub type Bytes<'a> = Inner<'a, false, 0, 0, { usize::MAX }>;\n+\n+impl<'decoder> From<[u8; 32]> for U256<'decoder> {\n+    fn from(v: [u8; 32]) -> Self {\n+        Inner::Owned(v.into())\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[cfg(feature = \"prop_test\")]\n+impl<'a> U256<'a> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let mut inner = Vec::<u8>::arbitrary(g);\n+        inner.resize(32, 0);\n+        let inner: [u8; 32] = inner.try_into().unwrap();\n+        inner.into()\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[cfg(feature = \"prop_test\")]\n+impl<'a> B016M<'a> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        Vec::<u8>::arbitrary(g).try_into().unwrap()\n+    }\n+}"
      },
      {
        "sha": "7283a819964af577ff36e5b02353669249ec4d20",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "status": "added",
        "additions": 253,
        "deletions": 0,
        "changes": 253,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/datatypes/non_copy_data_types/seq_inner.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,253 @@\n+use crate::codec::decodable::{Decodable, DecodableField, FieldMarker, GetMarker, PrimitiveMarker};\n+use crate::codec::encodable::{EncodableField, EncodablePrimitive};\n+use crate::codec::GetSize;\n+use crate::datatypes::Sv2DataType;\n+use crate::datatypes::*;\n+use crate::Error;\n+use core::marker::PhantomData;\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::Read;\n+\n+/// The liftime is here only for type compatibility with serde-sv2\n+#[repr(C)]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Seq0255<'a, T>(pub(crate) Vec<T>, PhantomData<&'a T>);\n+\n+impl<'a, T: 'a> Seq0255<'a, T> {\n+    const HEADERSIZE: usize = 1;\n+\n+    /// Return the len of the inner vector\n+    fn expected_len(data: &[u8]) -> Result<usize, Error> {\n+        if data.len() >= Self::HEADERSIZE {\n+            Ok(data[0] as usize)\n+        } else {\n+            Err(Error::ReadError(data.len(), Self::HEADERSIZE))\n+        }\n+    }\n+\n+    pub fn new(inner: Vec<T>) -> Result<Self, Error> {\n+        if inner.len() <= 255 {\n+            Ok(Self(inner, PhantomData))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+\n+    //pub fn try_from_slice(inner: &'a mut [T]) -> Result<Self, Error> {\n+    //    if inner.len() <= 255 {\n+    //        let inner_: Vec<T> = vec![];\n+    //        for v in inner {\n+    //            inner_.push(v);\n+    //        }\n+    //        Ok(Self(inner_, PhantomData))\n+    //    } else {\n+    //        Err(Error::Todo)\n+    //    }\n+    //}\n+}\n+\n+impl<'a, T: GetSize> GetSize for Seq0255<'a, T> {\n+    fn get_size(&self) -> usize {\n+        let mut size = Self::HEADERSIZE;\n+        for with_size in &self.0 {\n+            size += with_size.get_size()\n+        }\n+        size\n+    }\n+}\n+\n+/// The liftime is here only for type compatibility with serde-sv2\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Seq064K<'a, T>(pub(crate) Vec<T>, PhantomData<&'a T>);\n+\n+impl<'a, T: 'a> Seq064K<'a, T> {\n+    const HEADERSIZE: usize = 2;\n+\n+    /// Return the len of the inner vector\n+    fn expected_len(data: &[u8]) -> Result<usize, Error> {\n+        if data.len() >= Self::HEADERSIZE {\n+            Ok(u16::from_le_bytes([data[0], data[1]]) as usize)\n+        } else {\n+            Err(Error::ReadError(data.len(), Self::HEADERSIZE))\n+        }\n+    }\n+\n+    pub fn new(inner: Vec<T>) -> Result<Self, Error> {\n+        if inner.len() <= 65535 {\n+            Ok(Self(inner, PhantomData))\n+        } else {\n+            Err(Error::Todo)\n+        }\n+    }\n+}\n+\n+impl<'a, T: GetSize> GetSize for Seq064K<'a, T> {\n+    fn get_size(&self) -> usize {\n+        let mut size = Self::HEADERSIZE;\n+        for with_size in &self.0 {\n+            size += with_size.get_size()\n+        }\n+        size\n+    }\n+}\n+\n+macro_rules! impl_codec_for_sequence {\n+    ($a:ty) => {\n+        impl<'a, T: 'a + Sv2DataType<'a> + GetMarker + GetSize + Decodable<'a>> Decodable<'a>\n+            for $a\n+        {\n+            fn get_structure(\n+                data: &[u8],\n+            ) -> Result<Vec<crate::codec::decodable::FieldMarker>, Error> {\n+                let len = Self::expected_len(data)?;\n+                let mut inner = Vec::with_capacity(len + Self::HEADERSIZE);\n+                for _ in 0..Self::HEADERSIZE {\n+                    inner.push(FieldMarker::Primitive(PrimitiveMarker::U8));\n+                }\n+                let inner_type = T::get_marker();\n+                inner.resize(len + Self::HEADERSIZE, inner_type);\n+                Ok(inner)\n+            }\n+\n+            fn from_decoded_fields(\n+                data: Vec<crate::codec::decodable::DecodableField<'a>>,\n+            ) -> Result<Self, Error> {\n+                let mut inner: Vec<T> = Vec::with_capacity(data.len());\n+                let mut i = 0;\n+                for element in data {\n+                    if i >= Self::HEADERSIZE {\n+                        match element {\n+                            DecodableField::Primitive(p) => {\n+                                let element =\n+                                    T::from_decoded_fields(vec![DecodableField::Primitive(p)]);\n+                                inner.push(element?)\n+                            }\n+                            DecodableField::Struct(_) => unimplemented!(),\n+                        }\n+                    }\n+                    i += 1;\n+                }\n+                Ok(Self(inner, PhantomData))\n+            }\n+\n+            fn from_bytes(data: &'a mut [u8]) -> Result<Self, Error> {\n+                let len = Self::expected_len(data)?;\n+\n+                let mut inner = Vec::new();\n+                let mut tail = &mut data[Self::HEADERSIZE..];\n+\n+                for _ in 0..len {\n+                    let element_size = T::size_hint(tail, 0)?;\n+                    let (head, t) = tail.split_at_mut(element_size);\n+                    tail = t;\n+                    inner.push(T::from_bytes_unchecked(head));\n+                }\n+                Ok(Self(inner, PhantomData))\n+            }\n+\n+            #[cfg(not(feature = \"no_std\"))]\n+            fn from_reader(reader: &mut impl Read) -> Result<Self, Error> {\n+                let mut header = vec![0; Self::HEADERSIZE];\n+                reader.read_exact(&mut header)?;\n+\n+                let len = Self::expected_len(&header)?;\n+\n+                let mut inner = Vec::new();\n+\n+                for _ in 0..len {\n+                    inner.push(T::from_reader_(reader)?);\n+                }\n+                Ok(Self(inner, PhantomData))\n+            }\n+        }\n+    };\n+}\n+\n+impl_codec_for_sequence!(Seq0255<'a, T>);\n+impl_codec_for_sequence!(Seq064K<'a, T>);\n+\n+macro_rules! impl_into_encodable_field_for_seq {\n+    ($a:ty) => {\n+        impl<'a> From<Seq064K<'a, $a>> for EncodableField<'a> {\n+            fn from(v: Seq064K<'a, $a>) -> Self {\n+                let inner_len = v.0.len() as u16;\n+                let mut as_encodable: Vec<EncodableField> =\n+                    Vec::with_capacity((inner_len + 2) as usize);\n+                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n+                    inner_len.to_le_bytes()[0],\n+                )));\n+                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n+                    inner_len.to_le_bytes()[1],\n+                )));\n+                for element in v.0 {\n+                    as_encodable.push(element.into());\n+                }\n+                EncodableField::Struct(as_encodable)\n+            }\n+        }\n+\n+        impl<'a> From<Seq0255<'a, $a>> for EncodableField<'a> {\n+            fn from(v: Seq0255<$a>) -> Self {\n+                let inner_len = v.0.len() as u8;\n+                let mut as_encodable: Vec<EncodableField> =\n+                    Vec::with_capacity((inner_len + 1) as usize);\n+                as_encodable.push(EncodableField::Primitive(EncodablePrimitive::OwnedU8(\n+                    inner_len,\n+                )));\n+                for element in v.0 {\n+                    as_encodable.push(element.into());\n+                }\n+                EncodableField::Struct(as_encodable)\n+            }\n+        }\n+    };\n+}\n+\n+impl_into_encodable_field_for_seq!(bool);\n+impl_into_encodable_field_for_seq!(u8);\n+impl_into_encodable_field_for_seq!(u16);\n+impl_into_encodable_field_for_seq!(U24);\n+impl_into_encodable_field_for_seq!(u32);\n+impl_into_encodable_field_for_seq!(u64);\n+impl_into_encodable_field_for_seq!(U256<'a>);\n+impl_into_encodable_field_for_seq!(Signature<'a>);\n+impl_into_encodable_field_for_seq!(B0255<'a>);\n+impl_into_encodable_field_for_seq!(B064K<'a>);\n+impl_into_encodable_field_for_seq!(B016M<'a>);\n+\n+#[cfg(feature = \"prop_test\")]\n+impl<'a, T> std::convert::TryFrom<Seq0255<'a, T>> for Vec<T> {\n+    type Error = &'static str;\n+    fn try_from(v: Seq0255<'a, T>) -> Result<Self, Self::Error> {\n+        if v.0.len() > 255 {\n+            Ok(v.0)\n+        } else {\n+            Err(\"Incorrect length, expected 225\")\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl<'a, T> std::convert::TryFrom<Seq064K<'a, T>> for Vec<T> {\n+    type Error = &'static str;\n+    fn try_from(v: Seq064K<'a, T>) -> Result<Self, Self::Error> {\n+        if v.0.len() > 64 {\n+            Ok(v.0)\n+        } else {\n+            Err(\"Incorrect length, expected 64\")\n+        }\n+    }\n+}\n+\n+impl<'a, T> From<Vec<T>> for Seq0255<'a, T> {\n+    fn from(v: Vec<T>) -> Self {\n+        Seq0255(v, PhantomData)\n+    }\n+}\n+\n+impl<'a, T> From<Vec<T>> for Seq064K<'a, T> {\n+    fn from(v: Vec<T>) -> Self {\n+        Seq064K(v, PhantomData)\n+    }\n+}"
      },
      {
        "sha": "9ef05fedcd46aa846b7432c8eb6b432680f7aca7",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "status": "added",
        "additions": 296,
        "deletions": 0,
        "changes": 296,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/codec/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,296 @@\n+//! ```txt\n+//! SERDE    <-> Sv2\n+//! bool     <-> BOOL\n+//! u8       <-> U8\n+//! u16      <-> U16\n+//! U24      <-> U24\n+//! u32      <-> u32\n+//! f32      <-> f32 // todo not in the spec but used\n+//! u64      <-> u64 // todo not in the spec but used\n+//! U256     <-> U256\n+//! Str0255  <-> STRO_255\n+//! Str032   <-> STRO_32 // todo not in the spec but used\n+//! Signature<-> SIGNATURE\n+//! B032     <-> B0_32 // todo not in the spec but used\n+//! B0255    <-> B0_255\n+//! B064K    <-> B0_64K\n+//! B016M    <-> B0_16M\n+//! [u8]     <-> BYTES\n+//! Pubkey   <-> PUBKEY\n+//! Seq0255  <-> SEQ0_255[T]\n+//! Seq064K  <-> SEQ0_64K[T]\n+//! ```\n+#![cfg_attr(feature = \"no_std\", no_std)]\n+use core::convert::TryInto;\n+\n+#[cfg(not(feature = \"no_std\"))]\n+use std::io::{Error as E, ErrorKind};\n+\n+mod codec;\n+mod datatypes;\n+pub use datatypes::{\n+    Bytes, PubKey, Seq0255, Seq064K, Signature, Str0255, Str032, B016M, B0255, B032, B064K, U24,\n+    U256,\n+};\n+\n+pub use crate::codec::decodable::Decodable;\n+pub use crate::codec::encodable::{Encodable, EncodableField};\n+pub use crate::codec::GetSize;\n+pub use crate::codec::SizeHint;\n+\n+#[allow(clippy::wrong_self_convention)]\n+pub fn to_bytes<T: Encodable + GetSize>(src: T) -> Result<Vec<u8>, Error> {\n+    let mut result = vec![0_u8; src.get_size()];\n+    src.to_bytes(&mut result)?;\n+    Ok(result)\n+}\n+\n+#[allow(clippy::wrong_self_convention)]\n+pub fn to_writer<T: Encodable>(src: T, dst: &mut [u8]) -> Result<(), Error> {\n+    src.to_bytes(dst)?;\n+    Ok(())\n+}\n+\n+pub fn from_bytes<'a, T: Decodable<'a>>(data: &'a mut [u8]) -> Result<T, Error> {\n+    T::from_bytes(data)\n+}\n+\n+pub mod decodable {\n+    pub use crate::codec::decodable::Decodable;\n+    pub use crate::codec::decodable::DecodableField;\n+    pub use crate::codec::decodable::FieldMarker;\n+    //pub use crate::codec::decodable::PrimitiveMarker;\n+}\n+\n+pub mod encodable {\n+    pub use crate::codec::encodable::Encodable;\n+    pub use crate::codec::encodable::EncodableField;\n+}\n+\n+#[macro_use]\n+extern crate alloc;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    OutOfBound,\n+    NotABool(u8),\n+    /// -> (expected size, actual size)\n+    WriteError(usize, usize),\n+    U24TooBig(u32),\n+    InvalidSignatureSize(usize),\n+    InvalidU256(usize),\n+    InvalidU24(u32),\n+    InvalidB0255Size(usize),\n+    InvalidB064KSize(usize),\n+    InvalidB016MSize(usize),\n+    InvalidSeq0255Size(usize),\n+    PrimitiveConversionError,\n+    DecodableConversionError,\n+    UnInitializedDecoder,\n+    #[cfg(not(feature = \"no_std\"))]\n+    IoError(E),\n+    ReadError(usize, usize),\n+    Todo,\n+}\n+\n+#[cfg(not(feature = \"no_std\"))]\n+impl From<E> for Error {\n+    fn from(v: E) -> Self {\n+        match v.kind() {\n+            ErrorKind::UnexpectedEof => Error::OutOfBound,\n+            _ => Error::IoError(v),\n+        }\n+    }\n+}\n+\n+/// Vec<u8> is used as the Sv2 type Bytes\n+impl GetSize for Vec<u8> {\n+    fn get_size(&self) -> usize {\n+        self.len()\n+    }\n+}\n+\n+impl<'a> From<Vec<u8>> for EncodableField<'a> {\n+    fn from(v: Vec<u8>) -> Self {\n+        let bytes: Bytes = v.try_into().unwrap();\n+        crate::encodable::EncodableField::Primitive(\n+            crate::codec::encodable::EncodablePrimitive::Bytes(bytes),\n+        )\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy)]\n+pub struct CVec {\n+    data: *mut u8,\n+    len: usize,\n+    capacity: usize,\n+}\n+\n+impl CVec {\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        unsafe { core::slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+\n+    /// Used when we need to fill a buffer allocated in rust from C.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function construct a CVec without taking ownership of the pointed buffer so if the\n+    /// owner drop them the CVec will point to garbage.\n+    #[allow(clippy::wrong_self_convention)]\n+    pub fn as_shared_buffer(v: &mut [u8]) -> Self {\n+        let (data, len) = (v.as_mut_ptr(), v.len());\n+        Self {\n+            data,\n+            len,\n+            capacity: len,\n+        }\n+    }\n+}\n+\n+impl From<&[u8]> for CVec {\n+    fn from(v: &[u8]) -> Self {\n+        let mut buffer: Vec<u8> = vec![0; v.len()];\n+        buffer.copy_from_slice(v);\n+\n+        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+        let len = buffer.len();\n+        let ptr = buffer.as_mut_ptr();\n+        std::mem::forget(buffer);\n+\n+        CVec {\n+            data: ptr,\n+            len,\n+            capacity: len,\n+        }\n+    }\n+}\n+\n+/// Given a C allocated buffer return a rust allocated CVec\n+///\n+/// # Safety\n+///\n+/// TODO\n+#[no_mangle]\n+pub unsafe extern \"C\" fn cvec_from_buffer(data: *const u8, len: usize) -> CVec {\n+    let input = std::slice::from_raw_parts(data, len);\n+\n+    let mut buffer: Vec<u8> = vec![0; len];\n+    buffer.copy_from_slice(input);\n+\n+    // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+    let len = buffer.len();\n+    let ptr = buffer.as_mut_ptr();\n+    std::mem::forget(buffer);\n+\n+    CVec {\n+        data: ptr,\n+        len,\n+        capacity: len,\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Debug, Clone, Copy)]\n+pub struct CVec2 {\n+    data: *mut CVec,\n+    len: usize,\n+    capacity: usize,\n+}\n+\n+impl CVec2 {\n+    pub fn as_mut_slice(&mut self) -> &mut [CVec] {\n+        unsafe { core::slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+}\n+impl From<CVec2> for Vec<CVec> {\n+    fn from(v: CVec2) -> Self {\n+        unsafe { Vec::from_raw_parts(v.data, v.len, v.capacity) }\n+    }\n+}\n+\n+pub fn free_vec(buf: &mut CVec) {\n+    let _: Vec<u8> = unsafe { Vec::from_raw_parts(buf.data, buf.len, buf.capacity) };\n+}\n+\n+pub fn free_vec_2(buf: &mut CVec2) {\n+    let vs: Vec<CVec> = unsafe { Vec::from_raw_parts(buf.data, buf.len, buf.capacity) };\n+    for mut s in vs {\n+        free_vec(&mut s)\n+    }\n+}\n+\n+impl<'a, const A: bool, const B: usize, const C: usize, const D: usize>\n+    From<datatypes::Inner<'a, A, B, C, D>> for CVec\n+{\n+    fn from(v: datatypes::Inner<'a, A, B, C, D>) -> Self {\n+        let (ptr, len, cap): (*mut u8, usize, usize) = match v {\n+            datatypes::Inner::Ref(inner) => {\n+                // Data is copied in a vector that then will be forgetted from the allocator,\n+                // cause the owner of the data is going to be dropped by rust\n+                let mut inner: Vec<u8> = inner.into();\n+\n+                // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+                let len = inner.len();\n+                let cap = inner.capacity();\n+                let ptr = inner.as_mut_ptr();\n+                std::mem::forget(inner);\n+\n+                (ptr, len, cap)\n+            }\n+            datatypes::Inner::Owned(mut inner) => {\n+                // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+                let len = inner.len();\n+                let cap = inner.capacity();\n+                let ptr = inner.as_mut_ptr();\n+                std::mem::forget(inner);\n+\n+                (ptr, len, cap)\n+            }\n+        };\n+        Self {\n+            data: ptr,\n+            len,\n+            capacity: cap,\n+        }\n+    }\n+}\n+\n+impl<'a, T: Into<CVec>> From<Seq0255<'a, T>> for CVec2 {\n+    fn from(v: Seq0255<'a, T>) -> Self {\n+        let mut v: Vec<CVec> = v.0.into_iter().map(|x| x.into()).collect();\n+        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+        let len = v.len();\n+        let capacity = v.capacity();\n+        let data = v.as_mut_ptr();\n+        std::mem::forget(v);\n+        Self {\n+            data,\n+            len,\n+            capacity,\n+        }\n+    }\n+}\n+impl<'a, T: Into<CVec>> From<Seq064K<'a, T>> for CVec2 {\n+    fn from(v: Seq064K<'a, T>) -> Self {\n+        let mut v: Vec<CVec> = v.0.into_iter().map(|x| x.into()).collect();\n+        // Get the length, first, then the pointer (doing it the other way around **currently** doesn't cause UB, but it may be unsound due to unclear (to me, at least) guarantees of the std lib)\n+        let len = v.len();\n+        let capacity = v.capacity();\n+        let data = v.as_mut_ptr();\n+        std::mem::forget(v);\n+        Self {\n+            data,\n+            len,\n+            capacity,\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_u24(_a: U24) {}\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_cvec(_a: CVec) {}\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_cvec2(_a: CVec2) {}"
      },
      {
        "sha": "ea8c4bf7f35f6f77f75d92ad8ce8349f6e81ddba",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/.gitignore?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1 @@\n+/target"
      },
      {
        "sha": "1f6ad16fb59c637488410877a5dbf2279859b9fc",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.lock?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,12 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"derive_codec\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"parse\",\n+]\n+\n+[[package]]\n+name = \"parse\"\n+version = \"0.1.0\""
      },
      {
        "sha": "153e72c9c8d52af6aaf7bf7ed274857405d37612",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,15 @@\n+[package]\n+name = \"derive_codec_sv2\"\n+version = \"0.1.2\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Derive macro for Sv2 binary format serializer and deserializer\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+binary_codec_sv2 = {version = \"0.1.*\", path=\"../codec\"}\n+\n+[lib]\n+proc-macro = true"
      },
      {
        "sha": "7d16cf152f342fffe8caa07cd972005322c03b85",
        "filename": "src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "status": "added",
        "additions": 387,
        "deletions": 0,
        "changes": 387,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,387 @@\n+extern crate proc_macro;\n+use core::iter::FromIterator;\n+use proc_macro::{Group, TokenStream, TokenTree};\n+\n+fn remove_attributes(item: TokenStream) -> TokenStream {\n+    let stream = item.into_iter();\n+    let mut is_attribute = false;\n+    let mut result = Vec::new();\n+\n+    for next in stream {\n+        match next.clone() {\n+            TokenTree::Punct(p) => {\n+                if p.to_string() == \"#\" {\n+                    is_attribute = true;\n+                } else {\n+                    result.push(next.clone());\n+                }\n+            }\n+            TokenTree::Group(g) => {\n+                if is_attribute {\n+                    continue;\n+                } else {\n+                    let delimiter = g.delimiter();\n+                    let cleaned_group = remove_attributes(g.stream());\n+                    let cleaned_group = TokenTree::Group(Group::new(delimiter, cleaned_group));\n+                    result.push(cleaned_group);\n+                }\n+            }\n+            _ => {\n+                is_attribute = false;\n+                result.push(next.clone());\n+            }\n+        }\n+    }\n+\n+    TokenStream::from_iter(result)\n+}\n+\n+enum ParserState {\n+    Name,\n+    Type,\n+    //       open angle brackets\n+    Generics(usize),\n+}\n+fn parse_struct_fields(group: Vec<TokenTree>) -> Vec<ParsedField> {\n+    let mut fields = Vec::new();\n+    let mut field_ = ParsedField::new();\n+    let mut field_parser_state = ParserState::Name;\n+    for token in group {\n+        match (token, &field_parser_state) {\n+            (TokenTree::Ident(i), ParserState::Name) => {\n+                if i.to_string() == \"pub\" {\n+                    continue;\n+                } else {\n+                    field_.name = i.to_string();\n+                }\n+            }\n+            (TokenTree::Ident(i), ParserState::Type) => {\n+                field_.type_ = i.to_string();\n+            }\n+            (TokenTree::Ident(i), ParserState::Generics(_)) => {\n+                field_.generics = format!(\"{}{}\", field_.generics, i.to_string());\n+            }\n+            (TokenTree::Punct(p), ParserState::Name) => {\n+                if p.to_string() == \":\" {\n+                    field_parser_state = ParserState::Type\n+                } else {\n+                    panic!(\n+                        \"Unexpected token '{}' in parsing {:#?}\",\n+                        p.to_string(),\n+                        field_\n+                    );\n+                }\n+            }\n+            (TokenTree::Punct(p), ParserState::Type) => match p.to_string().as_ref() {\n+                \",\" => {\n+                    field_parser_state = ParserState::Name;\n+                    fields.push(field_.clone());\n+                    field_ = ParsedField::new();\n+                }\n+                \"<\" => {\n+                    field_.generics = \"<\".to_string();\n+                    field_parser_state = ParserState::Generics(0);\n+                }\n+                _ => panic!(\n+                    \"Unexpected token '{}' in parsing {:#?}\",\n+                    p.to_string(),\n+                    field_\n+                ),\n+            },\n+            (TokenTree::Punct(p), ParserState::Generics(open_brackets)) => {\n+                match p.to_string().as_ref() {\n+                    \"'\" => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                    }\n+                    \"<\" => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                        field_parser_state = ParserState::Generics(open_brackets + 1);\n+                    }\n+                    \">\" => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                        if open_brackets == &0 {\n+                            field_parser_state = ParserState::Type\n+                        } else {\n+                            field_parser_state = ParserState::Generics(open_brackets - 1);\n+                        }\n+                    }\n+                    _ => {\n+                        field_.generics = format!(\"{}{}\", field_.generics, p.to_string());\n+                    }\n+                }\n+            }\n+            _ => panic!(\"Unexpected token\"),\n+        }\n+    }\n+    fields\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ParsedField {\n+    name: String,\n+    type_: String,\n+    generics: String,\n+}\n+\n+impl ParsedField {\n+    pub fn new() -> Self {\n+        ParsedField {\n+            name: \"\".to_string(),\n+            type_: \"\".to_string(),\n+            generics: \"\".to_string(),\n+        }\n+    }\n+\n+    pub fn get_generics(&self) -> String {\n+        if self.generics == \"<'decoder>\" || self.generics.is_empty() {\n+            \"\".to_string()\n+        } else {\n+            format!(\"::{}\", self.generics.clone())\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ParsedStruct {\n+    pub name: String,\n+    pub generics: String,\n+    pub fields: Vec<ParsedField>,\n+}\n+\n+// impl ParsedStruct {\n+//     pub fn new() -> Self {\n+//         ParsedStruct {\n+//             name: \"\".to_string(),\n+//             generics: \"\".to_string(),\n+//             fields: Vec::new(),\n+//         }\n+//     }\n+// }\n+\n+fn get_struct_properties(item: TokenStream) -> ParsedStruct {\n+    let item = remove_attributes(item);\n+    let mut stream = item.into_iter();\n+\n+    // Check if the stream is a struct\n+    loop {\n+        match stream.next().expect(\"Stream not a struct\") {\n+            TokenTree::Ident(i) => {\n+                if i.to_string() == \"struct\" {\n+                    break;\n+                }\n+            }\n+            _ => continue,\n+        }\n+    }\n+\n+    // Get the struct name\n+    let struct_name = match stream.next().expect(\"Struct has no name\") {\n+        TokenTree::Ident(i) => i.to_string(),\n+        _ => panic!(\"Strcut has no name\"),\n+    };\n+\n+    let mut struct_generics = \"\".to_string();\n+    let group: Vec<TokenTree>;\n+\n+    // Get the struct generics if any\n+    loop {\n+        match stream\n+            .next()\n+            .unwrap_or_else(|| panic!(\"Struct {} has no fields\", struct_name))\n+        {\n+            TokenTree::Group(g) => {\n+                group = g.stream().into_iter().collect();\n+                break;\n+            }\n+            TokenTree::Punct(p) => {\n+                struct_generics = format!(\"{}{}\", struct_generics, p.to_string());\n+            }\n+            TokenTree::Ident(i) => {\n+                struct_generics = format!(\"{}{}\", struct_generics, i.to_string());\n+            }\n+            _ => panic!(\"Struct {} has no fields\", struct_name),\n+        };\n+    }\n+\n+    let fields = parse_struct_fields(group);\n+\n+    ParsedStruct {\n+        name: struct_name,\n+        generics: struct_generics,\n+        fields,\n+    }\n+}\n+\n+#[proc_macro_derive(Decodable)]\n+pub fn decodable(item: TokenStream) -> TokenStream {\n+    let parsed_struct = get_struct_properties(item);\n+\n+    let mut derive_fields = String::new();\n+\n+    for f in parsed_struct.fields.clone() {\n+        let field = format!(\n+            \"\n+            let {}: Vec<FieldMarker> = {}{}::get_structure(& data[offset..])?;\n+            offset += {}.size_hint_(&data, offset)?;\n+            let {} =  {}.into();\n+            fields.push({});\n+            \",\n+            f.name,\n+            f.type_,\n+            f.get_generics(),\n+            f.name,\n+            f.name,\n+            f.name,\n+            f.name\n+        );\n+        derive_fields.push_str(&field)\n+    }\n+\n+    let mut derive_decoded_fields = String::new();\n+    let mut fields = parsed_struct.fields.clone();\n+\n+    // Reverse the fields as they are popped out from the end of the vector but we want to pop out\n+    // from the front\n+    fields.reverse();\n+\n+    // Create Struct from fields\n+    for f in fields.clone() {\n+        let field = format!(\n+            \"\n+            {}: {}{}::from_decoded_fields(data.pop().unwrap().into())?,\n+            \",\n+            f.name,\n+            f.type_,\n+            f.get_generics()\n+        );\n+        derive_decoded_fields.push_str(&field)\n+    }\n+\n+    let impl_generics = if !parsed_struct.generics.is_empty() {\n+        parsed_struct.clone().generics\n+    } else {\n+        \"<'decoder>\".to_string()\n+    };\n+\n+    let result = format!(\n+        \"mod impl_parse_decodable_{} {{\n+\n+    use super::binary_codec_sv2::{{decodable::DecodableField, decodable::FieldMarker, Decodable, Error, SizeHint}};\n+    use super::*;\n+\n+    impl{} Decodable<'decoder> for {}{} {{\n+        fn get_structure(data: &[u8]) -> Result<Vec<FieldMarker>, Error> {{\n+            let mut fields = Vec::new();\n+            let mut offset = 0;\n+            {}\n+            Ok(fields)\n+        }}\n+\n+        fn from_decoded_fields(mut data: Vec<DecodableField<'decoder>>) -> Result<Self, Error> {{\n+            Ok(Self {{\n+                {}\n+            }})\n+        }}\n+    }}\n+    }}\",\n+        // imports\n+        parsed_struct.name.to_lowercase(),\n+        // derive decodable\n+        impl_generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        derive_fields,\n+        derive_decoded_fields,\n+    );\n+    //println!(\"{}\", result);\n+\n+    result.parse().unwrap()\n+}\n+\n+#[proc_macro_derive(Encodable)]\n+pub fn encodable(item: TokenStream) -> TokenStream {\n+    let parsed_struct = get_struct_properties(item);\n+    let fields = parsed_struct.fields.clone();\n+\n+    let mut field_into_decoded_field = String::new();\n+\n+    // Create DecodableField from fields\n+    for f in fields.clone() {\n+        let field = format!(\n+            \"\n+            let val = v.{};\n+            fields.push(val.into());\n+            \",\n+            f.name\n+        );\n+        field_into_decoded_field.push_str(&field)\n+    }\n+\n+    let mut sizes = String::new();\n+\n+    for f in fields {\n+        let field = format!(\n+            \"\n+            size += self.{}.get_size();\n+            \",\n+            f.name\n+        );\n+        sizes.push_str(&field)\n+    }\n+    let impl_generics = if !parsed_struct.generics.is_empty() {\n+        parsed_struct.clone().generics\n+    } else {\n+        \"<'decoder>\".to_string()\n+    };\n+\n+    let result = format!(\n+        \"mod impl_parse_encodable_{} {{\n+\n+    use super::binary_codec_sv2::{{encodable::EncodableField, GetSize}};\n+    use super::{};\n+    extern crate alloc;\n+    use alloc::vec::Vec;\n+\n+    impl{} From<{}{}> for EncodableField<'decoder> {{\n+        fn from(v: {}{}) -> Self {{\n+            let mut fields: Vec<EncodableField> = Vec::new();\n+            {}\n+            Self::Struct(fields)\n+        }}\n+    }}\n+\n+\n+    impl{} GetSize for {}{} {{\n+        fn get_size(&self) -> usize {{\n+            let mut size = 0;\n+            {}\n+            size\n+        }}\n+    }}\n+\n+    }}\",\n+        // imports\n+        parsed_struct.name.to_lowercase(),\n+        parsed_struct.name,\n+        // impl From<Struct> for DecodableField\n+        impl_generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        field_into_decoded_field,\n+        // impl Encodable for Struct\n+        //impl{} Encodable<'decoder> for {}{} {{}}\n+        //impl_generics,\n+        //parsed_struct.name,\n+        //parsed_struct.generics,\n+        // impl GetSize for Struct\n+        impl_generics,\n+        parsed_struct.name,\n+        parsed_struct.generics,\n+        sizes,\n+    );\n+    //println!(\"{}\", result);\n+\n+    result.parse().unwrap()\n+}"
      },
      {
        "sha": "6f86a7ab2b08281e8f60b4dfc1f62ba9a7a08646",
        "filename": "src/rusty/protocols/v2/codec-sv2/Cargo.toml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/codec-sv2/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"codec_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 data format\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional = true }\n+framing_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/framing-sv2\" }\n+noise_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/noise-sv2\", optional=true}\n+binary_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/binary-sv2/binary-sv2\"}\n+const_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/const-sv2\"}\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\", \"framing_sv2/with_serde\"]"
      },
      {
        "sha": "3df316f9cfc1b18bebb9d18b439f49c892b7f57f",
        "filename": "src/rusty/protocols/v2/codec-sv2/src/buffer.rs",
        "status": "added",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/buffer.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/buffer.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/codec-sv2/src/buffer.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,71 @@\n+use alloc::vec::Vec;\n+\n+pub trait Buffer {\n+    type Slice: AsMut<[u8]>;\n+\n+    fn get_writable(&mut self, len: usize) -> &mut [u8];\n+\n+    fn get_data_owned(&mut self) -> Self::Slice;\n+\n+    fn get_data_by_ref(&mut self, header_size: usize) -> &mut [u8];\n+\n+    fn len(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+pub struct SlowAndCorrect {\n+    inner: Vec<u8>,\n+    cursor: usize,\n+}\n+\n+impl SlowAndCorrect {\n+    pub fn new() -> Self {\n+        Self {\n+            inner: Vec::new(),\n+            cursor: 0,\n+        }\n+    }\n+}\n+\n+impl Default for SlowAndCorrect {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl Buffer for SlowAndCorrect {\n+    type Slice = Vec<u8>;\n+\n+    #[inline]\n+    fn get_writable(&mut self, len: usize) -> &mut [u8] {\n+        let cursor = self.cursor;\n+        let len = self.cursor + len;\n+\n+        if len > self.inner.len() {\n+            self.inner.resize(len, 0)\n+        };\n+\n+        self.cursor = len;\n+\n+        &mut self.inner[cursor..len]\n+    }\n+\n+    #[inline]\n+    fn get_data_owned(&mut self) -> Vec<u8> {\n+        let mut tail = self.inner.split_off(self.cursor);\n+        core::mem::swap(&mut tail, &mut self.inner);\n+        let head = tail;\n+        self.cursor = 0;\n+        head\n+    }\n+\n+    #[inline]\n+    fn get_data_by_ref(&mut self, header_size: usize) -> &mut [u8] {\n+        &mut self.inner[..usize::min(header_size, self.cursor)]\n+    }\n+\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.cursor\n+    }\n+}"
      },
      {
        "sha": "8cd6c81457b94b428098bb7a6f0571e8a07738ff",
        "filename": "src/rusty/protocols/v2/codec-sv2/src/decoder.rs",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/decoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/decoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/codec-sv2/src/decoder.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,60 @@\n+use binary_sv2::Serialize;\n+use core::marker::PhantomData;\n+use framing_sv2::framing2::{EitherFrame, Frame as F_, Sv2Frame};\n+use framing_sv2::header::Header;\n+\n+use crate::buffer::{Buffer, SlowAndCorrect};\n+use crate::error::{Error, Result};\n+\n+pub type StandardEitherFrame<T> = EitherFrame<T, <SlowAndCorrect as Buffer>::Slice>;\n+pub type StandardSv2Frame<T> = Sv2Frame<T, <SlowAndCorrect as Buffer>::Slice>;\n+pub type StandardDecoder<T> = WithoutNoise<SlowAndCorrect, T>;\n+\n+#[derive(Debug)]\n+pub struct WithoutNoise<B: Buffer, T: Serialize + binary_sv2::GetSize> {\n+    frame: PhantomData<T>,\n+    missing_b: usize,\n+    buffer: B,\n+}\n+\n+impl<T: Serialize + binary_sv2::GetSize, B: Buffer> WithoutNoise<B, T> {\n+    #[inline]\n+    pub fn next_frame(&mut self) -> Result<Sv2Frame<T, B::Slice>> {\n+        let len = self.buffer.len();\n+        let src = self.buffer.get_data_by_ref(len);\n+        let hint = Sv2Frame::<T, B::Slice>::size_hint(src) as usize;\n+\n+        match hint {\n+            0 => {\n+                self.missing_b = Header::SIZE;\n+                let src = self.buffer.get_data_owned();\n+                let frame = Sv2Frame::<T, B::Slice>::from_bytes_unchecked(src);\n+                Ok(frame)\n+            }\n+            _ => {\n+                self.missing_b = hint;\n+                Err(Error::MissingBytes(self.missing_b))\n+            }\n+        }\n+    }\n+\n+    pub fn writable(&mut self) -> &mut [u8] {\n+        self.buffer.get_writable(self.missing_b)\n+    }\n+}\n+\n+impl<T: Serialize + binary_sv2::GetSize> WithoutNoise<SlowAndCorrect, T> {\n+    pub fn new() -> Self {\n+        Self {\n+            frame: PhantomData,\n+            missing_b: Header::SIZE,\n+            buffer: SlowAndCorrect::new(),\n+        }\n+    }\n+}\n+\n+impl<T: Serialize + binary_sv2::GetSize> Default for WithoutNoise<SlowAndCorrect, T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}"
      },
      {
        "sha": "73b1665f5579539cd3fa8b47b098db02ffebeeea",
        "filename": "src/rusty/protocols/v2/codec-sv2/src/encoder.rs",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/encoder.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/encoder.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/codec-sv2/src/encoder.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,38 @@\n+use alloc::vec::Vec;\n+use binary_sv2::GetSize;\n+use binary_sv2::Serialize;\n+use core::marker::PhantomData;\n+use framing_sv2::framing2::{Frame as F_, Sv2Frame};\n+\n+\n+#[derive(Debug)]\n+pub struct Encoder<T> {\n+    buffer: Vec<u8>,\n+    frame: PhantomData<T>,\n+}\n+\n+impl<T: Serialize + GetSize> Encoder<T> {\n+    pub fn encode(&mut self, item: Sv2Frame<T, Vec<u8>>) -> Result<&[u8], crate::Error> {\n+        let len = item.encoded_length();\n+\n+        self.buffer.resize(len, 0);\n+\n+        item.serialize(&mut self.buffer).map_err(|_| ())?;\n+\n+        Ok(&self.buffer[..])\n+    }\n+\n+    pub fn new() -> Self {\n+        Self {\n+            // TODO which capacity??\n+            buffer: Vec::with_capacity(512),\n+            frame: core::marker::PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T: Serialize + GetSize> Default for Encoder<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}"
      },
      {
        "sha": "2e689b515d0f3c110878c784ebd1c4bda2d7f013",
        "filename": "src/rusty/protocols/v2/codec-sv2/src/error.rs",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/codec-sv2/src/error.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,19 @@\n+#[derive(Debug)]\n+pub enum Error {\n+    MissingBytes(usize),\n+    Todo,\n+}\n+\n+pub type Result<T> = core::result::Result<T, Error>;\n+\n+impl From<()> for Error {\n+    fn from(_: ()) -> Self {\n+        Error::Todo\n+    }\n+}\n+\n+impl core::fmt::Display for Error {\n+    fn fmt(&self, _: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n+        Ok(())\n+    }\n+}"
      },
      {
        "sha": "03e6c69153c5bd65ec0a92b1cade39042964e8f3",
        "filename": "src/rusty/protocols/v2/codec-sv2/src/lib.rs",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/codec-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/codec-sv2/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,19 @@\n+#![no_std]\n+\n+extern crate alloc;\n+\n+mod buffer;\n+mod decoder;\n+mod encoder;\n+mod error;\n+\n+pub use error::Error;\n+\n+pub use decoder::StandardEitherFrame;\n+pub use decoder::StandardSv2Frame;\n+\n+pub use decoder::StandardDecoder;\n+\n+pub use encoder::Encoder;\n+\n+pub use framing_sv2::framing2::{Frame, Sv2Frame};"
      },
      {
        "sha": "7432c3d50c4ae1fdf1ad1714f9d12c3e1322acec",
        "filename": "src/rusty/protocols/v2/const-sv2/Cargo.toml",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/const-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/const-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/const-sv2/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"const_sv2\"\n+version = \"0.1.0\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2  constatnts\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n+#[dev-dependencies]\n+#cbindgen = \"0.16.0\""
      },
      {
        "sha": "943f5db0f54be4aff51c1266ce1af9badfeb60f6",
        "filename": "src/rusty/protocols/v2/const-sv2/src/lib.rs",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/const-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/const-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/const-sv2/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,34 @@\n+//! Central repository for all the sv2 constants\n+#![no_std]\n+\n+pub const SV2_FRAME_HEADER_SIZE: usize = 6;\n+pub const SV2_FRAME_HEADER_LEN_OFFSET: usize = 3;\n+pub const SV2_FRAME_HEADER_LEN_END: usize = 3;\n+\n+pub const NOISE_FRAME_HEADER_SIZE: usize = 2;\n+pub const NOISE_FRAME_HEADER_LEN_OFFSET: usize = 0;\n+pub const NOISE_FRAME_HEADER_LEN_END: usize = 2;\n+pub const NOISE_FRAME_MAX_SIZE: usize = u16::MAX as usize;\n+\n+pub const NOISE_PARAMS: &str = \"Noise_NX_25519_ChaChaPoly_BLAKE2s\";\n+pub const SNOW_PSKLEN: usize = 32;\n+pub const SNOW_TAGLEN: usize = 16;\n+\n+pub const SV2_MINING_PROTOCOL_DISCRIMINANT: u8 = 0;\n+pub const SV2_JOB_NEG_PROTOCOL_DISCRIMINANT: u8 = 1;\n+pub const SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT: u8 = 2;\n+pub const SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT: u8 = 3;\n+\n+// COMMON MESSAGES TYPES\n+pub const MESSAGE_TYPE_SETUP_CONNECTION: u8 = 0;\n+pub const MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS: u8 = 1;\n+pub const MESSAGE_TYPE_SETUP_CONNECTION_ERROR: u8 = 2;\n+pub const MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES: u8 = 3;\n+// TEMPLATE DISTRIBUTION PROTOCOL MESSAGES TYPES\n+pub const MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE: u8 = 70;\n+pub const MESSAGE_TYPE_NEW_TEMPLATE: u8 = 71;\n+pub const MESSAGE_TYPE_SET_NEW_PREV_HASH: u8 = 72;\n+pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA: u8 = 73;\n+pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS: u8 = 74;\n+pub const MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR: u8 = 75;\n+pub const MESSAGE_TYPE_SUBMIT_SOLUTION: u8 = 76;"
      },
      {
        "sha": "f694f05d7a65ec18c9a74dcab1fa16db30743bd5",
        "filename": "src/rusty/protocols/v2/framing-sv2/Cargo.toml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/framing-sv2/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,18 @@\n+[package]\n+name = \"framing_sv2\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 frames\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional = true }\n+const_sv2 = { version = \"0.1.0\", path = \"../../../protocols/v2/const-sv2\"}\n+binary_sv2 = { version = \"0.1.3\", path = \"../../../protocols/v2/binary-sv2/binary-sv2\" }\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\"]"
      },
      {
        "sha": "7331f4ea5fc692e8f4f937a0805008fcda6808dd",
        "filename": "src/rusty/protocols/v2/framing-sv2/src/framing2.rs",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/src/framing2.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/src/framing2.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/framing-sv2/src/framing2.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,306 @@\n+use crate::header::Header;\n+use crate::header::NoiseHeader;\n+use alloc::vec::Vec;\n+use binary_sv2::Serialize;\n+use binary_sv2::{to_writer, GetSize};\n+use core::convert::TryFrom;\n+\n+const NOISE_MAX_LEN: usize = const_sv2::NOISE_FRAME_MAX_SIZE;\n+\n+pub trait Frame<'a, T: Serialize + GetSize>: Sized {\n+    type Buffer: AsMut<[u8]>;\n+    type Deserialized;\n+\n+    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n+    /// itself\n+    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error>;\n+\n+    ///fn deserialize(&'a mut self) -> Result<Self::Deserialized, serde_sv2::Error>;\n+    fn payload(&'a mut self) -> &'a mut [u8];\n+\n+    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n+    fn get_header(&self) -> Option<crate::header::Header>;\n+\n+    /// Try to build an Frame frame from raw bytes.\n+    /// It return the frame or the number of the bytes needed to complete the frame\n+    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n+    /// is said about the correctness of the payload\n+    fn from_bytes(bytes: Self::Buffer) -> Result<Self, isize>;\n+\n+    fn from_bytes_unchecked(bytes: Self::Buffer) -> Self;\n+\n+    fn size_hint(bytes: &[u8]) -> isize;\n+\n+    fn encoded_length(&self) -> usize;\n+\n+    /// Try to build an Frame frame from a serializable payload.\n+    /// It return a Frame if the size of the payload fit in the frame, if not it return None\n+    fn from_message(message: T, message_type: u8, extension_type: u16) -> Option<Self>;\n+}\n+\n+#[derive(Debug)]\n+pub struct Sv2Frame<T, B> {\n+    header: Header,\n+    payload: Option<T>,\n+    serialized: Option<B>,\n+}\n+\n+impl<T, B> Default for Sv2Frame<T, B> {\n+    fn default() -> Self {\n+        Sv2Frame {\n+            header: Header::default(),\n+            payload: None,\n+            serialized: None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct NoiseFrame {\n+    header: u16,\n+    payload: Vec<u8>,\n+}\n+\n+pub type HandShakeFrame = NoiseFrame;\n+\n+impl<'a, T: Serialize + GetSize, B: AsMut<[u8]>> Frame<'a, T> for Sv2Frame<T, B> {\n+    type Buffer = B;\n+    type Deserialized = B;\n+\n+    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n+    /// itself\n+    #[inline]\n+    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error> {\n+        if self.serialized.is_some() {\n+            *dst = self.serialized.unwrap();\n+            Ok(())\n+        } else {\n+            #[cfg(not(feature = \"with_serde\"))]\n+            to_writer(self.header, dst.as_mut())?;\n+            #[cfg(not(feature = \"with_serde\"))]\n+            to_writer(self.payload.unwrap(), &mut dst.as_mut()[Header::SIZE..])?;\n+            #[cfg(feature = \"with_serde\")]\n+            to_writer(&self.header, dst.as_mut())?;\n+            #[cfg(feature = \"with_serde\")]\n+            to_writer(&self.payload.unwrap(), &mut dst.as_mut()[Header::SIZE..])?;\n+            Ok(())\n+        }\n+    }\n+\n+    fn payload(&'a mut self) -> &'a mut [u8] {\n+        if self.payload.is_some() {\n+            todo!()\n+        } else {\n+            &mut self.serialized.as_mut().unwrap().as_mut()[Header::SIZE..]\n+        }\n+    }\n+\n+    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n+    fn get_header(&self) -> Option<crate::header::Header> {\n+        Some(self.header)\n+    }\n+\n+    /// Try to build a Frame frame from raw bytes.\n+    /// It return the frame or the number of the bytes needed to complete the frame\n+    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n+    /// is said about the correctness of the payload\n+    #[inline]\n+    fn from_bytes(mut bytes: Self::Buffer) -> Result<Self, isize> {\n+        let hint = Self::size_hint(bytes.as_mut());\n+\n+        if hint == 0 {\n+            Ok(Self::from_bytes_unchecked(bytes))\n+        } else {\n+            Err(hint)\n+        }\n+    }\n+\n+    #[inline]\n+    fn from_bytes_unchecked(mut bytes: Self::Buffer) -> Self {\n+        let header = Header::from_bytes(bytes.as_mut()).unwrap();\n+        Self {\n+            header,\n+            payload: None,\n+            serialized: Some(bytes),\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(bytes: &[u8]) -> isize {\n+        match Header::from_bytes(bytes) {\n+            Err(i) => i,\n+            Ok(header) => {\n+                if bytes.len() - Header::SIZE == header.len() {\n+                    0\n+                } else {\n+                    (bytes.len() - Header::SIZE) as isize + header.len() as isize\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn encoded_length(&self) -> usize {\n+        if self.serialized.is_some() {\n+            unimplemented!()\n+        } else {\n+            self.payload.as_ref().unwrap().get_size() + Header::SIZE\n+        }\n+    }\n+\n+    /// Try to build an Frame frame from a serializable payload.\n+    /// It returns a Frame if the size of the payload fits in the frame, if not it returns None\n+    fn from_message(message: T, message_type: u8, extension_type: u16) -> Option<Self> {\n+        let len = message.get_size() as u32;\n+        Header::from_len(len, message_type, extension_type).map(|header| Self {\n+            header,\n+            payload: Some(message),\n+            serialized: None,\n+        })\n+    }\n+}\n+\n+#[inline]\n+pub fn build_noise_frame_header(frame: &mut Vec<u8>, len: u16) {\n+    frame.push(len.to_le_bytes()[0]);\n+    frame.push(len.to_le_bytes()[1]);\n+}\n+\n+impl<'a> Frame<'a, Vec<u8>> for NoiseFrame {\n+    //impl<T: Serialize + GetSize> Frame<T> for NoiseFrame {\n+\n+    type Buffer = Vec<u8>;\n+    type Deserialized = &'a mut [u8];\n+\n+    /// Serialize the frame into dst if the frame is already serialized it just swap dst with\n+    /// itself\n+    #[inline]\n+    fn serialize(self, dst: &mut Self::Buffer) -> Result<(), binary_sv2::Error> {\n+        *dst = self.payload;\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn payload(&'a mut self) -> &'a mut [u8] {\n+        &mut self.payload[NoiseHeader::SIZE..]\n+    }\n+\n+    /// If is an Sv2 frame return the Some(header) if it is a noise frame return None\n+    fn get_header(&self) -> Option<crate::header::Header> {\n+        None\n+    }\n+\n+    /// Try to build a Frame frame from raw bytes.\n+    /// It return the frame or the number of the bytes needed to complete the frame\n+    /// The resulting frame is just a header plus a payload with the right number of bytes nothing\n+    /// is said about the correctness of the payload\n+    fn from_bytes(_bytes: Self::Buffer) -> Result<Self, isize> {\n+        unimplemented!()\n+    }\n+\n+    #[inline]\n+    fn from_bytes_unchecked(bytes: Self::Buffer) -> Self {\n+        let len_b = &bytes[NoiseHeader::LEN_OFFSET..NoiseHeader::SIZE];\n+        let expected_len = u16::from_le_bytes([len_b[0], len_b[1]]) as usize;\n+\n+        Self {\n+            header: expected_len as u16,\n+            payload: bytes,\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(bytes: &[u8]) -> isize {\n+        if bytes.len() < NoiseHeader::SIZE {\n+            return (NoiseHeader::SIZE - bytes.len()) as isize;\n+        };\n+\n+        let len_b = &bytes[NoiseHeader::LEN_OFFSET..NoiseHeader::SIZE];\n+        let expected_len = u16::from_le_bytes([len_b[0], len_b[1]]) as usize;\n+\n+        if bytes.len() - NoiseHeader::SIZE == expected_len {\n+            0\n+        } else {\n+            expected_len as isize - (bytes.len() - NoiseHeader::SIZE) as isize\n+        }\n+    }\n+\n+    #[inline]\n+    fn encoded_length(&self) -> usize {\n+        self.payload.len()\n+    }\n+\n+    /// Try to build a `Frame` frame from a serializable payload.\n+    /// It returns a Frame if the size of the payload fits in the frame, if not it returns None\n+    /// Inneficient should be used only to build `HandShakeFrames`\n+    fn from_message(message: Vec<u8>, _message_type: u8, _extension_type: u16) -> Option<Self> {\n+        if message.len() <= NOISE_MAX_LEN {\n+            let header = message.len() as u16;\n+            let payload = [&header.to_le_bytes()[..], &message[..]].concat();\n+            Some(Self { header, payload })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// A frame can be either\n+/// 1: Sv2Frame\n+/// 2: NoiseFrame\n+/// 3: HandashakeFrame\n+///\n+#[derive(Debug)]\n+pub enum EitherFrame<T, B> {\n+    HandShake(HandShakeFrame),\n+    Sv2(Sv2Frame<T, B>),\n+}\n+\n+impl<T: Serialize + GetSize, B: AsMut<[u8]>> EitherFrame<T, B> {\n+    //pub fn serialize(mut self, dst: &mut B) -> Result<(), serde_sv2::Error> {\n+    //    match self {\n+    //        Self::HandShake(frame) => todo!(),\n+    //        Self::Sv2(frame) => frame.serialize(dst),\n+    //    }\n+    //}\n+\n+    pub fn encoded_length(&self) -> usize {\n+        match &self {\n+            Self::HandShake(frame) => frame.encoded_length(),\n+            Self::Sv2(frame) => frame.encoded_length(),\n+        }\n+    }\n+}\n+\n+impl<T, B> TryFrom<EitherFrame<T, B>> for HandShakeFrame {\n+    type Error = ();\n+\n+    fn try_from(v: EitherFrame<T, B>) -> Result<Self, Self::Error> {\n+        match v {\n+            EitherFrame::HandShake(frame) => Ok(frame),\n+            EitherFrame::Sv2(_) => Err(()),\n+        }\n+    }\n+}\n+\n+impl<T, B> TryFrom<EitherFrame<T, B>> for Sv2Frame<T, B> {\n+    type Error = ();\n+\n+    fn try_from(v: EitherFrame<T, B>) -> Result<Self, Self::Error> {\n+        match v {\n+            EitherFrame::Sv2(frame) => Ok(frame),\n+            EitherFrame::HandShake(_) => Err(()),\n+        }\n+    }\n+}\n+\n+impl<T, B> From<HandShakeFrame> for EitherFrame<T, B> {\n+    fn from(v: HandShakeFrame) -> Self {\n+        Self::HandShake(v)\n+    }\n+}\n+\n+impl<T, B> From<Sv2Frame<T, B>> for EitherFrame<T, B> {\n+    fn from(v: Sv2Frame<T, B>) -> Self {\n+        Self::Sv2(v)\n+    }\n+}"
      },
      {
        "sha": "adc56a3f8d734563750dc5a776cb0667a6860725",
        "filename": "src/rusty/protocols/v2/framing-sv2/src/header.rs",
        "status": "added",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/src/header.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/src/header.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/framing-sv2/src/header.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,82 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2;\n+use binary_sv2::U24;\n+use binary_sv2::{Deserialize, Serialize};\n+use core::convert::TryInto;\n+\n+#[derive(Debug, Serialize, Deserialize, Copy, Clone)]\n+pub struct Header {\n+    extesion_type: u16, // TODO use specific type?\n+    msg_type: u8,       // TODO use specific type?\n+    msg_length: U24,\n+}\n+\n+impl Default for Header {\n+    fn default() -> Self {\n+        Header {\n+            extesion_type: 0,\n+            msg_type: 0,\n+            msg_length: 0_u32.try_into().unwrap(),\n+        }\n+    }\n+}\n+\n+impl Header {\n+    pub const LEN_OFFSET: usize = const_sv2::SV2_FRAME_HEADER_LEN_OFFSET;\n+    pub const LEN_SIZE: usize = const_sv2::SV2_FRAME_HEADER_LEN_END;\n+    pub const LEN_END: usize = Self::LEN_OFFSET + Self::LEN_SIZE;\n+\n+    pub const SIZE: usize = const_sv2::SV2_FRAME_HEADER_SIZE;\n+\n+    #[inline]\n+    pub fn from_bytes(bytes: &[u8]) -> Result<Self, isize> {\n+        if bytes.len() < Self::SIZE {\n+            return Err((Self::SIZE - bytes.len()) as isize);\n+        };\n+\n+        // TODO remove hardcoded\n+        let extesion_type = u16::from_le_bytes([bytes[0], bytes[1]]);\n+        let msg_type = bytes[2];\n+        let msg_length = u32::from_le_bytes([bytes[3], bytes[4], bytes[5], 0]);\n+\n+        Ok(Self {\n+            extesion_type,\n+            msg_type,\n+            // TODO\n+            msg_length: msg_length.try_into().unwrap(),\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        let inner: u32 = self.msg_length.into();\n+        inner as usize\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        unimplemented!()\n+    }\n+\n+    #[inline]\n+    pub fn from_len(len: u32, message_type: u8, extension_type: u16) -> Option<Header> {\n+        Some(Self {\n+            extesion_type: extension_type,\n+            msg_type: message_type,\n+            msg_length: len.try_into().unwrap(),\n+        })\n+    }\n+\n+    pub fn msg_type(&self) -> u8 {\n+        self.msg_type\n+    }\n+}\n+\n+pub struct NoiseHeader {}\n+\n+impl NoiseHeader {\n+    pub const SIZE: usize = const_sv2::NOISE_FRAME_HEADER_SIZE;\n+    pub const LEN_OFFSET: usize = const_sv2::NOISE_FRAME_HEADER_LEN_OFFSET;\n+    pub const LEN_END: usize = const_sv2::NOISE_FRAME_HEADER_LEN_END;\n+}"
      },
      {
        "sha": "84f9f5ee930834f1e2f3ae9c12045a3217ba59c4",
        "filename": "src/rusty/protocols/v2/framing-sv2/src/lib.rs",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/framing-sv2/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/framing-sv2/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,23 @@\n+#![no_std]\n+extern crate alloc;\n+\n+///\n+/// Sv2 messages are framed as\n+/// ```txt\n+/// extension type: u16\n+/// msg type: u8\n+/// msg length: u24\n+/// payload: [u8; msg length]\n+/// ```\n+///\n+/// Sv2 messages can be encapsulated in noise messages, noise messages are framed as:\n+///\n+/// ```txt\n+/// msg length: u16\n+/// payload: [u8; msg length]\n+/// ```\n+///\n+///\n+pub mod framing2;\n+\n+pub mod header;"
      },
      {
        "sha": "b31f72f48454641c17d237c7a6f6e722b99252e4",
        "filename": "src/rusty/protocols/v2/subprotocols/common-messages/Cargo.toml",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/common-messages/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,20 @@\n+[package]\n+name = \"common_messages_sv2\"\n+version = \"0.1.4\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 subprotocol common messages\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional= true }\n+binary_sv2 = {version = \"0.1.*\", path = \"../../../../protocols/v2/binary-sv2/binary-sv2\" }\n+const_sv2 = {version = \"0.1.*\", path = \"../../../../protocols/v2/const-sv2\"}\n+quickcheck = { version = \"1.0.3\", optional=true }\n+quickcheck_macros = { version = \"1\", optional=true }\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\"]\n+prop_test = [\"quickcheck\"]"
      },
      {
        "sha": "67ac86c4e191af5bca7b258e22503549048f0ef7",
        "filename": "src/rusty/protocols/v2/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/src/channel_endpoint_changed.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/common-messages/src/channel_endpoint_changed.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,19 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2;\n+use binary_sv2::{Deserialize, Serialize};\n+\n+/// ## ChannelEndpointChanged (Server -> Client)\n+/// When a channel\u2019s upstream or downstream endpoint changes and that channel had previously\n+/// sent messages with [channel_msg](TODO) bitset of unknown extension_type, the intermediate proxy\n+/// MUST send a [`ChannelEndpointChanged`] message. Upon receipt thereof, any extension state\n+/// (including version negotiation and the presence of support for a given extension) MUST be\n+/// reset and version/presence negotiation must begin again.\n+///\n+#[repr(C)]\n+#[derive(Serialize, Deserialize, Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct ChannelEndpointChanged {\n+    /// The channel which has changed endpoint.\n+    pub channel_id: u32,\n+}"
      },
      {
        "sha": "e15614e46e5be67299f4f74099bddd48aeeff70d",
        "filename": "src/rusty/protocols/v2/subprotocols/common-messages/src/lib.rs",
        "status": "added",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/common-messages/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,112 @@\n+#![no_std]\n+\n+//! Common messages for [stratum v2][Sv2]\n+//! The following protocol messages are common across all of the sv2 (sub)protocols.\n+extern crate alloc;\n+mod channel_endpoint_changed;\n+mod setup_connection;\n+\n+#[cfg(feature = \"prop_test\")]\n+use alloc::vec;\n+#[cfg(feature = \"prop_test\")]\n+use core::convert::TryInto;\n+#[cfg(feature = \"prop_test\")]\n+use quickcheck::{Arbitrary, Gen};\n+\n+pub use channel_endpoint_changed::ChannelEndpointChanged;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use setup_connection::{CSetupConnection, CSetupConnectionError};\n+pub use setup_connection::{\n+    Protocol, SetupConnection, SetupConnectionError, SetupConnectionSuccess,\n+};\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_channel_endpoint_changed(_a: ChannelEndpointChanged) {}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_setup_conn_succ(_a: SetupConnectionSuccess) {}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl ChannelEndpointChanged {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        ChannelEndpointChanged {\n+            channel_id: u32::arbitrary(g).try_into().unwrap(),\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl SetupConnection<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let protocol = setup_connection::Protocol::MiningProtocol;\n+        // TODO: test each Protocol variant\n+        // let protocol = setup_connection::Protocol::JobDistributionProtocol;\n+        // let protocol = setup_connection::Protocol::TemplateDistributionProtocol;\n+        // let protocol = setup_connection::Protocol::JobNegotiationProtocol;\n+\n+        let mut endpoint_host_gen = Gen::new(255);\n+        let mut endpoint_host: vec::Vec<u8> = vec::Vec::new();\n+        endpoint_host.resize_with(255, || u8::arbitrary(&mut endpoint_host_gen));\n+        let endpoint_host: binary_sv2::Str0255 = endpoint_host.try_into().unwrap();\n+\n+        let mut vendor_gen = Gen::new(255);\n+        let mut vendor: vec::Vec<u8> = vec::Vec::new();\n+        vendor.resize_with(255, || u8::arbitrary(&mut vendor_gen));\n+        let vendor: binary_sv2::Str0255 = vendor.try_into().unwrap();\n+\n+        let mut hardware_version_gen = Gen::new(255);\n+        let mut hardware_version: vec::Vec<u8> = vec::Vec::new();\n+        hardware_version.resize_with(255, || u8::arbitrary(&mut hardware_version_gen));\n+        let hardware_version: binary_sv2::Str0255 = hardware_version.try_into().unwrap();\n+\n+        let mut firmware_gen = Gen::new(255);\n+        let mut firmware: vec::Vec<u8> = vec::Vec::new();\n+        firmware.resize_with(255, || u8::arbitrary(&mut firmware_gen));\n+        let firmware: binary_sv2::Str0255 = firmware.try_into().unwrap();\n+\n+        let mut device_id_gen = Gen::new(255);\n+        let mut device_id: vec::Vec<u8> = vec::Vec::new();\n+        device_id.resize_with(255, || u8::arbitrary(&mut device_id_gen));\n+        let device_id: binary_sv2::Str0255 = device_id.try_into().unwrap();\n+\n+        SetupConnection {\n+            protocol,\n+            min_version: u16::arbitrary(g).try_into().unwrap(),\n+            max_version: u16::arbitrary(g).try_into().unwrap(),\n+            flags: u32::arbitrary(g).try_into().unwrap(),\n+            endpoint_host,\n+            endpoint_port: u16::arbitrary(g).try_into().unwrap(),\n+            vendor,\n+            hardware_version,\n+            firmware,\n+            device_id,\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl SetupConnectionError<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let mut error_code_gen = Gen::new(255);\n+        let mut error_code: vec::Vec<u8> = vec::Vec::new();\n+        error_code.resize_with(255, || u8::arbitrary(&mut error_code_gen));\n+        let error_code: binary_sv2::Str0255 = error_code.try_into().unwrap();\n+\n+        SetupConnectionError {\n+            flags: u32::arbitrary(g).try_into().unwrap(),\n+            error_code,\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl SetupConnectionSuccess {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        SetupConnectionSuccess {\n+            used_version: u16::arbitrary(g).try_into().unwrap(),\n+            flags: u32::arbitrary(g).try_into().unwrap(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "daca38961a8ef2020f59e89ab079cffd20388771",
        "filename": "src/rusty/protocols/v2/subprotocols/common-messages/src/setup_connection.rs",
        "status": "added",
        "additions": 272,
        "deletions": 0,
        "changes": 272,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/src/setup_connection.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/common-messages/src/setup_connection.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/common-messages/src/setup_connection.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,272 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+use binary_sv2::Str0255;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::{\n+    binary_codec_sv2, binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n+    free_vec, Error, GetSize,\n+};\n+use binary_sv2::{Deserialize, Serialize};\n+use const_sv2::{\n+    SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT, SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n+    SV2_MINING_PROTOCOL_DISCRIMINANT, SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n+};\n+use core::convert::TryFrom;\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## SetupConnection (Client -> Server)\n+/// Initiates the connection. This MUST be the first message sent by the client on the newly\n+/// opened connection. Server MUST respond with either a [`SetupConnectionSuccess`] or\n+/// [`SetupConnectionError`] message. Clients that are not configured to provide telemetry data to\n+/// the upstream node SHOULD set device_id to 0-length strings. However, they MUST always set\n+/// vendor to a string describing the manufacturer/developer and firmware version and SHOULD\n+/// always set hardware_version to a string describing, at least, the particular hardware/software\n+/// package in use.\n+///\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct SetupConnection<'decoder> {\n+    /// [`Protocol`]\n+    pub protocol: Protocol,\n+    /// The minimum protocol version the client supports (currently must be 2).\n+    pub min_version: u16,\n+    /// The maximum protocol version the client supports (currently must be 2).\n+    pub max_version: u16,\n+    /// Flags indicating optional protocol features the client supports. Each\n+    /// protocol from [`SetupConnection.protocol`] field has its own values/flags.\n+    pub flags: u32,\n+    /// ASCII text indicating the hostname or IP address.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub endpoint_host: Str0255<'decoder>,\n+    /// Connecting port value\n+    pub endpoint_port: u16,\n+    //-- DEVICE INFORMATION --//\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub vendor: Str0255<'decoder>,\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub hardware_version: Str0255<'decoder>,\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub firmware: Str0255<'decoder>,\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub device_id: Str0255<'decoder>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+#[derive(Debug, Clone)]\n+pub struct CSetupConnection {\n+    pub protocol: Protocol,\n+    pub min_version: u16,\n+    pub max_version: u16,\n+    pub flags: u32,\n+    pub endpoint_host: CVec,\n+    pub endpoint_port: u16,\n+    pub vendor: CVec,\n+    pub hardware_version: CVec,\n+    pub firmware: CVec,\n+    pub device_id: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSetupConnection {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetupConnection<'a>, Error> {\n+        let endpoint_host: Str0255 = self.endpoint_host.as_mut_slice().try_into()?;\n+        let vendor: Str0255 = self.vendor.as_mut_slice().try_into()?;\n+        let hardware_version: Str0255 = self.hardware_version.as_mut_slice().try_into()?;\n+        let firmware: Str0255 = self.firmware.as_mut_slice().try_into()?;\n+        let device_id: Str0255 = self.device_id.as_mut_slice().try_into()?;\n+\n+        Ok(SetupConnection {\n+            protocol: self.protocol,\n+            min_version: self.min_version,\n+            max_version: self.max_version,\n+            flags: self.flags,\n+            endpoint_host,\n+            endpoint_port: self.endpoint_port,\n+            vendor,\n+            hardware_version,\n+            firmware,\n+            device_id,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_setup_connection(s: CSetupConnection) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSetupConnection {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.endpoint_host);\n+        free_vec(&mut self.vendor);\n+        free_vec(&mut self.hardware_version);\n+        free_vec(&mut self.firmware);\n+        free_vec(&mut self.device_id);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SetupConnection<'a>> for CSetupConnection {\n+    fn from(v: SetupConnection) -> Self {\n+        Self {\n+            protocol: v.protocol,\n+            min_version: v.min_version,\n+            max_version: v.max_version,\n+            flags: v.flags,\n+            endpoint_host: v.endpoint_host.into(),\n+            endpoint_port: v.endpoint_port,\n+            vendor: v.vendor.into(),\n+            hardware_version: v.hardware_version.into(),\n+            firmware: v.firmware.into(),\n+            device_id: v.device_id.into(),\n+        }\n+    }\n+}\n+\n+/// ## SetupConnection.Success (Server -> Client)\n+/// Response to [`SetupConnection`] message if the server accepts the connection. The client is\n+/// required to verify the set of feature flags that the server supports and act accordingly.\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+#[repr(C)]\n+pub struct SetupConnectionSuccess {\n+    /// Selected version proposed by the connecting node that the upstream\n+    /// node supports. This version will be used on the connection for the rest\n+    /// of its life.\n+    pub used_version: u16,\n+    /// Flags indicating optional protocol features the server supports. Each\n+    /// protocol from [`Protocol`] field has its own values/flags.\n+    pub flags: u32,\n+}\n+\n+/// ## SetupConnection.Error (Server -> Client)\n+/// When protocol version negotiation fails (or there is another reason why the upstream node\n+/// cannot setup the connection) the server sends this message with a particular error code prior\n+/// to closing the connection.\n+/// In order to allow a client to determine the set of available features for a given server (e.g. for\n+/// proxies which dynamically switch between different pools and need to be aware of supported\n+/// options), clients SHOULD send a SetupConnection message with all flags set and examine the\n+/// (potentially) resulting [`SetupConnectionError`] message\u2019s flags field. The Server MUST provide\n+/// the full set of flags which it does not support in each [`SetupConnectionError`] message and\n+/// MUST consistently support the same set of flags across all servers on the same hostname and\n+/// port number. If flags is 0, the error is a result of some condition aside from unsupported flags.\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct SetupConnectionError<'decoder> {\n+    /// Flags indicating features causing an error.\n+    pub flags: u32,\n+    /// Human-readable error code(s). See Error Codes section, [link](TODO).\n+    /// ### Possible error codes:\n+    /// * \u2018unsupported-feature-flags\u2019\n+    /// * \u2018unsupported-protocol\u2019\n+    /// * \u2018protocol-version-mismatch\u2019\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub error_code: Str0255<'decoder>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+#[derive(Debug, Clone)]\n+pub struct CSetupConnectionError {\n+    flags: u32,\n+    error_code: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSetupConnectionError {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetupConnectionError<'a>, Error> {\n+        let error_code: Str0255 = self.error_code.as_mut_slice().try_into()?;\n+\n+        Ok(SetupConnectionError {\n+            flags: self.flags,\n+            error_code,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_setup_connection_error(s: CSetupConnectionError) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSetupConnectionError {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.error_code);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SetupConnectionError<'a>> for CSetupConnectionError {\n+    fn from(v: SetupConnectionError<'a>) -> Self {\n+        Self {\n+            flags: v.flags,\n+            error_code: v.error_code.into(),\n+        }\n+    }\n+}\n+\n+/// MiningProtocol = [`SV2_MINING_PROTOCOL_DISCRIMINANT`],\n+/// JobNegotiationProtocol = [`SV2_JOB_NEG_PROTOCOL_DISCRIMINANT`],\n+/// TemplateDistributionProtocol = [`SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT`],\n+/// JobDistributionProtocol = [`SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT`],\n+#[cfg_attr(feature = \"with_serde\", derive(Serialize, Deserialize))]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+#[repr(u8)]\n+#[allow(clippy::enum_variant_names)]\n+pub enum Protocol {\n+    MiningProtocol = SV2_MINING_PROTOCOL_DISCRIMINANT,\n+    JobNegotiationProtocol = SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n+    TemplateDistributionProtocol = SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n+    JobDistributionProtocol = SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<Protocol> for binary_sv2::encodable::EncodableField<'a> {\n+    fn from(v: Protocol) -> Self {\n+        let val = v as u8;\n+        val.into()\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'decoder> binary_sv2::Decodable<'decoder> for Protocol {\n+    fn get_structure(\n+        _: &[u8],\n+    ) -> core::result::Result<alloc::vec::Vec<FieldMarker>, binary_sv2::Error> {\n+        let field: FieldMarker = 0_u8.into();\n+        Ok(alloc::vec![field])\n+    }\n+    fn from_decoded_fields(\n+        mut v: alloc::vec::Vec<DecodableField<'decoder>>,\n+    ) -> core::result::Result<Self, binary_sv2::Error> {\n+        let val = v.pop().unwrap();\n+        let val: u8 = val.try_into().unwrap();\n+        Ok(val.try_into().unwrap())\n+    }\n+}\n+\n+impl TryFrom<u8> for Protocol {\n+    type Error = ();\n+\n+    fn try_from(value: u8) -> Result<Self, Self::Error> {\n+        match value {\n+            SV2_MINING_PROTOCOL_DISCRIMINANT => Ok(Protocol::MiningProtocol),\n+            SV2_JOB_NEG_PROTOCOL_DISCRIMINANT => Ok(Protocol::JobNegotiationProtocol),\n+            SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT => Ok(Protocol::TemplateDistributionProtocol),\n+            SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT => Ok(Protocol::JobDistributionProtocol),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl GetSize for Protocol {\n+    fn get_size(&self) -> usize {\n+        1\n+    }\n+}"
      },
      {
        "sha": "2f0de091d5d4a0eed61abcbba79dfc6dba08f759",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/Cargo.toml",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,20 @@\n+[package]\n+name = \"template_distribution_sv2\"\n+version = \"0.1.4\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+description = \"Sv2 template distribution subprotocol\"\n+license = \"MIT\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde = { version = \"1.0.89\", default-features = false, optional= true }\n+binary_sv2 = { version = \"0.1.*\", path = \"../../../../protocols/v2/binary-sv2/binary-sv2\" }\n+const_sv2 = { version = \"0.1.*\", path = \"../../../../protocols/v2/const-sv2\"}\n+quickcheck = { version = \"1.0.3\", optional=true }\n+quickcheck_macros = { version = \"1\", optional=true }\n+\n+[features]\n+with_serde = [\"binary_sv2/with_serde\", \"serde\"]\n+prop_test = [\"quickcheck\"]"
      },
      {
        "sha": "d82cabc30ea5c0c708416778ba1983c39c357878",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/coinbase_output_data_size.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/src/coinbase_output_data_size.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,27 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2;\n+use binary_sv2::{Deserialize, Serialize};\n+\n+/// ## CoinbaseOutputDataSize (Client -> Server)\n+/// Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and\n+/// other uses, and thus the Template Provider will need to consider this additional block size\n+/// when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\n+/// Thus, this message is used to indicate that some additional space in the block/coinbase\n+/// transaction be reserved for the pool\u2019s use (while always assuming the pool will use the entirety\n+/// of available coinbase space).\n+/// The Job Negotiator MUST discover the maximum serialized size of the additional outputs which\n+/// will be added by the pool(s) it intends to use this work. It then MUST communicate the\n+/// maximum such size to the Template Provider via this message. The Template Provider MUST\n+/// NOT provide NewWork messages which would represent consensus-invalid blocks once this\n+/// additional size \u2014 along with a maximally-sized (100 byte) coinbase field \u2014 is added. Further,\n+/// the Template Provider MUST consider the maximum additional bytes required in the output\n+/// count variable-length integer in the coinbase transaction when complying with the size limits.\n+#[derive(Serialize, Deserialize, Copy, Clone, Debug, PartialEq, Eq)]\n+#[repr(C)]\n+pub struct CoinbaseOutputDataSize {\n+    /// The maximum additional serialized bytes which the pool will add in\n+    /// coinbase transaction outputs.\n+    pub coinbase_output_max_additional_size: u32,\n+}"
      },
      {
        "sha": "1b5c237f02679ea13ce2419e058fc2372de60fed",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/src/lib.rs",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,171 @@\n+#![no_std]\n+\n+//! # Template Distribution Protocol\n+//! The Template Distribution protocol is used to receive updates of the block template to use in\n+//! mining the next block. It effectively replaces BIPs [22](TODO) and [23](TODO) (getblocktemplate) and provides\n+//! a much more efficient API which allows Bitcoin Core (or some other full node software) to push\n+//! template updates at more appropriate times as well as provide a template which may be\n+//! mined on quickly for the block-after-next. While not recommended, the template update\n+//! protocol can be a remote server, and is thus authenticated and signed in the same way as all\n+//! other protocols ([using the same SetupConnection handshake][TODO]).\n+//! Like the [Job Negotiation](TODO) and [Job Distribution](TODO) (sub)protocols, all Template Distribution messages\n+//! have the channel_msg bit unset, and there is no concept of channels. After the initial common\n+//! handshake, the client MUST immediately send a [`CoinbaseOutputDataSize`] message to indicate\n+//! the space it requires for coinbase output addition, to which the server MUST immediately reply\n+//! with the current best block template it has available to the client. Thereafter, the server\n+//! SHOULD push new block templates to the client whenever the total fee in the current block\n+//! template increases materially, and MUST send updated block templates whenever it learns of\n+//! a new block.\n+//! Template Providers MUST attempt to broadcast blocks which are mined using work they\n+//! provided, and thus MUST track the work which they provided to clients.\n+extern crate alloc;\n+\n+#[cfg(feature = \"prop_test\")]\n+use alloc::vec;\n+#[cfg(feature = \"prop_test\")]\n+use core::convert::TryInto;\n+#[cfg(feature = \"prop_test\")]\n+use quickcheck::{Arbitrary, Gen};\n+\n+mod coinbase_output_data_size;\n+mod new_template;\n+mod request_transaction_data;\n+mod set_new_prev_hash;\n+mod submit_solution;\n+//\n+pub use coinbase_output_data_size::CoinbaseOutputDataSize;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use new_template::CNewTemplate;\n+pub use new_template::NewTemplate;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use request_transaction_data::{CRequestTransactionDataError, CRequestTransactionDataSuccess};\n+pub use request_transaction_data::{\n+    RequestTransactionData, RequestTransactionDataError, RequestTransactionDataSuccess,\n+};\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use set_new_prev_hash::CSetNewPrevHash;\n+pub use set_new_prev_hash::SetNewPrevHash;\n+#[cfg(not(feature = \"with_serde\"))]\n+pub use submit_solution::CSubmitSolution;\n+pub use submit_solution::SubmitSolution;\n+\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_coinbase_out(_a: CoinbaseOutputDataSize) {}\n+\n+#[no_mangle]\n+pub extern \"C\" fn _c_export_req_tx_data(_a: RequestTransactionData) {}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[cfg(feature = \"prop_test\")]\n+impl NewTemplate<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let mut coinbase_prefix_gen = Gen::new(255);\n+        let mut coinbase_prefix: vec::Vec<u8> = vec::Vec::new();\n+        coinbase_prefix.resize_with(255, || u8::arbitrary(&mut coinbase_prefix_gen));\n+        let mut coinbase_prefix: binary_sv2::B0255 = coinbase_prefix.try_into().unwrap();\n+\n+        let mut coinbase_tx_outputs_gen = Gen::new(64);\n+        let mut coinbase_tx_outputs: vec::Vec<u8> = vec::Vec::new();\n+        coinbase_tx_outputs.resize_with(64, || u8::arbitrary(&mut coinbase_tx_outputs_gen));\n+        let mut coinbase_tx_outputs: binary_sv2::B064K = coinbase_tx_outputs.try_into().unwrap();\n+\n+        let mut merkle_path_inner_gen = Gen::new(256);\n+        let mut merkle_path_inner: vec::Vec<u8> = vec::Vec::new();\n+        merkle_path_inner.resize_with(256, || u8::arbitrary(&mut merkle_path_inner_gen));\n+        let mut merkle_path_inner: binary_sv2::U256 = merkle_path_inner.try_into().unwrap();\n+\n+        let merkle_path: binary_sv2::Seq0255<binary_sv2::U256> = vec![merkle_path_inner].into();\n+        NewTemplate {\n+            template_id: u64::arbitrary(g),\n+            future_template: bool::arbitrary(g),\n+            version: u32::arbitrary(g),\n+            coinbase_tx_version: u32::arbitrary(g),\n+            coinbase_prefix,\n+            coinbase_tx_input_sequence: u32::arbitrary(g),\n+            coinbase_tx_value_remaining: u64::arbitrary(g),\n+            coinbase_tx_outputs_count: u32::arbitrary(g),\n+            coinbase_tx_outputs,\n+            coinbase_tx_locktime: u32::arbitrary(g),\n+            merkle_path,\n+        }\n+    }\n+}\n+#[cfg(feature = \"prop_test\")]\n+impl CoinbaseOutputDataSize {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        coinbase_output_data_size::CoinbaseOutputDataSize {\n+            coinbase_output_max_additional_size: u32::arbitrary(g).try_into().unwrap(),\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl RequestTransactionData {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        RequestTransactionData {\n+            template_id: u64::arbitrary(g).try_into().unwrap(),\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl RequestTransactionDataError<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let mut error_code_gen = Gen::new(255);\n+        let mut error_code: vec::Vec<u8> = vec::Vec::new();\n+        error_code.resize_with(255, || u8::arbitrary(&mut error_code_gen));\n+        let error_code: binary_sv2::Str0255 = error_code.try_into().unwrap();\n+\n+        RequestTransactionDataError {\n+            template_id: u64::arbitrary(g).try_into().unwrap(),\n+            error_code,\n+        }\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[cfg(feature = \"prop_test\")]\n+impl RequestTransactionDataSuccess<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let excess_data: binary_sv2::B064K = vec::Vec::<u8>::arbitrary(g).try_into().unwrap();\n+        let transaction_list_inner = binary_sv2::B016M::from_gen(g);\n+        let transaction_list: binary_sv2::Seq064K<binary_sv2::B016M> =\n+            vec![transaction_list_inner].into();\n+\n+        RequestTransactionDataSuccess {\n+            template_id: u64::arbitrary(g).try_into().unwrap(),\n+            excess_data,\n+            transaction_list,\n+        }\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[cfg(feature = \"prop_test\")]\n+impl SetNewPrevHash<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let prev_hash = binary_sv2::U256::from_gen(g);\n+        let target = binary_sv2::U256::from_gen(g);\n+        SetNewPrevHash {\n+            template_id: u64::arbitrary(g).try_into().unwrap(),\n+            prev_hash,\n+            header_timestamp: u32::arbitrary(g).try_into().unwrap(),\n+            n_bits: u32::arbitrary(g).try_into().unwrap(),\n+            target,\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"prop_test\")]\n+impl SubmitSolution<'static> {\n+    pub fn from_gen(g: &mut Gen) -> Self {\n+        let coinbase_tx: binary_sv2::B064K = vec::Vec::<u8>::arbitrary(g).try_into().unwrap();\n+        SubmitSolution {\n+            template_id: u64::arbitrary(g).try_into().unwrap(),\n+            version: u32::arbitrary(g).try_into().unwrap(),\n+            header_timestamp: u32::arbitrary(g).try_into().unwrap(),\n+            header_nonce: u32::arbitrary(g).try_into().unwrap(),\n+            coinbase_tx,\n+        }\n+    }\n+}"
      },
      {
        "sha": "15c15eac05adc5fd4f4deeb583a5477e3fdd099d",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/src/new_template.rs",
        "status": "added",
        "additions": 135,
        "deletions": 0,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/new_template.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/new_template.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/src/new_template.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,135 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, free_vec_2, CVec, CVec2};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::{Deserialize, Serialize};\n+use binary_sv2::{Seq0255, B0255, B064K, U256};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## NewTemplate (Server -> Client)\n+/// The primary template-providing function. Note that the coinbase_tx_outputs bytes will appear\n+/// as is at the end of the coinbase transaction.\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct NewTemplate<'decoder> {\n+    /// Server\u2019s identification of the template. Strictly increasing, the\n+    /// current UNIX time may be used in place of an ID.\n+    pub template_id: u64,\n+    /// True if the template is intended for future [`crate::SetNewPrevHash`]\n+    /// message sent on the channel. If False, the job relates to the last\n+    /// sent [`crate::SetNewPrevHash`] message on the channel and the miner\n+    /// should start to work on the job immediately.\n+    pub future_template: bool,\n+    /// Valid header version field that reflects the current network\n+    /// consensus. The general purpose bits (as specified in [BIP320](TODO link)) can\n+    /// be freely manipulated by the downstream node. The downstream\n+    /// node MUST NOT rely on the upstream node to set the BIP320 bits\n+    /// to any particular value.\n+    pub version: u32,\n+    /// The coinbase transaction nVersion field.\n+    pub coinbase_tx_version: u32,\n+    /// Up to 8 bytes (not including the length byte) which are to be placed\n+    /// at the beginning of the coinbase field in the coinbase transaction.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub coinbase_prefix: B0255<'decoder>,\n+    ///bug\n+    /// The coinbase transaction input\u2019s nSequence field.\n+    pub coinbase_tx_input_sequence: u32,\n+    /// The value, in satoshis, available for spending in coinbase outputs\n+    /// added by the client. Includes both transaction fees and block\n+    /// subsidy.\n+    pub coinbase_tx_value_remaining: u64,\n+    /// The number of transaction outputs included in coinbase_tx_outputs.\n+    pub coinbase_tx_outputs_count: u32,\n+    /// Bitcoin transaction outputs to be included as the last outputs in the\n+    /// coinbase transaction.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub coinbase_tx_outputs: B064K<'decoder>, //bug\n+    /// The locktime field in the coinbase transaction.\n+    pub coinbase_tx_locktime: u32,\n+    /// Merkle path hashes ordered from deepest.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub merkle_path: Seq0255<'decoder, U256<'decoder>>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub struct CNewTemplate {\n+    template_id: u64,\n+    future_template: bool,\n+    version: u32,\n+    coinbase_tx_version: u32,\n+    coinbase_prefix: CVec,\n+    coinbase_tx_input_sequence: u32,\n+    coinbase_tx_value_remaining: u64,\n+    coinbase_tx_outputs_count: u32,\n+    coinbase_tx_outputs: CVec,\n+    coinbase_tx_locktime: u32,\n+    merkle_path: CVec2,\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_new_template(s: CNewTemplate) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CNewTemplate {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.coinbase_prefix);\n+        free_vec(&mut self.coinbase_tx_outputs);\n+        free_vec_2(&mut self.merkle_path);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<NewTemplate<'a>> for CNewTemplate {\n+    fn from(v: NewTemplate<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            future_template: v.future_template,\n+            version: v.version,\n+            coinbase_tx_version: v.coinbase_tx_version,\n+            coinbase_prefix: v.coinbase_prefix.into(),\n+            coinbase_tx_input_sequence: v.coinbase_tx_input_sequence,\n+            coinbase_tx_value_remaining: v.coinbase_tx_value_remaining,\n+            coinbase_tx_outputs_count: v.coinbase_tx_outputs_count,\n+            coinbase_tx_outputs: v.coinbase_tx_outputs.into(),\n+            coinbase_tx_locktime: v.coinbase_tx_locktime,\n+            merkle_path: v.merkle_path.into(),\n+        }\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CNewTemplate {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<NewTemplate<'a>, Error> {\n+        let coinbase_prefix: B0255 = self.coinbase_prefix.as_mut_slice().try_into()?;\n+        let coinbase_tx_outputs: B064K = self.coinbase_tx_outputs.as_mut_slice().try_into()?;\n+\n+        let merkle_path_ = self.merkle_path.as_mut_slice();\n+        let mut merkle_path: Vec<U256> = Vec::new();\n+        for cvec in merkle_path_ {\n+            merkle_path.push(cvec.as_mut_slice().try_into()?);\n+        }\n+\n+        let merkle_path = Seq0255::new(merkle_path)?;\n+        Ok(NewTemplate {\n+            template_id: self.template_id,\n+            future_template: self.future_template,\n+            version: self.version,\n+            coinbase_tx_version: self.coinbase_tx_version,\n+            coinbase_prefix,\n+            coinbase_tx_input_sequence: self.coinbase_tx_input_sequence,\n+            coinbase_tx_value_remaining: self.coinbase_tx_value_remaining,\n+            coinbase_tx_outputs_count: self.coinbase_tx_outputs_count,\n+            coinbase_tx_outputs,\n+            coinbase_tx_locktime: self.coinbase_tx_locktime,\n+            merkle_path,\n+        })\n+    }\n+}"
      },
      {
        "sha": "987bb86caa1f1afde8dec68f47f53a8d39cf7a9a",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/src/request_transaction_data.rs",
        "status": "added",
        "additions": 165,
        "deletions": 0,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/request_transaction_data.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/request_transaction_data.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/src/request_transaction_data.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,165 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, free_vec_2, CVec, CVec2};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::{Deserialize, Serialize};\n+use binary_sv2::{Seq064K, Str0255, B016M, B064K};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## RequestTransactionData (Client -> Server)\n+/// A request sent by the Job Negotiator to the Template Provider which requests the set of\n+/// transaction data for all transactions (excluding the coinbase transaction) included in a block, as\n+/// well as any additional data which may be required by the Pool to validate the work.\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+#[repr(C)]\n+pub struct RequestTransactionData {\n+    /// The template_id corresponding to a NewTemplate message.\n+    pub template_id: u64,\n+}\n+\n+/// ## RequestTransactionData.Success (Server->Client)\n+/// A response to [`RequestTransactionData`] which contains the set of full transaction data and\n+/// excess data required for validation. For practical purposes, the excess data is usually the\n+/// SegWit commitment, however the Job Negotiator MUST NOT parse or interpret the excess data\n+/// in any way. Note that the transaction data MUST be treated as opaque blobs and MUST include\n+/// any SegWit or other data which the Pool may require to verify the transaction. For practical\n+/// purposes, the transaction data is likely the witness-encoded transaction today. However, to\n+/// ensure backward compatibility, the transaction data MAY be encoded in a way that is different\n+/// from the consensus serialization of Bitcoin transactions.\n+/// Ultimately, having some method of negotiating the specific format of transactions between the\n+/// Template Provider and the Pool\u2019s Template verification node would be overly burdensome,\n+/// thus the following requirements are made explicit. The RequestTransactionData.Success\n+/// sender MUST ensure that the data is provided in a forwards- and backwards-compatible way to\n+/// ensure the end receiver of the data can interpret it, even in the face of new,\n+/// consensus-optional data. This allows significantly more flexibility on both the\n+/// RequestTransactionData.Success-generating and -interpreting sides during upgrades, at the\n+/// cost of breaking some potential optimizations which would require version negotiation to\n+/// provide support for previous versions. For practical purposes, and as a non-normative\n+/// suggested implementation for Bitcoin Core, this implies that additional consensus-optional\n+/// data be appended at the end of transaction data. It will simply be ignored by versions which do\n+/// not understand it.\n+/// To work around the limitation of not being able to negotiate e.g. a transaction compression\n+/// scheme, the format of the opaque data in RequestTransactionData.Success messages MAY be\n+/// changed in non-compatible ways at the time a fork activates, given sufficient time from\n+/// code-release to activation (as any sane fork would have to have) and there being some\n+/// in-Template Negotiation Protocol signaling of support for the new fork (e.g. for soft-forks\n+/// activated using [BIP 9](TODO link)).\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct RequestTransactionDataSuccess<'decoder> {\n+    /// The template_id corresponding to a NewTemplate/RequestTransactionData message.\n+    pub template_id: u64,\n+    /// Extra data which the Pool may require to validate the work.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub excess_data: B064K<'decoder>,\n+    /// The transaction data, serialized as a series of B0_16M byte arrays.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub transaction_list: Seq064K<'decoder, B016M<'decoder>>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub struct CRequestTransactionDataSuccess {\n+    template_id: u64,\n+    excess_data: CVec,\n+    transaction_list: CVec2,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CRequestTransactionDataSuccess {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<RequestTransactionDataSuccess<'a>, Error> {\n+        let excess_data: B064K = self.excess_data.as_mut_slice().try_into()?;\n+        let transaction_list_ = self.transaction_list.as_mut_slice();\n+        let mut transaction_list: Vec<B016M> = Vec::new();\n+        for cvec in transaction_list_ {\n+            transaction_list.push(cvec.as_mut_slice().try_into()?);\n+        }\n+        let transaction_list = Seq064K::new(transaction_list)?;\n+        Ok(RequestTransactionDataSuccess {\n+            template_id: self.template_id,\n+            excess_data,\n+            transaction_list,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_request_tx_data_success(s: CRequestTransactionDataSuccess) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CRequestTransactionDataSuccess {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.excess_data);\n+        free_vec_2(&mut self.transaction_list);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<RequestTransactionDataSuccess<'a>> for CRequestTransactionDataSuccess {\n+    fn from(v: RequestTransactionDataSuccess<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            excess_data: v.excess_data.into(),\n+            transaction_list: v.transaction_list.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct RequestTransactionDataError<'decoder> {\n+    /// The template_id corresponding to a NewTemplate/RequestTransactionData message.\n+    pub template_id: u64,\n+    /// Reason why no transaction data has been provided\n+    /// Possible error codes:\n+    /// * template-id-not-found\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub error_code: Str0255<'decoder>,\n+}\n+\n+#[repr(C)]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub struct CRequestTransactionDataError {\n+    template_id: u64,\n+    error_code: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CRequestTransactionDataError {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<RequestTransactionDataError<'a>, Error> {\n+        let error_code: Str0255 = self.error_code.as_mut_slice().try_into()?;\n+        Ok(RequestTransactionDataError {\n+            template_id: self.template_id,\n+            error_code,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_request_tx_data_error(s: CRequestTransactionDataError) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CRequestTransactionDataError {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.error_code);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<RequestTransactionDataError<'a>> for CRequestTransactionDataError {\n+    fn from(v: RequestTransactionDataError<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            error_code: v.error_code.into(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "055ee4d19587c5f0299f844b891bdd38d37078d5",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/set_new_prev_hash.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/src/set_new_prev_hash.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,90 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, CVec};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::U256;\n+use binary_sv2::{Deserialize, Serialize};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## SetNewPrevHash (Server -> Client)\n+/// Upon successful validation of a new best block, the server MUST immediately provide a\n+/// SetNewPrevHash message. If a [NewWork](TODO link) message has previously been sent with the\n+/// [future_job](TODO link) flag set, which is valid work based on the prev_hash contained in this message, the\n+/// template_id field SHOULD be set to the job_id present in that NewTemplate message\n+/// indicating the client MUST begin mining on that template as soon as possible.\n+/// TODO: Define how many previous works the client has to track (2? 3?), and require that the\n+/// server reference one of those in SetNewPrevHash.\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct SetNewPrevHash<'decoder> {\n+    /// template_id referenced in a previous NewTemplate message.\n+    pub template_id: u64,\n+    /// Previous block\u2019s hash, as it must appear in the next block\u2019s header.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub prev_hash: U256<'decoder>,\n+    /// The nTime field in the block header at which the client should start\n+    /// (usually current time). This is NOT the minimum valid nTime value.\n+    pub header_timestamp: u32,\n+    /// Block header field.\n+    pub n_bits: u32,\n+    /// The maximum double-SHA256 hash value which would represent a valid\n+    /// block. Note that this may be lower than the target implied by nBits in\n+    /// several cases, including weak-block based block propagation.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub target: U256<'decoder>,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[repr(C)]\n+pub struct CSetNewPrevHash {\n+    template_id: u64,\n+    prev_hash: CVec,\n+    header_timestamp: u32,\n+    n_bits: u32,\n+    target: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSetNewPrevHash {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SetNewPrevHash<'a>, Error> {\n+        let prev_hash: U256 = self.prev_hash.as_mut_slice().try_into()?;\n+        let target: U256 = self.target.as_mut_slice().try_into()?;\n+\n+        Ok(SetNewPrevHash {\n+            template_id: self.template_id,\n+            prev_hash,\n+            header_timestamp: self.header_timestamp,\n+            n_bits: self.n_bits,\n+            target,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_set_new_prev_hash(s: CSetNewPrevHash) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSetNewPrevHash {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.target);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SetNewPrevHash<'a>> for CSetNewPrevHash {\n+    fn from(v: SetNewPrevHash<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            prev_hash: v.prev_hash.into(),\n+            header_timestamp: v.header_timestamp,\n+            n_bits: v.n_bits,\n+            target: v.target.into(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "af78ff53d20c8513b0489cd1a87ebbfe5262dba8",
        "filename": "src/rusty/protocols/v2/subprotocols/template-distribution/src/submit_solution.rs",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/submit_solution.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/subprotocols/template-distribution/src/submit_solution.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/subprotocols/template-distribution/src/submit_solution.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,88 @@\n+#[cfg(not(feature = \"with_serde\"))]\n+use alloc::vec::Vec;\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::binary_codec_sv2::{self, free_vec, CVec};\n+#[cfg(not(feature = \"with_serde\"))]\n+use binary_sv2::Error;\n+use binary_sv2::B064K;\n+use binary_sv2::{Deserialize, Serialize};\n+#[cfg(not(feature = \"with_serde\"))]\n+use core::convert::TryInto;\n+\n+/// ## SubmitSolution (Client -> Server)\n+/// Upon finding a coinbase transaction/nonce pair which double-SHA256 hashes at or below\n+/// [`crate::SetNewPrevHash.target`], the client MUST immediately send this message, and the server\n+/// MUST then immediately construct the corresponding full block and attempt to propagate it to\n+/// the Bitcoin network.\n+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\n+pub struct SubmitSolution<'decoder> {\n+    /// The template_id field as it appeared in NewTemplate.\n+    pub template_id: u64,\n+    /// The version field in the block header. Bits not defined by [BIP320](TODO link) as\n+    /// additional nonce MUST be the same as they appear in the [NewWork](TODO link)\n+    /// message, other bits may be set to any value.\n+    pub version: u32,\n+    /// The nTime field in the block header. This MUST be greater than or equal\n+    /// to the header_timestamp field in the latest [`crate::SetNewPrevHash`] message\n+    /// and lower than or equal to that value plus the number of seconds since\n+    /// the receipt of that message.\n+    pub header_timestamp: u32,\n+    /// The nonce field in the header.\n+    pub header_nonce: u32,\n+    /// The full serialized coinbase transaction, meeting all the requirements of\n+    /// the NewWork message, above.\n+    #[cfg_attr(feature = \"with_serde\", serde(borrow))]\n+    pub coinbase_tx: B064K<'decoder>,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+#[repr(C)]\n+pub struct CSubmitSolution {\n+    template_id: u64,\n+    version: u32,\n+    header_timestamp: u32,\n+    header_nonce: u32,\n+    coinbase_tx: CVec,\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> CSubmitSolution {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<SubmitSolution<'a>, Error> {\n+        let coinbase_tx: B064K = self.coinbase_tx.as_mut_slice().try_into()?;\n+\n+        Ok(SubmitSolution {\n+            template_id: self.template_id,\n+            version: self.version,\n+            header_timestamp: self.header_timestamp,\n+            header_nonce: self.header_nonce,\n+            coinbase_tx,\n+        })\n+    }\n+}\n+\n+#[no_mangle]\n+#[cfg(not(feature = \"with_serde\"))]\n+pub extern \"C\" fn free_submit_solution(s: CSubmitSolution) {\n+    drop(s)\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl Drop for CSubmitSolution {\n+    fn drop(&mut self) {\n+        free_vec(&mut self.coinbase_tx);\n+    }\n+}\n+\n+#[cfg(not(feature = \"with_serde\"))]\n+impl<'a> From<SubmitSolution<'a>> for CSubmitSolution {\n+    fn from(v: SubmitSolution<'a>) -> Self {\n+        Self {\n+            template_id: v.template_id,\n+            version: v.version,\n+            header_timestamp: v.header_timestamp,\n+            header_nonce: v.header_nonce,\n+            coinbase_tx: v.coinbase_tx.into(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "43d5c9114c19fef0b04535e7388a5d01c087c859",
        "filename": "src/rusty/protocols/v2/sv2-ffi/Cargo.toml",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/sv2-ffi/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/sv2-ffi/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/sv2-ffi/Cargo.toml?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,27 @@\n+[package]\n+name = \"sv2_ffi\"\n+version = \"0.1.3\"\n+authors = [\"fi3 <email@email.org>\"]\n+edition = \"2018\"\n+\n+[lib]\n+crate-type = [\"staticlib\"]\n+\n+[dependencies]\n+codec_sv2 = { path = \"../../../protocols/v2/codec-sv2\", version = \"0.1.*\" }\n+const_sv2 = { path = \"../../../protocols/v2/const-sv2\", version = \"0.1.*\" }\n+binary_sv2 = { path = \"../../../protocols/v2/binary-sv2/binary-sv2\", version = \"0.1.*\" }\n+common_messages_sv2 = { path = \"../../../protocols/v2/subprotocols/common-messages\", version = \"0.1.*\" }\n+template_distribution_sv2 = { path = \"../../../protocols/v2/subprotocols/template-distribution\", version = \"0.1.*\"}\n+\n+[dev-dependencies]\n+quickcheck = \"1.0.3\"\n+quickcheck_macros = \"1\"\n+\n+[features]\n+with_serde = []\n+prop_test = [\"binary_sv2/prop_test\", \"common_messages_sv2/prop_test\", \"template_distribution_sv2/prop_test\"]\n+\n+[profile.release]\n+panic = 'unwind'\n+overflow-checks = true"
      },
      {
        "sha": "3620632308454aa1e4b0d2ebe090157a5a3f6b6d",
        "filename": "src/rusty/protocols/v2/sv2-ffi/src/lib.rs",
        "status": "added",
        "additions": 1124,
        "deletions": 0,
        "changes": 1124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/sv2-ffi/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/sv2-ffi/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/sv2-ffi/src/lib.rs?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,1124 @@\n+#![cfg(not(feature = \"with_serde\"))]\n+\n+use codec_sv2::{Encoder, Frame, StandardDecoder, StandardSv2Frame};\n+use common_messages_sv2::{\n+    CSetupConnection, CSetupConnectionError, ChannelEndpointChanged, SetupConnection,\n+    SetupConnectionError, SetupConnectionSuccess,\n+};\n+use template_distribution_sv2::{\n+    CNewTemplate, CRequestTransactionDataError, CRequestTransactionDataSuccess, CSetNewPrevHash,\n+    CSubmitSolution, CoinbaseOutputDataSize, NewTemplate, RequestTransactionData,\n+    RequestTransactionDataError, RequestTransactionDataSuccess, SetNewPrevHash, SubmitSolution,\n+};\n+\n+use binary_sv2::{\n+    binary_codec_sv2::CVec, decodable::DecodableField, decodable::FieldMarker,\n+    encodable::EncodableField, from_bytes, Deserialize, Error,\n+};\n+\n+use const_sv2::{\n+    MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES, MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n+    MESSAGE_TYPE_NEW_TEMPLATE, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n+    MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS,\n+    MESSAGE_TYPE_SETUP_CONNECTION, MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n+    MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS, MESSAGE_TYPE_SET_NEW_PREV_HASH,\n+    MESSAGE_TYPE_SUBMIT_SOLUTION,\n+};\n+use core::convert::{TryFrom, TryInto};\n+\n+#[derive(Clone, Debug)]\n+pub enum Sv2Message<'a> {\n+    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n+    NewTemplate(NewTemplate<'a>),\n+    RequestTransactionData(RequestTransactionData),\n+    RequestTransactionDataError(RequestTransactionDataError<'a>),\n+    RequestTransactionDataSuccess(RequestTransactionDataSuccess<'a>),\n+    SetNewPrevHash(SetNewPrevHash<'a>),\n+    SubmitSolution(SubmitSolution<'a>),\n+    ChannelEndpointChanged(ChannelEndpointChanged),\n+    SetupConnection(SetupConnection<'a>),\n+    SetupConnectionError(SetupConnectionError<'a>),\n+    SetupConnectionSuccess(SetupConnectionSuccess),\n+}\n+\n+impl<'a> Sv2Message<'a> {\n+    pub fn message_type(&self) -> u8 {\n+        match self {\n+            Sv2Message::CoinbaseOutputDataSize(_) => MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE,\n+            Sv2Message::NewTemplate(_) => MESSAGE_TYPE_NEW_TEMPLATE,\n+            Sv2Message::RequestTransactionData(_) => MESSAGE_TYPE_REQUEST_TRANSACTION_DATA,\n+            Sv2Message::RequestTransactionDataError(_) => {\n+                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR\n+            }\n+            Sv2Message::RequestTransactionDataSuccess(_) => {\n+                MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS\n+            }\n+            Sv2Message::SetNewPrevHash(_) => MESSAGE_TYPE_SET_NEW_PREV_HASH,\n+            Sv2Message::SubmitSolution(_) => MESSAGE_TYPE_SUBMIT_SOLUTION,\n+            Sv2Message::ChannelEndpointChanged(_) => MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES,\n+            Sv2Message::SetupConnection(_) => MESSAGE_TYPE_SETUP_CONNECTION,\n+            Sv2Message::SetupConnectionError(_) => MESSAGE_TYPE_SETUP_CONNECTION_ERROR,\n+            Sv2Message::SetupConnectionSuccess(_) => MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS,\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub enum CSv2Message {\n+    CoinbaseOutputDataSize(CoinbaseOutputDataSize),\n+    NewTemplate(CNewTemplate),\n+    RequestTransactionData(RequestTransactionData),\n+    RequestTransactionDataError(CRequestTransactionDataError),\n+    RequestTransactionDataSuccess(CRequestTransactionDataSuccess),\n+    SetNewPrevHash(CSetNewPrevHash),\n+    SubmitSolution(CSubmitSolution),\n+    ChannelEndpointChanged(ChannelEndpointChanged),\n+    SetupConnection(CSetupConnection),\n+    SetupConnectionError(CSetupConnectionError),\n+    SetupConnectionSuccess(SetupConnectionSuccess),\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn drop_sv2_message(s: CSv2Message) {\n+    match s {\n+        CSv2Message::CoinbaseOutputDataSize(_) => (),\n+        CSv2Message::NewTemplate(a) => drop(a),\n+        CSv2Message::RequestTransactionData(a) => drop(a),\n+        CSv2Message::RequestTransactionDataError(a) => drop(a),\n+        CSv2Message::RequestTransactionDataSuccess(a) => drop(a),\n+        CSv2Message::SetNewPrevHash(a) => drop(a),\n+        CSv2Message::SubmitSolution(a) => drop(a),\n+        CSv2Message::ChannelEndpointChanged(_) => (),\n+        CSv2Message::SetupConnection(_) => (),\n+        CSv2Message::SetupConnectionError(a) => drop(a),\n+        CSv2Message::SetupConnectionSuccess(a) => drop(a),\n+    }\n+}\n+\n+impl<'a> From<Sv2Message<'a>> for CSv2Message {\n+    fn from(v: Sv2Message<'a>) -> Self {\n+        match v {\n+            Sv2Message::CoinbaseOutputDataSize(a) => Self::CoinbaseOutputDataSize(a),\n+            Sv2Message::NewTemplate(a) => Self::NewTemplate(a.into()),\n+            Sv2Message::RequestTransactionData(a) => Self::RequestTransactionData(a),\n+            Sv2Message::RequestTransactionDataError(a) => {\n+                Self::RequestTransactionDataError(a.into())\n+            }\n+            Sv2Message::RequestTransactionDataSuccess(a) => {\n+                Self::RequestTransactionDataSuccess(a.into())\n+            }\n+            Sv2Message::SetNewPrevHash(a) => Self::SetNewPrevHash(a.into()),\n+            Sv2Message::SubmitSolution(a) => Self::SubmitSolution(a.into()),\n+            Sv2Message::ChannelEndpointChanged(a) => Self::ChannelEndpointChanged(a),\n+            Sv2Message::SetupConnection(a) => Self::SetupConnection(a.into()),\n+            Sv2Message::SetupConnectionError(a) => Self::SetupConnectionError(a.into()),\n+            Sv2Message::SetupConnectionSuccess(a) => Self::SetupConnectionSuccess(a),\n+        }\n+    }\n+}\n+\n+impl<'a> CSv2Message {\n+    #[cfg(not(feature = \"with_serde\"))]\n+    pub fn to_rust_rep_mut(&'a mut self) -> Result<Sv2Message<'a>, Error> {\n+        match self {\n+            //CSv2Message::CoinbaseOutputDataSize(v) => {Ok(Sv2Message::CoinbaseOutputDataSize(*v))}\n+            CSv2Message::NewTemplate(v) => Ok(Sv2Message::NewTemplate(v.to_rust_rep_mut()?)),\n+            //CSv2Message::RequestTransactionData(v) => {Ok(Sv2Message::RequestTransactionData(*v))}\n+            //CSv2Message::RequestTransactionDataError(mut v) => {Ok(Sv2Message::RequestTransactionDataError(v.to_rust_rep_mut()?))}\n+            //CSv2Message::RequestTransactionDataSuccess(mut v) => {Ok(Sv2Message::RequestTransactionDataSuccess(v.to_rust_rep_mut()?))}\n+            CSv2Message::SetNewPrevHash(v) => Ok(Sv2Message::SetNewPrevHash(v.to_rust_rep_mut()?)),\n+            CSv2Message::SubmitSolution(v) => Ok(Sv2Message::SubmitSolution(v.to_rust_rep_mut()?)),\n+            //CSv2Message::ChannelEndpointChanged(v) => {Ok(Sv2Message::ChannelEndpointChanged(*v))}\n+            CSv2Message::SetupConnection(v) => {\n+                Ok(Sv2Message::SetupConnection(v.to_rust_rep_mut()?))\n+            }\n+            CSv2Message::SetupConnectionError(v) => {\n+                Ok(Sv2Message::SetupConnectionError(v.to_rust_rep_mut()?))\n+            }\n+            //CSv2Message::SetupConnectionSuccess(v) => {Ok(Sv2Message::SetupConnectionSuccess(*v))}\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n+impl<'decoder> From<Sv2Message<'decoder>> for EncodableField<'decoder> {\n+    fn from(m: Sv2Message<'decoder>) -> Self {\n+        match m {\n+            Sv2Message::CoinbaseOutputDataSize(a) => a.into(),\n+            Sv2Message::NewTemplate(a) => a.into(),\n+            Sv2Message::RequestTransactionData(a) => a.into(),\n+            Sv2Message::RequestTransactionDataError(a) => a.into(),\n+            Sv2Message::RequestTransactionDataSuccess(a) => a.into(),\n+            Sv2Message::SetNewPrevHash(a) => a.into(),\n+            Sv2Message::SubmitSolution(a) => a.into(),\n+            Sv2Message::ChannelEndpointChanged(a) => a.into(),\n+            Sv2Message::SetupConnection(a) => a.into(),\n+            Sv2Message::SetupConnectionError(a) => a.into(),\n+            Sv2Message::SetupConnectionSuccess(a) => a.into(),\n+        }\n+    }\n+}\n+\n+impl binary_sv2::GetSize for Sv2Message<'_> {\n+    fn get_size(&self) -> usize {\n+        match self {\n+            Sv2Message::CoinbaseOutputDataSize(a) => a.get_size(),\n+            Sv2Message::NewTemplate(a) => a.get_size(),\n+            Sv2Message::RequestTransactionData(a) => a.get_size(),\n+            Sv2Message::RequestTransactionDataError(a) => a.get_size(),\n+            Sv2Message::RequestTransactionDataSuccess(a) => a.get_size(),\n+            Sv2Message::SetNewPrevHash(a) => a.get_size(),\n+            Sv2Message::SubmitSolution(a) => a.get_size(),\n+            Sv2Message::ChannelEndpointChanged(a) => a.get_size(),\n+            Sv2Message::SetupConnection(a) => a.get_size(),\n+            Sv2Message::SetupConnectionError(a) => a.get_size(),\n+            Sv2Message::SetupConnectionSuccess(a) => a.get_size(),\n+        }\n+    }\n+}\n+\n+impl<'decoder> Deserialize<'decoder> for Sv2Message<'decoder> {\n+    fn get_structure(_v: &[u8]) -> std::result::Result<Vec<FieldMarker>, binary_sv2::Error> {\n+        unimplemented!()\n+    }\n+    fn from_decoded_fields(\n+        _v: Vec<DecodableField<'decoder>>,\n+    ) -> std::result::Result<Self, binary_sv2::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a> TryFrom<(u8, &'a mut [u8])> for Sv2Message<'a> {\n+    type Error = Error;\n+\n+    fn try_from(v: (u8, &'a mut [u8])) -> Result<Self, Self::Error> {\n+        let msg_type = v.0;\n+        match msg_type {\n+            MESSAGE_TYPE_SETUP_CONNECTION => {\n+                let message: SetupConnection<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnection(message))\n+            }\n+            MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS => {\n+                let message: SetupConnectionSuccess = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnectionSuccess(message))\n+            }\n+            MESSAGE_TYPE_SETUP_CONNECTION_ERROR => {\n+                let message: SetupConnectionError<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetupConnectionError(message))\n+            }\n+            MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES => {\n+                let message: ChannelEndpointChanged = from_bytes(v.1)?;\n+                Ok(Sv2Message::ChannelEndpointChanged(message))\n+            }\n+            MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE => {\n+                let message: CoinbaseOutputDataSize = from_bytes(v.1)?;\n+                Ok(Sv2Message::CoinbaseOutputDataSize(message))\n+            }\n+            MESSAGE_TYPE_NEW_TEMPLATE => {\n+                let message: NewTemplate<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::NewTemplate(message))\n+            }\n+            MESSAGE_TYPE_SET_NEW_PREV_HASH => {\n+                let message: SetNewPrevHash<'a> = from_bytes(v.1)?;\n+                Ok(Sv2Message::SetNewPrevHash(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA => {\n+                let message: RequestTransactionData = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionData(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS => {\n+                let message: RequestTransactionDataSuccess = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionDataSuccess(message))\n+            }\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR => {\n+                let message: RequestTransactionDataError = from_bytes(v.1)?;\n+                Ok(Sv2Message::RequestTransactionDataError(message))\n+            }\n+            MESSAGE_TYPE_SUBMIT_SOLUTION => {\n+                let message: SubmitSolution = from_bytes(v.1)?;\n+                Ok(Sv2Message::SubmitSolution(message))\n+            }\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub enum CResult<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+\n+#[repr(C)]\n+pub enum Sv2Error {\n+    MissingBytes,\n+    EncoderBusy,\n+    Todo,\n+    Unknown,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn is_ok(cresult: &CResult<CSv2Message, Sv2Error>) -> bool {\n+    match cresult {\n+        CResult::Ok(_) => true,\n+        CResult::Err(_) => false,\n+    }\n+}\n+\n+impl<T, E> From<Result<T, E>> for CResult<T, E> {\n+    fn from(v: Result<T, E>) -> Self {\n+        match v {\n+            Ok(v) => Self::Ok(v),\n+            Err(e) => Self::Err(e),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct EncoderWrapper {\n+    encoder: Encoder<Sv2Message<'static>>,\n+    free: bool,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn new_encoder() -> *mut EncoderWrapper {\n+    let encoder: Encoder<Sv2Message<'static>> = Encoder::new();\n+    let s = Box::new(EncoderWrapper {\n+        encoder,\n+        free: true,\n+    });\n+    Box::into_raw(s)\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn free_encoder(encoder: *mut EncoderWrapper) {\n+    let mut encoder = unsafe { Box::from_raw(encoder) };\n+    encoder.free = true;\n+    Box::into_raw(encoder);\n+}\n+\n+fn encode_(message: &'static mut CSv2Message, encoder: &mut EncoderWrapper) -> Result<CVec, Error> {\n+    let message: Sv2Message = message.to_rust_rep_mut()?;\n+    let m_type = message.message_type();\n+    let frame = StandardSv2Frame::<Sv2Message<'static>>::from_message(message, m_type, 0)\n+        .ok_or(Error::Todo)?;\n+    encoder\n+        .encoder\n+        .encode(frame)\n+        .map_err(|_| Error::Todo)\n+        .map(|x| x.into())\n+}\n+\n+/// # Safety\n+///\n+/// TODO\n+#[no_mangle]\n+pub unsafe extern \"C\" fn encode(\n+    message: &'static mut CSv2Message,\n+    encoder: *mut EncoderWrapper,\n+) -> CResult<CVec, Sv2Error> {\n+    let mut encoder = Box::from_raw(encoder);\n+    if encoder.free {\n+        let result = encode_(message, &mut encoder)\n+            .map_err(|_| Sv2Error::Todo)\n+            .into();\n+        encoder.free = false;\n+        Box::into_raw(encoder);\n+        result\n+    } else {\n+        CResult::Err(Sv2Error::EncoderBusy)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct DecoderWrapper(StandardDecoder<Sv2Message<'static>>);\n+\n+#[no_mangle]\n+pub extern \"C\" fn new_decoder() -> *mut DecoderWrapper {\n+    let s = Box::new(DecoderWrapper(StandardDecoder::new()));\n+    Box::into_raw(s)\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn get_writable(decoder: *mut DecoderWrapper) -> CVec {\n+    let mut decoder = unsafe { Box::from_raw(decoder) };\n+    let writable = decoder.0.writable();\n+    let res = CVec::as_shared_buffer(writable);\n+    Box::into_raw(decoder);\n+    res\n+}\n+\n+#[no_mangle]\n+#[allow(clippy::not_unsafe_ptr_arg_deref)]\n+pub extern \"C\" fn next_frame(decoder: *mut DecoderWrapper) -> CResult<CSv2Message, Sv2Error> {\n+    let mut decoder = unsafe { Box::from_raw(decoder) };\n+\n+    match decoder.0.next_frame() {\n+        Ok(mut f) => {\n+            let msg_type = f.get_header().unwrap().msg_type();\n+            let payload = f.payload();\n+            let len = payload.len();\n+            let ptr = payload.as_mut_ptr();\n+            let payload = unsafe { std::slice::from_raw_parts_mut(ptr, len) };\n+            Box::into_raw(decoder);\n+            (msg_type, payload)\n+                .try_into()\n+                .map(|x: Sv2Message| x.into())\n+                .map_err(|_| Sv2Error::Unknown)\n+                .into()\n+        }\n+        Err(_) => {\n+            Box::into_raw(decoder);\n+            CResult::Err(Sv2Error::MissingBytes)\n+        }\n+    }\n+}\n+#[cfg(test)]\n+#[cfg(feature = \"prop_test\")]\n+mod tests {\n+    use super::*;\n+    use core::convert::TryInto;\n+    use quickcheck::{Arbitrary, Gen};\n+    use quickcheck_macros;\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomCoinbaseOutputDataSize(pub CoinbaseOutputDataSize);\n+\n+    impl Arbitrary for RandomCoinbaseOutputDataSize {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomCoinbaseOutputDataSize(CoinbaseOutputDataSize::from_gen(g))\n+        }\n+    }\n+\n+    fn get_setup_connection() -> SetupConnection<'static> {\n+        get_setup_connection_w_params(\n+            common_messages_sv2::Protocol::TemplateDistributionProtocol,\n+            2,\n+            2,\n+            0,\n+            \"0.0.0.0\".to_string(),\n+            8081,\n+            \"Bitmain\".to_string(),\n+            \"901\".to_string(),\n+            \"abcX\".to_string(),\n+            \"89567\".to_string(),\n+        )\n+    }\n+\n+    fn get_setup_connection_w_params(\n+        protocol: common_messages_sv2::Protocol,\n+        min_version: u16,\n+        max_version: u16,\n+        flags: u32,\n+        endpoint_host: String,\n+        endpoint_port: u16,\n+        vendor: String,\n+        hardware_version: String,\n+        firmware: String,\n+        device_id: String,\n+    ) -> SetupConnection<'static> {\n+        SetupConnection {\n+            protocol,\n+            min_version,\n+            max_version,\n+            flags,\n+            endpoint_host: endpoint_host.into_bytes().try_into().unwrap(),\n+            endpoint_port,\n+            vendor: vendor.into_bytes().try_into().unwrap(),\n+            hardware_version: hardware_version.into_bytes().try_into().unwrap(),\n+            firmware: firmware.into_bytes().try_into().unwrap(),\n+            device_id: device_id.into_bytes().try_into().unwrap(),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_message_type_cb_output_data_size() {\n+        let expect = MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE;\n+        let cb_output_data_size = CoinbaseOutputDataSize {\n+            coinbase_output_max_additional_size: 0,\n+        };\n+        let sv2_message = Sv2Message::CoinbaseOutputDataSize(cb_output_data_size);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_new_template() {\n+        let expect = MESSAGE_TYPE_NEW_TEMPLATE;\n+        let new_template = NewTemplate {\n+            template_id: 0,\n+            future_template: false,\n+            version: 0x01000000,\n+            coinbase_tx_version: 0x01000000,\n+            coinbase_prefix: \"0\".to_string().into_bytes().try_into().unwrap(),\n+            coinbase_tx_input_sequence: 0xffffffff,\n+            coinbase_tx_value_remaining: 0x00f2052a,\n+            coinbase_tx_outputs_count: 1,\n+            coinbase_tx_outputs: \"0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac\"\n+                .to_string()\n+                .into_bytes()\n+                .try_into()\n+                .unwrap(),\n+                coinbase_tx_locktime: 0x00000000,\n+                merkle_path: binary_sv2::Seq0255::new(Vec::<binary_sv2::U256>::new()).unwrap(),\n+\n+        };\n+        let sv2_message = Sv2Message::NewTemplate(new_template);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_request_transaction_data() {\n+        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA;\n+        let request_tx_data = RequestTransactionData { template_id: 0 };\n+        let sv2_message = Sv2Message::RequestTransactionData(request_tx_data);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_request_transaction_data_error() {\n+        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR;\n+        let request_tx_data_err = RequestTransactionDataError {\n+            template_id: 0,\n+            error_code: \"an error code\".to_string().into_bytes().try_into().unwrap(),\n+        };\n+        let sv2_message = Sv2Message::RequestTransactionDataError(request_tx_data_err);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_request_transaction_data_success() {\n+        let expect = MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS;\n+\n+        let request_tx_data_success = RequestTransactionDataSuccess {\n+            template_id: 0,\n+            excess_data: \"some_excess_data\"\n+                .to_string()\n+                .into_bytes()\n+                .try_into()\n+                .unwrap(),\n+            transaction_list: binary_sv2::Seq064K::new(Vec::new()).unwrap(),\n+        };\n+        let sv2_message = Sv2Message::RequestTransactionDataSuccess(request_tx_data_success);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_set_new_prev_hash() {\n+        let expect = MESSAGE_TYPE_SET_NEW_PREV_HASH;\n+\n+        let mut u256 = [0_u8; 32];\n+        let u256_prev_hash: binary_sv2::U256 = (&mut u256[..]).try_into().unwrap();\n+\n+        let mut u256 = [0_u8; 32];\n+        let u256_target: binary_sv2::U256 = (&mut u256[..]).try_into().unwrap();\n+\n+        let set_new_prev_hash = SetNewPrevHash {\n+            template_id: 0,\n+            prev_hash: u256_prev_hash,\n+            header_timestamp: 0x29ab5f49,\n+            n_bits: 0xffff001d,\n+            target: u256_target,\n+        };\n+        let sv2_message = Sv2Message::SetNewPrevHash(set_new_prev_hash);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_submit_solution() {\n+        let expect = MESSAGE_TYPE_SUBMIT_SOLUTION;\n+\n+        let submit_solution = SubmitSolution {\n+            template_id: 0,\n+            version: 0x01000000,\n+            header_timestamp: 0x29ab5f49,\n+            header_nonce: 0x1dac2b7c,\n+            coinbase_tx: \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\"\n+                .to_string()\n+                .into_bytes()\n+                .try_into()\n+                .unwrap(),\n+        };\n+\n+        let sv2_message = Sv2Message::SubmitSolution(submit_solution);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_channel_endpoint_changed() {\n+        let expect = MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES;\n+\n+        let channel_endpoint_changed = ChannelEndpointChanged { channel_id: 0 };\n+\n+        let sv2_message = Sv2Message::ChannelEndpointChanged(channel_endpoint_changed);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_setup_connection() {\n+        let expect = MESSAGE_TYPE_SETUP_CONNECTION;\n+\n+        let setup_connection = get_setup_connection();\n+\n+        let sv2_message = Sv2Message::SetupConnection(setup_connection);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_setup_connection_error() {\n+        let expect = MESSAGE_TYPE_SETUP_CONNECTION_ERROR;\n+\n+        let setup_connection_err = SetupConnectionError {\n+            flags: 0,\n+            error_code: \"an error code\".to_string().into_bytes().try_into().unwrap(),\n+        };\n+\n+        let sv2_message = Sv2Message::SetupConnectionError(setup_connection_err);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    fn test_message_type_setup_connection_success() {\n+        let expect = MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS;\n+\n+        let setup_connection_success = SetupConnectionSuccess {\n+            used_version: 1,\n+            flags: 0,\n+        };\n+\n+        let sv2_message = Sv2Message::SetupConnectionSuccess(setup_connection_success);\n+        let actual = sv2_message.message_type();\n+\n+        assert_eq!(expect, actual);\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn test_next_frame() {\n+        let decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+        println!(\"DECODER: {:?}\", &decoder);\n+        println!(\"DECODER 2: {:?}\", &decoder);\n+        let mut decoder_wrapper = DecoderWrapper(decoder);\n+        let _res = next_frame(&mut decoder_wrapper);\n+    }\n+\n+    // RR\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_coinbase_output_data_size(message: RandomCoinbaseOutputDataSize) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<CoinbaseOutputDataSize>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE, 0)\n+                .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::CoinbaseOutputDataSize(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomNewTemplate(pub NewTemplate<'static>);\n+    impl Arbitrary for RandomNewTemplate {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomNewTemplate(NewTemplate::from_gen(g))\n+        }\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_new_template_id(message: RandomNewTemplate) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<NewTemplate>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        // Create frame\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_NEW_TEMPLATE, 0).unwrap();\n+        // Encode frame\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        // Decode encoded frame\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        // Puts decoder in the next state (next 6 bytes). If frame is incomplete, returns an error\n+        // prompting to add more bytes to decode the frame\n+        // Required between two writes because of how this is intended to use the decoder in a loop\n+        // read from a stream.\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        // Decoded frame, complete frame is filled\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        // Extract payload of the frame which is the NewTemplate message\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::NewTemplate(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomRequestTransactionData(pub RequestTransactionData);\n+    impl Arbitrary for RandomRequestTransactionData {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomRequestTransactionData(RequestTransactionData::from_gen(g))\n+        }\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_request_transaction_data(message: RandomRequestTransactionData) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<RequestTransactionData>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_REQUEST_TRANSACTION_DATA, 0)\n+                .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::RequestTransactionData(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomRequestTransactionDataError(pub RequestTransactionDataError<'static>);\n+\n+    impl Arbitrary for RandomRequestTransactionDataError {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomRequestTransactionDataError(RequestTransactionDataError::from_gen(g))\n+        }\n+    }\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_request_transaction_data_error(\n+        message: RandomRequestTransactionDataError,\n+    ) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<RequestTransactionDataError>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame = StandardSv2Frame::from_message(\n+            message.0,\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR,\n+            0,\n+        )\n+        .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::RequestTransactionDataError(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomRequestTransactionDataSuccess(pub RequestTransactionDataSuccess<'static>);\n+\n+    impl Arbitrary for RandomRequestTransactionDataSuccess {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomRequestTransactionDataSuccess(RequestTransactionDataSuccess::from_gen(g))\n+        }\n+    }\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_request_transaction_data_success(\n+        message: RandomRequestTransactionDataSuccess,\n+    ) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<RequestTransactionDataSuccess>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame = StandardSv2Frame::from_message(\n+            message.0,\n+            MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS,\n+            0,\n+        )\n+        .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::RequestTransactionDataSuccess(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomSetNewPrevHash(pub SetNewPrevHash<'static>);\n+\n+    impl Arbitrary for RandomSetNewPrevHash {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomSetNewPrevHash(SetNewPrevHash::from_gen(g))\n+        }\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_set_new_prev_hash(message: RandomSetNewPrevHash) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<SetNewPrevHash>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_SET_NEW_PREV_HASH, 0).unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::SetNewPrevHash(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomSubmitSolution(pub SubmitSolution<'static>);\n+\n+    impl Arbitrary for RandomSubmitSolution {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomSubmitSolution(SubmitSolution::from_gen(g))\n+        }\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_submit_solution(message: RandomSubmitSolution) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<SubmitSolution>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_SUBMIT_SOLUTION, 0).unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::SubmitSolution(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomSetupConnection(pub SetupConnection<'static>);\n+\n+    impl Arbitrary for RandomSetupConnection {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomSetupConnection(SetupConnection::from_gen(g))\n+        }\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomChannelEndpointChanged(pub ChannelEndpointChanged);\n+\n+    impl Arbitrary for RandomChannelEndpointChanged {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomChannelEndpointChanged(ChannelEndpointChanged::from_gen(g))\n+        }\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_channel_endpoint_changed(message: RandomChannelEndpointChanged) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<ChannelEndpointChanged>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES, 0)\n+                .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::ChannelEndpointChanged(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_setup_connection(message: RandomSetupConnection) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<SetupConnection>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_SETUP_CONNECTION, 0).unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::SetupConnection(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message == expected\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomSetupConnectionError(pub SetupConnectionError<'static>);\n+\n+    impl Arbitrary for RandomSetupConnectionError {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomSetupConnectionError(SetupConnectionError::from_gen(g))\n+        }\n+    }\n+\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_setup_connection_error(message: RandomSetupConnectionError) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<SetupConnectionError>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_SETUP_CONNECTION_ERROR, 0)\n+                .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::SetupConnectionError(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message.flags == expected.flags\n+    }\n+\n+    #[derive(Clone, Debug)]\n+    pub struct RandomSetupConnectionSuccess(pub SetupConnectionSuccess);\n+\n+    #[cfg(feature = \"prop_test\")]\n+    impl Arbitrary for RandomSetupConnectionSuccess {\n+        fn arbitrary(g: &mut Gen) -> Self {\n+            RandomSetupConnectionSuccess(SetupConnectionSuccess::from_gen(g))\n+        }\n+    }\n+    #[quickcheck_macros::quickcheck]\n+    fn encode_with_c_setup_connection_success(message: RandomSetupConnectionSuccess) -> bool {\n+        let expected = message.clone().0;\n+\n+        let mut encoder = Encoder::<SetupConnectionSuccess>::new();\n+        let mut decoder = StandardDecoder::<Sv2Message<'static>>::new();\n+\n+        let frame =\n+            StandardSv2Frame::from_message(message.0, MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS, 0)\n+                .unwrap();\n+        let encoded_frame = encoder.encode(frame).unwrap();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i]\n+        }\n+        let _ = decoder.next_frame();\n+\n+        let buffer = decoder.writable();\n+        for i in 0..buffer.len() {\n+            buffer[i] = encoded_frame[i + 6]\n+        }\n+\n+        let mut decoded = decoder.next_frame().unwrap();\n+\n+        let msg_type = decoded.get_header().unwrap().msg_type();\n+        let payload = decoded.payload();\n+        let decoded_message: Sv2Message = (msg_type, payload).try_into().unwrap();\n+        let decoded_message = match decoded_message {\n+            Sv2Message::SetupConnectionSuccess(m) => m,\n+            _ => panic!(),\n+        };\n+\n+        decoded_message.flags == expected.flags\n+    }\n+}"
      },
      {
        "sha": "8488175819f01121df832f55c0de7e880eb2261b",
        "filename": "src/rusty/protocols/v2/sv2-ffi/sv2.h",
        "status": "added",
        "additions": 389,
        "deletions": 0,
        "changes": 389,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/sv2-ffi/sv2.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70d314fff39127f98c3f0aafd4213ea0fab194ac/src/rusty/protocols/v2/sv2-ffi/sv2.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/protocols/v2/sv2-ffi/sv2.h?ref=70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "patch": "@@ -0,0 +1,389 @@\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+static const uintptr_t SV2_FRAME_HEADER_SIZE = 6;\n+\n+static const uintptr_t SV2_FRAME_HEADER_LEN_OFFSET = 3;\n+\n+static const uintptr_t SV2_FRAME_HEADER_LEN_END = 3;\n+\n+static const uintptr_t NOISE_FRAME_HEADER_SIZE = 2;\n+\n+static const uintptr_t NOISE_FRAME_HEADER_LEN_OFFSET = 0;\n+\n+static const uintptr_t NOISE_FRAME_HEADER_LEN_END = 2;\n+\n+static const uintptr_t SNOW_PSKLEN = 32;\n+\n+static const uintptr_t SNOW_TAGLEN = 16;\n+\n+static const uint8_t SV2_MINING_PROTOCOL_DISCRIMINANT = 0;\n+\n+static const uint8_t SV2_JOB_NEG_PROTOCOL_DISCRIMINANT = 1;\n+\n+static const uint8_t SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT = 2;\n+\n+static const uint8_t SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT = 3;\n+\n+static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION = 0;\n+\n+static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION_SUCCESS = 1;\n+\n+static const uint8_t MESSAGE_TYPE_SETUP_CONNECTION_ERROR = 2;\n+\n+static const uint8_t MESSAGE_TYPE_CHANNEL_ENDPOINT_CHANGES = 3;\n+\n+static const uint8_t MESSAGE_TYPE_COINBASE_OUTPUT_DATA_SIZE = 70;\n+\n+static const uint8_t MESSAGE_TYPE_NEW_TEMPLATE = 71;\n+\n+static const uint8_t MESSAGE_TYPE_SET_NEW_PREV_HASH = 72;\n+\n+static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA = 73;\n+\n+static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_SUCCESS = 74;\n+\n+static const uint8_t MESSAGE_TYPE_REQUEST_TRANSACTION_DATA_ERROR = 75;\n+\n+static const uint8_t MESSAGE_TYPE_SUBMIT_SOLUTION = 76;\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+struct CVec {\n+  uint8_t *data;\n+  uintptr_t len;\n+  uintptr_t capacity;\n+};\n+\n+struct U24 {\n+  uint32_t _0;\n+};\n+\n+struct CVec2 {\n+  CVec *data;\n+  uintptr_t len;\n+  uintptr_t capacity;\n+};\n+\n+extern \"C\" {\n+\n+/// Given a C allocated buffer return a rust allocated CVec\n+///\n+/// # Safety\n+///\n+/// TODO\n+CVec cvec_from_buffer(const uint8_t *data, uintptr_t len);\n+\n+void _c_export_u24(U24 _a);\n+\n+void _c_export_cvec(CVec _a);\n+\n+void _c_export_cvec2(CVec2 _a);\n+\n+} // extern \"C\"\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+/// MiningProtocol = [`SV2_MINING_PROTOCOL_DISCRIMINANT`],\n+/// JobNegotiationProtocol = [`SV2_JOB_NEG_PROTOCOL_DISCRIMINANT`],\n+/// TemplateDistributionProtocol = [`SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT`],\n+/// JobDistributionProtocol = [`SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT`],\n+enum class Protocol : uint8_t {\n+  MiningProtocol = SV2_MINING_PROTOCOL_DISCRIMINANT,\n+  JobNegotiationProtocol = SV2_JOB_NEG_PROTOCOL_DISCRIMINANT,\n+  TemplateDistributionProtocol = SV2_TEMPLATE_DISTR_PROTOCOL_DISCRIMINANT,\n+  JobDistributionProtocol = SV2_JOB_DISTR_PROTOCOL_DISCRIMINANT,\n+};\n+\n+/// ## ChannelEndpointChanged (Server -> Client)\n+/// When a channel\u2019s upstream or downstream endpoint changes and that channel had previously\n+/// sent messages with [channel_msg](TODO) bitset of unknown extension_type, the intermediate proxy\n+/// MUST send a [`ChannelEndpointChanged`] message. Upon receipt thereof, any extension state\n+/// (including version negotiation and the presence of support for a given extension) MUST be\n+/// reset and version/presence negotiation must begin again.\n+///\n+struct ChannelEndpointChanged {\n+  /// The channel which has changed endpoint.\n+  uint32_t channel_id;\n+};\n+\n+/// ## SetupConnection.Success (Server -> Client)\n+/// Response to [`SetupConnection`] message if the server accepts the connection. The client is\n+/// required to verify the set of feature flags that the server supports and act accordingly.\n+struct SetupConnectionSuccess {\n+  /// Selected version proposed by the connecting node that the upstream\n+  /// node supports. This version will be used on the connection for the rest\n+  /// of its life.\n+  uint16_t used_version;\n+  /// Flags indicating optional protocol features the server supports. Each\n+  /// protocol from [`Protocol`] field has its own values/flags.\n+  uint32_t flags;\n+};\n+\n+struct CSetupConnection {\n+  Protocol protocol;\n+  uint16_t min_version;\n+  uint16_t max_version;\n+  uint32_t flags;\n+  CVec endpoint_host;\n+  uint16_t endpoint_port;\n+  CVec vendor;\n+  CVec hardware_version;\n+  CVec firmware;\n+  CVec device_id;\n+};\n+\n+struct CSetupConnectionError {\n+  uint32_t flags;\n+  CVec error_code;\n+};\n+\n+extern \"C\" {\n+\n+void _c_export_channel_endpoint_changed(ChannelEndpointChanged _a);\n+\n+void _c_export_setup_conn_succ(SetupConnectionSuccess _a);\n+\n+void free_setup_connection(CSetupConnection s);\n+\n+void free_setup_connection_error(CSetupConnectionError s);\n+\n+} // extern \"C\"\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+/// ## CoinbaseOutputDataSize (Client -> Server)\n+/// Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and\n+/// other uses, and thus the Template Provider will need to consider this additional block size\n+/// when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\n+/// Thus, this message is used to indicate that some additional space in the block/coinbase\n+/// transaction be reserved for the pool\u2019s use (while always assuming the pool will use the entirety\n+/// of available coinbase space).\n+/// The Job Negotiator MUST discover the maximum serialized size of the additional outputs which\n+/// will be added by the pool(s) it intends to use this work. It then MUST communicate the\n+/// maximum such size to the Template Provider via this message. The Template Provider MUST\n+/// NOT provide NewWork messages which would represent consensus-invalid blocks once this\n+/// additional size \u2014 along with a maximally-sized (100 byte) coinbase field \u2014 is added. Further,\n+/// the Template Provider MUST consider the maximum additional bytes required in the output\n+/// count variable-length integer in the coinbase transaction when complying with the size limits.\n+struct CoinbaseOutputDataSize {\n+  /// The maximum additional serialized bytes which the pool will add in\n+  /// coinbase transaction outputs.\n+  uint32_t coinbase_output_max_additional_size;\n+};\n+\n+/// ## RequestTransactionData (Client -> Server)\n+/// A request sent by the Job Negotiator to the Template Provider which requests the set of\n+/// transaction data for all transactions (excluding the coinbase transaction) included in a block, as\n+/// well as any additional data which may be required by the Pool to validate the work.\n+struct RequestTransactionData {\n+  /// The template_id corresponding to a NewTemplate message.\n+  uint64_t template_id;\n+};\n+\n+struct CNewTemplate {\n+  uint64_t template_id;\n+  bool future_template;\n+  uint32_t version;\n+  uint32_t coinbase_tx_version;\n+  CVec coinbase_prefix;\n+  uint32_t coinbase_tx_input_sequence;\n+  uint64_t coinbase_tx_value_remaining;\n+  uint32_t coinbase_tx_outputs_count;\n+  CVec coinbase_tx_outputs;\n+  uint32_t coinbase_tx_locktime;\n+  CVec2 merkle_path;\n+};\n+\n+struct CRequestTransactionDataSuccess {\n+  uint64_t template_id;\n+  CVec excess_data;\n+  CVec2 transaction_list;\n+};\n+\n+struct CRequestTransactionDataError {\n+  uint64_t template_id;\n+  CVec error_code;\n+};\n+\n+struct CSetNewPrevHash {\n+  uint64_t template_id;\n+  CVec prev_hash;\n+  uint32_t header_timestamp;\n+  uint32_t n_bits;\n+  CVec target;\n+};\n+\n+struct CSubmitSolution {\n+  uint64_t template_id;\n+  uint32_t version;\n+  uint32_t header_timestamp;\n+  uint32_t header_nonce;\n+  CVec coinbase_tx;\n+};\n+\n+extern \"C\" {\n+\n+void _c_export_coinbase_out(CoinbaseOutputDataSize _a);\n+\n+void _c_export_req_tx_data(RequestTransactionData _a);\n+\n+void free_new_template(CNewTemplate s);\n+\n+void free_request_tx_data_success(CRequestTransactionDataSuccess s);\n+\n+void free_request_tx_data_error(CRequestTransactionDataError s);\n+\n+void free_set_new_prev_hash(CSetNewPrevHash s);\n+\n+void free_submit_solution(CSubmitSolution s);\n+\n+} // extern \"C\"\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <ostream>\n+#include <new>\n+\n+enum class Sv2Error {\n+  MissingBytes,\n+  EncoderBusy,\n+  Todo,\n+  Unknown,\n+};\n+\n+struct DecoderWrapper;\n+\n+struct EncoderWrapper;\n+\n+struct CSv2Message {\n+  enum class Tag {\n+    CoinbaseOutputDataSize,\n+    NewTemplate,\n+    RequestTransactionData,\n+    RequestTransactionDataError,\n+    RequestTransactionDataSuccess,\n+    SetNewPrevHash,\n+    SubmitSolution,\n+    ChannelEndpointChanged,\n+    SetupConnection,\n+    SetupConnectionError,\n+    SetupConnectionSuccess,\n+  };\n+\n+  struct CoinbaseOutputDataSize_Body {\n+    CoinbaseOutputDataSize _0;\n+  };\n+\n+  struct NewTemplate_Body {\n+    CNewTemplate _0;\n+  };\n+\n+  struct RequestTransactionData_Body {\n+    RequestTransactionData _0;\n+  };\n+\n+  struct RequestTransactionDataError_Body {\n+    CRequestTransactionDataError _0;\n+  };\n+\n+  struct RequestTransactionDataSuccess_Body {\n+    CRequestTransactionDataSuccess _0;\n+  };\n+\n+  struct SetNewPrevHash_Body {\n+    CSetNewPrevHash _0;\n+  };\n+\n+  struct SubmitSolution_Body {\n+    CSubmitSolution _0;\n+  };\n+\n+  struct ChannelEndpointChanged_Body {\n+    ChannelEndpointChanged _0;\n+  };\n+\n+  struct SetupConnection_Body {\n+    CSetupConnection _0;\n+  };\n+\n+  struct SetupConnectionError_Body {\n+    CSetupConnectionError _0;\n+  };\n+\n+  struct SetupConnectionSuccess_Body {\n+    SetupConnectionSuccess _0;\n+  };\n+\n+  Tag tag;\n+  union {\n+    CoinbaseOutputDataSize_Body coinbase_output_data_size;\n+    NewTemplate_Body new_template;\n+    RequestTransactionData_Body request_transaction_data;\n+    RequestTransactionDataError_Body request_transaction_data_error;\n+    RequestTransactionDataSuccess_Body request_transaction_data_success;\n+    SetNewPrevHash_Body set_new_prev_hash;\n+    SubmitSolution_Body submit_solution;\n+    ChannelEndpointChanged_Body channel_endpoint_changed;\n+    SetupConnection_Body setup_connection;\n+    SetupConnectionError_Body setup_connection_error;\n+    SetupConnectionSuccess_Body setup_connection_success;\n+  };\n+};\n+\n+template<typename T, typename E>\n+struct CResult {\n+  enum class Tag {\n+    Ok,\n+    Err,\n+  };\n+\n+  struct Ok_Body {\n+    T _0;\n+  };\n+\n+  struct Err_Body {\n+    E _0;\n+  };\n+\n+  Tag tag;\n+  union {\n+    Ok_Body ok;\n+    Err_Body err;\n+  };\n+};\n+\n+extern \"C\" {\n+\n+void drop_sv2_message(CSv2Message s);\n+\n+bool is_ok(const CResult<CSv2Message, Sv2Error> *cresult);\n+\n+EncoderWrapper *new_encoder();\n+\n+void free_encoder(EncoderWrapper *encoder);\n+\n+/// # Safety\n+///\n+/// TODO\n+CResult<CVec, Sv2Error> encode(CSv2Message *message, EncoderWrapper *encoder);\n+\n+DecoderWrapper *new_decoder();\n+\n+CVec get_writable(DecoderWrapper *decoder);\n+\n+CResult<CSv2Message, Sv2Error> next_frame(DecoderWrapper *decoder);\n+\n+} // extern \"C\""
      }
    ]
  },
  {
    "sha": "b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
    "node_id": "C_kwDOABII59oAKGI2ZGZmNGRlNDNjM2FiYzg1YjVhMjRhNjc4ZmQ0M2QxYjYzMWFlNmY",
    "commit": {
      "author": {
        "name": "RJ Rybarczyk",
        "email": "rj@rybar.tech",
        "date": "2021-09-21T18:46:48Z"
      },
      "committer": {
        "name": "RJ Rybarczyk",
        "email": "rj@rybar.tech",
        "date": "2021-09-21T22:21:34Z"
      },
      "message": "Update guix builds to reflect src/rusty directory structure",
      "tree": {
        "sha": "301752d549a12475ce34bf52c8316ada820b64b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/301752d549a12475ce34bf52c8316ada820b64b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/comments",
    "author": {
      "login": "rrybarczyk",
      "id": 29670338,
      "node_id": "MDQ6VXNlcjI5NjcwMzM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/29670338?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rrybarczyk",
      "html_url": "https://github.com/rrybarczyk",
      "followers_url": "https://api.github.com/users/rrybarczyk/followers",
      "following_url": "https://api.github.com/users/rrybarczyk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rrybarczyk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rrybarczyk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rrybarczyk/subscriptions",
      "organizations_url": "https://api.github.com/users/rrybarczyk/orgs",
      "repos_url": "https://api.github.com/users/rrybarczyk/repos",
      "events_url": "https://api.github.com/users/rrybarczyk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rrybarczyk/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rrybarczyk",
      "id": 29670338,
      "node_id": "MDQ6VXNlcjI5NjcwMzM4",
      "avatar_url": "https://avatars.githubusercontent.com/u/29670338?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rrybarczyk",
      "html_url": "https://github.com/rrybarczyk",
      "followers_url": "https://api.github.com/users/rrybarczyk/followers",
      "following_url": "https://api.github.com/users/rrybarczyk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rrybarczyk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rrybarczyk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rrybarczyk/subscriptions",
      "organizations_url": "https://api.github.com/users/rrybarczyk/orgs",
      "repos_url": "https://api.github.com/users/rrybarczyk/repos",
      "events_url": "https://api.github.com/users/rrybarczyk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rrybarczyk/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70d314fff39127f98c3f0aafd4213ea0fab194ac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/70d314fff39127f98c3f0aafd4213ea0fab194ac"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 2,
      "deletions": 4
    },
    "files": [
      {
        "sha": "dd7229b6fa6dc61dd882c218671db85074580bfa",
        "filename": "contrib/guix/guix-build",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/contrib/guix/guix-build",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/contrib/guix/guix-build",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-build?ref=b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
        "patch": "@@ -1,5 +1,4 @@\n #!/usr/bin/env bash\n-\n export LC_ALL=C\n set -e -o pipefail\n "
      },
      {
        "sha": "8aa33baf286d6bf9c728e5e7bfeb77b44309e389",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
        "patch": "@@ -4,11 +4,10 @@ set -e -o pipefail\n export TZ=UTC\n \n # Build rust library\n-ls /bitcoin/rust-build\n-/bitcoin/rust-build/rust-build-script.sh /bitcoin/src/rusty /bitcoin/rust-build\n+/bitcoin/rust-build/rust-build-script.sh /bitcoin/src/rusty/protocols/v2/ /bitcoin/rust-build\n \n SV2_FFI_LIB=/bitcoin/rust-build\n-SV2_FFI_HEADER=/bitcoin/src/rusty/sv2-ffi/\n+SV2_FFI_HEADER=/bitcoin/src/rusty/protocols/v2/sv2-ffi/\n \n # Although Guix _does_ set umask when building its own packages (in our case,\n # this is all packages in manifest.scm), it does not set it for `guix"
      }
    ]
  },
  {
    "sha": "100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
    "node_id": "C_kwDOABII59oAKDEwMGVlZWY2YWQyNzNlYWJmNzhjMWNhOTIxZGE0YmZlYTNlMmJjMGI",
    "commit": {
      "author": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-10-06T15:47:41Z"
      },
      "committer": {
        "name": "fi3",
        "email": "email@email.org",
        "date": "2021-10-07T15:12:44Z"
      },
      "message": "Update build system\n\nIt conditionally compile the Template Provider logic into core if:\n* the system that compile core has rustc at least at version 0.51\n* configure is called `enable-template-provider`\n\nTemplate Provider is optional, with default to no, so no rustc is required to compile core.\nWhen compiled with guix the Template Provider is compiled in. As guix do support rustc.",
      "tree": {
        "sha": "6cd1209f4a9d644463375b25cb6b18b93c4eabc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6cd1209f4a9d644463375b25cb6b18b93c4eabc4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/comments",
    "author": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "UnidenifiedUser",
      "id": 70348531,
      "node_id": "MDQ6VXNlcjcwMzQ4NTMx",
      "avatar_url": "https://avatars.githubusercontent.com/u/70348531?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/UnidenifiedUser",
      "html_url": "https://github.com/UnidenifiedUser",
      "followers_url": "https://api.github.com/users/UnidenifiedUser/followers",
      "following_url": "https://api.github.com/users/UnidenifiedUser/following{/other_user}",
      "gists_url": "https://api.github.com/users/UnidenifiedUser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/UnidenifiedUser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/UnidenifiedUser/subscriptions",
      "organizations_url": "https://api.github.com/users/UnidenifiedUser/orgs",
      "repos_url": "https://api.github.com/users/UnidenifiedUser/repos",
      "events_url": "https://api.github.com/users/UnidenifiedUser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/UnidenifiedUser/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f"
      }
    ],
    "stats": {
      "total": 676,
      "additions": 450,
      "deletions": 226
    },
    "files": [
      {
        "sha": "ffb4997e8b146e1e40f5da58fee4f4150290f4a4",
        "filename": "build-aux/m4/ax_compare_version.m4",
        "status": "added",
        "additions": 177,
        "deletions": 0,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/build-aux/m4/ax_compare_version.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/build-aux/m4/ax_compare_version.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_compare_version.m4?ref=100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
        "patch": "@@ -0,0 +1,177 @@\n+# ===========================================================================\n+#    https://www.gnu.org/software/autoconf-archive/ax_compare_version.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_COMPARE_VERSION(VERSION_A, OP, VERSION_B, [ACTION-IF-TRUE], [ACTION-IF-FALSE])\n+#\n+# DESCRIPTION\n+#\n+#   This macro compares two version strings. Due to the various number of\n+#   minor-version numbers that can exist, and the fact that string\n+#   comparisons are not compatible with numeric comparisons, this is not\n+#   necessarily trivial to do in a autoconf script. This macro makes doing\n+#   these comparisons easy.\n+#\n+#   The six basic comparisons are available, as well as checking equality\n+#   limited to a certain number of minor-version levels.\n+#\n+#   The operator OP determines what type of comparison to do, and can be one\n+#   of:\n+#\n+#    eq  - equal (test A == B)\n+#    ne  - not equal (test A != B)\n+#    le  - less than or equal (test A <= B)\n+#    ge  - greater than or equal (test A >= B)\n+#    lt  - less than (test A < B)\n+#    gt  - greater than (test A > B)\n+#\n+#   Additionally, the eq and ne operator can have a number after it to limit\n+#   the test to that number of minor versions.\n+#\n+#    eq0 - equal up to the length of the shorter version\n+#    ne0 - not equal up to the length of the shorter version\n+#    eqN - equal up to N sub-version levels\n+#    neN - not equal up to N sub-version levels\n+#\n+#   When the condition is true, shell commands ACTION-IF-TRUE are run,\n+#   otherwise shell commands ACTION-IF-FALSE are run. The environment\n+#   variable 'ax_compare_version' is always set to either 'true' or 'false'\n+#   as well.\n+#\n+#   Examples:\n+#\n+#     AX_COMPARE_VERSION([3.15.7],[lt],[3.15.8])\n+#     AX_COMPARE_VERSION([3.15],[lt],[3.15.8])\n+#\n+#   would both be true.\n+#\n+#     AX_COMPARE_VERSION([3.15.7],[eq],[3.15.8])\n+#     AX_COMPARE_VERSION([3.15],[gt],[3.15.8])\n+#\n+#   would both be false.\n+#\n+#     AX_COMPARE_VERSION([3.15.7],[eq2],[3.15.8])\n+#\n+#   would be true because it is only comparing two minor versions.\n+#\n+#     AX_COMPARE_VERSION([3.15.7],[eq0],[3.15])\n+#\n+#   would be true because it is only comparing the lesser number of minor\n+#   versions of the two values.\n+#\n+#   Note: The characters that separate the version numbers do not matter. An\n+#   empty string is the same as version 0. OP is evaluated by autoconf, not\n+#   configure, so must be a string, not a variable.\n+#\n+#   The author would like to acknowledge Guido Draheim whose advice about\n+#   the m4_case and m4_ifvaln functions make this macro only include the\n+#   portions necessary to perform the specific comparison specified by the\n+#   OP argument in the final configure script.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Tim Toolan <toolan@ele.uri.edu>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 13\n+\n+dnl #########################################################################\n+AC_DEFUN([AX_COMPARE_VERSION], [\n+  AC_REQUIRE([AC_PROG_AWK])\n+\n+  # Used to indicate true or false condition\n+  ax_compare_version=false\n+\n+  # Convert the two version strings to be compared into a format that\n+  # allows a simple string comparison.  The end result is that a version\n+  # string of the form 1.12.5-r617 will be converted to the form\n+  # 0001001200050617.  In other words, each number is zero padded to four\n+  # digits, and non digits are removed.\n+  AS_VAR_PUSHDEF([A],[ax_compare_version_A])\n+  A=`echo \"$1\" | sed -e 's/\\([[0-9]]*\\)/Z\\1Z/g' \\\n+                     -e 's/Z\\([[0-9]]\\)Z/Z0\\1Z/g' \\\n+                     -e 's/Z\\([[0-9]][[0-9]]\\)Z/Z0\\1Z/g' \\\n+                     -e 's/Z\\([[0-9]][[0-9]][[0-9]]\\)Z/Z0\\1Z/g' \\\n+                     -e 's/[[^0-9]]//g'`\n+\n+  AS_VAR_PUSHDEF([B],[ax_compare_version_B])\n+  B=`echo \"$3\" | sed -e 's/\\([[0-9]]*\\)/Z\\1Z/g' \\\n+                     -e 's/Z\\([[0-9]]\\)Z/Z0\\1Z/g' \\\n+                     -e 's/Z\\([[0-9]][[0-9]]\\)Z/Z0\\1Z/g' \\\n+                     -e 's/Z\\([[0-9]][[0-9]][[0-9]]\\)Z/Z0\\1Z/g' \\\n+                     -e 's/[[^0-9]]//g'`\n+\n+  dnl # In the case of le, ge, lt, and gt, the strings are sorted as necessary\n+  dnl # then the first line is used to determine if the condition is true.\n+  dnl # The sed right after the echo is to remove any indented white space.\n+  m4_case(m4_tolower($2),\n+  [lt],[\n+    ax_compare_version=`echo \"x$A\n+x$B\" | sed 's/^ *//' | sort -r | sed \"s/x${A}/false/;s/x${B}/true/;1q\"`\n+  ],\n+  [gt],[\n+    ax_compare_version=`echo \"x$A\n+x$B\" | sed 's/^ *//' | sort | sed \"s/x${A}/false/;s/x${B}/true/;1q\"`\n+  ],\n+  [le],[\n+    ax_compare_version=`echo \"x$A\n+x$B\" | sed 's/^ *//' | sort | sed \"s/x${A}/true/;s/x${B}/false/;1q\"`\n+  ],\n+  [ge],[\n+    ax_compare_version=`echo \"x$A\n+x$B\" | sed 's/^ *//' | sort -r | sed \"s/x${A}/true/;s/x${B}/false/;1q\"`\n+  ],[\n+    dnl Split the operator from the subversion count if present.\n+    m4_bmatch(m4_substr($2,2),\n+    [0],[\n+      # A count of zero means use the length of the shorter version.\n+      # Determine the number of characters in A and B.\n+      ax_compare_version_len_A=`echo \"$A\" | $AWK '{print(length)}'`\n+      ax_compare_version_len_B=`echo \"$B\" | $AWK '{print(length)}'`\n+\n+      # Set A to no more than B's length and B to no more than A's length.\n+      A=`echo \"$A\" | sed \"s/\\(.\\{$ax_compare_version_len_B\\}\\).*/\\1/\"`\n+      B=`echo \"$B\" | sed \"s/\\(.\\{$ax_compare_version_len_A\\}\\).*/\\1/\"`\n+    ],\n+    [[0-9]+],[\n+      # A count greater than zero means use only that many subversions\n+      A=`echo \"$A\" | sed \"s/\\(\\([[0-9]]\\{4\\}\\)\\{m4_substr($2,2)\\}\\).*/\\1/\"`\n+      B=`echo \"$B\" | sed \"s/\\(\\([[0-9]]\\{4\\}\\)\\{m4_substr($2,2)\\}\\).*/\\1/\"`\n+    ],\n+    [.+],[\n+      AC_WARNING(\n+        [invalid OP numeric parameter: $2])\n+    ],[])\n+\n+    # Pad zeros at end of numbers to make same length.\n+    ax_compare_version_tmp_A=\"$A`echo $B | sed 's/./0/g'`\"\n+    B=\"$B`echo $A | sed 's/./0/g'`\"\n+    A=\"$ax_compare_version_tmp_A\"\n+\n+    # Check for equality or inequality as necessary.\n+    m4_case(m4_tolower(m4_substr($2,0,2)),\n+    [eq],[\n+      test \"x$A\" = \"x$B\" && ax_compare_version=true\n+    ],\n+    [ne],[\n+      test \"x$A\" != \"x$B\" && ax_compare_version=true\n+    ],[\n+      AC_WARNING([invalid OP parameter: $2])\n+    ])\n+  ])\n+\n+  AS_VAR_POPDEF([A])dnl\n+  AS_VAR_POPDEF([B])dnl\n+\n+  dnl # Execute ACTION-IF-TRUE / ACTION-IF-FALSE.\n+  if test \"$ax_compare_version\" = \"true\" ; then\n+    m4_ifvaln([$4],[$4],[:])dnl\n+    m4_ifvaln([$5],[else $5])dnl\n+  fi\n+]) dnl AX_COMPARE_VERSION"
      },
      {
        "sha": "3f4097fdc95c772a0f1b860a3601cc739a42ece1",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
        "patch": "@@ -326,6 +326,40 @@ AC_ARG_ENABLE([external-signer],\n \n AC_LANG_PUSH([C++])\n \n+dnl Set RUSTC to yes if rustc is present and rustc version is at least 1.51\n+AC_CHECK_PROG([RUSTC], rustc, checking, no)\n+RUSTC_MIN_VERSION=1.51.0\n+AS_IF([test $RUSTC = checking], \n+      dnl rustc --version return `rustc [verison] [hash]` split it at withe space and get the second\n+      dnl value (version)\n+      RUSTC_VERSION=m4_argn(2, m4_unquote(m4_split(esyscmd([rustc --version]), [[ ]+])))\n+      AX_COMPARE_VERSION([${RUSTC_VERSION}],[ge],[${RUSTC_MIN_VERSION}],\n+                         [\n+                           AC_MSG_RESULT(found rustc)\n+                           RUSTC=yes\n+                         ],\n+                         [\n+                           AC_MSG_RESULT(rustc version is too old required version is ${RUSTC_MIN_VERSION})\n+                           RUSTC=no\n+                         ]\n+                         )\n+      )\n+\n+AC_ARG_ENABLE([template-provider],\n+    [AS_HELP_STRING([--enable-template-provider],[compile template provider (default is no, requires rustc)])],\n+    [AS_IF([test ${RUSTC} = yes],\n+            [\n+                AC_DEFINE([ENABLE_TMEPLATE_PROVIDER],[1],[Define if TP should be compiled in])\n+                LDFLAGS=\"$LDFLAGS -lpthread -ldl\"\n+                add_template_provider=$enableval\n+            ],\n+            AC_MSG_ERROR(enable-template-provider set but rustc ${RUSTC_MIN_VERSION} or later is not avaiable)\n+\n+    )],\n+    [add_template_provider=no])\n+\n+\n+\n dnl Check for a flag to turn compiler warnings into errors. This is helpful for checks which may\n dnl appear to succeed because by default they merely emit warnings when they fail.\n dnl\n@@ -1803,6 +1837,7 @@ AM_CONDITIONAL([USE_ASM],[test x$use_asm = xyes])\n AM_CONDITIONAL([WORDS_BIGENDIAN],[test x$ac_cv_c_bigendian = xyes])\n AM_CONDITIONAL([USE_NATPMP],[test x$use_natpmp = xyes])\n AM_CONDITIONAL([USE_UPNP],[test x$use_upnp = xyes])\n+AM_CONDITIONAL([ENABLE_TMEPLATE_PROVIDER],[test x$add_template_provider = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1876,6 +1911,7 @@ AC_SUBST(HAVE_MM_PREFETCH)\n AC_SUBST(HAVE_STRONG_GETAUXVAL)\n AC_SUBST(HAVE_WEAK_GETAUXVAL)\n AC_SUBST(ANDROID_ARCH)\n+AC_SUBST(ENABLE_TMEPLATE_PROVIDER)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])"
      },
      {
        "sha": "d0c49583fca28f9acc53311821e9c2743e967222",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
        "patch": "@@ -3,12 +3,6 @@ export LC_ALL=C\n set -e -o pipefail\n export TZ=UTC\n \n-# Build rust library\n-/bitcoin/rust-build/rust-build-script.sh /bitcoin/src/rusty/protocols/v2/ /bitcoin/rust-build\n-\n-SV2_FFI_LIB=/bitcoin/rust-build\n-SV2_FFI_HEADER=/bitcoin/src/rusty/protocols/v2/sv2-ffi/\n-\n # Although Guix _does_ set umask when building its own packages (in our case,\n # this is all packages in manifest.scm), it does not set it for `guix\n # environment`. It does make sense for at least `guix environment --container`\n@@ -243,7 +237,7 @@ mkdir -p \"$OUTDIR\"\n ###########################\n \n # CONFIGFLAGS\n-CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary\"\n+CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary --enable-template-provider\"\n case \"$HOST\" in\n     *linux*) CONFIGFLAGS+=\" --disable-threadlocal\" ;;\n esac\n@@ -258,7 +252,7 @@ esac\n \n # CXXFLAGS\n HOST_CXXFLAGS=\"$HOST_CFLAGS\"\n-HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -I ${SV2_FFI_HEADER} ${SV2_FFI_LIB}/libsv2_ffi.a -lpthread -ldl\"\n+HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -lpthread -ldl\"\n \n case \"$HOST\" in\n     arm-linux-gnueabihf) HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -Wno-psabi\" ;;"
      },
      {
        "sha": "35139926113e56e3f4bbd712a7e1f2e7747aced7",
        "filename": "rust-build/rust-build-script.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 163,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/rust-build/rust-build-script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6dff4de43c3abc85b5a24a678fd43d1b631ae6f/rust-build/rust-build-script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/rust-build/rust-build-script.sh?ref=b6dff4de43c3abc85b5a24a678fd43d1b631ae6f",
        "patch": "@@ -1,163 +0,0 @@\n-#! /bin/sh\n-\n-ROOT=$1\n-OUT_DIR=$2\n-\n-DEPS=\"./deps\"\n-\n-rm -rf $DEPS\n-\n-mkdir $DEPS\n-\n-rustc \\\n-        --crate-name binary_codec_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/binary-sv2/no-serde-sv2/codec/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C embed-bitcode=no \\\n-        -C debug-assertions=off \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS\n-\n-rustc \\\n-        --crate-name binary_codec_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/binary-sv2/no-serde-sv2/codec/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi,artifacts \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS\n-\n-rustc \\\n-        --crate-name const_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/const-sv2/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi,artifacts \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS\n-\n-rustc \\\n-        --crate-name derive_codec_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi \\\n-        --crate-type proc-macro \\\n-        --emit=dep-info,link \\\n-        -C prefer-dynamic \\\n-        -C embed-bitcode=no \\\n-        -C debug-assertions=off \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS \\\n-        --extern binary_codec_sv2=$DEPS/libbinary_codec_sv2.rlib \\\n-        --extern proc_macro\n-\n-rustc \\\n-        --crate-name binary_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/binary-sv2/binary-sv2/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi,artifacts \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --cfg 'feature=\"binary_codec_sv2\"' \\\n-        --cfg 'feature=\"core\"' \\\n-        --cfg 'feature=\"default\"' \\\n-        --cfg 'feature=\"derive_codec_sv2\"' \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS \\\n-        --extern binary_codec_sv2=$DEPS/libbinary_codec_sv2.rmeta \\\n-        --extern derive_codec_sv2=$DEPS/libderive_codec_sv2.so\n-\n-rustc \\\n-        --crate-name framing_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/framing-sv2/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi,artifacts \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS \\\n-        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n-        --extern const_sv2=$DEPS/libconst_sv2.rmeta\n-\n-rustc \\\n-        --crate-name common_messages_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/subprotocols/common-messages/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS \\\n-        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n-        --extern const_sv2=$DEPS/libconst_sv2.rmeta\n-\n-rustc \\\n-        --crate-name template_distribution_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/subprotocols/template-distribution/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS \\\n-        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n-        --extern const_sv2=$DEPS/libconst_sv2.rmeta\n-\n-rustc \\\n-        --crate-name codec_sv2 \\\n-        --edition=2018 \\\n-        $ROOT/codec-sv2/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi \\\n-        --crate-type lib \\\n-        --emit=dep-info,metadata,link \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $DEPS \\\n-        -L dependency=$DEPS \\\n-        --extern binary_sv2=$DEPS/libbinary_sv2.rmeta \\\n-        --extern const_sv2=$DEPS/libconst_sv2.rmeta \\\n-        --extern framing_sv2=$DEPS/libframing_sv2.rmeta\n-\n-rustc \\\n-        --crate-name sv2_ffi \\\n-        --edition=2018 \\\n-        $ROOT/sv2-ffi/src/lib.rs \\\n-        --error-format=json \\\n-        --json=diagnostic-rendered-ansi \\\n-        --crate-type staticlib \\\n-        -C opt-level=3 \\\n-        -C embed-bitcode=no \\\n-        --out-dir $OUT_DIR  \\\n-        -L dependency=$DEPS \\\n-        --extern binary_sv2=$DEPS/libbinary_sv2.rlib \\\n-        --extern codec_sv2=$DEPS/libcodec_sv2.rlib \\\n-        --extern common_messages_sv2=$DEPS/libcommon_messages_sv2.rlib \\\n-        --extern const_sv2=$DEPS/libconst_sv2.rlib \\\n-        --extern template_distribution_sv2=$DEPS/libtemplate_distribution_sv2.rlib\n-"
      },
      {
        "sha": "66b23523f946fa0df8584c2eb677c08ffc336237",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
        "patch": "@@ -884,3 +884,7 @@ endif\n if ENABLE_QT_TESTS\n include Makefile.qttest.include\n endif\n+\n+if ENABLE_TMEPLATE_PROVIDER\n+include Makefile.template_provider.include\n+endif"
      },
      {
        "sha": "67f84367845e11202ff63a188a56a94b84ddc575",
        "filename": "src/Makefile.template_provider.include",
        "status": "added",
        "additions": 159,
        "deletions": 0,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/src/Makefile.template_provider.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/src/Makefile.template_provider.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.template_provider.include?ref=100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
        "patch": "@@ -0,0 +1,159 @@\n+ROOT=$(abs_srcdir)/rusty/protocols/v2\n+TP_OUT_DIR=$(abs_top_builddir)/rust-build\n+LIB_SV2_FFI=$(TP_OUT_DIR)/libsv2_ffi.a\n+\n+LDFLAGS += $(LIB_SV2_FFI)\n+\n+all-recursive: build-sv2 $(all-recursive)  \n+\n+DEPS=$(TP_OUT_DIR)/deps\n+\n+\n+build-sv2:\n+\t${MAKE} clean-start\n+\t${MAKE} build-sv2-deps\n+\t${MAKE} build-sv2-ffi\n+\t${MAKE} clean-end\n+\n+# CLEAN TEMPORARY DEPENDECY DIRECTORY\n+clean-start:\n+\techo $(LDFLAGS)\n+\t@rm -rf $(DEPS)\n+\t@mkdir $(DEPS)\n+\n+# It build the sv2_ffi dependecy with rustc, the libs are build in the temporary directory\n+# ./rust-build/deps (--out-dir) that is cleaned at the and of the process.\n+#\n+#  Most iomportant flag are:\n+# --crate-type lib (it say to build a rust library)\n+# -C opt-level=3 use all the optimization\n+build-sv2-deps:\n+\t@rustc \\\n+        --crate-name binary_codec_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/binary-sv2/no-serde-sv2/codec/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS)\n+\n+\t@rustc \\\n+        --crate-name const_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/const-sv2/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS)\n+\n+\t@rustc \\\n+        --crate-name derive_codec_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/binary-sv2/no-serde-sv2/derive_codec/src/lib.rs \\\n+        --crate-type proc-macro \\\n+        --emit=dep-info,link \\\n+        -C prefer-dynamic \\\n+        -C embed-bitcode=no \\\n+        -C debug-assertions=off \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_codec_sv2=$(DEPS)/libbinary_codec_sv2.rlib \\\n+        --extern proc_macro\n+\n+\t@rustc \\\n+        --crate-name binary_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/binary-sv2/binary-sv2/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --cfg 'feature=\"binary_codec_sv2\"' \\\n+        --cfg 'feature=\"core\"' \\\n+        --cfg 'feature=\"default\"' \\\n+        --cfg 'feature=\"derive_codec_sv2\"' \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_codec_sv2=$(DEPS)/libbinary_codec_sv2.rmeta \\\n+        --extern derive_codec_sv2=$(DEPS)/libderive_codec_sv2.so\n+\n+\t@rustc \\\n+        --crate-name framing_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/framing-sv2/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_sv2=$(DEPS)/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$(DEPS)/libconst_sv2.rmeta\n+\n+\t@rustc \\\n+        --crate-name common_messages_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/subprotocols/common-messages/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_sv2=$(DEPS)/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$(DEPS)/libconst_sv2.rmeta\n+\n+\t@rustc \\\n+        --crate-name template_distribution_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/subprotocols/template-distribution/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_sv2=$(DEPS)/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$(DEPS)/libconst_sv2.rmeta\n+\n+\t@rustc \\\n+        --crate-name codec_sv2 \\\n+        --edition=2018 \\\n+        $(ROOT)/codec-sv2/src/lib.rs \\\n+        --crate-type lib \\\n+        --emit=dep-info,metadata,link \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(DEPS) \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_sv2=$(DEPS)/libbinary_sv2.rmeta \\\n+        --extern const_sv2=$(DEPS)/libconst_sv2.rmeta \\\n+        --extern framing_sv2=$(DEPS)/libframing_sv2.rmeta\n+\n+# It build the sv2_ffi library with rustc, as a c static lib\n+#\n+#  Most iomportant flag are:\n+# --crate-type staticlib (build as c staticlib)\n+# -C opt-level=3 use all the optimization\n+build-sv2-ffi:\n+\t@rustc \\\n+        --crate-name sv2_ffi \\\n+        --edition=2018 \\\n+        $(ROOT)/sv2-ffi/src/lib.rs \\\n+        --crate-type staticlib \\\n+        -C opt-level=3 \\\n+        -C embed-bitcode=no \\\n+        --out-dir $(TP_OUT_DIR)  \\\n+        -L dependency=$(DEPS) \\\n+        --extern binary_sv2=$(DEPS)/libbinary_sv2.rlib \\\n+        --extern codec_sv2=$(DEPS)/libcodec_sv2.rlib \\\n+        --extern common_messages_sv2=$(DEPS)/libcommon_messages_sv2.rlib \\\n+        --extern const_sv2=$(DEPS)/libconst_sv2.rlib \\\n+        --extern template_distribution_sv2=$(DEPS)/libtemplate_distribution_sv2.rlib\n+\n+clean-end:\n+\t@rm -rf $(DEPS)"
      },
      {
        "sha": "f2fdd89b0faa9dd7447996a7f7055c11a023244a",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 55,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100eeef6ad273eabf78c1ca921da4bfea3e2bc0b/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=100eeef6ad273eabf78c1ca921da4bfea3e2bc0b",
        "patch": "@@ -247,66 +247,83 @@ static bool AppInit(NodeContext& node, int argc, char* argv[])\n     return fRet;\n }\n \n-#include <sv2.h>\n+\n+#ifdef ENABLE_TMEPLATE_PROVIDER\n+    #include <rusty/protocols/v2/sv2-ffi/sv2.h>\n+    // It uses the sv2_ffi library to build a correct Sv2 message and an incorrect one.\n+    // Then try to encode them, it print ok if the ecoding is possible it print err if not.\n+    void test_template_provider()\n+    {\n+        EncoderWrapper * encoder = new_encoder();\n+    \n+        const char* error = \"connection can not be created\";\n+        uint8_t* error_ = (uint8_t*) error;\n+      \n+        // Build a CSetupConnectionError message\n+        CVec error_code = cvec_from_buffer(error_, strlen(error));\n+        CSetupConnectionError message;\n+        message.flags = 0;\n+        message.error_code = error_code;\n+      \n+        CSv2Message response;\n+        response.tag = CSv2Message::Tag::SetupConnectionError;\n+        response.setup_connection_error._0 = message;\n+      \n+        // Put the message in a Sv2 frame and encode it\n+        CResult<CVec, Sv2Error> encoded = encode(&response, encoder);\n+        switch (encoded.tag) {\n+      \n+        // Print Ok as the message has been encoded without encoutering errors\n+        case CResult < CVec, Sv2Error > ::Tag::Ok:\n+          tfm::format(std::cout, \"Ok \\n\");\n+          break;\n+        case CResult < CVec, Sv2Error > ::Tag::Err:\n+          tfm::format(std::cout, \"Err \\n\");\n+          break;\n+        };\n+    \n+        // Build an incorrect CSetupConnectionError message\n+        CSv2Message response2;\n+        response.tag = CSv2Message::Tag::SetNewPrevHash;\n+        response.setup_connection_error._0 = message;\n+      \n+        // Put the message in a Sv2 frame and try to encode it\n+        CResult<CVec, Sv2Error> encoded2 = encode(&response2, encoder);\n+        switch (encoded2.tag) {\n+      \n+        // Print Err as is not possible to encode incorrect messages\n+        case CResult < CVec, Sv2Error > ::Tag::Ok:\n+          tfm::format(std::cout, \"Ok \\n\");\n+          break;\n+        case CResult < CVec, Sv2Error > ::Tag::Err:\n+          tfm::format(std::cout, \"Err \\n\");\n+          break;\n+        };\n+    };\n+#endif\n \n int main(int argc, char* argv[])\n {\n+#ifdef WIN32\n+    util::WinCmdLineArgs winArgs;\n+    std::tie(argc, argv) = winArgs.get();\n+#endif\n+#ifdef ENABLE_TMEPLATE_PROVIDER\n+    test_template_provider();\n+#else\n \n-    EncoderWrapper * encoder = new_encoder();\n-\n-    const char* error = \"connection can not be created\";\n-    uint8_t* error_ = (uint8_t*) error;\n-  \n-    CVec error_code = cvec_from_buffer(error_, strlen(error));\n-    CSetupConnectionError message;\n-    message.flags = 0;\n-    message.error_code = error_code;\n-  \n-    CSv2Message response;\n-    response.tag = CSv2Message::Tag::SetupConnectionError;\n-    response.setup_connection_error._0 = message;\n-  \n-    CResult<CVec, Sv2Error> encoded = encode(&response, encoder);\n-    switch (encoded.tag) {\n-  \n-    case CResult < CVec, Sv2Error > ::Tag::Ok:\n-      tfm::format(std::cout, \"Ok \\n\");\n-      break;\n-    case CResult < CVec, Sv2Error > ::Tag::Err:\n-      tfm::format(std::cout, \"Err \\n\");\n-      break;\n-    };\n-\n-    CSv2Message response2;\n-    response.tag = CSv2Message::Tag::SetNewPrevHash;\n-    response.setup_connection_error._0 = message;\n-  \n-    CResult<CVec, Sv2Error> encoded2 = encode(&response2, encoder);\n-    switch (encoded2.tag) {\n-  \n-    case CResult < CVec, Sv2Error > ::Tag::Ok:\n-      tfm::format(std::cout, \"Ok \\n\");\n-      break;\n-    case CResult < CVec, Sv2Error > ::Tag::Err:\n-      tfm::format(std::cout, \"Err \\n\");\n-      break;\n-    };\n-//#ifdef WIN32\n-//    util::WinCmdLineArgs winArgs;\n-//    std::tie(argc, argv) = winArgs.get();\n-//#endif\n+    NodeContext node;\n+    int exit_status;\n+    std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node, argc, argv, exit_status);\n+    if (!init) {\n+        return exit_status;\n+    }\n \n-    //NodeContext node;\n-    //int exit_status;\n-    //std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node, argc, argv, exit_status);\n-    //if (!init) {\n-    //    return exit_status;\n-    //}\n+    SetupEnvironment();\n \n-    //SetupEnvironment();\n+    noui_connect();\n \n-    // Connect bitcoind signal handlers\n-    //noui_connect();\n+    return (AppInit(node, argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n+#endif\n \n-    //return (AppInit(node, argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n-}\n+};"
      }
    ]
  }
]