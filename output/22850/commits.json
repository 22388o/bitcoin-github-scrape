[
  {
    "sha": "0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTA3ZTQ4YTNiMDQ5ZWFhMWM3Yjc3OTE4N2U1NmNmN2VhODVlYWQ5",
    "commit": {
      "author": {
        "name": "Sriram",
        "email": "sriramdvt@gmail.com",
        "date": "2021-08-31T13:38:18Z"
      },
      "committer": {
        "name": "Sriram",
        "email": "sriramdvt@gmail.com",
        "date": "2021-08-31T19:28:52Z"
      },
      "message": "Make m_mempool optional in PeerManager\n\n- Make m_mempool a pointer in the initialization of PeerManager\n- Check that m_mempool exists before dereferencing the pointer in PeerManager functions\n- If m_mempool is a nullptr, turn off transaction relay with all peers by setting m_tx_relay to nullptr",
      "tree": {
        "sha": "0aea6f56d79d5037e4a9e704d0ddaef2eda25cbb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0aea6f56d79d5037e4a9e704d0ddaef2eda25cbb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/comments",
    "author": {
      "login": "sriramdvt",
      "id": 41079588,
      "node_id": "MDQ6VXNlcjQxMDc5NTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/41079588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sriramdvt",
      "html_url": "https://github.com/sriramdvt",
      "followers_url": "https://api.github.com/users/sriramdvt/followers",
      "following_url": "https://api.github.com/users/sriramdvt/following{/other_user}",
      "gists_url": "https://api.github.com/users/sriramdvt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sriramdvt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sriramdvt/subscriptions",
      "organizations_url": "https://api.github.com/users/sriramdvt/orgs",
      "repos_url": "https://api.github.com/users/sriramdvt/repos",
      "events_url": "https://api.github.com/users/sriramdvt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sriramdvt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sriramdvt",
      "id": 41079588,
      "node_id": "MDQ6VXNlcjQxMDc5NTg4",
      "avatar_url": "https://avatars.githubusercontent.com/u/41079588?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sriramdvt",
      "html_url": "https://github.com/sriramdvt",
      "followers_url": "https://api.github.com/users/sriramdvt/followers",
      "following_url": "https://api.github.com/users/sriramdvt/following{/other_user}",
      "gists_url": "https://api.github.com/users/sriramdvt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sriramdvt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sriramdvt/subscriptions",
      "organizations_url": "https://api.github.com/users/sriramdvt/orgs",
      "repos_url": "https://api.github.com/users/sriramdvt/repos",
      "events_url": "https://api.github.com/users/sriramdvt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sriramdvt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7be143a960e2bb9ac81144f55c45731c1bb209c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7be143a960e2bb9ac81144f55c45731c1bb209c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7be143a960e2bb9ac81144f55c45731c1bb209c5"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 56,
      "deletions": 37
    },
    "files": [
      {
        "sha": "6291a5e3b1b5aa4ce8adfa8b7da5f2f170b6faa7",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
        "patch": "@@ -1208,7 +1208,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n     assert(!node.peerman);\n     node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),\n-                                     chainman, *node.mempool, ignores_incoming_txs);\n+                                     chainman, node.mempool.get(), ignores_incoming_txs);\n     RegisterValidationInterface(node.peerman.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "fb5a47245f97ef12e589598edd11aebc1cdad327",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 30,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
        "patch": "@@ -293,7 +293,7 @@ class PeerManagerImpl final : public PeerManager\n public:\n     PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n                     BanMan* banman, ChainstateManager& chainman,\n-                    CTxMemPool& pool, bool ignore_incoming_txs);\n+                    CTxMemPool* pool, bool ignore_incoming_txs);\n \n     /** Overridden from CValidationInterface. */\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n@@ -413,7 +413,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n-    CTxMemPool& m_mempool;\n+    CTxMemPool* const m_mempool;\n     TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n \n     /** The height of the best chain */\n@@ -867,7 +867,7 @@ bool PeerManagerImpl::BlockRequested(NodeId nodeid, const CBlockIndex& block, st\n     RemoveBlockRequest(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {&block, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n+            {&block, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n@@ -884,6 +884,9 @@ bool PeerManagerImpl::BlockRequested(NodeId nodeid, const CBlockIndex& block, st\n void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n {\n     AssertLockHeld(cs_main);\n+\n+    if (!m_mempool) return;\n+\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n         // Never ask from peers who can't provide witnesses.\n@@ -1096,6 +1099,10 @@ void PeerManagerImpl::PushNodeVersion(CNode& pnode, int64_t nTime)\n     CService addr_you = addr.IsRoutable() && !IsProxy(addr) && addr.IsAddrV1Compatible() ? addr : CService();\n     uint64_t your_services{addr.nServices};\n \n+    if (!m_mempool) {\n+        pnode.m_tx_relay = nullptr;\n+    }\n+\n     const bool tx_relay = !m_ignore_incoming_txs && pnode.m_tx_relay != nullptr;\n     m_connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, my_services, nTime,\n             your_services, addr_you, // Together the pre-version-31402 serialization of CAddress \"addrYou\" (without nTime)\n@@ -1165,16 +1172,17 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n \n void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler)\n {\n-    std::set<uint256> unbroadcast_txids = m_mempool.GetUnbroadcastTxs();\n+    if (!m_mempool) return;\n+    std::set<uint256> unbroadcast_txids = m_mempool->GetUnbroadcastTxs();\n \n     for (const auto& txid : unbroadcast_txids) {\n-        CTransactionRef tx = m_mempool.get(txid);\n+        CTransactionRef tx = m_mempool->get(txid);\n \n         if (tx != nullptr) {\n             LOCK(cs_main);\n             _RelayTransaction(txid, tx->GetWitnessHash());\n         } else {\n-            m_mempool.RemoveUnbroadcastTx(txid, true);\n+            m_mempool->RemoveUnbroadcastTx(txid, true);\n         }\n     }\n \n@@ -1421,14 +1429,14 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n \n std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n                                                BanMan* banman, ChainstateManager& chainman,\n-                                               CTxMemPool& pool, bool ignore_incoming_txs)\n+                                               CTxMemPool* pool, bool ignore_incoming_txs)\n {\n     return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, chainman, pool, ignore_incoming_txs);\n }\n \n PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n                                  BanMan* banman, ChainstateManager& chainman,\n-                                 CTxMemPool& pool, bool ignore_incoming_txs)\n+                                 CTxMemPool* pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n       m_connman(connman),\n       m_addrman(addrman),\n@@ -1632,6 +1640,8 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n \n bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n {\n+    if (!m_mempool) return false;\n+\n     if (m_chainman.ActiveChain().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n         // If the chain tip has changed previously rejected transactions\n         // might be now valid, e.g. due to a nLockTime'd tx becoming valid,\n@@ -1650,7 +1660,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n         if (m_recent_confirmed_transactions.contains(hash)) return true;\n     }\n \n-    return m_recent_rejects.contains(hash) || m_mempool.exists(gtxid);\n+    return m_recent_rejects.contains(hash) || m_mempool->exists(gtxid);\n }\n \n bool PeerManagerImpl::AlreadyHaveBlock(const uint256& block_hash)\n@@ -1883,7 +1893,9 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n \n CTransactionRef PeerManagerImpl::FindTxForGetData(const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now)\n {\n-    auto txinfo = m_mempool.info(gtxid);\n+    if (!Assume(m_mempool)) return {};\n+\n+    auto txinfo = m_mempool->info(gtxid);\n     if (txinfo.tx) {\n         // If a TX could have been INVed in reply to a MEMPOOL request,\n         // or is older than UNCONDITIONAL_RELAY_DELAY, permit the request\n@@ -1942,12 +1954,12 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n             // WTX and WITNESS_TX imply we serialize with witness\n             int nSendFlags = (inv.IsMsgTx() ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n             m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n-            m_mempool.RemoveUnbroadcastTx(tx->GetHash());\n+            m_mempool->RemoveUnbroadcastTx(tx->GetHash());\n             // As we're going to send tx, make sure its unconfirmed parents are made requestable.\n             std::vector<uint256> parent_ids_to_add;\n             {\n-                LOCK(m_mempool.cs);\n-                auto txiter = m_mempool.GetIter(tx->GetHash());\n+                LOCK(m_mempool->cs);\n+                auto txiter = m_mempool->GetIter(tx->GetHash());\n                 if (txiter) {\n                     const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n                     parent_ids_to_add.reserve(parents.size());\n@@ -2165,7 +2177,11 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                    if (m_mempool\n+                        && nodestate->fSupportsDesiredCmpctVersion\n+                        && vGetData.size() == 1\n+                        && mapBlocksInFlight.size() == 1\n+                        && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n@@ -2221,6 +2237,8 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n  */\n void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n {\n+    if (!Assume(m_mempool)) return;\n+\n     AssertLockHeld(cs_main);\n     AssertLockHeld(g_cs_orphans);\n \n@@ -2231,7 +2249,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         const auto [porphanTx, from_peer] = m_orphanage.GetTx(orphanHash);\n         if (porphanTx == nullptr) continue;\n \n-        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), m_mempool, porphanTx, false /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), *m_mempool, porphanTx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n@@ -2288,7 +2306,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n             break;\n         }\n     }\n-    m_mempool.check(m_chainman.ActiveChainstate());\n+    m_mempool->check(m_chainman.ActiveChainstate());\n }\n \n bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,\n@@ -2913,8 +2931,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // block-relay-only peer\n         bool fBlocksOnly = m_ignore_incoming_txs || (pfrom.m_tx_relay == nullptr);\n \n-        // Allow peers with relay permission to send data other than blocks in blocks only mode\n-        if (pfrom.HasPermission(NetPermissionFlags::Relay)) {\n+        // Allow peers with relay permission to send data other than blocks in blocks only mode, and if\n+        // the mempool exists\n+        if (m_mempool && pfrom.HasPermission(NetPermissionFlags::Relay)) {\n             fBlocksOnly = false;\n         }\n \n@@ -3236,7 +3255,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // Always relay transactions received from peers with forcerelay\n                 // permission, even if they were already in the mempool, allowing\n                 // the node to function as a gateway for nodes hidden behind it.\n-                if (!m_mempool.exists(tx.GetHash())) {\n+                if (!m_mempool->exists(tx.GetHash())) {\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n@@ -3246,11 +3265,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), m_mempool, ptx, false /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_chainman.ActiveChainstate(), *m_mempool, ptx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            m_mempool.check(m_chainman.ActiveChainstate());\n+            m_mempool->check(m_chainman.ActiveChainstate());\n             // As this version of the transaction was acceptable, we can forget about any\n             // requests for it.\n             m_txrequest.ForgetTxHash(tx.GetHash());\n@@ -3263,7 +3282,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n                 pfrom.GetId(),\n                 tx.GetHash().ToString(),\n-                m_mempool.size(), m_mempool.DynamicMemoryUsage() / 1000);\n+                m_mempool->size(), m_mempool->DynamicMemoryUsage() / 1000);\n \n             for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n                 AddToCompactExtraTransactions(removedTx);\n@@ -3396,8 +3415,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n     if (msg_type == NetMsgType::CMPCTBLOCK)\n     {\n-        // Ignore cmpctblock received while importing\n-        if (fImporting || fReindex) {\n+        // Ignore cmpctblock received while importing, or when there is no mempool\n+        if (fImporting || fReindex || !m_mempool) {\n             LogPrint(BCLog::NET, \"Unexpected cmpctblock message received from peer %d\\n\", pfrom.GetId());\n             return;\n         }\n@@ -3498,7 +3517,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n                 if (!BlockRequested(pfrom.GetId(), *pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n-                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n+                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(m_mempool));\n                     else {\n                         // The block was already in flight using compact blocks from the same peer\n                         LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");\n@@ -3541,7 +3560,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // download from.\n                 // Optimistically try to reconstruct anyway since we might be\n                 // able to without any round trips.\n-                PartiallyDownloadedBlock tempBlock(&m_mempool);\n+                PartiallyDownloadedBlock tempBlock(m_mempool);\n                 ReadStatus status = tempBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status != READ_STATUS_OK) {\n                     // TODO: don't ignore failures\n@@ -4416,7 +4435,7 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, std::chrono::microseconds c\n     // peers with the forcerelay permission should not filter txs to us\n     if (pto.HasPermission(NetPermissionFlags::ForceRelay)) return;\n \n-    CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n+    CAmount currentFilter = m_mempool->GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n     static FeeFilterRounder g_filter_rounder{CFeeRate{DEFAULT_MIN_RELAY_TX_FEE}};\n \n     if (m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n@@ -4733,7 +4752,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n                 // Respond to BIP35 mempool requests\n                 if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n-                    auto vtxinfo = m_mempool.infoAll();\n+                    auto vtxinfo = m_mempool->infoAll();\n                     pto->m_tx_relay->fSendMempool = false;\n                     const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n \n@@ -4772,7 +4791,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n-                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, state.m_wtxid_relay);\n+                    CompareInvMempoolOrder compareInvMempoolOrder(m_mempool, state.m_wtxid_relay);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n@@ -4792,7 +4811,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n-                        auto txinfo = m_mempool.info(ToGenTxid(inv));\n+                        auto txinfo = m_mempool->info(ToGenTxid(inv));\n                         if (!txinfo.tx) {\n                             continue;\n                         }"
      },
      {
        "sha": "25eed465790cc1a5c91607bfaf292061b47eee8e",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
        "patch": "@@ -39,7 +39,7 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n public:\n     static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n                                              BanMan* banman, ChainstateManager& chainman,\n-                                             CTxMemPool& pool, bool ignore_incoming_txs);\n+                                             CTxMemPool* pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }\n \n     /** Begin running background tasks, should only be called once */"
      },
      {
        "sha": "f1c4637987d1e02ee3d0a99608603ffc8ce6d807",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
        "patch": "@@ -53,7 +53,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     const CChainParams& chainparams = Params();\n     auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, m_node.mempool.get(), false);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     const CChainParams& chainparams = Params();\n     auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, m_node.mempool.get(), false);\n \n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n     CConnman::Options options;\n@@ -194,7 +194,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     auto banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, m_node.mempool.get(), false);\n \n     CNetAddr tor_netaddr;\n     BOOST_REQUIRE(\n@@ -288,7 +288,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     auto banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, m_node.mempool.get(), false);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "51f74bc55d7736e3ead4579ebc7baab0d6338764",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e07e48a3b049eaa1c7b779187e56cf7ea85ead9/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=0e07e48a3b049eaa1c7b779187e56cf7ea85ead9",
        "patch": "@@ -198,7 +198,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,\n                                        m_node.banman.get(), *m_node.chainman,\n-                                       *m_node.mempool, false);\n+                                       m_node.mempool.get(), false);\n     {\n         CConnman::Options options;\n         options.m_msgproc = m_node.peerman.get();"
      }
    ]
  }
]