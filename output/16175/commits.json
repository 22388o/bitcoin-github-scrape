[
  {
    "sha": "9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmM4Y2E2MWY1YzljYTU3ZWE3MWIzYWNkZDEwMjFhNWNmNjY1MTJm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T00:10:25Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T16:52:58Z"
      },
      "message": "Remove unnecessary cs_mains in denialofservice_tests\n\n9fdf05d70cac4a62d1aeeb4299e2c3a9a866f8af resolved some lock\ninversion warnings in denialofservice_tests, but left in a number\nof cs_main locks that are unnecessary (introducing lock inversion\nwarnings in future changes).",
      "tree": {
        "sha": "4fe761b1c6108705a14e918a1272f07b63472b46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4fe761b1c6108705a14e918a1272f07b63472b46"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f792395d13aa99ce51887db14e4f77a746d910e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f792395d13aa99ce51887db14e4f77a746d910e3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f792395d13aa99ce51887db14e4f77a746d910e3"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 12,
      "deletions": 12
    },
    "files": [
      {
        "sha": "f6ddec9bb495a22a0e146c834911793f6f1d5475",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
        "patch": "@@ -95,11 +95,11 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     // Test starts here\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_vSend);\n+        LOCK(dummyNode1.cs_vSend);\n         BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n         dummyNode1.vSendMsg.clear();\n     }\n@@ -108,17 +108,17 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     // Wait 21 minutes\n     SetMockTime(nStartTime+21*60);\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_vSend);\n+        LOCK(dummyNode1.cs_vSend);\n         BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n     }\n     // Wait 3 more minutes\n     SetMockTime(nStartTime+24*60);\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in disconnect\n     }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n@@ -232,7 +232,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(banman->IsBanned(addr1));\n@@ -249,7 +249,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n-        LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n+        LOCK(dummyNode2.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr2)); // 2 not banned yet...\n@@ -259,7 +259,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n-        LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n+        LOCK(dummyNode2.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n     }\n     BOOST_CHECK(banman->IsBanned(addr2));\n@@ -288,7 +288,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         Misbehaving(dummyNode1.GetId(), 100);\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n@@ -297,7 +297,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         Misbehaving(dummyNode1.GetId(), 10);\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n@@ -306,7 +306,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         Misbehaving(dummyNode1.GetId(), 1);\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(banman->IsBanned(addr1));\n@@ -338,7 +338,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         Misbehaving(dummyNode.GetId(), 100);\n     }\n     {\n-        LOCK2(cs_main, dummyNode.cs_sendProcessing);\n+        LOCK(dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n     BOOST_CHECK(banman->IsBanned(addr));"
      }
    ]
  },
  {
    "sha": "79e6e446dd0c8a3f53759a9792388f28e1053bfb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OWU2ZTQ0NmRkMGM4YTNmNTM3NTlhOTc5MjM4OGYyOGUxMDUzYmZi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-08T14:52:53Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T16:52:58Z"
      },
      "message": "Make ProcessNewBlock return a future instead of an immediate bool\n\nThis prepares for making ProcessNewBlock processing actually happen\nin a separate thread from the caller, even though all callsites\ncurrently block on the return value immediately.\n\nNote that this makes some of the unit tests less restrictive.",
      "tree": {
        "sha": "d25f46b6db2f3289e9da78a2023024e96c072b52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d25f46b6db2f3289e9da78a2023024e96c072b52"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/79e6e446dd0c8a3f53759a9792388f28e1053bfb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79e6e446dd0c8a3f53759a9792388f28e1053bfb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/79e6e446dd0c8a3f53759a9792388f28e1053bfb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79e6e446dd0c8a3f53759a9792388f28e1053bfb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9bc8ca61f5c9ca57ea71b3acdd1021a5cf66512f"
      }
    ],
    "stats": {
      "total": 75,
      "additions": 40,
      "deletions": 35
    },
    "files": [
      {
        "sha": "8eaf14e1f2caca929e642ff39a8313035c22bc7e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -2803,7 +2803,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_main);\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n-            bool fNewBlock = false;\n             // Setting fForceProcessing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n             // unrequested blocks that might be trying to waste our resources\n@@ -2813,7 +2812,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n+            bool fNewBlock = ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true).get();\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2895,14 +2894,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n-            bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n+            bool fNewBlock = ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true).get();\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2963,8 +2961,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n-        bool fNewBlock = false;\n-        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n+        bool fNewBlock = ProcessNewBlock(chainparams, pblock, forceProcessing).get();\n         if (fNewBlock) {\n             pfrom->nLastBlockTime = GetTime();\n         } else {"
      },
      {
        "sha": "7278903e90ed9467f3a9b87f94cd6dfe4a1efca5",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -135,7 +135,8 @@ static UniValue generateBlocks(const CScript& coinbase_script, int nGenerate, ui\n             continue;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n+        ProcessNewBlock(Params(), shared_pblock, true).wait();\n+        if (ChainActive().Tip()->GetBlockHash() != pblock->GetHash())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -745,12 +746,13 @@ static UniValue submitblock(const JSONRPCRequest& request)\n         }\n     }\n \n-    bool new_block;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool accepted = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n+    bool new_block = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true).get();\n     UnregisterValidationInterface(&sc);\n-    if (!new_block && accepted) {\n+    LOCK(cs_main);\n+    const CBlockIndex* pindex = LookupBlockIndex(blockptr->GetHash());\n+    if (!new_block && pindex && pindex->IsValid()) {\n         return \"duplicate\";\n     }\n     if (!sc.found) {"
      },
      {
        "sha": "e6b6e42956bce024fe79ac49901991e3e9ac31e8",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -102,7 +102,7 @@ static bool BuildChain(const CBlockIndex* pindex, const CScript& coinbase_script\n         CBlockHeader header = block->GetBlockHeader();\n \n         CValidationState state;\n-        if (!ProcessNewBlockHeaders({header}, state, Params(), &pindex, nullptr)) {\n+        if (!ProcessNewBlockHeaders({header}, state, Params(), &pindex)) {\n             return false;\n         }\n     }\n@@ -175,7 +175,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     uint256 chainA_last_header = last_header;\n     for (size_t i = 0; i < 2; i++) {\n         const auto& block = chainA[i];\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, true, nullptr));\n+        ProcessNewBlock(Params(), block, true).wait();\n \n         const CBlockIndex* block_index;\n         {\n@@ -191,7 +191,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     uint256 chainB_last_header = last_header;\n     for (size_t i = 0; i < 3; i++) {\n         const auto& block = chainB[i];\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, true, nullptr));\n+        ProcessNewBlock(Params(), block, true).wait();\n \n         const CBlockIndex* block_index;\n         {\n@@ -220,7 +220,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     // Reorg back to chain A.\n      for (size_t i = 2; i < 4; i++) {\n          const auto& block = chainA[i];\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, true, nullptr));\n+         ProcessNewBlock(Params(), block, true).wait();\n      }\n \n      // Check that chain A and B blocks can be retrieved."
      },
      {
        "sha": "2118057b652a6c445f5978d694f2a9176b09bb57",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -247,7 +247,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n             pblock->nNonce = blockinfo[i].nonce;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n+        ProcessNewBlock(chainparams, shared_pblock, true).wait();\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n "
      },
      {
        "sha": "082d420619b812b8df28c467ab9cd811a1771517",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -156,7 +156,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n+    ProcessNewBlock(chainparams, shared_pblock, true).wait();\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "530adaf3b48d7a9f3ad7b6d7fbb94fe73df09150",
        "filename": "src/test/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -68,8 +68,7 @@ CTxIn MineBlock(const CScript& coinbase_scriptPubKey)\n         assert(block->nNonce);\n     }\n \n-    bool processed{ProcessNewBlock(Params(), block, true, nullptr)};\n-    assert(processed);\n+    ProcessNewBlock(Params(), block, true).wait();\n \n     return CTxIn{block->vtx[0]->GetHash(), 0};\n }"
      },
      {
        "sha": "36972094c8dfb46532aec0a94e7536a40442fff3",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -128,7 +128,6 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n         BuildChain(Params().GenesisBlock().GetHash(), 100, 15, 10, 500, blocks);\n     }\n \n-    bool ignored;\n     CValidationState state;\n     std::vector<CBlockHeader> headers;\n     std::transform(blocks.begin(), blocks.end(), std::back_inserter(headers), [](std::shared_ptr<const CBlock> b) { return b->GetBlockHeader(); });\n@@ -137,7 +136,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     BOOST_CHECK(ProcessNewBlockHeaders(headers, state, Params()));\n \n     // Connect the genesis block and drain any outstanding events\n-    BOOST_CHECK(ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored));\n+    ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true).wait();\n     SyncWithValidationInterfaceQueue();\n \n     // subscribe to events (this subscriber will validate event ordering)\n@@ -155,18 +154,16 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     std::vector<std::thread> threads;\n     for (int i = 0; i < 10; i++) {\n         threads.emplace_back([&blocks]() {\n-            bool ignored;\n             FastRandomContext insecure;\n             for (int i = 0; i < 1000; i++) {\n                 auto block = blocks[insecure.randrange(blocks.size() - 1)];\n-                ProcessNewBlock(Params(), block, true, &ignored);\n+                ProcessNewBlock(Params(), block, true);\n             }\n \n             // to make sure that eventually we process the full chain - do it here\n             for (auto block : blocks) {\n                 if (block->vtx.size() == 1) {\n-                    bool processed = ProcessNewBlock(Params(), block, true, &ignored);\n-                    assert(processed);\n+                    ProcessNewBlock(Params(), block, true).wait();\n                 }\n             }\n         });"
      },
      {
        "sha": "10d0268a104646d51cde893d8416098cfe0f8e1a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -3430,13 +3430,16 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     return true;\n }\n \n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool *fNewBlock)\n+std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing)\n {\n     AssertLockNotHeld(cs_main);\n \n+    std::promise<bool> result_promise;\n+    std::future<bool> result = result_promise.get_future();\n+    bool fNewBlock = false;\n+\n     {\n         CBlockIndex *pindex = nullptr;\n-        if (fNewBlock) *fNewBlock = false;\n         CValidationState state;\n \n         // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n@@ -3448,21 +3451,25 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n         bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n         if (ret) {\n             // Store to disk\n-            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n+            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n         }\n         if (!ret) {\n             GetMainSignals().BlockChecked(*pblock, state);\n-            return error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+            error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+            result_promise.set_value(fNewBlock);\n+            return result;\n         }\n     }\n \n+    result_promise.set_value(fNewBlock);\n+\n     NotifyHeaderTip();\n \n     CValidationState state; // Only used to report errors, not invalidity - ignore it\n     if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n-        return error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n+        error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n-    return true;\n+    return result;\n }\n \n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)"
      },
      {
        "sha": "cea413c8de4b8badbb01b73d4eef77fa4537c30f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79e6e446dd0c8a3f53759a9792388f28e1053bfb/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "patch": "@@ -23,6 +23,7 @@\n #include <algorithm>\n #include <atomic>\n #include <exception>\n+#include <future>\n #include <map>\n #include <memory>\n #include <set>\n@@ -208,15 +209,17 @@ static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n  * Note that we guarantee that either the proof-of-work is valid on pblock, or\n  * (and possibly also) BlockChecked will have been called.\n  *\n- * May not be called in a\n- * validationinterface callback.\n+ * May not be called in a validationinterface callback.\n+ *\n+ * Do NOT block on the returned future waiting for it to resolve as this may\n+ * introduce deadlocks (in the case you are holding any mutexes which are\n+ * also taken in validationinterface callbacks).\n  *\n  * @param[in]   pblock  The block we want to process.\n  * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n- * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n- * @return True if state.IsValid()\n+ * @return      A future which complets with a boolean which is set to indicate if the block was first received via this call\n  */\n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock) LOCKS_EXCLUDED(cs_main);\n+std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing) LOCKS_EXCLUDED(cs_main);\n \n /**\n  * Process incoming block headers."
      }
    ]
  },
  {
    "sha": "e89822964e9ef8dadf88d47bc94f5396a8c61a54",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplODk4MjI5NjRlOWVmOGRhZGY4OGQ0N2JjOTRmNTM5NmE4YzYxYTU0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-08T12:47:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T16:52:58Z"
      },
      "message": "Add a new peer state tracking class to reduce cs_main contention.\n\nCNodeState was added for validation-state-tracking, and thus,\nlogically, was protected by cs_main. However, as it has grown to\ninclude non-validation state (taking state from CNode), and as\nwe've reduced cs_main usage for other unrelated things, CNodeState\nis left with lots of cs_main locking in net_processing.\n\nIn order to ease transition to something new, this adds only a\ndummy CPeerState which is held as a reference for the duration of\nmessage processing.\n\nNote that moving things is somewhat tricky pre validation-thread as\na consistent lockorder must be kept - we can't take a lock on the\nnew cs_peerstate in anything that's called directly from\nvalidation.",
      "tree": {
        "sha": "b250340e591fb5bf9a2adaedbd4f18e7fe9526a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b250340e591fb5bf9a2adaedbd4f18e7fe9526a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e89822964e9ef8dadf88d47bc94f5396a8c61a54",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e89822964e9ef8dadf88d47bc94f5396a8c61a54",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e89822964e9ef8dadf88d47bc94f5396a8c61a54",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e89822964e9ef8dadf88d47bc94f5396a8c61a54/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79e6e446dd0c8a3f53759a9792388f28e1053bfb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/79e6e446dd0c8a3f53759a9792388f28e1053bfb"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 44,
      "deletions": 3
    },
    "files": [
      {
        "sha": "982123b56b6da91522aff3b0c4fddf432ea062bf",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 3,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e89822964e9ef8dadf88d47bc94f5396a8c61a54/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e89822964e9ef8dadf88d47bc94f5396a8c61a54/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e89822964e9ef8dadf88d47bc94f5396a8c61a54",
        "patch": "@@ -199,6 +199,17 @@ struct CBlockReject {\n     uint256 hashBlock;\n };\n \n+/**\n+ * Maintain state about nodes, protected by our own lock. Historically we put all\n+ * peer tracking state in CNodeState, however this results in significant cs_main\n+ * contention. Thus, new state tracking should go here, and we should eventually\n+ * move most (non-validation-specific) state here.\n+ */\n+struct CPeerState {\n+    CPeerState() {}\n+};\n+\n+\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -393,7 +404,20 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n+/** Note that this must be locked BEFORE cs_main! */\n+CCriticalSection cs_peerstate;\n+\n /** Map maintaining per-node state. */\n+static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n+\n+static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) LOCKS_EXCLUDED(cs_main) {\n+    std::map<NodeId, CPeerState>::iterator it = mapPeerState.find(pnode);\n+    if (it == mapPeerState.end())\n+        return nullptr;\n+    return &it->second;\n+}\n+\n+/** Map maintaining new per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n@@ -771,12 +795,22 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n         LOCK(cs_main);\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n+    {\n+        LOCK(cs_peerstate);\n+        mapPeerState.emplace_hint(mapPeerState.end(), nodeid, CPeerState{});\n+    }\n+\n     if(!pnode->fInbound)\n         PushNodeVersion(pnode, connman, GetTime());\n }\n \n void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n+\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(nodeid);\n+    assert(peerstate != nullptr);\n+\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -799,13 +833,15 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n     mapNodeState.erase(nodeid);\n+    mapPeerState.erase(nodeid);\n \n     if (mapNodeState.empty()) {\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n         assert(g_outbound_peers_with_protect_from_disconnect == 0);\n+        assert(mapPeerState.empty());\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -1843,7 +1879,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n     }\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n+bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2785,7 +2821,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n+            return ProcessMessage(pfrom, peerstate, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n@@ -3231,6 +3267,8 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(pfrom->GetId());\n     //\n     // Message format\n     //  (4) message start\n@@ -3313,7 +3351,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n+        fRet = ProcessMessage(pfrom, peerstate, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3522,6 +3560,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // If we get here, the outgoing message serialization version is set and can't change.\n         const CNetMsgMaker msgMaker(pto->GetSendVersion());\n \n+        LOCK(cs_peerstate);\n+        CPeerState* peerstate = PeerState(pto->GetId());\n+\n         //\n         // Message: ping\n         //"
      }
    ]
  },
  {
    "sha": "8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZGRiYjEyNjc4MGE4YWI2ZmY1NDc0MTFlMmI4ZDNiNDZlNDJjODg3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-11T19:54:36Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T20:32:18Z"
      },
      "message": "Move net_processing's ProcessNewBlock calls to resolve async.\n\nEssentially, our goal is to not process anything for the given peer\nuntil the block finishes processing (emulating the previous behavior)\nwithout actually blocking the ProcessMessages loops. Obviously, in\nmost cases, we'll just go on to the next peer and immediately hit a\ncs_main lock, blocking us anyway, but this we can slowly improve\nthat state over time by moving things from CNodeState to CPeerState.",
      "tree": {
        "sha": "367dcceaaf7af31b03903622bc822018f3bca230",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/367dcceaaf7af31b03903622bc822018f3bca230"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ddbb126780a8ab6ff547411e2b8d3b46e42c887/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e89822964e9ef8dadf88d47bc94f5396a8c61a54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e89822964e9ef8dadf88d47bc94f5396a8c61a54",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e89822964e9ef8dadf88d47bc94f5396a8c61a54"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 64,
      "deletions": 30
    },
    "files": [
      {
        "sha": "146936909d4751584101f2c70eceaa5349629689",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 30,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ddbb126780a8ab6ff547411e2b8d3b46e42c887/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ddbb126780a8ab6ff547411e2b8d3b46e42c887/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
        "patch": "@@ -206,6 +206,13 @@ struct CBlockReject {\n  * move most (non-validation-specific) state here.\n  */\n struct CPeerState {\n+    //! If this peer generated some headers for us to add, we store the resulting\n+    //! future here and wait for it to complete before we process more data from this\n+    //! peer.\n+    std::future<bool> pending_block_processing;\n+    //! The hash of the block which is pending download.\n+    uint256 pending_block_hash;\n+\n     CPeerState() {}\n };\n \n@@ -2717,8 +2724,15 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n-        if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n+        if (pindex->nStatus & BLOCK_HAVE_DATA) { // Nothing to do here\n+            if (fAlreadyInFlight) {\n+                // There is a possibility the block was opportunistically reconstructed\n+                // from another peer while we were waiting for the block to come in here.\n+                // Thus, we need to wipe its in-flight state.\n+                MarkBlockAsReceived(pindex->GetBlockHash());\n+            }\n             return true;\n+        }\n \n         if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n@@ -2848,21 +2862,8 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            bool fNewBlock = ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true).get();\n-            if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n-                // Clear download state for this block, which is in\n-                // process from some other peer.  We do this after calling\n-                // ProcessNewBlock so that a malleated cmpctblock announcement\n-                // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n-            }\n+            peerstate->pending_block_hash = pblock->GetHash();\n+            peerstate->pending_block_processing = ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true);\n         }\n         return true;\n     }\n@@ -2890,6 +2891,16 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n                 return true;\n             }\n \n+            const CBlockIndex* pindex = LookupBlockIndex(resp.blockhash);\n+            if (pindex && pindex->nStatus & BLOCK_HAVE_DATA) { // Nothing to do here\n+                // There is a possibility the block was opportunistically reconstructed\n+                // from another peer while we were waiting for the block to come in here.\n+                // Thus, we may want to just skip processing (and potentially downloading\n+                // the full block in case of a shortid collision).\n+                MarkBlockAsReceived(pindex->GetBlockHash());\n+                return true;\n+            }\n+\n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n@@ -2936,13 +2947,8 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            bool fNewBlock = ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true).get();\n-            if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n+            peerstate->pending_block_hash = pblock->GetHash();\n+            peerstate->pending_block_processing = ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true);\n         }\n         return true;\n     }\n@@ -2997,13 +3003,8 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n-        bool fNewBlock = ProcessNewBlock(chainparams, pblock, forceProcessing).get();\n-        if (fNewBlock) {\n-            pfrom->nLastBlockTime = GetTime();\n-        } else {\n-            LOCK(cs_main);\n-            mapBlockSource.erase(pblock->GetHash());\n-        }\n+        peerstate->pending_block_hash = hash;\n+        peerstate->pending_block_processing = ProcessNewBlock(chainparams, pblock, forceProcessing);\n         return true;\n     }\n \n@@ -3264,6 +3265,24 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n     return false;\n }\n \n+bool IsPendingBlockValidation(CNode* pfrom, CPeerState* peerstate) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n+{\n+    if (peerstate->pending_block_processing.valid()) {\n+        if (peerstate->pending_block_processing.wait_for(std::chrono::duration<int>::zero()) == std::future_status::ready) {\n+            bool fNewBlock = peerstate->pending_block_processing.get();\n+            if (fNewBlock) {\n+                pfrom->nLastBlockTime = GetTime();\n+            } else {\n+                LOCK(cs_main);\n+                mapBlockSource.erase(peerstate->pending_block_hash);\n+            }\n+            peerstate->pending_block_processing = std::future<bool>();\n+            peerstate->pending_block_hash = uint256();\n+            return false;\n+        } else { return true; }\n+    } else { return false; }\n+}\n+\n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n@@ -3291,6 +3310,17 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         }\n     }\n \n+    if (IsPendingBlockValidation(pfrom, peerstate)) {\n+        return false;\n+    }\n+    {\n+        // Somewhat annoyingly, tests currently rely on any pending bans/disconnects\n+        // being processed prior to any pong responses, thus if we were waiting on a\n+        // block validation to complete, we need to recheck bans.\n+        LOCK(cs_main);\n+        SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n+    }\n+\n     if (pfrom->fDisconnect)\n         return false;\n \n@@ -3563,6 +3593,10 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         LOCK(cs_peerstate);\n         CPeerState* peerstate = PeerState(pto->GetId());\n \n+        if (IsPendingBlockValidation(pto, peerstate)) {\n+            return true;\n+        }\n+\n         //\n         // Message: ping\n         //"
      }
    ]
  },
  {
    "sha": "64e74ce8a917e071b8a250a4ba9cd110448796d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NGU3NGNlOGE5MTdlMDcxYjhhMjUwYTRiYTljZDExMDQ0ODc5NmQ2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T15:26:16Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T22:04:59Z"
      },
      "message": "Run ProcessNewBlock in a background thread (XXX: p2p_sendheaders broken)\n\nSpawn a background thread at startup which validates each block as\nit comes in from ProcessNewBlock, taking advantage of the new\nstd::future return value to keep tests simple (and the new\nnet_processing handling of such values async already).\n\nThis makes introducing subtle validationinterface deadlocks much\nharder as any locks held going into ProcessNewBlock do not interact\nwith (in the form of lockorder restrictions) locks taken in\nvalidationinterface callbacks.\n\nNote that after this commit, feature_block and feature_assumevalid\ntests time out due to increased latency between block processing\nwhen those blocks do not represent a new best block. This will be\nresolved in the next commit.",
      "tree": {
        "sha": "b1d990467a53cb9d401530c73200ad5c08c16eab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b1d990467a53cb9d401530c73200ad5c08c16eab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64e74ce8a917e071b8a250a4ba9cd110448796d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64e74ce8a917e071b8a250a4ba9cd110448796d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/64e74ce8a917e071b8a250a4ba9cd110448796d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64e74ce8a917e071b8a250a4ba9cd110448796d6/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ddbb126780a8ab6ff547411e2b8d3b46e42c887",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ddbb126780a8ab6ff547411e2b8d3b46e42c887"
      }
    ],
    "stats": {
      "total": 114,
      "additions": 85,
      "deletions": 29
    },
    "files": [
      {
        "sha": "9acbbee096332380db535531e3db0ce2aeb763a9",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=64e74ce8a917e071b8a250a4ba9cd110448796d6",
        "patch": "@@ -1451,6 +1451,8 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n     // ********************************************************* Step 7: load block chain\n \n+    threadGroup.create_thread(std::bind(&TraceThread<std::function<void()>>, \"blockconn\", std::function<void()>(std::bind(&CChainState::ProcessBlockValidationQueue, &ChainstateActive()))));\n+\n     fReindex = gArgs.GetBoolArg(\"-reindex\", false);\n     bool fReindexChainState = gArgs.GetBoolArg(\"-reindex-chainstate\", false);\n "
      },
      {
        "sha": "e78b37f9a4015d9daf2b13babd4934a71135581c",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=64e74ce8a917e071b8a250a4ba9cd110448796d6",
        "patch": "@@ -78,6 +78,8 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     threadGroup.create_thread(std::bind(&CScheduler::serviceQueue, &scheduler));\n     GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n \n+    threadGroup.create_thread(std::function<void()>(std::bind(&CChainState::ProcessBlockValidationQueue, &ChainstateActive())));\n+\n     mempool.setSanityCheck(1.0);\n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n     pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));"
      },
      {
        "sha": "cc47958b499e63b120bb8a3f5e7f0e16412387eb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 29,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=64e74ce8a917e071b8a250a4ba9cd110448796d6",
        "patch": "@@ -3430,48 +3430,87 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     return true;\n }\n \n-std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing)\n+void CChainState::ProcessBlockValidationQueue()\n {\n-    AssertLockNotHeld(cs_main);\n+    while (true) {\n+        LimitValidationInterfaceQueue();\n \n-    std::promise<bool> result_promise;\n-    std::future<bool> result = result_promise.get_future();\n-    bool fNewBlock = false;\n+        std::shared_ptr<const CBlock> pblock;\n+        bool fForceProcessing;\n+        std::promise<bool> result_promise;\n+        {\n+            std::unique_lock<CCriticalSection> lock(m_cs_block_validation_queue);\n+            if (m_block_validation_queue.empty()) {\n+                m_cv_block_validation_queue.wait_for(lock, std::chrono::seconds(1));\n+            }\n+            if (ShutdownRequested())\n+                break;\n+            boost::this_thread::interruption_point();\n+            if (m_block_validation_queue.empty()) {\n+                continue;\n+            }\n \n-    {\n-        CBlockIndex *pindex = nullptr;\n-        CValidationState state;\n+            std::tuple<std::shared_ptr<const CBlock>, bool, std::promise<bool>>& tuple = m_block_validation_queue.front();\n+            pblock = std::move(std::get<0>(tuple));\n+            fForceProcessing = std::get<1>(tuple);\n+            result_promise = std::move(std::get<2>(tuple));\n+            m_block_validation_queue.pop_front();\n+        }\n \n-        // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n-        // Therefore, the following critical section must include the CheckBlock() call as well.\n-        LOCK(cs_main);\n+        CChainParams chainparams = Params();\n+        bool fNewBlock = false;\n+        {\n+            CBlockIndex *pindex = nullptr;\n+            CValidationState state;\n \n-        // Ensure that CheckBlock() passes before calling AcceptBlock, as\n-        // belt-and-suspenders.\n-        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n-        if (ret) {\n-            // Store to disk\n-            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n-        }\n-        if (!ret) {\n-            GetMainSignals().BlockChecked(*pblock, state);\n-            error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n-            result_promise.set_value(fNewBlock);\n-            return result;\n+            // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n+            // Therefore, the following critical section must include the CheckBlock() call as well.\n+            LOCK(cs_main);\n+\n+            // Ensure that CheckBlock() passes before calling AcceptBlock, as\n+            // belt-and-suspenders.\n+            bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n+            if (ret) {\n+                // Store to disk\n+                ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n+            }\n+            if (!ret) {\n+                GetMainSignals().BlockChecked(*pblock, state);\n+                error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+                result_promise.set_value(fNewBlock);\n+                continue;\n+            }\n         }\n-    }\n \n-    result_promise.set_value(fNewBlock);\n+        NotifyHeaderTip();\n \n-    NotifyHeaderTip();\n+        CValidationState state; // Only used to report errors, not invalidity - ignore it\n+        if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n+            error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n+\n+        result_promise.set_value(fNewBlock);\n+    }\n+}\n \n-    CValidationState state; // Only used to report errors, not invalidity - ignore it\n-    if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n-        error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n+std::future<bool> CChainState::ProcessNewBlock(const std::shared_ptr<const CBlock> pblock, bool fForceProcessing)\n+{\n+    AssertLockNotHeld(cs_main);\n \n+    std::promise<bool> result_promise;\n+    std::future<bool> result = result_promise.get_future();\n+    {\n+        LOCK(m_cs_block_validation_queue);\n+        m_block_validation_queue.emplace_back(std::move(pblock), fForceProcessing, std::move(result_promise));\n+    }\n+    m_cv_block_validation_queue.notify_one();\n     return result;\n }\n \n+std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing)\n+{\n+    return ::ChainstateActive().ProcessNewBlock(pblock, fForceProcessing);\n+}\n+\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     AssertLockHeld(cs_main);"
      },
      {
        "sha": "798699a1efd18a9c96fdebccfddc74a68c6e4868",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64e74ce8a917e071b8a250a4ba9cd110448796d6/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=64e74ce8a917e071b8a250a4ba9cd110448796d6",
        "patch": "@@ -512,6 +512,13 @@ class CChainState {\n      */\n     mutable std::atomic<bool> m_cached_finished_ibd{false};\n \n+    /** Lock for m_block_validation_queue */\n+    CCriticalSection m_cs_block_validation_queue;\n+    /** CV for m_block_validation_queue */\n+    std::condition_variable_any m_cv_block_validation_queue;\n+    /** Queue of blocks to validate */\n+    std::list<std::tuple<std::shared_ptr<const CBlock>, bool, std::promise<bool>>> m_block_validation_queue;\n+\n public:\n     //! The current chain of blockheaders we consult and build on.\n     //! @see CChain, CBlockIndex.\n@@ -577,6 +584,12 @@ class CChainState {\n     /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n     bool IsInitialBlockDownload() const;\n \n+    /** Drain the block validation queue in a loop */\n+    void ProcessBlockValidationQueue();\n+\n+    /** Push a new block to the block validation queue */\n+    std::future<bool> ProcessNewBlock(const std::shared_ptr<const CBlock> pblock, bool fForceProcessing);\n+\n private:\n     bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      }
    ]
  },
  {
    "sha": "ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYTgxMGI5ZTg4YmVlNTU4YzM0YWMyNGRjNjg1YzY4ZTVkNWM4M2Ni",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-11T17:29:08Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T22:11:51Z"
      },
      "message": "Add a callback to indicate a block has been processed\n\nThis resolves the performance regression introduced in the previous\ncommit by always waking the message processing thread after each\nblock future resolves.\n\nSadly, this is somewhat awkward - all other validationinterface\ncallbacks represent an actual change to the global validation state,\nwhereas this callback indicates only that a call which one\nvalidation \"client\" made has completed. After going back and forth\nfor some time I didn't see a materially better way to resolve this\nissue, and luckily its a rather simple change, but its far from\nideal. Note that because we absolutely do not want to ever block on\na ProcessNewBlock-returned-future, the callback approach is\ncritical.",
      "tree": {
        "sha": "865d8d56215ad86e3bd8d75ce1ca7b058a6d9e0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/865d8d56215ad86e3bd8d75ce1ca7b058a6d9e0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "64e74ce8a917e071b8a250a4ba9cd110448796d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64e74ce8a917e071b8a250a4ba9cd110448796d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/64e74ce8a917e071b8a250a4ba9cd110448796d6"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 29,
      "deletions": 0
    },
    "files": [
      {
        "sha": "bd7080c85912d7cb267106563ca2cfd4fecc3faf",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "patch": "@@ -1306,6 +1306,14 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n         mapBlockSource.erase(it);\n }\n \n+/**\n+ * Wake up message handler once a block has been processed to process the\n+ * next message from the peer that sent us that block.\n+ */\n+void PeerLogicValidation::BlockProcessed() {\n+    connman->WakeMessageHandler();\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Messages"
      },
      {
        "sha": "62e0ae77fa4f48611e82f6aa5ebe0966014580dc",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "patch": "@@ -45,6 +45,10 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n      * Overridden from CValidationInterface.\n      */\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+    /**\n+     * Overridden from CValidationInterface.\n+     */\n+    void BlockProcessed() override;\n \n     /** Initialize a peer by adding it to mapNodeState and pushing a message requesting its version */\n     void InitializeNode(CNode* pnode) override;"
      },
      {
        "sha": "89dd454206112b9d2920a579c495ae19e80d4d4d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "patch": "@@ -3489,6 +3489,7 @@ void CChainState::ProcessBlockValidationQueue()\n             error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n         result_promise.set_value(fNewBlock);\n+        GetMainSignals().BlockProcessed();\n     }\n }\n "
      },
      {
        "sha": "ed3c43b986a6cbf73444f0ea32f5b8b4e4b2997f",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "patch": "@@ -25,6 +25,7 @@ struct ValidationInterfaceConnections {\n     boost::signals2::scoped_connection ChainStateFlushed;\n     boost::signals2::scoped_connection BlockChecked;\n     boost::signals2::scoped_connection NewPoWValidBlock;\n+    boost::signals2::scoped_connection BlockProcessed;\n };\n \n struct MainSignalsInstance {\n@@ -36,6 +37,7 @@ struct MainSignalsInstance {\n     boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n     boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+    boost::signals2::signal<void ()> BlockProcessed;\n \n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n@@ -99,6 +101,7 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     conns.ChainStateFlushed = g_signals.m_internals->ChainStateFlushed.connect(std::bind(&CValidationInterface::ChainStateFlushed, pwalletIn, std::placeholders::_1));\n     conns.BlockChecked = g_signals.m_internals->BlockChecked.connect(std::bind(&CValidationInterface::BlockChecked, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n     conns.NewPoWValidBlock = g_signals.m_internals->NewPoWValidBlock.connect(std::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n+    conns.BlockProcessed = g_signals.m_internals->BlockProcessed.connect(std::bind(&CValidationInterface::BlockProcessed, pwalletIn));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n@@ -177,3 +180,9 @@ void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& sta\n void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {\n     m_internals->NewPoWValidBlock(pindex, block);\n }\n+\n+void CMainSignals::BlockProcessed() {\n+    m_internals->m_schedulerClient.AddToProcessQueue([this] {\n+        m_internals->BlockProcessed();\n+    });\n+}"
      },
      {
        "sha": "75503f684e90040eac324f8b8800e20797eda001",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba810b9e88bee558c34ac24dc685c68e5d5c83cb/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "patch": "@@ -144,6 +144,12 @@ class CValidationInterface {\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */\n     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n+    /**\n+     * Notifies listeners that a block which was submitted has been fully processed.\n+     *\n+     * Called on a background thread.\n+     */\n+    virtual void BlockProcessed() {}\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterAllValidationInterfaces();\n@@ -183,6 +189,7 @@ class CMainSignals {\n     void ChainStateFlushed(const CBlockLocator &);\n     void BlockChecked(const CBlock&, const CValidationState&);\n     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n+    void BlockProcessed();\n };\n \n CMainSignals& GetMainSignals();"
      }
    ]
  },
  {
    "sha": "3499d988a9cef162987d98dda3cf914be24a3fa1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDk5ZDk4OGE5Y2VmMTYyOTg3ZDk4ZGRhM2NmOTE0YmUyNGEzZmEx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T15:27:07Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T22:17:02Z"
      },
      "message": "Move BlockChecked to a background thread",
      "tree": {
        "sha": "4350f064d07909b79a96e1ad55c6ace83bfdd153",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4350f064d07909b79a96e1ad55c6ace83bfdd153"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3499d988a9cef162987d98dda3cf914be24a3fa1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3499d988a9cef162987d98dda3cf914be24a3fa1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3499d988a9cef162987d98dda3cf914be24a3fa1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3499d988a9cef162987d98dda3cf914be24a3fa1/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba810b9e88bee558c34ac24dc685c68e5d5c83cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ba810b9e88bee558c34ac24dc685c68e5d5c83cb"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 11,
      "deletions": 5
    },
    "files": [
      {
        "sha": "4727bf70a494214addbb6ac7fee29300f91f236f",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3499d988a9cef162987d98dda3cf914be24a3fa1/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3499d988a9cef162987d98dda3cf914be24a3fa1/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=3499d988a9cef162987d98dda3cf914be24a3fa1",
        "patch": "@@ -749,6 +749,7 @@ static UniValue submitblock(const JSONRPCRequest& request)\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n     bool new_block = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true).get();\n+    SyncWithValidationInterfaceQueue();\n     UnregisterValidationInterface(&sc);\n     LOCK(cs_main);\n     const CBlockIndex* pindex = LookupBlockIndex(blockptr->GetHash());"
      },
      {
        "sha": "e6b1c08d9b639f23f200fb2bf85659801df534c9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3499d988a9cef162987d98dda3cf914be24a3fa1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3499d988a9cef162987d98dda3cf914be24a3fa1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3499d988a9cef162987d98dda3cf914be24a3fa1",
        "patch": "@@ -2293,7 +2293,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     {\n         CCoinsViewCache view(pcoinsTip.get());\n         bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);\n-        GetMainSignals().BlockChecked(blockConnecting, state);\n+        GetMainSignals().BlockChecked(pthisBlock, state);\n         if (!rv) {\n             if (state.IsInvalid())\n                 InvalidBlockFound(pindexNew, state);\n@@ -3475,7 +3475,7 @@ void CChainState::ProcessBlockValidationQueue()\n                 ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n             }\n             if (!ret) {\n-                GetMainSignals().BlockChecked(*pblock, state);\n+                GetMainSignals().BlockChecked(pblock, state);\n                 error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n                 result_promise.set_value(fNewBlock);\n                 continue;"
      },
      {
        "sha": "b1f7158a359e76ed29c9d8f75e3c00799ac578fe",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3499d988a9cef162987d98dda3cf914be24a3fa1/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3499d988a9cef162987d98dda3cf914be24a3fa1/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=3499d988a9cef162987d98dda3cf914be24a3fa1",
        "patch": "@@ -5,6 +5,7 @@\n \n #include <validationinterface.h>\n \n+#include <consensus/validation.h>\n #include <primitives/block.h>\n #include <scheduler.h>\n #include <txmempool.h>\n@@ -173,8 +174,10 @@ void CMainSignals::ChainStateFlushed(const CBlockLocator &locator) {\n     });\n }\n \n-void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& state) {\n-    m_internals->BlockChecked(block, state);\n+void CMainSignals::BlockChecked(const std::shared_ptr<const CBlock> &pblock, const CValidationState& state) {\n+    m_internals->m_schedulerClient.AddToProcessQueue([pblock, state, this] {\n+        m_internals->BlockChecked(*pblock, state);\n+    });\n }\n \n void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {"
      },
      {
        "sha": "0a11627f2f55f02dd4bcc148e870d230858ab76e",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3499d988a9cef162987d98dda3cf914be24a3fa1/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3499d988a9cef162987d98dda3cf914be24a3fa1/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=3499d988a9cef162987d98dda3cf914be24a3fa1",
        "patch": "@@ -138,6 +138,8 @@ class CValidationInterface {\n      * If the provided CValidationState IsValid, the provided block\n      * is guaranteed to be the current best block at the time the\n      * callback was generated (not necessarily now)\n+     *\n+     * Called on a background thread.\n      */\n     virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n     /**\n@@ -187,7 +189,7 @@ class CMainSignals {\n     void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::shared_ptr<const std::vector<CTransactionRef>> &);\n     void BlockDisconnected(const std::shared_ptr<const CBlock> &);\n     void ChainStateFlushed(const CBlockLocator &);\n-    void BlockChecked(const CBlock&, const CValidationState&);\n+    void BlockChecked(const std::shared_ptr<const CBlock> &block, const CValidationState&);\n     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n     void BlockProcessed();\n };"
      }
    ]
  },
  {
    "sha": "445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NDViYjg0YmQzYzM4YjJlOThjY2MyNDdhYTFhMzQ2Y2EzYzVkNjZj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T11:18:35Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T22:27:51Z"
      },
      "message": "Move nDoS counters to CPeerState (and, thus, out of cs_main)",
      "tree": {
        "sha": "c5d4eefb85eebef17768b84d041c275da2a25da9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5d4eefb85eebef17768b84d041c275da2a25da9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3499d988a9cef162987d98dda3cf914be24a3fa1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3499d988a9cef162987d98dda3cf914be24a3fa1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3499d988a9cef162987d98dda3cf914be24a3fa1"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 68,
      "deletions": 62
    },
    "files": [
      {
        "sha": "6aad14a9373a8cda38912dbf8489ae80b6f700a1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 54,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
        "patch": "@@ -93,8 +93,10 @@ std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n \n void EraseOrphansFor(NodeId peer);\n \n+/** Note that this must be locked BEFORE cs_main! */\n+CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n /** Increase a node's misbehavior score. */\n-void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate);\n \n /** Average delay between local address broadcasts in seconds. */\n static constexpr unsigned int AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24 * 60 * 60;\n@@ -206,14 +208,35 @@ struct CBlockReject {\n  * move most (non-validation-specific) state here.\n  */\n struct CPeerState {\n+    //! String name of this peer (debugging/logging purposes).\n+    const std::string name;\n+\n+    //! Whether this peer should be disconnected and banned (unless whitelisted).\n+    bool fShouldBan;\n+    //! Accumulated misbehaviour score for this peer.\n+    int nMisbehavior;\n+\n+    //! Whether this peer is an inbound connection\n+    bool m_is_inbound;\n+\n+    //! Whether this peer is a manual connection\n+    bool m_is_manual_connection;\n+\n     //! If this peer generated some headers for us to add, we store the resulting\n     //! future here and wait for it to complete before we process more data from this\n     //! peer.\n     std::future<bool> pending_block_processing;\n     //! The hash of the block which is pending download.\n     uint256 pending_block_hash;\n \n-    CPeerState() {}\n+    CPeerState(std::string addrNameIn, bool is_inbound, bool is_manual) :\n+        name(std::move(addrNameIn)),\n+        m_is_inbound(is_inbound),\n+        m_is_manual_connection (is_manual)\n+    {\n+        fShouldBan = false;\n+        nMisbehavior = 0;\n+    }\n };\n \n \n@@ -228,12 +251,6 @@ struct CNodeState {\n     const CService address;\n     //! Whether we have a fully established connection.\n     bool fCurrentlyConnected;\n-    //! Accumulated misbehaviour score for this peer.\n-    int nMisbehavior;\n-    //! Whether this peer should be disconnected and banned (unless whitelisted).\n-    bool fShouldBan;\n-    //! String name of this peer (debugging/logging purposes).\n-    const std::string name;\n     //! List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n@@ -378,13 +395,11 @@ struct CNodeState {\n     //! Whether this peer is a manual connection\n     bool m_is_manual_connection;\n \n-    CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :\n-        address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),\n+    CNodeState(CAddress addrIn, bool is_inbound, bool is_manual) :\n+        address(addrIn), m_is_inbound(is_inbound),\n         m_is_manual_connection (is_manual)\n     {\n         fCurrentlyConnected = false;\n-        nMisbehavior = 0;\n-        fShouldBan = false;\n         pindexBestKnownBlock = nullptr;\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = nullptr;\n@@ -411,13 +426,10 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n-/** Note that this must be locked BEFORE cs_main! */\n-CCriticalSection cs_peerstate;\n-\n /** Map maintaining per-node state. */\n static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n \n-static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) LOCKS_EXCLUDED(cs_main) {\n+static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     std::map<NodeId, CPeerState>::iterator it = mapPeerState.find(pnode);\n     if (it == mapPeerState.end())\n         return nullptr;\n@@ -800,11 +812,11 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     NodeId nodeid = pnode->GetId();\n     {\n         LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, pnode->fInbound, pnode->m_manual_connection));\n     }\n     {\n         LOCK(cs_peerstate);\n-        mapPeerState.emplace_hint(mapPeerState.end(), nodeid, CPeerState{});\n+        mapPeerState.emplace_hint(mapPeerState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n \n     if(!pnode->fInbound)\n@@ -825,7 +837,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     if (state->fSyncStarted)\n         nSyncStarted--;\n \n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n+    if (peerstate->nMisbehavior == 0 && state->fCurrentlyConnected) {\n         fUpdateConnectionTime = true;\n     }\n \n@@ -854,11 +866,14 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n }\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(nodeid);\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n-    if (state == nullptr)\n+    if (state == nullptr || peerstate == nullptr)\n         return false;\n-    stats.nMisbehavior = state->nMisbehavior;\n+\n+    stats.nMisbehavior = peerstate->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n     for (const QueuedBlock& queue : state->vBlocksInFlight) {\n@@ -1001,27 +1016,28 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     return nEvicted;\n }\n \n+\n /**\n  * Mark a misbehaving peer to be banned depending upon the value of `-banscore`.\n  */\n-void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     if (howmuch == 0)\n         return;\n \n-    CNodeState *state = State(pnode);\n-    if (state == nullptr)\n+    CPeerState *peerstate = PeerState(pnode);\n+    if (peerstate == nullptr)\n         return;\n \n-    state->nMisbehavior += howmuch;\n+    peerstate->nMisbehavior += howmuch;\n     int banscore = gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD);\n     std::string message_prefixed = message.empty() ? \"\" : (\": \" + message);\n-    if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n+    if (peerstate->nMisbehavior >= banscore && peerstate->nMisbehavior - howmuch < banscore)\n     {\n-        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n-        state->fShouldBan = true;\n+        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, peerstate->name, pnode, peerstate->nMisbehavior-howmuch, peerstate->nMisbehavior, message_prefixed);\n+        peerstate->fShouldBan = true;\n     } else\n-        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, peerstate->name, pnode, peerstate->nMisbehavior-howmuch, peerstate->nMisbehavior, message_prefixed);\n }\n \n /**\n@@ -1047,30 +1063,28 @@ static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n  *\n  * Changes here may need to be reflected in TxRelayMayResultInDisconnect().\n  */\n-static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     switch (state.GetReason()) {\n     case ValidationInvalidReason::NONE:\n         break;\n     // The node is providing invalid data:\n     case ValidationInvalidReason::CONSENSUS:\n     case ValidationInvalidReason::BLOCK_MUTATED:\n         if (!via_compact_block) {\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n             return true;\n         }\n         break;\n     case ValidationInvalidReason::CACHED_INVALID:\n         {\n-            LOCK(cs_main);\n-            CNodeState *node_state = State(nodeid);\n-            if (node_state == nullptr) {\n+            CPeerState *peer_state = PeerState(nodeid);\n+            if (peer_state == nullptr) {\n                 break;\n             }\n \n             // Ban outbound (but not inbound) peers if on an invalid chain.\n             // Exempt HB compact block peers and manual connections.\n-            if (!via_compact_block && !node_state->m_is_inbound && !node_state->m_is_manual_connection) {\n+            if (!via_compact_block && !peer_state->m_is_inbound && !peer_state->m_is_manual_connection) {\n                 Misbehaving(nodeid, 100, message);\n                 return true;\n             }\n@@ -1080,15 +1094,13 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n     case ValidationInvalidReason::BLOCK_CHECKPOINT:\n     case ValidationInvalidReason::BLOCK_INVALID_PREV:\n         {\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n         }\n         return true;\n     // Conflicting (but not necessarily invalid) data or different policy:\n     case ValidationInvalidReason::BLOCK_MISSING_PREV:\n         {\n             // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 10, message);\n         }\n         return true;\n@@ -1276,6 +1288,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n  * peers announce compact blocks.\n  */\n void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n+    LOCK(cs_peerstate);\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n@@ -1635,11 +1648,10 @@ static uint32_t GetFetchFlags(CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId()));\n             return;\n         }\n@@ -1651,7 +1663,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1832,9 +1844,10 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate, cs_main, g_cs_orphans)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     AssertLockHeld(g_cs_orphans);\n     std::set<NodeId> setMisbehaving;\n     bool done = false;\n@@ -1909,7 +1922,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n                strCommand == NetMsgType::FILTERADD))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n             return false;\n         } else {\n@@ -1950,7 +1962,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             if (enable_bip61) {\n                 connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             }\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n         }\n@@ -2118,7 +2129,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n     if (pfrom->nVersion == 0) {\n         // Must have a version message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -2165,7 +2175,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n     if (!pfrom->fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -2179,7 +2188,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             return true;\n         if (vAddr.size() > 1000)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n             return false;\n         }\n@@ -2255,7 +2263,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n             return false;\n         }\n@@ -2313,7 +2320,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n             return false;\n         }\n@@ -2974,7 +2980,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n             return false;\n         }\n@@ -3150,7 +3155,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         if (!filter.IsWithinSizeConstraints())\n         {\n             // There is no excuse for sending a too-large filter\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         else\n@@ -3181,7 +3185,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             }\n         }\n         if (bad) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         return true;\n@@ -3239,10 +3242,12 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n     return true;\n }\n \n-bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_peerstate)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     CNodeState &state = *State(pnode->GetId());\n+    CPeerState &peerstate = *PeerState(pnode->GetId());\n \n     if (enable_bip61) {\n         for (const CBlockReject& reject : state.rejects) {\n@@ -3251,8 +3256,8 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n     }\n     state.rejects.clear();\n \n-    if (state.fShouldBan) {\n-        state.fShouldBan = false;\n+    if (peerstate.fShouldBan) {\n+        peerstate.fShouldBan = false;\n         if (pnode->fWhitelisted)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n         else if (pnode->m_manual_connection)"
      },
      {
        "sha": "b677e5a40dd4ee885202ef5ccb8d50b323237852",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
        "patch": "@@ -42,6 +42,7 @@ extern bool AddOrphanTx(const CTransactionRef& tx, NodeId peer);\n extern void EraseOrphansFor(NodeId peer);\n extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n extern void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\");\n+extern CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n \n struct COrphanTx {\n     CTransactionRef tx;\n@@ -228,7 +229,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     }\n     {\n@@ -245,7 +246,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n@@ -255,7 +256,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     BOOST_CHECK(!banman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(banman->IsBanned(addr1));  // ... but 1 still should be\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n@@ -284,7 +285,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 100);\n     }\n     {\n@@ -293,7 +294,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 10);\n     }\n     {\n@@ -302,7 +303,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 1);\n     }\n     {\n@@ -334,7 +335,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     dummyNode.fSuccessfullyConnected = true;\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode.GetId(), 100);\n     }\n     {\n@@ -356,7 +357,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n static CTransactionRef RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;\n-    LOCK2(cs_main, g_cs_orphans);\n+    LOCK(g_cs_orphans);\n     it = mapOrphanTransactions.lower_bound(InsecureRand256());\n     if (it == mapOrphanTransactions.end())\n         it = mapOrphanTransactions.begin();"
      }
    ]
  },
  {
    "sha": "b6a05524f9b66af1147c9776e3b499bdb94655f8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNmEwNTUyNGY5YjY2YWYxMTQ3Yzk3NzZlM2I0OTliZGI5NDY1NWY4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T11:32:18Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T22:27:52Z"
      },
      "message": "Move rejects into cs_peerstate.\n\nThis removes the cs_main lock which is taken on every\nProcessMessages call.",
      "tree": {
        "sha": "b264071769248ae2320e27bf407fe0a373a26caf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b264071769248ae2320e27bf407fe0a373a26caf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6a05524f9b66af1147c9776e3b499bdb94655f8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6a05524f9b66af1147c9776e3b499bdb94655f8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b6a05524f9b66af1147c9776e3b499bdb94655f8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6a05524f9b66af1147c9776e3b499bdb94655f8/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/445bb84bd3c38b2e98ccc247aa1a346ca3c5d66c"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 17,
      "deletions": 18
    },
    "files": [
      {
        "sha": "adda634fbde50e6cff528d638b461d4a0af59104",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 17,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6a05524f9b66af1147c9776e3b499bdb94655f8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6a05524f9b66af1147c9776e3b499bdb94655f8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b6a05524f9b66af1147c9776e3b499bdb94655f8",
        "patch": "@@ -211,6 +211,9 @@ struct CPeerState {\n     //! String name of this peer (debugging/logging purposes).\n     const std::string name;\n \n+    //! List of asynchronously-determined block rejections to notify this peer about.\n+    std::vector<CBlockReject> rejects;\n+\n     //! Whether this peer should be disconnected and banned (unless whitelisted).\n     bool fShouldBan;\n     //! Accumulated misbehaviour score for this peer.\n@@ -251,8 +254,6 @@ struct CNodeState {\n     const CService address;\n     //! Whether we have a fully established connection.\n     bool fCurrentlyConnected;\n-    //! List of asynchronously-determined block rejections to notify this peer about.\n-    std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n     const CBlockIndex *pindexBestKnownBlock;\n     //! The hash of the last unknown block this peer has announced.\n@@ -1295,10 +1296,11 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n \n     if (state.IsInvalid()) {\n+        CPeerState *peerstate = PeerState(it->second.first);\n         // Don't send reject message with code 0 or an internal reject code.\n-        if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n+        if (it != mapBlockSource.end() && peerstate && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n             CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n-            State(it->second.first)->rejects.push_back(reject);\n+            peerstate->rejects.push_back(reject);\n             MaybePunishNode(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n         }\n     }\n@@ -3242,19 +3244,17 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n     return true;\n }\n \n-bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_peerstate)\n+bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n-    AssertLockHeld(cs_main);\n     AssertLockHeld(cs_peerstate);\n-    CNodeState &state = *State(pnode->GetId());\n     CPeerState &peerstate = *PeerState(pnode->GetId());\n \n     if (enable_bip61) {\n-        for (const CBlockReject& reject : state.rejects) {\n+        for (const CBlockReject& reject : peerstate.rejects) {\n             connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::BLOCK), reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n         }\n     }\n-    state.rejects.clear();\n+    peerstate.rejects.clear();\n \n     if (peerstate.fShouldBan) {\n         peerstate.fShouldBan = false;\n@@ -3326,13 +3326,10 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     if (IsPendingBlockValidation(pfrom, peerstate)) {\n         return false;\n     }\n-    {\n-        // Somewhat annoyingly, tests currently rely on any pending bans/disconnects\n-        // being processed prior to any pong responses, thus if we were waiting on a\n-        // block validation to complete, we need to recheck bans.\n-        LOCK(cs_main);\n-        SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n-    }\n+    // Somewhat annoyingly, tests currently rely on any pending bans/disconnects\n+    // being processed prior to any pong responses, thus if we were waiting on a\n+    // block validation to complete, we need to recheck bans.\n+    SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n \n     if (pfrom->fDisconnect)\n         return false;\n@@ -3434,7 +3431,6 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         LogPrint(BCLog::NET, \"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n     }\n \n-    LOCK(cs_main);\n     SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n \n     return fMoreWork;"
      },
      {
        "sha": "f81c2920ceab4a4c8f2861b10485e08527c51030",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6a05524f9b66af1147c9776e3b499bdb94655f8/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6a05524f9b66af1147c9776e3b499bdb94655f8/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=b6a05524f9b66af1147c9776e3b499bdb94655f8",
        "patch": "@@ -13,6 +13,9 @@\n \n extern CCriticalSection cs_main;\n \n+/** Note that this must be locked BEFORE cs_main! */\n+extern CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n+\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n@@ -25,7 +28,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     CConnman* const connman;\n     BanMan* const m_banman;\n \n-    bool SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate);\n public:\n     PeerLogicValidation(CConnman* connman, BanMan* banman, CScheduler &scheduler, bool enable_bip61);\n "
      }
    ]
  },
  {
    "sha": "2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZDFlOGY2NGNkNTI3YjljNDRiYTE3MWJlYjBiYjgzN2M2NGNjMGE1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-08T17:07:01Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T22:27:53Z"
      },
      "message": "Actually parallelize validation somewhat",
      "tree": {
        "sha": "fbe9b4fa915443653f6b72f76a419bf7435fcdb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fbe9b4fa915443653f6b72f76a419bf7435fcdb5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6a05524f9b66af1147c9776e3b499bdb94655f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6a05524f9b66af1147c9776e3b499bdb94655f8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6a05524f9b66af1147c9776e3b499bdb94655f8"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 6,
      "deletions": 0
    },
    "files": [
      {
        "sha": "16918b96439f5a4236f116008c918272b3a192eb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2d1e8f64cd527b9c44ba171beb0bb837c64cc0a5",
        "patch": "@@ -3005,6 +3005,12 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n+        // Call CheckBlock before we hit cs_main so that we can (hopefully) get\n+        // the fChecked flag cached in the pblock while the validation thread is\n+        // processing some other block.\n+        CValidationState statedummy;\n+        CheckBlock(*pblock, statedummy, chainparams.GetConsensus(), true, true);\n+\n         LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n         bool forceProcessing = false;"
      }
    ]
  }
]