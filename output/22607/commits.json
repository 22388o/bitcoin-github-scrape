[
  {
    "sha": "78cc97296bc2a7a8b18c82154b300d5f1573344a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OGNjOTcyOTZiYzJhN2E4YjE4YzgyMTU0YjMwMGQ1ZjE1NzMzNDRh",
    "commit": {
      "author": {
        "name": "root",
        "email": "ruhiasap@gmail.com",
        "date": "2021-08-02T16:06:15Z"
      },
      "committer": {
        "name": "root",
        "email": "ruhiasap@gmail.com",
        "date": "2021-08-02T16:06:15Z"
      },
      "message": "initial commit",
      "tree": {
        "sha": "2141005534e451280599146146c0fbf0a3dbd8d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2141005534e451280599146146c0fbf0a3dbd8d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78cc97296bc2a7a8b18c82154b300d5f1573344a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78cc97296bc2a7a8b18c82154b300d5f1573344a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/78cc97296bc2a7a8b18c82154b300d5f1573344a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78cc97296bc2a7a8b18c82154b300d5f1573344a/comments",
    "author": {
      "login": "stratospher",
      "id": 44024636,
      "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stratospher",
      "html_url": "https://github.com/stratospher",
      "followers_url": "https://api.github.com/users/stratospher/followers",
      "following_url": "https://api.github.com/users/stratospher/following{/other_user}",
      "gists_url": "https://api.github.com/users/stratospher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
      "organizations_url": "https://api.github.com/users/stratospher/orgs",
      "repos_url": "https://api.github.com/users/stratospher/repos",
      "events_url": "https://api.github.com/users/stratospher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stratospher/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "stratospher",
      "id": 44024636,
      "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stratospher",
      "html_url": "https://github.com/stratospher",
      "followers_url": "https://api.github.com/users/stratospher/followers",
      "following_url": "https://api.github.com/users/stratospher/following{/other_user}",
      "gists_url": "https://api.github.com/users/stratospher/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
      "organizations_url": "https://api.github.com/users/stratospher/orgs",
      "repos_url": "https://api.github.com/users/stratospher/repos",
      "events_url": "https://api.github.com/users/stratospher/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stratospher/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1488f55fa57a1400a57be837b574183f019c7855",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1488f55fa57a1400a57be837b574183f019c7855",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1488f55fa57a1400a57be837b574183f019c7855"
      }
    ],
    "stats": {
      "total": 351,
      "additions": 351,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2abc8e7a48686f7895dfe7d14223db03ac0e1955",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78cc97296bc2a7a8b18c82154b300d5f1573344a/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78cc97296bc2a7a8b18c82154b300d5f1573344a/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=78cc97296bc2a7a8b18c82154b300d5f1573344a",
        "patch": "@@ -227,6 +227,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/crypto_chacha20.cpp \\\n  test/fuzz/crypto_chacha20_poly1305_aead.cpp \\\n  test/fuzz/crypto_common.cpp \\\n+ test/fuzz/crypto_compare_chacha20.cpp \\\n  test/fuzz/crypto_hkdf_hmac_sha256_l32.cpp \\\n  test/fuzz/crypto_poly1305.cpp \\\n  test/fuzz/cuckoocache.cpp \\"
      },
      {
        "sha": "19e8279f19f230e31f1c27cf0ce42ec0838dba84",
        "filename": "src/test/fuzz/crypto_compare_chacha20.cpp",
        "status": "added",
        "additions": 350,
        "deletions": 0,
        "changes": 350,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78cc97296bc2a7a8b18c82154b300d5f1573344a/src/test/fuzz/crypto_compare_chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78cc97296bc2a7a8b18c82154b300d5f1573344a/src/test/fuzz/crypto_compare_chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto_compare_chacha20.cpp?ref=78cc97296bc2a7a8b18c82154b300d5f1573344a",
        "patch": "@@ -0,0 +1,350 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                                       \\\n+  (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) |            \\\n+   ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)                                                    \\\n+  do {                                                                         \\\n+    (p)[0] = U8V((v));                                                         \\\n+    (p)[1] = U8V((v) >> 8);                                                    \\\n+    (p)[2] = U8V((v) >> 16);                                                   \\\n+    (p)[3] = U8V((v) >> 24);                                                   \\\n+  } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+  u32 input[16]; \n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_init();\n+\n+void ECRYPT_keysetup(\n+  ECRYPT_ctx* ctx, \n+  const u8* key, \n+  u32 keysize,                /* Key size in bits. */ \n+  u32 ivsize);                /* IV size in bits. */ \n+\n+void ECRYPT_ivsetup(\n+  ECRYPT_ctx* ctx, \n+  const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+  ECRYPT_ctx* ctx, \n+  const u8* plaintext, \n+  u8* ciphertext, \n+  u32 msglen);                /* Message length in bytes. */ \n+\n+void ECRYPT_decrypt_bytes(\n+  ECRYPT_ctx* ctx, \n+  const u8* ciphertext, \n+  u8* plaintext, \n+  u32 msglen);                /* Message length in bytes. */ \n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+\n+#define ECRYPT_GENERATES_KEYSTREAM\n+#ifdef ECRYPT_GENERATES_KEYSTREAM\n+\n+void ECRYPT_keystream_bytes(\n+  ECRYPT_ctx* ctx,\n+  u8* keystream,\n+  u32 length);                /* Length of keystream in bytes. */\n+\n+#endif\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v,c) (ROTL32(v,c))\n+#define XOR(v,w) ((v) ^ (w))\n+#define PLUS(v,w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v),1))\n+\n+#define QUARTERROUND(a,b,c,d) \\\n+  a = PLUS(a,b); d = ROTATE(XOR(d,a),16); \\\n+  c = PLUS(c,d); b = ROTATE(XOR(b,c),12); \\\n+  a = PLUS(a,b); d = ROTATE(XOR(d,a), 8); \\\n+  c = PLUS(c,d); b = ROTATE(XOR(b,c), 7);\n+\n+void ECRYPT_init(void)\n+{\n+  return;\n+}\n+\n+static const char sigma[17] = \"expand 32-byte k\";\n+static const char tau[17] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx *x,const u8 *k,u32 kbits)\n+{\n+  const char *constants;\n+\n+  x->input[4] = U8TO32_LITTLE(k + 0);\n+  x->input[5] = U8TO32_LITTLE(k + 4);\n+  x->input[6] = U8TO32_LITTLE(k + 8);\n+  x->input[7] = U8TO32_LITTLE(k + 12);\n+  if (kbits == 256) { /* recommended */\n+    k += 16;\n+    constants = sigma;\n+  } else { /* kbits == 128 */\n+    constants = tau;\n+  }\n+  x->input[8] = U8TO32_LITTLE(k + 0);\n+  x->input[9] = U8TO32_LITTLE(k + 4);\n+  x->input[10] = U8TO32_LITTLE(k + 8);\n+  x->input[11] = U8TO32_LITTLE(k + 12);\n+  x->input[0] = U8TO32_LITTLE(constants + 0);\n+  x->input[1] = U8TO32_LITTLE(constants + 4);\n+  x->input[2] = U8TO32_LITTLE(constants + 8);\n+  x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx *x,const u8 *iv)\n+{\n+  x->input[12] = 0;\n+  x->input[13] = 0;\n+  x->input[14] = U8TO32_LITTLE(iv + 0);\n+  x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx *x,const u8 *m,u8 *c,u32 bytes)\n+{\n+  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+  u8 *ctarget=NULL;\n+  u8 tmp[64];\n+  uint32_t i;\n+\n+  if (!bytes) return;\n+\n+  j0 = x->input[0];\n+  j1 = x->input[1];\n+  j2 = x->input[2];\n+  j3 = x->input[3];\n+  j4 = x->input[4];\n+  j5 = x->input[5];\n+  j6 = x->input[6];\n+  j7 = x->input[7];\n+  j8 = x->input[8];\n+  j9 = x->input[9];\n+  j10 = x->input[10];\n+  j11 = x->input[11];\n+  j12 = x->input[12];\n+  j13 = x->input[13];\n+  j14 = x->input[14];\n+  j15 = x->input[15];\n+\n+  for (;;) {\n+    if (bytes < 64) {\n+      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n+      m = tmp;\n+      ctarget = c;\n+      c = tmp;\n+    }\n+    x0 = j0;\n+    x1 = j1;\n+    x2 = j2;\n+    x3 = j3;\n+    x4 = j4;\n+    x5 = j5;\n+    x6 = j6;\n+    x7 = j7;\n+    x8 = j8;\n+    x9 = j9;\n+    x10 = j10;\n+    x11 = j11;\n+    x12 = j12;\n+    x13 = j13;\n+    x14 = j14;\n+    x15 = j15;\n+    for (i = 20;i > 0;i -= 2) {\n+      QUARTERROUND( x0, x4, x8,x12)\n+      QUARTERROUND( x1, x5, x9,x13)\n+      QUARTERROUND( x2, x6,x10,x14)\n+      QUARTERROUND( x3, x7,x11,x15)\n+      QUARTERROUND( x0, x5,x10,x15)\n+      QUARTERROUND( x1, x6,x11,x12)\n+      QUARTERROUND( x2, x7, x8,x13)\n+      QUARTERROUND( x3, x4, x9,x14)\n+    }\n+    x0 = PLUS(x0,j0);\n+    x1 = PLUS(x1,j1);\n+    x2 = PLUS(x2,j2);\n+    x3 = PLUS(x3,j3);\n+    x4 = PLUS(x4,j4);\n+    x5 = PLUS(x5,j5);\n+    x6 = PLUS(x6,j6);\n+    x7 = PLUS(x7,j7);\n+    x8 = PLUS(x8,j8);\n+    x9 = PLUS(x9,j9);\n+    x10 = PLUS(x10,j10);\n+    x11 = PLUS(x11,j11);\n+    x12 = PLUS(x12,j12);\n+    x13 = PLUS(x13,j13);\n+    x14 = PLUS(x14,j14);\n+    x15 = PLUS(x15,j15);\n+\n+    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n+    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n+    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n+    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n+    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n+    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n+    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n+    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n+    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n+    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n+    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n+    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n+    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n+    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n+    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n+    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n+\n+    j12 = PLUSONE(j12);\n+    if (!j12) {\n+      j13 = PLUSONE(j13);\n+      /* stopping at 2^70 bytes per nonce is user's responsibility */\n+    }\n+\n+    U32TO8_LITTLE(c + 0,x0);\n+    U32TO8_LITTLE(c + 4,x1);\n+    U32TO8_LITTLE(c + 8,x2);\n+    U32TO8_LITTLE(c + 12,x3);\n+    U32TO8_LITTLE(c + 16,x4);\n+    U32TO8_LITTLE(c + 20,x5);\n+    U32TO8_LITTLE(c + 24,x6);\n+    U32TO8_LITTLE(c + 28,x7);\n+    U32TO8_LITTLE(c + 32,x8);\n+    U32TO8_LITTLE(c + 36,x9);\n+    U32TO8_LITTLE(c + 40,x10);\n+    U32TO8_LITTLE(c + 44,x11);\n+    U32TO8_LITTLE(c + 48,x12);\n+    U32TO8_LITTLE(c + 52,x13);\n+    U32TO8_LITTLE(c + 56,x14);\n+    U32TO8_LITTLE(c + 60,x15);\n+\n+    if (bytes <= 64) {\n+      if (bytes < 64) {\n+        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n+      }\n+      x->input[12] = j12;\n+      x->input[13] = j13;\n+      return;\n+    }\n+    bytes -= 64;\n+    c += 64;\n+    m += 64;\n+  }\n+}\n+\n+void ECRYPT_decrypt_bytes(ECRYPT_ctx *x,const u8 *c,u8 *m,u32 bytes)\n+{\n+  ECRYPT_encrypt_bytes(x,c,m,bytes);\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx *x,u8 *stream,u32 bytes)\n+{\n+  u32 i;\n+  for (i = 0;i < bytes;++i) stream[i] = 0;\n+  ECRYPT_encrypt_bytes(x,stream,stream,bytes);\n+}\n+\n+FUZZ_TARGET(crypto_compare_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+\t      const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx,key.data(),key.size()*8);\n+        uint64_t iv=0;\n+        ECRYPT_ivsetup(&ctx, (u8 *)&iv);\n+    }\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+\t    \t      size_t cir=fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32);\n+              const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, cir);\n+              chacha20.SetKey(key.data(), key.size());\n+\t\t//ECRYPT_keysetup(&ctx,key.data(),key.size()*8);//Wouldn't *8 cause a problem? unsigned char is ideally uint8_t and u32is the type of that argument.\n+            },\n+            [&] {\n+\t    \t      uint64_t iv=fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+              chacha20.SetIV(iv);\n+\t\t//ECRYPT_ivsetup(&ctx,(u8 *)&iv); //actual type is const u8 *, wouldn't passing uint64_t cause problems? of course it would, let's change DJB's function? -- critical!!!\n+            },\n+            [&] {\n+              uint64_t counter=fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+              chacha20.Seek(counter);\n+            },\n+            [&] {\n+\t    \t      uint32_t integralInRange=fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);//why 4096?\n+\t\t          std::vector<uint8_t> output(integralInRange);\n+              chacha20.Keystream(output.data(), output.size());\n+\t\t          std::vector<uint8_t> output2(integralInRange);\n+              ECRYPT_keystream_bytes(&ctx, output2.data(), output2.size()); //Arguments should ideally be (,u8*,u32) and we are ideally passing (,u8*, u32) --- ok \n+              if(output.data()!=NULL && output2.data()!=NULL){\n+                if(memcmp(output.data(),output2.data(),integralInRange)==0){\n+                    fprintf(stderr, \"--------bytes match---------\\n\");\n+                    std::string str(output.begin(), output.end());\n+                    fprintf(stderr, \"str: %s\\n\",str.c_str());\n+                    std::string str2(output2.begin(), output2.end());\n+                    fprintf(stderr, \"str2: %s\\n\",str2.c_str());\n+                    fprintf(stderr, \"-----------------------------\\n\");\n+                }else{\n+                    fprintf(stderr, \"--!--!-!---bytes don't match-!--!--!-\\n\");\n+                    std::string str(output.begin(), output.end());\n+                    fprintf(stderr, \"str: %s\\n\",str.c_str());\n+                    std::string str2(output2.begin(), output2.end());\n+                    fprintf(stderr, \"str2: %s\\n\",str2.c_str());\n+                    fprintf(stderr, \"--!---!---!---!----!--!--!--\\n\");\n+                }\n+              } \n+            \n+            },\n+            [&] {\n+\t\t            uint32_t integralInRange=fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                const std::vector<uint8_t> input = ConsumeFixedLengthByteVector(fuzzed_data_provider, output.size());\n+                chacha20.Crypt(input.data(), output.data(), input.size());\n+            });\n+    }\n+}"
      }
    ]
  }
]