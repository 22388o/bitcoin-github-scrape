[
  {
    "sha": "d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMTFhNThhMmQzOWI5MGRmZTI3ZDNhNjk2YjM5NzdiODdkN2M4MTEz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-04T22:31:21Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-13T15:20:42Z"
      },
      "message": "Remove not-used-anywhere scriptPrereq from SignSignature()",
      "tree": {
        "sha": "b1954fff1ab41312beccffa6ef5859fffe508df6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b1954fff1ab41312beccffa6ef5859fffe508df6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f290a649f91dca1f8e4fe01e09f20eea2e52cbd8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f290a649f91dca1f8e4fe01e09f20eea2e52cbd8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f290a649f91dca1f8e4fe01e09f20eea2e52cbd8"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 5,
      "deletions": 8
    },
    "files": [
      {
        "sha": "d0fb8303b2ddba32fd3bae420619f6a8c3c6c4f5",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
        "patch": "@@ -1525,7 +1525,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n }\n \n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType, CScript scriptPrereq)\n+bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n@@ -1534,18 +1534,15 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n \n     // Leave out the signature from the hash, since a signature can't sign itself.\n     // The checksig op will also drop the signatures from its hash.\n-    uint256 hash = SignatureHash(scriptPrereq + txout.scriptPubKey, txTo, nIn, nHashType);\n+    uint256 hash = SignatureHash(txout.scriptPubKey, txTo, nIn, nHashType);\n \n     if (!Solver(keystore, txout.scriptPubKey, hash, nHashType, txin.scriptSig))\n         return false;\n \n-    txin.scriptSig = scriptPrereq + txin.scriptSig;\n-\n     // Test solution\n     int nUnused = 0;\n-    if (scriptPrereq.empty())\n-        if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nUnused, 0, true))\n-            return false;\n+    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nUnused, 0, true))\n+        return false;\n \n     return true;\n }"
      },
      {
        "sha": "64171c7192b59cb51c58a5bf9550d29b4b979ae9",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
        "patch": "@@ -574,7 +574,7 @@ bool IsStandard(const CScript& scriptPubKey);\n bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n bool ExtractAddress(const CScript& scriptPubKey, CBitcoinAddress& addressRet);\n bool ExtractAddresses(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CBitcoinAddress>& addressRet, int& nRequiredRet);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL, CScript scriptPrereq=CScript());\n+bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType=0, bool fStrictOpEval=true);\n \n #endif"
      }
    ]
  },
  {
    "sha": "922e8e2929a2e78270868385aa46f96002fbcff3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjJlOGUyOTI5YTJlNzgyNzA4NjgzODVhYTQ2Zjk2MDAyZmJjZmYz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-05T02:40:52Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-13T15:22:23Z"
      },
      "message": "Replace OP_EVAL (BIP 12) with Pay-to-script-hash (BIP 16).",
      "tree": {
        "sha": "d7c7d2b3fe89bc18b8d0f1137980b9db16db3ae8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d7c7d2b3fe89bc18b8d0f1137980b9db16db3ae8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/922e8e2929a2e78270868385aa46f96002fbcff3",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/922e8e2929a2e78270868385aa46f96002fbcff3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/922e8e2929a2e78270868385aa46f96002fbcff3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/922e8e2929a2e78270868385aa46f96002fbcff3/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d11a58a2d39b90dfe27d3a696b3977b87d7c8113"
      }
    ],
    "stats": {
      "total": 1368,
      "additions": 824,
      "deletions": 544
    },
    "files": [
      {
        "sha": "d3a153b1e4ea6797ecf245432fe404c6094ecd74",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -255,7 +255,7 @@ class CBase58Data\n // base58-encoded bitcoin addresses\n // Public-key-hash-addresses have version 0 (or 192 testnet)\n // The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key\n-// Script-hash-addresses (OP_EVAL) have version 5 (or 196 testnet)\n+// Script-hash-addresses have version 5 (or 196 testnet)\n // The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script\n class CBitcoinAddress : public CBase58Data\n {\n@@ -296,7 +296,7 @@ class CBitcoinAddress : public CBase58Data\n                 fExpectTestNet = false;\n                 break;\n             case SCRIPT_ADDRESS:\n-                nExpectedSize = 20; // OP_EVAL, hash of CScript\n+                nExpectedSize = 20; // Hash of CScript\n                 fExpectTestNet = false;\n                 break;\n "
      },
      {
        "sha": "c1e4df4b6e5d3e21eea691d600d0dede897ede28",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 19,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -1008,41 +1008,62 @@ Value addmultisigaddress(const Array& params, bool fHelp)\n         strAccount = AccountFromValue(params[2]);\n \n     // Gather public keys\n-    if (keys.size() < nRequired)\n+    if (nRequired < 1 || keys.size() < nRequired)\n         throw runtime_error(\n-            strprintf(\"addmultisigaddress: wrong number of keys (got %d, need at least %d)\", keys.size(), nRequired));\n+            strprintf(\"wrong number of keys\"\n+                      \"(got %d, need at least %d)\", keys.size(), nRequired));\n     std::vector<CKey> pubkeys;\n     pubkeys.resize(keys.size());\n     for (int i = 0; i < keys.size(); i++)\n     {\n         const std::string& ks = keys[i].get_str();\n-        if (ks.size() == 130) // hex public key\n-            pubkeys[i].SetPubKey(ParseHex(ks));\n-        else if (ks.size() > 34) // base58-encoded\n-        {\n-            std::vector<unsigned char> vchPubKey;\n-            if (DecodeBase58(ks, vchPubKey))\n-                pubkeys[i].SetPubKey(vchPubKey);\n-            else\n-                throw runtime_error(\"Error base58 decoding key: \"+ks);\n-        }\n-        else // bitcoin address for key in this wallet\n+\n+        // Case 1: bitcoin address and we have full public key:\n+        CBitcoinAddress address(ks);\n+        if (address.IsValid())\n         {\n-            CBitcoinAddress address(ks);\n+            if (address.IsScript())\n+                throw runtime_error(\n+                    strprintf(\"%s is a pay-to-script address\",ks.c_str()));\n             if (!pwalletMain->GetKey(address, pubkeys[i]))\n                 throw runtime_error(\n-                    strprintf(\"addmultisigaddress: unknown address: %s\",ks.c_str()));\n+                    strprintf(\"no full public key for address %s\",ks.c_str()));\n+            continue;\n         }\n+\n+        // Case 2: hex public key\n+        if (IsHex(ks))\n+        {\n+            vector<unsigned char> vchPubKey = ParseHex(ks);\n+            if (vchPubKey.empty() || !pubkeys[i].SetPubKey(vchPubKey))\n+                throw runtime_error(\" Invalid public key: \"+ks);\n+            // There is approximately a zero percent chance a random\n+            // public key encoded as base58 will consist entirely\n+            // of hex characters.\n+            continue;\n+        }\n+        // Case 3: base58-encoded public key\n+        {\n+            vector<unsigned char> vchPubKey;\n+            if (!DecodeBase58(ks, vchPubKey))\n+                throw runtime_error(\"base58 decoding failed: \"+ks);\n+            if (vchPubKey.size() < 33) // 33 is size of a compressed public key\n+                throw runtime_error(\"decoded public key too short: \"+ks);\n+            if (pubkeys[i].SetPubKey(vchPubKey))\n+                continue;\n+        }\n+\n+        throw runtime_error(\" Invalid public key: \"+ks);\n     }\n \n-    // Construct using OP_EVAL\n+    // Construct using pay-to-script-hash:\n     CScript inner;\n     inner.SetMultisig(nRequired, pubkeys);\n \n     uint160 scriptHash = Hash160(inner);\n     CScript scriptPubKey;\n-    scriptPubKey.SetEval(inner);\n-    pwalletMain->AddCScript(scriptHash, inner);\n+    scriptPubKey.SetPayToScriptHash(inner);\n+    pwalletMain->AddCScript(inner);\n     CBitcoinAddress address;\n     address.SetScriptHash160(scriptHash);\n \n@@ -2681,7 +2702,7 @@ int CommandLineRPC(int argc, char *argv[])\n             string s = params[1].get_str();\n             Value v;\n             if (!read_string(s, v) || v.type() != array_type)\n-                throw runtime_error(\"addmultisigaddress: type mismatch \"+s);\n+                throw runtime_error(\"type mismatch \"+s);\n             params[1] = v.get_array();\n         }\n "
      },
      {
        "sha": "8ca783163bcba90179b47965aaaca2f662eecc43",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -942,7 +942,7 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n                 ssKey >> hash;\n                 CScript script;\n                 ssValue >> script;\n-                if (!pwallet->LoadCScript(hash, script))\n+                if (!pwallet->LoadCScript(script))\n                     return DB_CORRUPT;\n             }\n         }"
      },
      {
        "sha": "61d84ec0f224c6b87cae75dbfdc6826b8921bf58",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -36,10 +36,10 @@ bool CBasicKeyStore::AddKey(const CKey& key)\n     return true;\n }\n \n-bool CBasicKeyStore::AddCScript(const uint160 &hash, const CScript& redeemScript)\n+bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n {\n     CRITICAL_BLOCK(cs_KeyStore)\n-        mapScripts[hash] = redeemScript;\n+        mapScripts[Hash160(redeemScript)] = redeemScript;\n     return true;\n }\n "
      },
      {
        "sha": "1d068b4d75eeedb4c7ba337c651eac958fcb9ea4",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -25,7 +25,7 @@ class CKeyStore\n     virtual bool GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const;\n \n     // Support for BIP 0013 : see https://en.bitcoin.it/wiki/BIP_0013\n-    virtual bool AddCScript(const uint160 &hash, const CScript& redeemScript) =0;\n+    virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const uint160 &hash) const =0;\n     virtual bool GetCScript(const uint160 &hash, CScript& redeemScriptOut) const =0;\n \n@@ -87,7 +87,7 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n-    virtual bool AddCScript(const uint160 &hash, const CScript& redeemScript);\n+    virtual bool AddCScript(const CScript& redeemScript);\n     virtual bool HaveCScript(const uint160 &hash) const;\n     virtual bool GetCScript(const uint160 &hash, CScript& redeemScriptOut) const;\n };"
      },
      {
        "sha": "68583361dd05a4840019d46b447eead428b8d0dd",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 88,
        "deletions": 58,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -251,63 +251,83 @@ bool CTransaction::IsStandard() const\n     BOOST_FOREACH(const CTxIn& txin, vin)\n     {\n         // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n-        // in an OP_EVAL, which is 3 ~80-byte signatures, 3\n+        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n         // ~65-byte public keys, plus a few script ops.\n         if (txin.scriptSig.size() > 500)\n-            return error(\"nonstandard txin, size %d is too large\\n\", txin.scriptSig.size());\n+            return false;\n         if (!txin.scriptSig.IsPushOnly())\n-            return error(\"nonstandard txin (opcodes other than PUSH): %s\", txin.scriptSig.ToString().c_str());\n+            return false;\n     }\n     BOOST_FOREACH(const CTxOut& txout, vout)\n         if (!::IsStandard(txout.scriptPubKey))\n-            return error(\"nonstandard txout: %s\", txout.scriptPubKey.ToString().c_str());\n+            return false;\n     return true;\n }\n \n //\n // Check transaction inputs, and make sure any\n-// OP_EVAL transactions are evaluating IsStandard scripts\n+// pay-to-script-hash transactions are evaluating IsStandard scripts\n //\n // Why bother? To avoid denial-of-service attacks; an attacker\n-// can submit a standard DUP HASH... OP_EVAL transaction,\n-// which will get accepted into blocks. The script being\n-// EVAL'ed can be anything; an attacker could use a very\n+// can submit a standard HASH... OP_EQUAL transaction,\n+// which will get accepted into blocks. The redemption\n+// script can be anything; an attacker could use a very\n // expensive-to-check-upon-redemption script like:\n //   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n //\n-bool CTransaction::AreInputsStandard(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const\n+bool CTransaction::AreInputsStandard(const std::map<uint256, std::pair<CTxIndex, CTransaction> >& mapInputs) const\n {\n     if (fTestNet)\n         return true; // Allow non-standard on testnet\n \n     for (int i = 0; i < vin.size(); i++)\n     {\n         COutPoint prevout = vin[i].prevout;\n-        assert(mapInputs.count(prevout.hash) > 0);\n-        CTransaction& txPrev = mapInputs[prevout.hash].second;\n+\n+        std::map<uint256, std::pair<CTxIndex, CTransaction> >::const_iterator mi = mapInputs.find(prevout.hash);\n+        if (mi == mapInputs.end())\n+            return false;\n+\n+        const CTransaction& txPrev = (mi->second).second;\n         assert(prevout.n < txPrev.vout.size());\n \n         vector<vector<unsigned char> > vSolutions;\n         txnouttype whichType;\n         // get the scriptPubKey corresponding to this input:\n-        CScript& prevScript = txPrev.vout[prevout.n].scriptPubKey;\n+        const CScript& prevScript = txPrev.vout[prevout.n].scriptPubKey;\n         if (!Solver(prevScript, whichType, vSolutions))\n-            return error(\"nonstandard txin (spending nonstandard txout %s)\", prevScript.ToString().c_str());\n+            return false;\n         if (whichType == TX_SCRIPTHASH)\n         {\n             vector<vector<unsigned char> > stack;\n-            int nUnused;\n-            if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0, true, nUnused))\n+\n+            if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n+                return false;\n+            if (stack.empty())\n                 return false;\n             CScript subscript(stack.back().begin(), stack.back().end());\n             if (!::IsStandard(subscript))\n-                return error(\"nonstandard txin (nonstandard OP_EVAL subscript %s)\", subscript.ToString().c_str());\n+                return false;\n         }\n     }\n \n     return true;\n }\n \n+int\n+CTransaction::GetLegacySigOpCount() const\n+{\n+    int nSigOps = 0;\n+    BOOST_FOREACH(const CTxIn& txin, vin)\n+    {\n+        nSigOps += txin.scriptSig.GetSigOpCount(false);\n+    }\n+    BOOST_FOREACH(const CTxOut& txout, vout)\n+    {\n+        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n+    }\n+    return nSigOps;\n+}\n \n \n int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n@@ -483,7 +503,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n             return error(\"AcceptToMemoryPool() : FetchInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n \n-        // Check for non-standard OP_EVALs in inputs\n+        // Check for non-standard pay-to-script-hash in inputs\n         if (!AreInputsStandard(mapInputs))\n             return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n \n@@ -496,6 +516,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n                 *pfMissingInputs = true;\n             return error(\"AcceptToMemoryPool() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n+\n         // Checking ECDSA signatures is a CPU bottleneck, so to avoid denial-of-service\n         // attacks disallow transactions with more than one SigOp per 65 bytes.\n         // 65 bytes because that is the minimum size of an ECDSA signature\n@@ -967,8 +988,8 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n }\n \n bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inputs,\n-                                 map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n-                                 CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee)\n+                                 map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n+                                 const CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee)\n {\n     // Take over previous transactions' spent pointers\n     // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n@@ -989,33 +1010,31 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n \n             // If prev is coinbase, check that it's matured\n             if (txPrev.IsCoinBase())\n-                for (CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n+                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n                     if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                         return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n \n+            bool fStrictPayToScriptHash = true;\n+            if (fBlock)\n+            {\n+                // To avoid being on the short end of a block-chain split,\n+                // don't do secondary validation of pay-to-script-hash transactions\n+                // until blocks with timestamps after paytoscripthashtime:\n+                int64 nEvalSwitchTime = GetArg(\"paytoscripthashtime\", 1329264000); // Feb 15, 2012\n+                fStrictPayToScriptHash = (pindexBlock->nTime >= nEvalSwitchTime);\n+            }\n+            // if !fBlock, then always be strict-- don't accept\n+            // invalid-under-new-rules pay-to-script-hash transactions into\n+            // our memory pool (don't relay them, don't include them\n+            // in blocks we mine).\n+\n             // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n             // before the last blockchain checkpoint. This is safe because block merkle hashes are\n             // still computed and checked, and any change will be caught at the next checkpoint.\n             if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n             {\n-                bool fStrictOpEval = true;\n-                // This code should be removed when OP_EVAL has\n-                // a majority of hashing power on the network.\n-                if (fBlock)\n-                {\n-                    // To avoid being on the short end of a block-chain split,\n-                    // interpret OP_EVAL as a NO_OP until blocks with timestamps\n-                    // after opevaltime:\n-                    int64 nEvalSwitchTime = GetArg(\"opevaltime\", 1328054400); // Feb 1, 2012\n-                    fStrictOpEval = (pindexBlock->nTime >= nEvalSwitchTime);\n-                }\n-                // if !fBlock, then always be strict-- don't accept\n-                // invalid-under-new-rules OP_EVAL transactions into\n-                // our memory pool (don't relay them, don't include them\n-                // in blocks we mine).\n-\n                 // Verify signature\n-                if (!VerifySignature(txPrev, *this, i, nSigOpsRet, fStrictOpEval))\n+                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n             }\n \n@@ -1030,6 +1049,9 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n             if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                 return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n \n+            // Calculate sigOps accurately:\n+            nSigOpsRet += txPrev.vout[prevout.n].scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n+\n             // Mark outpoints as spent\n             txindex.vSpent[prevout.n] = posThisTx;\n \n@@ -1090,8 +1112,7 @@ bool CTransaction::ClientConnectInputs()\n                 return false;\n \n             // Verify signature\n-            int nUnused = 0;\n-            if (!VerifySignature(txPrev, *this, i, nUnused, false))\n+            if (!VerifySignature(txPrev, *this, i, true, 0))\n                 return error(\"ConnectInputs() : VerifySignature failed\");\n \n             ///// this is redundant with the mapNextTx stuff, not sure which I want to get rid of\n@@ -1158,10 +1179,17 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n         map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n         if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs))\n             return false;\n-        if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, nFees, true, false, nSigOps))\n+\n+        int nTxOps = 0;\n+        if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, nFees, true, false, nTxOps))\n             return false;\n+\n+        nSigOps += nTxOps;\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n             return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+        // There is a different MAX_BLOCK_SIGOPS check in AcceptBlock();\n+        // a block must satisfy both to make it into the best-chain\n+        // (AcceptBlock() is always called before ConnectBlock())\n     }\n \n     // Write queued txindex changes\n@@ -1441,19 +1469,13 @@ bool CBlock::CheckBlock() const\n         if (!tx.CheckTransaction())\n             return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n \n-    // This code should be removed when a compatibility-breaking block chain split has passed.\n-    // Compatibility check for old clients that counted sigops differently:\n+    // Pre-pay-to-script-hash (before version 0.6), this is how sigops\n+    // were counted; there is another check in ConnectBlock when\n+    // transaction inputs are fetched to count pay-to-script-hash sigops:\n     int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n-        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        {\n-            nSigOps += txin.scriptSig.GetSigOpCount();\n-        }\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-        {\n-            nSigOps += txout.scriptPubKey.GetSigOpCount();\n-        }\n+        nSigOps += tx.GetLegacySigOpCount();\n     }\n     if (nSigOps > MAX_BLOCK_SIGOPS)\n         return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n@@ -2983,7 +3005,8 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         map<uint256, CTxIndex> mapTestPool;\n         uint64 nBlockSize = 1000;\n         uint64 nBlockTx = 0;\n-        int nBlockSigOps = 100;\n+        int nBlockSigOps1 = 100; // pre-0.6 count of sigOps\n+        int nBlockSigOps2 = 100; // post-0.6 count of sigOps\n         while (!mapPriority.empty())\n         {\n             // Take highest priority transaction off priority queue\n@@ -2996,6 +3019,11 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n                 continue;\n \n+            // Legacy limits on sigOps:\n+            int nTxSigOps1 = tx.GetLegacySigOpCount();\n+            if (nBlockSigOps1 + nTxSigOps1 >= MAX_BLOCK_SIGOPS)\n+                continue;\n+\n             // Transaction fee required depends on block size\n             bool fAllowFree = (nBlockSize + nTxSize < 4000 || CTransaction::AllowFree(dPriority));\n             int64 nMinFee = tx.GetMinFee(nBlockSize, fAllowFree, GMF_BLOCK);\n@@ -3006,18 +3034,20 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n             if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs))\n                 continue;\n-            int nTxSigOps = 0;\n-            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, nFees, false, true, nTxSigOps, nMinFee))\n+\n+            int nTxSigOps2 = 0;\n+            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, nFees, false, true, nTxSigOps2, nMinFee))\n                 continue;\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            if (nBlockSigOps2 + nTxSigOps2 >= MAX_BLOCK_SIGOPS)\n                 continue;\n             swap(mapTestPool, mapTestPoolTmp);\n \n             // Added\n             pblock->vtx.push_back(tx);\n             nBlockSize += nTxSize;\n-            nBlockSigOps += nTxSigOps;\n             ++nBlockTx;\n+            nBlockSigOps1 += nTxSigOps1;\n+            nBlockSigOps2 += nTxSigOps2;\n \n             // Add transactions that depend on this one to the priority queue\n             uint256 hash = tx.GetHash();\n@@ -3065,10 +3095,10 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n     ++nExtraNonce;\n     pblock->vtx[0].vin[0].scriptSig = CScript() << pblock->nTime << CBigNum(nExtraNonce);\n \n-    // Put \"OP_EVAL\" in the coinbase so everybody can tell when\n+    // Put \"/P2SH/\" in the coinbase so everybody can tell when\n     // a majority of miners support it\n-    const char* pOpEvalName = GetOpName(OP_EVAL);\n-    pblock->vtx[0].vin[0].scriptSig += CScript() << std::vector<unsigned char>(pOpEvalName, pOpEvalName+strlen(pOpEvalName));\n+    const char* pszP2SH = \"/P2SH/\";\n+    pblock->vtx[0].vin[0].scriptSig += CScript() << std::vector<unsigned char>(pszP2SH, pszP2SH+strlen(pszP2SH));\n     assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n \n     pblock->hashMerkleRoot = pblock->BuildMerkleTree();"
      },
      {
        "sha": "6f71fd20046ba8c1918e93b7686c90fc9ede95d9",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -503,7 +503,9 @@ class CTransaction\n     }\n \n     bool IsStandard() const;\n-    bool AreInputsStandard(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const;\n+    bool AreInputsStandard(const std::map<uint256, std::pair<CTxIndex, CTransaction> >& mapInputs) const;\n+\n+    int GetLegacySigOpCount() const;\n \n     int64 GetValueOut() const\n     {\n@@ -636,8 +638,8 @@ class CTransaction\n     bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n                      bool fBlock, bool fMiner, std::map<uint256, std::pair<CTxIndex, CTransaction> >& inputsRet);\n     bool ConnectInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > inputs,\n-                       std::map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n-                       CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee=0);\n+                       std::map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n+                       const CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee=0);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);"
      },
      {
        "sha": "66962d78b3fba8d49df5831061cdbb4456906301",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 136,
        "deletions": 102,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -203,10 +203,8 @@ const char* GetOpName(opcodetype opcode)\n     case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n     case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n \n-    // meta\n-    case OP_EVAL                   : return \"OP_EVAL\";\n-\n     // expanson\n+    case OP_NOP1                   : return \"OP_NOP1\";\n     case OP_NOP2                   : return \"OP_NOP2\";\n     case OP_NOP3                   : return \"OP_NOP3\";\n     case OP_NOP4                   : return \"OP_NOP4\";\n@@ -220,7 +218,6 @@ const char* GetOpName(opcodetype opcode)\n \n \n     // template matching params\n-    case OP_SCRIPTHASH             : return \"OP_SCRIPTHASH\";\n     case OP_PUBKEYHASH             : return \"OP_PUBKEYHASH\";\n     case OP_PUBKEY                 : return \"OP_PUBKEY\";\n \n@@ -230,26 +227,20 @@ const char* GetOpName(opcodetype opcode)\n     }\n }\n \n-//\n-// Returns true if script is valid.\n-//\n-bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType,\n-                     CScript::const_iterator pbegincodehash, CScript::const_iterator pendcodehash, int& nOpCount, int& nSigOpCount,\n-                     bool fStrictOpEval, int nRecurseDepth)\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     CAutoBN_CTX pctx;\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n+    CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n     vector<bool> vfExec;\n     vector<valtype> altstack;\n     if (script.size() > 10000)\n         return false;\n+    int nOpCount = 0;\n \n-    // Limit OP_EVAL recursion\n-    if (nRecurseDepth > 2)\n-        return false;\n \n     try\n     {\n@@ -321,7 +312,7 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                 // Control\n                 //\n                 case OP_NOP:\n-                case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n+                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                 case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                 break;\n \n@@ -917,13 +908,12 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                     //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n \n                     // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pendcodehash);\n+                    CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signature, since there's no way for a signature to sign itself\n                     scriptCode.FindAndDelete(CScript(vchSig));\n \n                     bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n-                    nSigOpCount++;\n \n                     popstack(stack);\n                     popstack(stack);\n@@ -967,7 +957,7 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                         return false;\n \n                     // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pendcodehash);\n+                    CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signatures, since there's no way for a signature to sign itself\n                     for (int k = 0; k < nSigsCount; k++)\n@@ -990,7 +980,6 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                         }\n                         ikey++;\n                         nKeysCount--;\n-                        nSigOpCount++;\n \n                         // If there are more signatures left than keys left,\n                         // then too many signatures have failed\n@@ -1012,32 +1001,6 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                 }\n                 break;\n \n-                case OP_EVAL:\n-                {\n-                    if (!fStrictOpEval)\n-                        break; // Act as a NO_OP\n-\n-\n-                    // Evaluate the top item on the stack as a Script\n-                    // [serialized script ] -- [result(s) of executing script]\n-                    if (stack.size() < 1)\n-                        return false;\n-                    valtype& vchScript = stacktop(-1);\n-                    CScript subscript(vchScript.begin(), vchScript.end());\n-                    popstack(stack);\n-\n-                    // Codeseparators not allowed; they don't make sense 'inside' an OP_EVAL, because\n-                    // their purpose is to change which parts of the scriptPubKey script is copied\n-                    // and signed by OP_CHECKSIG, but OP_EVAl'ed code is in the scriptSig, not the scriptPubKey.\n-                    if (subscript.Find(OP_CODESEPARATOR))\n-                        return false;\n-\n-                    if (!EvalScriptInner(stack, subscript, txTo, nIn, nHashType,\n-                                         pbegincodehash, pendcodehash, nOpCount, nSigOpCount, fStrictOpEval, nRecurseDepth+1))\n-                        return false;\n-                }\n-                break;\n-\n                 default:\n                     return false;\n             }\n@@ -1059,18 +1022,6 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n     return true;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script,\n-                const CTransaction& txTo, unsigned int nIn, int nHashType,\n-                bool fStrictOpEval, int& nSigOpCountRet)\n-{\n-    CScript::const_iterator pbegincodehash = script.begin();\n-    CScript::const_iterator pendcodehash = script.end();\n-\n-    int nOpCount = 0;\n-    return EvalScriptInner(stack, script, txTo, nIn, nHashType, pbegincodehash, pendcodehash,\n-                           nOpCount, nSigOpCountRet, fStrictOpEval, 0);\n-}\n-\n \n \n \n@@ -1186,10 +1137,16 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n \n         // Sender provides N pubkeys, receivers provides M signatures\n         mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n+    }\n \n-        // Sender provides script hash, receiver provides script and\n-        // as many signatures as required to satisfy script\n-        mTemplates.insert(make_pair(TX_SCRIPTHASH, CScript() << OP_DUP << OP_HASH160 << OP_SCRIPTHASH << OP_EQUALVERIFY << OP_EVAL));\n+    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n+    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n+    if (scriptPubKey.IsPayToScriptHash())\n+    {\n+        typeRet = TX_SCRIPTHASH;\n+        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n+        vSolutionsRet.push_back(hashBytes);\n+        return true;\n     }\n \n     // Scan templates\n@@ -1253,12 +1210,6 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n                     break;\n                 vSolutionsRet.push_back(vch1);\n             }\n-            else if (opcode2 == OP_SCRIPTHASH)\n-            {\n-                if (vch1.size() != sizeof(uint160))\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n             else if (opcode2 == OP_SMALLINTEGER)\n             {   // Single-byte small integer pushed onto vSolutions\n                 if (opcode1 == OP_0 ||\n@@ -1319,21 +1270,21 @@ bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint2\n \n //\n // Sign scriptPubKey with private keys stored in keystore, given transaction hash and hash type.\n-// Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed).\n-// Returns true if scriptPubKey could be completely satisified.\n+// Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n+// unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n+// Returns false if scriptPubKey could not be completely satisified.\n //\n-bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)\n+bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n+                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n {\n     scriptSigRet.clear();\n \n-    txnouttype whichType;\n     vector<valtype> vSolutions;\n-    if (!Solver(scriptPubKey, whichType, vSolutions))\n+    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n         return false;\n \n     CBitcoinAddress address;\n-    CScript subscript;\n-    switch (whichType)\n+    switch (whichTypeRet)\n     {\n     case TX_NONSTANDARD:\n         return false;\n@@ -1350,21 +1301,15 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n             keystore.GetPubKey(address, vch);\n             scriptSigRet << vch;\n         }\n-        break;\n+        return true;\n     case TX_SCRIPTHASH:\n-        if (!keystore.GetCScript(uint160(vSolutions[0]), subscript))\n-            return false;\n-        if (!Solver(keystore, subscript, hash, nHashType, scriptSigRet))\n-            return false;\n-        if (hash != 0)\n-            // static_cast to get vector.operator<< instead of CScript.operator<<\n-            scriptSigRet << static_cast<valtype>(subscript); // signatures AND serialized script\n-        break;\n+        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n+\n     case TX_MULTISIG:\n         scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n         return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n     }\n-    return true;\n+    return false;\n }\n \n \n@@ -1503,25 +1448,40 @@ bool ExtractAddresses(const CScript& scriptPubKey, txnouttype& typeRet, vector<C\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet,\n-                  int nHashType, bool fStrictOpEval)\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                  bool fValidatePayToScriptHash, int nHashType)\n {\n-    vector<vector<unsigned char> > stack;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType, fStrictOpEval, nSigOpCountRet))\n+    vector<vector<unsigned char> > stack, stackCopy;\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n         return false;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType, fStrictOpEval, nSigOpCountRet))\n+    if (fValidatePayToScriptHash)\n+        stackCopy = stack;\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n         return false;\n     if (stack.empty())\n         return false;\n-    bool fResult = CastToBool(stack.back());\n \n-    // This code should be removed when a compatibility-breaking block chain split has passed.\n-    // Special check for OP_EVAL backwards-compatibility: if scriptPubKey or scriptSig contains\n-    // OP_EVAL, then result must be identical if OP_EVAL is treated as a no-op:\n-    if (fResult && fStrictOpEval && (scriptPubKey.Find(OP_EVAL) || scriptSig.Find(OP_EVAL)))\n-        return VerifyScript(scriptSig, scriptPubKey, txTo, nIn, nSigOpCountRet, nHashType, false);\n+    if (CastToBool(stack.back()) == false)\n+        return false;\n+\n+    // Additional validation for spend-to-script-hash transactions:\n+    if (fValidatePayToScriptHash && scriptPubKey.IsPayToScriptHash())\n+    {\n+        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n+            return false;            // or validation fails\n+\n+        const valtype& pubKeySerialized = stackCopy.back();\n+        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n+        popstack(stackCopy);\n \n-    return fResult;\n+        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n+            return false;\n+        if (stackCopy.empty())\n+            return false;\n+        return CastToBool(stackCopy.back());\n+    }\n+\n+    return true;\n }\n \n \n@@ -1536,19 +1496,36 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     // The checksig op will also drop the signatures from its hash.\n     uint256 hash = SignatureHash(txout.scriptPubKey, txTo, nIn, nHashType);\n \n-    if (!Solver(keystore, txout.scriptPubKey, hash, nHashType, txin.scriptSig))\n+    txnouttype whichType;\n+    if (!Solver(keystore, txout.scriptPubKey, hash, nHashType, txin.scriptSig, whichType))\n         return false;\n \n+    if (whichType == TX_SCRIPTHASH)\n+    {\n+        // Solver returns the subscript that need to be evaluated;\n+        // the final scriptSig is the signatures from that\n+        // and then the serialized subscript:\n+        CScript subscript = txin.scriptSig;\n+\n+        // Recompute txn hash using subscript in place of scriptPubKey:\n+        uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n+        txnouttype subType;\n+        if (!Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType))\n+            return false;\n+        if (subType == TX_SCRIPTHASH)\n+            return false;\n+        txin.scriptSig << static_cast<valtype>(subscript); // Append serialized subscript\n+    }\n+\n     // Test solution\n-    int nUnused = 0;\n-    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nUnused, 0, true))\n+    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, true, 0))\n         return false;\n \n     return true;\n }\n \n \n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType, bool fStrictOpEval)\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n@@ -1559,17 +1536,74 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (txin.prevout.hash != txFrom.GetHash())\n         return false;\n \n-    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nSigOpCountRet, nHashType, fStrictOpEval))\n+    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, nHashType))\n         return false;\n \n     return true;\n }\n \n+int CScript::GetSigOpCount(bool fAccurate) const\n+{\n+    int n = 0;\n+    const_iterator pc = begin();\n+    opcodetype lastOpcode = OP_INVALIDOPCODE;\n+    while (pc < end())\n+    {\n+        opcodetype opcode;\n+        if (!GetOp(pc, opcode))\n+            break;\n+        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n+            n++;\n+        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n+        {\n+            if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)\n+                n += DecodeOP_N(lastOpcode);\n+            else\n+                n += 20;\n+        }\n+        lastOpcode = opcode;\n+    }\n+    return n;\n+}\n+\n+int CScript::GetSigOpCount(const CScript& scriptSig) const\n+{\n+    if (!IsPayToScriptHash())\n+        return GetSigOpCount(true);\n+\n+    // This is a pay-to-script-hash scriptPubKey;\n+    // get the last item that the scriptSig\n+    // pushes onto the stack:\n+    const_iterator pc = scriptSig.begin();\n+    vector<unsigned char> data;\n+    while (pc < scriptSig.end())\n+    {\n+        opcodetype opcode;\n+        if (!scriptSig.GetOp(pc, opcode, data))\n+            return 0;\n+        if (opcode > OP_16)\n+            return 0;\n+    }\n+\n+    /// ... and return it's opcount:\n+    CScript subscript(data.begin(), data.end());\n+    return subscript.GetSigOpCount(true);\n+}\n+\n+bool CScript::IsPayToScriptHash() const\n+{\n+    // Extra-fast test for pay-to-script-hash CScripts:\n+    return (this->size() == 23 &&\n+            this->at(0) == OP_HASH160 &&\n+            this->at(1) == 0x14 &&\n+            this->at(22) == OP_EQUAL);\n+}\n+\n void CScript::SetBitcoinAddress(const CBitcoinAddress& address)\n {\n     this->clear();\n     if (address.IsScript())\n-        *this << OP_DUP << OP_HASH160 << address.GetHash160() << OP_EQUALVERIFY << OP_EVAL;\n+        *this << OP_HASH160 << address.GetHash160() << OP_EQUAL;\n     else\n         *this << OP_DUP << OP_HASH160 << address.GetHash160() << OP_EQUALVERIFY << OP_CHECKSIG;\n }\n@@ -1584,10 +1618,10 @@ void CScript::SetMultisig(int nRequired, const std::vector<CKey>& keys)\n     *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n }\n \n-void CScript::SetEval(const CScript& subscript)\n+void CScript::SetPayToScriptHash(const CScript& subscript)\n {\n     assert(!subscript.empty());\n     uint160 subscriptHash = Hash160(subscript);\n     this->clear();\n-    *this << OP_DUP << OP_HASH160 << subscriptHash << OP_EQUALVERIFY << OP_EVAL;\n+    *this << OP_HASH160 << subscriptHash << OP_EQUAL;\n }"
      },
      {
        "sha": "63f9f9353a922f5209b17f0bacc76e07aa923daf",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 16,
        "deletions": 26,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -158,10 +158,8 @@ enum opcodetype\n     OP_CHECKMULTISIG,\n     OP_CHECKMULTISIGVERIFY,\n \n-    // meta\n-    OP_EVAL, // Was OP_NOP1\n-\n     // expansion\n+    OP_NOP1,\n     OP_NOP2,\n     OP_NOP3,\n     OP_NOP4,\n@@ -177,7 +175,6 @@ enum opcodetype\n     // template matching params\n     OP_SMALLINTEGER = 0xfa,\n     OP_PUBKEYS = 0xfb,\n-    OP_SCRIPTHASH = 0xfc,\n     OP_PUBKEYHASH = 0xfd,\n     OP_PUBKEY = 0xfe,\n \n@@ -485,24 +482,18 @@ class CScript : public std::vector<unsigned char>\n         return nFound;\n     }\n \n-    // This method should be removed when a compatibility-breaking block chain split has passed.\n-    // Compatibility method for old clients that count sigops differently:\n-    int GetSigOpCount() const\n-    {\n-        int n = 0;\n-        const_iterator pc = begin();\n-        while (pc < end())\n-        {\n-            opcodetype opcode;\n-            if (!GetOp(pc, opcode))\n-                break;\n-            if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n-                n++;\n-            else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n-                n += 20;\n-        }\n-        return n;\n-    }\n+    // Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs\n+    // as 20 sigops. With pay-to-script-hash, that changed:\n+    // CHECKMULTISIGs serialized in scriptSigs are\n+    // counted more accurately, assuming they are of the form\n+    //  ... OP_N CHECKMULTISIG ...\n+    int GetSigOpCount(bool fAccurate) const;\n+\n+    // Accurately count sigOps, including sigOps in\n+    // pay-to-script-hash transactions:\n+    int GetSigOpCount(const CScript& scriptSig) const;\n+\n+    bool IsPayToScriptHash() const;\n \n     // Called by CTransaction::IsStandard\n     bool IsPushOnly() const\n@@ -526,7 +517,7 @@ class CScript : public std::vector<unsigned char>\n         SetBitcoinAddress(CBitcoinAddress(vchPubKey));\n     }\n     void SetMultisig(int nRequired, const std::vector<CKey>& keys);\n-    void SetEval(const CScript& subscript);\n+    void SetPayToScriptHash(const CScript& subscript);\n \n \n     void PrintHex() const\n@@ -567,14 +558,13 @@ class CScript : public std::vector<unsigned char>\n \n \n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType, bool fStrictOpEval, int& nSigOpCountRet);\n-\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType);\n bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n bool IsStandard(const CScript& scriptPubKey);\n bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n bool ExtractAddress(const CScript& scriptPubKey, CBitcoinAddress& addressRet);\n bool ExtractAddresses(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CBitcoinAddress>& addressRet, int& nRequiredRet);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType=0, bool fStrictOpEval=true);\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType);\n \n #endif"
      },
      {
        "sha": "56b18044b81eeb1af7b75ae4c6564246c3dc9266",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 12,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -20,8 +20,8 @@ using namespace boost::assign;\n typedef vector<unsigned char> valtype;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCount,\n-                         int nHashType, bool fStrictOpEval);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                         bool fValidatePayToScriptHash, int nHashType);\n \n BOOST_AUTO_TEST_SUITE(multisig_tests)\n \n@@ -75,25 +75,24 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n \n     vector<CKey> keys;\n     CScript s;\n-    int nUnused = 0;\n \n     // Test a AND b:\n     keys.clear();\n     keys += key[0],key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0, true));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, true, 0));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0, true), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, 0), strprintf(\"a&b 1: %d\", i));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0, true), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, 0), strprintf(\"a&b 2: %d\", i));\n     }\n \n     // Test a OR b:\n@@ -103,16 +102,16 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, true, 0), strprintf(\"a|b: %d\", i));\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0), strprintf(\"a|b: %d\", i));\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n \n \n     for (int i = 0; i < 4; i++)\n@@ -122,9 +121,9 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, nUnused, 0, true), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, true, 0), strprintf(\"escrow 1: %d %d\", i, j));\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, nUnused, 0, true), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, true, 0), strprintf(\"escrow 2: %d %d\", i, j));\n         }\n }\n "
      },
      {
        "sha": "87462f765bb8bfc1472a29ac4113fa4324a4fb77",
        "filename": "src/test/rpc_tests.cpp",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -0,0 +1,74 @@\n+#include <boost/test/unit_test.hpp>\n+#include <boost/foreach.hpp>\n+\n+#include \"base58.h\"\n+#include \"util.h\"\n+#include \"json/json_spirit_reader_template.h\"\n+#include \"json/json_spirit_writer_template.h\"\n+#include \"json/json_spirit_utils.h\"\n+\n+using namespace std;\n+using namespace json_spirit;\n+\n+typedef Value(*rpcfn_type)(const Array& params, bool fHelp);\n+extern map<string, rpcfn_type> mapCallTable;\n+\n+BOOST_AUTO_TEST_SUITE(rpc_tests)\n+\n+static Array\n+createArgs(int nRequired, const char* address1=NULL, const char* address2=NULL)\n+{\n+    Array result;\n+    result.push_back(nRequired);\n+    Array addresses;\n+    if (address1) addresses.push_back(address1);\n+    if (address2) addresses.push_back(address1);\n+    result.push_back(addresses);\n+    return result;\n+}\n+\n+// This can be removed this when addmultisigaddress is enabled on main net:\n+struct TestNetFixture\n+{\n+    TestNetFixture() { fTestNet = true; }\n+    ~TestNetFixture() { fTestNet = false; }\n+};\n+\n+BOOST_FIXTURE_TEST_CASE(rpc_addmultisig, TestNetFixture)\n+{\n+    rpcfn_type addmultisig = mapCallTable[\"addmultisigaddress\"];\n+\n+    // old, 65-byte-long:\n+    const char* address1Hex = \"0434e3e09f49ea168c5bbf53f877ff4206923858aab7c7e1df25bc263978107c95e35065a27ef6f1b27222db0ec97e0e895eaca603d3ee0d4c060ce3d8a00286c8\";\n+    // new, compressed:\n+    const char* address2Hex = \"0388c2037017c62240b6b72ac1a2a5f94da790596ebd06177c8572752922165cb4\";\n+\n+    Value v;\n+    CBitcoinAddress address;\n+    BOOST_CHECK_NO_THROW(v = addmultisig(createArgs(1, address1Hex), false));\n+    address.SetString(v.get_str());\n+    BOOST_CHECK(address.IsValid() && address.IsScript());\n+\n+    BOOST_CHECK_NO_THROW(v = addmultisig(createArgs(1, address1Hex, address2Hex), false));\n+    address.SetString(v.get_str());\n+    BOOST_CHECK(address.IsValid() && address.IsScript());\n+\n+    BOOST_CHECK_NO_THROW(v = addmultisig(createArgs(2, address1Hex, address2Hex), false));\n+    address.SetString(v.get_str());\n+    BOOST_CHECK(address.IsValid() && address.IsScript());\n+\n+    BOOST_CHECK_THROW(addmultisig(createArgs(0), false), runtime_error);\n+    BOOST_CHECK_THROW(addmultisig(createArgs(1), false), runtime_error);\n+    BOOST_CHECK_THROW(addmultisig(createArgs(2, address1Hex), false), runtime_error);\n+\n+    BOOST_CHECK_THROW(addmultisig(createArgs(1, \"\"), false), runtime_error);\n+    BOOST_CHECK_THROW(addmultisig(createArgs(1, \"NotAValidPubkey\"), false), runtime_error);\n+\n+    string short1(address1Hex, address1Hex+sizeof(address1Hex)-2); // last byte missing\n+    BOOST_CHECK_THROW(addmultisig(createArgs(2, short1.c_str()), false), runtime_error);\n+\n+    string short2(address1Hex+2, address1Hex+sizeof(address1Hex)); // first byte missing\n+    BOOST_CHECK_THROW(addmultisig(createArgs(2, short2.c_str()), false), runtime_error);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "aed3e23319ac6df1dbcd533ebb38fe1c6f9bde46",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "added",
        "additions": 310,
        "deletions": 0,
        "changes": 310,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -0,0 +1,310 @@\n+#include <boost/assert.hpp>\n+#include <boost/assign/list_of.hpp>\n+#include <boost/assign/list_inserter.hpp>\n+#include <boost/assign/std/vector.hpp>\n+#include <boost/test/unit_test.hpp>\n+#include <boost/foreach.hpp>\n+\n+#include \"../main.h\"\n+#include \"../script.h\"\n+#include \"../wallet.h\"\n+\n+using namespace std;\n+\n+// Test routines internal to script.cpp:\n+extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                         bool fValidatePayToScriptHash, int nHashType);\n+\n+// Helpers:\n+static std::vector<unsigned char>\n+Serialize(const CScript& s)\n+{\n+    std::vector<unsigned char> sSerialized(s);\n+    return sSerialized;\n+}\n+\n+static bool\n+Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict)\n+{\n+    // Create dummy to/from transactions:\n+    CTransaction txFrom;\n+    txFrom.vout.resize(1);\n+    txFrom.vout[0].scriptPubKey = scriptPubKey;\n+\n+    CTransaction txTo;\n+    txTo.vin.resize(1);\n+    txTo.vout.resize(1);\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    txTo.vin[0].scriptSig = scriptSig;\n+    txTo.vout[0].nValue = 1;\n+\n+    return VerifyScript(scriptSig, scriptPubKey, txTo, 0, fStrict, 0);\n+}\n+\n+\n+BOOST_AUTO_TEST_SUITE(script_P2SH_tests)\n+\n+BOOST_AUTO_TEST_CASE(sign)\n+{\n+    // Pay-to-script-hash looks like this:\n+    // scriptSig:    <sig> <sig...> <serialized_script>\n+    // scriptPubKey: HASH160 <hash> EQUAL\n+\n+    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n+    CBasicKeyStore keystore;\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+    }\n+\n+    // 8 Scripts: checking all combinations of\n+    // different keys, straight/P2SH, pubkey/pubkeyhash\n+    CScript standardScripts[4];\n+    standardScripts[0] << key[0].GetPubKey() << OP_CHECKSIG;\n+    standardScripts[1].SetBitcoinAddress(key[1].GetPubKey());\n+    standardScripts[2] << key[1].GetPubKey() << OP_CHECKSIG;\n+    standardScripts[3].SetBitcoinAddress(key[2].GetPubKey());\n+    CScript evalScripts[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        keystore.AddCScript(standardScripts[i]);\n+        evalScripts[i].SetPayToScriptHash(standardScripts[i]);\n+    }\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(8);\n+    for (int i = 0; i < 4; i++)\n+    {\n+        txFrom.vout[i].scriptPubKey = evalScripts[i];\n+        txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n+    }\n+    BOOST_CHECK(txFrom.IsStandard());\n+\n+    CTransaction txTo[8]; // Spending transactions\n+    for (int i = 0; i < 8; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n+    }\n+    for (int i = 0; i < 8; i++)\n+    {\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+    }\n+    // All of the above should be OK, and the txTos have valid signatures\n+    // Check to make sure signature verification fails if we use the wrong ScriptSig:\n+    for (int i = 0; i < 8; i++)\n+        for (int j = 0; j < 8; j++)\n+        {\n+            CScript sigSave = txTo[i].vin[0].scriptSig;\n+            txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n+            bool sigOK = VerifySignature(txFrom, txTo[i], 0, true, 0);\n+            if (i == j)\n+                BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n+            else\n+                BOOST_CHECK_MESSAGE(!sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n+            txTo[i].vin[0].scriptSig = sigSave;\n+        }\n+}\n+\n+BOOST_AUTO_TEST_CASE(norecurse)\n+{\n+    // Make sure only the outer pay-to-script-hash does the\n+    // extra-validation thing:\n+    CScript invalidAsScript;\n+    invalidAsScript << OP_INVALIDOPCODE << OP_INVALIDOPCODE;\n+\n+    CScript p2sh;\n+    p2sh.SetPayToScriptHash(invalidAsScript);\n+\n+    CScript scriptSig;\n+    scriptSig << Serialize(invalidAsScript);\n+\n+    // Should not verify, because it will try to execute OP_INVALIDOPCODE\n+    BOOST_CHECK(!Verify(scriptSig, p2sh, true));\n+\n+    // Try to recurse, and verification should succeed because\n+    // the inner HASH160 <> EQUAL should only check the hash:\n+    CScript p2sh2;\n+    p2sh2.SetPayToScriptHash(p2sh);\n+    CScript scriptSig2;\n+    scriptSig2 << Serialize(invalidAsScript) << Serialize(p2sh);\n+\n+    BOOST_CHECK(Verify(scriptSig2, p2sh2, true));\n+}\n+\n+BOOST_AUTO_TEST_CASE(set)\n+{\n+    // Test the CScript::Set* methods\n+    CBasicKeyStore keystore;\n+    CKey key[4];\n+    std::vector<CKey> keys;\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+        keys.push_back(key[i]);\n+    }\n+\n+    CScript inner[4];\n+    inner[0].SetBitcoinAddress(key[0].GetPubKey());\n+    inner[1].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+2));\n+    inner[2].SetMultisig(1, std::vector<CKey>(keys.begin(), keys.begin()+2));\n+    inner[3].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+3));\n+\n+    CScript outer[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        outer[i].SetPayToScriptHash(inner[i]);\n+        keystore.AddCScript(inner[i]);\n+    }\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(4);\n+    for (int i = 0; i < 4; i++)\n+    {\n+        txFrom.vout[i].scriptPubKey = outer[i];\n+    }\n+    BOOST_CHECK(txFrom.IsStandard());\n+\n+    CTransaction txTo[4]; // Spending transactions\n+    for (int i = 0; i < 4; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+        txTo[i].vout[0].scriptPubKey = inner[i];\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n+    }\n+    for (int i = 0; i < 4; i++)\n+    {\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(txTo[i].IsStandard(), strprintf(\"txTo[%d].IsStandard\", i));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(is)\n+{\n+    // Test CScript::IsPayToScriptHash()\n+    uint160 dummy;\n+    CScript p2sh;\n+    p2sh << OP_HASH160 << dummy << OP_EQUAL;\n+    BOOST_CHECK(p2sh.IsPayToScriptHash());\n+\n+    // Not considered pay-to-script-hash if using one of the OP_PUSHDATA opcodes:\n+    static const unsigned char direct[] =    { OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n+    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToScriptHash());\n+    static const unsigned char pushdata1[] = { OP_HASH160, OP_PUSHDATA1, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n+    BOOST_CHECK(!CScript(pushdata1, pushdata1+sizeof(pushdata1)).IsPayToScriptHash());\n+    static const unsigned char pushdata2[] = { OP_HASH160, OP_PUSHDATA2, 20,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n+    BOOST_CHECK(!CScript(pushdata2, pushdata2+sizeof(pushdata2)).IsPayToScriptHash());\n+    static const unsigned char pushdata4[] = { OP_HASH160, OP_PUSHDATA4, 20,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n+    BOOST_CHECK(!CScript(pushdata4, pushdata4+sizeof(pushdata4)).IsPayToScriptHash());\n+\n+    CScript not_p2sh;\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+\n+    not_p2sh.clear(); not_p2sh << OP_HASH160 << dummy << dummy << OP_EQUAL;\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+\n+    not_p2sh.clear(); not_p2sh << OP_NOP << dummy << OP_EQUAL;\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+\n+    not_p2sh.clear(); not_p2sh << OP_HASH160 << dummy << OP_CHECKSIG;\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n+}\n+\n+BOOST_AUTO_TEST_CASE(switchover)\n+{\n+    // Test switchover code\n+    CScript notValid;\n+    notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\n+    CScript scriptSig;\n+    scriptSig << Serialize(notValid);\n+\n+    CScript fund;\n+    fund.SetPayToScriptHash(notValid);\n+\n+\n+    // Validation should succeed under old rules (hash is correct):\n+    BOOST_CHECK(Verify(scriptSig, fund, false));\n+    // Fail under new:\n+    BOOST_CHECK(!Verify(scriptSig, fund, true));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AreInputsStandard)\n+{\n+    std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs;\n+    CBasicKeyStore keystore;\n+    CKey key[3];\n+    vector<CKey> keys;\n+    for (int i = 0; i < 3; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+        keys.push_back(key[i]);\n+    }\n+\n+    CTransaction txFrom;\n+    txFrom.vout.resize(5);\n+\n+    // First three are standard:\n+    CScript pay1; pay1.SetBitcoinAddress(key[0].GetPubKey());\n+    keystore.AddCScript(pay1);\n+    CScript payScriptHash1; payScriptHash1.SetPayToScriptHash(pay1);\n+    CScript pay1of3; pay1of3.SetMultisig(1, keys);\n+\n+    txFrom.vout[0].scriptPubKey = payScriptHash1;\n+    txFrom.vout[1].scriptPubKey = pay1;\n+    txFrom.vout[2].scriptPubKey = pay1of3;\n+\n+    // Last two non-standard:\n+    CScript empty;\n+    keystore.AddCScript(empty);\n+    txFrom.vout[3].scriptPubKey = empty;\n+    // Can't use SetPayToScriptHash, it checks for the empty Script. So:\n+    txFrom.vout[4].scriptPubKey << OP_HASH160 << Hash160(empty) << OP_EQUAL;\n+\n+    mapInputs[txFrom.GetHash()] = make_pair(CTxIndex(), txFrom);\n+\n+    CTransaction txTo;\n+    txTo.vout.resize(1);\n+    txTo.vout[0].scriptPubKey.SetBitcoinAddress(key[1].GetPubKey());\n+\n+    txTo.vin.resize(3);\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0));\n+    txTo.vin[1].prevout.n = 1;\n+    txTo.vin[1].prevout.hash = txFrom.GetHash();\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1));\n+    txTo.vin[2].prevout.n = 2;\n+    txTo.vin[2].prevout.hash = txFrom.GetHash();\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2));\n+\n+    BOOST_CHECK(txTo.AreInputsStandard(mapInputs));\n+\n+    CTransaction txToNonStd;\n+    txToNonStd.vout.resize(1);\n+    txToNonStd.vout[0].scriptPubKey.SetBitcoinAddress(key[1].GetPubKey());\n+    txToNonStd.vin.resize(1);\n+    txToNonStd.vin[0].prevout.n = 4;\n+    txToNonStd.vin[0].prevout.hash = txFrom.GetHash();\n+    txToNonStd.vin[0].scriptSig << Serialize(empty);\n+\n+    BOOST_CHECK(!txToNonStd.AreInputsStandard(mapInputs));\n+\n+    txToNonStd.vin[0].scriptSig.clear();\n+    BOOST_CHECK(!txToNonStd.AreInputsStandard(mapInputs));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "b1bd52c5f2939aeb98f157f25423e5d2cb8bbcb7",
        "filename": "src/test/script_op_eval_tests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 268,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/src/test/script_op_eval_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d11a58a2d39b90dfe27d3a696b3977b87d7c8113/src/test/script_op_eval_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_op_eval_tests.cpp?ref=d11a58a2d39b90dfe27d3a696b3977b87d7c8113",
        "patch": "@@ -1,268 +0,0 @@\n-#include <boost/assert.hpp>\n-#include <boost/assign/list_of.hpp>\n-#include <boost/assign/list_inserter.hpp>\n-#include <boost/assign/std/vector.hpp>\n-#include <boost/test/unit_test.hpp>\n-#include <boost/foreach.hpp>\n-\n-#include \"../main.h\"\n-#include \"../script.h\"\n-#include \"../wallet.h\"\n-\n-using namespace std;\n-\n-// Test routines internal to script.cpp:\n-extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps,\n-                         int nHashType, bool fStrictOpEval);\n-\n-BOOST_AUTO_TEST_SUITE(script_op_eval_tests)\n-\n-BOOST_AUTO_TEST_CASE(script_op_eval1)\n-{\n-    // OP_EVAL looks like this:\n-    // scriptSig:    <sig> <sig...> <serialized_script>\n-    // scriptPubKey: DUP HASH160 <hash> EQUALVERIFY EVAL\n-\n-    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n-    CBasicKeyStore keystore;\n-    CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        key[i].MakeNewKey();\n-        keystore.AddKey(key[i]);\n-    }\n-\n-    // 8 Scripts: checking all combinations of\n-    // different keys, straight/EVAL, pubkey/pubkeyhash\n-    CScript standardScripts[4];\n-    standardScripts[0] << key[0].GetPubKey() << OP_CHECKSIG;\n-    standardScripts[1].SetBitcoinAddress(key[1].GetPubKey());\n-    standardScripts[2] << key[1].GetPubKey() << OP_CHECKSIG;\n-    standardScripts[3].SetBitcoinAddress(key[2].GetPubKey());\n-    CScript evalScripts[4];\n-    uint160 sigScriptHashes[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        sigScriptHashes[i] = Hash160(standardScripts[i]);\n-        keystore.AddCScript(sigScriptHashes[i], standardScripts[i]);\n-        evalScripts[i] << OP_DUP << OP_HASH160 << sigScriptHashes[i] << OP_EQUALVERIFY << OP_EVAL;\n-    }\n-\n-    CTransaction txFrom;  // Funding transaction:\n-    txFrom.vout.resize(8);\n-    for (int i = 0; i < 4; i++)\n-    {\n-        txFrom.vout[i].scriptPubKey = evalScripts[i];\n-        txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n-    }\n-    BOOST_CHECK(txFrom.IsStandard());\n-\n-    CTransaction txTo[8]; // Spending transactions\n-    for (int i = 0; i < 8; i++)\n-    {\n-        txTo[i].vin.resize(1);\n-        txTo[i].vout.resize(1);\n-        txTo[i].vin[0].prevout.n = i;\n-        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1;\n-        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n-    }\n-    for (int i = 0; i < 8; i++)\n-    {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n-    }\n-    // All of the above should be OK, and the txTos have valid signatures\n-    // Check to make sure signature verification fails if we use the wrong ScriptSig:\n-    for (int i = 0; i < 8; i++)\n-        for (int j = 0; j < 8; j++)\n-        {\n-            CScript sigSave = txTo[i].vin[0].scriptSig;\n-            txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            int nUnused = 0;\n-            bool sigOK = VerifySignature(txFrom, txTo[i], 0, nUnused);\n-            if (i == j)\n-                BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n-            else\n-                BOOST_CHECK_MESSAGE(!sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n-            txTo[i].vin[0].scriptSig = sigSave;\n-        }\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_op_eval2)\n-{\n-    // Test OP_EVAL edge cases\n-\n-    // Make sure infinite recursion fails to validate:\n-    CScript infiniteRecurse;\n-    infiniteRecurse << OP_DUP << OP_EVAL;\n-\n-    uint160 infiniteRecurseHash = Hash160(infiniteRecurse);\n-\n-    CScript fund1;\n-    fund1 << OP_DUP << OP_HASH160 << infiniteRecurseHash << OP_EQUALVERIFY << OP_EVAL;\n-\n-    CTransaction txFrom1;  // Funding transaction:\n-    txFrom1.vout.resize(1);\n-    txFrom1.vout[0].scriptPubKey = fund1;\n-\n-    BOOST_CHECK(txFrom1.IsStandard()); // Looks like a standard transaction until you try to spend it\n-\n-    std::vector<unsigned char> infiniteRecurseSerialized(infiniteRecurse);\n-\n-    CTransaction txTo1;\n-    txTo1.vin.resize(1);\n-    txTo1.vout.resize(1);\n-    txTo1.vin[0].prevout.n = 0;\n-    txTo1.vin[0].prevout.hash = txFrom1.GetHash();\n-    txTo1.vin[0].scriptSig = CScript() << infiniteRecurseSerialized << infiniteRecurseSerialized;\n-    txTo1.vout[0].nValue = 1;\n-\n-    int nUnused1 = 0;\n-    BOOST_CHECK(!VerifyScript(txTo1.vin[0].scriptSig, txFrom1.vout[0].scriptPubKey, txTo1, 0, nUnused1, 0, true));\n-    BOOST_CHECK(!VerifySignature(txFrom1, txTo1, 0, nUnused1, true));\n-\n-    // Make sure 3-level-deep recursion fails to validate:\n-    CScript recurse3;\n-    recurse3 << OP_EVAL;\n-\n-    uint160 recurse3Hash = Hash160(recurse3);\n-\n-    CScript fund2;\n-    fund2 << OP_DUP << OP_HASH160 << recurse3Hash << OP_EQUALVERIFY << OP_EVAL;\n-\n-    CTransaction txFrom2;  // Funding transaction:\n-    txFrom2.vout.resize(1);\n-    txFrom2.vout[0].scriptPubKey = fund2;\n-\n-    BOOST_CHECK(txFrom2.IsStandard()); // Looks like a standard transaction until you try to spend it\n-\n-    std::vector<unsigned char> recurse3Serialized(recurse3);\n-    CScript op1Script = CScript() << OP_1;\n-    std::vector<unsigned char> op1Serialized(op1Script);\n-\n-    CTransaction txTo2;\n-    txTo2.vin.resize(1);\n-    txTo2.vout.resize(1);\n-    txTo2.vin[0].prevout.n = 0;\n-    txTo2.vin[0].prevout.hash = txFrom2.GetHash();\n-    txTo2.vin[0].scriptSig = CScript() << op1Serialized << recurse3Serialized << recurse3Serialized;\n-    txTo2.vout[0].nValue = 1;\n-\n-    int nUnused2 = 0;\n-    BOOST_CHECK(!VerifyScript(txTo2.vin[0].scriptSig, txFrom2.vout[0].scriptPubKey, txTo2, 0, nUnused2, 0, true));\n-    BOOST_CHECK(!VerifySignature(txFrom2, txTo2, 0, nUnused2, true));\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_op_eval3)\n-{\n-    // Test the CScript::Set* methods\n-    CBasicKeyStore keystore;\n-    CKey key[4];\n-    std::vector<CKey> keys;\n-    for (int i = 0; i < 4; i++)\n-    {\n-        key[i].MakeNewKey();\n-        keystore.AddKey(key[i]);\n-        keys.push_back(key[i]);\n-    }\n-\n-    CScript inner[4];\n-    inner[0].SetBitcoinAddress(key[0].GetPubKey());\n-    inner[1].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+2));\n-    inner[2].SetMultisig(1, std::vector<CKey>(keys.begin(), keys.begin()+2));\n-    inner[3].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+3));\n-\n-    CScript outer[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        outer[i].SetEval(inner[i]);\n-        keystore.AddCScript(Hash160(inner[i]), inner[i]);\n-    }\n-\n-    CTransaction txFrom;  // Funding transaction:\n-    txFrom.vout.resize(4);\n-    for (int i = 0; i < 4; i++)\n-    {\n-        txFrom.vout[i].scriptPubKey = outer[i];\n-    }\n-    BOOST_CHECK(txFrom.IsStandard());\n-\n-    CTransaction txTo[4]; // Spending transactions\n-    for (int i = 0; i < 4; i++)\n-    {\n-        txTo[i].vin.resize(1);\n-        txTo[i].vout.resize(1);\n-        txTo[i].vin[0].prevout.n = i;\n-        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1;\n-        txTo[i].vout[0].scriptPubKey = inner[i];\n-        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n-    }\n-    for (int i = 0; i < 4; i++)\n-    {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n-        BOOST_CHECK_MESSAGE(txTo[i].IsStandard(), strprintf(\"txTo[%d].IsStandard\", i));\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_op_eval_backcompat1)\n-{\n-    // Check backwards-incompatibility-testing code\n-    CScript returnsEleven;\n-    returnsEleven << OP_11;\n-\n-    // This should validate on new clients, but will\n-    // be invalid on old clients (that interpret OP_EVAL as a no-op)\n-    //  ... except there's a special rule that makes new clients reject\n-    // it.\n-    CScript fund;\n-    fund << OP_EVAL << OP_11 << OP_EQUAL;\n-\n-    CTransaction txFrom;  // Funding transaction:\n-    txFrom.vout.resize(1);\n-    txFrom.vout[0].scriptPubKey = fund;\n-\n-    CTransaction txTo;\n-    txTo.vin.resize(1);\n-    txTo.vout.resize(1);\n-    txTo.vin[0].prevout.n = 0;\n-    txTo.vin[0].prevout.hash = txFrom.GetHash();\n-    txTo.vin[0].scriptSig = CScript() << static_cast<std::vector<unsigned char> >(returnsEleven);\n-    txTo.vout[0].nValue = 1;\n-\n-    int nUnused = 0;\n-    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, true));\n-    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused, true));\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_op_eval_switchover)\n-{\n-    // Test OP_EVAL switchover code\n-    CScript notValid;\n-    notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\n-\n-    // This will be valid under old rules, invalid under new:\n-    CScript fund;\n-    fund << OP_EVAL;\n-\n-    CTransaction txFrom;  // Funding transaction:\n-    txFrom.vout.resize(1);\n-    txFrom.vout[0].scriptPubKey = fund;\n-\n-    CTransaction txTo;\n-    txTo.vin.resize(1);\n-    txTo.vout.resize(1);\n-    txTo.vin[0].prevout.n = 0;\n-    txTo.vin[0].prevout.hash = txFrom.GetHash();\n-    txTo.vin[0].scriptSig = CScript() << static_cast<std::vector<unsigned char> >(notValid);\n-    txTo.vout[0].nValue = 1;\n-\n-    int nUnused = 0;\n-    BOOST_CHECK(VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, false));\n-\n-    // Under strict op_eval switchover, it should be considered invalid:\n-    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, true));\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "79dd7f1bd3aa8311ad9a5e6161b9cdd6e6e98c53",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 23,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -7,8 +7,8 @@\n \n using namespace std;\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps,\n-                         int nHashType, bool fStrictOpEval);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                         bool fValidatePayToScriptHash, int nHashType);\n \n BOOST_AUTO_TEST_SUITE(script_tests)\n \n@@ -21,21 +21,19 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n     static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n \n-    int nUnused = 0;\n-\n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0, true, nUnused));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0, true, nUnused));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0));\n     BOOST_CHECK(pushdata1Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0, true, nUnused));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0));\n     BOOST_CHECK(pushdata2Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0, true, nUnused));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0));\n     BOOST_CHECK(pushdata4Stack == directStack);\n }\n \n@@ -73,7 +71,6 @@ sign_multisig(CScript scriptPubKey, CKey key, CTransaction transaction)\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n {\n-    int nUnused = 0;\n     CKey key1, key2, key3;\n     key1.MakeNewKey();\n     key2.MakeNewKey();\n@@ -94,20 +91,19 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     txTo12.vout[0].nValue = 1;\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, 0));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, 0));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, true, 0));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, true, 0));\n }\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n {\n-    int nUnused = 0;\n     CKey key1, key2, key3, key4;\n     key1.MakeNewKey();\n     key2.MakeNewKey();\n@@ -131,46 +127,46 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, true, 0));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, true, 0));\n }    \n \n "
      },
      {
        "sha": "0b0a4a62d8d4fb0fadd01de2b7bd26acb781befb",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -0,0 +1,60 @@\n+#include <vector>\n+#include <boost/test/unit_test.hpp>\n+#include <boost/foreach.hpp>\n+\n+#include \"script.h\"\n+#include \"key.h\"\n+\n+using namespace std;\n+\n+// Helpers:\n+static std::vector<unsigned char>\n+Serialize(const CScript& s)\n+{\n+    std::vector<unsigned char> sSerialized(s);\n+    return sSerialized;\n+}\n+\n+BOOST_AUTO_TEST_SUITE(sigopcount_tests)\n+\n+BOOST_AUTO_TEST_CASE(GetSigOpCount)\n+{\n+    // Test CScript::GetSigOpCount()\n+    CScript s1;\n+    BOOST_CHECK_EQUAL(s1.GetSigOpCount(false), 0);\n+    BOOST_CHECK_EQUAL(s1.GetSigOpCount(true), 0);\n+\n+    uint160 dummy;\n+    s1 << OP_1 << dummy << dummy << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK_EQUAL(s1.GetSigOpCount(true), 2);\n+    s1 << OP_IF << OP_CHECKSIG << OP_ENDIF;\n+    BOOST_CHECK_EQUAL(s1.GetSigOpCount(true), 3);\n+    BOOST_CHECK_EQUAL(s1.GetSigOpCount(false), 21);\n+\n+    CScript p2sh;\n+    p2sh.SetPayToScriptHash(s1);\n+    CScript scriptSig;\n+    scriptSig << OP_0 << Serialize(s1);\n+    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig), 3);\n+\n+    std::vector<CKey> keys;\n+    for (int i = 0; i < 3; i++)\n+    {\n+        CKey k;\n+        k.MakeNewKey();\n+        keys.push_back(k);\n+    }\n+    CScript s2;\n+    s2.SetMultisig(1, keys);\n+    BOOST_CHECK_EQUAL(s2.GetSigOpCount(true), 3);\n+    BOOST_CHECK_EQUAL(s2.GetSigOpCount(false), 20);\n+\n+    p2sh.SetPayToScriptHash(s2);\n+    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(true), 0);\n+    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(false), 0);\n+    CScript scriptSig2;\n+    scriptSig2 << OP_1 << dummy << dummy << Serialize(s2);\n+    BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig2), 3);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7ff7545ab4bf8eaf707e591750eeeeda109afc9f",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -4,18 +4,24 @@\n #include \"main.h\"\n #include \"wallet.h\"\n \n+CWallet* pwalletMain;\n+\n extern bool fPrintToConsole;\n struct TestingSetup {\n     TestingSetup() {\n         fPrintToConsole = true; // don't want to write to debug.log file\n+        pwalletMain = new CWallet();\n+        RegisterWallet(pwalletMain);\n+    }\n+    ~TestingSetup()\n+    {\n+        delete pwalletMain;\n+        pwalletMain = NULL;\n     }\n-    ~TestingSetup() { }\n };\n \n BOOST_GLOBAL_FIXTURE(TestingSetup);\n \n-CWallet* pwalletMain;\n-\n void Shutdown(void* parg)\n {\n   exit(0);"
      },
      {
        "sha": "94c0c77a44b991ea378495c6c7d12428b65a9006",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -232,4 +232,19 @@ BOOST_AUTO_TEST_CASE(util_ParseMoney)\n     BOOST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n }\n \n+BOOST_AUTO_TEST_CASE(util_IsHex)\n+{\n+    BOOST_CHECK(IsHex(\"00\"));\n+    BOOST_CHECK(IsHex(\"00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n+    BOOST_CHECK(IsHex(\"ff\"));\n+    BOOST_CHECK(IsHex(\"FF\"));\n+\n+    BOOST_CHECK(!IsHex(\"\"));\n+    BOOST_CHECK(!IsHex(\"0\"));\n+    BOOST_CHECK(!IsHex(\"a\"));\n+    BOOST_CHECK(!IsHex(\"eleven\"));\n+    BOOST_CHECK(!IsHex(\"00xx00\"));\n+    BOOST_CHECK(!IsHex(\"0x0000\"));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "67e1bf801a2a8380065f3984bb04bfccea782e8e",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 18,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -400,26 +400,36 @@ bool ParseMoney(const char* pszIn, int64& nRet)\n }\n \n \n-vector<unsigned char> ParseHex(const char* psz)\n+static char phexdigit[256] =\n+{ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n+  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n+  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n+\n+bool IsHex(const string& str)\n {\n-    static char phexdigit[256] =\n-    { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n-      -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n-      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n+    BOOST_FOREACH(unsigned char c, str)\n+    {\n+        if (phexdigit[c] < 0)\n+            return false;\n+    }\n+    return (str.size() > 0) && (str.size()%2 == 0);\n+}\n \n+vector<unsigned char> ParseHex(const char* psz)\n+{\n     // convert hex dump to vector\n     vector<unsigned char> vch;\n     loop"
      },
      {
        "sha": "87725b721721fc702e526c0db28392be4dee1b49",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -138,6 +138,7 @@ bool ParseMoney(const std::string& str, int64& nRet);\n bool ParseMoney(const char* pszIn, int64& nRet);\n std::vector<unsigned char> ParseHex(const char* psz);\n std::vector<unsigned char> ParseHex(const std::string& str);\n+bool IsHex(const std::string& str);\n std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = NULL);\n std::string DecodeBase64(const std::string& str);\n std::string EncodeBase64(const unsigned char* pch, size_t len);"
      },
      {
        "sha": "a196044f1f2edef6eb853be9b82e1ffbb10665c5",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -42,13 +42,13 @@ bool CWallet::AddCryptedKey(const vector<unsigned char> &vchPubKey, const vector\n     return false;\n }\n \n-bool CWallet::AddCScript(const uint160 &hash, const CScript& redeemScript)\n+bool CWallet::AddCScript(const CScript& redeemScript)\n {\n-    if (!CCryptoKeyStore::AddCScript(hash, redeemScript))\n+    if (!CCryptoKeyStore::AddCScript(redeemScript))\n         return false;\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).WriteCScript(hash, redeemScript);\n+    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n }\n \n bool CWallet::Unlock(const SecureString& strWalletPassphrase)"
      },
      {
        "sha": "113210461d517a7a52771b113f5cec3989d0ea59",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/922e8e2929a2e78270868385aa46f96002fbcff3/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/922e8e2929a2e78270868385aa46f96002fbcff3/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=922e8e2929a2e78270868385aa46f96002fbcff3",
        "patch": "@@ -70,8 +70,8 @@ class CWallet : public CCryptoKeyStore\n     bool AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n     // Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret) { return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret); }\n-    bool AddCScript(const uint160& hash, const CScript& redeemScript);\n-    bool LoadCScript(const uint160& hash, const CScript& redeemScript) { return CCryptoKeyStore::AddCScript(hash, redeemScript); }\n+    bool AddCScript(const CScript& redeemScript);\n+    bool LoadCScript(const CScript& redeemScript) { return CCryptoKeyStore::AddCScript(redeemScript); }\n \n     bool Unlock(const SecureString& strWalletPassphrase);\n     bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);"
      }
    ]
  },
  {
    "sha": "8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZDc4NDliNmRiNWY1NGRjMzJmZTRmOGM2YzcyODMwNjg0NzNjZDIx",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-11T01:18:00Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-13T15:22:24Z"
      },
      "message": "Refactored ConnectInputs, so valid-transaction-checks are done before ECDSA-verifying signatures.",
      "tree": {
        "sha": "44c3f275be983eaa8ca69c422e77d693fb02b8e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44c3f275be983eaa8ca69c422e77d693fb02b8e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "922e8e2929a2e78270868385aa46f96002fbcff3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/922e8e2929a2e78270868385aa46f96002fbcff3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/922e8e2929a2e78270868385aa46f96002fbcff3"
      }
    ],
    "stats": {
      "total": 319,
      "additions": 255,
      "deletions": 64
    },
    "files": [
      {
        "sha": "3a43f5eb369cb34585a1df698613ce70559daf1e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 59,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
        "patch": "@@ -275,26 +275,22 @@ bool CTransaction::IsStandard() const\n // expensive-to-check-upon-redemption script like:\n //   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n //\n-bool CTransaction::AreInputsStandard(const std::map<uint256, std::pair<CTxIndex, CTransaction> >& mapInputs) const\n+bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n {\n     if (fTestNet)\n         return true; // Allow non-standard on testnet\n \n+    if (IsCoinBase())\n+        return true; // Coinbases are allowed to have any input\n+\n     for (int i = 0; i < vin.size(); i++)\n     {\n-        COutPoint prevout = vin[i].prevout;\n-\n-        std::map<uint256, std::pair<CTxIndex, CTransaction> >::const_iterator mi = mapInputs.find(prevout.hash);\n-        if (mi == mapInputs.end())\n-            return false;\n-\n-        const CTransaction& txPrev = (mi->second).second;\n-        assert(prevout.n < txPrev.vout.size());\n+        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n \n         vector<vector<unsigned char> > vSolutions;\n         txnouttype whichType;\n         // get the scriptPubKey corresponding to this input:\n-        const CScript& prevScript = txPrev.vout[prevout.n].scriptPubKey;\n+        const CScript& prevScript = prev.scriptPubKey;\n         if (!Solver(prevScript, whichType, vSolutions))\n             return false;\n         if (whichType == TX_SCRIPTHASH)\n@@ -494,7 +490,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n \n     if (fCheckInputs)\n     {\n-        map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n+        MapPrevTx mapInputs;\n         map<uint256, CTxIndex> mapUnused;\n         if (!FetchInputs(txdb, mapUnused, false, false, mapInputs))\n         {\n@@ -507,27 +503,20 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n         if (!AreInputsStandard(mapInputs))\n             return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n \n-        // Check against previous transactions\n-        int64 nFees = 0;\n-        int nSigOps = 0;\n-        if (!ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, nFees, false, false, nSigOps))\n-        {\n-            if (pfMissingInputs)\n-                *pfMissingInputs = true;\n-            return error(\"AcceptToMemoryPool() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n-        }\n+        int64 nFees = GetValueIn(mapInputs)-GetValueOut();\n+        int nSigOps = GetSigOpCount(mapInputs);\n+        unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n+\n+        // Don't accept it if it can't get into a block\n+        if (nFees < GetMinFee(1000, true, GMF_RELAY))\n+            return error(\"AcceptToMemoryPool() : not enough fees\");\n \n         // Checking ECDSA signatures is a CPU bottleneck, so to avoid denial-of-service\n         // attacks disallow transactions with more than one SigOp per 65 bytes.\n         // 65 bytes because that is the minimum size of an ECDSA signature\n-        unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n         if (nSigOps > nSize / 65 || nSize < 100)\n             return error(\"AcceptToMemoryPool() : transaction with out-of-bounds SigOpCount\");\n \n-        // Don't accept it if it can't get into a block\n-        if (nFees < GetMinFee(1000, true, GMF_RELAY))\n-            return error(\"AcceptToMemoryPool() : not enough fees\");\n-\n         // Continuously rate-limit free transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make other's transactions take longer to confirm.\n@@ -552,6 +541,15 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n                 dFreeCount += nSize;\n             }\n         }\n+\n+        // Check against previous transactions\n+        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n+        if (!ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n+        {\n+            if (pfMissingInputs)\n+                *pfMissingInputs = true;\n+            return error(\"AcceptToMemoryPool() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n+        }\n     }\n \n     // Store transaction in memory\n@@ -925,7 +923,7 @@ bool CTransaction::DisconnectInputs(CTxDB& txdb)\n \n \n bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n-                               bool fBlock, bool fMiner, map<uint256, pair<CTxIndex, CTransaction> >& inputsRet)\n+                               bool fBlock, bool fMiner, MapPrevTx& inputsRet)\n {\n     if (IsCoinBase())\n         return true; // Coinbase transactions have no inputs to fetch.\n@@ -978,6 +976,7 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n     for (int i = 0; i < vin.size(); i++)\n     {\n         const COutPoint prevout = vin[i].prevout;\n+        assert(inputsRet.count(prevout.hash) != 0);\n         const CTxIndex& txindex = inputsRet[prevout.hash].first;\n         const CTransaction& txPrev = inputsRet[prevout.hash].second;\n         if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n@@ -987,9 +986,49 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n     return true;\n }\n \n-bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inputs,\n+const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n+{\n+    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n+    if (mi == inputs.end())\n+        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n+\n+    const CTransaction& txPrev = (mi->second).second;\n+    if (input.prevout.n >= txPrev.vout.size())\n+        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n+\n+    return txPrev.vout[input.prevout.n];\n+}\n+\n+int64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n+{\n+    if (IsCoinBase())\n+        return 0;\n+\n+    int64 nResult = 0;\n+    for (int i = 0; i < vin.size(); i++)\n+    {\n+        nResult += GetOutputFor(vin[i], inputs).nValue;\n+    }\n+    return nResult;\n+\n+}\n+\n+int CTransaction::GetSigOpCount(const MapPrevTx& inputs) const\n+{\n+    if (IsCoinBase())\n+        return 0;\n+\n+    int nSigOps = 0;\n+    for (int i = 0; i < vin.size(); i++)\n+    {\n+        nSigOps += GetOutputFor(vin[i], inputs).scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n+    }\n+    return nSigOps;\n+}\n+\n+bool CTransaction::ConnectInputs(MapPrevTx inputs,\n                                  map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n-                                 const CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee)\n+                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n {\n     // Take over previous transactions' spent pointers\n     // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n@@ -998,6 +1037,7 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n     if (!IsCoinBase())\n     {\n         int64 nValueIn = 0;\n+        int64 nFees = 0;\n         for (int i = 0; i < vin.size(); i++)\n         {\n             COutPoint prevout = vin[i].prevout;\n@@ -1014,6 +1054,17 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n                     if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                         return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n \n+            // Check for conflicts (double-spend)\n+            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n+            // for an attacker to attempt to split the network.\n+            if (!txindex.vSpent[prevout.n].IsNull())\n+                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n+\n+            // Check for negative or overflow input values\n+            nValueIn += txPrev.vout[prevout.n].nValue;\n+            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n+\n             bool fStrictPayToScriptHash = true;\n             if (fBlock)\n             {\n@@ -1038,20 +1089,6 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n             }\n \n-            // Check for conflicts (double-spend)\n-            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n-            // for an attacker to attempt to split the network.\n-            if (!txindex.vSpent[prevout.n].IsNull())\n-                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n-\n-            // Check for negative or overflow input values\n-            nValueIn += txPrev.vout[prevout.n].nValue;\n-            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n-\n-            // Calculate sigOps accurately:\n-            nSigOpsRet += txPrev.vout[prevout.n].scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n-\n             // Mark outpoints as spent\n             txindex.vSpent[prevout.n] = posThisTx;\n \n@@ -1069,8 +1106,6 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n         int64 nTxFee = nValueIn - GetValueOut();\n         if (nTxFee < 0)\n             return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n-        if (nTxFee < nMinFee)\n-            return false;\n         nFees += nTxFee;\n         if (!MoneyRange(nFees))\n             return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n@@ -1176,20 +1211,27 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n         CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n         nTxPos += ::GetSerializeSize(tx, SER_DISK);\n \n-        map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n-        if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs))\n-            return false;\n+        MapPrevTx mapInputs;\n+        if (!tx.IsCoinBase())\n+        {\n+            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs))\n+                return false;\n \n-        int nTxOps = 0;\n-        if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, nFees, true, false, nTxOps))\n-            return false;\n+            int nTxOps = tx.GetSigOpCount(mapInputs);\n+            nSigOps += nTxOps;\n+            if (nSigOps > MAX_BLOCK_SIGOPS)\n+                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+            // There is a different MAX_BLOCK_SIGOPS check in AcceptBlock();\n+            // a block must satisfy both to make it into the best-chain\n+            // (AcceptBlock() is always called before ConnectBlock())\n \n-        nSigOps += nTxOps;\n-        if (nSigOps > MAX_BLOCK_SIGOPS)\n-            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n-        // There is a different MAX_BLOCK_SIGOPS check in AcceptBlock();\n-        // a block must satisfy both to make it into the best-chain\n-        // (AcceptBlock() is always called before ConnectBlock())\n+            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n+        }\n+\n+        // It seems wrong that ConnectInputs must be called on the coinbase transaction\n+        // (which has no inputs) : TODO: refactor the code at the end of ConnectInputs out...\n+        if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n+            return false;\n     }\n \n     // Write queued txindex changes\n@@ -3031,15 +3073,20 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             // Connecting shouldn't fail due to dependency on other memory pool transactions\n             // because we're already processing them in order of dependency\n             map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n-            map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n+            MapPrevTx mapInputs;\n             if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs))\n                 continue;\n \n-            int nTxSigOps2 = 0;\n-            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, nFees, false, true, nTxSigOps2, nMinFee))\n+            int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n+            if (nFees < nMinFee)\n                 continue;\n+\n+            int nTxSigOps2 = tx.GetSigOpCount(mapInputs);\n             if (nBlockSigOps2 + nTxSigOps2 >= MAX_BLOCK_SIGOPS)\n                 continue;\n+\n+            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n+                continue;\n             swap(mapTestPool, mapTestPoolTmp);\n \n             // Added"
      },
      {
        "sha": "678c14cc39bf8d311f929aec5d3b092cb78f344d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 64,
        "deletions": 5,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
        "patch": "@@ -402,6 +402,8 @@ enum GetMinFee_mode\n     GMF_SEND,\n };\n \n+typedef std::map<uint256, std::pair<CTxIndex, CTransaction> > MapPrevTx;\n+\n //\n // The basic transaction that is broadcasted on the network and contained in\n // blocks.  A transaction can contain multiple inputs and outputs.\n@@ -502,11 +504,36 @@ class CTransaction\n         return (vin.size() == 1 && vin[0].prevout.IsNull());\n     }\n \n+    /** Check for standard transaction types\n+        @return True if all outputs (scriptPubKeys) use only standard transaction forms\n+    */\n     bool IsStandard() const;\n-    bool AreInputsStandard(const std::map<uint256, std::pair<CTxIndex, CTransaction> >& mapInputs) const;\n \n+    /** Check for standard transaction types\n+        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n+        @return True if all inputs (scriptSigs) use only standard transaction forms\n+        @see CTransaction::FetchInputs\n+    */\n+    bool AreInputsStandard(const MapPrevTx& mapInputs) const;\n+\n+    /** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n+        @return number of sigops this transaction's outputs will produce when spent\n+        @see CTransaction::FetchInputs\n+    */\n     int GetLegacySigOpCount() const;\n \n+    /** Count ECDSA signature operations the new (0.6-and-later) way\n+        This is a better measure of how expensive it is to process this transaction.\n+\n+        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n+        @return maximum number of sigops required to validate this transaction's inputs\n+        @see CTransaction::FetchInputs\n+     */\n+    int GetSigOpCount(const MapPrevTx& mapInputs) const;\n+\n+    /** Amount of bitcoins spent by this transaction.\n+        @return sum of all outputs (note: does not include fees)\n+     */\n     int64 GetValueOut() const\n     {\n         int64 nValueOut = 0;\n@@ -519,6 +546,16 @@ class CTransaction\n         return nValueOut;\n     }\n \n+    /** Amount of bitcoins coming in to this transaction\n+        Note that lightweight clients may not know anything besides the hash of previous transactions,\n+        so may not be able to calculate this.\n+\n+        @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n+        @return\tSum of value of all inputs (scriptSigs)\n+        @see CTransaction::FetchInputs\n+     */\n+    int64 GetValueIn(const MapPrevTx& mapInputs) const;\n+\n     static bool AllowFree(double dPriority)\n     {\n         // Large (in bytes) low-priority (new, small-coin) transactions\n@@ -634,17 +671,39 @@ class CTransaction\n     bool ReadFromDisk(COutPoint prevout);\n     bool DisconnectInputs(CTxDB& txdb);\n \n-    // Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n+    /** Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n+\n+     @param[in] txdb\tTransaction database\n+     @param[in] mapTestPool\tList of pending changes to the transaction index database\n+     @param[in] fBlock\tTrue if being called to add a new best-block to the chain\n+     @param[in] fMiner\tTrue if being called by CreateNewBlock\n+     @param[out] inputsRet\tPointers to this transaction's inputs\n+     @return\tReturns true if all inputs are in txdb or mapTestPool\n+     */\n     bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n-                     bool fBlock, bool fMiner, std::map<uint256, std::pair<CTxIndex, CTransaction> >& inputsRet);\n-    bool ConnectInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > inputs,\n+                     bool fBlock, bool fMiner, MapPrevTx& inputsRet);\n+\n+    /** Sanity check previous transactions, then, if all checks succeed,\n+        mark them as spent by this transaction.\n+\n+        @param[in] inputs\tPrevious transactions (from FetchInputs)\n+        @param[out] mapTestPool\tKeeps track of inputs that need to be updated on disk\n+        @param[in] posThisTx\tPosition of this transaction on disk\n+        @param[in] pindexBlock\n+        @param[in] fBlock\ttrue if called from ConnectBlock\n+        @param[in] fMiner\ttrue if called from CreateNewBlock\n+        @return Returns true if all checks succeed\n+     */\n+    bool ConnectInputs(MapPrevTx inputs,\n                        std::map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n-                       const CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee=0);\n+                       const CBlockIndex* pindexBlock, bool fBlock, bool fMiner);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n     bool AcceptToMemoryPool(bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n+\n protected:\n+    const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n     bool AddToMemoryPoolUnchecked();\n public:\n     bool RemoveFromMemoryPool();"
      },
      {
        "sha": "33765ca966cb4a6fdb7b51cb6a45d7add42cb2a6",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d7849b6db5f54dc32fe4f8c6c7283068473cd21/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
        "patch": "@@ -22,4 +22,89 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     BOOST_CHECK_MESSAGE(!tx.CheckTransaction(), \"Transaction with duplicate txins should be invalid.\");\n }\n \n+//\n+// Helper: create two dummy transactions, each with\n+// two outputs.  The first has 11 and 50 CENT outputs,\n+// the second 21 and 22 CENT outputs.\n+//\n+static std::vector<CTransaction>\n+SetupDummyInputs(CBasicKeyStore& keystoreRet, MapPrevTx& inputsRet)\n+{\n+    std::vector<CTransaction> dummyTransactions;\n+    dummyTransactions.resize(2);\n+\n+    // Add some keys to the keystore:\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystoreRet.AddKey(key[i]);\n+    }\n+\n+    // Create some dummy input transactions\n+    dummyTransactions[0].vout.resize(2);\n+    dummyTransactions[0].vout[0].nValue = 11*CENT;\n+    dummyTransactions[0].vout[0].scriptPubKey.SetBitcoinAddress(key[0].GetPubKey());\n+    dummyTransactions[0].vout[1].nValue = 50*CENT;\n+    dummyTransactions[0].vout[1].scriptPubKey.SetBitcoinAddress(key[1].GetPubKey());\n+    inputsRet[dummyTransactions[0].GetHash()] = make_pair(CTxIndex(), dummyTransactions[0]);\n+\n+    dummyTransactions[1].vout.resize(2);\n+    dummyTransactions[1].vout[0].nValue = 21*CENT;\n+    dummyTransactions[1].vout[0].scriptPubKey.SetBitcoinAddress(key[2].GetPubKey());\n+    dummyTransactions[1].vout[1].nValue = 22*CENT;\n+    dummyTransactions[1].vout[1].scriptPubKey.SetBitcoinAddress(key[3].GetPubKey());\n+    inputsRet[dummyTransactions[1].GetHash()] = make_pair(CTxIndex(), dummyTransactions[1]);\n+\n+    return dummyTransactions;\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_Get)\n+{\n+    CBasicKeyStore keystore;\n+    MapPrevTx dummyInputs;\n+    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, dummyInputs);\n+\n+    CTransaction t1;\n+    t1.vin.resize(3);\n+    t1.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n+    t1.vin[0].prevout.n = 1;\n+    t1.vin[1].prevout.hash = dummyTransactions[1].GetHash();;\n+    t1.vin[1].prevout.n = 0;\n+    t1.vin[2].prevout.hash = dummyTransactions[1].GetHash();;\n+    t1.vin[2].prevout.n = 1;\n+    t1.vout.resize(2);\n+    t1.vout[0].nValue = 90*CENT;\n+    t1.vout[0].scriptPubKey << OP_1;\n+\n+    BOOST_CHECK(t1.AreInputsStandard(dummyInputs));\n+    BOOST_CHECK_EQUAL(t1.GetSigOpCount(dummyInputs), 3);\n+    BOOST_CHECK_EQUAL(t1.GetValueIn(dummyInputs), (50+21+22)*CENT);\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_GetThrow)\n+{\n+    CBasicKeyStore keystore;\n+    MapPrevTx dummyInputs;\n+    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, dummyInputs);\n+\n+    MapPrevTx missingInputs;\n+\n+    CTransaction t1;\n+    t1.vin.resize(3);\n+    t1.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n+    t1.vin[0].prevout.n = 0;\n+    t1.vin[1].prevout.hash = dummyTransactions[1].GetHash();;\n+    t1.vin[1].prevout.n = 0;\n+    t1.vin[2].prevout.hash = dummyTransactions[1].GetHash();;\n+    t1.vin[2].prevout.n = 1;\n+    t1.vout.resize(2);\n+    t1.vout[0].nValue = 90*CENT;\n+    t1.vout[0].scriptPubKey << OP_1;\n+\n+    BOOST_CHECK_THROW(t1.AreInputsStandard(missingInputs), runtime_error);\n+    BOOST_CHECK_THROW(t1.GetSigOpCount(missingInputs), runtime_error);\n+    BOOST_CHECK_THROW(t1.GetValueIn(missingInputs), runtime_error);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "4063460534768e2062585573548c293b39313a41",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MDYzNDYwNTM0NzY4ZTIwNjI1ODU1NzM1NDhjMjkzYjM5MzEzYTQx",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-11T01:45:55Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-13T15:22:24Z"
      },
      "message": "Refactor: needing to call ConnectInputs to process coinbase transactions was counter-intuitive",
      "tree": {
        "sha": "d7690c9ee4254d0169d0c16a84c2996383da1b87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d7690c9ee4254d0169d0c16a84c2996383da1b87"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4063460534768e2062585573548c293b39313a41",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4063460534768e2062585573548c293b39313a41",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4063460534768e2062585573548c293b39313a41",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4063460534768e2062585573548c293b39313a41/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d7849b6db5f54dc32fe4f8c6c7283068473cd21",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d7849b6db5f54dc32fe4f8c6c7283068473cd21"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 5,
      "deletions": 15
    },
    "files": [
      {
        "sha": "3c3f066042260a55daf5287bf2ac75ae12146866",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 15,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4063460534768e2062585573548c293b39313a41/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4063460534768e2062585573548c293b39313a41/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4063460534768e2062585573548c293b39313a41",
        "patch": "@@ -1111,17 +1111,6 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n     }\n \n-    if (fBlock)\n-    {\n-        // Add transaction to changes\n-        mapTestPool[GetHash()] = CTxIndex(posThisTx, vout.size());\n-    }\n-    else if (fMiner)\n-    {\n-        // Add transaction to test pool\n-        mapTestPool[GetHash()] = CTxIndex(CDiskTxPos(1,1,1), vout.size());\n-    }\n-\n     return true;\n }\n \n@@ -1226,12 +1215,12 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n             // (AcceptBlock() is always called before ConnectBlock())\n \n             nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n+\n+            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n+                return false;\n         }\n \n-        // It seems wrong that ConnectInputs must be called on the coinbase transaction\n-        // (which has no inputs) : TODO: refactor the code at the end of ConnectInputs out...\n-        if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n-            return false;\n+        mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n     }\n \n     // Write queued txindex changes\n@@ -3087,6 +3076,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n \n             if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n                 continue;\n+            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());\n             swap(mapTestPool, mapTestPoolTmp);\n \n             // Added"
      }
    ]
  },
  {
    "sha": "9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTg4MThlYzlkMDFiM2NmOWU0YWE2MDFhOTY3ODVjNGZkYzNmOWI3",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-12T15:33:21Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-13T15:22:24Z"
      },
      "message": "Remove base58 encoding from validateaddress/addmultisigaddress\n\nbase58-encoding of full/compressed public keys needs more thought; it probably makes sense to define a base58 encoding that includes a version byte and a checksum. So just support hex and bitcoin-address encodings for now.",
      "tree": {
        "sha": "39e986619b4e92a02ef2c2b1ad358c4119570c3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/39e986619b4e92a02ef2c2b1ad358c4119570c3e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4063460534768e2062585573548c293b39313a41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4063460534768e2062585573548c293b39313a41",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4063460534768e2062585573548c293b39313a41"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 4,
      "deletions": 19
    },
    "files": [
      {
        "sha": "db595cbf960453f4eaed01d5d80c7da782f67a78",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 19,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=9e8818ec9d01b3cf9e4aa601a96785c4fdc3f9b7",
        "patch": "@@ -994,7 +994,7 @@ Value addmultisigaddress(const Array& params, bool fHelp)\n     {\n         string msg = \"addmultisigaddress <nrequired> <'[\\\"key\\\",\\\"key\\\"]'> [account]\\n\"\n             \"Add a nrequired-to-sign multisignature address to the wallet\\\"\\n\"\n-            \"each key is a bitcoin address, hex or base58 public key\\n\"\n+            \"each key is a bitcoin address or hex-encoded public key\\n\"\n             \"If [account] is specified, assign address to [account].\";\n         throw runtime_error(msg);\n     }\n@@ -1028,32 +1028,19 @@ Value addmultisigaddress(const Array& params, bool fHelp)\n             if (!pwalletMain->GetKey(address, pubkeys[i]))\n                 throw runtime_error(\n                     strprintf(\"no full public key for address %s\",ks.c_str()));\n-            continue;\n         }\n \n         // Case 2: hex public key\n-        if (IsHex(ks))\n+        else if (IsHex(ks))\n         {\n             vector<unsigned char> vchPubKey = ParseHex(ks);\n             if (vchPubKey.empty() || !pubkeys[i].SetPubKey(vchPubKey))\n                 throw runtime_error(\" Invalid public key: \"+ks);\n-            // There is approximately a zero percent chance a random\n-            // public key encoded as base58 will consist entirely\n-            // of hex characters.\n-            continue;\n         }\n-        // Case 3: base58-encoded public key\n+        else\n         {\n-            vector<unsigned char> vchPubKey;\n-            if (!DecodeBase58(ks, vchPubKey))\n-                throw runtime_error(\"base58 decoding failed: \"+ks);\n-            if (vchPubKey.size() < 33) // 33 is size of a compressed public key\n-                throw runtime_error(\"decoded public key too short: \"+ks);\n-            if (pubkeys[i].SetPubKey(vchPubKey))\n-                continue;\n+            throw runtime_error(\" Invalid public key: \"+ks);\n         }\n-\n-        throw runtime_error(\" Invalid public key: \"+ks);\n     }\n \n     // Construct using pay-to-script-hash:\n@@ -1739,8 +1726,6 @@ Value validateaddress(const Array& params, bool fHelp)\n             std::vector<unsigned char> vchPubKey;\n             pwalletMain->GetPubKey(address, vchPubKey);\n             ret.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n-            std::string strPubKey(vchPubKey.begin(), vchPubKey.end());\n-            ret.push_back(Pair(\"pubkey58\", EncodeBase58(vchPubKey)));\n             CKey key;\n             key.SetPubKey(vchPubKey);\n             ret.push_back(Pair(\"iscompressed\", key.IsCompressed()));"
      }
    ]
  }
]