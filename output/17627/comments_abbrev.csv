laanwj,2019-11-28 09:48:42,"I think in general, initializing everything *unless* it's deliberately not done for performance reasons, is a good thing. One company I've worked for even had a strict ""initialize everything"" policy, no exceptions.\n\nFixing random buffers because of valgrind false positives has some [very bad](https://research.swtch.com/openssl) precedent though, please review carefully.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559421439,559421439,
practicalswift,2019-11-28 09:53:29,"@laanwj To be fair this is not a Valgrind false positive? :)  Valgrind false positives are _very_ rare in my experience.\n",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559423287,559423287,
laanwj,2019-11-28 10:00:14,"> To be fair this is not a Valgrind false positive? :) Valgrind false positives are very rare in my experience.\n\nIt's a false positive because the buffer is actually filled in by the syscall but ~~valgrind~~ msan doesn't notice. \n\n> The memory sanitizer cannot see through syscall (see google/sanitizers#852). This caused a false positive use-of-uninitialized-value error for SYS_getrandom.\",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559425791,559425791,
practicalswift,2019-11-28 10:02:10,"@laanwj Yes, but the false positive is in MemorySanitizer -- not Valgrind :)",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559426538,559426538,
elichai,2019-11-28 10:09:04,"Concept ACK.\nFrom a quick glance it seems like the only change is initializing the value, and because unlike the openssl/debian fiasco, we *don't* use unintialized memory for generating randomness then there's no logical reason why this can make anything that currently works break (unless it was already broken).\n\nStill requires close up review but I think it's good to keep that in mind",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559429166,559429166,
Sjors,2019-11-28 10:17:35,"Agree that it needs careful review. I can replace the `{0}` with ""// intentionally not initialized"" where needed.\n\nAlso note that the code this touches is relatively new (added by @sipa in #15250 and #17270), and deserves extra scrutiny anyway now that we've dropped the OpenSSL training wheels.\n\nThe actual initialization before this commit took place in `GetOSRand`, which is different depe",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559432380,559432380,
practicalswift,2019-11-28 10:29:03,"Concept ACK\n\n> I think in general, initializing everything _unless_ it's deliberately not done for performance reasons, is a good thing. One company I've worked for even had a strict ""initialize everything"" policy, no exceptions.\n\nAgree. I think it is worth doing.\n\nSome background reading that might be of interest regarding the pros/cons of default initialization in general:\n* C++ Co",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559436518,559436518,
practicalswift,2019-11-28 10:33:39,"@Sjors Which subset of these changes are required to make MemorySanitizer happy? Not all these are technically needed, right? (I'm not opposing fixing it generally, but asking to get the full picture :))",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559438202,559438202,
gmaxwell,2019-11-28 15:01:34,"Initializing this would conceal from valgrind if changes in the code cased the random variable to not get filled which would be a moderately serious problem: Zero is not an acceptable random value. :)\n\nSince msan is actually incorrect due to a known and documented limitation in msan, might it not be better to use a suppression?  I'm not a fan of suppressing actual errors-- but this isn't an er",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559525797,559525797,
elichai,2019-11-28 15:09:26,"> Initializing this would conceal from valgrind if changes in the code cased the random variable to not get filled which would be a moderately serious problem: Zero is not an acceptable random value. :)\n> \n> Since msan is actually incorrect due to a known and documented limitation in msan, might it not be better to use a suppression? I'm not a fan of suppressing actual errors-- but this isn't ",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559528278,559528278,
Sjors,2019-11-28 15:51:03,Maybe I can add `assert` statements directly after any buffers are filled  to check that they're not still 0? (though I suppose that could be forgotten in new places),https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559541756,559541756,
practicalswift,2019-11-28 21:11:35,"Clarification regarding my Concept ACK: a suppression would be totally fine too.\n\nAs long as we make it easier for everyone to use MemorySanitizer I'm happy: we need more MSAN testing :)",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559603572,559603572,
Sjors,2019-11-29 08:44:12,"I added asserts to ensure these buffers are actually populated on first use. I also added @gmaxwell's comment about valgrind. I'm not very familiar with how valgrind works. If it substitutes calls to `hasher.Write()`, `hasher.Finalize()`, `GetOSRand()`, etc with no-op, then this won't work.\n\nI could pick a magic value instead, initialize with that and use == in the assert.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559708343,559708343,
laanwj,2019-11-29 08:47:58,"> That's a good point. does valgrind support syscalls?\n\nYes, valgrind doesn't have this issue.\n\n> Maybe I can add assert statements directly after any buffers are filled to check that they're not still 0? (though I suppose that could be forgotten in new places)\n\nBut what if the input is legitly 0? These are not random values being fed in, but just some OS data, which may or may not con",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559709475,559709475,
laanwj,2019-11-29 09:15:12,"I've thought about it a bit and I'm principally opposed to adding asserts here. Now you're changing *run-time* behavior of the application to work around a problem in an analysis tool.\n\nI'm sorry to say this but : please fix the tool instead",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559717966,559717966,
practicalswift,2019-11-29 09:26:07,Echoing the NACK on the asserts :),https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559721657,559721657,
practicalswift,2019-11-29 09:30:56,@Sjors Have you considered taking the suppressions route instead? Perhaps that is less intrusive.,https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559723237,559723237,
Sjors,2019-11-29 09:31:42,"Reverted to the original approach, which just initializes to zero. I'm not sure if intentially leaving them uninitialized and having the warnings suppressed if the right approach either.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559723488,559723488,
practicalswift,2019-11-29 09:34:14,"> I'm not sure if intentially leaving them uninitialized and having the warnings suppressed if the right approach either.\n\nWhy? :)",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559724329,559724329,
Sjors,2019-11-29 09:51:04,"It seems like we're choosing between two tools here:\n1. memory sanity check: `= {0}`\n2. valgrind: `// intentionally undefined to allow valgrind to catch issues`\n\nThere's gotta be a solution that involves defined behavior. That would make the code easier to reason about, and prevents folks on different operating systems and compiler optimization flags not noticing bugs (as happened with  #1",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559729879,559729879,
laanwj,2019-11-29 10:00:56,"In that case, let's at least not penalize the tool that actually gets things right (valgrind).\n\nSo I'd vote for adding a MSAN surpression and just be done with it. It can be removed when the tool is fixed.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559733266,559733266,
Sjors,2019-11-29 10:04:11,"Wouldn't initializing to a magic value (e.g `sha256(""bitcoin"")`) solve both valgrind and sanity check issue?",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559734355,559734355,
practicalswift,2019-11-29 15:26:36,"@Sjors Why not doing a suppression? That seems to be the easiest way to solve the problem this PR is meant to solve :)\n\nThere are two ways to do MemorySanitizer suppresions: you can do the suppression in the code using the annotation `__attribute__((no_sanitize(""memory"")))` for the functions you want MSAN-suppressed, or you can use a sanitizer special case blacklist which is perhaps slightly m",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-559823310,559823310,
MarcoFalke,2019-12-03 19:03:36,"NACK. We don't generally change code to please buggy tool or compiler warnings, especially if the ""fix"" hides actual bugs in our code base.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561309991,561309991,
Sjors,2019-12-04 09:10:36,"@MarcoFalke it's about more than making tools happy. The tool pointed us to these uninitialized variables, which have caused pretty serious bugs in the recent past and are bad practice. I don't think we should just ignore this.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561546297,561546297,
practicalswift,2019-12-04 09:20:29,@Sjors You haven't addressed the question about suppressions. Why not suppress this case? :),https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561550156,561550156,
laanwj,2019-12-04 09:22:16,"I agree with @MarcoFalke and @practicalswift  here.\n\nAs I said before, if we do anything here it should be a tool-specific suppression, until the tool is fixed.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561550822,561550822,
Sjors,2019-12-04 09:36:45,"I'm not against suppressing the warning, but I don't think that's enough by itself. It doesn't make the undefined behavior go away. Perhaps one day the address sanitizer can reason about undefined behavior even through syscall. That's great, but still not a good reason to keep the undefined behavior.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561556393,561556393,
laanwj,2019-12-04 09:37:55,"But it is not undefined behavior, *this specific tool* is unable to reason through this. If it was actual undefined behavior, we'd respond very differently.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561556821,561556821,
Sjors,2019-12-04 12:48:43,"I added the suppression, as narrowly as possible. I also added comments to the uninitialized variables, pointing back to this discussion so it doesn't get repeated.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561628884,561628884,
MarcoFalke,2019-12-04 14:50:57,"> @MarcoFalke it's about more than making tools happy. The tool pointed us to these uninitialized variables, which have caused pretty serious bugs in the recent past and are bad practice. I don't think we should just ignore this.\n\nAgain, this is a bug in the tool. These variables are not uninitialized when read. Initializing them with the wrong value will cause bugs in the future because tools",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561679458,561679458,
DrahtBot,2019-12-05 05:25:23,<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.,https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-561975042,561975042,
practicalswift,2019-12-05 08:13:28,@Sjors Thanks for using a suppression instead. Is this the only suppression needed to make MSAN happy in your setup?,https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-562019966,562019966,
Sjors,2019-12-05 08:56:12,"@practicalswift no, it fails on other things, but those appear unrelated. I'll update #17620 later.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-562033723,562033723,
gmaxwell,2019-12-06 01:06:12,"It's not clear to me that everyone understands what's going on here. And maybe I caused some confusion by say that zero is not an acceptable random value. No constant is an acceptable random value.\n\nThe variable is not undefined. It gets defined by the SYS_getrandom.  Memcheck has a flaw/shortcoming where it doesn't know or assume that sys_getrandom initializes it so it falsely reports it as u",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-562387426,562387426,
practicalswift,2019-12-06 07:31:21,"> Memcheck has a flaw/shortcoming where it doesn't know or assume that sys_getrandom initializes it so it falsely reports it as uninitialized.\n\nYou mean MemorySanitizer (MSAN) and not Memcheck (Valgrind), right? :)\n\n> In some rare cases pre-initilization is a performance concern. But in most-- where the variable isn't in some inner loop and doesn't involve a bunch of malloc-- it's not. It ",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-562465531,562465531,
gmaxwell,2019-12-21 12:10:35,"> minimising the risk of leaking non-dummy memory content (achieved by pre-initializing)\n\nThere is no risk of leaking anything here, and of the randomness is hashed before being used.\n\nThe difference between initializing and not is that if a bug is introduced: With initializing a bug that hobbles the random input will not be detectable (except via review),  without initializing the bug wou",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-568176488,568176488,
jonatack,2019-12-21 12:34:02,"FWIW I attempted to summarise this discussion in the review club notes as a resource and will probably update it with the points made here. Don't hesitate to suggest corrections or improvements in the [repository](https://github.com/bitcoin-core-review-club/bitcoin-core-review-club.github.io) or to me via IRC.  \n\nhttps://bitcoincore.reviews/17639.html#what-can-we-do-to-mitigate-uninitialized-v",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-568177940,568177940,
practicalswift,2019-12-21 17:26:27,"> > From a security perspective doesn't it boil down to a trade-off between maximising testing sensitivity (achieved by not pre-initializing) vs minimising the risk of leaking non-dummy memory content (achieved by pre-initializing)?\n> \n> There is no risk of leaking anything here, and of the randomness is hashed before being used.\n\nI was talking about the pros and cons of pre-initializing g",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-568197649,568197649,
Sjors,2020-03-12 13:17:20,"Closing in favor of the more precise fix in #18288. We should still document a policy around initialisation, perhaps requiring _either_ initialisation or a comment that's intentionally not initialised.",https://github.com/bitcoin/bitcoin/pull/17627#issuecomment-598180225,598180225,
Sjors,2019-11-28 12:30:41,"@practicalswift once I fixed this one, it ran into unrelated   `use-of-uninitialized-value` problems. That could mean this is the only problem, or the other ones just didn't get a chance to get called before the sanitizer bailed out.",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r351755307,351755307,src/random.cpp
laanwj,2019-11-29 08:48:15,"FWIW: asserting the *address* of the buffer, on the stack, like you do here does nothing.",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r352029242,352029242,src/random.cpp
Sjors,2019-11-29 09:52:56,"For future reference, something like this works (?), though it's hideous, probably needs a macro, which adds even more complexity:\n```\nunsigned char zeros[sizeof(buf)] = {0};\nassert(!memcmp(fbuf, zeros, sizeof(buf)));\n```",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r352055215,352055215,src/random.cpp
Sjors,2019-11-29 09:53:36,Funny who you run into while googling that: https://rusty.ozlabs.org/?p=560 :-),https://github.com/bitcoin/bitcoin/pull/17627#discussion_r352055534,352055534,src/random.cpp
MarcoFalke,2019-12-04 20:45:44,"This is a clang bug, right? Should link to the commit that fixed it. And since you are compiling clang from source you might as well use that commit and then remove this code blob here.",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r353973199,353973199,src/random.cpp
Sjors,2019-12-04 20:57:39,"The memory sanitizer appears to be a Google project, and they don't expect `syscall` support to be fixed anytime soon. Only a more narrow case of `getrandom` was fixed, which is of no use to us: https://github.com/google/sanitizers/issues/852#issuecomment-327305535\n",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r353978629,353978629,src/random.cpp
MarcoFalke,2019-12-05 18:24:11,"Ok, fine. I'd still prefer a suppression in a suppressions file if possible. Modifying the code like this makes it harder to read and potentially impossible to compile on some environments.",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r354474171,354474171,src/random.cpp
Sjors,2019-12-06 11:10:16,"@practicalswift any idea how to achieve such a suppressions file? I could also put it in a macro, or we can do that if we ever need it again.\nThe outer `#if defined(__has_feature)` is there to make sure other environments don't trip over it. ",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r354780838,354780838,src/random.cpp
practicalswift,2019-12-06 14:02:33,"@Sjors Sure! :) You need to use the sanitizer special case list functionality by passing `-fsanitize-blacklist=test/sanitizer_suppressions/msan` as part of `CFLAGS`/`CXXFLAGS`. You need to create the file `test/sanitizer_suppressions/msan` following the file format specified here: https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format\n\nUnfortunately MemorySanitizer only supports supp",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r354846650,354846650,src/random.cpp
Sjors,2019-12-06 14:33:17,I prefer to punt on this until we need it in more places...,https://github.com/bitcoin/bitcoin/pull/17627#discussion_r354860394,354860394,src/random.cpp
laanwj,2019-12-09 11:34:04,"> I prefer to punt on this until we need it in more places...\n\nSo this is the only place where MSAN special treatment is needed? That's pretty good, I had assumed it would be the first of many.",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r355399735,355399735,src/random.cpp
Sjors,2019-12-09 16:07:49,"I don't know yet. The binary exits once it finds a single problem. The next problem in line is in a different file, but who know what happens after that.\n\nThere's only one place in our codebase where we use `syscall`, so that's a reason for optimism.",https://github.com/bitcoin/bitcoin/pull/17627#discussion_r355536685,355536685,src/random.cpp
