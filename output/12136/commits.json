[
  {
    "sha": "51ed700dc22ef447b18827af9a1c9958ea469ac1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MWVkNzAwZGMyMmVmNDQ3YjE4ODI3YWY5YTFjOTk1OGVhNDY5YWMx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-09T19:06:25Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-12T17:55:57Z"
      },
      "message": "Inline Sign1 and SignN\n\nSign1 and SignN are kind of redundant so remove them and inline their\nbehavior into SignStep",
      "tree": {
        "sha": "a51c51d692caef8b7db8ce08753f7dacc070a4b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a51c51d692caef8b7db8ce08753f7dacc070a4b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51ed700dc22ef447b18827af9a1c9958ea469ac1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51ed700dc22ef447b18827af9a1c9958ea469ac1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51ed700dc22ef447b18827af9a1c9958ea469ac1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51ed700dc22ef447b18827af9a1c9958ea469ac1/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56f69360dc98bd68704f19646a84d045788d199e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56f69360dc98bd68704f19646a84d045788d199e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56f69360dc98bd68704f19646a84d045788d199e"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 25,
      "deletions": 37
    },
    "files": [
      {
        "sha": "269844cfeeab0bc147f4ef9c1eeb66ed35c040a2",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 37,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51ed700dc22ef447b18827af9a1c9958ea469ac1/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51ed700dc22ef447b18827af9a1c9958ea469ac1/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=51ed700dc22ef447b18827af9a1c9958ea469ac1",
        "patch": "@@ -33,29 +33,6 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n-static bool Sign1(const SigningProvider& provider, const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n-{\n-    std::vector<unsigned char> vchSig;\n-    if (!creator.CreateSig(provider, vchSig, address, scriptCode, sigversion))\n-        return false;\n-    ret.push_back(vchSig);\n-    return true;\n-}\n-\n-static bool SignN(const SigningProvider& provider, const std::vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n-{\n-    int nSigned = 0;\n-    int nRequired = multisigdata.front()[0];\n-    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n-    {\n-        const valtype& pubkey = multisigdata[i];\n-        CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (Sign1(provider, keyID, creator, scriptCode, ret, sigversion))\n-            ++nSigned;\n-    }\n-    return nSigned==nRequired;\n-}\n-\n /**\n  * Sign scriptPubKey using signature made with creator.\n  * Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n@@ -68,6 +45,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     CScript scriptRet;\n     uint160 h160;\n     ret.clear();\n+    std::vector<unsigned char> sig;\n \n     std::vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n@@ -81,30 +59,40 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_WITNESS_UNKNOWN:\n         return false;\n     case TX_PUBKEY:\n-        keyID = CPubKey(vSolutions[0]).GetID();\n-        return Sign1(provider, keyID, creator, scriptPubKey, ret, sigversion);\n-    case TX_PUBKEYHASH:\n+        if (!creator.CreateSig(provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n+        ret.push_back(std::move(sig));\n+        return true;\n+    case TX_PUBKEYHASH: {\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!Sign1(provider, keyID, creator, scriptPubKey, ret, sigversion))\n-            return false;\n-        else\n-        {\n-            CPubKey vch;\n-            provider.GetPubKey(keyID, vch);\n-            ret.push_back(ToByteVector(vch));\n-        }\n+        if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n+        ret.push_back(std::move(sig));\n+        CPubKey pubkey;\n+        provider.GetPubKey(keyID, pubkey);\n+        ret.push_back(ToByteVector(pubkey));\n         return true;\n+    }\n     case TX_SCRIPTHASH:\n         if (provider.GetCScript(uint160(vSolutions[0]), scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n         return false;\n \n-    case TX_MULTISIG:\n+    case TX_MULTISIG: {\n+        size_t required = vSolutions.front()[0];\n         ret.push_back(valtype()); // workaround CHECKMULTISIG bug\n-        return (SignN(provider, vSolutions, creator, scriptPubKey, ret, sigversion));\n-\n+        for (size_t i = 1; i < vSolutions.size() - 1; ++i) {\n+            CPubKey pubkey = CPubKey(vSolutions[i]);\n+            if (ret.size() < required + 1 && creator.CreateSig(provider, sig, pubkey.GetID(), scriptPubKey, sigversion)) {\n+                ret.push_back(std::move(sig));\n+            }\n+        }\n+        bool ok = ret.size() == required + 1;\n+        for (size_t i = 0; i + ret.size() < required + 1; ++i) {\n+            ret.push_back(valtype());\n+        }\n+        return ok;\n+    }\n     case TX_WITNESS_V0_KEYHASH:\n         ret.push_back(vSolutions[0]);\n         return true;"
      }
    ]
  },
  {
    "sha": "0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowY2M1YzczZjNhNWVlMmU4ZTdhMzMzYmU1OTA1NWZkMmFiYzAzOTI1",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-08T04:01:24Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T17:42:40Z"
      },
      "message": "Make SignatureData able to store signatures and scripts\n\nIn addition to having the scriptSig and scriptWitness, have SignatureData\nalso be able to store just the signatures (pubkeys mapped to sigs) and\nscripts (script ids mapped to scripts).\n\nAlso have DataFromTransaction be able to extract signatures and scripts\nfrom the scriptSig and scriptWitness of an input to put them in SignatureData.\n\nAdds a new SignatureChecker which takes a SignatureData and puts pubkeys\nand signatures into it when it successfully verifies a signature.\n\nAdds a new field in SignatureData which stores whether the SignatureData\nwas complete. This allows us to also update the scriptSig and\nscriptWitness to the final one when updating a SignatureData with another\none.",
      "tree": {
        "sha": "4a382c0494fc2ce55a401f7311c81a56a4c3b1e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4a382c0494fc2ce55a401f7311c81a56a4c3b1e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "51ed700dc22ef447b18827af9a1c9958ea469ac1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51ed700dc22ef447b18827af9a1c9958ea469ac1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/51ed700dc22ef447b18827af9a1c9958ea469ac1"
      }
    ],
    "stats": {
      "total": 172,
      "additions": 136,
      "deletions": 36
    },
    "files": [
      {
        "sha": "ae60588c2d82353c63a240695e24627983ef0ee1",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "patch": "@@ -9,6 +9,7 @@\n #endif\n #include <script/script.h>\n #include <script/sign.h>\n+#include <script/standard.h>\n #include <streams.h>\n \n #include <array>"
      },
      {
        "sha": "52e6ff979a004d1e1635f7edea583d215e0b6365",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "patch": "@@ -645,13 +645,13 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n         const CScript& prevPubKey = coin.out.scriptPubKey;\n         const CAmount& amount = coin.out.nValue;\n \n-        SignatureData sigdata;\n+        SignatureData sigdata = DataFromTransaction(mergedTx, i, coin.out);\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n             ProduceSignature(keystore, MutableTransactionSignatureCreator(&mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         // ... and merge in other signatures:\n-        sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n+        sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i, coin.out));\n         UpdateInput(txin, sigdata);\n     }\n "
      },
      {
        "sha": "550fffb3265e65bff18cbc03a894e7b7e488ff66",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "patch": "@@ -744,7 +744,7 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n         // ... and merge in other signatures:\n         for (const CMutableTransaction& txv : txVariants) {\n             if (txv.vin.size() > i) {\n-                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n+                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i, coin.out));\n             }\n         }\n \n@@ -875,12 +875,12 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n         const CScript& prevPubKey = coin.out.scriptPubKey;\n         const CAmount& amount = coin.out.nValue;\n \n-        SignatureData sigdata;\n+        SignatureData sigdata = DataFromTransaction(mtx, i, coin.out);\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mtx.vout.size())) {\n             ProduceSignature(*keystore, MutableTransactionSignatureCreator(&mtx, i, amount, nHashType), prevPubKey, sigdata);\n         }\n-        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\n+        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i, coin.out));\n \n         UpdateInput(txin, sigdata);\n "
      },
      {
        "sha": "b716fa918e3e122ab230476573424ee4a828c54f",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 24,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "patch": "@@ -127,6 +127,8 @@ static CScript PushAll(const std::vector<valtype>& values)\n \n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)\n {\n+    if (sigdata.complete) return true;\n+\n     std::vector<valtype> result;\n     txnouttype whichType;\n     bool solved = SignStep(provider, creator, fromPubKey, result, whichType, SigVersion::BASE);\n@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n+}\n+\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+// Extracts signatures and scripts from scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.scripts.emplace(CScriptID(redeem_script), redeem_script);\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.scripts.emplace(CScriptID(witness_script), witness_script);\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {\n+                const valtype& pubkey = solutions[i+1];\n+                // We either have a signature for this pubkey, or we have found a signature and it is valid\n+                if (data.signatures.count(CPubKey(pubkey).GetID()) || checker.CheckSig(sig, pubkey, next_script, sigversion)) {\n+                    last_success_key = i + 1;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     return data;\n }\n \n@@ -187,6 +280,17 @@ void UpdateInput(CTxIn& input, const SignatureData& data)\n     input.scriptWitness = data.scriptWitness;\n }\n \n+void SignatureData::MergeSignatureData(SignatureData sigdata)\n+{\n+    if (complete) return;\n+    if (sigdata.complete) {\n+        *this = std::move(sigdata);\n+        return;\n+    }\n+    scripts.insert(std::make_move_iterator(sigdata.scripts.begin()), std::make_move_iterator(sigdata.scripts.end()));\n+    signatures.insert(std::make_move_iterator(sigdata.signatures.begin()), std::make_move_iterator(sigdata.signatures.end()));\n+}\n+\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n@@ -264,28 +368,6 @@ static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const B\n     return result;\n }\n \n-namespace\n-{\n-struct Stacks\n-{\n-    std::vector<valtype> script;\n-    std::vector<valtype> witness;\n-\n-    Stacks() {}\n-    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n-    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n-        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n-    }\n-\n-    SignatureData Output() const {\n-        SignatureData result;\n-        result.scriptSig = PushAll(script);\n-        result.scriptWitness.stack = witness;\n-        return result;\n-    }\n-};\n-}\n-\n static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n                                  const txnouttype txType, const std::vector<valtype>& vSolutions,\n                                  Stacks sigs1, Stacks sigs2, SigVersion sigversion)"
      },
      {
        "sha": "76263f919fc14ed878f3e2fca723b51c48e2bdd7",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 20,
        "deletions": 3,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "patch": "@@ -53,12 +53,18 @@ class MutableTransactionSignatureCreator : public BaseSignatureCreator {\n /** A signature creator that just produces 72-byte empty signatures. */\n extern const BaseSignatureCreator& DUMMY_SIGNATURE_CREATOR;\n \n+typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n+\n struct SignatureData {\n-    CScript scriptSig;\n-    CScriptWitness scriptWitness;\n+    bool complete = false; // Stores whether the scriptSig and scriptWitness are complete\n+    CScript scriptSig; // The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n+    CScriptWitness scriptWitness; // The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format\n+    std::map<CKeyID, SigPair> signatures; // BIP 174 style partial signatures for the input. May contain complete signatures\n+    std::map<CScriptID, CScript> scripts; // BIP 174 style scripts for the input\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n+    void MergeSignatureData(SignatureData sigdata);\n };\n \n /** Produce a script signature using a generic signature creator. */\n@@ -72,7 +78,7 @@ bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom,\n SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const SignatureData& scriptSig1, const SignatureData& scriptSig2);\n \n /** Extract signature data from a transaction, and insert it. */\n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn);\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout);\n void UpdateInput(CTxIn& input, const SignatureData& data);\n \n /* Check whether we know how to sign for an output like this, assuming we\n@@ -81,4 +87,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;\n+    BaseSignatureChecker* checker;\n+\n+public:\n+    SignatureExtractorChecker(SignatureData* sigdata, BaseSignatureChecker* checker) : sigdata(sigdata), checker(checker) {}\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+};\n+\n #endif // BITCOIN_SCRIPT_SIGN_H"
      },
      {
        "sha": "9ec3fd35f0bcd731f10cd853a7fb81d26d49eb3e",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "patch": "@@ -629,7 +629,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n     CheckWithFlag(output2, input2, 0, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n     // P2SH 2-of-2 multisig\n@@ -640,7 +640,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -652,7 +652,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -664,7 +664,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n }"
      }
    ]
  },
  {
    "sha": "fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzk5YmE5NGJkMGViMWQwNDVmNDRhNmQ5M2Q3ZTc5NDlhNzZmZDk2",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-08T04:12:25Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T17:42:40Z"
      },
      "message": "Replace CombineSignatures with ProduceSignature\n\nInstead of using CombineSignatures to create the final scriptSig or\nscriptWitness of an input, use ProduceSignature itself.\n\nTo allow for ProduceSignature to place signatures, pubkeys, and scripts\nthat it does not know about, we pass down the SignatureData to SignStep\nwhich pulls out the information that it needs from the SignatureData.",
      "tree": {
        "sha": "7dae8f168d4c68b8b03c95843fc858e485119b01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7dae8f168d4c68b8b03c95843fc858e485119b01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0cc5c73f3a5ee2e8e7a333be59055fd2abc03925"
      }
    ],
    "stats": {
      "total": 86,
      "additions": 65,
      "deletions": 21
    },
    "files": [
      {
        "sha": "7c41745ab70f18ef02312baf3023eed6c55cadee",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
        "patch": "@@ -650,8 +650,6 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n             ProduceSignature(keystore, MutableTransactionSignatureCreator(&mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n-        // ... and merge in other signatures:\n-        sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i, coin.out));\n         UpdateInput(txin, sigdata);\n     }\n "
      },
      {
        "sha": "dbe762b7a931f40bf4346807cf55d6774fb30990",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
        "patch": "@@ -736,17 +736,15 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n         if (coin.IsSpent()) {\n             throw JSONRPCError(RPC_VERIFY_ERROR, \"Input not found or already spent\");\n         }\n-        const CScript& prevPubKey = coin.out.scriptPubKey;\n-        const CAmount& amount = coin.out.nValue;\n-\n         SignatureData sigdata;\n \n         // ... and merge in other signatures:\n         for (const CMutableTransaction& txv : txVariants) {\n             if (txv.vin.size() > i) {\n-                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i, coin.out));\n+                sigdata.MergeSignatureData(DataFromTransaction(txv, i, coin.out));\n             }\n         }\n+        ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&mergedTx, i, coin.out.nValue, 1), coin.out.scriptPubKey, sigdata);\n \n         UpdateInput(txin, sigdata);\n     }\n@@ -880,7 +878,6 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n         if (!fHashSingle || (i < mtx.vout.size())) {\n             ProduceSignature(*keystore, MutableTransactionSignatureCreator(&mtx, i, amount, nHashType), prevPubKey, sigdata);\n         }\n-        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i, coin.out));\n \n         UpdateInput(txin, sigdata);\n "
      },
      {
        "sha": "ad114d5556fb0fb7045a99585186d14d7f48fa8d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 11,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
        "patch": "@@ -33,14 +33,58 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    auto mi = sigdata->scripts.find(scriptid);\n+    if (mi != sigdata->scripts.end()) {\n+        script = mi->second;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);\n+    if (it != sigdata->signatures.end()) {\n+        pubkey = it->second.first;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool CreateSig(const BaseSignatureCreator& creator, SignatureData& sigdata, const SigningProvider& provider, std::vector<unsigned char>& sig_out, const CKeyID& keyid, const CScript& scriptcode, SigVersion sigversion)\n+{\n+    const auto& it = sigdata.signatures.find(keyid);\n+    if (it != sigdata.signatures.end()) {\n+        sig_out = it->second.second;\n+        return true;\n+    }\n+    if (creator.CreateSig(provider, sig_out, keyid, scriptcode, sigversion)) {\n+        CPubKey pubkey;\n+        GetPubKey(&provider, &sigdata, keyid, pubkey);\n+        sigdata.signatures.emplace(keyid, SigPair(pubkey, sig_out));\n+        return true;\n+    }\n+    return false;\n+}\n+\n /**\n  * Sign scriptPubKey using signature made with creator.\n  * Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n  * unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n  * Returns false if scriptPubKey could not be completely satisfied.\n  */\n static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey,\n-                     std::vector<valtype>& ret, txnouttype& whichTypeRet, SigVersion sigversion)\n+                     std::vector<valtype>& ret, txnouttype& whichTypeRet, SigVersion sigversion, SignatureData& sigdata)\n {\n     CScript scriptRet;\n     uint160 h160;\n@@ -59,20 +103,20 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_WITNESS_UNKNOWN:\n         return false;\n     case TX_PUBKEY:\n-        if (!creator.CreateSig(provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n+        if (!CreateSig(creator, sigdata, provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n         ret.push_back(std::move(sig));\n         return true;\n     case TX_PUBKEYHASH: {\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n+        if (!CreateSig(creator, sigdata, provider, sig, keyID, scriptPubKey, sigversion)) return false;\n         ret.push_back(std::move(sig));\n         CPubKey pubkey;\n-        provider.GetPubKey(keyID, pubkey);\n+        GetPubKey(&provider, &sigdata, keyID, pubkey);\n         ret.push_back(ToByteVector(pubkey));\n         return true;\n     }\n     case TX_SCRIPTHASH:\n-        if (provider.GetCScript(uint160(vSolutions[0]), scriptRet)) {\n+        if (GetCScript(&provider, &sigdata, uint160(vSolutions[0]), scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -83,7 +127,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n         ret.push_back(valtype()); // workaround CHECKMULTISIG bug\n         for (size_t i = 1; i < vSolutions.size() - 1; ++i) {\n             CPubKey pubkey = CPubKey(vSolutions[i]);\n-            if (ret.size() < required + 1 && creator.CreateSig(provider, sig, pubkey.GetID(), scriptPubKey, sigversion)) {\n+            if (ret.size() < required + 1 && CreateSig(creator, sigdata, provider, sig, pubkey.GetID(), scriptPubKey, sigversion)) {\n                 ret.push_back(std::move(sig));\n             }\n         }\n@@ -99,7 +143,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n \n     case TX_WITNESS_V0_SCRIPTHASH:\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin());\n-        if (provider.GetCScript(h160, scriptRet)) {\n+        if (GetCScript(&provider, &sigdata, h160, scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -131,7 +175,7 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n \n     std::vector<valtype> result;\n     txnouttype whichType;\n-    bool solved = SignStep(provider, creator, fromPubKey, result, whichType, SigVersion::BASE);\n+    bool solved = SignStep(provider, creator, fromPubKey, result, whichType, SigVersion::BASE, sigdata);\n     bool P2SH = false;\n     CScript subscript;\n     sigdata.scriptWitness.stack.clear();\n@@ -142,7 +186,8 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n         subscript = CScript(result[0].begin(), result[0].end());\n-        solved = solved && SignStep(provider, creator, subscript, result, whichType, SigVersion::BASE) && whichType != TX_SCRIPTHASH;\n+        sigdata.scripts.emplace(CScriptID(subscript), subscript);\n+        solved = solved && SignStep(provider, creator, subscript, result, whichType, SigVersion::BASE, sigdata) && whichType != TX_SCRIPTHASH;\n         P2SH = true;\n     }\n \n@@ -151,15 +196,16 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n         CScript witnessscript;\n         witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n         txnouttype subType;\n-        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0);\n+        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata);\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n     }\n     else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n     {\n         CScript witnessscript(result[0].begin(), result[0].end());\n+        sigdata.scripts.emplace(CScriptID(witnessscript), witnessscript);\n         txnouttype subType;\n-        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n         result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n@@ -486,6 +532,7 @@ class DummySignatureCreator final : public BaseSignatureCreator {\n }\n \n const BaseSignatureCreator& DUMMY_SIGNATURE_CREATOR = DummySignatureCreator();\n+const SigningProvider& DUMMY_SIGNING_PROVIDER = SigningProvider();\n \n bool IsSolvable(const SigningProvider& provider, const CScript& script)\n {"
      },
      {
        "sha": "dbdf1e844b47ad394fcb1a46074a36ece26367f7",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
        "patch": "@@ -21,11 +21,13 @@ class SigningProvider\n {\n public:\n     virtual ~SigningProvider() {}\n-    virtual bool GetCScript(const CScriptID &scriptid, CScript& script) const =0;\n-    virtual bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const =0;\n-    virtual bool GetKey(const CKeyID &address, CKey& key) const =0;\n+    virtual bool GetCScript(const CScriptID &scriptid, CScript& script) const { return false; }\n+    virtual bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const { return false; }\n+    virtual bool GetKey(const CKeyID &address, CKey& key) const { return false; }\n };\n \n+extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n+\n /** Interface for signature creators. */\n class BaseSignatureCreator {\n public:"
      }
    ]
  },
  {
    "sha": "3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZDJjYmU2N2U0MTNlOGRlMGI3MTQ0MjgwYTE5YmIzNDhkMWE3NmNh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-08T21:39:36Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T17:42:40Z"
      },
      "message": "Remove CombineSignatures and replace tests\n\nRemoves CombineSignatures and replaces its use in tests with\nProduceSignature to test the same behavior for ProduceSignature.",
      "tree": {
        "sha": "639e6513390d94d3d5f40630e95e8699211a065b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/639e6513390d94d3d5f40630e95e8699211a065b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc99ba94bd0eb1d045f44a6d93d7e7949a76fd96"
      }
    ],
    "stats": {
      "total": 246,
      "additions": 63,
      "deletions": 183
    },
    "files": [
      {
        "sha": "08f68874e89dd710ba72b5430681a78d70613078",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 140,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
        "patch": "@@ -359,146 +359,6 @@ bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom,\n     return SignSignature(provider, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n-static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                               const std::vector<valtype>& vSolutions,\n-                               const std::vector<valtype>& sigs1, const std::vector<valtype>& sigs2, SigVersion sigversion)\n-{\n-    // Combine all the signatures we've got:\n-    std::set<valtype> allsigs;\n-    for (const valtype& v : sigs1)\n-    {\n-        if (!v.empty())\n-            allsigs.insert(v);\n-    }\n-    for (const valtype& v : sigs2)\n-    {\n-        if (!v.empty())\n-            allsigs.insert(v);\n-    }\n-\n-    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n-    assert(vSolutions.size() > 1);\n-    unsigned int nSigsRequired = vSolutions.front()[0];\n-    unsigned int nPubKeys = vSolutions.size()-2;\n-    std::map<valtype, valtype> sigs;\n-    for (const valtype& sig : allsigs)\n-    {\n-        for (unsigned int i = 0; i < nPubKeys; i++)\n-        {\n-            const valtype& pubkey = vSolutions[i+1];\n-            if (sigs.count(pubkey))\n-                continue; // Already got a sig for this pubkey\n-\n-            if (checker.CheckSig(sig, pubkey, scriptPubKey, sigversion))\n-            {\n-                sigs[pubkey] = sig;\n-                break;\n-            }\n-        }\n-    }\n-    // Now build a merged CScript:\n-    unsigned int nSigsHave = 0;\n-    std::vector<valtype> result; result.push_back(valtype()); // pop-one-too-many workaround\n-    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n-    {\n-        if (sigs.count(vSolutions[i+1]))\n-        {\n-            result.push_back(sigs[vSolutions[i+1]]);\n-            ++nSigsHave;\n-        }\n-    }\n-    // Fill any missing with OP_0:\n-    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n-        result.push_back(valtype());\n-\n-    return result;\n-}\n-\n-static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                                 const txnouttype txType, const std::vector<valtype>& vSolutions,\n-                                 Stacks sigs1, Stacks sigs2, SigVersion sigversion)\n-{\n-    switch (txType)\n-    {\n-    case TX_NONSTANDARD:\n-    case TX_NULL_DATA:\n-    case TX_WITNESS_UNKNOWN:\n-        // Don't know anything about this, assume bigger one is correct:\n-        if (sigs1.script.size() >= sigs2.script.size())\n-            return sigs1;\n-        return sigs2;\n-    case TX_PUBKEY:\n-    case TX_PUBKEYHASH:\n-        // Signatures are bigger than placeholders or empty scripts:\n-        if (sigs1.script.empty() || sigs1.script[0].empty())\n-            return sigs2;\n-        return sigs1;\n-    case TX_WITNESS_V0_KEYHASH:\n-        // Signatures are bigger than placeholders or empty scripts:\n-        if (sigs1.witness.empty() || sigs1.witness[0].empty())\n-            return sigs2;\n-        return sigs1;\n-    case TX_SCRIPTHASH:\n-        if (sigs1.script.empty() || sigs1.script.back().empty())\n-            return sigs2;\n-        else if (sigs2.script.empty() || sigs2.script.back().empty())\n-            return sigs1;\n-        else\n-        {\n-            // Recur to combine:\n-            valtype spk = sigs1.script.back();\n-            CScript pubKey2(spk.begin(), spk.end());\n-\n-            txnouttype txType2;\n-            std::vector<std::vector<unsigned char> > vSolutions2;\n-            Solver(pubKey2, txType2, vSolutions2);\n-            sigs1.script.pop_back();\n-            sigs2.script.pop_back();\n-            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, sigversion);\n-            result.script.push_back(spk);\n-            return result;\n-        }\n-    case TX_MULTISIG:\n-        return Stacks(CombineMultisig(scriptPubKey, checker, vSolutions, sigs1.script, sigs2.script, sigversion));\n-    case TX_WITNESS_V0_SCRIPTHASH:\n-        if (sigs1.witness.empty() || sigs1.witness.back().empty())\n-            return sigs2;\n-        else if (sigs2.witness.empty() || sigs2.witness.back().empty())\n-            return sigs1;\n-        else\n-        {\n-            // Recur to combine:\n-            CScript pubKey2(sigs1.witness.back().begin(), sigs1.witness.back().end());\n-            txnouttype txType2;\n-            std::vector<valtype> vSolutions2;\n-            Solver(pubKey2, txType2, vSolutions2);\n-            sigs1.witness.pop_back();\n-            sigs1.script = sigs1.witness;\n-            sigs1.witness.clear();\n-            sigs2.witness.pop_back();\n-            sigs2.script = sigs2.witness;\n-            sigs2.witness.clear();\n-            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SigVersion::WITNESS_V0);\n-            result.witness = result.script;\n-            result.script.clear();\n-            result.witness.push_back(valtype(pubKey2.begin(), pubKey2.end()));\n-            return result;\n-        }\n-    default:\n-        return Stacks();\n-    }\n-}\n-\n-SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                          const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n-{\n-    txnouttype txType;\n-    std::vector<std::vector<unsigned char> > vSolutions;\n-    Solver(scriptPubKey, txType, vSolutions);\n-\n-    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SigVersion::BASE).Output();\n-}\n-\n namespace {\n /** Dummy signature checker which accepts all signatures. */\n class DummySignatureChecker final : public BaseSignatureChecker"
      },
      {
        "sha": "b9c82b1249ff3b91a414ccc60b6304e36ce2ad83",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
        "patch": "@@ -76,9 +76,6 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n-/** Combine two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders. */\n-SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const SignatureData& scriptSig1, const SignatureData& scriptSig2);\n-\n /** Extract signature data from a transaction, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout);\n void UpdateInput(CTxIn& input, const SignatureData& data);"
      },
      {
        "sha": "c7cdd7ca826705637242703bcea3946afe5943d5",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 36,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
        "patch": "@@ -1161,10 +1161,19 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n \n+/* Wrapper around ProduceSignature to combine two scriptsigs */\n+SignatureData CombineSignatures(const CTxOut& txout, const CMutableTransaction& tx, const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n+{\n+    SignatureData data;\n+    data.MergeSignatureData(scriptSig1);\n+    data.MergeSignatureData(scriptSig2);\n+    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&tx, 0, txout.nValue), txout.scriptPubKey, data);\n+    return data;\n+}\n+\n BOOST_AUTO_TEST_CASE(script_combineSigs)\n {\n-    // Test the CombineSignatures function\n-    CAmount amount = 0;\n+    // Test the ProduceSignature's ability to combine signatures function\n     CBasicKeyStore keystore;\n     std::vector<CKey> keys;\n     std::vector<CPubKey> pubkeys;\n@@ -1180,52 +1189,51 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(keys[0].GetPubKey().GetID()));\n     CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom);\n     CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n-    CScript& scriptSig = txTo.vin[0].scriptSig;\n+    SignatureData scriptSig;\n \n     SignatureData empty;\n-    SignatureData combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, empty);\n+    SignatureData combined = CombineSignatures(txFrom.vout[0], txTo, empty, empty);\n     BOOST_CHECK(combined.scriptSig.empty());\n \n     // Single signature case:\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL); // changes scriptSig\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n-    CScript scriptSigCopy = scriptSig;\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    SignatureData scriptSigCopy = scriptSig;\n     // Signing again will give a different, valid signature:\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n \n     // P2SH, single-signature case:\n     CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n     keystore.AddCScript(pkSingle);\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n     scriptSigCopy = scriptSig;\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n-    // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n-    scriptSigCopy = CScript() << OP_0 << std::vector<unsigned char>(pkSingle.begin(), pkSingle.end());\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), SignatureData(scriptSigCopy));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n     scriptPubKey = GetScriptForMultisig(2, pubkeys);\n     keystore.AddCScript(scriptPubKey);\n     SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n-    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n \n     // A couple of partially-signed versions:\n     std::vector<unsigned char> sig1;\n@@ -1252,22 +1260,28 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript complete12 = CScript() << OP_0 << sig1 << sig2;\n     CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n     CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n-\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1a), SignatureData(partial1b));\n+    SignatureData partial1_sigs;\n+    partial1_sigs.signatures.emplace(keys[0].GetPubKey().GetID(), SigPair(keys[0].GetPubKey(), sig1));\n+    SignatureData partial2_sigs;\n+    partial2_sigs.signatures.emplace(keys[1].GetPubKey().GetID(), SigPair(keys[1].GetPubKey(), sig2));\n+    SignatureData partial3_sigs;\n+    partial3_sigs.signatures.emplace(keys[2].GetPubKey().GetID(), SigPair(keys[2].GetPubKey(), sig3));\n+\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial1_sigs);\n     BOOST_CHECK(combined.scriptSig == partial1a);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1a), SignatureData(partial2a));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial2_sigs);\n     BOOST_CHECK(combined.scriptSig == complete12);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial2a), SignatureData(partial1a));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial2_sigs, partial1_sigs);\n     BOOST_CHECK(combined.scriptSig == complete12);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1b), SignatureData(partial2b));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial2_sigs);\n     BOOST_CHECK(combined.scriptSig == complete12);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial1b));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial1_sigs);\n     BOOST_CHECK(combined.scriptSig == complete13);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial2a), SignatureData(partial3a));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial2_sigs, partial3_sigs);\n     BOOST_CHECK(combined.scriptSig == complete23);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial2b));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial2_sigs);\n     BOOST_CHECK(combined.scriptSig == complete23);\n-    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial3a));\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial3_sigs);\n     BOOST_CHECK(combined.scriptSig == partial3c);\n }\n "
      },
      {
        "sha": "45dc0e35713ebacc1973d6aa41f37aeb375748be",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 4,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d2cbe67e413e8de0b7144280a19bb348d1a76ca/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
        "patch": "@@ -494,6 +494,15 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     threadGroup.join_all();\n }\n \n+SignatureData CombineSignatures(const CMutableTransaction& input1, const CMutableTransaction& input2, const CTransactionRef tx)\n+{\n+    SignatureData sigdata;\n+    sigdata = DataFromTransaction(input1, 0, tx->vout[0]);\n+    sigdata.MergeSignatureData(DataFromTransaction(input2, 0, tx->vout[0]));\n+    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&input1, 0, tx->vout[0].nValue), tx->vout[0].scriptPubKey, sigdata);\n+    return sigdata;\n+}\n+\n BOOST_AUTO_TEST_CASE(test_witness)\n {\n     CBasicKeyStore keystore, keystore2;\n@@ -629,7 +638,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n     CheckWithFlag(output2, input2, 0, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n+    UpdateInput(input1.vin[0], CombineSignatures(input1, input2, output1));\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n     // P2SH 2-of-2 multisig\n@@ -640,7 +649,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n+    UpdateInput(input1.vin[0], CombineSignatures(input1, input2, output1));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -652,7 +661,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, 0, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n+    UpdateInput(input1.vin[0], CombineSignatures(input1, input2, output1));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n \n@@ -664,7 +673,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\n     CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n     BOOST_CHECK(*output1 == *output2);\n-    UpdateInput(input1.vin[0], CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0, output1->vout[0]), DataFromTransaction(input2, 0, output1->vout[0])));\n+    UpdateInput(input1.vin[0], CombineSignatures(input1, input2, output1));\n     CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n     CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n }"
      }
    ]
  },
  {
    "sha": "b7de8dede7d0df083266a340bcce0bf9bdcd4846",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiN2RlOGRlZGU3ZDBkZjA4MzI2NmEzNDBiY2NlMGJmOWJkY2Q0ODQ2",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-09-27T22:31:33Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T21:26:29Z"
      },
      "message": "Implement PSBT structures and un/serliazation methods per BIP 174",
      "tree": {
        "sha": "7a7fc87a1f1d9d3790552cf1839433beea574794",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a7fc87a1f1d9d3790552cf1839433beea574794"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7de8dede7d0df083266a340bcce0bf9bdcd4846",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7de8dede7d0df083266a340bcce0bf9bdcd4846",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7de8dede7d0df083266a340bcce0bf9bdcd4846",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7de8dede7d0df083266a340bcce0bf9bdcd4846/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d2cbe67e413e8de0b7144280a19bb348d1a76ca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3d2cbe67e413e8de0b7144280a19bb348d1a76ca"
      }
    ],
    "stats": {
      "total": 505,
      "additions": 505,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0985273f343822e1b4dfaa3477782ee7d8859a49",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=b7de8dede7d0df083266a340bcce0bf9bdcd4846",
        "patch": "@@ -107,6 +107,7 @@ class CPubKey\n \n     //! Simple read-only vector-like interface to the pubkey data.\n     unsigned int size() const { return GetLen(vch[0]); }\n+    const unsigned char* data() const { return vch; }\n     const unsigned char* begin() const { return vch; }\n     const unsigned char* end() const { return vch + size(); }\n     const unsigned char& operator[](unsigned int pos) const { return vch[pos]; }"
      },
      {
        "sha": "c68a140786240fdbbe8c315e457fd68fb6dd9e2b",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=b7de8dede7d0df083266a340bcce0bf9bdcd4846",
        "patch": "@@ -411,3 +411,71 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction(const PartiallySignedTransaction& psbtx_in) : tx(psbtx_in.tx), redeem_scripts(psbtx_in.redeem_scripts), witness_scripts(psbtx_in.witness_scripts), inputs(psbtx_in.inputs), unknown(psbtx_in.unknown), hd_keypaths(psbtx_in.hd_keypaths), num_ins(psbtx_in.num_ins), use_in_index(psbtx_in.use_in_index) {}\n+PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths)\n+{\n+    this->tx = tx;\n+    this->redeem_scripts = redeem_scripts;\n+    this->witness_scripts = witness_scripts;\n+    this->inputs = inputs;\n+    this->hd_keypaths = hd_keypaths;\n+\n+    SanitizeForSerialization();\n+}\n+\n+void PartiallySignedTransaction::SanitizeForSerialization()\n+{\n+    // Remove sigs from inputs\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        CTxIn& in = tx.vin[i];\n+        const PartiallySignedInput& psbt_in = inputs[i];\n+        CTxOut vout;\n+        if (psbt_in.non_witness_utxo) {\n+            vout = psbt_in.non_witness_utxo->vout[in.prevout.n];\n+        } else if (!psbt_in.witness_utxo.IsNull()) {\n+            vout = psbt_in.witness_utxo;\n+        } else {\n+            // There is no input here, skip\n+            continue;\n+        }\n+\n+        // Check the input for sigs. Remove partial sigs. Assume that they are already in partial_sigs\n+        ScriptError serror = SCRIPT_ERR_OK;\n+        const CAmount& amount = vout.nValue;\n+        const CTransaction const_tx(tx);\n+        if (!VerifyScript(in.scriptSig, vout.scriptPubKey, &in.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&const_tx, i, amount), &serror)) {\n+            in.scriptSig.clear();\n+            in.scriptWitness.SetNull();\n+        } else { // If this passes, then remove all input data for this input\n+            inputs[i].SetNull();\n+        }\n+    }\n+}\n+\n+void PartiallySignedTransaction::SetNull()\n+{\n+    tx = CMutableTransaction();\n+    redeem_scripts.clear();\n+    witness_scripts.clear();\n+    inputs.clear();\n+    hd_keypaths.clear();\n+}\n+\n+bool PartiallySignedTransaction::IsNull()\n+{\n+    return tx.vin.empty() && tx.vout.empty() && redeem_scripts.empty() && witness_scripts.empty() && inputs.empty() && hd_keypaths.empty();\n+}\n+\n+void PartiallySignedInput::SetNull()\n+{\n+    non_witness_utxo.reset();\n+    witness_utxo.SetNull();\n+    partial_sigs.clear();\n+    unknown.clear();\n+}\n+\n+bool PartiallySignedInput::IsNull()\n+{\n+    return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty();\n+}"
      },
      {
        "sha": "647e7bd427bb4722f10a201dd223177f6a6c0571",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 427,
        "deletions": 0,
        "changes": 427,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=b7de8dede7d0df083266a340bcce0bf9bdcd4846",
        "patch": "@@ -6,7 +6,10 @@\n #ifndef BITCOIN_SCRIPT_SIGN_H\n #define BITCOIN_SCRIPT_SIGN_H\n \n+#include <hash.h>\n+#include <pubkey.h>\n #include <script/interpreter.h>\n+#include <streams.h>\n \n class CKey;\n class CKeyID;\n@@ -69,6 +72,430 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        if (a.tx.vin.size() != b.tx.vin.size() || a.tx.vout.size() != b.tx.vout.size()) return false;\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                    s << sig_pair.second.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        s >> MakeSpan(redeemscript_bytes);\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        s >> MakeSpan(witnessscript_bytes);\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        s >> MakeSpan(sig);\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in key path\n+                        std::vector<uint32_t> keypath;\n+                        for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                            uint32_t index;\n+                            s >> index;\n+                            keypath.push_back(index);\n+                        }\n+\n+                        // Add to map\n+                        hd_keypaths.emplace(pubkey, keypath);\n+                    } else {\n+                        // Read in the sighash type\n+                        s >> input.sighash_type;\n+                    }\n+                    break;\n+                // Number of inputs and input index\n+                case PSBT_NUM_IN_VIN:\n+                    if (in_globals) {\n+                        num_ins = ReadCompactSize(s);\n+                    } else {\n+                        // Make sure that we are using input indexes or this is the first input\n+                        if (!use_in_index && separators != 1) {\n+                            throw std::ios_base::failure(\"Input indexes being used but an input does not provide its index\");\n+                        }\n+\n+                        input.index = ReadCompactSize(s);\n+                        use_in_index = true;\n+                        input.use_in_index = true;\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default:\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+\n+                    // global data\n+                    if (in_globals) {\n+                        unknown.emplace(std::move(key), std::move(val_bytes));\n+                    } else {\n+                        input.unknown.emplace(std::move(key), std::move(val_bytes));\n+                    }\n+            }\n+        }\n+\n+        // Make sure that the number of separators - 1 matches the number of inputs\n+        if (separators - 1 != num_ins && use_in_index) {\n+            throw std::ios_base::failure(\"Inputs provided does not match the number of inputs stated.\");\n+        }\n+\n+        // Make sure that the number of inputs matches the number of inputs in the transaction\n+        if (inputs.size() != tx.vin.size()) {\n+            throw std::ios_base::failure(\"Inputs provided does not match the number of inputs in transaction.\");\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedTransaction(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+\n+    void SanitizeForSerialization();\n+};\n+\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n "
      },
      {
        "sha": "1826fce5efcad1de76fe834dcbda97eb247bd222",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7de8dede7d0df083266a340bcce0bf9bdcd4846/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=b7de8dede7d0df083266a340bcce0bf9bdcd4846",
        "patch": "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32LE(int pos) const\n+    {\n+        const uint8_t* ptr = data + pos * 4;\n+        return ((uint32_t)ptr[0]) | \\\n+               ((uint32_t)ptr[1]) << 8 | \\\n+               ((uint32_t)ptr[2]) << 16 | \\\n+               ((uint32_t)ptr[3]) << 24;\n+    }\n+\n     template<typename Stream>\n     void Serialize(Stream& s) const\n     {"
      }
    ]
  },
  {
    "sha": "2fa265513cfbf7d034116be40a165803d808dce4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZmEyNjU1MTNjZmJmN2QwMzQxMTZiZTQwYTE2NTgwM2Q4MDhkY2U0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-09-27T22:43:18Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T21:26:29Z"
      },
      "message": "Implement a signer that takes an unserialized PSBT and signs it",
      "tree": {
        "sha": "a34218f228b87e0620cf4b49cf80dcd36623106b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a34218f228b87e0620cf4b49cf80dcd36623106b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2fa265513cfbf7d034116be40a165803d808dce4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fa265513cfbf7d034116be40a165803d808dce4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2fa265513cfbf7d034116be40a165803d808dce4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fa265513cfbf7d034116be40a165803d808dce4/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7de8dede7d0df083266a340bcce0bf9bdcd4846",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7de8dede7d0df083266a340bcce0bf9bdcd4846",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7de8dede7d0df083266a340bcce0bf9bdcd4846"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 70,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5b8c2fd102aa76c5a02d0cfa3b1a472552c918a3",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fa265513cfbf7d034116be40a165803d808dce4/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fa265513cfbf7d034116be40a165803d808dce4/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=2fa265513cfbf7d034116be40a165803d808dce4",
        "patch": "@@ -58,6 +58,12 @@ static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigd\n         pubkey = it->second.first;\n         return true;\n     }\n+    // Look for pubkey in pubkey list\n+    const auto& pk_it = sigdata->misc_pubkeys.find(address);\n+    if (pk_it != sigdata->misc_pubkeys.end()) {\n+        pubkey = pk_it->second;\n+        return true;\n+    }\n     return false;\n }\n \n@@ -359,6 +365,66 @@ bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom,\n     return SignSignature(provider, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+// Returns true if the transaction is finalized, false otherwise. False does not necessarily mean that signing failed, just that a complete set of signatures\n+// for the transaction does not exist or the final transaction was not constructed.\n+bool SignPartiallySignedTransaction(PartiallySignedTransaction& psbt, SigningProvider* provider, int nHashType, bool finalize)\n+{\n+    // Create the SignatureData with global data\n+    SignatureData sigdata;\n+    sigdata.scripts.insert(psbt.redeem_scripts.begin(), psbt.redeem_scripts.end());\n+    for (const auto& script_pair : psbt.witness_scripts) {\n+        sigdata.scripts.emplace(CScriptID(script_pair.second), script_pair.second);\n+    }\n+    for (const auto& key_pair : psbt.hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+\n+    CMutableTransaction mtx = psbt.tx;\n+    bool solved = finalize;\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        // Clear sigdata for input specific things\n+        sigdata.signatures.clear();\n+        sigdata.scriptSig.clear();\n+        sigdata.scriptWitness.SetNull();\n+        sigdata.complete = false;\n+\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        CScript script = utxo.scriptPubKey;\n+        const CAmount& amount = utxo.nValue;\n+\n+        sigdata.signatures.insert(psbt.inputs[i].partial_sigs.begin(), psbt.inputs[i].partial_sigs.end());\n+        MutableTransactionSignatureCreator creator(&mtx, i, amount, nHashType);\n+        bool sig_complete = ProduceSignature(*provider, creator, script, sigdata);\n+        psbt.inputs[i].partial_sigs.insert(sigdata.signatures.begin(), sigdata.signatures.end());\n+        if (sig_complete && finalize) {\n+            // signatures are complete\n+            // Add scriptsig/scriptwitness to transaction\n+            psbt.tx.vin[i].scriptSig = sigdata.scriptSig;\n+            psbt.tx.vin[i].scriptWitness = sigdata.scriptWitness;\n+        }\n+        solved &= sig_complete;\n+    }\n+\n+    return solved;\n+}\n+\n namespace {\n /** Dummy signature checker which accepts all signatures. */\n class DummySignatureChecker final : public BaseSignatureChecker"
      },
      {
        "sha": "72c49cb45f4f7d1383d707e99181ba5b50b69295",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2fa265513cfbf7d034116be40a165803d808dce4/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2fa265513cfbf7d034116be40a165803d808dce4/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=2fa265513cfbf7d034116be40a165803d808dce4",
        "patch": "@@ -10,6 +10,7 @@\n #include <pubkey.h>\n #include <script/interpreter.h>\n #include <streams.h>\n+#include <version.h>\n \n class CKey;\n class CKeyID;\n@@ -66,6 +67,7 @@ struct SignatureData {\n     CScriptWitness scriptWitness; // The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format\n     std::map<CKeyID, SigPair> signatures; // BIP 174 style partial signatures for the input. May contain complete signatures\n     std::map<CScriptID, CScript> scripts; // BIP 174 style scripts for the input\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n@@ -499,6 +501,8 @@ struct PartiallySignedTransaction\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n+bool SignPartiallySignedTransaction(PartiallySignedTransaction& psbt, SigningProvider* provider, int nHashType, bool finalize = false);\n+\n /** Produce a script signature for a transaction. */\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);"
      }
    ]
  },
  {
    "sha": "d35077262dcb74390e8e443183fc035cd4207586",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMzUwNzcyNjJkY2I3NDM5MGU4ZTQ0MzE4M2ZjMDM1Y2Q0MjA3NTg2",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-09-27T22:49:27Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T21:26:29Z"
      },
      "message": "Create RPCs for PSBT\n\nwalletupdatepsbt takes a PSBT format transaction, updates the\nPSBT with any inputs related to this wallet, and signs the transaction\n\nwalletcreatepsbt takes a raw network serialized transaction like\nwhat createrawtransaction and fundrawtransaction output and converts\nit to a PSBT using whatever information about the inputs it knows\nfrom the wallet.\n\ndecodepsbt takes a PSBT and decodes it to JSON\n\ncombinepsbt takes multiple PSBTs for the same tx and combines them.",
      "tree": {
        "sha": "6b33a28c101604595184e60247dc6c0a3012b15b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b33a28c101604595184e60247dc6c0a3012b15b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d35077262dcb74390e8e443183fc035cd4207586",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d35077262dcb74390e8e443183fc035cd4207586",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d35077262dcb74390e8e443183fc035cd4207586",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d35077262dcb74390e8e443183fc035cd4207586/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2fa265513cfbf7d034116be40a165803d808dce4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2fa265513cfbf7d034116be40a165803d808dce4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2fa265513cfbf7d034116be40a165803d808dce4"
      }
    ],
    "stats": {
      "total": 819,
      "additions": 819,
      "deletions": 0
    },
    "files": [
      {
        "sha": "416ef94d6725a9219ad91065a6fb16846d544c01",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d35077262dcb74390e8e443183fc035cd4207586/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d35077262dcb74390e8e443183fc035cd4207586/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=d35077262dcb74390e8e443183fc035cd4207586",
        "patch": "@@ -30,6 +30,8 @@ std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strN\n UniValue ValueFromAmount(const CAmount& amount);\n std::string FormatScript(const CScript& script);\n std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags = 0);\n+std::string SighashToStr(unsigned char sighash_type);\n+std::vector<uint8_t> Uint32ToUint8VectorLE(uint32_t in);\n void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex = true, int serialize_flags = 0);\n "
      },
      {
        "sha": "ad29f704c1d55d58cf8f2039f3807dea15e5e97d",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d35077262dcb74390e8e443183fc035cd4207586/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d35077262dcb74390e8e443183fc035cd4207586/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=d35077262dcb74390e8e443183fc035cd4207586",
        "patch": "@@ -70,6 +70,23 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    const auto& it = mapSigHashTypes.find(sighash_type);\n+    if (it == mapSigHashTypes.end()) return \"\";\n+    return it->second;\n+}\n+\n+std::vector<uint8_t> Uint32ToUint8VectorLE(uint32_t in)\n+{\n+    std::vector<uint8_t> bytes;\n+    bytes.push_back(in);\n+    bytes.push_back(in >> 8);\n+    bytes.push_back(in >> 16);\n+    bytes.push_back(in >> 24);\n+    return bytes;\n+}\n+\n /**\n  * Create the assembly string representation of a CScript object.\n  * @param[in] script    CScript object to convert into the asm string representation."
      },
      {
        "sha": "1a80632212774aa1baa1a11970ec7a3ff1f05499",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d35077262dcb74390e8e443183fc035cd4207586/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d35077262dcb74390e8e443183fc035cd4207586/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=d35077262dcb74390e8e443183fc035cd4207586",
        "patch": "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},\n+    { \"walletupdatepsbt\", 3, \"include_output_info\"},\n+    { \"walletcreatepsbt\", 1, \"include_output_info\"},\n+    { \"combinepsbt\", 0, \"txs\"},\n+    { \"combinepsbt\", 1, \"psbtformat\"},\n     { \"gettxout\", 1, \"n\" },\n     { \"gettxout\", 2, \"include_mempool\" },\n     { \"gettxoutproof\", 0, \"txids\" },"
      },
      {
        "sha": "0358a036c79ad861d3efd05862304ba9aee3c433",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 397,
        "deletions": 0,
        "changes": 397,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d35077262dcb74390e8e443183fc035cd4207586/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d35077262dcb74390e8e443183fc035cd4207586/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=d35077262dcb74390e8e443183fc035cd4207586",
        "patch": "@@ -1256,6 +1256,401 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"hexstring\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"n\\\" : n,                    (numeric) Index\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+            + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData(ParseHexV(request.params[0].get_str(), \"psbt\"));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Redeem scripts\n+    if (!psbtx.redeem_scripts.empty()) {\n+        UniValue redeem_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.redeem_scripts) {\n+            UniValue redeem_script(UniValue::VOBJ);\n+            redeem_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            redeem_script.pushKV(\"script\", r);\n+\n+            redeem_scripts.push_back(redeem_script);\n+        }\n+        result.pushKV(\"redeem_scripts\", redeem_scripts);\n+    }\n+\n+    // Witness Scripts\n+    if (!psbtx.witness_scripts.empty()) {\n+        UniValue witness_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.witness_scripts) {\n+            UniValue witness_script(UniValue::VOBJ);\n+            witness_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            witness_script.pushKV(\"script\", r);\n+\n+            witness_scripts.push_back(witness_script);\n+        }\n+        result.pushKV(\"witness_scripts\", witness_scripts);\n+    }\n+\n+    // keypaths\n+    if (!psbtx.hd_keypaths.empty()) {\n+        UniValue keypaths(UniValue::VARR);\n+        for (auto entry : psbtx.hd_keypaths) {\n+            UniValue keypath(UniValue::VOBJ);\n+            keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+            uint32_t fingerprint = entry.second.at(0);\n+            keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+            entry.second.erase(entry.second.begin());\n+            keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+            keypaths.push_back(keypath);\n+        }\n+        result.pushKV(\"bip32_derivs\", keypaths);\n+    }\n+\n+    // num_ins\n+    if (psbtx.num_ins > 0) {\n+        result.pushKV(\"inputs_provided\", psbtx.num_ins);\n+    }\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        PartiallySignedInput& input = psbtx.inputs.at(i);\n+        if (!input.IsNull()) {\n+            UniValue in(UniValue::VOBJ);\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+                out.pushKV(\"n\", (int64_t)i);\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // index\n+            in.pushKV(\"index\", (int)i);\n+            inputs.push_back(in);\n+        }\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"hexstring\\\",...] (psbtformat)\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"The combined transaction may be still be partially signed transaction, in which case\\n\"\n+            \"it will be a PSBT, or it may be fully signed transaction, in which case it will be a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hexstring\\\"             (string) A transaction hash\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"2. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"myhex1\\\", \\\"myhex2\\\", \\\"myhex3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData(ParseHexV(txs[i].get_str(), \"psbt\"));\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        for (const PartiallySignedTransaction& comp_psbtx : psbtxs) {\n+            if (psbtx != comp_psbtx) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+            }\n+        }\n+    }\n+\n+    // Merge the input fields\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    const CTransaction txConst(merged_psbtx.tx);\n+    // Merge global data\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        // Merge redeem_scripts\n+        merged_psbtx.redeem_scripts.insert(psbtx.redeem_scripts.begin(), psbtx.redeem_scripts.end());\n+\n+        // Merge witness_scripts\n+        merged_psbtx.witness_scripts.insert(psbtx.witness_scripts.begin(), psbtx.witness_scripts.end());\n+\n+        // Merge unknown\n+        merged_psbtx.unknown.insert(psbtx.unknown.begin(), psbtx.unknown.end());\n+\n+        // Merge hd_keypaths\n+        merged_psbtx.hd_keypaths.insert(psbtx.hd_keypaths.begin(), psbtx.hd_keypaths.end());\n+\n+        // If one of these is using input indexes, then use input indexes\n+        if (psbtx.use_in_index) {\n+            merged_psbtx.use_in_index = true;\n+        }\n+    }\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        SignatureData sigdata;\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input partial signatures\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            UpdateInput(txin, sigdata);\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Sign what we can:\n+    bool return_finalized = request.params[1].isNull() || (!request.params[1].isNull() && !request.params[1].get_bool());\n+    bool fComplete = false;\n+    if (return_finalized) {\n+        fComplete = SignPartiallySignedTransaction(merged_psbtx, nullptr, 1 /* sighash, doesn't matter */, return_finalized);\n+    }\n+    merged_psbtx.SanitizeForSerialization();\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    if (fComplete && return_finalized) {\n+        ssTx << merged_psbtx.tx;\n+    } else {\n+        ssTx << merged_psbtx;\n+    }\n+    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                            actor (function)            argNames\n   //  --------------------- ------------------------        -----------------------     ----------\n@@ -1268,6 +1663,8 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"signrawtransaction\",           &signrawtransaction,        {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n     { \"rawtransactions\",    \"signrawtransactionwithkey\",    &signrawtransactionwithkey, {\"hexstring\",\"privkeys\",\"prevtxs\",\"sighashtype\"} },\n     { \"rawtransactions\",    \"testmempoolaccept\",            &testmempoolaccept,         {\"rawtxs\",\"allowhighfees\"} },\n+    { \"rawtransactions\",    \"decodepsbt\",                   &decodepsbt,                {\"hexstring\"} },\n+    { \"rawtransactions\",    \"combinepsbt\",                  &combinepsbt,               {\"txs\",\"psbtformat\"} },\n \n     { \"blockchain\",         \"gettxoutproof\",                &gettxoutproof,             {\"txids\", \"blockhash\"} },\n     { \"blockchain\",         \"verifytxoutproof\",             &verifytxoutproof,          {\"proof\"} },"
      },
      {
        "sha": "009692152082fa427479b43515ac3368cb9f17a3",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 398,
        "deletions": 0,
        "changes": 398,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d35077262dcb74390e8e443183fc035cd4207586/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d35077262dcb74390e8e443183fc035cd4207586/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=d35077262dcb74390e8e443183fc035cd4207586",
        "patch": "@@ -4339,6 +4339,402 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wallets\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+            + HelpExampleRpc(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VSTR, UniValue::VBOOL});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData(ParseHexV(request.params[0].get_str(), \"psbt\"));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Sign the transaction\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[1].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Script verification errors\n+    UniValue vErrors(UniValue::VARR);\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    CMutableTransaction mtx = psbtx.tx;\n+    const CTransaction txConst(mtx);\n+\n+    // Fill transaction with out data\n+    bool include_output_info = !request.params[3].isNull() && request.params[3].get_bool();\n+    fill_psbt(pwallet, psbtx, &txConst, include_output_info);\n+\n+    // Sign what we can:\n+    bool return_finalized = request.params[2].isNull() || (!request.params[2].isNull() && !request.params[2].get_bool());\n+    bool fComplete = SignPartiallySignedTransaction(psbtx, pwallet, nHashType, return_finalized);\n+    psbtx.SanitizeForSerialization();\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    if (fComplete && return_finalized) {\n+        ssTx << psbtx.tx;\n+    } else {\n+        ssTx << psbtx;\n+    }\n+    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n+UniValue walletcreatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 2 || request.params.size() < 1)\n+        throw std::runtime_error(\n+                            \"walletcreatepsbt \\\"hexstring\\\" ( include_output_info )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format from a\\n\"\n+                            \"raw transaction that was funded with inputs from our wallet, typically from\\n\"\n+                            \"using fundrawtransaction.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"            (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. \\\"include_output_info\\\"  (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+                            \"                          scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wallets\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"hex\\\": \\\"value\\\",         (string)  The resulting raw transaction (hex-encoded string)\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction with no inputs\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+                            \"\\nAdd sufficient unsigned inputs to meet the output value\\n\"\n+                            + HelpExampleCli(\"fundrawtransaction\", \"\\\"rawtransactionhex\\\"\") +\n+                            \"\\nMake PSBT to sign elsewhere\\n\"\n+                            + HelpExampleCli(\"walletcreatepsbt\", \"\\\"fundedtransactionhex\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    CMutableTransaction mtx;\n+\n+    // Decode the transaction\n+    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.SetNull();\n+\n+    // Fill the psbtx\n+    const CTransaction txConst(mtx);\n+    bool include_output_info = !request.params[1].isNull() && request.params[1].get_bool();\n+    fill_psbt(pwallet, psbtx, &txConst, include_output_info);\n+    psbtx.tx = mtx;\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return HexStr(ssTx.begin(), ssTx.end());\n+}\n+\n extern UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n@@ -4355,6 +4751,8 @@ static const CRPCCommand commands[] =\n { //  category              name                                actor (function)                argNames\n     //  --------------------- ------------------------          -----------------------         ----------\n     { \"rawtransactions\",    \"fundrawtransaction\",               &fundrawtransaction,            {\"hexstring\",\"options\",\"iswitness\"} },\n+    { \"wallet\",             \"walletupdatepsbt\",                 &walletupdatepsbt,              {\"hexstring\",\"sighashtype\",\"psbtformat\",\"include_output_info\"} },\n+    { \"wallet\",             \"walletcreatepsbt\",                 &walletcreatepsbt,              {\"hexstring\",\"include_output_info\"} },\n     { \"hidden\",             \"resendwallettransactions\",         &resendwallettransactions,      {} },\n     { \"wallet\",             \"abandontransaction\",               &abandontransaction,            {\"txid\"} },\n     { \"wallet\",             \"abortrescan\",                      &abortrescan,                   {} },"
      }
    ]
  },
  {
    "sha": "950746725a0ec1dbf155299bb5fffbd7dc2f76eb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NTA3NDY3MjVhMGVjMWRiZjE1NTI5OWJiNWZmZmJkN2RjMmY3NmVi",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-09-27T22:52:14Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-14T21:26:29Z"
      },
      "message": "Test the PSBT RPCs",
      "tree": {
        "sha": "c6521d7a25cdf8858283feed6c0347df983ff3b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c6521d7a25cdf8858283feed6c0347df983ff3b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/950746725a0ec1dbf155299bb5fffbd7dc2f76eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/950746725a0ec1dbf155299bb5fffbd7dc2f76eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/950746725a0ec1dbf155299bb5fffbd7dc2f76eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/950746725a0ec1dbf155299bb5fffbd7dc2f76eb/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d35077262dcb74390e8e443183fc035cd4207586",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d35077262dcb74390e8e443183fc035cd4207586",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d35077262dcb74390e8e443183fc035cd4207586"
      }
    ],
    "stats": {
      "total": 151,
      "additions": 151,
      "deletions": 0
    },
    "files": [
      {
        "sha": "867d2c79458e21d777e5e08d4ea1a07abe699fb3",
        "filename": "test/functional/rpc_psbt.py",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/950746725a0ec1dbf155299bb5fffbd7dc2f76eb/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/950746725a0ec1dbf155299bb5fffbd7dc2f76eb/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=950746725a0ec1dbf155299bb5fffbd7dc2f76eb",
        "patch": "@@ -0,0 +1,150 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\n+Test the following RPCs:\n+   - walletcreatepsbt\n+   - walletupdatepsbt\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        self.extra_args = [[\"-addresstype=legacy\"], [\"-addresstype=legacy\", \"-deprecatedrpc=addwitnessaddress\"], [\"-addresstype=legacy\"]]\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)\n+\n+        # Create and fund a raw tx for sending 10 BTC\n+        rawtx = self.nodes[0].createrawtransaction([], {self.nodes[1].getnewaddress():10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx)['hex']\n+\n+        # Node 1 should not be able to sign it but still return the psbtx same as before\n+        psbtx1 = self.nodes[0].walletcreatepsbt(rawtx)\n+        psbtx = self.nodes[1].walletupdatepsbt(psbtx1)['hex']\n+        assert_equal(psbtx1, psbtx)\n+\n+        # Sign the transaction and send\n+        signed_tx = self.nodes[0].walletupdatepsbt(psbtx)['hex']\n+        self.nodes[0].sendrawtransaction(signed_tx)\n+\n+        # Create p2sh, p2wpkh, and p2wsh addresses\n+        pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey']\n+        pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey']\n+        p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2])['address']\n+        p2wsh = self.nodes[1].addwitnessaddress(p2sh)\n+        p2wpkh = self.nodes[1].getnewaddress()\n+\n+        # fund those addresses\n+        rawtx = self.nodes[0].createrawtransaction([], {p2sh:10, p2wsh:10, p2wpkh:10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n+        signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n+        txid = self.nodes[0].sendrawtransaction(signed_tx)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+\n+        # Find the output pos\n+        p2sh_pos = -1\n+        p2wsh_pos = -1\n+        p2wpkh_pos = -1\n+        decoded = self.nodes[0].decoderawtransaction(signed_tx)\n+        for out in decoded['vout']:\n+            if out['scriptPubKey']['addresses'][0] == p2sh:\n+                p2sh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wsh:\n+                p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wpkh:\n+                p2wpkh_pos = out['n']\n+\n+        # spend p2wpkh from node 1\n+        rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wpkh_pos}], {self.nodes[1].getnewaddress():9.99})\n+        psbtx = self.nodes[1].walletcreatepsbt(rawtx)\n+        walletupdatepsbt_out = self.nodes[1].walletupdatepsbt(psbtx)\n+        assert_equal(walletupdatepsbt_out['complete'], True)\n+        self.nodes[1].sendrawtransaction(walletupdatepsbt_out['hex'])\n+\n+        # partially sign p2sh and p2wsh with node 1\n+        rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos}], {self.nodes[1].getnewaddress():19.99})\n+        psbtx = self.nodes[1].walletcreatepsbt(rawtx)\n+        walletupdatepsbt_out = self.nodes[1].walletupdatepsbt(psbtx)\n+        psbtx = walletupdatepsbt_out['hex']\n+        assert_equal(walletupdatepsbt_out['complete'], False)\n+\n+        # partially sign with node 2. This should be complete and sendable\n+        walletupdatepsbt_out = self.nodes[2].walletupdatepsbt(psbtx)\n+        assert_equal(walletupdatepsbt_out['complete'], True)\n+        self.nodes[2].sendrawtransaction(walletupdatepsbt_out['hex'])\n+\n+        # check that walletupdatepsbt fails to decode a non-psbt\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletupdatepsbt, rawtx)\n+\n+        # check that walletcreatepsbt fails to decode a psbt\n+        walletupdatepsbt_out = self.nodes[2].walletupdatepsbt(psbtx, \"ALL\", True)\n+        psbtx = walletupdatepsbt_out['hex']\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletcreatepsbt, psbtx)\n+\n+        # Check that unknown values are just passed through\n+        unknown_psbt = \"70736274ff0a080102030405060708090f0102030405060708090a0b0c0d0e0f00\"\n+        unknown_out = self.nodes[0].walletupdatepsbt(unknown_psbt, \"ALL\", True)['hex']\n+        assert_equal(unknown_psbt, unknown_out)\n+\n+        # Test against BIP 174 test vectors\n+\n+        # Invalid PSBTs\n+        # Network transaction, not PSBT format\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decodepsbt, \"0200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf6000000006a473044022070b2245123e6bf474d60c5b50c043d4c691a5d2435f09a34a7662a9dc251790a022001329ca9dacf280bdf30740ec0390422422c81cb45839457aeb76fc12edd95b3012102657d118d3357b8e0f4c2cd46db7b39f6d9c38d9a70abcb9b2de5dc8dbfe4ce31feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300\")\n+        # PSBT missing null terminator\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decodepsbt, \"70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab300000000\")\n+        # PSBT with one P2PKH input and one P2SH-P2WPKH input with only the first input signed, finalized, and skipped. Input index is specified but total input count is not given.\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decodepsbt, \"70736274ff0100fd0a010200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be4000000006a47304402204759661797c01b036b25928948686218347d89864b719e1f7fcf57d1e511658702205309eabf56aa4d8891ffd111fdf1336f3a29da866d7f8486d75546ceedaf93190121035cdc61fc7ba971c0b501a646a2a83b102cb43881217ca682dc86e2d73fa88292feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac0000000015013545e6e33b832c47050f24d3eeb93c9c03948bc716001485d13537f2e265405a34dbafa9e3dda01fb823080001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc7870104010200\")\n+        # PSBT with one P2PKH input and one P2SH-P2WPKH input with only the first input signed, finalized, and skipped. Total input count is given but second input does not have its index.\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decodepsbt, \"70736274ff0100fd0a010200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be4000000006a47304402204759661797c01b036b25928948686218347d89864b719e1f7fcf57d1e511658702205309eabf56aa4d8891ffd111fdf1336f3a29da866d7f8486d75546ceedaf93190121035cdc61fc7ba971c0b501a646a2a83b102cb43881217ca682dc86e2d73fa88292feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac0000000015013545e6e33b832c47050f24d3eeb93c9c03948bc716001485d13537f2e265405a34dbafa9e3dda01fb82308010401010001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc78700\")\n+\n+        # Valid PSBTs\n+        # PSBT with one P2PKH input which has a non-final scriptSig.\n+        self.nodes[0].decodepsbt(\"70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab30000000000\")\n+        # PSBT with one P2PKH input which has a non-final scriptSig and sighash type specified.\n+        self.nodes[0].decodepsbt(\"70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab3000000000103040100000000\")\n+        # PSBT with one P2PKH input and one P2SH-P2WPKH input both with non-final scriptSigs. P2SH-P2WPKH input's redeemScript is available.\n+        self.nodes[0].decodepsbt(\"70736274ff0100a00200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40000000000feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac0000000015013545e6e33b832c47050f24d3eeb93c9c03948bc716001485d13537f2e265405a34dbafa9e3dda01fb82308000100df0200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf6000000006a473044022070b2245123e6bf474d60c5b50c043d4c691a5d2435f09a34a7662a9dc251790a022001329ca9dacf280bdf30740ec0390422422c81cb45839457aeb76fc12edd95b3012102657d118d3357b8e0f4c2cd46db7b39f6d9c38d9a70abcb9b2de5dc8dbfe4ce31feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e13000001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc78700\")\n+        # PSBT with one P2PKH input and one P2SH-P2WPKH input with only the first input signed and finalized.\n+        self.nodes[0].decodepsbt(\"70736274ff0100fd0a010200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be4000000006a47304402204759661797c01b036b25928948686218347d89864b719e1f7fcf57d1e511658702205309eabf56aa4d8891ffd111fdf1336f3a29da866d7f8486d75546ceedaf93190121035cdc61fc7ba971c0b501a646a2a83b102cb43881217ca682dc86e2d73fa88292feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac0000000015013545e6e33b832c47050f24d3eeb93c9c03948bc716001485d13537f2e265405a34dbafa9e3dda01fb82308000001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc78700\")\n+        # PSBT with one P2PKH input and one P2SH-P2WPKH input with only the first input signed, finalized, and skipped. Input indexes are used.\n+        self.nodes[0].decodepsbt(\"70736274ff0100fd0a010200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be4000000006a47304402204759661797c01b036b25928948686218347d89864b719e1f7fcf57d1e511658702205309eabf56aa4d8891ffd111fdf1336f3a29da866d7f8486d75546ceedaf93190121035cdc61fc7ba971c0b501a646a2a83b102cb43881217ca682dc86e2d73fa88292feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac0000000015013545e6e33b832c47050f24d3eeb93c9c03948bc716001485d13537f2e265405a34dbafa9e3dda01fb82308010401010001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc7870104010100\")\n+        # PSBT with one P2SH-P2WSH input of a 2-of-2 multisig, redeemScript, witnessScript, and keypaths are available. Contains one signature.\n+        self.nodes[0].decodepsbt(\"70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000015016345200f68d189e1adc0df1c4d16ea8f14c0dbeb220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d56812102771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d568147522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220303b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220303de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba67000000800000008005000080000100fd51010200000002f1d8d4b1acab9217bcbd0a09e37876efd79cf753baa2b2362e7d429c0deafbf5000000006a47304402202f29ddfff387626cf43fcae483456fb9d12d7f50fb10b39c245bab238d960d6502200f32fa3197dc6aa1fc870e33d8c590378862ce0b9bf6be865d5aac0a7390ae3a012102ead596687ca806043edc3de116cdf29d5e9257c196cd055cf698c8d02bf24e99fefffffff1d8d4b1acab9217bcbd0a09e37876efd79cf753baa2b2362e7d429c0deafbf5010000006b483045022100dc3bc94086fd7d48102a8290c737e27841bc1ce587fd4d9efe96a37d88c03a6502206dea717b8225b4ae9e1624bfc02927edac222ee094bf009996d9d0305d7645f501210394f62be9df19952c5587768aeb7698061ad2c4a25c894f47d8c162b4d7213d05feffffff01955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87fb2e1300220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a0100\")\n+\n+        # TODO: Creator tests\n+\n+        # Signer tests\n+        self.nodes[0].importprivkey(\"cQxozhqme9dcDbxT97uDu1P32Cnywc5nAMhPtQwyWhVgQnP43WGH\")\n+        self.nodes[0].importprivkey(\"cP3ArXq5BpHE94R4buJ5uma4pyKvaWXUd5Bpsy3hS2zA69X9KMnM\")\n+        signed_tx1 = self.nodes[0].walletupdatepsbt(\"70736274ff01007c02000000022e8c7d8d37c427e060ec002ec1c2bc30196fc2f75d6a8844cbc03651c081430a0100000000ffffffff96a04e0cc636f377933e3d93accc627faacdbcdb5a9624df1b490bd045f24d2c0000000000ffffffff01e02be50e0000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d87000000001501203736c3c06053896d7041ce8f5bae3df76cc49147522103c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c02103c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977352ae1501f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d5220020a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df2102a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df47522102e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87210258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e52ae000100fdff0002000000018b2dd2f735d0a9338af96402a8a91e4841cd3fed882362e7329fb04f1ff65325000000006a473044022077bedfea9910c9ba4e00dec941dace974f8b47349992c5d4312c1cf5796cce5502206164e6bfff7ac11590064ca571583709337c8a38973db2e70f4e9d93b3bcce1d0121032d64447459784e37cb2dda366c697adbbdc8aae2ad6db74ed2dade39d75882fafeffffff0382b42a04000000001976a914da533648fd339d5797790e6bb1667d9e86fdfb6888ac80f0fa020000000017a914203736c3c06053896d7041ce8f5bae3df76cc4918700b4c4040000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d879e2f13000001012000c2eb0b0000000017a914f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d58700\")['hex']\n+        assert_equal(signed_tx1, \"70736274ff01007c02000000022e8c7d8d37c427e060ec002ec1c2bc30196fc2f75d6a8844cbc03651c081430a0100000000ffffffff96a04e0cc636f377933e3d93accc627faacdbcdb5a9624df1b490bd045f24d2c0000000000ffffffff01e02be50e0000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d87000000001501203736c3c06053896d7041ce8f5bae3df76cc49147522103c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c02103c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977352ae1501f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d5220020a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df2102a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df47522102e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87210258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e52ae000100fdff0002000000018b2dd2f735d0a9338af96402a8a91e4841cd3fed882362e7329fb04f1ff65325000000006a473044022077bedfea9910c9ba4e00dec941dace974f8b47349992c5d4312c1cf5796cce5502206164e6bfff7ac11590064ca571583709337c8a38973db2e70f4e9d93b3bcce1d0121032d64447459784e37cb2dda366c697adbbdc8aae2ad6db74ed2dade39d75882fafeffffff0382b42a04000000001976a914da533648fd339d5797790e6bb1667d9e86fdfb6888ac80f0fa020000000017a914203736c3c06053896d7041ce8f5bae3df76cc4918700b4c4040000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d879e2f1300220203c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977347304402202a690a7a8d5763839df48285dea09f8ca69accd0227db9b735858eb87512a35b02204d294da3240bb1b069b728ddd5ce77dab61a9edf8db996268775a79a62817286010001012000c2eb0b0000000017a914f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d587220202e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87483045022100f75f171e172383026972f8ed9986dba1db1f4fd12c9530b27d216b0b9fea60ac02206b288ffdeb2c6aa5e6c24aea4294e91c384249b04b29977dff7d5d53d8db71520100\")\n+\n+        self.nodes[1].importprivkey(\"cUL8UxFiJjnLkkZwmmXDxmaNRQfEMDP44eZnSaiYR3KUJNv82chM\")\n+        self.nodes[1].importprivkey(\"cNQm3eSF9rQnpoUB8xThUVDfaeRVEckPK11rGB6LjweFdhwcCS4A\")\n+        signed_tx2 = self.nodes[1].walletupdatepsbt(\"70736274ff01007c02000000022e8c7d8d37c427e060ec002ec1c2bc30196fc2f75d6a8844cbc03651c081430a0100000000ffffffff96a04e0cc636f377933e3d93accc627faacdbcdb5a9624df1b490bd045f24d2c0000000000ffffffff01e02be50e0000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d87000000001501203736c3c06053896d7041ce8f5bae3df76cc49147522103c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c02103c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977352ae1501f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d5220020a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df2102a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df47522102e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87210258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e52ae000100fdff0002000000018b2dd2f735d0a9338af96402a8a91e4841cd3fed882362e7329fb04f1ff65325000000006a473044022077bedfea9910c9ba4e00dec941dace974f8b47349992c5d4312c1cf5796cce5502206164e6bfff7ac11590064ca571583709337c8a38973db2e70f4e9d93b3bcce1d0121032d64447459784e37cb2dda366c697adbbdc8aae2ad6db74ed2dade39d75882fafeffffff0382b42a04000000001976a914da533648fd339d5797790e6bb1667d9e86fdfb6888ac80f0fa020000000017a914203736c3c06053896d7041ce8f5bae3df76cc4918700b4c4040000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d879e2f13000001012000c2eb0b0000000017a914f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d58700\")['hex']\n+        assert_equal(signed_tx2, \"70736274ff01007c02000000022e8c7d8d37c427e060ec002ec1c2bc30196fc2f75d6a8844cbc03651c081430a0100000000ffffffff96a04e0cc636f377933e3d93accc627faacdbcdb5a9624df1b490bd045f24d2c0000000000ffffffff01e02be50e0000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d87000000001501203736c3c06053896d7041ce8f5bae3df76cc49147522103c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c02103c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977352ae1501f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d5220020a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df2102a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df47522102e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87210258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e52ae000100fdff0002000000018b2dd2f735d0a9338af96402a8a91e4841cd3fed882362e7329fb04f1ff65325000000006a473044022077bedfea9910c9ba4e00dec941dace974f8b47349992c5d4312c1cf5796cce5502206164e6bfff7ac11590064ca571583709337c8a38973db2e70f4e9d93b3bcce1d0121032d64447459784e37cb2dda366c697adbbdc8aae2ad6db74ed2dade39d75882fafeffffff0382b42a04000000001976a914da533648fd339d5797790e6bb1667d9e86fdfb6888ac80f0fa020000000017a914203736c3c06053896d7041ce8f5bae3df76cc4918700b4c4040000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d879e2f1300220203c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c047304402204a33aa884465a7d909000c366afb90c9256b66575f0c7e5f12446a16d8cc1a4d02203fa9fc43d50168f000b280be6b3db916cf9e483de8e6d9eac948b0d08f7601df010001012000c2eb0b0000000017a914f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d58722020258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e483045022100cdac5ee547b60f79feec111d0e082c3350b30a087c130d5e734e0199b3f8c14702205deddd38d8f7ddb19931059f46b2de0c8548fe79f8c8aea34c5e653ea0136b950100\")\n+\n+        # Combiner test\n+        combined = self.nodes[2].combinepsbt([signed_tx1, signed_tx2], True)['hex']\n+        assert_equal(combined, \"70736274ff01007c02000000022e8c7d8d37c427e060ec002ec1c2bc30196fc2f75d6a8844cbc03651c081430a0100000000ffffffff96a04e0cc636f377933e3d93accc627faacdbcdb5a9624df1b490bd045f24d2c0000000000ffffffff01e02be50e0000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d87000000001501203736c3c06053896d7041ce8f5bae3df76cc49147522103c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c02103c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977352ae1501f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d5220020a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df2102a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590df47522102e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87210258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e52ae000100fdff0002000000018b2dd2f735d0a9338af96402a8a91e4841cd3fed882362e7329fb04f1ff65325000000006a473044022077bedfea9910c9ba4e00dec941dace974f8b47349992c5d4312c1cf5796cce5502206164e6bfff7ac11590064ca571583709337c8a38973db2e70f4e9d93b3bcce1d0121032d64447459784e37cb2dda366c697adbbdc8aae2ad6db74ed2dade39d75882fafeffffff0382b42a04000000001976a914da533648fd339d5797790e6bb1667d9e86fdfb6888ac80f0fa020000000017a914203736c3c06053896d7041ce8f5bae3df76cc4918700b4c4040000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d879e2f1300220203c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977347304402202a690a7a8d5763839df48285dea09f8ca69accd0227db9b735858eb87512a35b02204d294da3240bb1b069b728ddd5ce77dab61a9edf8db996268775a79a6281728601220203c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c047304402204a33aa884465a7d909000c366afb90c9256b66575f0c7e5f12446a16d8cc1a4d02203fa9fc43d50168f000b280be6b3db916cf9e483de8e6d9eac948b0d08f7601df010001012000c2eb0b0000000017a914f3ba8a120d960ae07d1dbe6f0c37fb4c926d76d58722020258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e483045022100cdac5ee547b60f79feec111d0e082c3350b30a087c130d5e734e0199b3f8c14702205deddd38d8f7ddb19931059f46b2de0c8548fe79f8c8aea34c5e653ea0136b9501220202e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87483045022100f75f171e172383026972f8ed9986dba1db1f4fd12c9530b27d216b0b9fea60ac02206b288ffdeb2c6aa5e6c24aea4294e91c384249b04b29977dff7d5d53d8db71520100\")\n+\n+        # Finalizer test\n+        finalized = self.nodes[2].combinepsbt([combined], False)['hex']\n+        assert_equal(finalized, \"020000000001022e8c7d8d37c427e060ec002ec1c2bc30196fc2f75d6a8844cbc03651c081430a01000000d90047304402204a33aa884465a7d909000c366afb90c9256b66575f0c7e5f12446a16d8cc1a4d02203fa9fc43d50168f000b280be6b3db916cf9e483de8e6d9eac948b0d08f7601df0147304402202a690a7a8d5763839df48285dea09f8ca69accd0227db9b735858eb87512a35b02204d294da3240bb1b069b728ddd5ce77dab61a9edf8db996268775a79a628172860147522103c8727ce35f1c93eb0be21406ee9a923c89219fe9c9e8504c8314a6a22d1295c02103c74dc710c407d7db6e041ee212d985cd2826d93f806ed44912b9a1da691c977352aeffffffff96a04e0cc636f377933e3d93accc627faacdbcdb5a9624df1b490bd045f24d2c0000000023220020a8f44467bf171d51499153e01c0bd6291109fc38bd21b3c3224c9dc6b57590dfffffffff01e02be50e0000000017a914b53bb0dc1db8c8d803e3e39f784d42e4737ffa0d87000400483045022100f75f171e172383026972f8ed9986dba1db1f4fd12c9530b27d216b0b9fea60ac02206b288ffdeb2c6aa5e6c24aea4294e91c384249b04b29977dff7d5d53d8db715201483045022100cdac5ee547b60f79feec111d0e082c3350b30a087c130d5e734e0199b3f8c14702205deddd38d8f7ddb19931059f46b2de0c8548fe79f8c8aea34c5e653ea0136b950147522102e80dec31d167865c1685e9d7a9291e66a4ea22c65cfee324289a1667ccda3b87210258cbbc3cb295a8bebac233aadc7773978804993798be5390ab444f6dd4c5327e52ae00000000\")\n+\n+if __name__ == '__main__':\n+    PSBTTest().main()"
      },
      {
        "sha": "194effc4dec69094123437f006c8c20ce6883772",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/950746725a0ec1dbf155299bb5fffbd7dc2f76eb/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/950746725a0ec1dbf155299bb5fffbd7dc2f76eb/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=950746725a0ec1dbf155299bb5fffbd7dc2f76eb",
        "patch": "@@ -99,6 +99,7 @@\n     'wallet_multiwallet.py',\n     'wallet_multiwallet.py --usecli',\n     'interface_http.py',\n+    'rpc_psbt.py',\n     'rpc_users.py',\n     'feature_proxy.py',\n     'rpc_signrawtransaction.py',"
      }
    ]
  }
]