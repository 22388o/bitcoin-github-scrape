[
  {
    "sha": "f3044fd191505253e7914916c784235698514e1e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzA0NGZkMTkxNTA1MjUzZTc5MTQ5MTZjNzg0MjM1Njk4NTE0ZTFl",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-06-05T16:10:30Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-06-22T04:56:40Z"
      },
      "message": "Add first-seen-safe replace-by-fee logic to the mempool\n\nReplaces transactions already in the mempool if a new transaction is\nseen with a higher fee, provided that the replacement transaction's\noutputs pay all previous outputs an equal or greater amount. This\npreserves the \"first seen\" behavior of the mempool, in the sense that a\ntransaction will never be replaced in a fashion that prevents an address\nfrom receiving funds that it otherwise would have. In short, zero-conf\ntransactions are unaffected.\n\nTo prevent replacements from being used as a DoS attack mechanism a\nreplacement only happens if the new transaction has a higher fee, pays a\nhigher fee/KB rate, and the fee increase is sufficient to pay for the\nbandwidth consumed in relaying the replacement.\n\nIncludes stand-alone unittests for regtest in qa/replace-by-fee/",
      "tree": {
        "sha": "8d93ebd30e3d89bb5c8b562de5f11ad1889b45e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8d93ebd30e3d89bb5c8b562de5f11ad1889b45e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3044fd191505253e7914916c784235698514e1e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJVh5WJXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwNzdiYjRlOTUzY2ViNTYxNTQwODk4NDBjYzVjOWRjZmU3\nYmEyNTY2MTVlODhhNjgvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQJIFAPaXwkfvQ2Qf9Gt5mWMDB8QYrgi/h/Zlu6VcO\ntd+LoXL/jm76qV+P/uBJTzHBywyxsdvKgv5Tsy8sN/k4A0bXT5p2SvL+G+rRTQLN\nVKwJf+BWpkXOwCq6V5TvLc1GxxjYRszec9kBZDSVAieiKJ2O+pH2cE5p5/cbcwUk\nzvfeMokpDt3Wq/25ZVf0J7khm5y6UlkGwxf4MnmZXl0LgI13tDm3Ybuy3plZa+al\n2SZBlEjMCLp4eB/8AgrRISkBCqsdDQspZMVLm3yGwKEO2TzFQgITm+qj88Wp3Ini\ngR+w7zkjsrwv1pH9GhFdOnm3HJSeBgBzfIZjfdLnaukeDlfnTpWOSqOJBobdwQ==\n=4KFo\n-----END PGP SIGNATURE-----",
        "payload": "tree 8d93ebd30e3d89bb5c8b562de5f11ad1889b45e5\nparent 247b91449ad7d041c6af5d2abf5660ab00be0fb4\nauthor Peter Todd <pete@petertodd.org> 1433520630 +0200\ncommitter Peter Todd <pete@petertodd.org> 1434949000 -0400\n\nAdd first-seen-safe replace-by-fee logic to the mempool\n\nReplaces transactions already in the mempool if a new transaction is\nseen with a higher fee, provided that the replacement transaction's\noutputs pay all previous outputs an equal or greater amount. This\npreserves the \"first seen\" behavior of the mempool, in the sense that a\ntransaction will never be replaced in a fashion that prevents an address\nfrom receiving funds that it otherwise would have. In short, zero-conf\ntransactions are unaffected.\n\nTo prevent replacements from being used as a DoS attack mechanism a\nreplacement only happens if the new transaction has a higher fee, pays a\nhigher fee/KB rate, and the fee increase is sufficient to pay for the\nbandwidth consumed in relaying the replacement.\n\nIncludes stand-alone unittests for regtest in qa/replace-by-fee/\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3044fd191505253e7914916c784235698514e1e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3044fd191505253e7914916c784235698514e1e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3044fd191505253e7914916c784235698514e1e/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "247b91449ad7d041c6af5d2abf5660ab00be0fb4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/247b91449ad7d041c6af5d2abf5660ab00be0fb4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/247b91449ad7d041c6af5d2abf5660ab00be0fb4"
      }
    ],
    "stats": {
      "total": 562,
      "additions": 560,
      "deletions": 2
    },
    "files": [
      {
        "sha": "b2c4f4657aebb1a2bffcc5e7a7d1c3bcdefdd56f",
        "filename": "qa/replace-by-fee/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3044fd191505253e7914916c784235698514e1e/qa/replace-by-fee/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3044fd191505253e7914916c784235698514e1e/qa/replace-by-fee/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/.gitignore?ref=f3044fd191505253e7914916c784235698514e1e",
        "patch": "@@ -0,0 +1 @@\n+python-bitcoinlib"
      },
      {
        "sha": "52a35e2646b7bca9a5222a838d350265d5a977f6",
        "filename": "qa/replace-by-fee/README.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3044fd191505253e7914916c784235698514e1e/qa/replace-by-fee/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3044fd191505253e7914916c784235698514e1e/qa/replace-by-fee/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/README.md?ref=f3044fd191505253e7914916c784235698514e1e",
        "patch": "@@ -0,0 +1,13 @@\n+Replace-by-fee regression test\n+==============================\n+\n+First get version v0.4.0 of the python-bitcoinlib library. In this directory\n+run:\n+\n+    git clone -n https://github.com/petertodd/python-bitcoinlib\n+    (cd python-bitcoinlib && git checkout f8606134765aa986537e897598df7b7833e0e6da)\n+\n+Then run the tests themselves with a bitcoind available running in regtest\n+mode:\n+\n+    ./replace-by-fee-tests.py"
      },
      {
        "sha": "e95534dbdab8c90eb23a1f11f42bb238d1774773",
        "filename": "qa/replace-by-fee/replace-by-fee-tests.py",
        "status": "added",
        "additions": 387,
        "deletions": 0,
        "changes": 387,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3044fd191505253e7914916c784235698514e1e/qa/replace-by-fee/replace-by-fee-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3044fd191505253e7914916c784235698514e1e/qa/replace-by-fee/replace-by-fee-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/replace-by-fee-tests.py?ref=f3044fd191505253e7914916c784235698514e1e",
        "patch": "@@ -0,0 +1,387 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test replace-by-fee\n+#\n+\n+import os\n+import sys\n+\n+# Add python-bitcoinlib to module search path:\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n+\n+import unittest\n+\n+import bitcoin\n+bitcoin.SelectParams('regtest')\n+\n+import bitcoin.rpc\n+\n+from bitcoin.core import *\n+from bitcoin.core.script import *\n+from bitcoin.wallet import *\n+\n+class Test_ReplaceByFee(unittest.TestCase):\n+    proxy = None\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        if cls.proxy is None:\n+            cls.proxy = bitcoin.rpc.Proxy()\n+\n+    @classmethod\n+    def mine_mempool(cls):\n+        \"\"\"Mine until mempool is empty\"\"\"\n+        mempool_size = 1\n+        while mempool_size:\n+            cls.proxy.generate(1)\n+            new_mempool_size = len(cls.proxy.getrawmempool())\n+\n+            # It's possible to get stuck in a loop here if the mempool has\n+            # transactions that can't be mined.\n+            assert(new_mempool_size != mempool_size)\n+            mempool_size = new_mempool_size\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        # Make sure mining works\n+        cls.mine_mempool()\n+\n+    def make_txouts(self, n, amount, confirmed=True, scriptPubKey=CScript([1])):\n+        \"\"\"Create n txouts with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+\n+        confirmed - txouts created will be confirmed in the blockchain;\n+                    unconfirmed otherwise.\n+        \"\"\"\n+        if not n:\n+            return []\n+\n+        fee = 1*COIN\n+        while self.proxy.getbalance() < n*amount + fee:\n+            self.proxy.generate(100)\n+\n+        addr = P2SHBitcoinAddress.from_redeemScript(CScript([]))\n+        txid = self.proxy.sendtoaddress(addr, n*amount + fee)\n+\n+        tx1 = self.proxy.getrawtransaction(txid)\n+\n+        i = None\n+        for i, txout in enumerate(tx1.vout):\n+            if txout.scriptPubKey == addr.to_scriptPubKey():\n+                break\n+        assert i is not None\n+\n+        tx2 = CTransaction([CTxIn(COutPoint(txid, i), CScript([1, CScript([])]))],\n+                           [CTxOut(amount, scriptPubKey)]*n)\n+\n+        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+\n+        # If requested, ensure txouts are confirmed.\n+        if confirmed:\n+            self.mine_mempool()\n+\n+        return [COutPoint(tx2_txid, i) for i in range(n)]\n+\n+    def make_txout(self, amount, confirmed=True, scriptPubKey=CScript([1])):\n+        \"\"\"Create a txout with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+\n+        confirmed - txouts created will be confirmed in the blockchain;\n+                    unconfirmed otherwise.\n+        \"\"\"\n+        return self.make_txouts(1, amount, confirmed, scriptPubKey)[0]\n+\n+    def test_subset_prohibited(self):\n+        \"\"\"Replacement prohibited if any recipient will receive less funds from replacement\"\"\"\n+\n+        for n in range(1,4):\n+            utxo1 = self.make_txout(n*0.11*COIN)\n+            utxo2 = self.make_txout(1.0*COIN)\n+\n+            tx1 = CTransaction([CTxIn(utxo1)],\n+                                [CTxOut(0.10*COIN, CScript([i])) for i in range(n)])\n+            tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+            # Double spend with too-few outputs\n+            for m in range(1,n):\n+                tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                                   tx1.vout[0:m])\n+\n+                try:\n+                    tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+                except bitcoin.rpc.JSONRPCException as exp:\n+                    self.assertEqual(exp.error['code'], -26)\n+                else:\n+                    self.fail()\n+\n+            # Double spend with one of the outputs changed\n+            for m in range(0,n):\n+                vout = list(tx1.vout)\n+                vout[m] = CTxOut(0.10*COIN, CScript([b'a']))\n+                tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)], vout)\n+\n+                try:\n+                    tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+                except bitcoin.rpc.JSONRPCException as exp:\n+                    self.assertEqual(exp.error['code'], -26)\n+                else:\n+                    self.fail()\n+\n+            # Double spend with one of the outputs reduced in value by one satoshi\n+            for m in range(0,n):\n+                vout = list(tx1.vout)\n+                vout[m] = CTxOut(vout[m].nValue-1, vout[m].scriptPubKey)\n+                tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)], vout)\n+\n+                try:\n+                    tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+                except bitcoin.rpc.JSONRPCException as exp:\n+                    self.assertEqual(exp.error['code'], -26)\n+                else:\n+                    self.fail()\n+\n+            # With all the outputs the same, and an additional input, the\n+            # replacement will succeed.\n+            tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)], tx1.vout)\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx1_txid)\n+            self.proxy.getrawtransaction(tx2_txid)\n+\n+    def test_reorder_vout_prohibited(self):\n+        \"\"\"Changing the order of vout is prohibited\"\"\"\n+\n+        utxo1 = self.make_txout(2*1.1*COIN)\n+        utxo2 = self.make_txout(1.0*COIN)\n+\n+        tx1 = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.0*COIN, CScript([1])),\n+                             CTxOut(1.0*COIN, CScript([2]))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                           reversed(tx1.vout))\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+    def test_reorder_vin_allowed(self):\n+        \"\"\"Changing the order of vin is allowed\"\"\"\n+        utxo1 = self.make_txout(1.1*COIN)\n+        utxo2 = self.make_txout(1.0*COIN)\n+\n+        tx1 = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.0*COIN, CScript([1]))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo2), CTxIn(utxo1)],\n+                           tx1.vout)\n+\n+        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        with self.assertRaises(IndexError):\n+            self.proxy.getrawtransaction(tx1_txid)\n+        self.proxy.getrawtransaction(tx2_txid)\n+\n+    def test_one_to_one(self):\n+        \"\"\"Replacing multiple transactions at once is prohibited\"\"\"\n+        utxo1 = self.make_txout(1.1*COIN)\n+        utxo2 = self.make_txout(1.1*COIN)\n+        utxo3 = self.make_txout(1.0*COIN)\n+\n+        tx1a = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        tx1b = CTransaction([CTxIn(utxo2)],\n+                            [CTxOut(1.0*COIN, CScript([b'b']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2), CTxIn(utxo3)],\n+                           tx1a.vout + tx1b.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+    def test_replaced_outputs_unspent(self):\n+        \"\"\"Replaced transaction's outputs must be unspent\"\"\"\n+\n+        for i in range(2):\n+            utxo1 = self.make_txout(1.2*COIN)\n+            utxo2 = self.make_txout(3.0*COIN)\n+\n+            tx1a = CTransaction([CTxIn(utxo1)],\n+                                [CTxOut(0.5*COIN, CScript([b'a'])),\n+                                 CTxOut(0.5*COIN, CScript([b'b']))])\n+            tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+            tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, i))],\n+                                [CTxOut(0.4*COIN, CScript([b'b']))])\n+            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+            tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                               tx1a.vout + tx1b.vout)\n+\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+    def test_additional_unconfirmed_inputs(self):\n+        \"\"\"Replacement fails if additional unconfirmed inputs added\"\"\"\n+        confirmed_utxo = self.make_txout(1.1*COIN)\n+        unconfirmed_utxo = self.make_txout(0.1*COIN, False)\n+\n+        tx1 = CTransaction([CTxIn(confirmed_utxo)],\n+                           [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)],\n+                           tx1.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+    def test_spends_of_conflicting_outputs(self):\n+        \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n+        utxo1 = self.make_txout(1.2*COIN)\n+        utxo2 = self.make_txout(3.0*COIN)\n+\n+        tx1a = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Direct spend an output of the transaction we're replacing.\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2),\n+                            CTxIn(COutPoint(tx1a_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+        # Spend tx1a's output to test the indirect case.\n+        tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, 0))],\n+                            [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2),\n+                            CTxIn(COutPoint(tx1b_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+\n+    def test_economics(self):\n+        \"\"\"Replacement prohibited if uneconomical\"\"\"\n+        utxo1 = self.make_txout(110000)\n+        utxo2 = self.make_txout(1)\n+        utxo3 = self.make_txout(1000000)\n+\n+        # By including utxo2 in tx1 but not tx2 lets us test the case where the\n+        # replacement pays less fees than the original while still respecting\n+        # the \"no-decreases\" rule.\n+        tx1 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                            [CTxOut(100000, CScript([b'a']))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        # FIXME: these constants should be derived somehow, but right now\n+        # there's no way to get min fee info from the mempool over RPC\n+        for fee_delta in [-1,   # less fees than original\n+                          0, 1, # not enough to pay for bandwidth\n+                          114, 1068,  # fee/KB of replacement less than original\n+                         ]:\n+            tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo3)],\n+                               [tx1.vout[0],\n+                                CTxOut(1000000-1-fee_delta, CScript([b'b']))])\n+\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+\n+    def test_very_large_replacements(self):\n+        \"\"\"Very large replacements\"\"\"\n+        n = 5000\n+        for n_vin, n_new_vin, n_vout, n_new_vout in [(n,0,2,0),\n+                                                     (n,n,2,0),\n+                                                     (n,n,n,0),\n+                                                     (n,n,n,n),\n+                                                     (2,n,n,n),\n+                                                     (2,0,n,n),\n+                                                     (2,0,2,n),\n+                                                     ]:\n+            utxos = self.make_txouts(n_vin, 1000)\n+\n+            fee_utxo1 = self.make_txout(0.01*COIN)\n+            fee_utxo2 = self.make_txout(10*COIN)\n+            new_utxos = tuple(CTxIn(utxo) for utxo in self.make_txouts(n_new_vin, 1000))\n+\n+            tx1 = CTransaction([CTxIn(utxo) for utxo in utxos] + [CTxIn(fee_utxo1)],\n+                               [CTxOut(1, CScript([b'a'])) for i in range(n_vout)])\n+            tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+            new_vout = tuple(CTxOut(1, CScript([b'b'])) for i in range(n_new_vout))\n+\n+            # Prohibited replacement, last vout omitted\n+            tx2 = CTransaction(tx1.vin + (CTxIn(fee_utxo2),) + new_utxos,\n+                               tx1.vout[0:-1] + new_vout)\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+            # Prohibited replacement, last vout changed\n+            tx2 = CTransaction(tx1.vin + (CTxIn(fee_utxo2),) + new_utxos,\n+                               tx1.vout[0:-1] + (CTxOut(1, CScript([b'b'])),) + new_vout)\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+            # Succesful replacement\n+            tx2 = CTransaction(tx1.vin + (CTxIn(fee_utxo2),) + new_utxos,\n+                               tx1.vout + new_vout)\n+\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx1_txid)\n+            self.proxy.getrawtransaction(tx2_txid)\n+\n+if __name__ == '__main__':\n+    unittest.main()"
      },
      {
        "sha": "acd906b4bcd66ea10fa24f601f34424bab4873df",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 159,
        "deletions": 2,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3044fd191505253e7914916c784235698514e1e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3044fd191505253e7914916c784235698514e1e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f3044fd191505253e7914916c784235698514e1e",
        "patch": "@@ -916,16 +916,111 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     if (pool.exists(hash))\n         return false;\n \n+    uint256 hashConflicting;\n+    CAmount nConflictingFees = 0;\n+    size_t nConflictingSize = 0;\n+\n     // Check for conflicts with in-memory transactions\n     {\n     LOCK(pool.cs); // protect pool.mapNextTx\n+    const CTransaction *ptxConflicting = NULL;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n         COutPoint outpoint = tx.vin[i].prevout;\n         if (pool.mapNextTx.count(outpoint))\n         {\n-            // Disable replacement feature for now\n-            return false;\n+            if (ptxConflicting)\n+            {\n+                // For simplicity we only replace transactions on a 1-for-1 basis.\n+                if (pool.mapNextTx[outpoint].ptx != ptxConflicting)\n+                    return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s conflicts with more than one other transaction\",\n+                                              hash.ToString()),\n+                                     REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+            }\n+            else\n+            {\n+                ptxConflicting = pool.mapNextTx[outpoint].ptx;\n+                hashConflicting = ptxConflicting->GetHash();\n+\n+                if (GetBoolArg(\"-firstseensafe\", true))\n+                {\n+                    // Check that the replacement is first-seen-safe.\n+                    //\n+                    // This requires the conflicting transaction's vout to be a\n+                    // subset of the replacement. Outputs can pay more than before,\n+                    // but not less. For simplicity we require the order of outputs\n+                    // be unchanged.\n+                    if (tx.vout.size() < ptxConflicting->vout.size())\n+                    {\n+                        return state.DoS(0, error(\"AcceptToMemoryPool: replacement has %s fewer outputs than original %s\",\n+                                                  hash.ToString(),\n+                                                  hashConflicting.ToString()),\n+                                         REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                    }\n+                    for (unsigned int j = 0; j < ptxConflicting->vout.size(); j++)\n+                    {\n+                        if (ptxConflicting->vout[j].scriptPubKey != tx.vout[j].scriptPubKey ||\n+                            ptxConflicting->vout[j].nValue > tx.vout[j].nValue)\n+                        {\n+                            return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s outputs not a subset of original %s\",\n+                                                      hash.ToString(),\n+                                                      hashConflicting.ToString()),\n+                                             REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                        }\n+                    }\n+                }\n+\n+                // Make sure the outputs of the transaction we're replacing\n+                // have not been spent.\n+                std::map<COutPoint, CInPoint>::iterator it;\n+                it = pool.mapNextTx.lower_bound(COutPoint(hashConflicting, 0));\n+                if (it != pool.mapNextTx.end() && it->first.hash == hashConflicting)\n+                {\n+                    return state.DoS(0, error(\"AcceptToMemoryPool: outpoint %s:%d already spent; can't replace with %s\",\n+                                              hashConflicting.ToString(), it->first.n,\n+                                              hash.ToString()),\n+                                     REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                }\n+\n+                set<COutPoint> setConflictsPrevouts;\n+                for (unsigned int j = 0; j < ptxConflicting->vin.size(); j++)\n+                {\n+                    setConflictsPrevouts.insert(ptxConflicting->vin[j].prevout);\n+                }\n+\n+                for (unsigned int j = 0; j < tx.vin.size(); j++)\n+                {\n+                    // Check that any new inputs spend only confirmed coins. It\n+                    // might not be economically rational to replace a\n+                    // transaction that spent confirmed inputs with one that\n+                    // spent the result of a long chain of inputs, as the total\n+                    // fee/KB might go down. Forcing all new inputs to be\n+                    // confirmed is a simple way of avoiding that problem.\n+                    //\n+                    // Note that if we ever change this to allow the spending\n+                    // of unconfirmed coins, we also need to check that the\n+                    // transaction doesn't itself spend an output of the\n+                    // conflicting transaction. If it did, when the conflict\n+                    // was removed this transaction would become an orphan.\n+                    if (!setConflictsPrevouts.count(tx.vin[j].prevout))\n+                    {\n+                        // Rather than check the UTXO set - potentially\n+                        // expensive - it's cheaper to just check that the new\n+                        // input refers to a tx that is *not* in the mempool.\n+                        if (pool.exists(tx.vin[j].prevout.hash))\n+                            return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s adds unconfirmed input, idx %d\",\n+                                                      hash.ToString(), j),\n+                                             REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                    }\n+\n+                }\n+\n+                // Save fees and size for later so we don't have to get the\n+                // pool.cs lock again.\n+                const CTxMemPoolEntry& entryConflicting = pool.mapTx.at(hashConflicting);\n+                nConflictingFees = entryConflicting.GetFee();\n+                nConflictingSize = entryConflicting.GetTxSize();\n+            }\n         }\n     }\n     }\n@@ -1034,6 +1129,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                          hash.ToString(),\n                          nFees, ::minRelayTxFee.GetFee(nSize) * 10000);\n \n+        // Replacing previous transactions?\n+        if (nConflictingSize)\n+        {\n+            // First of all we can't allow a replacement unless it pays greater\n+            // fees than the transaction it conflicts with - if we did the\n+            // bandwidth used by the replaced transactions would not be paid\n+            // for.\n+            if (nFees < nConflictingFees)\n+            {\n+                return state.DoS(0, error(\"AcceptToMemoryPool: rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                                          hash.ToString(), FormatMoney(nFees), FormatMoney(nConflictingFees)),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+            }\n+\n+            // Secondly in addition to paying more fees the new transaction\n+            // must also pay for its own bandwidth. We use the minimum relay tx\n+            // fee as for this calculation, on the basis that an attacker could\n+            // simply flood minimum fee transactions instead; we're not\n+            // allowing them to do anything that they previously can't do.\n+            CAmount nDeltaFees = nFees - nConflictingFees;\n+            if (nDeltaFees < ::minRelayTxFee.GetFee(nSize))\n+            {\n+                return state.DoS(0,\n+                        error(\"AcceptToMemoryPool: rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                            hash.ToString(),\n+                            FormatMoney(nDeltaFees),\n+                            FormatMoney(::minRelayTxFee.GetFee(nSize))),\n+                        REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+            }\n+\n+            // Finally require that the overall fees-per-kb of the replacement\n+            // be higher than the replaced.\n+            CFeeRate oldFeeRate(nConflictingFees, nConflictingSize);\n+            CFeeRate newFeeRate(nFees, nSize);\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.DoS(0,\n+                        error(\"AcceptToMemoryPool: rejecting replacement %s; new fee %s <= old fee %s\",\n+                              hash.ToString(),\n+                              newFeeRate.ToString(),\n+                              oldFeeRate.ToString()),\n+                        REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+            }\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n@@ -1055,8 +1195,25 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return error(\"AcceptToMemoryPool: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s\", hash.ToString());\n         }\n \n+        // Remove conflicting transaction(s) from mempool (if any)\n+        //\n+        // This should nearly always be either zero or one conflicting\n+        // transactions, but as the mempool isn't locked the whole time it's\n+        // possible there may be more than one.\n+        list<CTransaction> ltxConflicted;\n+        pool.removeConflicts(tx, ltxConflicted);\n+\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n+\n+        BOOST_FOREACH(const CTransaction &txConflicted, ltxConflicted)\n+        {\n+            LogPrint(\"mempool\", \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+                     txConflicted.GetHash().ToString(),\n+                     hash.ToString(),\n+                     FormatMoney(nFees - nConflictingFees),\n+                     (int)nSize - (int)nConflictingSize);\n+        }\n     }\n \n     SyncWithWallets(tx, NULL);"
      }
    ]
  }
]