[
  {
    "sha": "efd2474d17098c754367b844ec646ebececc7c74",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZmQyNDc0ZDE3MDk4Yzc1NDM2N2I4NDRlYzY0NmViZWNlY2M3Yzc0",
    "commit": {
      "author": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2019-09-10T13:53:09Z"
      },
      "committer": {
        "name": "Larry Ruane",
        "email": "larryruane@gmail.com",
        "date": "2019-09-10T13:53:09Z"
      },
      "message": "util: CBufferedFile fixes",
      "tree": {
        "sha": "9329d87a0c8507e8064b4a297a99d7eca07cfc43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9329d87a0c8507e8064b4a297a99d7eca07cfc43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/efd2474d17098c754367b844ec646ebececc7c74",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/efd2474d17098c754367b844ec646ebececc7c74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/efd2474d17098c754367b844ec646ebececc7c74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/efd2474d17098c754367b844ec646ebececc7c74/comments",
    "author": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "LarryRuane",
      "id": 8321330,
      "node_id": "MDQ6VXNlcjgzMjEzMzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LarryRuane",
      "html_url": "https://github.com/LarryRuane",
      "followers_url": "https://api.github.com/users/LarryRuane/followers",
      "following_url": "https://api.github.com/users/LarryRuane/following{/other_user}",
      "gists_url": "https://api.github.com/users/LarryRuane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
      "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
      "repos_url": "https://api.github.com/users/LarryRuane/repos",
      "events_url": "https://api.github.com/users/LarryRuane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1985c4efda56b48f6f9c04f39d69268ee8f0b40a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1985c4efda56b48f6f9c04f39d69268ee8f0b40a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1985c4efda56b48f6f9c04f39d69268ee8f0b40a"
      }
    ],
    "stats": {
      "total": 268,
      "additions": 257,
      "deletions": 11
    },
    "files": [
      {
        "sha": "517eefc9326ee6acb08e765adfa94224e4b3e223",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 13,
        "deletions": 11,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/efd2474d17098c754367b844ec646ebececc7c74/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/efd2474d17098c754367b844ec646ebececc7c74/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=efd2474d17098c754367b844ec646ebececc7c74",
        "patch": "@@ -735,16 +735,17 @@ class CBufferedFile\n         size_t nBytes = fread((void*)&vchBuf[pos], 1, readNow, src);\n         if (nBytes == 0) {\n             throw std::ios_base::failure(feof(src) ? \"CBufferedFile::Fill: end of file\" : \"CBufferedFile::Fill: fread failed\");\n-        } else {\n-            nSrcPos += nBytes;\n-            return true;\n         }\n+        nSrcPos += nBytes;\n+        return true;\n     }\n \n public:\n     CBufferedFile(FILE *fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn) :\n         nType(nTypeIn), nVersion(nVersionIn), nSrcPos(0), nReadPos(0), nReadLimit(std::numeric_limits<uint64_t>::max()), nRewind(nRewindIn), vchBuf(nBufSize, 0)\n     {\n+        if (nRewindIn >= nBufSize)\n+            throw std::ios_base::failure(\"Rewind limit must be less than buffer size\");\n         src = fileIn;\n     }\n \n@@ -777,8 +778,6 @@ class CBufferedFile\n     void read(char *pch, size_t nSize) {\n         if (nSize + nReadPos > nReadLimit)\n             throw std::ios_base::failure(\"Read attempted past buffer limit\");\n-        if (nSize + nRewind > vchBuf.size())\n-            throw std::ios_base::failure(\"Read larger than buffer size\");\n         while (nSize > 0) {\n             if (nReadPos == nSrcPos)\n                 Fill();\n@@ -802,16 +801,19 @@ class CBufferedFile\n \n     //! rewind to a given reading position\n     bool SetPos(uint64_t nPos) {\n-        nReadPos = nPos;\n-        if (nReadPos + nRewind < nSrcPos) {\n-            nReadPos = nSrcPos - nRewind;\n+        size_t bufsize = vchBuf.size();\n+        if (nPos + bufsize < nSrcPos) {\n+            // rewinding too far, rewind as far as possible\n+            nReadPos = nSrcPos - bufsize;\n             return false;\n-        } else if (nReadPos > nSrcPos) {\n+        }\n+        if (nPos > nSrcPos) {\n+            // can't go this far forward, go as far as possible\n             nReadPos = nSrcPos;\n             return false;\n-        } else {\n-            return true;\n         }\n+        nReadPos = nPos;\n+        return true;\n     }\n \n     bool Seek(uint64_t nPos) {"
      },
      {
        "sha": "638819d564a44d44897d5ac99736b9b3b307f592",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 244,
        "deletions": 0,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/efd2474d17098c754367b844ec646ebececc7c74/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/efd2474d17098c754367b844ec646ebececc7c74/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=efd2474d17098c754367b844ec646ebececc7c74",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <random.h>\n #include <streams.h>\n #include <test/setup_common.h>\n \n@@ -202,4 +203,247 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n             std::string(ds.begin(), ds.end()));\n }\n \n+BOOST_AUTO_TEST_CASE(streams_buffered_file)\n+{\n+    FILE* file = fsbridge::fopen(\"streams_test_tmp\", \"w+b\");\n+    // The value at each offset is the offset.\n+    for (uint8_t j = 0; j < 40; ++j) {\n+        fwrite(&j, 1, 1, file);\n+    }\n+    rewind(file);\n+\n+    // The buffer size (second arg) must be greater than the rewind\n+    // amount (third arg).\n+    try {\n+        CBufferedFile bfbad(file, 25, 25, 222, 333);\n+        BOOST_CHECK(false);\n+    } catch (const std::exception& e) {\n+        BOOST_CHECK(strstr(e.what(),\n+                        \"Rewind limit must be less than buffer size\") != nullptr);\n+    }\n+\n+    // The buffer is 25 bytes, allow rewinding 10 bytes.\n+    CBufferedFile bf(file, 25, 10, 222, 333);\n+    BOOST_CHECK(!bf.eof());\n+\n+    // These two members have no functional effect.\n+    BOOST_CHECK_EQUAL(bf.GetType(), 222);\n+    BOOST_CHECK_EQUAL(bf.GetVersion(), 333);\n+\n+    uint8_t i;\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 0);\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 1);\n+\n+    // After reading bytes 0 and 1, we're positioned at 2.\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 2);\n+\n+    // Rewind to offset 0, ok (within the 10 byte window).\n+    BOOST_CHECK(bf.SetPos(0));\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 0);\n+\n+    // We can go forward to where we've been, but beyond may fail.\n+    BOOST_CHECK(bf.SetPos(2));\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 2);\n+\n+    // If you know the maximum number of bytes that should be\n+    // read to deserialize the variable, you can limit the read\n+    // extent. The current file offset is 3, so the following\n+    // SetLimit() allows zero bytes to be read.\n+    BOOST_CHECK(bf.SetLimit(3));\n+    try {\n+        bf >> i;\n+        BOOST_CHECK(false);\n+    } catch (const std::exception& e) {\n+        BOOST_CHECK(strstr(e.what(),\n+                        \"Read attempted past buffer limit\") != nullptr);\n+    }\n+    // The default argument removes the limit completely.\n+    BOOST_CHECK(bf.SetLimit());\n+    // The read position should still be at 3 (no change).\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 3);\n+\n+    // Read from current offset, 3, forward until position 10.\n+    for (uint8_t j = 3; j < 10; ++j) {\n+        bf >> i;\n+        BOOST_CHECK_EQUAL(i, j);\n+    }\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 10);\n+\n+    // We're guaranteed (just barely) to be able to rewind to zero.\n+    BOOST_CHECK(bf.SetPos(0));\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 0);\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 0);\n+\n+    // We can set the position forward again up to the farthest\n+    // into the stream we've been, but no farther. (Attempting\n+    // to go farther may succeed, but it's not guaranteed.)\n+    BOOST_CHECK(bf.SetPos(10));\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 10);\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 11);\n+\n+    // Now it's only guaranteed that we can rewind to offset 1\n+    // (current read position, 11, minus rewind amount, 10).\n+    BOOST_CHECK(bf.SetPos(1));\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 1);\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 1);\n+\n+    // We can stream into large variables, even larger than\n+    // the buffer size.\n+    BOOST_CHECK(bf.SetPos(11));\n+    {\n+        uint8_t a[40 - 11];\n+        bf >> a;\n+        for (uint8_t j = 0; j < sizeof(a); ++j) {\n+            BOOST_CHECK_EQUAL(a[j], 11 + j);\n+        }\n+    }\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 40);\n+\n+    // We've read the entire file, the next read should throw.\n+    try {\n+        bf >> i;\n+        BOOST_CHECK(false);\n+    } catch (const std::exception& e) {\n+        BOOST_CHECK(strstr(e.what(),\n+                        \"CBufferedFile::Fill: end of file\") != nullptr);\n+    }\n+    // Attempting to read beyond the end sets the EOF indicator.\n+    BOOST_CHECK(bf.eof());\n+\n+    // Still at offset 40, we can go back 10, to 30.\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 40);\n+    BOOST_CHECK(bf.SetPos(30));\n+    bf >> i;\n+    BOOST_CHECK_EQUAL(i, 30);\n+    BOOST_CHECK_EQUAL(bf.GetPos(), 31);\n+\n+    // We're too far to rewind to position zero.\n+    BOOST_CHECK(!bf.SetPos(0));\n+    // But we should now be positioned at least as far back as allowed\n+    // by the rewind window (relative to our farthest read position, 40).\n+    BOOST_CHECK(bf.GetPos() <= 30);\n+\n+    // We can explicitly close the file, or the destructor will do it.\n+    bf.fclose();\n+\n+    fs::remove(\"streams_test_tmp\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(streams_buffered_file_rand)\n+{\n+    // Make this test deterministic.\n+    SeedInsecureRand(true);\n+\n+    for (int rep = 0; rep < 50; ++rep) {\n+        FILE* file = fsbridge::fopen(\"streams_test_tmp\", \"w+b\");\n+        size_t fileSize = InsecureRandRange(256);\n+        for (uint8_t i = 0; i < fileSize; ++i) {\n+            fwrite(&i, 1, 1, file);\n+        }\n+        rewind(file);\n+\n+        size_t bufSize = InsecureRandRange(300) + 1;\n+        size_t rewindSize = InsecureRandRange(bufSize);\n+        CBufferedFile bf(file, bufSize, rewindSize, 222, 333);\n+        size_t currentPos = 0;\n+        size_t maxPos = 0;\n+        for (int step = 0; step < 100; ++step) {\n+            if (currentPos >= fileSize)\n+                break;\n+\n+            // We haven't read to the end of the file yet.\n+            BOOST_CHECK(!bf.eof());\n+            BOOST_CHECK_EQUAL(bf.GetPos(), currentPos);\n+\n+            // Pretend the file consists of a series of objects of varying\n+            // sizes; the boundaries of the objects can interact arbitrarily\n+            // with the CBufferFile's internal buffer. These first three\n+            // cases simulate objects of various sizes (1, 2, 5 bytes).\n+            switch (InsecureRandRange(5)) {\n+            case 0: {\n+                uint8_t a[1];\n+                if (currentPos + 1 > fileSize)\n+                    continue;\n+                bf.SetLimit(currentPos + 1);\n+                bf >> a;\n+                for (uint8_t i = 0; i < 1; ++i) {\n+                    BOOST_CHECK_EQUAL(a[i], currentPos);\n+                    currentPos++;\n+                }\n+                break;\n+            }\n+            case 1: {\n+                uint8_t a[2];\n+                if (currentPos + 2 > fileSize)\n+                    continue;\n+                bf.SetLimit(currentPos + 2);\n+                bf >> a;\n+                for (uint8_t i = 0; i < 2; ++i) {\n+                    BOOST_CHECK_EQUAL(a[i], currentPos);\n+                    currentPos++;\n+                }\n+                break;\n+            }\n+            case 2: {\n+                uint8_t a[5];\n+                if (currentPos + 5 > fileSize)\n+                    continue;\n+                bf.SetLimit(currentPos + 5);\n+                bf >> a;\n+                for (uint8_t i = 0; i < 5; ++i) {\n+                    BOOST_CHECK_EQUAL(a[i], currentPos);\n+                    currentPos++;\n+                }\n+                break;\n+            }\n+            case 3: {\n+                // Find a byte value (that is at or ahead of the current position).\n+                size_t find = currentPos + InsecureRandRange(8);\n+                if (find >= fileSize)\n+                    find = fileSize - 1;\n+                bf.FindByte(static_cast<char>(find));\n+                // The value at each offset is the offset.\n+                BOOST_CHECK_EQUAL(bf.GetPos(), find);\n+                currentPos = find;\n+\n+                bf.SetLimit(currentPos + 1);\n+                uint8_t i;\n+                bf >> i;\n+                BOOST_CHECK_EQUAL(i, currentPos);\n+                currentPos++;\n+                break;\n+            }\n+            case 4: {\n+                size_t requestPos = InsecureRandRange(maxPos + 4);\n+                bool okay = bf.SetPos(requestPos);\n+                // The new position may differ from the requested position\n+                // because we may not be able to rewind beyond the rewind\n+                // window, and we may not be able to move forward beyond the\n+                // farthest position we've reached so far.\n+                currentPos = bf.GetPos();\n+                BOOST_CHECK_EQUAL(okay, currentPos == requestPos);\n+                // Check that we can position within the rewind window.\n+                if (requestPos <= maxPos &&\n+                    maxPos > rewindSize &&\n+                    requestPos >= maxPos - rewindSize) {\n+                    // We requested a position within the rewind window.\n+                    BOOST_CHECK(okay);\n+                }\n+                break;\n+            }\n+            }\n+            if (maxPos < currentPos)\n+                maxPos = currentPos;\n+        }\n+    }\n+    fs::remove(\"streams_test_tmp\");\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]