DrahtBot,2021-03-25 08:57:08,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23173](https://github.com/bitcoin/bitcoin/pull/23173) (Add `ChainstateManager::ProcessTransaction` by jnewbery)\n* [#227",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-806478833,806478833,
ajtowns,2021-04-20 06:53:00,"Rebased, some of the suggestions picked up, reworked the ""message handler"" mutex.",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-823022635,823022635,
jnewbery,2021-04-20 13:08:48,I've re-reviewed the locking changes and they look reasonable. There are still a few review comments outstanding. I'm happy to review this PR again once those have been addressed.,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-823260165,823260165,
ajtowns,2021-04-22 22:43:15,"I think this is now cleaned up, and ready for review. The behaviour changes that were in the last commit are now deferred to https://github.com/ajtowns/bitcoin/commits/202104-whohandlesorphans . ",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-825228907,825228907,
jnewbery,2021-04-25 15:38:13,"When you rebase this, there are a few files that no longer need to include txorphanage.h:\n\n<details>\n<summary>Diff</summary>\n\n```diff\ndiff --git a/src/init.cpp b/src/init.cpp\nindex bb5b144802..e7b5ed60e3 100644\n--- a/src/init.cpp\n+++ b/src/init.cpp\n@@ -52,7 +52,6 @@\n #include <torcontrol.h>\n #include <txdb.h>\n #include <txmempool.h>\n-#include <txorphanage.h>\n #include",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-826344035,826344035,
ajtowns,2021-04-29 09:21:17,Rebased (and likewise the whohandlesorphans followup),https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-829077016,829077016,
DrahtBot,2021-05-03 09:32:51,<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nüïµÔ∏è @sipa has been requested to review this pull request as specified in the REVIEWERS file.,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-831142078,831142078,
ajtowns,2021-05-07 12:27:21,Rebased past #21845. cc @MarcoFalke @promag for reviews :),https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-834330923,834330923,
jnewbery,2021-05-07 13:00:50,"utACK 8b4f685ebef5eb14f049d04e2c4f4ce5b44878de\n\nDo you mind addressing https://github.com/bitcoin/bitcoin/pull/21527#discussion_r622998740 while there are no other ACKs on the branch?",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-834360334,834360334,
jnewbery,2021-05-07 14:39:42,ACK dd754fd73ab0fcbe9461a6a21b5fc2bc22faf968,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-834466926,834466926,
ajtowns,2021-05-25 04:28:44,"Rebased past #21186, addressed @jnewbery's nits.",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-847520754,847520754,
jnewbery,2021-05-25 10:55:54,Code review ACK d6dfa5977a7c03d9a81727e1692edb58bfeab62c,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-847768237,847768237,
michaelfolkson,2021-06-16 11:42:20,"> NACK the addition of m_mutex_message_handling.\n\n> Looks like neither one of us is convinced by the other's arguments. It's ok, it would have been too boring if everybody agreed on everything all the time.\n\n@vasild: Are you in a position where you can ACK this PR overall (with reservations) or would you prefer not to ACK it? Either is fine (obviously), I just suspect other reviewers may b",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-862308967,862308967,
vasild,2021-06-21 14:02:13,"> > NACK the addition of m_mutex_message_handling.\n> \n> > Looks like neither one of us is convinced by the other's arguments. It's ok, it would have been too boring if everybody agreed on everything all the time.\n> \n> @vasild: Are you in a position where you can ACK this PR overall (with reservations) or would you prefer not to ACK it? Either is fine (obviously), I just suspect other revie",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-865057893,865057893,
jnewbery,2021-07-27 10:20:37,@ajtowns are you still working on this? I think this new net_processing lock is the best way we have to make progress with much of the net/net_processing/validation separation work.,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-887393835,887393835,
ajtowns,2021-09-02 23:31:36,Rebased past #21562. Minor updates per reviews.,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-912129890,912129890,
glozow,2021-09-24 13:43:46,"Concept ACK, I like the idea of txorphanage being internally thread-safe",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-926635717,926635717,
ajtowns,2021-09-29 19:13:24,Rebased past #22976,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-930467996,930467996,
ajtowns,2021-10-26 12:42:37,Rebased past #23157,https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-951900670,951900670,
DrahtBot,2021-11-10 13:59:17,"<!--cf906140f33d8803c4a75a2196329ecb-->\nüêô This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a ""draft"".</sub>",https://github.com/bitcoin/bitcoin/pull/21527#issuecomment-965207447,965207447,
jnewbery,2021-03-25 08:28:45,"What do you think about removing this call? The comment above is incorrect (we only process one tx at most, not recursively), and we'll process the orphans in subsequent calls to `ProcessMessages()`. It seems strange that in this one case we can process up to two transactions in `ProcessMessage()` (the one that we just received, and up to one orphan child of it).",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601192396,601192396,src/net_processing.cpp
jnewbery,2021-03-25 08:44:03,"How about moving this check up to immediately after the call to `ProcessOrphanTx()`? It's not possible to have both `more_orphans` be true _and_ have `m_getdata_requests` be non-empty:\n\n- `ProcessOrphanTx(*peer)` can only return true if there are elements in peer's orphan work set, which can only be true if the last network message processed was a `tx` (`m_peer_work_set` only gets added to whe",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601207659,601207659,src/net_processing.cpp
jnewbery,2021-03-25 08:47:11,"Can be more concisely written as:\n\n```diff\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex 02e2785c24..c90d73cb95 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -3854,11 +3854,7 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n         }\n     }\n \n-    bool more_orphans = false;\n-    {\n-        LOCK",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601210830,601210830,src/net_processing.cpp
jnewbery,2021-03-25 08:57:13,It'd be good to remove the `EXCLUSIVE_LOCKS_REQUIRED(cs_main)` and only take the cs_main lock inside the while look (once we know that we have orphans to reprocess). In vast majority of cases we're taking and releasing cs_main for no reason because we have no orphans to process.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601221165,601221165,src/net_processing.cpp
jnewbery,2021-03-25 08:58:51,"Well remembered to do this. Perhaps add a `TxOrphange::Empty()` function that returns whether there are any elements in any of the containers in the orphanage, and then assert `m_orphange.Empty()` in the `FinalizeNode()` logic when the last peer is deleted.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601223122,601223122,src/txorphanage.cpp
jnewbery,2021-03-25 09:01:24,Not sure that it's very interesting to log `work_erased`. It'll only ever be 0 (nothing in the work set) or 1 (items in the work set).,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601225798,601225798,src/txorphanage.cpp
jnewbery,2021-03-25 09:11:32,"I don't think this is a good idea. Anything that you guard with this mutex will never be accessible on other threads, which would prevent us from eg exposing it to RPC methods, or using it in validation interface callbacks. This seems like a way of reinventing thread local storage, which I don't think we want.\n\nIn addition, this mutex is exposed and used in both the net and net_processing laye",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601236470,601236470,src/net.h
jnewbery,2021-03-25 09:26:41,"Is this possible? I think the logic in `GetTxToReconsider()` ensures that if true is returned, then porphanTx will not be null.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601253387,601253387,src/net_processing.cpp
jnewbery,2021-03-25 09:49:02,"This is a very strange interface. How about returning a `std::optional<std::pair<CTransactionRef, NodeId>>`, and then adding another public method `HasTxToReconsider()`. It's a bit less efficient, but we'll only ever call it after processing a transaction, so it seems negligible.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601279266,601279266,src/txorphanage.h
jnewbery,2021-03-25 09:49:56,I guess this means you already tried using an optional in the return value of `GetTxToReconsider()`? ,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601280373,601280373,src/txorphanage.h
jnewbery,2021-03-25 09:53:10,"I don't think you need this lock. It was previously here to enforce that cs_main was taken before g_cs_orphans.\n\nIt can also be removed from the process_message and process_messages fuzz tests.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601283910,601283910,src/init.cpp
jnewbery,2021-03-25 10:05:44,"This comment is now incorrect. The multimap stores the node that provided the orphan tx.\n\nAlso, this data is redundant data with the `fromPeer` in the `OrphanTx` struct (this could easily be a set of txids to reconsider, and the originating peer is then looked up in the `OrphanTx` struct). We store it in the multimap for efficiency - the comment could be updated to indicate that.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601298826,601298826,src/txorphanage.h
ajtowns,2021-03-25 11:27:43,"We could process 3 txs I think -- the last orphan already in the workset (in ProcessMessages), one from a just received TX message, and an additional orphan whose parent was the contents of that TX message. I don't think it's problematic that way, but 1-non-trivial-ATMP-call per ProcessMessages invocation could be reasonable.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601391595,601391595,src/net_processing.cpp
ajtowns,2021-03-25 11:28:46,It crossed my mind that this might be another case where a multi index could be a win.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601392702,601392702,src/txorphanage.cpp
ajtowns,2021-03-25 11:34:23,"The reasoning isn't that this is particularly ""good"", it's that it's documenting the safety mechanisms we already have. It would have caught https://github.com/bitcoin/bitcoin/pull/21528#discussion_r601317221 for instance.\n\nnet_processing is fundamentally coupled with net -- it implements the NetEventsInterface defined and called from net. I mean I guess if you preferred, it could be `NetEvent",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601398665,601398665,src/net.h
ajtowns,2021-03-25 11:36:39,`assert(porphanTx != nullptr)` seemed overkill and not having anything seemed like it might be annoying for static analysers,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601401123,601401123,src/net_processing.cpp
ajtowns,2021-03-25 11:48:29,"I updated the comments which should still indicate why cs_main is needed there -- it needs to be locked before cs_vNodes, but cs_vNodes is locked first if you call StopThreads directly?",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601414014,601414014,src/init.cpp
jnewbery,2021-03-25 11:49:09,Very good point. I hadn't considered processing the orphan _before_ processing the net message.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601414581,601414581,src/net_processing.cpp
jnewbery,2021-03-25 11:52:34,How about: `if (!Assume(porphanTx)) break` ?,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601416590,601416590,src/net_processing.cpp
jnewbery,2021-03-25 12:00:57,"Ah, very good point. And we can't take `cs_main` inside `StopNodes` because net isn't aware of `cs_main`.\n\nIt's outside the scope of this PR, but it'd be good to untangle this lock ordering dependency by eg making sure that cs_vNodes is not held when calling any PeerManager functions.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601422013,601422013,src/init.cpp
jnewbery,2021-03-25 12:46:18,And if you're doing that then perhaps you can make it a `PeerManagerImpl::m_mutex_message_handler` and take it in `ProcessMessages()` and `SendMessages()`. Taking that lock once at the top of those functions would be very low cost (since there would never be any contention).,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601452522,601452522,src/net.h
ajtowns,2021-04-20 06:04:30,"I've done this now -- the first three commits introduce `m_mutex_messages`, remove `cs_sendProcessing` and move extra txns to be protected by `m_mutex_messages` instead of `g_cs_orphans`. I think it would be good to cherry-pick those commits into #21186 so that the moved addr variables can actually be marked as guarded by something.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616368502,616368502,src/net.h
ajtowns,2021-04-20 06:39:32,"I think:\n\n * just call AddChildrenToWorkSet when a new tx arrives, don't also immediately process them (ie don't also call ProcessOrphanTx)\n * when ProcessOrphanTx does work, don't continue on to also do a ProcessMessage, give another peer a chance to get some work done first\n * have ProcessOrphanTx take cs_main only when necessary\n * make the GetTxToReconsider signature simpler\n \nwo",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616385405,616385405,src/net_processing.cpp
jnewbery,2021-04-20 06:52:36,See #21563,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616392400,616392400,src/init.cpp
jnewbery,2021-04-20 06:53:25,Also see #21563,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616392887,616392887,src/net.h
jnewbery,2021-04-20 10:14:46,"I think it'd be cleaner for the `m_mutex_messages` lock to be taken by ProcessMessage**s**, rather than ProcessMessage. That would remove the need to define an inner `_ProcessMessage` to be called when the mutex is already locked. It's also consistent with the comment on the `m_mutex_messages` member, which says ""is acquired by ProcessMessages and SendMessages""",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616546524,616546524,src/net_processing.cpp
ajtowns,2021-04-20 10:40:27,"It is taken by `ProcessMessages()` (and also by `SendMessages()`), however `ProcessMessage()` is also called from the test suite, so cannot assume the lock has been taken. That's why the public interface, `ProcessMessage()`, is implemented as a wrapper that takes the lock, then calls the internal function.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616563414,616563414,src/net_processing.cpp
jnewbery,2021-04-20 13:02:28,"Ah, sorry - misread.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616661184,616661184,src/net_processing.cpp
ajtowns,2021-04-20 13:44:22,"> This PR changes orphan processing from being done for the peer that provided the parent to the peer that provided the orphan. I think that's fine, but perhaps we should split the PR into one that does refactoring only and one that has behaviour changes.\n\nHmm, might make sense to put the changes above together with the last commit in a separate PR, so this is just refactoring and the behaviou",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616696972,616696972,src/net_processing.cpp
jnewbery,2021-04-20 14:00:59,"Yes, I agree that it's better to split the PR into two: one that refactors and one that changes behaviour.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r616712448,616712448,src/net_processing.cpp
ajtowns,2021-04-22 22:41:31,This is drafted at https://github.com/ajtowns/bitcoin/commits/202104-whohandlesorphans,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r618789454,618789454,src/net_processing.cpp
jnewbery,2021-04-25 15:02:06,21563 is merged,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r619829668,619829668,src/init.cpp
jnewbery,2021-04-29 12:20:48,"```suggestion\n    /** Get an orphan transaction for a peer to work on and erase it from the peer's workset.\n```",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r622998740,622998740,src/txorphanage.h
ajtowns,2021-05-07 14:04:51,Done-ish,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r628237298,628237298,src/txorphanage.h
jnewbery,2021-05-07 14:39:58,thank you!,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r628263177,628263177,src/txorphanage.h
MarcoFalke,2021-05-09 05:21:12,"nit fec0ff16627c1cbf5545c9de8db19b749c90beee:\n\nThe lock order is m_mutex_message_handling -> cs_main -> g_cs_orphans, so it would be nice to also order the Asserts here in the same way.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r628835510,628835510,src/net_processing.cpp
MarcoFalke,2021-05-09 05:30:24,"57900348db566105351b525ae18cc2830e9665b5:\n\nThis undocumented one-line-if might be a bit too minimal. Previously there was a nice comment as to why return early is needed here. Now the comment is gone, or at least can't be trivially attached to the return here.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r628836372,628836372,src/net_processing.cpp
MarcoFalke,2021-05-09 06:00:19,"67618f024690bc9b926aa48ead23a0f687f03fe4: I know there is a check to avoid duplicate insertion of the same txid, but is there a reason to pick this datastructure, which doesn't disallow duplicate entries like set? Also insertion is trivially more expensive (log(all peers' work sets) vs log(this peers' work set)). Finally handling is done in insertion order, not in sorted order.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r628839074,628839074,src/txorphanage.h
ajtowns,2021-05-09 15:45:33,"Not sure what you mean by ""the comment is gone"" ? The ""maintains the order of responses and prevents ~vRecvGetData~ m_getdata_requests to grow unbounded"" is still there, but at least I thought that sensibly described the ~`!pfrom->vRecvGetData.empty()`~ `!peer->m_getdata_requests.empty()` check it remains attached to, and didn't really fit the ""more orphans to work on"" check. (EDIT: oops, was look",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r628907747,628907747,src/net_processing.cpp
vasild,2021-05-13 13:53:19,"> ... is there a reason to pick this datastructure, which doesn't disallow duplicate entries ...\n\nI think the reason could be to allow (nodeX, tx1), (nodeX, tx2)?",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r631826871,631826871,src/txorphanage.h
vasild,2021-05-13 15:25:27,"If it is single-threaded, then we don't need to guard anything with a mutex?\n\nIt looks to me that `PeerManagerImpl::m_mutex_message_handling` is useless because it is only being acquired from a single thread. No two threads are ever going to race to acquire it at the same time:\n\n```cpp\nThreadMessageHandler() // there is just one thread executing this\n   ProcessMessages()\n       ...\",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r631895780,631895780,src/net_processing.cpp
ajtowns,2021-05-17 03:49:59,"Note that if you've got N peers each with K items in their work set, then a log search over everything is `log(N*K)`, and a log search for the peer followed by a log search or the work item is `log(N) + log(K)` which is the same. If there's one peer with K items and every other peer has 0, you instead get `log(K)` vs `log(N) + 1/N log(K)`; so a map of sets would be better than a set of pairs provi",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633205205,633205205,src/txorphanage.h
ajtowns,2021-05-17 03:52:59,"Changed to `map<NodeId,set<uint256>>`",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633205889,633205889,src/txorphanage.h
ajtowns,2021-05-17 03:56:19,"You don't need the mutex at runtime, but having the `GUARDED_BY(m_mutex_message_handling)` at compile time makes it easy to verify nobody's accidentally accessing the object from some other thread (either currently, or as a result of some future change, eg adding an RPC call that wants to expose some of the information stored in those objects). The cost of also having the mutex at runtime is trivi",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633206688,633206688,src/net_processing.cpp
jnewbery,2021-05-17 07:31:35,"```suggestion\n    // Look up this peer's work set, ensuring it exists.\n```",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633287175,633287175,src/txorphanage.cpp
jnewbery,2021-05-17 07:42:41,"In commit bdd227493602437d4b6ee2d366ca0a83189f071c:\n\nThe new value for `it` is unused. No need to set it here:\n\n```suggestion\n        orphan_work_set.erase(it);\n```",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633293884,633293884,src/net_processing.cpp
jnewbery,2021-05-17 11:22:06,"I left a comment about this interface further up that seems to have been lost without being resolved. I think the interface is needlessly complex and doing too much. From my comment above:\n\n> How about returning a `std::optional<std::pair<CTransactionRef, NodeId>>`, and then adding another public method `HasTxToReconsider()`. It's a bit less efficient, but we'll only ever call it after process",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633446322,633446322,src/txorphanage.h
jnewbery,2021-05-17 11:23:53,"(if you're keeping `more`), the following is equivalent, and maybe more direct/clear:\n\n```suggestion\n                more = !(work_set.empty());\n```",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633447335,633447335,src/txorphanage.cpp
ajtowns,2021-05-17 11:40:48,See https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601221165,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633456971,633456971,src/txorphanage.h
vasild,2021-05-17 16:11:21,"NACK the addition of `m_mutex_message_handling`.\n\nFollowing the logic of\n\n> GUARDED_BY() makes it easy to verify nobody's accidentally accessing...\n\nshould we add a dummy mutex for **every** variable?\n\nIMO mutexes should be used only where concurrent access is possible.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633669006,633669006,src/net_processing.cpp
jnewbery,2021-05-17 16:43:31,"@vasild can you take a look at the commits that build on top of this branch in https://github.com/jnewbery/bitcoin/commits/2021-05-use-mutex-message-handling. Currently, a lot of the data in net_processing is guarded by cs_main, which is also used in validation. One way to loosen that coupling between validation and net_processing is to introduce an internal mutex inside net_processing (`m_mutex_m",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r633692263,633692263,src/net_processing.cpp
vasild,2021-05-18 13:26:04,"I think that https://github.com/jnewbery/bitcoin/commits/2021-05-use-mutex-message-handling can be simplified and the common `m_mutex_message_handling` avoided by changing some of the variables to atomics and using a dedicated mutex for e.g. `m_txrequest`.\n\nBtw, it does not compile.\n<details>\n<summary>minor fixups</summary>\n\n```diff\ndiff --git i/src/net_processing.cpp w/src/net_proce",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r634375833,634375833,src/net_processing.cpp
ajtowns,2021-05-18 16:10:19,"""Should we add a dummy mutex for every variable"" -- we should have a GUARDED_BY for every object that's reachable by multiple threads, yes. The mutex is not a dummy, it's a real mutex.\n\nFor this specific case, here's an example of a patch that adds an access from another thread: https://github.com/ajtowns/bitcoin/commits/202105-whyhaveaguard . With the `GUARDED_BY(m_mutex_message_handling)` th",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r634534643,634534643,src/net_processing.cpp
vasild,2021-05-19 10:41:11,"> we should have a GUARDED_BY for every object that's reachable by multiple threads\n\nI assume here you mean -- even if the current code accesses it from a single thread.\n\nIf yes, then I think that is an overkill - it means having a mutex attached to every non-const global or class member variable, including private ones (coz in the future somebody may access it from another thread).\n\n>",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r635119808,635119808,src/net_processing.cpp
ajtowns,2021-05-20 14:37:12,"> `diff --git i/src/net.h w/src/net.h`\n\nYes, net.cpp/net.h is terrible for having globally accessible variables that aren't annotated for thread safety. Being able to introduce races that the compiler doesn't catch is a bad thing... txmempool's a better example, though it's also missing some guards (cf #22003).\n\n> IMO annotating everything with `GUARDED_BY()`, just in case, would have a ne",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r636167047,636167047,src/net_processing.cpp
vasild,2021-05-25 13:44:20,"@ajtowns, thanks for the elaboration.\n\nI still think that mutexes should be introduced when needed, not beforehand (with a reason that in the future somebody may access a variable from a different thread).\n\nLooks like neither one of us is convinced by the other's arguments. It's ok, it would have been too boring if everybody agreed on everything all the time.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r638801680,638801680,src/net_processing.cpp
vasild,2021-05-25 14:18:12,"Previously this would have allowed concurrent executions of `SendMessages()` for different peers, whereas now the concurrency is reduced by serializing all `SendMessages()` under the newly introduced single mutex `m_mutex_message_handling`.\n\nCurrently this code is executed by a single thread, so that is irrelevant, but in a possible future where we might want to do concurrent `SendMessages()` ",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r638832780,638832780,src/net.cpp
vasild,2021-05-25 16:27:27,"Before this PR we would have returned `false` (no more work) if `fDisconnect` was set regardless of the outcome of `ProcessOrphanTx()` and regardless of whether `peer->m_orphan_work_set` was empty.\n\nNow `fDisconnect` may be set, but we may return `true` if `ProcessOrphanTx()` returns `true`.\n\nIf this change is not intentional, then maybe swap the order:\n\n```cpp\n    if (pfrom->fDiscon",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r638964977,638964977,src/net_processing.cpp
vasild,2021-05-25 16:35:10,"Can be simplified?\n\n```suggestion\n    std::set<uint256>& orphan_work_set = m_peer_work_set[peer];\n```",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r638972961,638972961,src/txorphanage.cpp
vasild,2021-05-25 16:39:03,"`s/map/unordered_map/` to make lookup `O(1)` (we don't rely on this being ordered by `NodeId`). Same for the set of transaction ids.\n\n```suggestion\n    std::unordered_map<NodeId, std::unordered_set<uint256>> m_peer_work_set GUARDED_BY(m_mutex);\n```",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r638975978,638975978,src/txorphanage.h
vasild,2021-05-26 16:53:24,This `Assume()` seems unnecessary because `GetTxToReconsider()` is documented to populate `porphanTx` if it returns `true`.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r639923436,639923436,src/net_processing.cpp
vasild,2021-05-27 09:36:09,Is it possible for `TxOrphanage::m_orphans` to contain keys (transaction ids) which are not in `TxOrphanage::m_peer_work_set` or the other way around?,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r640459998,640459998,src/txorphanage.h
ajtowns,2021-05-28 02:53:58,All Assume's should be unnecessary by definition? See https://github.com/bitcoin/bitcoin/pull/21527#discussion_r601253387 for prior discussion.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r641181600,641181600,src/net_processing.cpp
ajtowns,2021-05-28 03:20:24,"`m_orphans` will normally contain txids that aren't in `m_peer_work_set` -- they only get added to the work set when a parent appears and are (hopefully) very quickly removed from the work set after retrying ATMP.\n\nIt's also possible for something to expire from `m_orphans` and still be present in `m_peer_work_set`: if a tx that's in the work set is removed via `LimitOrphans` or `EraseForBlock",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r641207541,641207541,src/txorphanage.h
vasild,2021-05-28 08:48:08,"`Assume()` makes sense if the value is derived in an obscure way. But not for checking whether a function has set its ""out"" parameters as documented.\n\nFor example, when calling `CSHA256::Finalize(result)` we don't set `result` to a dummy value before the call and check that it is not that dummy value after the call with `Assume()`. Same for any other function that has ""out"" parameters.\n\nIf",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r641381542,641381542,src/net_processing.cpp
ariard,2021-06-16 17:30:57,"I think second part of this comment ""This peer's set may be added..."" is confusing and annotating the parameter as an output doesn't make sense anymore.\n\nAfter this PR, parameter is no more a `std::map<NodeId, std::set<uint256>>` and new one can be actually a const.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r652902450,652902450,src/net_processing.cpp
ariard,2021-06-16 17:36:04,What do you think about `EXCLUSIVE_LOCKS_EXCLUDED(!(...))` ? The logical negation operator is easy to miss for a reviewer. ,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r652906116,652906116,src/txorphanage.h
ariard,2021-06-16 18:00:56,"At commit f86a525, I don't think this lock is useful to protect `vExtraTxnForCompact`, there is already one in `AddToCompactExtraTransactions` ? Though it might be useful at branch tip ?",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r652926191,652926191,src/net_processing.cpp
ariard,2021-06-16 18:18:37,"I think this introduce a lightweight behavior change.\n\nPreviously, if our peer has `fDisconnect=true` set up from a previous message processing and the orphan work set is still non-empty after the `ProcessOrphanTx` above, we would have return `false`.\n\nFrom now on, if the orphan work set is still non-empty after `ProcessOrphanTx`, we're going to return `true`. \n\nThough i don't think it",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r652937929,652937929,src/net_processing.cpp
ariard,2021-06-16 18:28:00,"Actually, sharing block headers/compact blocks messages in parallel has been discussed a while back (iirc  https://bitcoincore.org/en/meetings/2018/05/03/, see ""Call ProcessNewBlock asynchronously"") though we could insert some queued interface between a net_processing thread and multiple net threads ?\n\nThat said, if it's direction we agree on, I think the discussion is worthy to have.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r652945059,652945059,src/net.cpp
narula,2021-06-18 22:55:03,">  /** Message handling mutex.\n>    *  Message processing is single-threaded, so anything only accessed\n>    *  by ProcessMessage(s) or SendMessages can be guarded by this mutex,\n>    *  which guarantees it's only accessed by a single thread.\n\nI'm confused. This mutex ends up protecting everything accessed in those functions. For example, in `SendMessages`, it also protects `MaybeDiscour",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r654705472,654705472,src/net_processing.cpp
amitiuttarwar,2021-06-18 23:28:52,"do I understand correctly that after these changes `PeerManagerImpl::ProcessMessage` is a test-only function? If so, I think the comment in `net_processing.h` should be updated. Or even better, the function renamed to something like `ProcessMessageTest` :)",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r654713376,654713376,src/net_processing.cpp
ajtowns,2021-09-02 06:49:02,I was just adding `AssertLockHeld` to correspond with the `EXCLUSIVE_LOCKS_REQUIRED` annotation as a matter of course (see the recommendation in developer-notes.md).,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r700794786,700794786,src/net_processing.cpp
ajtowns,2021-09-02 06:51:05,"`fDisconnect` is already checked in net.cpp prior to `ProcessMessages` being called, but there's always a chance that there's a race and `fDisconnect` is set while in the middle of `ProcessMessages` for the peer.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r700795929,700795929,src/net_processing.cpp
ajtowns,2021-09-02 22:26:56,"If you have:\n\n```c++\nMutex mutex;\nint x GUARDED_BY(mutex);\nint y;\nstatic void A() { LOCK(mutex); ++x; ++y; }\nstatic void B() { LOCK(mutex); --x; }\nvoid ThreadA() { for (int i = 0; i < 100; ++i) { A(); } }\nvoid ThreadB() { for (int i = 0; i < 100; ++i) { B(); } }\n```\n\nthen I'd say that only `x` is guarded by the mutex, even though `y` is only actually accessed while the mute",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701462414,701462414,src/net_processing.cpp
ajtowns,2021-09-02 22:35:53,"`PeerManager::ProcessMessage` has always only been exposed for tests, and is already documented that way in the header file:\n\n```c++\n    /** Process a single message from a peer. Public for fuzz testing */\n    virtual void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n```\n\n`PeerManagerImpl::ProcessMessage` is thus needed to complete the `PeerManager` i",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701466455,701466455,src/net_processing.cpp
ajtowns,2021-09-02 23:21:53,Added a comment.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701484079,701484079,src/net_processing.cpp
ajtowns,2021-09-02 23:23:16,Changed to `return !pfrom->fDisconnect` to preserve the same behaviour.,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701484517,701484517,src/net_processing.cpp
ajtowns,2021-09-02 23:24:37,Changed to C++17's `try_emplace` which simplifies it slightly. Not really a fan of `map::operator[]`,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701484925,701484925,src/txorphanage.cpp
ajtowns,2021-09-02 23:25:57,"Left as map; I don't think performance matters enough to justify using extra space for the hashmap; and longer term, using a multiindex rather than a bunch of different containers referencing each other is probably better.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701485341,701485341,src/txorphanage.h
ajtowns,2021-09-02 23:28:04,"Dropped the `out` which doesn't make sense. Knowing that this may increase the size of the set, not simply reduce it is valuable I think, so have left that text alone.",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701486116,701486116,src/net_processing.cpp
ajtowns,2021-09-02 23:29:08,Seems like something more for clang upstream if anything?,https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701486468,701486468,src/txorphanage.h
vasild,2021-09-03 08:06:17,"> I guess I'd look at it more as mutexes protect __code__ from being run simultaneously\n\nIMO mutexes protect variables, not code.\n\nFrom https://en.wikipedia.org/wiki/Lock_(computer_science)\n> ... a mechanism that enforces limits on access to a __resource__ ...\n> ... each thread cooperates by acquiring the lock before accessing the __corresponding data__ ...",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r701689238,701689238,src/net_processing.cpp
ajtowns,2021-09-07 02:55:55,"Read your second quote carefully -- it's not the mutex/lock that protects the data, it's the threads that protect it by cooperatively acquiring the lock before accessing the data.\n\nIt's 99% true that the point of using a mutex is to protect data, but it's not the mutex itself that ensures the data is protected, it's how you use the mutex. It's like looking both ways before crossing the road --",https://github.com/bitcoin/bitcoin/pull/21527#discussion_r703141868,703141868,src/net_processing.cpp
