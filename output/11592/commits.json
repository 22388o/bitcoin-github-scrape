[
  {
    "sha": "5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YjcyOGM4ZTk4YTRkM2Q3MmIxY2E1ZjZhYzI4N2I0NTNiMGZiNWQ2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-07-12T14:29:02Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T14:40:09Z"
      },
      "message": "[tests] remove direct testing on JSONRPCException from individual test cases\n\nGithub-Pull: #10853\nRebased-From: 5864e9c1611e6034a8d49b78231abe6bfade686d",
      "tree": {
        "sha": "c4a4cd22c46b1d214a27f532bf4e39adc5d395aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c4a4cd22c46b1d214a27f532bf4e39adc5d395aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34833534b656f565df9510a6c649687063db956d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34833534b656f565df9510a6c649687063db956d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34833534b656f565df9510a6c649687063db956d"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 26,
      "deletions": 26
    },
    "files": [
      {
        "sha": "c7eb07ab12d7fa8005c3946ff92c3d007f229be8",
        "filename": "test/functional/import-rescan.py",
        "status": "modified",
        "additions": 13,
        "deletions": 17,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/import-rescan.py?ref=5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "patch": "@@ -19,9 +19,8 @@\n happened previously.\n \"\"\"\n \n-from test_framework.authproxy import JSONRPCException\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (connect_nodes, sync_blocks, assert_equal, set_node_times)\n+from test_framework.util import (assert_raises_jsonrpc, connect_nodes, sync_blocks, assert_equal, set_node_times)\n \n import collections\n import enum\n@@ -35,21 +34,26 @@\n class Variant(collections.namedtuple(\"Variant\", \"call data rescan prune\")):\n     \"\"\"Helper for importing one key and verifying scanned transactions.\"\"\"\n \n+    def try_rpc(self, func, *args, **kwargs):\n+        if self.expect_disabled:\n+            assert_raises_jsonrpc(-4, \"Rescan is disabled in pruned mode\", func, *args, **kwargs)\n+        else:\n+            return func(*args, **kwargs)\n+\n     def do_import(self, timestamp):\n         \"\"\"Call one key import RPC.\"\"\"\n \n         if self.call == Call.single:\n             if self.data == Data.address:\n-                response, error = try_rpc(self.node.importaddress, self.address[\"address\"], self.label,\n-                                          self.rescan == Rescan.yes)\n+                response = self.try_rpc(self.node.importaddress, self.address[\"address\"], self.label,\n+                                               self.rescan == Rescan.yes)\n             elif self.data == Data.pub:\n-                response, error = try_rpc(self.node.importpubkey, self.address[\"pubkey\"], self.label,\n-                                          self.rescan == Rescan.yes)\n+                response = self.try_rpc(self.node.importpubkey, self.address[\"pubkey\"], self.label,\n+                                               self.rescan == Rescan.yes)\n             elif self.data == Data.priv:\n-                response, error = try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n+                response = self.try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n             assert_equal(response, None)\n-            assert_equal(error, {'message': 'Rescan is disabled in pruned mode',\n-                                 'code': -4} if self.expect_disabled else None)\n+\n         elif self.call == Call.multi:\n             response = self.node.importmulti([{\n                 \"scriptPubKey\": {\n@@ -180,13 +184,5 @@ def run_test(self):\n             else:\n                 variant.check()\n \n-\n-def try_rpc(func, *args, **kwargs):\n-    try:\n-        return func(*args, **kwargs), None\n-    except JSONRPCException as e:\n-        return None, e.error\n-\n-\n if __name__ == \"__main__\":\n     ImportRescanTest().main()"
      },
      {
        "sha": "f16c9ab97aad78ff2438c14ea6a5d5ad425d8a77",
        "filename": "test/functional/importmulti.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importmulti.py?ref=5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "patch": "@@ -448,11 +448,11 @@ def run_test (self):\n \n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n-        assert_raises_message(JSONRPCException, 'Missing required timestamp field for key',\n+        assert_raises_jsonrpc(-3, 'Missing required timestamp field for key',\n             self.nodes[1].importmulti, [{\n                 \"scriptPubKey\": address['scriptPubKey'],\n             }])\n-        assert_raises_message(JSONRPCException, 'Expected number or \"now\" timestamp value for key. got type string',\n+        assert_raises_jsonrpc(-3, 'Expected number or \"now\" timestamp value for key. got type string',\n             self.nodes[1].importmulti, [{\n                 \"scriptPubKey\": address['scriptPubKey'],\n                 \"timestamp\": \"\","
      },
      {
        "sha": "7571bd1a37bccbc18c39848c461bf61ca43d1aeb",
        "filename": "test/functional/segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/segwit.py?ref=5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "patch": "@@ -443,11 +443,7 @@ def run_test(self):\n         for i in importlist:\n             # import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n             # exceptions and continue.\n-            try:\n-                self.nodes[0].importaddress(i,\"\",False,True)\n-            except JSONRPCException as exp:\n-                assert_equal(exp.error[\"message\"], \"The wallet already contains the private key for this address or script\")\n-                assert_equal(exp.error[\"code\"], -4)\n+            try_rpc(-4, \"The wallet already contains the private key for this address or script\", self.nodes[0].importaddress, i, \"\", False, True)\n \n         self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n         self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey"
      },
      {
        "sha": "00a58e108e76c1d67aa104c80fe0b866e894b4e4",
        "filename": "test/functional/signrawtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/signrawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/signrawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/signrawtransactions.py?ref=5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "patch": "@@ -82,7 +82,7 @@ def script_verification_error_test(self):\n             assert_equal(decodedRawTx[\"vin\"][i][\"vout\"], inp[\"vout\"])\n \n         # Make sure decoderawtransaction throws if there is extra data\n-        assert_raises(JSONRPCException, self.nodes[0].decoderawtransaction, rawTx + \"00\")\n+        assert_raises_jsonrpc(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, rawTx + \"00\")\n \n         rawTxSigned = self.nodes[0].signrawtransaction(rawTx, scripts, privKeys)\n "
      },
      {
        "sha": "44d7e04a898096b9b1dff961f89e6cab85cce665",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "patch": "@@ -99,6 +99,13 @@ def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n         args*: positional arguments for the function.\n         kwds**: named arguments for the function.\n     \"\"\"\n+    assert try_rpc(code, message, fun, *args, **kwds), \"No exception raised\"\n+\n+def try_rpc(code, message, fun, *args, **kwds):\n+    \"\"\"Tries to run an rpc command.\n+\n+    Test against error code and message if the rpc fails.\n+    Returns whether a JSONRPCException was raised.\"\"\"\n     try:\n         fun(*args, **kwds)\n     except JSONRPCException as e:\n@@ -107,10 +114,11 @@ def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n             raise AssertionError(\"Unexpected JSONRPC error code %i\" % e.error[\"code\"])\n         if (message is not None) and (message not in e.error['message']):\n             raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n+        return True\n     except Exception as e:\n         raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n     else:\n-        raise AssertionError(\"No exception raised\")\n+        return False\n \n def assert_is_hex_string(string):\n     try:"
      }
    ]
  },
  {
    "sha": "623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjNkZTBhY2JiN2E1ODZhZGJhOGQxZjlhNjRjNzdmYWJiMGU5OGE0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-07-12T14:29:21Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T14:40:22Z"
      },
      "message": "[tests] do not allow assert_raises_message to be called with JSONRPCException\n\nGithub-Pull: #10853\nRebased-From: 677d893ff758b61f66203730da224bd7ef8f0b43",
      "tree": {
        "sha": "2599885d2222dc81fd93246eac359fa545a5f510",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2599885d2222dc81fd93246eac359fa545a5f510"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/623de0acbb7a586adba8d1f9a64c77fabb0e98a4/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b728c8e98a4d3d72b1ca5f6ac287b453b0fb5d6"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ed35bf576eb83b9a3c6587594beca73a1b00bfb5",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/623de0acbb7a586adba8d1f9a64c77fabb0e98a4/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/623de0acbb7a586adba8d1f9a64c77fabb0e98a4/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
        "patch": "@@ -51,6 +51,8 @@ def assert_raises(exc, fun, *args, **kwds):\n def assert_raises_message(exc, message, fun, *args, **kwds):\n     try:\n         fun(*args, **kwds)\n+    except JSONRPCException:\n+        raise AssertionError(\"Use assert_raises_jsonrpc() to test RPC failures\")\n     except exc as e:\n         if message is not None and message not in e.error['message']:\n             raise AssertionError(\"Expected substring not found:\" + e.error['message'])"
      }
    ]
  },
  {
    "sha": "d94fc336c47b5fd0f42217806faad1aa201b9d63",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOTRmYzMzNmM0N2I1ZmQwZjQyMjE3ODA2ZmFhZDFhYTIwMWI5ZDYz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-01T14:41:28Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T14:42:30Z"
      },
      "message": "scripted-diff: rename assert_raises_jsonrpc to assert_raises_rpc error\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/assert_raises_jsonrpc/assert_raises_rpc_error/g' test/functional/*py test/functional/test_framework/*py\n-END VERIFY SCRIPT-\n\nGithub-Pull: #10853\nRebased-From: 47ba8cf71e9a3a6f7452488fc9ab3b350f0fae36",
      "tree": {
        "sha": "1603fa9706a06bb0eb1ccaa5e9f78390896bbedd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1603fa9706a06bb0eb1ccaa5e9f78390896bbedd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d94fc336c47b5fd0f42217806faad1aa201b9d63",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d94fc336c47b5fd0f42217806faad1aa201b9d63",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d94fc336c47b5fd0f42217806faad1aa201b9d63",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d94fc336c47b5fd0f42217806faad1aa201b9d63/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/623de0acbb7a586adba8d1f9a64c77fabb0e98a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/623de0acbb7a586adba8d1f9a64c77fabb0e98a4"
      }
    ],
    "stats": {
      "total": 226,
      "additions": 113,
      "deletions": 113
    },
    "files": [
      {
        "sha": "b3b5adf425c1245e331934de5939d6b34871a772",
        "filename": "test/functional/bip68-sequence.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip68-sequence.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -83,7 +83,7 @@ def test_disable_flag(self):\n         tx2.vout = [CTxOut(int(value-self.relayfee*COIN), CScript([b'a']))]\n         tx2.rehash()\n \n-        assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx2))\n+        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx2))\n \n         # Setting the version back down to 1 should disable the sequence lock,\n         # so this should be accepted.\n@@ -180,7 +180,7 @@ def test_sequence_lock_confirmed_inputs(self):\n \n             if (using_sequence_locks and not should_pass):\n                 # This transaction should be rejected\n-                assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, rawtx)\n+                assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, rawtx)\n             else:\n                 # This raw transaction should be accepted\n                 self.nodes[0].sendrawtransaction(rawtx)\n@@ -227,7 +227,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n \n             if (orig_tx.hash in node.getrawmempool()):\n                 # sendrawtransaction should fail if the tx is in the mempool\n-                assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, node.sendrawtransaction, ToHex(tx))\n+                assert_raises_rpc_error(-26, NOT_FINAL_ERROR, node.sendrawtransaction, ToHex(tx))\n             else:\n                 # sendrawtransaction should succeed if the tx is not in the mempool\n                 node.sendrawtransaction(ToHex(tx))\n@@ -280,7 +280,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n         raw_tx5 = self.nodes[0].signrawtransaction(ToHex(tx5))[\"hex\"]\n \n-        assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, raw_tx5)\n+        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, raw_tx5)\n \n         # Test mempool-BIP68 consistency after reorg\n         #\n@@ -353,7 +353,7 @@ def test_bip68_not_consensus(self):\n         tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n         tx3.rehash()\n \n-        assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx3))\n+        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx3))\n \n         # make a block that violates bip68; ensure that the tip updates\n         tip = int(self.nodes[0].getbestblockhash(), 16)"
      },
      {
        "sha": "4c2997f8bdfd5a258d8b622e3f3f2511eed04a9a",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -25,7 +25,7 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises,\n-    assert_raises_jsonrpc,\n+    assert_raises_rpc_error,\n     assert_is_hex_string,\n     assert_is_hash_string,\n )\n@@ -96,7 +96,7 @@ def _test_gettxoutsetinfo(self):\n     def _test_getblockheader(self):\n         node = self.nodes[0]\n \n-        assert_raises_jsonrpc(-5, \"Block not found\",\n+        assert_raises_rpc_error(-5, \"Block not found\",\n                               node.getblockheader, \"nonsense\")\n \n         besthash = node.getbestblockhash()"
      },
      {
        "sha": "c2aa75209caedac26bb1f67940ef472c80e444db",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -133,7 +133,7 @@ def test_segwit_bumpfee_succeeds(rbf_node, dest_address):\n def test_nonrbf_bumpfee_fails(peer_node, dest_address):\n     # cannot replace a non RBF transaction (from node which did not enable RBF)\n     not_rbfid = peer_node.sendtoaddress(dest_address, Decimal(\"0.00090000\"))\n-    assert_raises_jsonrpc(-4, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n+    assert_raises_rpc_error(-4, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n \n \n def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n@@ -153,7 +153,7 @@ def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n     signedtx = rbf_node.signrawtransaction(rawtx)\n     signedtx = peer_node.signrawtransaction(signedtx[\"hex\"])\n     rbfid = rbf_node.sendrawtransaction(signedtx[\"hex\"])\n-    assert_raises_jsonrpc(-4, \"Transaction contains inputs that don't belong to this wallet\",\n+    assert_raises_rpc_error(-4, \"Transaction contains inputs that don't belong to this wallet\",\n                           rbf_node.bumpfee, rbfid)\n \n \n@@ -164,7 +164,7 @@ def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address)\n     tx = rbf_node.createrawtransaction([{\"txid\": parent_id, \"vout\": 0}], {dest_address: 0.00020000})\n     tx = rbf_node.signrawtransaction(tx)\n     txid = rbf_node.sendrawtransaction(tx[\"hex\"])\n-    assert_raises_jsonrpc(-8, \"Transaction has descendants in the wallet\", rbf_node.bumpfee, parent_id)\n+    assert_raises_rpc_error(-8, \"Transaction has descendants in the wallet\", rbf_node.bumpfee, parent_id)\n \n \n def test_small_output_fails(rbf_node, dest_address):\n@@ -173,7 +173,7 @@ def test_small_output_fails(rbf_node, dest_address):\n     rbf_node.bumpfee(rbfid, {\"totalFee\": 50000})\n \n     rbfid = spend_one_input(rbf_node, dest_address)\n-    assert_raises_jsonrpc(-4, \"Change output is too small\", rbf_node.bumpfee, rbfid, {\"totalFee\": 50001})\n+    assert_raises_rpc_error(-4, \"Change output is too small\", rbf_node.bumpfee, rbfid, {\"totalFee\": 50001})\n \n \n def test_dust_to_fee(rbf_node, dest_address):\n@@ -205,15 +205,15 @@ def test_rebumping(rbf_node, dest_address):\n     # check that re-bumping the original tx fails, but bumping the bumper succeeds\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 2000})\n-    assert_raises_jsonrpc(-4, \"already bumped\", rbf_node.bumpfee, rbfid, {\"totalFee\": 3000})\n+    assert_raises_rpc_error(-4, \"already bumped\", rbf_node.bumpfee, rbfid, {\"totalFee\": 3000})\n     rbf_node.bumpfee(bumped[\"txid\"], {\"totalFee\": 3000})\n \n \n def test_rebumping_not_replaceable(rbf_node, dest_address):\n     # check that re-bumping a non-replaceable bump tx fails\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 10000, \"replaceable\": False})\n-    assert_raises_jsonrpc(-4, \"Transaction is not BIP 125 replaceable\", rbf_node.bumpfee, bumped[\"txid\"],\n+    assert_raises_rpc_error(-4, \"Transaction is not BIP 125 replaceable\", rbf_node.bumpfee, bumped[\"txid\"],\n                           {\"totalFee\": 20000})\n \n \n@@ -264,7 +264,7 @@ def test_bumpfee_metadata(rbf_node, dest_address):\n def test_locked_wallet_fails(rbf_node, dest_address):\n     rbfid = spend_one_input(rbf_node, dest_address)\n     rbf_node.walletlock()\n-    assert_raises_jsonrpc(-13, \"Please enter the wallet passphrase with walletpassphrase first.\",\n+    assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first.\",\n                           rbf_node.bumpfee, rbfid)\n \n "
      },
      {
        "sha": "c75ef9b9f12d562a3667ec246e601045ce9bba97",
        "filename": "test/functional/disablewallet.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/disablewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/disablewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disablewallet.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -19,7 +19,7 @@ def set_test_params(self):\n \n     def run_test (self):\n         # Make sure wallet is really disabled\n-        assert_raises_jsonrpc(-32601, 'Method not found', self.nodes[0].getwalletinfo)\n+        assert_raises_rpc_error(-32601, 'Method not found', self.nodes[0].getwalletinfo)\n         x = self.nodes[0].validateaddress('3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n         assert(x['isvalid'] == False)\n         x = self.nodes[0].validateaddress('mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n@@ -28,7 +28,7 @@ def run_test (self):\n         # Checking mining to an address without a wallet. Generating to a valid address should succeed\n         # but generating to an invalid address will fail.\n         self.nodes[0].generatetoaddress(1, 'mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n-        assert_raises_jsonrpc(-5, \"Invalid address\", self.nodes[0].generatetoaddress, 1, '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n+        assert_raises_rpc_error(-5, \"Invalid address\", self.nodes[0].generatetoaddress, 1, '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n \n if __name__ == '__main__':\n     DisableWalletTest ().main ()"
      },
      {
        "sha": "59655d37fbe21878e13b76f5952c533a1512197a",
        "filename": "test/functional/disconnect_ban.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disconnect_ban.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -8,7 +8,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    assert_raises_jsonrpc,\n+    assert_raises_rpc_error,\n     connect_nodes_bi,\n     wait_until,\n )\n@@ -34,14 +34,14 @@ def run_test(self):\n \n         self.log.info(\"setban: fail to ban an already banned subnet\")\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n-        assert_raises_jsonrpc(-23, \"IP/Subnet already banned\", self.nodes[1].setban, \"127.0.0.1\", \"add\")\n+        assert_raises_rpc_error(-23, \"IP/Subnet already banned\", self.nodes[1].setban, \"127.0.0.1\", \"add\")\n \n         self.log.info(\"setban: fail to ban an invalid subnet\")\n-        assert_raises_jsonrpc(-30, \"Error: Invalid IP/Subnet\", self.nodes[1].setban, \"127.0.0.1/42\", \"add\")\n+        assert_raises_rpc_error(-30, \"Error: Invalid IP/Subnet\", self.nodes[1].setban, \"127.0.0.1/42\", \"add\")\n         assert_equal(len(self.nodes[1].listbanned()), 1)  # still only one banned ip because 127.0.0.1 is within the range of 127.0.0.0/24\n \n         self.log.info(\"setban remove: fail to unban a non-banned subnet\")\n-        assert_raises_jsonrpc(-30, \"Error: Unban failed\", self.nodes[1].setban, \"127.0.0.1\", \"remove\")\n+        assert_raises_rpc_error(-30, \"Error: Unban failed\", self.nodes[1].setban, \"127.0.0.1\", \"remove\")\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n \n         self.log.info(\"setban remove: successfully unban subnet\")\n@@ -81,10 +81,10 @@ def run_test(self):\n         self.log.info(\"disconnectnode: fail to disconnect when calling with address and nodeid\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']\n         node1 = self.nodes[0].getpeerinfo()[0]['addr']\n-        assert_raises_jsonrpc(-32602, \"Only one of address and nodeid should be provided.\", self.nodes[0].disconnectnode, address=address1, nodeid=node1)\n+        assert_raises_rpc_error(-32602, \"Only one of address and nodeid should be provided.\", self.nodes[0].disconnectnode, address=address1, nodeid=node1)\n \n         self.log.info(\"disconnectnode: fail to disconnect when calling with junk address\")\n-        assert_raises_jsonrpc(-29, \"Node not found in connected nodes\", self.nodes[0].disconnectnode, address=\"221B Baker Street\")\n+        assert_raises_rpc_error(-29, \"Node not found in connected nodes\", self.nodes[0].disconnectnode, address=\"221B Baker Street\")\n \n         self.log.info(\"disconnectnode: successfully disconnect node by address\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']"
      },
      {
        "sha": "1c4f269ec0e22e36e920a18e80ae21755207e8fe",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -179,7 +179,7 @@ def run_test(self):\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n-        assert_raises_jsonrpc(-3, \"Unexpected key foo\", self.nodes[2].fundrawtransaction, rawtx, {'foo':'bar'})\n+        assert_raises_rpc_error(-3, \"Unexpected key foo\", self.nodes[2].fundrawtransaction, rawtx, {'foo':'bar'})\n \n         ############################################################\n         # test a fundrawtransaction with an invalid change address #\n@@ -192,7 +192,7 @@ def run_test(self):\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n-        assert_raises_jsonrpc(-5, \"changeAddress must be a valid bitcoin address\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':'foobar'})\n+        assert_raises_rpc_error(-5, \"changeAddress must be a valid bitcoin address\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':'foobar'})\n \n         ############################################################\n         # test a fundrawtransaction with a provided change address #\n@@ -206,7 +206,7 @@ def run_test(self):\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n         change = self.nodes[2].getnewaddress()\n-        assert_raises_jsonrpc(-8, \"changePosition out of bounds\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':change, 'changePosition':2})\n+        assert_raises_rpc_error(-8, \"changePosition out of bounds\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':change, 'changePosition':2})\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx, {'changeAddress': change, 'changePosition': 0})\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n         out = dec_tx['vout'][0]\n@@ -315,7 +315,7 @@ def run_test(self):\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n \n-        assert_raises_jsonrpc(-4, \"Insufficient funds\", self.nodes[2].fundrawtransaction, rawtx)\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[2].fundrawtransaction, rawtx)\n \n         ############################################################\n         #compare fee of a standard pubkeyhash transaction\n@@ -470,14 +470,14 @@ def run_test(self):\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         # fund a transaction that requires a new key for the change output\n         # creating the key must be impossible because the wallet is locked\n-        assert_raises_jsonrpc(-4, \"Keypool ran out, please call keypoolrefill first\", self.nodes[1].fundrawtransaction, rawtx)\n+        assert_raises_rpc_error(-4, \"Keypool ran out, please call keypoolrefill first\", self.nodes[1].fundrawtransaction, rawtx)\n \n         #refill the keypool\n         self.nodes[1].walletpassphrase(\"test\", 100)\n         self.nodes[1].keypoolrefill(8) #need to refill the keypool to get an internal change address\n         self.nodes[1].walletlock()\n \n-        assert_raises_jsonrpc(-13, \"walletpassphrase\", self.nodes[1].sendtoaddress, self.nodes[0].getnewaddress(), 1.2)\n+        assert_raises_rpc_error(-13, \"walletpassphrase\", self.nodes[1].sendtoaddress, self.nodes[0].getnewaddress(), 1.2)\n \n         oldBalance = self.nodes[0].getbalance()\n "
      },
      {
        "sha": "955554204d81ac141cecc515914cd8a2d769ca17",
        "filename": "test/functional/import-rescan.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/import-rescan.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -20,7 +20,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (assert_raises_jsonrpc, connect_nodes, sync_blocks, assert_equal, set_node_times)\n+from test_framework.util import (assert_raises_rpc_error, connect_nodes, sync_blocks, assert_equal, set_node_times)\n \n import collections\n import enum\n@@ -36,7 +36,7 @@ class Variant(collections.namedtuple(\"Variant\", \"call data rescan prune\")):\n \n     def try_rpc(self, func, *args, **kwargs):\n         if self.expect_disabled:\n-            assert_raises_jsonrpc(-4, \"Rescan is disabled in pruned mode\", func, *args, **kwargs)\n+            assert_raises_rpc_error(-4, \"Rescan is disabled in pruned mode\", func, *args, **kwargs)\n         else:\n             return func(*args, **kwargs)\n "
      },
      {
        "sha": "324f6458e3059b608f96fc8a36b56df9326db5ad",
        "filename": "test/functional/importmulti.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importmulti.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -448,11 +448,11 @@ def run_test (self):\n \n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n-        assert_raises_jsonrpc(-3, 'Missing required timestamp field for key',\n+        assert_raises_rpc_error(-3, 'Missing required timestamp field for key',\n             self.nodes[1].importmulti, [{\n                 \"scriptPubKey\": address['scriptPubKey'],\n             }])\n-        assert_raises_jsonrpc(-3, 'Expected number or \"now\" timestamp value for key. got type string',\n+        assert_raises_rpc_error(-3, 'Expected number or \"now\" timestamp value for key. got type string',\n             self.nodes[1].importmulti, [{\n                 \"scriptPubKey\": address['scriptPubKey'],\n                 \"timestamp\": \"\","
      },
      {
        "sha": "c445b66df3ac69a752f1ab6d8460fffa899958cf",
        "filename": "test/functional/importprunedfunds.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importprunedfunds.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -67,7 +67,7 @@ def run_test(self):\n         self.sync_all()\n \n         #Import with no affiliated address\n-        assert_raises_jsonrpc(-5, \"No addresses\", self.nodes[1].importprunedfunds, rawtxn1, proof1)\n+        assert_raises_rpc_error(-5, \"No addresses\", self.nodes[1].importprunedfunds, rawtxn1, proof1)\n \n         balance1 = self.nodes[1].getbalance(\"\", 0, True)\n         assert_equal(balance1, Decimal(0))\n@@ -98,7 +98,7 @@ def run_test(self):\n         assert_equal(address_info['ismine'], True)\n \n         #Remove transactions\n-        assert_raises_jsonrpc(-8, \"Transaction does not exist in wallet.\", self.nodes[1].removeprunedfunds, txnid1)\n+        assert_raises_rpc_error(-8, \"Transaction does not exist in wallet.\", self.nodes[1].removeprunedfunds, txnid1)\n \n         balance1 = self.nodes[1].getbalance(\"*\", 0, True)\n         assert_equal(balance1, Decimal('0.075'))"
      },
      {
        "sha": "f2701c36bdcacbfd45ff30d27fd839131b1e228d",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -28,7 +28,7 @@ def run_test(self):\n         wallet_info = nodes[0].getwalletinfo()\n         assert(addr_before_encrypting_data['hdmasterkeyid'] != wallet_info['hdmasterkeyid'])\n         assert(addr_data['hdmasterkeyid'] == wallet_info['hdmasterkeyid'])\n-        assert_raises_jsonrpc(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n+        assert_raises_rpc_error(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n \n         # put six (plus 2) new keys in the keypool (100% external-, +100% internal-keys, 1 in min)\n         nodes[0].walletpassphrase('test', 12000)\n@@ -47,7 +47,7 @@ def run_test(self):\n         nodes[0].getrawchangeaddress()\n         addr = set()\n         # the next one should fail\n-        assert_raises_jsonrpc(-12, \"Keypool ran out\", nodes[0].getrawchangeaddress)\n+        assert_raises_rpc_error(-12, \"Keypool ran out\", nodes[0].getrawchangeaddress)\n \n         # drain the external keys\n         addr.add(nodes[0].getnewaddress())\n@@ -58,7 +58,7 @@ def run_test(self):\n         addr.add(nodes[0].getnewaddress())\n         assert(len(addr) == 6)\n         # the next one should fail\n-        assert_raises_jsonrpc(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n+        assert_raises_rpc_error(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n \n         # refill keypool with three new addresses\n         nodes[0].walletpassphrase('test', 1)\n@@ -72,7 +72,7 @@ def run_test(self):\n         nodes[0].generate(1)\n         nodes[0].generate(1)\n         nodes[0].generate(1)\n-        assert_raises_jsonrpc(-12, \"Keypool ran out\", nodes[0].generate, 1)\n+        assert_raises_rpc_error(-12, \"Keypool ran out\", nodes[0].generate, 1)\n \n         nodes[0].walletpassphrase('test', 100)\n         nodes[0].keypoolrefill(100)"
      },
      {
        "sha": "6d3849bf57ebb86f00207a0d00822abc645f4ddb",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -115,7 +115,7 @@ def run_test(self):\n             assert_equal(mempool[x]['descendantfees'], descendant_fees * COIN + 1000)\n \n         # Adding one more transaction on to the chain should fail.\n-        assert_raises_jsonrpc(-26, \"too-long-mempool-chain\", self.chain_transaction, self.nodes[0], txid, vout, value, fee, 1)\n+        assert_raises_rpc_error(-26, \"too-long-mempool-chain\", self.chain_transaction, self.nodes[0], txid, vout, value, fee, 1)\n \n         # Check that prioritising a tx before it's added to the mempool works\n         # First clear the mempool by mining a block.\n@@ -167,7 +167,7 @@ def run_test(self):\n \n         # Sending one more chained transaction will fail\n         utxo = transaction_package.pop(0)\n-        assert_raises_jsonrpc(-26, \"too-long-mempool-chain\", self.chain_transaction, self.nodes[0], utxo['txid'], utxo['vout'], utxo['amount'], fee, 10)\n+        assert_raises_rpc_error(-26, \"too-long-mempool-chain\", self.chain_transaction, self.nodes[0], utxo['txid'], utxo['vout'], utxo['amount'], fee, 10)\n \n         # TODO: check that node1's mempool is as expected\n "
      },
      {
        "sha": "2803371f5b603892fc549e15284f01b98ec73883",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -50,14 +50,14 @@ def run_test(self):\n         timelock_tx = timelock_tx[:-8] + hex(self.nodes[0].getblockcount() + 2)[2:] + \"000000\"\n         timelock_tx = self.nodes[0].signrawtransaction(timelock_tx)[\"hex\"]\n         # This will raise an exception because the timelock transaction is too immature to spend\n-        assert_raises_jsonrpc(-26, \"non-final\", self.nodes[0].sendrawtransaction, timelock_tx)\n+        assert_raises_rpc_error(-26, \"non-final\", self.nodes[0].sendrawtransaction, timelock_tx)\n \n         # Broadcast and mine spend_102 and 103:\n         spend_102_id = self.nodes[0].sendrawtransaction(spend_102_raw)\n         spend_103_id = self.nodes[0].sendrawtransaction(spend_103_raw)\n         self.nodes[0].generate(1)\n         # Time-locked transaction is still too immature to spend\n-        assert_raises_jsonrpc(-26,'non-final', self.nodes[0].sendrawtransaction, timelock_tx)\n+        assert_raises_rpc_error(-26,'non-final', self.nodes[0].sendrawtransaction, timelock_tx)\n \n         # Create 102_1 and 103_1:\n         spend_102_1_raw = create_tx(self.nodes[0], spend_102_id, node1_address, 49.98)"
      },
      {
        "sha": "6e8a635a765413fd3ab3ba0e38e739a6836039c9",
        "filename": "test/functional/mempool_spendcoinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mempool_spendcoinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mempool_spendcoinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spendcoinbase.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -36,7 +36,7 @@ def run_test(self):\n         spend_101_id = self.nodes[0].sendrawtransaction(spends_raw[0])\n \n         # coinbase at height 102 should be too immature to spend\n-        assert_raises_jsonrpc(-26,\"bad-txns-premature-spend-of-coinbase\", self.nodes[0].sendrawtransaction, spends_raw[1])\n+        assert_raises_rpc_error(-26,\"bad-txns-premature-spend-of-coinbase\", self.nodes[0].sendrawtransaction, spends_raw[1])\n \n         # mempool should have just spend_101:\n         assert_equal(self.nodes[0].getrawmempool(), [ spend_101_id ])"
      },
      {
        "sha": "b3989a4c54885ab9d9763cded9c263ef4dd06f75",
        "filename": "test/functional/merkle_blocks.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/merkle_blocks.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -38,7 +38,7 @@ def run_test(self):\n         tx2 = self.nodes[0].createrawtransaction([node0utxos.pop()], {self.nodes[1].getnewaddress(): 49.99})\n         txid2 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx2)[\"hex\"])\n         # This will raise an exception because the transaction is not yet in a block\n-        assert_raises_jsonrpc(-5, \"Transaction not yet in block\", self.nodes[0].gettxoutproof, [txid1])\n+        assert_raises_rpc_error(-5, \"Transaction not yet in block\", self.nodes[0].gettxoutproof, [txid1])\n \n         self.nodes[0].generate(1)\n         blockhash = self.nodes[0].getblockhash(chain_height + 1)\n@@ -63,11 +63,11 @@ def run_test(self):\n         txid_unspent = txid1 if txin_spent[\"txid\"] != txid1 else txid2\n \n         # We can't find the block from a fully-spent tx\n-        assert_raises_jsonrpc(-5, \"Transaction not yet in block\", self.nodes[2].gettxoutproof, [txid_spent])\n+        assert_raises_rpc_error(-5, \"Transaction not yet in block\", self.nodes[2].gettxoutproof, [txid_spent])\n         # We can get the proof if we specify the block\n         assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_spent], blockhash)), [txid_spent])\n         # We can't get the proof if we specify a non-existent block\n-        assert_raises_jsonrpc(-5, \"Block not found\", self.nodes[2].gettxoutproof, [txid_spent], \"00000000000000000000000000000000\")\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[2].gettxoutproof, [txid_spent], \"00000000000000000000000000000000\")\n         # We can get the proof if the transaction is unspent\n         assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_unspent])), [txid_unspent])\n         # We can get the proof if we provide a list of transactions and one of them is unspent. The ordering of the list should not matter.\n@@ -76,7 +76,7 @@ def run_test(self):\n         # We can always get a proof if we have a -txindex\n         assert_equal(self.nodes[2].verifytxoutproof(self.nodes[3].gettxoutproof([txid_spent])), [txid_spent])\n         # We can't get a proof if we specify transactions from different blocks\n-        assert_raises_jsonrpc(-5, \"Not all transactions found in specified or retrieved block\", self.nodes[2].gettxoutproof, [txid1, txid3])\n+        assert_raises_rpc_error(-5, \"Not all transactions found in specified or retrieved block\", self.nodes[2].gettxoutproof, [txid1, txid3])\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "085bdb568bdc6983dc6fd5a1af9af1ca331e5b81",
        "filename": "test/functional/mining.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mining.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/mining.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -15,7 +15,7 @@\n from test_framework.blocktools import create_coinbase\n from test_framework.mininode import CBlock\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_jsonrpc\n+from test_framework.util import assert_equal, assert_raises_rpc_error\n \n def b2x(b):\n     return b2a_hex(b).decode('ascii')\n@@ -69,7 +69,7 @@ def run_test(self):\n         assert_template(node, block, None)\n \n         self.log.info(\"submitblock: Test block decode failure\")\n-        assert_raises_jsonrpc(-22, \"Block decode failed\", node.submitblock, b2x(block.serialize()[:-15]))\n+        assert_raises_rpc_error(-22, \"Block decode failed\", node.submitblock, b2x(block.serialize()[:-15]))\n \n         self.log.info(\"getblocktemplate: Test bad input hash for coinbase transaction\")\n         bad_block = copy.deepcopy(block)\n@@ -78,10 +78,10 @@ def run_test(self):\n         assert_template(node, bad_block, 'bad-cb-missing')\n \n         self.log.info(\"submitblock: Test invalid coinbase transaction\")\n-        assert_raises_jsonrpc(-22, \"Block does not start with a coinbase\", node.submitblock, b2x(bad_block.serialize()))\n+        assert_raises_rpc_error(-22, \"Block does not start with a coinbase\", node.submitblock, b2x(bad_block.serialize()))\n \n         self.log.info(\"getblocktemplate: Test truncated final transaction\")\n-        assert_raises_jsonrpc(-22, \"Block decode failed\", node.getblocktemplate, {'data': b2x(block.serialize()[:-1]), 'mode': 'proposal'})\n+        assert_raises_rpc_error(-22, \"Block decode failed\", node.getblocktemplate, {'data': b2x(block.serialize()[:-1]), 'mode': 'proposal'})\n \n         self.log.info(\"getblocktemplate: Test duplicate transaction\")\n         bad_block = copy.deepcopy(block)\n@@ -108,7 +108,7 @@ def run_test(self):\n         bad_block_sn = bytearray(block.serialize())\n         assert_equal(bad_block_sn[TX_COUNT_OFFSET], 1)\n         bad_block_sn[TX_COUNT_OFFSET] += 1\n-        assert_raises_jsonrpc(-22, \"Block decode failed\", node.getblocktemplate, {'data': b2x(bad_block_sn), 'mode': 'proposal'})\n+        assert_raises_rpc_error(-22, \"Block decode failed\", node.getblocktemplate, {'data': b2x(bad_block_sn), 'mode': 'proposal'})\n \n         self.log.info(\"getblocktemplate: Test bad bits\")\n         bad_block = copy.deepcopy(block)"
      },
      {
        "sha": "6adcc1fd88289f6980c078507269f5a89e98c15e",
        "filename": "test/functional/multiwallet.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multiwallet.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -9,7 +9,7 @@\n import os\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_jsonrpc\n+from test_framework.util import assert_equal, assert_raises_rpc_error\n \n class MultiWalletTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -43,10 +43,10 @@ def run_test(self):\n         w1.generate(1)\n \n         # accessing invalid wallet fails\n-        assert_raises_jsonrpc(-18, \"Requested wallet does not exist or is not loaded\", wallet_bad.getwalletinfo)\n+        assert_raises_rpc_error(-18, \"Requested wallet does not exist or is not loaded\", wallet_bad.getwalletinfo)\n \n         # accessing wallet RPC without using wallet endpoint fails\n-        assert_raises_jsonrpc(-19, \"Wallet file not specified\", self.nodes[0].getwalletinfo)\n+        assert_raises_rpc_error(-19, \"Wallet file not specified\", self.nodes[0].getwalletinfo)\n \n         # check w1 wallet balance\n         w1_info = w1.getwalletinfo()"
      },
      {
        "sha": "61a5e1f2e9d4154132e75163017dc44c594e1320",
        "filename": "test/functional/net.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/net.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -12,7 +12,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    assert_raises_jsonrpc,\n+    assert_raises_rpc_error,\n     connect_nodes_bi,\n     p2p_port,\n )\n@@ -84,7 +84,7 @@ def _test_getaddednodeinfo(self):\n         assert_equal(len(added_nodes), 1)\n         assert_equal(added_nodes[0]['addednode'], ip_port)\n         # check that a non-existant node returns an error\n-        assert_raises_jsonrpc(-24, \"Node has not been added\",\n+        assert_raises_rpc_error(-24, \"Node has not been added\",\n                               self.nodes[0].getaddednodeinfo, '1.1.1.1')\n \n     def _test_getpeerinfo(self):"
      },
      {
        "sha": "91c4550653826253b949775bdd04807cffa532a1",
        "filename": "test/functional/nulldummy.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/nulldummy.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -71,7 +71,7 @@ def run_test(self):\n         self.log.info(\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n         test2tx = self.create_transaction(self.nodes[0], txid2, self.ms_address, 47)\n         trueDummy(test2tx)\n-        assert_raises_jsonrpc(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test2tx.serialize_with_witness()), True)\n+        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test2tx.serialize_with_witness()), True)\n \n         self.log.info(\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n         self.block_submit(self.nodes[0], [test2tx], False, True)\n@@ -80,14 +80,14 @@ def run_test(self):\n         test4tx = self.create_transaction(self.nodes[0], test2tx.hash, self.address, 46)\n         test6txs=[CTransaction(test4tx)]\n         trueDummy(test4tx)\n-        assert_raises_jsonrpc(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test4tx.serialize_with_witness()), True)\n+        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test4tx.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], [test4tx])\n \n         self.log.info(\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n         test5tx = self.create_transaction(self.nodes[0], txid3, self.wit_address, 48)\n         test6txs.append(CTransaction(test5tx))\n         test5tx.wit.vtxinwit[0].scriptWitness.stack[0] = b'\\x01'\n-        assert_raises_jsonrpc(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test5tx.serialize_with_witness()), True)\n+        assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test5tx.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], [test5tx], True)\n \n         self.log.info(\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")"
      },
      {
        "sha": "5b6429b410194d87a5c8ae76cf695d442cc3fad9",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -171,7 +171,7 @@ def run_test(self):\n         # Blocks 1-287 should be accepted, block 288 should be ignored because it's too far ahead\n         for x in all_blocks[:-1]:\n             self.nodes[0].getblock(x.hash)\n-        assert_raises_jsonrpc(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[-1].hash)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[-1].hash)\n \n         headers_message.headers.pop() # Ensure the last block is unrequested\n         white_node.send_message(headers_message) # Send headers leading to tip"
      },
      {
        "sha": "bb56db9b40f31758a96bc1605787cc019ec7aae2",
        "filename": "test/functional/prioritise_transaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/prioritise_transaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/prioritise_transaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/prioritise_transaction.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -101,7 +101,7 @@ def run_test(self):\n         tx_id = self.nodes[0].decoderawtransaction(tx_hex)[\"txid\"]\n \n         # This will raise an exception due to min relay fee not being met\n-        assert_raises_jsonrpc(-26, \"66: min relay fee not met\", self.nodes[0].sendrawtransaction, tx_hex)\n+        assert_raises_rpc_error(-26, \"66: min relay fee not met\", self.nodes[0].sendrawtransaction, tx_hex)\n         assert(tx_id not in self.nodes[0].getrawmempool())\n \n         # This is a less than 1000-byte transaction, so just set the fee"
      },
      {
        "sha": "1b0f0ba1cdaffac88c22e2488d2d1705410bc8ca",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -185,7 +185,7 @@ def reorg_test(self):\n \n     def reorg_back(self):\n         # Verify that a block on the old main chain fork has been pruned away\n-        assert_raises_jsonrpc(-1, \"Block not available (pruned data)\", self.nodes[2].getblock, self.forkhash)\n+        assert_raises_rpc_error(-1, \"Block not available (pruned data)\", self.nodes[2].getblock, self.forkhash)\n         self.log.info(\"Will need to redownload block %d\" % self.forkheight)\n \n         # Verify that we have enough history to reorg back to the fork point\n@@ -232,7 +232,7 @@ def manual_test(self, node_number, use_timestamp):\n         self.start_node(node_number)\n         node = self.nodes[node_number]\n         assert_equal(node.getblockcount(), 995)\n-        assert_raises_jsonrpc(-1, \"not in prune mode\", node.pruneblockchain, 500)\n+        assert_raises_rpc_error(-1, \"not in prune mode\", node.pruneblockchain, 500)\n \n         # now re-start in manual pruning mode\n         self.stop_node(node_number)\n@@ -265,14 +265,14 @@ def has_block(index):\n             return os.path.isfile(self.options.tmpdir + \"/node{}/regtest/blocks/blk{:05}.dat\".format(node_number, index))\n \n         # should not prune because chain tip of node 3 (995) < PruneAfterHeight (1000)\n-        assert_raises_jsonrpc(-1, \"Blockchain is too short for pruning\", node.pruneblockchain, height(500))\n+        assert_raises_rpc_error(-1, \"Blockchain is too short for pruning\", node.pruneblockchain, height(500))\n \n         # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n         node.generate(6)\n         assert_equal(node.getblockchaininfo()[\"blocks\"], 1001)\n \n         # negative heights should raise an exception\n-        assert_raises_jsonrpc(-8, \"Negative\", node.pruneblockchain, -10)\n+        assert_raises_rpc_error(-8, \"Negative\", node.pruneblockchain, -10)\n \n         # height=100 too low to prune first block file so this is a no-op\n         prune(100)"
      },
      {
        "sha": "ec9467eb445a0cb94517cc7522d47e7fe7aab1d9",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -48,7 +48,7 @@ def run_test(self):\n         rawtx   = self.nodes[2].signrawtransaction(rawtx)\n \n         # This will raise an exception since there are missing inputs\n-        assert_raises_jsonrpc(-25, \"Missing inputs\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n+        assert_raises_rpc_error(-25, \"Missing inputs\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n \n         #########################\n         # RAW TX MULTISIG TESTS #\n@@ -190,13 +190,13 @@ def run_test(self):\n         assert_equal(self.nodes[0].getrawtransaction(txHash, True)[\"hex\"], rawTxSigned['hex'])\n \n         # 6. invalid parameters - supply txid and string \"Flase\"\n-        assert_raises_jsonrpc(-3,\"Invalid type\", self.nodes[0].getrawtransaction, txHash, \"Flase\")\n+        assert_raises_rpc_error(-3,\"Invalid type\", self.nodes[0].getrawtransaction, txHash, \"Flase\")\n \n         # 7. invalid parameters - supply txid and empty array\n-        assert_raises_jsonrpc(-3,\"Invalid type\", self.nodes[0].getrawtransaction, txHash, [])\n+        assert_raises_rpc_error(-3,\"Invalid type\", self.nodes[0].getrawtransaction, txHash, [])\n \n         # 8. invalid parameters - supply txid and empty dict\n-        assert_raises_jsonrpc(-3,\"Invalid type\", self.nodes[0].getrawtransaction, txHash, {})\n+        assert_raises_rpc_error(-3,\"Invalid type\", self.nodes[0].getrawtransaction, txHash, {})\n \n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 1000}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n@@ -207,12 +207,12 @@ def run_test(self):\n         # 9. invalid parameters - sequence number out of range\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : -1}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n-        assert_raises_jsonrpc(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n+        assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n \n         # 10. invalid parameters - sequence number out of range\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967296}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n-        assert_raises_jsonrpc(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n+        assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n \n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967294}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }"
      },
      {
        "sha": "4ef10e6b3651618587ae74e1ce29c583cc3dcef0",
        "filename": "test/functional/replace-by-fee.py",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/replace-by-fee.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -136,17 +136,17 @@ def test_simple_doublespend(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception due to insufficient fee\n-        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n+        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n         # This will raise an exception due to transaction replacement being disabled\n-        assert_raises_jsonrpc(-26, \"txn-mempool-conflict\", self.nodes[1].sendrawtransaction, tx1b_hex, True)\n+        assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[1].sendrawtransaction, tx1b_hex, True)\n \n         # Extra 0.1 BTC fee\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(int(0.9*COIN), CScript([b'b']))]\n         tx1b_hex = txToHex(tx1b)\n         # Replacement still disabled even with \"enough fee\"\n-        assert_raises_jsonrpc(-26, \"txn-mempool-conflict\", self.nodes[1].sendrawtransaction, tx1b_hex, True)\n+        assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[1].sendrawtransaction, tx1b_hex, True)\n         # Works when enabled\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n \n@@ -189,7 +189,7 @@ def test_doublespend_chain(self):\n         dbl_tx_hex = txToHex(dbl_tx)\n \n         # This will raise an exception due to insufficient fee\n-        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n+        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n \n         # Accepted with sufficient fee\n         dbl_tx = CTransaction()\n@@ -250,7 +250,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n         dbl_tx.vout = [CTxOut(initial_nValue - fee*n, CScript([1]))]\n         dbl_tx_hex = txToHex(dbl_tx)\n         # This will raise an exception due to insufficient fee\n-        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n+        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n \n         # 1 BTC fee is enough\n         dbl_tx = CTransaction()\n@@ -278,7 +278,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n             dbl_tx.vout = [CTxOut(initial_nValue - 2*fee*n, CScript([1]))]\n             dbl_tx_hex = txToHex(dbl_tx)\n             # This will raise an exception\n-            assert_raises_jsonrpc(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n+            assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n \n             for tx in tree_txs:\n                 tx.rehash()\n@@ -302,7 +302,7 @@ def test_replacement_feeperkb(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception due to insufficient fee\n-        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n+        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n     def test_spends_of_conflicting_outputs(self):\n         \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n@@ -325,7 +325,7 @@ def test_spends_of_conflicting_outputs(self):\n         tx2_hex = txToHex(tx2)\n \n         # This will raise an exception\n-        assert_raises_jsonrpc(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n+        assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n \n         # Spend tx1a's output to test the indirect case.\n         tx1b = CTransaction()\n@@ -342,7 +342,7 @@ def test_spends_of_conflicting_outputs(self):\n         tx2_hex = txToHex(tx2)\n \n         # This will raise an exception\n-        assert_raises_jsonrpc(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n+        assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n \n     def test_new_unconfirmed_inputs(self):\n         \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n@@ -361,7 +361,7 @@ def test_new_unconfirmed_inputs(self):\n         tx2_hex = txToHex(tx2)\n \n         # This will raise an exception\n-        assert_raises_jsonrpc(-26, \"replacement-adds-unconfirmed\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n+        assert_raises_rpc_error(-26, \"replacement-adds-unconfirmed\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n \n     def test_too_many_replacements(self):\n         \"\"\"Replacements that evict too many transactions are rejected\"\"\"\n@@ -407,7 +407,7 @@ def test_too_many_replacements(self):\n         double_tx_hex = txToHex(double_tx)\n \n         # This will raise an exception\n-        assert_raises_jsonrpc(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, double_tx_hex, True)\n+        assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, double_tx_hex, True)\n \n         # If we remove an input, it should pass\n         double_tx = CTransaction()\n@@ -434,7 +434,7 @@ def test_opt_in(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception\n-        assert_raises_jsonrpc(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n+        assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n         tx1_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n \n@@ -452,7 +452,7 @@ def test_opt_in(self):\n         tx2b_hex = txToHex(tx2b)\n \n         # This will raise an exception\n-        assert_raises_jsonrpc(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx2b_hex, True)\n+        assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx2b_hex, True)\n \n         # Now create a new transaction that spends from tx1a and tx2a\n         # opt-in on one of the inputs\n@@ -504,7 +504,7 @@ def test_prioritised_transactions(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # Verify tx1b cannot replace tx1a.\n-        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n+        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n         # Use prioritisetransaction to set tx1a's fee to 0.\n         self.nodes[0].prioritisetransaction(txid=tx1a_txid, fee_delta=int(-0.1*COIN))\n@@ -531,7 +531,7 @@ def test_prioritised_transactions(self):\n         tx2b_hex = txToHex(tx2b)\n \n         # Verify tx2b cannot replace tx2a.\n-        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx2b_hex, True)\n+        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx2b_hex, True)\n \n         # Now prioritise tx2b to have a higher modified fee\n         self.nodes[0].prioritisetransaction(txid=tx2b.hash, fee_delta=int(0.1*COIN))"
      },
      {
        "sha": "d959bb4c3836466fa11e50fabc9da6f3d1cfc4d9",
        "filename": "test/functional/resendwallettransactions.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/resendwallettransactions.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -5,7 +5,7 @@\n \"\"\"Test resendwallettransactions RPC.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_jsonrpc\n+from test_framework.util import assert_equal, assert_raises_rpc_error\n \n class ResendWalletTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -14,7 +14,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         # Should raise RPC_WALLET_ERROR (-4) if walletbroadcast is disabled.\n-        assert_raises_jsonrpc(-4, \"Error: Wallet transaction broadcasting is disabled with -walletbroadcast\", self.nodes[0].resendwallettransactions)\n+        assert_raises_rpc_error(-4, \"Error: Wallet transaction broadcasting is disabled with -walletbroadcast\", self.nodes[0].resendwallettransactions)\n \n         # Should return an empty array if there aren't unconfirmed wallet transactions.\n         self.stop_node(0)"
      },
      {
        "sha": "0e8c3fa209ee82d73336ce2abda17c59f71dd55d",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -101,7 +101,7 @@ def run_test(self):\n \n         # Check that with invalid rpcallowip, we are denied\n         self.run_allowip_test([non_loopback_ip], non_loopback_ip, defaultport)\n-        assert_raises_jsonrpc(-342, \"non-JSON HTTP response with '403 Forbidden' from server\", self.run_allowip_test, ['1.1.1.1'], non_loopback_ip, defaultport)\n+        assert_raises_rpc_error(-342, \"non-JSON HTTP response with '403 Forbidden' from server\", self.run_allowip_test, ['1.1.1.1'], non_loopback_ip, defaultport)\n \n if __name__ == '__main__':\n     RPCBindTest().main()"
      },
      {
        "sha": "0fb0a62afd02be732abcdd87602c9d65b25f57db",
        "filename": "test/functional/rpcnamedargs.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/rpcnamedargs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/rpcnamedargs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcnamedargs.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -7,7 +7,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    assert_raises_jsonrpc,\n+    assert_raises_rpc_error,\n )\n \n class NamedArgumentTest(BitcoinTestFramework):\n@@ -19,7 +19,7 @@ def run_test(self):\n         h = node.help(command='getinfo')\n         assert(h.startswith('getinfo\\n'))\n \n-        assert_raises_jsonrpc(-8, 'Unknown named parameter', node.help, random='getinfo')\n+        assert_raises_rpc_error(-8, 'Unknown named parameter', node.help, random='getinfo')\n \n         h = node.getblockhash(height=0)\n         node.getblock(blockhash=h)"
      },
      {
        "sha": "7cd87e562698dbeaee19c822f49cc404a2081b01",
        "filename": "test/functional/segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/segwit.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -100,11 +100,11 @@ def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n         sync_blocks(self.nodes)\n \n     def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n-        assert_raises_jsonrpc(-26, error_msg, send_to_witness, 1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n+        assert_raises_rpc_error(-26, error_msg, send_to_witness, 1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n \n     def fail_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        assert_raises_jsonrpc(-1, \"CreateNewBlock: TestBlockValidity failed\", node.generate, 1)\n+        assert_raises_rpc_error(-1, \"CreateNewBlock: TestBlockValidity failed\", node.generate, 1)\n         sync_blocks(self.nodes)\n \n     def run_test(self):\n@@ -456,7 +456,7 @@ def run_test(self):\n         # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n         # note that no witness address should be returned by unsolvable addresses\n         for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address:\n-            assert_raises_jsonrpc(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n+            assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n \n         # addwitnessaddress should return a witness addresses even if keys are not in the wallet\n         self.nodes[0].addwitnessaddress(multisig_without_privkey_address)\n@@ -539,7 +539,7 @@ def run_test(self):\n         # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n         for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress:\n             # This will raise an exception\n-            assert_raises_jsonrpc(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n+            assert_raises_rpc_error(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n \n         # after importaddress it should pass addwitnessaddress\n         v = self.nodes[0].validateaddress(compressed_solvable_address[1])"
      },
      {
        "sha": "9a45d53cb85640e41c0542270148427294a03d4c",
        "filename": "test/functional/signrawtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/signrawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/signrawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/signrawtransactions.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -82,7 +82,7 @@ def script_verification_error_test(self):\n             assert_equal(decodedRawTx[\"vin\"][i][\"vout\"], inp[\"vout\"])\n \n         # Make sure decoderawtransaction throws if there is extra data\n-        assert_raises_jsonrpc(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, rawTx + \"00\")\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, rawTx + \"00\")\n \n         rawTxSigned = self.nodes[0].signrawtransaction(rawTx, scripts, privKeys)\n "
      },
      {
        "sha": "102c903018fedf239bae20be22451349539cf701",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -52,7 +52,7 @@ def assert_raises_message(exc, message, fun, *args, **kwds):\n     try:\n         fun(*args, **kwds)\n     except JSONRPCException:\n-        raise AssertionError(\"Use assert_raises_jsonrpc() to test RPC failures\")\n+        raise AssertionError(\"Use assert_raises_rpc_error() to test RPC failures\")\n     except exc as e:\n         if message is not None and message not in e.error['message']:\n             raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n@@ -85,7 +85,7 @@ def assert_raises_process_error(returncode, output, fun, *args, **kwds):\n     else:\n         raise AssertionError(\"No exception raised\")\n \n-def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n+def assert_raises_rpc_error(code, message, fun, *args, **kwds):\n     \"\"\"Run an RPC and verify that a specific JSONRPC exception code and message is raised.\n \n     Calls function `fun` with arguments `args` and `kwds`. Catches a JSONRPCException"
      },
      {
        "sha": "2ca01c7f0822eaa418ff0caababfd9af9c09eb1d",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -7,7 +7,7 @@\n import os\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (assert_equal, assert_raises_jsonrpc)\n+from test_framework.util import (assert_equal, assert_raises_rpc_error)\n \n \n def read_dump(file_name, addrs, hd_master_addr_old):\n@@ -106,7 +106,7 @@ def run_test (self):\n         assert_equal(found_addr_rsv, 90*2) \n \n         # Overwriting should fail\n-        assert_raises_jsonrpc(-8, \"already exists\", self.nodes[0].dumpwallet, tmpdir + \"/node0/wallet.unencrypted.dump\")\n+        assert_raises_rpc_error(-8, \"already exists\", self.nodes[0].dumpwallet, tmpdir + \"/node0/wallet.unencrypted.dump\")\n \n if __name__ == '__main__':\n     WalletDumpTest().main ()"
      },
      {
        "sha": "db62e1e30f489b18f573b08a135ccc5d7d321f04",
        "filename": "test/functional/wallet-encryption.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/wallet-encryption.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/wallet-encryption.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-encryption.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -9,7 +9,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    assert_raises_jsonrpc,\n+    assert_raises_rpc_error,\n )\n \n class WalletEncryptionTest(BitcoinTestFramework):\n@@ -32,28 +32,28 @@ def run_test(self):\n         self.start_node(0)\n \n         # Test that the wallet is encrypted\n-        assert_raises_jsonrpc(-13, \"Please enter the wallet passphrase with walletpassphrase first\", self.nodes[0].dumpprivkey, address)\n+        assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first\", self.nodes[0].dumpprivkey, address)\n \n         # Check that walletpassphrase works\n         self.nodes[0].walletpassphrase(passphrase, 2)\n         assert_equal(privkey, self.nodes[0].dumpprivkey(address))\n \n         # Check that the timeout is right\n         time.sleep(2)\n-        assert_raises_jsonrpc(-13, \"Please enter the wallet passphrase with walletpassphrase first\", self.nodes[0].dumpprivkey, address)\n+        assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first\", self.nodes[0].dumpprivkey, address)\n \n         # Test wrong passphrase\n-        assert_raises_jsonrpc(-14, \"wallet passphrase entered was incorrect\", self.nodes[0].walletpassphrase, passphrase + \"wrong\", 10)\n+        assert_raises_rpc_error(-14, \"wallet passphrase entered was incorrect\", self.nodes[0].walletpassphrase, passphrase + \"wrong\", 10)\n \n         # Test walletlock\n         self.nodes[0].walletpassphrase(passphrase, 84600)\n         assert_equal(privkey, self.nodes[0].dumpprivkey(address))\n         self.nodes[0].walletlock()\n-        assert_raises_jsonrpc(-13, \"Please enter the wallet passphrase with walletpassphrase first\", self.nodes[0].dumpprivkey, address)\n+        assert_raises_rpc_error(-13, \"Please enter the wallet passphrase with walletpassphrase first\", self.nodes[0].dumpprivkey, address)\n \n         # Test passphrase changes\n         self.nodes[0].walletpassphrasechange(passphrase, passphrase2)\n-        assert_raises_jsonrpc(-14, \"wallet passphrase entered was incorrect\", self.nodes[0].walletpassphrase, passphrase, 10)\n+        assert_raises_rpc_error(-14, \"wallet passphrase entered was incorrect\", self.nodes[0].walletpassphrase, passphrase, 10)\n         self.nodes[0].walletpassphrase(passphrase2, 10)\n         assert_equal(privkey, self.nodes[0].dumpprivkey(address))\n "
      },
      {
        "sha": "7d6b0b24b6f42d88715163809a898fb7f9ef53b0",
        "filename": "test/functional/wallet.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -102,7 +102,7 @@ def run_test(self):\n         unspent_0 = self.nodes[2].listunspent()[0]\n         unspent_0 = {\"txid\": unspent_0[\"txid\"], \"vout\": unspent_0[\"vout\"]}\n         self.nodes[2].lockunspent(False, [unspent_0])\n-        assert_raises_jsonrpc(-4, \"Insufficient funds\", self.nodes[2].sendtoaddress, self.nodes[2].getnewaddress(), 20)\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[2].sendtoaddress, self.nodes[2].getnewaddress(), 20)\n         assert_equal([unspent_0], self.nodes[2].listlockunspent())\n         self.nodes[2].lockunspent(True, [unspent_0])\n         assert_equal(len(self.nodes[2].listlockunspent()), 0)\n@@ -287,10 +287,10 @@ def run_test(self):\n         assert_equal(txObj['amount'], Decimal('-0.0001'))\n \n         # This will raise an exception because the amount type is wrong\n-        assert_raises_jsonrpc(-3, \"Invalid amount\", self.nodes[0].sendtoaddress, self.nodes[2].getnewaddress(), \"1f-4\")\n+        assert_raises_rpc_error(-3, \"Invalid amount\", self.nodes[0].sendtoaddress, self.nodes[2].getnewaddress(), \"1f-4\")\n \n         # This will raise an exception since generate does not accept a string\n-        assert_raises_jsonrpc(-1, \"not an integer\", self.nodes[0].generate, \"2\")\n+        assert_raises_rpc_error(-1, \"not an integer\", self.nodes[0].generate, \"2\")\n \n         # Import address and private key to check correct behavior of spendable unspents\n         # 1. Send some coins to generate new UTXO\n@@ -423,7 +423,7 @@ def run_test(self):\n \n         node0_balance = self.nodes[0].getbalance()\n         # With walletrejectlongchains we will not create the tx and store it in our wallet.\n-        assert_raises_jsonrpc(-4, \"Transaction has too long of a mempool chain\", self.nodes[0].sendtoaddress, sending_addr, node0_balance - Decimal('0.01'))\n+        assert_raises_rpc_error(-4, \"Transaction has too long of a mempool chain\", self.nodes[0].sendtoaddress, sending_addr, node0_balance - Decimal('0.01'))\n \n         # Verify nothing new in wallet\n         assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\",99999)))"
      },
      {
        "sha": "8cd622dc8ec3b7996140f2115f904a89e3a6639e",
        "filename": "test/functional/zapwallettxes.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d94fc336c47b5fd0f42217806faad1aa201b9d63/test/functional/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zapwallettxes.py?ref=d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "patch": "@@ -17,7 +17,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    assert_raises_jsonrpc,\n+    assert_raises_rpc_error,\n     wait_until,\n )\n \n@@ -72,7 +72,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)\n \n         # This will raise an exception because the unconfirmed transaction has been zapped\n-        assert_raises_jsonrpc(-5, 'Invalid or non-wallet transaction id', self.nodes[0].gettransaction, txid2)\n+        assert_raises_rpc_error(-5, 'Invalid or non-wallet transaction id', self.nodes[0].gettransaction, txid2)\n \n if __name__ == '__main__':\n     ZapWalletTXesTest().main()"
      }
    ]
  },
  {
    "sha": "fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZDc5ZWQ2YjIwMmVjODcyYWE3OTRiYTZhMjNkNGRmYzM3M2E5OGYx",
    "commit": {
      "author": {
        "name": "Tomas van der Wansem",
        "email": "tomas@tomasvdw.nl",
        "date": "2017-09-20T22:10:46Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T19:23:06Z"
      },
      "message": "Ensure backupwallet fails when attempting to backup to source file\n\nPrevious behaviour was to destroy the wallet (to zero-length)\n\nGithub-Pull: #11376\nRebased-From: 5d465e396249a0e2cc60b16984a2bdbe4c8993c3",
      "tree": {
        "sha": "9a8e2ce5deba2c1ba8dd4c0da0145275624d80cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a8e2ce5deba2c1ba8dd4c0da0145275624d80cc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/comments",
    "author": {
      "login": "tomasvdw",
      "id": 534388,
      "node_id": "MDQ6VXNlcjUzNDM4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/534388?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomasvdw",
      "html_url": "https://github.com/tomasvdw",
      "followers_url": "https://api.github.com/users/tomasvdw/followers",
      "following_url": "https://api.github.com/users/tomasvdw/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomasvdw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomasvdw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomasvdw/subscriptions",
      "organizations_url": "https://api.github.com/users/tomasvdw/orgs",
      "repos_url": "https://api.github.com/users/tomasvdw/repos",
      "events_url": "https://api.github.com/users/tomasvdw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomasvdw/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d94fc336c47b5fd0f42217806faad1aa201b9d63",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d94fc336c47b5fd0f42217806faad1aa201b9d63"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 16,
      "deletions": 1
    },
    "files": [
      {
        "sha": "8c23d9c0722d66df5feba6d1242abc62aac9db83",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
        "patch": "@@ -673,6 +673,11 @@ bool CWalletDBWrapper::Backup(const std::string& strDest)\n                     pathDest /= strFile;\n \n                 try {\n+                    if (fs::equivalent(pathSrc, pathDest)) {\n+                        LogPrintf(\"cannot backup to wallet source file %s\\n\", pathDest.string());\n+                        return false;\n+                    }\n+\n                     fs::copy_file(pathSrc, pathDest, fs::copy_option::overwrite_if_exists);\n                     LogPrintf(\"copied %s to %s\\n\", strFile, pathDest.string());\n                     return true;"
      },
      {
        "sha": "6f3cfe9557042181ea3c73e0e30d9c06fc550197",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
        "patch": "@@ -45,7 +45,7 @@ class CDBEnv\n     void Reset();\n \n     void MakeMock();\n-    bool IsMock() { return fMockDb; }\n+    bool IsMock() const { return fMockDb; }\n \n     /**\n      * Verify that database file strFile is OK. If it is not,"
      },
      {
        "sha": "85a149793e730fcaa072b80ee756d2b964ddf7b2",
        "filename": "test/functional/walletbackup.py",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/test/functional/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1/test/functional/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/walletbackup.py?ref=fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
        "patch": "@@ -190,6 +190,16 @@ def run_test(self):\n         assert_equal(self.nodes[1].getbalance(), balance1)\n         assert_equal(self.nodes[2].getbalance(), balance2)\n \n+        # Backup to source wallet file must fail\n+        sourcePaths = [\n+            tmpdir + \"/node0/regtest/wallet.dat\",\n+            tmpdir + \"/node0/./regtest/wallet.dat\",\n+            tmpdir + \"/node0/regtest/\",\n+            tmpdir + \"/node0/regtest\"]\n+\n+        for sourcePath in sourcePaths:\n+            assert_raises_rpc_error(-4, \"backup failed\", self.nodes[0].backupwallet, sourcePath)\n+\n \n if __name__ == '__main__':\n     WalletBackupTest().main()"
      }
    ]
  },
  {
    "sha": "de7053f1141756158c2107bcba376401b4cc94e9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTcwNTNmMTE0MTc1NjE1OGMyMTA3YmNiYTM3NjQwMWI0Y2M5NGU5",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-12T22:14:46Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T19:23:06Z"
      },
      "message": "[wallet] Fix leak in CDB constructor\n\nNow using a std::unique_ptr, the Db instance is correctly released\nwhen CDB initialization fails.\nThe internal CDB state and mapFileUseCount are only mutated when\nthe CDB initialization succeeds.\n\nGithub-Pull: #11492\nRebased-From: 7104de8b1f3a31d3a60009b5dc376adbedac6a9c",
      "tree": {
        "sha": "6b248c20036e2f7aa2bc8015b36f428b3ae9955a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b248c20036e2f7aa2bc8015b36f428b3ae9955a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de7053f1141756158c2107bcba376401b4cc94e9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de7053f1141756158c2107bcba376401b4cc94e9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de7053f1141756158c2107bcba376401b4cc94e9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de7053f1141756158c2107bcba376401b4cc94e9/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd79ed6b202ec872aa794ba6a23d4dfc373a98f1"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 16,
      "deletions": 18
    },
    "files": [
      {
        "sha": "f5f96768b074bd647cc0358bcf9fe70c4a5fa12d",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 18,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de7053f1141756158c2107bcba376401b4cc94e9/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de7053f1141756158c2107bcba376401b4cc94e9/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=de7053f1141756158c2107bcba376401b4cc94e9",
        "patch": "@@ -379,45 +379,43 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n         if (!env->Open(GetDataDir()))\n             throw std::runtime_error(\"CDB: Failed to open database environment.\");\n \n-        strFile = strFilename;\n-        ++env->mapFileUseCount[strFile];\n-        pdb = env->mapDb[strFile];\n+        pdb = env->mapDb[strFilename];\n         if (pdb == nullptr) {\n             int ret;\n-            pdb = new Db(env->dbenv, 0);\n+            std::unique_ptr<Db> pdb_temp(new Db(env->dbenv, 0));\n \n             bool fMockDb = env->IsMock();\n             if (fMockDb) {\n-                DbMpoolFile* mpf = pdb->get_mpf();\n+                DbMpoolFile* mpf = pdb_temp->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n-                if (ret != 0)\n-                    throw std::runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n+                if (ret != 0) {\n+                    throw std::runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFilename));\n+                }\n             }\n \n-            ret = pdb->open(nullptr,                               // Txn pointer\n-                            fMockDb ? nullptr : strFile.c_str(),   // Filename\n-                            fMockDb ? strFile.c_str() : \"main\", // Logical db name\n-                            DB_BTREE,                           // Database type\n-                            nFlags,                             // Flags\n+            ret = pdb_temp->open(nullptr,                             // Txn pointer\n+                            fMockDb ? nullptr : strFilename.c_str(),  // Filename\n+                            fMockDb ? strFilename.c_str() : \"main\",   // Logical db name\n+                            DB_BTREE,                                 // Database type\n+                            nFlags,                                   // Flags\n                             0);\n \n             if (ret != 0) {\n-                delete pdb;\n-                pdb = nullptr;\n-                --env->mapFileUseCount[strFile];\n-                strFile = \"\";\n                 throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n             }\n \n+            pdb = pdb_temp.release();\n+            env->mapDb[strFilename] = pdb;\n+\n             if (fCreate && !Exists(std::string(\"version\"))) {\n                 bool fTmp = fReadOnly;\n                 fReadOnly = false;\n                 WriteVersion(CLIENT_VERSION);\n                 fReadOnly = fTmp;\n             }\n-\n-            env->mapDb[strFile] = pdb;\n         }\n+        ++env->mapFileUseCount[strFilename];\n+        strFile = strFilename;\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "9c8006dc332139069d798f39406ec67186ecb311",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YzgwMDZkYzMzMjEzOTA2OWQ3OThmMzk0MDZlYzY3MTg2ZWNiMzEx",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-10-10T19:27:26Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T19:23:06Z"
      },
      "message": "Avoid opening copied wallet databases simultaneously\n\nMake sure wallet databases have unique fileids. If they don't, throw an error.\nBDB caches do not work properly when more than one open database has the same\nfileid, because values written to one database may show up in reads to other\ndatabases.\n\nBitcoin will never create different databases with the same fileid, but users\ncan create them by manually copying database files.\n\nBDB caching bug was reported by Chris Moore <dooglus@gmail.com>\nhttps://github.com/bitcoin/bitcoin/issues/11429\n\nFixes #11429\n\nGithub-Pull: #11476\nRebased-From: 478a89c1ef79a75275d1b508122c06eee9386b2d",
      "tree": {
        "sha": "84b4f3330847e5bb0d1a5ddcb1827123a0f6caec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84b4f3330847e5bb0d1a5ddcb1827123a0f6caec"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c8006dc332139069d798f39406ec67186ecb311",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c8006dc332139069d798f39406ec67186ecb311",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c8006dc332139069d798f39406ec67186ecb311",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c8006dc332139069d798f39406ec67186ecb311/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de7053f1141756158c2107bcba376401b4cc94e9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de7053f1141756158c2107bcba376401b4cc94e9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de7053f1141756158c2107bcba376401b4cc94e9"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 41,
      "deletions": 0
    },
    "files": [
      {
        "sha": "fb6e57607475e68eaa94c2f48ccf86aa8040781a",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c8006dc332139069d798f39406ec67186ecb311/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c8006dc332139069d798f39406ec67186ecb311/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=9c8006dc332139069d798f39406ec67186ecb311",
        "patch": "@@ -20,6 +20,40 @@\n \n #include <boost/thread.hpp>\n \n+namespace {\n+//! Make sure database has a unique fileid within the environment. If it\n+//! doesn't, throw an error. BDB caches do not work properly when more than one\n+//! open database has the same fileid (values written to one database may show\n+//! up in reads to other databases).\n+//!\n+//! BerkeleyDB generates unique fileids by default\n+//! (https://docs.oracle.com/cd/E17275_01/html/programmer_reference/program_copy.html),\n+//! so bitcoin should never create different databases with the same fileid, but\n+//! this error can be triggered if users manually copy database files.\n+void CheckUniqueFileid(const CDBEnv& env, const std::string& filename, Db& db)\n+{\n+    if (env.IsMock()) return;\n+\n+    u_int8_t fileid[DB_FILE_ID_LEN];\n+    int ret = db.get_mpf()->get_fileid(fileid);\n+    if (ret != 0) {\n+        throw std::runtime_error(strprintf(\"CDB: Can't open database %s (get_fileid failed with %d)\", filename, ret));\n+    }\n+\n+    for (const auto& item : env.mapDb) {\n+        u_int8_t item_fileid[DB_FILE_ID_LEN];\n+        if (item.second && item.second->get_mpf()->get_fileid(item_fileid) == 0 &&\n+            memcmp(fileid, item_fileid, sizeof(fileid)) == 0) {\n+            const char* item_filename = nullptr;\n+            item.second->get_dbname(&item_filename, nullptr);\n+            throw std::runtime_error(strprintf(\"CDB: Can't open database %s (duplicates fileid %s from %s)\", filename,\n+                HexStr(std::begin(item_fileid), std::end(item_fileid)),\n+                item_filename ? item_filename : \"(unknown database)\"));\n+        }\n+    }\n+}\n+} // namespace\n+\n //\n // CDB\n //\n@@ -403,6 +437,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n             if (ret != 0) {\n                 throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n             }\n+            CheckUniqueFileid(*env, strFilename, *pdb_temp);\n \n             pdb = pdb_temp.release();\n             env->mapDb[strFilename] = pdb;"
      },
      {
        "sha": "ba6b659ddcfd9334f5c0885f7b6915a4535a2bec",
        "filename": "test/functional/multiwallet.py",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c8006dc332139069d798f39406ec67186ecb311/test/functional/multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c8006dc332139069d798f39406ec67186ecb311/test/functional/multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multiwallet.py?ref=9c8006dc332139069d798f39406ec67186ecb311",
        "patch": "@@ -7,6 +7,7 @@\n Verify that a bitcoind node can load multiple wallet files\n \"\"\"\n import os\n+import shutil\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error\n@@ -29,6 +30,11 @@ def run_test(self):\n         os.mkdir(os.path.join(self.options.tmpdir, 'node0', 'regtest', 'w11'))\n         self.assert_start_raises_init_error(0, ['-wallet=w11'], 'Error loading wallet w11. -wallet filename must be a regular file.')\n \n+        # should not initialize if one wallet is a copy of another\n+        shutil.copyfile(os.path.join(self.options.tmpdir, 'node0', 'regtest', 'w2'),\n+                        os.path.join(self.options.tmpdir, 'node0', 'regtest', 'w22'))\n+        self.assert_start_raises_init_error(0, ['-wallet=w2', '-wallet=w22'], 'duplicates fileid')\n+\n         # should not initialize if wallet file is a symlink\n         os.symlink(os.path.join(self.options.tmpdir, 'node0', 'regtest', 'w1'), os.path.join(self.options.tmpdir, 'node0', 'regtest', 'w12'))\n         self.assert_start_raises_init_error(0, ['-wallet=w12'], 'Error loading wallet w12. -wallet filename must be a regular file.')"
      }
    ]
  },
  {
    "sha": "f3457d0e83c408770eeabb002f569e22c9832c1b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzQ1N2QwZTgzYzQwODc3MGVlYWJiMDAyZjU2OWUyMmM5ODMyYzFi",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-10-09T22:04:45Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T19:23:06Z"
      },
      "message": "qa: Make tmpdir option an absolute path\n\nThis should fix issues with the multiwallet test and symlinks\nwhen the tmpdir is a relative path.\n\nRather than fixing os.symlink to work with paths relative to a\ndirectory descriptor, which does not work on Windows, normalize\nthe path instead.\n\nGithub-Pull: #11472\nRebased-From: fa9de370b17297d6dd542da627c8dd2b31aec340",
      "tree": {
        "sha": "6e653cb243fadda7665928ca1e0364212fd04a06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e653cb243fadda7665928ca1e0364212fd04a06"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3457d0e83c408770eeabb002f569e22c9832c1b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3457d0e83c408770eeabb002f569e22c9832c1b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3457d0e83c408770eeabb002f569e22c9832c1b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3457d0e83c408770eeabb002f569e22c9832c1b/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c8006dc332139069d798f39406ec67186ecb311",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c8006dc332139069d798f39406ec67186ecb311",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c8006dc332139069d798f39406ec67186ecb311"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 3,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7aabdd9c007c56fb45846213c6067ef801cdc157",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3457d0e83c408770eeabb002f569e22c9832c1b/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3457d0e83c408770eeabb002f569e22c9832c1b/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=f3457d0e83c408770eeabb002f569e22c9832c1b",
        "patch": "@@ -102,8 +102,11 @@ def main(self):\n \n         check_json_precision()\n \n+        self.options.cachedir = os.path.abspath(self.options.cachedir)\n+\n         # Set up temp directory and start logging\n         if self.options.tmpdir:\n+            self.options.tmpdir = os.path.abspath(self.options.tmpdir)\n             os.makedirs(self.options.tmpdir, exist_ok=False)\n         else:\n             self.options.tmpdir = tempfile.mkdtemp(prefix=\"test\")"
      }
    ]
  },
  {
    "sha": "41088795dd9a1c90bb379b2d5237d88ae8889c90",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MTA4ODc5NWRkOWExYzkwYmIzNzliMmQ1MjM3ZDg4YWU4ODg5Yzkw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-10-11T20:14:49Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-01T19:23:06Z"
      },
      "message": "qa: Remove never used return value of sync_with_ping\n\nGithub-Pull: #11472\nRebased-From: fafa0039708e15d1067be091b2bfc10195afa480",
      "tree": {
        "sha": "118bf80a3a71222f2dba01e594ce834bbd0cf17e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/118bf80a3a71222f2dba01e594ce834bbd0cf17e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41088795dd9a1c90bb379b2d5237d88ae8889c90",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41088795dd9a1c90bb379b2d5237d88ae8889c90",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/41088795dd9a1c90bb379b2d5237d88ae8889c90",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41088795dd9a1c90bb379b2d5237d88ae8889c90/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3457d0e83c408770eeabb002f569e22c9832c1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3457d0e83c408770eeabb002f569e22c9832c1b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3457d0e83c408770eeabb002f569e22c9832c1b"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 6,
      "deletions": 4
    },
    "files": [
      {
        "sha": "6c7e6a22ec9cc540dc68f5bbee4e1beee18c6e6b",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41088795dd9a1c90bb379b2d5237d88ae8889c90/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41088795dd9a1c90bb379b2d5237d88ae8889c90/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=41088795dd9a1c90bb379b2d5237d88ae8889c90",
        "patch": "@@ -103,7 +103,8 @@ def run_test(self):\n         test_node.send_message(msg_block(blocks_h2[0]))\n         white_node.send_message(msg_block(blocks_h2[1]))\n \n-        [ x.sync_with_ping() for x in [test_node, white_node] ]\n+        for x in [test_node, white_node]:\n+            x.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         assert_equal(self.nodes[1].getblockcount(), 2)\n         self.log.info(\"First height 2 block accepted by both nodes\")\n@@ -116,7 +117,8 @@ def run_test(self):\n         test_node.send_message(msg_block(blocks_h2f[0]))\n         white_node.send_message(msg_block(blocks_h2f[1]))\n \n-        [ x.sync_with_ping() for x in [test_node, white_node] ]\n+        for x in [test_node, white_node]:\n+            x.sync_with_ping()\n         for x in self.nodes[0].getchaintips():\n             if x['hash'] == blocks_h2f[0].hash:\n                 assert_equal(x['status'], \"headers-only\")\n@@ -135,7 +137,8 @@ def run_test(self):\n         test_node.send_message(msg_block(blocks_h3[0]))\n         white_node.send_message(msg_block(blocks_h3[1]))\n \n-        [ x.sync_with_ping() for x in [test_node, white_node] ]\n+        for x in [test_node, white_node]:\n+            x.sync_with_ping()\n         # Since the earlier block was not processed by node0, the new block\n         # can't be fully validated.\n         for x in self.nodes[0].getchaintips():"
      },
      {
        "sha": "dc8731066b27740312a69ae4babe15c0dbf85919",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41088795dd9a1c90bb379b2d5237d88ae8889c90/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41088795dd9a1c90bb379b2d5237d88ae8889c90/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=41088795dd9a1c90bb379b2d5237d88ae8889c90",
        "patch": "@@ -1622,7 +1622,6 @@ def sync_with_ping(self, timeout=60):\n         test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n         self.ping_counter += 1\n-        return True\n \n # The actual NodeConn class\n # This class provides an interface for a p2p connection to a specified node"
      }
    ]
  },
  {
    "sha": "da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYTQ5MDhjM2EwNTY1OTg0NmRhZTgxYjhkMGJkNzNhMDRmN2VkN2M5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-05-07T18:10:19Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:08:43Z"
      },
      "message": "Allow setting nMinimumChainWork on command line\n\nGithub-Pull: #10357\nRebased-From: 0311836f6927aec4ba5687ea12af35df3c509682",
      "tree": {
        "sha": "c3c0269c5244bb2bffd2459417c9ef34cdb77f3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c3c0269c5244bb2bffd2459417c9ef34cdb77f3c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "41088795dd9a1c90bb379b2d5237d88ae8889c90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41088795dd9a1c90bb379b2d5237d88ae8889c90",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/41088795dd9a1c90bb379b2d5237d88ae8889c90"
      }
    ],
    "stats": {
      "total": 73,
      "additions": 68,
      "deletions": 5
    },
    "files": [
      {
        "sha": "c9bb827f82006cd99ea1e334578ada1e259b3302",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -362,6 +362,9 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n+    if (showDebug) {\n+        strUsage += HelpMessageOpt(\"-minimumchainwork=<hex>\", strprintf(\"Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)\", defaultChainParams->GetConsensus().nMinimumChainWork.GetHex(), testnetChainParams->GetConsensus().nMinimumChainWork.GetHex()));\n+    }\n     strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n@@ -979,6 +982,20 @@ bool AppInitParameterInteraction()\n     else\n         LogPrintf(\"Validating signatures for all blocks.\\n\");\n \n+    if (gArgs.IsArgSet(\"-minimumchainwork\")) {\n+        const std::string minChainWorkStr = gArgs.GetArg(\"-minimumchainwork\", \"\");\n+        if (!IsHexNumber(minChainWorkStr)) {\n+            return InitError(strprintf(\"Invalid non-hex (%s) minimum chain work value specified\", minChainWorkStr));\n+        }\n+        nMinimumChainWork = UintToArith256(uint256S(minChainWorkStr));\n+    } else {\n+        nMinimumChainWork = UintToArith256(chainparams.GetConsensus().nMinimumChainWork);\n+    }\n+    LogPrintf(\"Setting nMinimumChainWork=%s\\n\", nMinimumChainWork.GetHex());\n+    if (nMinimumChainWork < UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {\n+        LogPrintf(\"Warning: nMinimumChainWork set below default value of %s\\n\", chainparams.GetConsensus().nMinimumChainWork.GetHex());\n+    }\n+\n     // mempool limits\n     int64_t nMempoolSizeMax = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     int64_t nMempoolSizeMin = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40;"
      },
      {
        "sha": "5f117dea7ebe871bff2647c68523613bf3c862a5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -466,7 +466,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < UintToArith256(consensusParams.nMinimumChainWork)) {\n+    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }"
      },
      {
        "sha": "6ec544290daa534879c4ab7ec5c9ebb3b0af57ba",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -253,6 +253,31 @@ BOOST_AUTO_TEST_CASE(util_IsHex)\n     BOOST_CHECK(!IsHex(\"0x0000\"));\n }\n \n+BOOST_AUTO_TEST_CASE(util_IsHexNumber)\n+{\n+    BOOST_CHECK(IsHexNumber(\"0x0\"));\n+    BOOST_CHECK(IsHexNumber(\"0\"));\n+    BOOST_CHECK(IsHexNumber(\"0x10\"));\n+    BOOST_CHECK(IsHexNumber(\"10\"));\n+    BOOST_CHECK(IsHexNumber(\"0xff\"));\n+    BOOST_CHECK(IsHexNumber(\"ff\"));\n+    BOOST_CHECK(IsHexNumber(\"0xFfa\"));\n+    BOOST_CHECK(IsHexNumber(\"Ffa\"));\n+    BOOST_CHECK(IsHexNumber(\"0x00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n+    BOOST_CHECK(IsHexNumber(\"00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n+\n+    BOOST_CHECK(!IsHexNumber(\"\"));   // empty string not allowed\n+    BOOST_CHECK(!IsHexNumber(\"0x\")); // empty string after prefix not allowed\n+    BOOST_CHECK(!IsHexNumber(\"0x0 \")); // no spaces at end,\n+    BOOST_CHECK(!IsHexNumber(\" 0x0\")); // or beginning,\n+    BOOST_CHECK(!IsHexNumber(\"0x 0\")); // or middle,\n+    BOOST_CHECK(!IsHexNumber(\" \"));    // etc.\n+    BOOST_CHECK(!IsHexNumber(\"0x0ga\")); // invalid character\n+    BOOST_CHECK(!IsHexNumber(\"x0\"));    // broken prefix\n+    BOOST_CHECK(!IsHexNumber(\"0x0x00\")); // two prefixes not allowed\n+\n+}\n+\n BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n {\n     SeedInsecureRand(true);"
      },
      {
        "sha": "741680e93f79609351925af29edece852483dc0a",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -65,6 +65,19 @@ bool IsHex(const std::string& str)\n     return (str.size() > 0) && (str.size()%2 == 0);\n }\n \n+bool IsHexNumber(const std::string& str)\n+{\n+    size_t starting_location = 0;\n+    if (str.size() > 2 && *str.begin() == '0' && *(str.begin()+1) == 'x') {\n+        starting_location = 2;\n+    }\n+    for (auto c : str.substr(starting_location)) {\n+        if (HexDigit(c) < 0) return false;\n+    }\n+    // Return false for empty string or \"0x\".\n+    return (str.size() > starting_location);\n+}\n+\n std::vector<unsigned char> ParseHex(const char* psz)\n {\n     // convert hex dump to vector"
      },
      {
        "sha": "192f33fb290e037d0fc5a692f35c7187dca536ba",
        "filename": "src/utilstrencodings.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/utilstrencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/utilstrencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.h?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -38,7 +38,13 @@ std::string SanitizeString(const std::string& str, int rule = SAFE_CHARS_DEFAULT\n std::vector<unsigned char> ParseHex(const char* psz);\n std::vector<unsigned char> ParseHex(const std::string& str);\n signed char HexDigit(char c);\n+/* Returns true if each character in str is a hex character, and has an even\n+ * number of hex digits.*/\n bool IsHex(const std::string& str);\n+/**\n+* Return true if the string is a hex number, optionally prefixed with \"0x\"\n+*/\n+bool IsHexNumber(const std::string& str);\n std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = nullptr);\n std::string DecodeBase64(const std::string& str);\n std::string EncodeBase64(const unsigned char* pch, size_t len);"
      },
      {
        "sha": "76b8401f1ba597d36bf4da93f440140ba55524bf",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -80,6 +80,7 @@ int64_t nMaxTipAge = DEFAULT_MAX_TIP_AGE;\n bool fEnableReplacement = DEFAULT_ENABLE_REPLACEMENT;\n \n uint256 hashAssumeValid;\n+arith_uint256 nMinimumChainWork;\n \n CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;\n@@ -1032,8 +1033,6 @@ CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n \n bool IsInitialBlockDownload()\n {\n-    const CChainParams& chainParams = Params();\n-\n     // Once this function has returned false, it must remain false.\n     static std::atomic<bool> latchToFalse{false};\n     // Optimization: pre-test latch before taking the lock.\n@@ -1047,7 +1046,7 @@ bool IsInitialBlockDownload()\n         return true;\n     if (chainActive.Tip() == nullptr)\n         return true;\n-    if (chainActive.Tip()->nChainWork < UintToArith256(chainParams.GetConsensus().nMinimumChainWork))\n+    if (chainActive.Tip()->nChainWork < nMinimumChainWork)\n         return true;\n     if (chainActive.Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))\n         return true;\n@@ -1664,7 +1663,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         if (it != mapBlockIndex.end()) {\n             if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n-                pindexBestHeader->nChainWork >= UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {\n+                pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n                 // The equivalent time check discourages hash power from extorting the network via DOS attack\n                 //  into accepting an invalid block through telling users they must manually set assumevalid."
      },
      {
        "sha": "f3d88d318090b2db3b5e093256ac9e6f447cda5f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da4908c3a05659846dae81b8d0bd73a04f7ed7c9/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "patch": "@@ -186,6 +186,9 @@ extern bool fEnableReplacement;\n /** Block hash whose ancestors we will assume to have valid scripts without checking them. */\n extern uint256 hashAssumeValid;\n \n+/** Minimum work we will assume exists on some valid chain. */\n+extern arith_uint256 nMinimumChainWork;\n+\n /** Best header we've seen so far (used for getheaders queries' starting points). */\n extern CBlockIndex *pindexBestHeader;\n "
      }
    ]
  },
  {
    "sha": "0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTlkMDRiZjBhOTQ2NWQwODVkZjFmOGM4ODU4Y2Y0MjdjNmM5N2Jh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-05-08T13:59:00Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:08:50Z"
      },
      "message": "[qa] Test nMinimumChainWork\n\nNodes don't consider themselves out of \"initial block download\" until\ntheir active chain has more work than nMinimumChainWork.\n\nWhile in initial block download, nodes won't relay blocks to their\npeers, so test that this parameter functions as intended by verifying\nthat block relay only succeeds past a given node once its\nnMinimumChainWork has been exceeded.\n\nGithub-Pull: #10357\nRebased-From: eac64bb7a3b6aba747403b23b3b1d3609843f8db",
      "tree": {
        "sha": "019a9326821f535edc1bda5955e6c6830ed6925d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/019a9326821f535edc1bda5955e6c6830ed6925d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da4908c3a05659846dae81b8d0bd73a04f7ed7c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/da4908c3a05659846dae81b8d0bd73a04f7ed7c9"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 82,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c7579d2548e4642ffc65c07dcc000f55a39825d0",
        "filename": "test/functional/minchainwork.py",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba/test/functional/minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba/test/functional/minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/minchainwork.py?ref=0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
        "patch": "@@ -0,0 +1,81 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test logic for setting nMinimumChainWork on command line.\n+\n+Nodes don't consider themselves out of \"initial block download\" until\n+their active chain has more work than nMinimumChainWork.\n+\n+Nodes don't download blocks from a peer unless the peer's best known block\n+has more work than nMinimumChainWork.\n+\n+While in initial block download, nodes won't relay blocks to their peers, so\n+test that this parameter functions as intended by verifying that block relay\n+only succeeds past a given node once its nMinimumChainWork has been exceeded.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import sync_blocks, connect_nodes, assert_equal\n+\n+# 2 hashes required per regtest block (with no difficulty adjustment)\n+REGTEST_WORK_PER_BLOCK = 2\n+\n+class MinimumChainWorkTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        self.extra_args = [[], [\"-minimumchainwork=0x65\"], [\"-minimumchainwork=0x65\"]]\n+        self.node_min_work = [0, 101, 101]\n+\n+    def setup_network(self):\n+        # This test relies on the chain setup being:\n+        # node0 <- node1 <- node2\n+        # Before leaving IBD, nodes prefer to download blocks from outbound\n+        # peers, so ensure that we're mining on an outbound peer and testing\n+        # block relay to inbound peers.\n+        self.setup_nodes()\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i+1], i)\n+\n+    def run_test(self):\n+        # Start building a chain on node0.  node2 shouldn't be able to sync until node1's\n+        # minchainwork is exceeded\n+        starting_chain_work = REGTEST_WORK_PER_BLOCK # Genesis block's work\n+        self.log.info(\"Testing relay across node %d (minChainWork = %d)\", 1, self.node_min_work[1])\n+\n+        starting_blockcount = self.nodes[2].getblockcount()\n+\n+        num_blocks_to_generate = int((self.node_min_work[1] - starting_chain_work) / REGTEST_WORK_PER_BLOCK)\n+        self.log.info(\"Generating %d blocks on node0\", num_blocks_to_generate)\n+        hashes = self.nodes[0].generate(num_blocks_to_generate)\n+\n+        self.log.info(\"Node0 current chain work: %s\", self.nodes[0].getblockheader(hashes[-1])['chainwork'])\n+\n+        # Sleep a few seconds and verify that node2 didn't get any new blocks\n+        # or headers.  We sleep, rather than sync_blocks(node0, node1) because\n+        # it's reasonable either way for node1 to get the blocks, or not get\n+        # them (since they're below node1's minchainwork).\n+        time.sleep(3)\n+\n+        self.log.info(\"Verifying node 2 has no more blocks than before\")\n+        self.log.info(\"Blockcounts: %s\", [n.getblockcount() for n in self.nodes])\n+        # Node2 shouldn't have any new headers yet, because node1 should not\n+        # have relayed anything.\n+        assert_equal(len(self.nodes[2].getchaintips()), 1)\n+        assert_equal(self.nodes[2].getchaintips()[0]['height'], 0)\n+\n+        assert self.nodes[1].getbestblockhash() != self.nodes[0].getbestblockhash()\n+        assert_equal(self.nodes[2].getblockcount(), starting_blockcount)\n+\n+        self.log.info(\"Generating one more block\")\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Verifying nodes are all synced\")\n+        self.sync_all()\n+        self.log.info(\"Blockcounts: %s\", [n.getblockcount() for n in self.nodes])\n+\n+if __name__ == '__main__':\n+    MinimumChainWorkTest().main()"
      },
      {
        "sha": "714a907ee8da9c4ad58baf0b9b192a09ac0f5b58",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
        "patch": "@@ -121,6 +121,7 @@\n     'bip65-cltv-p2p.py',\n     'uptime.py',\n     'resendwallettransactions.py',\n+    'minchainwork.py',\n ]\n \n EXTENDED_SCRIPTS = ["
      }
    ]
  },
  {
    "sha": "3acec3878133c52f4f3a594baf1dcbd6575244bb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYWNlYzM4NzgxMzNjNTJmNGYzYTU5NGJhZjFkY2JkNjU3NTI0NGJi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-06T18:11:43Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:09:00Z"
      },
      "message": "Don't process unrequested, low-work blocks\n\nA peer could try to waste our resources by sending us unrequested blocks with\nlow work, eg to fill up our disk.  Since\ne2652002b6011f793185d473f87f1730c625593b we no longer request blocks until we\nknow we're on a chain with more than nMinimumChainWork (our anti-DoS\nthreshold), but we would still process unrequested blocks that had more work\nthan our tip.  This commit fixes that behavior.\n\nGithub-Pull: #11458\nRebased-From: ce8cd7a7da9174ab151172fc0ce97b5164637cf3",
      "tree": {
        "sha": "701f01e965031ed46f2735b447d46ce91c29b6bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/701f01e965031ed46f2735b447d46ce91c29b6bf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3acec3878133c52f4f3a594baf1dcbd6575244bb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3acec3878133c52f4f3a594baf1dcbd6575244bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3acec3878133c52f4f3a594baf1dcbd6575244bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3acec3878133c52f4f3a594baf1dcbd6575244bb/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0e9d04bf0a9465d085df1f8c8858cf427c6c97ba"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 6,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3bff2d8228760ba1c38f6e0bb63ce2b8eb32c81c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3acec3878133c52f4f3a594baf1dcbd6575244bb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3acec3878133c52f4f3a594baf1dcbd6575244bb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3acec3878133c52f4f3a594baf1dcbd6575244bb",
        "patch": "@@ -3120,6 +3120,12 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n         if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n         if (!fHasMoreWork) return true;     // Don't process less-work chains\n         if (fTooFarAhead) return true;      // Block height is too high\n+\n+        // Protect against DoS attacks from low-work chains.\n+        // If our tip is behind, a peer could try to send us\n+        // low-work blocks on a fake chain that we would never\n+        // request; don't process these.\n+        if (pindex->nChainWork < nMinimumChainWork) return true;\n     }\n     if (fNewBlock) *fNewBlock = true;\n "
      }
    ]
  },
  {
    "sha": "2df65eeb98100a376678cdf9cad4c973733df894",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZGY2NWVlYjk4MTAwYTM3NjY3OGNkZjljYWQ0Yzk3MzczM2RmODk0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-06T18:32:07Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:09:03Z"
      },
      "message": "qa: add test for minchainwork use in acceptblock\n\nGithub-Pull: #11458\nRebased-From: 08fd822771bf8dae1c21698811f57aa691b2f25d",
      "tree": {
        "sha": "6767f71bf07110d67bcc6ee4398a5b91a85cf1d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6767f71bf07110d67bcc6ee4398a5b91a85cf1d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2df65eeb98100a376678cdf9cad4c973733df894",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2df65eeb98100a376678cdf9cad4c973733df894",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2df65eeb98100a376678cdf9cad4c973733df894",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2df65eeb98100a376678cdf9cad4c973733df894/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3acec3878133c52f4f3a594baf1dcbd6575244bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3acec3878133c52f4f3a594baf1dcbd6575244bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3acec3878133c52f4f3a594baf1dcbd6575244bb"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 33,
      "deletions": 11
    },
    "files": [
      {
        "sha": "27ae0c27e19656733ebfee3edc3a0ad9399f3a0b",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 33,
        "deletions": 11,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2df65eeb98100a376678cdf9cad4c973733df894/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2df65eeb98100a376678cdf9cad4c973733df894/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=2df65eeb98100a376678cdf9cad4c973733df894",
        "patch": "@@ -8,17 +8,22 @@\n versus non-whitelisted peers, this tests the behavior of both (effectively two\n separate tests running in parallel).\n \n-Setup: two nodes, node0 and node1, not connected to each other.  Node0 does not\n+Setup: three nodes, node0+node1+node2, not connected to each other.  Node0 does not\n whitelist localhost, but node1 does. They will each be on their own chain for\n-this test.\n+this test.  Node2 will have nMinimumChainWork set to 0x10, so it won't process\n+low-work unrequested blocks.\n \n-We have one NodeConn connection to each, test_node and white_node respectively.\n+We have one NodeConn connection to each, test_node, white_node, and min_work_node,\n+respectively.\n \n The test:\n 1. Generate one block on each node, to leave IBD.\n \n 2. Mine a new block on each tip, and deliver to each node from node's peer.\n-   The tip should advance.\n+   The tip should advance for node0 and node1, but node2 should skip processing\n+   due to nMinimumChainWork.\n+\n+Node2 is unused in tests 3-7:\n \n 3. Mine a block that forks the previous block, and deliver to each node from\n    corresponding peer.\n@@ -46,6 +51,10 @@\n \n 7. Send Node0 the missing block again.\n    Node0 should process and the tip should advance.\n+\n+8. Test Node2 is able to sync when connected to node0 (which should have sufficient\n+work on its chain).\n+\n \"\"\"\n \n from test_framework.mininode import *\n@@ -62,52 +71,60 @@ def add_options(self, parser):\n \n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 2\n-        self.extra_args = [[], [\"-whitelist=127.0.0.1\"]]\n+        self.num_nodes = 3\n+        self.extra_args = [[], [\"-whitelist=127.0.0.1\"], [\"-minimumchainwork=0x10\"]]\n \n     def setup_network(self):\n         # Node0 will be used to test behavior of processing unrequested blocks\n         # from peers which are not whitelisted, while Node1 will be used for\n         # the whitelisted case.\n+        # Node2 will be used for non-whitelisted peers to test the interaction\n+        # with nMinimumChainWork.\n         self.setup_nodes()\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n         white_node = NodeConnCB()  # connects to node1 (whitelisted)\n+        min_work_node = NodeConnCB()  # connects to node2 (not whitelisted)\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n         connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], white_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], min_work_node))\n         test_node.add_connection(connections[0])\n         white_node.add_connection(connections[1])\n+        min_work_node.add_connection(connections[2])\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # Test logic begins here\n         test_node.wait_for_verack()\n         white_node.wait_for_verack()\n+        min_work_node.wait_for_verack()\n \n-        # 1. Have both nodes mine a block (leave IBD)\n+        # 1. Have nodes mine a block (nodes1/2 leave IBD)\n         [ n.generate(1) for n in self.nodes ]\n         tips = [ int(\"0x\" + n.getbestblockhash(), 0) for n in self.nodes ]\n \n         # 2. Send one block that builds on each tip.\n-        # This should be accepted.\n+        # This should be accepted by nodes 1/2\n         blocks_h2 = []  # the height 2 blocks on each node's chain\n         block_time = int(time.time()) + 1\n-        for i in range(2):\n+        for i in range(3):\n             blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))\n             blocks_h2[i].solve()\n             block_time += 1\n         test_node.send_message(msg_block(blocks_h2[0]))\n         white_node.send_message(msg_block(blocks_h2[1]))\n+        min_work_node.send_message(msg_block(blocks_h2[2]))\n \n-        for x in [test_node, white_node]:\n+        for x in [test_node, white_node, min_work_node]:\n             x.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         assert_equal(self.nodes[1].getblockcount(), 2)\n-        self.log.info(\"First height 2 block accepted by both nodes\")\n+        assert_equal(self.nodes[2].getblockcount(), 1)\n+        self.log.info(\"First height 2 block accepted by node0/node1; correctly rejected by node2\")\n \n         # 3. Send another block that builds on the original tip.\n         blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n@@ -220,6 +237,11 @@ def run_test(self):\n         assert_equal(self.nodes[0].getblockcount(), 290)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n+        # 8. Connect node2 to node0 and ensure it is able to sync\n+        connect_nodes(self.nodes[0], 2)\n+        sync_blocks([self.nodes[0], self.nodes[2]])\n+        self.log.info(\"Successfully synced nodes 2 and 0\")\n+\n         [ c.disconnect_node() for c in connections ]\n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZmI2ZWE0ZTVlYmZlMTA5ZTk3NzFhYWIwNThiZGQ0ZDJmNjQ2OGE4",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-20T00:52:30Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:09:16Z"
      },
      "message": "Add comment explaining forced processing of compact blocks\n\nGithub-Pull: #11458\nRebased-From: 01b52cedd42f50a93b40981c91af7c12de6e45ce",
      "tree": {
        "sha": "ba355b722427dd221a126d79850ea318b8d96d42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba355b722427dd221a126d79850ea318b8d96d42"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2df65eeb98100a376678cdf9cad4c973733df894",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2df65eeb98100a376678cdf9cad4c973733df894",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2df65eeb98100a376678cdf9cad4c973733df894"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 15,
      "deletions": 2
    },
    "files": [
      {
        "sha": "5b97509d642c85b5856152bb34032009fd93c1bb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
        "patch": "@@ -2144,7 +2144,16 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n             bool fNewBlock = false;\n-            ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n+            // Setting fForceProcessing to true means that we bypass some of\n+            // our anti-DoS protections in AcceptBlock, which filters\n+            // unrequested blocks that might be trying to waste our resources\n+            // (eg disk space). Because we only try to reconstruct blocks when\n+            // we're close to caught up (via the CanDirectFetch() requirement\n+            // above, combined with the behavior of not requesting blocks until\n+            // we have a chain with at least nMinimumChainWork), and we ignore\n+            // compact blocks with less work than our tip, it is safe to treat\n+            // reconstructed compact blocks as having been requested.\n+            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2224,7 +2233,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n-            ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n+            // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n+            // disk-space attacks), but this should be safe due to the\n+            // protections in the compact block handler -- see related comment\n+            // in compact block optimistic reconstruction handling.\n+            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {"
      }
    ]
  },
  {
    "sha": "6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZjI3OTY1MmIwNGVlYTVkMTFhM2ZkZjZlYWM1ODY1ZjBiODU1N2M1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-11-01T20:48:19Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:11:54Z"
      },
      "message": "Rename fAddnode to a more-descriptive \"manual_connection\"\n\nGithub-Pull: #11456\nRebased-From: 57edc0b0c86549020a39cd65f96496e9771c4769",
      "tree": {
        "sha": "7f548e749ab3d03515fac7f65632498bc50a9380",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f548e749ab3d03515fac7f65632498bc50a9380"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ffb6ea4e5ebfe109e9771aab058bdd4d2f6468a8"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "864bd31cba236ffb71bf95a4a270d00ac8ef96fa",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
        "patch": "@@ -665,7 +665,7 @@ void CNode::copyStats(CNodeStats &stats)\n         X(cleanSubVer);\n     }\n     X(fInbound);\n-    X(fAddnode);\n+    X(m_manual_connection);\n     X(nStartingHeight);\n     {\n         LOCK(cs_vSend);\n@@ -1738,7 +1738,7 @@ void CConnman::ThreadOpenConnections()\n         {\n             LOCK(cs_vNodes);\n             for (CNode* pnode : vNodes) {\n-                if (!pnode->fInbound && !pnode->fAddnode) {\n+                if (!pnode->fInbound && !pnode->m_manual_connection) {\n \n                     // Count the peers that have all relevant services\n                     if (pnode->fSuccessfullyConnected && !pnode->fFeeler && ((pnode->nServices & nRelevantServices) == nRelevantServices)) {\n@@ -1934,7 +1934,7 @@ void CConnman::ThreadOpenAddedConnections()\n }\n \n // if successful, this moves the passed grant to the constructed node\n-bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool fAddnode)\n+bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool manual_connection)\n {\n     //\n     // Initiate outbound network connection\n@@ -1963,8 +1963,8 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n         pnode->fOneShot = true;\n     if (fFeeler)\n         pnode->fFeeler = true;\n-    if (fAddnode)\n-        pnode->fAddnode = true;\n+    if (manual_connection)\n+        pnode->m_manual_connection = true;\n \n     GetNodeSignals().InitializeNode(pnode, *this);\n     {\n@@ -2704,7 +2704,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     strSubVer = \"\";\n     fWhitelisted = false;\n     fOneShot = false;\n-    fAddnode = false;\n+    m_manual_connection = false;\n     fClient = false; // set by version message\n     fFeeler = false;\n     fSuccessfullyConnected = false;"
      },
      {
        "sha": "fa9404ffbcf92b42185c0467e6c0ec434025c516",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
        "patch": "@@ -170,7 +170,7 @@ class CConnman\n     void Interrupt();\n     bool GetNetworkActive() const { return fNetworkActive; };\n     void SetNetworkActive(bool active);\n-    bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n+    bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool manual_connection = false);\n     bool CheckIncomingNonce(uint64_t nonce);\n \n     bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n@@ -508,7 +508,7 @@ class CNodeStats\n     int nVersion;\n     std::string cleanSubVer;\n     bool fInbound;\n-    bool fAddnode;\n+    bool m_manual_connection;\n     int nStartingHeight;\n     uint64_t nSendBytes;\n     mapMsgCmdSize mapSendBytesPerMsgCmd;\n@@ -618,7 +618,7 @@ class CNode\n     bool fWhitelisted; // This peer can bypass DoS banning.\n     bool fFeeler; // If true this node is being used as a short lived feeler.\n     bool fOneShot;\n-    bool fAddnode;\n+    bool m_manual_connection;\n     bool fClient;\n     const bool fInbound;\n     std::atomic_bool fSuccessfullyConnected;"
      },
      {
        "sha": "6e6b62484c5dc2e018afa3776b6ad63f2f8c23e7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
        "patch": "@@ -2656,7 +2656,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n         state.fShouldBan = false;\n         if (pnode->fWhitelisted)\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n-        else if (pnode->fAddnode)\n+        else if (pnode->m_manual_connection)\n             LogPrintf(\"Warning: not punishing addnoded peer %s!\\n\", pnode->addr.ToString());\n         else {\n             pnode->fDisconnect = true;"
      },
      {
        "sha": "2916bdc02ff4e4e835505b8500aa8a4d2adaee3d",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f279652b04eea5d11a3fdf6eac5865f0b8557c5/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
        "patch": "@@ -156,7 +156,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n         // their ver message.\n         obj.push_back(Pair(\"subver\", stats.cleanSubVer));\n         obj.push_back(Pair(\"inbound\", stats.fInbound));\n-        obj.push_back(Pair(\"addnode\", stats.fAddnode));\n+        obj.push_back(Pair(\"addnode\", stats.m_manual_connection));\n         obj.push_back(Pair(\"startingheight\", stats.nStartingHeight));\n         if (fStateStats) {\n             obj.push_back(Pair(\"banscore\", statestats.nMisbehavior));"
      }
    ]
  },
  {
    "sha": "8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YWVlNTVhZjNkMjFmYjc5ZWRmMTQ4ZTQyYzNiZDEwYmY4MGY3ZWM4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-07-06T17:53:52Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:15:02Z"
      },
      "message": "net: pass CConnman via pointer rather than reference\n\nThere are a few too many edge-cases here to make this a scripted diff.\n\nThe following commits will move a few functions into PeerLogicValidation, where\nthe local connman instance can be used. This change prepares for that usage.\n\nGithub-Pull: #10756\nRebased-From: 28f11e9406b185dc87144f1f29af0d93eb115b4e",
      "tree": {
        "sha": "9ecea5ae74040a03ea9746380830c14bdb64f8b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9ecea5ae74040a03ea9746380830c14bdb64f8b6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f279652b04eea5d11a3fdf6eac5865f0b8557c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6f279652b04eea5d11a3fdf6eac5865f0b8557c5"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 104,
      "deletions": 104
    },
    "files": [
      {
        "sha": "5bb1a82598bf733576d8f73271833dcdb7719580",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "patch": "@@ -1114,7 +1114,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n-    GetNodeSignals().InitializeNode(pnode, *this);\n+    GetNodeSignals().InitializeNode(pnode, this);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1966,7 +1966,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (manual_connection)\n         pnode->m_manual_connection = true;\n \n-    GetNodeSignals().InitializeNode(pnode, *this);\n+    GetNodeSignals().InitializeNode(pnode, this);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -1996,15 +1996,15 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = GetNodeSignals().ProcessMessages(pnode, *this, flagInterruptMsgProc);\n+            bool fMoreNodeWork = GetNodeSignals().ProcessMessages(pnode, this, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n \n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                GetNodeSignals().SendMessages(pnode, *this, flagInterruptMsgProc);\n+                GetNodeSignals().SendMessages(pnode, this, flagInterruptMsgProc);\n             }\n             if (flagInterruptMsgProc)\n                 return;"
      },
      {
        "sha": "9e1898d14d803a1ac53c066bd3fe6436399650f3",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "patch": "@@ -439,9 +439,9 @@ struct CombinerAll\n // Signals for message handling\n struct CNodeSignals\n {\n-    boost::signals2::signal<bool (CNode*, CConnman&, std::atomic<bool>&), CombinerAll> ProcessMessages;\n-    boost::signals2::signal<bool (CNode*, CConnman&, std::atomic<bool>&), CombinerAll> SendMessages;\n-    boost::signals2::signal<void (CNode*, CConnman&)> InitializeNode;\n+    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> ProcessMessages;\n+    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> SendMessages;\n+    boost::signals2::signal<void (CNode*, CConnman*)> InitializeNode;\n     boost::signals2::signal<void (NodeId, bool&)> FinalizeNode;\n };\n "
      },
      {
        "sha": "e3d2a51e7ec6e513581b87dd2e93e97ea30d9d01",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 84,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "patch": "@@ -244,7 +244,7 @@ void UpdatePreferredDownload(CNode* node, CNodeState* state)\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n+void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n {\n     ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n     uint64_t nonce = pnode->GetLocalNonce();\n@@ -255,7 +255,7 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n-    connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+    connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n             nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes));\n \n     if (fLogIPs) {\n@@ -265,7 +265,7 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     }\n }\n \n-void InitializeNode(CNode *pnode, CConnman& connman) {\n+void InitializeNode(CNode *pnode, CConnman* connman) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n@@ -402,7 +402,7 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n-void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) {\n+void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n@@ -417,20 +417,20 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) {\n                 return;\n             }\n         }\n-        connman.ForNode(nodeid, [&connman](CNode* pfrom){\n+        connman->ForNode(nodeid, [connman](CNode* pfrom){\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n-                connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n-                    connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+                connman->ForNode(lNodesAnnouncingHeaderAndIDs.front(), [connman, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n+                    connman->PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n                     return true;\n                 });\n                 lNodesAnnouncingHeaderAndIDs.pop_front();\n             }\n             fAnnounceUsingCMPCTBLOCK = true;\n-            connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            connman->PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n             return true;\n         });\n@@ -865,7 +865,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n              !IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n-            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, *connman);\n+            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);\n         }\n     }\n     if (it != mapBlockSource.end())\n@@ -910,24 +910,24 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     return true;\n }\n \n-static void RelayTransaction(const CTransaction& tx, CConnman& connman)\n+static void RelayTransaction(const CTransaction& tx, CConnman* connman)\n {\n     CInv inv(MSG_TX, tx.GetHash());\n-    connman.ForEachNode([&inv](CNode* pnode)\n+    connman->ForEachNode([&inv](CNode* pnode)\n     {\n         pnode->PushInventory(inv);\n     });\n }\n \n-static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connman)\n+static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connman)\n {\n     unsigned int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n \n     // Relay to a limited number of other nodes\n     // Use deterministic randomness to send to the same nodes for 24 hours\n     // at a time so the addrKnowns of the chosen nodes prevent repeats\n     uint64_t hashAddr = addr.GetHash();\n-    const CSipHasher hasher = connman.GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24*60*60));\n+    const CSipHasher hasher = connman->GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24*60*60));\n     FastRandomContext insecure_rand;\n \n     std::array<std::pair<uint64_t, CNode*>,2> best{{{0, nullptr}, {0, nullptr}}};\n@@ -952,10 +952,10 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n         }\n     };\n \n-    connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n+    connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n@@ -1017,7 +1017,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // disconnect node in case we have reached the outbound limit for serving historical blocks\n                 // never disconnect whitelisted nodes\n                 static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n-                if (send && connman.OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+                if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n                 {\n                     LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1040,9 +1040,9 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         pblock = pblockRead;\n                     }\n                     if (inv.type == MSG_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+                        connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_WITNESS_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         bool sendMerkleBlock = false;\n@@ -1055,7 +1055,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             }\n                         }\n                         if (sendMerkleBlock) {\n-                            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n                             // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                             // This avoids hurting performance by pointlessly requiring a round-trip\n                             // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -1064,7 +1064,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             for (PairType& pair : merkleBlock.vMatchedTxn)\n-                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+                                connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                         }\n                         // else\n                             // no response\n@@ -1079,13 +1079,13 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                         if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n                             if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n-                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                             } else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                         } else {\n-                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                            connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n                         }\n                     }\n \n@@ -1097,7 +1097,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // wait for other stuff first.\n                         std::vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n-                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                         pfrom->hashContinue.SetNull();\n                     }\n                 }\n@@ -1109,14 +1109,14 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 auto mi = mapRelay.find(inv.hash);\n                 int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n                 if (mi != mapRelay.end()) {\n-                    connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                     push = true;\n                 } else if (pfrom->timeLastMempoolReq) {\n                     auto txinfo = mempool.info(inv.hash);\n                     // To protect privacy, do not answer getdata using the mempool when\n                     // that TX couldn't have been INVed in reply to a MEMPOOL request.\n                     if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n+                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n                         push = true;\n                     }\n                 }\n@@ -1143,7 +1143,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n         // do that because they want to know about (and store and rebroadcast and\n         // risk analyze) the dependencies of transactions relevant to them, without\n         // having to download the entire memory pool.\n-        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n+        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n     }\n }\n \n@@ -1155,7 +1155,7 @@ uint32_t GetFetchFlags(CNode* pfrom) {\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman& connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n@@ -1169,10 +1169,10 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     LOCK(cs_main);\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-    connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n+    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -1225,7 +1225,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -1249,12 +1249,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         nServices = ServiceFlags(nServiceInt);\n         if (!pfrom->fInbound)\n         {\n-            connman.SetServices(pfrom->addr, nServices);\n+            connman->SetServices(pfrom->addr, nServices);\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n             LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -1275,7 +1275,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             // disconnect from peers older than this proto version\n             LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n+            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -1295,7 +1295,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!vRecv.empty())\n             vRecv >> fRelay;\n         // Disconnect if we connected to ourself\n-        if (pfrom->fInbound && !connman.CheckIncomingNonce(nNonce))\n+        if (pfrom->fInbound && !connman->CheckIncomingNonce(nNonce))\n         {\n             LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString());\n             pfrom->fDisconnect = true;\n@@ -1311,7 +1311,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pfrom->fInbound)\n             PushNodeVersion(pfrom, connman, GetAdjustedTime());\n \n-        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n         pfrom->nServices = nServices;\n         pfrom->SetAddrLocal(addrMe);\n@@ -1362,12 +1362,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n \n             // Get recent addresses\n-            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman.GetAddressCount() < 1000)\n+            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman->GetAddressCount() < 1000)\n             {\n-                connman.PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n+                connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n                 pfrom->fGetAddr = true;\n             }\n-            connman.MarkAddressGood(pfrom->addr);\n+            connman->MarkAddressGood(pfrom->addr);\n         }\n \n         std::string remoteAddr;\n@@ -1386,7 +1386,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // If the peer is old enough to have the old alert system, send it the final alert.\n         if (pfrom->nVersion <= 70012) {\n             CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);\n-            connman.PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n+            connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n         }\n \n         // Feeler connections exist only to verify if address is online.\n@@ -1424,7 +1424,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n         if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n@@ -1435,9 +1435,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n             if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom->fSuccessfullyConnected = true;\n     }\n@@ -1456,7 +1456,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> vAddr;\n \n         // Don't want addr from older versions unless seeding\n-        if (pfrom->nVersion < CADDR_TIME_VERSION && connman.GetAddressCount() > 1000)\n+        if (pfrom->nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)\n             return true;\n         if (vAddr.size() > 1000)\n         {\n@@ -1490,7 +1490,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n-        connman.AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);\n+        connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n             pfrom->fGetAddr = false;\n         if (pfrom->fOneShot)\n@@ -1568,7 +1568,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n                     LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n@@ -1774,7 +1774,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n-        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n     }\n \n \n@@ -1955,7 +1955,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n             if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n@@ -1975,7 +1975,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n         }\n@@ -2030,7 +2030,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n         }\n@@ -2074,7 +2074,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n \n@@ -2091,7 +2091,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     fProcessBLOCKTXN = true;\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             } else {\n                 // This block is either already in flight from a different\n@@ -2117,7 +2117,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -2200,7 +2200,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED.\n@@ -2285,7 +2285,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -2340,7 +2340,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -2390,7 +2390,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n-                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                 }\n             }\n         }\n@@ -2451,7 +2451,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->fSentAddr = true;\n \n         pfrom->vAddrToSend.clear();\n-        std::vector<CAddress> vAddr = connman.GetAddresses();\n+        std::vector<CAddress> vAddr = connman->GetAddresses();\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n@@ -2467,7 +2467,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        if (connman.OutboundTargetReached(false) && !pfrom->fWhitelisted)\n+        if (connman->OutboundTargetReached(false) && !pfrom->fWhitelisted)\n         {\n             LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n@@ -2496,7 +2496,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n     }\n \n@@ -2642,13 +2642,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     return true;\n }\n \n-static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n+static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n {\n     AssertLockHeld(cs_main);\n     CNodeState &state = *State(pnode->GetId());\n \n     for (const CBlockReject& reject : state.rejects) {\n-        connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+        connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n     }\n     state.rejects.clear();\n \n@@ -2664,15 +2664,15 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n                 LogPrintf(\"Warning: not banning local peer %s!\\n\", pnode->addr.ToString());\n             else\n             {\n-                connman.Ban(pnode->addr, BanReasonNodeMisbehaving);\n+                connman->Ban(pnode->addr, BanReasonNodeMisbehaving);\n             }\n         }\n         return true;\n     }\n     return false;\n }\n \n-bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n     //\n@@ -2706,7 +2706,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n         // Just take one message\n         msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n         pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n-        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n+        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman->GetReceiveFloodSize();\n         fMoreWork = !pfrom->vProcessMsg.empty();\n     }\n     CNetMessage& msg(msgs.front());\n@@ -2755,7 +2755,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     }\n     catch (const std::ios_base::failure& e)\n     {\n-        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n         if (strstr(e.what(), \"end of data\"))\n         {\n             // Allow exceptions from under-length message on vRecv\n@@ -2809,7 +2809,7 @@ class CompareInvMempoolOrder\n     }\n };\n \n-bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n+bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {\n@@ -2841,11 +2841,11 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             pto->nPingUsecStart = GetTimeMicros();\n             if (pto->nVersion > BIP0031_VERSION) {\n                 pto->nPingNonceSent = nonce;\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n             } else {\n                 // Peer is too old to support ping command with nonce, pong will never arrive.\n                 pto->nPingNonceSent = 0;\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n             }\n         }\n \n@@ -2880,14 +2880,14 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // receiver rejects addr messages larger than 1000\n                     if (vAddr.size() >= 1000)\n                     {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();\n@@ -2914,7 +2914,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n-                connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -2923,7 +2923,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n         // transactions become unconfirmed and spams other nodes.\n         if (!fReindex && !fImporting && !IsInitialBlockDownload())\n         {\n-            GetMainSignals().Broadcast(nTimeBestReceived, &connman);\n+            GetMainSignals().Broadcast(nTimeBestReceived, connman);\n         }\n \n         //\n@@ -3007,10 +3007,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n                             if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n-                                connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n+                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n-                                connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                             fGotBlockFromCache = true;\n                         }\n@@ -3020,7 +3020,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n                         CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                        connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n@@ -3033,7 +3033,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                 vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n@@ -3079,7 +3079,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             for (const uint256& hash : pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                     vInv.clear();\n                 }\n             }\n@@ -3125,7 +3125,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     pto->filterInventoryKnown.insert(hash);\n                     vInv.push_back(inv);\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                 }\n@@ -3191,15 +3191,15 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         }\n                     }\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                     pto->filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n         if (!vInv.empty())\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n         nNow = GetTimeMicros();\n@@ -3294,7 +3294,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                     vGetData.clear();\n                 }\n             } else {\n@@ -3304,7 +3304,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n         if (!vGetData.empty())\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n         //\n         // Message: feefilter\n@@ -3321,7 +3321,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n                 if (filterToSend != pto->lastSentFeeFilter) {\n-                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n                     pto->lastSentFeeFilter = filterToSend;\n                 }\n                 pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);"
      },
      {
        "sha": "84ec7a7662834a855d51db1240d5fbec82895729",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "patch": "@@ -53,7 +53,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n void Misbehaving(NodeId nodeid, int howmuch);\n \n /** Process protocol messages received from a given node */\n-bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& interrupt);\n+bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interrupt);\n /**\n  * Send queued protocol messages to be sent to a give node.\n  *\n@@ -62,6 +62,6 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n  * @param[in]   interrupt       Interrupt condition for processing threads\n  * @return                      True if there is more work to be done\n  */\n-bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interrupt);\n+bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interrupt);\n \n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "39a75f7c820cef98f889cfaaf2b7f0a239553b6f",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "patch": "@@ -50,26 +50,26 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode2, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode2, connman);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, *connman, interruptDummy);\n+    SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, *connman, interruptDummy);\n+    SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n \n@@ -82,17 +82,17 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    SendMessages(&dummyNode1, *connman, interruptDummy);\n+    SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n }\n@@ -108,12 +108,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode, *connman);\n+    GetNodeSignals().InitializeNode(&dummyNode, connman);\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    SendMessages(&dummyNode, *connman, interruptDummy);\n+    SendMessages(&dummyNode, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      }
    ]
  },
  {
    "sha": "dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYzg5N2U1M2Q4YTZjMjkwMTZhMTljODYyZGRkMGI2NTZhZThkZTNm",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-07-06T17:40:09Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:16:28Z"
      },
      "message": "net: use an interface class rather than signals for message processing\n\nDrop boost signals in favor of a stateful class. This will allow the message\nprocessing loop to actually move to net_processing in a future step.\n\nGithub-Pull: #10756\nRebased-From: 8ad663c1fa88d68843e45580deced56112343183",
      "tree": {
        "sha": "6ee77baaf72f7d5fa09cc05d717816736cd9a598",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6ee77baaf72f7d5fa09cc05d717816736cd9a598"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8aee55af3d21fb79edf148e42c3bd10bf80f7ec8"
      }
    ],
    "stats": {
      "total": 228,
      "additions": 103,
      "deletions": 125
    },
    "files": [
      {
        "sha": "62250664e360abd50467ff7e0b2cf0791302d0e1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -194,11 +194,10 @@ void Shutdown()\n #endif\n     MapPort(false);\n     UnregisterValidationInterface(peerLogic.get());\n-    peerLogic.reset();\n     g_connman.reset();\n+    peerLogic.reset();\n \n     StopTorControl();\n-    UnregisterNodeSignals(GetNodeSignals());\n     if (fDumpMempoolLater && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n     }\n@@ -1277,7 +1276,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     peerLogic.reset(new PeerLogicValidation(&connman));\n     RegisterValidationInterface(peerLogic.get());\n-    RegisterNodeSignals(GetNodeSignals());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n@@ -1668,6 +1666,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxFeeler = 1;\n     connOptions.nBestHeight = chainActive.Height();\n     connOptions.uiInterface = &uiInterface;\n+    connOptions.m_msgproc = peerLogic.get();\n     connOptions.nSendBufferMaxSize = 1000*gArgs.GetArg(\"-maxsendbuffer\", DEFAULT_MAXSENDBUFFER);\n     connOptions.nReceiveFloodSize = 1000*gArgs.GetArg(\"-maxreceivebuffer\", DEFAULT_MAXRECEIVEBUFFER);\n "
      },
      {
        "sha": "63ac833405bc81961440458a6ebb163a67089d88",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -89,10 +89,6 @@ std::string strSubVersion;\n \n limitedmap<uint256, int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n \n-// Signals for message handling\n-static CNodeSignals g_signals;\n-CNodeSignals& GetNodeSignals() { return g_signals; }\n-\n void CConnman::AddOneShot(const std::string& strDest)\n {\n     LOCK(cs_vOneShots);\n@@ -1114,7 +1110,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n-    GetNodeSignals().InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode, this);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1966,7 +1962,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (manual_connection)\n         pnode->m_manual_connection = true;\n \n-    GetNodeSignals().InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode, this);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -1996,16 +1992,16 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = GetNodeSignals().ProcessMessages(pnode, this, flagInterruptMsgProc);\n+            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, this, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n-\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                GetNodeSignals().SendMessages(pnode, this, flagInterruptMsgProc);\n+                m_msgproc->SendMessages(pnode, this, flagInterruptMsgProc);\n             }\n+\n             if (flagInterruptMsgProc)\n                 return;\n         }\n@@ -2324,6 +2320,7 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n     //\n     // Start threads\n     //\n+    assert(m_msgproc);\n     InterruptSocks5(false);\n     interruptNet.reset();\n     flagInterruptMsgProc = false;\n@@ -2443,9 +2440,10 @@ void CConnman::DeleteNode(CNode* pnode)\n {\n     assert(pnode);\n     bool fUpdateConnectionTime = false;\n-    GetNodeSignals().FinalizeNode(pnode->GetId(), fUpdateConnectionTime);\n-    if(fUpdateConnectionTime)\n+    m_msgproc->FinalizeNode(pnode->GetId(), fUpdateConnectionTime);\n+    if(fUpdateConnectionTime) {\n         addrman.Connected(pnode->addr);\n+    }\n     delete pnode;\n }\n "
      },
      {
        "sha": "fcbf93672f06a58fc0f101adaab764cd0a83c991",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -33,7 +33,6 @@\n #include <arpa/inet.h>\n #endif\n \n-#include <boost/signals2/signal.hpp>\n \n class CScheduler;\n class CNode;\n@@ -116,7 +115,7 @@ struct CSerializedNetMsg\n     std::string command;\n };\n \n-\n+class NetEventsInterface;\n class CConnman\n {\n public:\n@@ -138,6 +137,7 @@ class CConnman\n         int nMaxFeeler = 0;\n         int nBestHeight = 0;\n         CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n         unsigned int nSendBufferMaxSize = 0;\n         unsigned int nReceiveFloodSize = 0;\n         uint64_t nMaxOutboundTimeframe = 0;\n@@ -156,6 +156,7 @@ class CConnman\n         nMaxFeeler = connOptions.nMaxFeeler;\n         nBestHeight = connOptions.nBestHeight;\n         clientInterface = connOptions.uiInterface;\n+        m_msgproc = connOptions.m_msgproc;\n         nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n         nReceiveFloodSize = connOptions.nReceiveFloodSize;\n         nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n@@ -396,6 +397,7 @@ class CConnman\n     int nMaxFeeler;\n     std::atomic<int> nBestHeight;\n     CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n \n     /** SipHasher seeds for deterministic randomness */\n     const uint64_t nSeed0, nSeed1;\n@@ -436,19 +438,18 @@ struct CombinerAll\n     }\n };\n \n-// Signals for message handling\n-struct CNodeSignals\n+/**\n+ * Interface for message handling\n+ */\n+class NetEventsInterface\n {\n-    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> ProcessMessages;\n-    boost::signals2::signal<bool (CNode*, CConnman*, std::atomic<bool>&), CombinerAll> SendMessages;\n-    boost::signals2::signal<void (CNode*, CConnman*)> InitializeNode;\n-    boost::signals2::signal<void (NodeId, bool&)> FinalizeNode;\n+public:\n+    virtual bool ProcessMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n+    virtual void InitializeNode(CNode* pnode, CConnman* connman) = 0;\n+    virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n };\n \n-\n-CNodeSignals& GetNodeSignals();\n-\n-\n enum\n {\n     LOCAL_NONE,   // unknown"
      },
      {
        "sha": "22d7ee194bb39d9beee306bbf1adb1f375bd1c82",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 66,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -123,11 +123,6 @@ namespace {\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n } // namespace\n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// Registration of network node signals.\n-//\n-\n namespace {\n \n struct CBlockReject {\n@@ -265,49 +260,6 @@ void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n     }\n }\n \n-void InitializeNode(CNode *pnode, CConnman* connman) {\n-    CAddress addr = pnode->addr;\n-    std::string addrName = pnode->GetAddrName();\n-    NodeId nodeid = pnode->GetId();\n-    {\n-        LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n-    }\n-    if(!pnode->fInbound)\n-        PushNodeVersion(pnode, connman, GetTime());\n-}\n-\n-void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n-    fUpdateConnectionTime = false;\n-    LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n-\n-    if (state->fSyncStarted)\n-        nSyncStarted--;\n-\n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n-        fUpdateConnectionTime = true;\n-    }\n-\n-    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n-    }\n-    EraseOrphansFor(nodeid);\n-    nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n-\n-    mapNodeState.erase(nodeid);\n-\n-    if (mapNodeState.empty()) {\n-        // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n-        assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n-    }\n-    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n-}\n-\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n@@ -543,6 +495,50 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+void PeerLogicValidation::InitializeNode(CNode *pnode, CConnman* connman) {\n+    CAddress addr = pnode->addr;\n+    std::string addrName = pnode->GetAddrName();\n+    NodeId nodeid = pnode->GetId();\n+    {\n+        LOCK(cs_main);\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n+    }\n+    if(!pnode->fInbound)\n+        PushNodeVersion(pnode, connman, GetTime());\n+}\n+\n+void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n+    fUpdateConnectionTime = false;\n+    LOCK(cs_main);\n+    CNodeState *state = State(nodeid);\n+    assert(state != nullptr);\n+\n+    if (state->fSyncStarted)\n+        nSyncStarted--;\n+\n+    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n+        fUpdateConnectionTime = true;\n+    }\n+\n+    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n+        mapBlocksInFlight.erase(entry.hash);\n+    }\n+    EraseOrphansFor(nodeid);\n+    nPreferredDownload -= state->fPreferredDownload;\n+    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n+    assert(nPeersWithValidatedDownloads >= 0);\n+\n+    mapNodeState.erase(nodeid);\n+\n+    if (mapNodeState.empty()) {\n+        // Do a consistency check after the last peer is removed.\n+        assert(mapBlocksInFlight.empty());\n+        assert(nPreferredDownload == 0);\n+        assert(nPeersWithValidatedDownloads == 0);\n+    }\n+    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n+}\n+\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n@@ -558,22 +554,6 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     return true;\n }\n \n-void RegisterNodeSignals(CNodeSignals& nodeSignals)\n-{\n-    nodeSignals.ProcessMessages.connect(&ProcessMessages);\n-    nodeSignals.SendMessages.connect(&SendMessages);\n-    nodeSignals.InitializeNode.connect(&InitializeNode);\n-    nodeSignals.FinalizeNode.connect(&FinalizeNode);\n-}\n-\n-void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n-{\n-    nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n-    nodeSignals.SendMessages.disconnect(&SendMessages);\n-    nodeSignals.InitializeNode.disconnect(&InitializeNode);\n-    nodeSignals.FinalizeNode.disconnect(&FinalizeNode);\n-}\n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // mapOrphanTransactions\n@@ -2672,7 +2652,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n     return false;\n }\n \n-bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n     //\n@@ -2809,7 +2789,7 @@ class CompareInvMempoolOrder\n     }\n };\n \n-bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {"
      },
      {
        "sha": "d79b74fcb7f71ec057282f66538f66fc17a2bf12",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 17,
        "deletions": 19,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -22,22 +22,32 @@ static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n \n-/** Register with a network node to receive its signals */\n-void RegisterNodeSignals(CNodeSignals& nodeSignals);\n-/** Unregister a network node */\n-void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n-\n-class PeerLogicValidation : public CValidationInterface {\n+class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* connman;\n \n public:\n-    PeerLogicValidation(CConnman* connmanIn);\n+    explicit PeerLogicValidation(CConnman* connman);\n \n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n     void BlockChecked(const CBlock& block, const CValidationState& state) override;\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+\n+\n+    void InitializeNode(CNode* pnode, CConnman* connman) override;\n+    void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) override;\n+    /** Process protocol messages received from a given node */\n+    bool ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interrupt) override;\n+    /**\n+    * Send queued protocol messages to be sent to a give node.\n+    *\n+    * @param[in]   pto             The node which we are sending messages to.\n+    * @param[in]   connman         The connection manager for that node.\n+    * @param[in]   interrupt       Interrupt condition for processing threads\n+    * @return                      True if there is more work to be done\n+    */\n+    bool SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interrupt) override;\n };\n \n struct CNodeStateStats {\n@@ -52,16 +62,4 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch);\n \n-/** Process protocol messages received from a given node */\n-bool ProcessMessages(CNode* pfrom, CConnman* connman, const std::atomic<bool>& interrupt);\n-/**\n- * Send queued protocol messages to be sent to a give node.\n- *\n- * @param[in]   pto             The node which we are sending messages to.\n- * @param[in]   connman         The connection manager for that node.\n- * @param[in]   interrupt       Interrupt condition for processing threads\n- * @return                      True if there is more work to be done\n- */\n-bool SendMessages(CNode* pto, CConnman* connman, const std::atomic<bool>& interrupt);\n-\n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "fc5ef84ad2ac5f06709de1508b29fd5af7e9b894",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -50,26 +50,26 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode2, connman);\n+    peerLogic->InitializeNode(&dummyNode2, connman);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n \n@@ -82,17 +82,17 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1, connman);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n }\n@@ -108,12 +108,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(&dummyNode, connman);\n+    peerLogic->InitializeNode(&dummyNode, connman);\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    SendMessages(&dummyNode, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode, connman, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      },
      {
        "sha": "045655983c66fdbafc0679b8a6fb0befc3a1bd19",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -48,7 +48,6 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n BasicTestingSetup::~BasicTestingSetup()\n {\n         ECC_Stop();\n-        g_connman.reset();\n }\n \n TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\n@@ -86,16 +85,17 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             threadGroup.create_thread(&ThreadScriptCheck);\n         g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n         connman = g_connman.get();\n-        RegisterNodeSignals(GetNodeSignals());\n+        peerLogic.reset(new PeerLogicValidation(connman));\n }\n \n TestingSetup::~TestingSetup()\n {\n-        UnregisterNodeSignals(GetNodeSignals());\n         threadGroup.interrupt_all();\n         threadGroup.join_all();\n         GetMainSignals().FlushBackgroundCallbacks();\n         GetMainSignals().UnregisterBackgroundSignalScheduler();\n+        g_connman.reset();\n+        peerLogic.reset();\n         UnloadBlockIndex();\n         delete pcoinsTip;\n         delete pcoinsdbview;"
      },
      {
        "sha": "5a39f8ab821c11d37519309339f9067b4aabf564",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc897e53d8a6c29016a19c862ddd0b656ae8de3f/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "patch": "@@ -49,12 +49,14 @@ struct BasicTestingSetup {\n  * Included are data directory, coins database, script check threads setup.\n  */\n class CConnman;\n+class PeerLogicValidation;\n struct TestingSetup: public BasicTestingSetup {\n     CCoinsViewDB *pcoinsdbview;\n     fs::path pathTemp;\n     boost::thread_group threadGroup;\n     CConnman* connman;\n     CScheduler scheduler;\n+    std::unique_ptr<PeerLogicValidation> peerLogic;\n \n     TestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~TestingSetup();"
      }
    ]
  },
  {
    "sha": "b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNDEzNmYyMWNmYmJlYjA0M2NlNDZmZmExYmY1ZjM1MzgzOGJmYmVh",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-07-06T18:08:23Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:16:50Z"
      },
      "message": "net: drop unused connman param\n\nThe copy in PeerLogicValidation can be used instead.\n\nGithub-Pull: #10756\nRebased-From: 80e2e9d0cec890c5d2f81360ebb81e81c07ccb8c",
      "tree": {
        "sha": "895075c49d165a9372ffaa7e85f417aa84145993",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/895075c49d165a9372ffaa7e85f417aa84145993"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc897e53d8a6c29016a19c862ddd0b656ae8de3f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc897e53d8a6c29016a19c862ddd0b656ae8de3f"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 24,
      "deletions": 25
    },
    "files": [
      {
        "sha": "a07b22bf5d819789fa68896b1230d633b2f879d3",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "patch": "@@ -1110,7 +1110,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n-    m_msgproc->InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1962,7 +1962,7 @@ bool CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (manual_connection)\n         pnode->m_manual_connection = true;\n \n-    m_msgproc->InitializeNode(pnode, this);\n+    m_msgproc->InitializeNode(pnode);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -1992,14 +1992,14 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, this, flagInterruptMsgProc);\n+            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                m_msgproc->SendMessages(pnode, this, flagInterruptMsgProc);\n+                m_msgproc->SendMessages(pnode, flagInterruptMsgProc);\n             }\n \n             if (flagInterruptMsgProc)"
      },
      {
        "sha": "9bb1d3c39b085dcd70fb059cdfb16ddb97a2b8ca",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "patch": "@@ -444,9 +444,9 @@ struct CombinerAll\n class NetEventsInterface\n {\n public:\n-    virtual bool ProcessMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode, CConnman* connman, std::atomic<bool>& interrupt) = 0;\n-    virtual void InitializeNode(CNode* pnode, CConnman* connman) = 0;\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n };\n "
      },
      {
        "sha": "24d8d49c0c39255a81d52656b0fb6f4ae358b857",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "patch": "@@ -495,7 +495,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n-void PeerLogicValidation::InitializeNode(CNode *pnode, CConnman* connman) {\n+void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n@@ -2652,7 +2652,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman)\n     return false;\n }\n \n-bool PeerLogicValidation::ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n     //\n@@ -2789,7 +2789,7 @@ class CompareInvMempoolOrder\n     }\n };\n \n-bool PeerLogicValidation::SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interruptMsgProc)\n+bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptMsgProc)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {"
      },
      {
        "sha": "79745cdd42c96ad765b27703b313ce2b6278ad59",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "patch": "@@ -35,19 +35,18 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n \n \n-    void InitializeNode(CNode* pnode, CConnman* connman) override;\n+    void InitializeNode(CNode* pnode) override;\n     void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) override;\n     /** Process protocol messages received from a given node */\n-    bool ProcessMessages(CNode* pfrom, CConnman* connman, std::atomic<bool>& interrupt) override;\n+    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n     /**\n     * Send queued protocol messages to be sent to a give node.\n     *\n     * @param[in]   pto             The node which we are sending messages to.\n-    * @param[in]   connman         The connection manager for that node.\n     * @param[in]   interrupt       Interrupt condition for processing threads\n     * @return                      True if there is more work to be done\n     */\n-    bool SendMessages(CNode* pto, CConnman* connman, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "b88ad5ed1b8ab892c358a4f6b6b1e7cb9248e8fc",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "patch": "@@ -50,26 +50,26 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode2, connman);\n+    peerLogic->InitializeNode(&dummyNode2);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    peerLogic->SendMessages(&dummyNode2, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n \n@@ -82,17 +82,17 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode1, connman);\n+    peerLogic->InitializeNode(&dummyNode1);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    peerLogic->SendMessages(&dummyNode1, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n }\n@@ -108,12 +108,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode, connman);\n+    peerLogic->InitializeNode(&dummyNode);\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    peerLogic->SendMessages(&dummyNode, connman, interruptDummy);\n+    peerLogic->SendMessages(&dummyNode, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      }
    ]
  },
  {
    "sha": "0a5477c7e30667f4dc864b69975a8da5f63ca71e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTU0NzdjN2UzMDY2N2Y0ZGM4NjRiNjk5NzVhOGRhNWY2M2NhNzFl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-09-07T18:26:20Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:16:57Z"
      },
      "message": "net: stop both net/net_processing before destroying them\n\nThis should avoid either attempting to use an invalid reference/pointer to the\nother.\n\nGithub-Pull: #10756\nRebased-From: 2525b972af6645ca239ac1078cffb132b402bfbb",
      "tree": {
        "sha": "4b6dd3118c9f798babfaf5966da897e121c4e95d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b6dd3118c9f798babfaf5966da897e121c4e95d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a5477c7e30667f4dc864b69975a8da5f63ca71e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a5477c7e30667f4dc864b69975a8da5f63ca71e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a5477c7e30667f4dc864b69975a8da5f63ca71e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a5477c7e30667f4dc864b69975a8da5f63ca71e/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4136f21cfbbeb043ce46ffa1bf5f353838bfbea"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 5,
      "deletions": 1
    },
    "files": [
      {
        "sha": "798c24a2a83a3c813aa4351e9ea85859343b6a0f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a5477c7e30667f4dc864b69975a8da5f63ca71e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a5477c7e30667f4dc864b69975a8da5f63ca71e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=0a5477c7e30667f4dc864b69975a8da5f63ca71e",
        "patch": "@@ -193,9 +193,13 @@ void Shutdown()\n     }\n #endif\n     MapPort(false);\n+\n+    // Because these depend on each-other, we make sure that neither can be\n+    // using the other before destroying them.\n     UnregisterValidationInterface(peerLogic.get());\n-    g_connman.reset();\n+    g_connman->Stop();\n     peerLogic.reset();\n+    g_connman.reset();\n \n     StopTorControl();\n     if (fDumpMempoolLater && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {"
      }
    ]
  },
  {
    "sha": "d570aa4290bf678bab764aa58dde19167bc927f5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTcwYWE0MjkwYmY2NzhiYWI3NjRhYTU4ZGRlMTkxNjdiYzkyN2Y1",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2017-09-14T03:18:55Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:17:58Z"
      },
      "message": "Fix uninitialized g_connman crash in Shutdown()\n\nGithub-Pull: #11326\nRebased-From: 77939f27f7dc42640ebfb9fe52490a2ddacc3ad4",
      "tree": {
        "sha": "7398db5824d4dc0574a809e25e0a4ddf9d8af79d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7398db5824d4dc0574a809e25e0a4ddf9d8af79d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d570aa4290bf678bab764aa58dde19167bc927f5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d570aa4290bf678bab764aa58dde19167bc927f5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d570aa4290bf678bab764aa58dde19167bc927f5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d570aa4290bf678bab764aa58dde19167bc927f5/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0a5477c7e30667f4dc864b69975a8da5f63ca71e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a5477c7e30667f4dc864b69975a8da5f63ca71e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a5477c7e30667f4dc864b69975a8da5f63ca71e"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "4efc06a4be9b4fc44040b7dc66bc8fabcee540f1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d570aa4290bf678bab764aa58dde19167bc927f5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d570aa4290bf678bab764aa58dde19167bc927f5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d570aa4290bf678bab764aa58dde19167bc927f5",
        "patch": "@@ -197,7 +197,7 @@ void Shutdown()\n     // Because these depend on each-other, we make sure that neither can be\n     // using the other before destroying them.\n     UnregisterValidationInterface(peerLogic.get());\n-    g_connman->Stop();\n+    if(g_connman) g_connman->Stop();\n     peerLogic.reset();\n     g_connman.reset();\n "
      }
    ]
  },
  {
    "sha": "bf191a71836f357d7949459f666db506dffd123b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZjE5MWE3MTgzNmYzNTdkNzk0OTQ1OWY2NjZkYjUwNmRmZmQxMjNi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-11T12:55:14Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:18:23Z"
      },
      "message": "Disconnecting from bad outbound peers in IBD\n\nWhen in IBD, we'd like to use all our outbound peers to help us\nsync the chain.  Disconnect any outbound peers whose headers have\ninsufficient work.\n\nGithub-Pull: #11490\nRebased-From: c60fd71a65e841efe187992f46c583a704cc37f5",
      "tree": {
        "sha": "f6f410b14e72bda966ef09956617bdd04a72f9f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6f410b14e72bda966ef09956617bdd04a72f9f2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf191a71836f357d7949459f666db506dffd123b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf191a71836f357d7949459f666db506dffd123b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bf191a71836f357d7949459f666db506dffd123b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf191a71836f357d7949459f666db506dffd123b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d570aa4290bf678bab764aa58dde19167bc927f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d570aa4290bf678bab764aa58dde19167bc927f5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d570aa4290bf678bab764aa58dde19167bc927f5"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 26,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87a36553072c971d4789ec3af7ff330f1be56ddb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf191a71836f357d7949459f666db506dffd123b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf191a71836f357d7949459f666db506dffd123b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=bf191a71836f357d7949459f666db506dffd123b",
        "patch": "@@ -2374,6 +2374,24 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n         }\n+        // If we're in IBD, we want outbound peers that will serve us a useful\n+        // chain. Disconnect peers that are on chains with insufficient work.\n+        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n+            // headers to fetch from this peer.\n+            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+                // This peer has too little work on their headers chain to help\n+                // us sync -- disconnect if using an outbound slot (unless\n+                // whitelisted or addnode).\n+                // Note: We compare their tip to nMinimumChainWork (rather than\n+                // chainActive.Tip()) because we won't start block download\n+                // until we have a headers chain that has at least\n+                // nMinimumChainWork, even if a peer has a chain past our tip,\n+                if (!(pfrom->fInbound || pfrom->fWhitelisted || pfrom->m_manual_connection)) {\n+                    pfrom->fDisconnect = true;\n+                }\n+            }\n+        }\n         }\n     }\n "
      },
      {
        "sha": "35cd7ad1418079f70692a6a7c4c759f92b7808f5",
        "filename": "test/functional/minchainwork.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf191a71836f357d7949459f666db506dffd123b/test/functional/minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf191a71836f357d7949459f666db506dffd123b/test/functional/minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/minchainwork.py?ref=bf191a71836f357d7949459f666db506dffd123b",
        "patch": "@@ -27,6 +27,7 @@ class MinimumChainWorkTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n+\n         self.extra_args = [[], [\"-minimumchainwork=0x65\"], [\"-minimumchainwork=0x65\"]]\n         self.node_min_work = [0, 101, 101]\n \n@@ -74,6 +75,13 @@ def run_test(self):\n         self.nodes[0].generate(1)\n \n         self.log.info(\"Verifying nodes are all synced\")\n+\n+        # Because nodes in regtest are all manual connections (eg using\n+        # addnode), node1 should not have disconnected node0. If not for that,\n+        # we'd expect node1 to have disconnected node0 for serving an\n+        # insufficient work chain, in which case we'd need to reconnect them to\n+        # continue the test.\n+\n         self.sync_all()\n         self.log.info(\"Blockcounts: %s\", [n.getblockcount() for n in self.nodes])\n "
      }
    ]
  },
  {
    "sha": "9961abf9e469da17a3142697007fb810ca88c145",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTYxYWJmOWU0NjlkYTE3YTMxNDI2OTcwMDdmYjgxMGNhODhjMTQ1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-12T17:55:43Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:18:34Z"
      },
      "message": "Permit disconnection of outbound peers on bad/slow chains\n\nCurrently we have no rotation of outbound peers.  If an outbound peer\nstops serving us blocks, or is on a consensus-incompatible chain with\nless work than our tip (but otherwise valid headers), then we will never\ndisconnect that peer, even though that peer is using one of our 8\noutbound connection slots.  Because we rely on our outbound peers to\nfind an honest node in order to reach consensus, allowing an\nincompatible peer to occupy one of those slots is undesirable,\nparticularly if it is possible for all such slots to be occupied by such\npeers.\n\nProtect against this by always checking to see if a peer's best known\nblock has less work than our tip, and if so, set a 20 minute timeout --\nif the peer is still not known to have caught up to a chain with as much\nwork as ours after 20 minutes, then send a single getheaders message,\nwait 2 more minutes, and if a better header hasn't been received by then,\ndisconnect that peer.\n\nNote:\n\n- we do not require that our peer sync to the same tip as ours, just an\nequal or greater work tip.  (Doing otherwise would risk partitioning the\nnetwork in the event of a chain split, and is also unnecessary.)\n\n- we pick 4 of our outbound peers and do not subject them to this logic,\nto be more conservative. We don't wish to permit temporary network\nissues (or an attacker) to excessively disrupt network topology.\n\nGithub-Pull: #11490\nRebased-From: 5a6d00c6defc587e22c93e63029fdd538ce8858d",
      "tree": {
        "sha": "bd174ea3414f569aa76fbb993d9d144918413acd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd174ea3414f569aa76fbb993d9d144918413acd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9961abf9e469da17a3142697007fb810ca88c145",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9961abf9e469da17a3142697007fb810ca88c145",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9961abf9e469da17a3142697007fb810ca88c145",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9961abf9e469da17a3142697007fb810ca88c145/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bf191a71836f357d7949459f666db506dffd123b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf191a71836f357d7949459f666db506dffd123b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bf191a71836f357d7949459f666db506dffd123b"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 120,
      "deletions": 1
    },
    "files": [
      {
        "sha": "d81a90323f9fa27b662a8dafafeb4149a6985ce2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 112,
        "deletions": 1,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9961abf9e469da17a3142697007fb810ca88c145/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9961abf9e469da17a3142697007fb810ca88c145/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9961abf9e469da17a3142697007fb810ca88c145",
        "patch": "@@ -116,6 +116,9 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads = 0;\n \n+    /** Number of outbound peers with m_chain_sync.m_protect. */\n+    int g_outbound_peers_with_protect_from_disconnect = 0;\n+\n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay;\n@@ -193,6 +196,33 @@ struct CNodeState {\n      */\n     bool fSupportsDesiredCmpctVersion;\n \n+    /** State used to enforce CHAIN_SYNC_TIMEOUT\n+      * Only in effect for outbound, non-manual connections, with\n+      * m_protect == false\n+      * Algorithm: if a peer's best known block has less work than our tip,\n+      * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:\n+      *   - If at timeout their best known block now has more work than our tip\n+      *     when the timeout was set, then either reset the timeout or clear it\n+      *     (after comparing against our current tip's work)\n+      *   - If at timeout their best known block still has less work than our\n+      *     tip did when the timeout was set, then send a getheaders message,\n+      *     and set a shorter timeout, HEADERS_RESPONSE_TIME seconds in future.\n+      *     If their best known block is still behind when that new timeout is\n+      *     reached, disconnect.\n+      */\n+    struct ChainSyncTimeoutState {\n+        //! A timeout used for checking whether our peer has sufficiently synced\n+        int64_t m_timeout;\n+        //! A header with the work we require on our peer's chain\n+        const CBlockIndex * m_work_header;\n+        //! After timeout is reached, set to true after sending getheaders\n+        bool m_sent_getheaders;\n+        //! Whether this peer is protected from disconnection due to a bad/slow chain\n+        bool m_protect;\n+    };\n+\n+    ChainSyncTimeoutState m_chain_sync;\n+\n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n@@ -215,6 +245,7 @@ struct CNodeState {\n         fHaveWitness = false;\n         fWantsCmpctWitness = false;\n         fSupportsDesiredCmpctVersion = false;\n+        m_chain_sync = { 0, nullptr, false, false };\n     }\n };\n \n@@ -495,6 +526,13 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+// Returns true for outbound peers, excluding manual connections, feelers, and\n+// one-shots\n+bool IsOutboundDisconnectionCandidate(const CNode *node)\n+{\n+    return !(node->fInbound || node->m_manual_connection || node->fFeeler || node->fOneShot);\n+}\n+\n void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n@@ -527,6 +565,8 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n+    g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n+    assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n     mapNodeState.erase(nodeid);\n \n@@ -535,6 +575,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n+        assert(g_outbound_peers_with_protect_from_disconnect == 0);\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -2315,6 +2356,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindexLast);\n         UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n \n+        // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n+        // because it is set in UpdateBlockAvailability. Some nullptr checks\n+        // are still present, however, as belt-and-suspenders.\n+\n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n@@ -2387,11 +2432,22 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // chainActive.Tip()) because we won't start block download\n                 // until we have a headers chain that has at least\n                 // nMinimumChainWork, even if a peer has a chain past our tip,\n-                if (!(pfrom->fInbound || pfrom->fWhitelisted || pfrom->m_manual_connection)) {\n+                // as an anti-DoS measure.\n+                if (IsOutboundDisconnectionCandidate(pfrom)) {\n+                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n                     pfrom->fDisconnect = true;\n                 }\n             }\n         }\n+\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n+            // If this is an outbound peer, check to see if we should protect\n+            // it from the bad/lagging chain logic.\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+                nodestate->m_chain_sync.m_protect = true;\n+                ++g_outbound_peers_with_protect_from_disconnect;\n+            }\n+        }\n         }\n     }\n \n@@ -2790,6 +2846,58 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    CNodeState &state = *State(pto->GetId());\n+    const CNetMsgMaker msgMaker(pto->GetSendVersion());\n+\n+    if (!state.m_chain_sync.m_protect && IsOutboundDisconnectionCandidate(pto) && state.fSyncStarted) {\n+        // This is an outbound peer subject to disconnection if they don't\n+        // announce a block with as much work as the current tip within\n+        // CHAIN_SYNC_TIMEOUT + HEADERS_RESPONSE_TIME seconds (note: if\n+        // their chain has more work than ours, we should sync to it,\n+        // unless it's invalid, in which case we should find that out and\n+        // disconnect from them elsewhere).\n+        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork) {\n+            if (state.m_chain_sync.m_timeout != 0) {\n+                state.m_chain_sync.m_timeout = 0;\n+                state.m_chain_sync.m_work_header = nullptr;\n+                state.m_chain_sync.m_sent_getheaders = false;\n+            }\n+        } else if (state.m_chain_sync.m_timeout == 0 || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n+            // Our best block known by this peer is behind our tip, and we're either noticing\n+            // that for the first time, OR this peer was able to catch up to some earlier point\n+            // where we checked against our tip.\n+            // Either way, set a new timeout based on current tip.\n+            state.m_chain_sync.m_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;\n+            state.m_chain_sync.m_work_header = chainActive.Tip();\n+            state.m_chain_sync.m_sent_getheaders = false;\n+        } else if (state.m_chain_sync.m_timeout > 0 && time_in_seconds > state.m_chain_sync.m_timeout) {\n+            // No evidence yet that our peer has synced to a chain with work equal to that\n+            // of our tip, when we first detected it was behind. Send a single getheaders\n+            // message to give the peer a chance to update us.\n+            if (state.m_chain_sync.m_sent_getheaders) {\n+                // They've run out of time to catch up!\n+                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n+                pto->fDisconnect = true;\n+            } else {\n+                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n+                state.m_chain_sync.m_sent_getheaders = true;\n+                constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n+                // Bump the timeout to allow a response, which could clear the timeout\n+                // (if the response shows the peer has synced), reset the timeout (if\n+                // the peer syncs to the required work but not to our tip), or result\n+                // in disconnect (if we advance to the timeout and pindexBestKnownBlock\n+                // has not sufficiently progressed)\n+                state.m_chain_sync.m_timeout = time_in_seconds + HEADERS_RESPONSE_TIME;\n+            }\n+        }\n+    }\n+}\n+\n class CompareInvMempoolOrder\n {\n     CTxMemPool *mp;\n@@ -3256,6 +3364,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n             }\n         }\n \n+        // Check that outbound peers have reasonable chains\n+        // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n+        ConsiderEviction(pto, GetTime());\n \n         //\n         // Message: getdata (blocks)"
      },
      {
        "sha": "656324bba0c4cc327455eed03793ca8ef8007129",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9961abf9e469da17a3142697007fb810ca88c145/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9961abf9e469da17a3142697007fb810ca88c145/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=9961abf9e469da17a3142697007fb810ca88c145",
        "patch": "@@ -21,6 +21,12 @@ static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n  *  Timeout = base + per_header * (expected number of headers) */\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n+/** Protect at least this many outbound peers from disconnection due to slow/\n+ * behind headers chain.\n+ */\n+static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n+/** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n+static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n \n class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n@@ -47,6 +53,8 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     * @return                      True if there is more work to be done\n     */\n     bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n+\n+    void ConsiderEviction(CNode *pto, int64_t time_in_seconds);\n };\n \n struct CNodeStateStats {"
      }
    ]
  },
  {
    "sha": "e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzI3MjI0MmUyNWEzYjhhNGEyYmM0ZWJlYzg1YjI2YWI5ODliOTU5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-19T15:42:47Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:18:44Z"
      },
      "message": "Add unit test for outbound peer eviction\n\nGithub-Pull: #11490\nRebased-From: e065249c014a070a8799b2ff947af5b8f012c5c1",
      "tree": {
        "sha": "bda1a1befb98f5cb105d3f7bc51a0cdae8c1a75d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bda1a1befb98f5cb105d3f7bc51a0cdae8c1a75d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3272242e25a3b8a4a2bc4ebec85b26ab989b959/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9961abf9e469da17a3142697007fb810ca88c145",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9961abf9e469da17a3142697007fb810ca88c145",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9961abf9e469da17a3142697007fb810ca88c145"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 55,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7bcf304833f175596968cec2f3a6cb0dc30f21ca",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3272242e25a3b8a4a2bc4ebec85b26ab989b959/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3272242e25a3b8a4a2bc4ebec85b26ab989b959/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
        "patch": "@@ -42,6 +42,51 @@ static NodeId id = 0;\n \n BOOST_FIXTURE_TEST_SUITE(DoS_tests, TestingSetup)\n \n+// Test eviction of an outbound peer whose chain never advances\n+// Mock a node connection, and use mocktime to simulate a peer\n+// which never sends any headers messages.  PeerLogic should\n+// decide to evict that outbound peer, after the appropriate timeouts.\n+// Note that we protect 4 outbound nodes from being subject to\n+// this logic; this test takes advantage of that protection only\n+// being applied to nodes which send headers with sufficient\n+// work.\n+BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n+{\n+    std::atomic<bool> interruptDummy(false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode dummyNode1(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false);\n+    dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n+\n+    peerLogic->InitializeNode(&dummyNode1);\n+    dummyNode1.nVersion = 1;\n+    dummyNode1.fSuccessfullyConnected = true;\n+\n+    // This test requires that we have a chain with non-zero work.\n+    BOOST_CHECK(chainActive.Tip() != nullptr);\n+    BOOST_CHECK(chainActive.Tip()->nChainWork > 0);\n+\n+    // Test starts here\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+    dummyNode1.vSendMsg.clear();\n+\n+    int64_t nStartTime = GetTime();\n+    // Wait 21 minutes\n+    SetMockTime(nStartTime+21*60);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+    // Wait 3 more minutes\n+    SetMockTime(nStartTime+24*60);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in disconnect\n+    BOOST_CHECK(dummyNode1.fDisconnect == true);\n+    SetMockTime(0);\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+}\n+\n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     std::atomic<bool> interruptDummy(false);\n@@ -71,6 +116,10 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     Misbehaving(dummyNode2.GetId(), 50);\n     peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+    peerLogic->FinalizeNode(dummyNode2.GetId(), dummy);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n@@ -95,6 +144,9 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n@@ -121,6 +173,9 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n \n     SetMockTime(nStartTime+60*60*24+1);\n     BOOST_CHECK(!connman->IsBanned(addr));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode.GetId(), dummy);\n }\n \n CTransactionRef RandomOrphan()"
      }
    ]
  },
  {
    "sha": "fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzk2NmJiZDJiNjU5NmY4YWM2OGVmM2MzNDVkNDdmYmI1ZDdlMGM5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T18:46:17Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:19:47Z"
      },
      "message": "moveonly: factor out headers processing into separate function\n\nProcessMessages will now return earlier when processing headers\nmessages, rather than continuing on (and do nothing).\n\nGithub-Pull: #11568\nRebased-From: 4637f18522429473e68f6f512a03040e121a446d",
      "tree": {
        "sha": "ec98b43ff2ec2338dc33a794baee33b3195bf1af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec98b43ff2ec2338dc33a794baee33b3195bf1af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3272242e25a3b8a4a2bc4ebec85b26ab989b959",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3272242e25a3b8a4a2bc4ebec85b26ab989b959"
      }
    ],
    "stats": {
      "total": 336,
      "additions": 173,
      "deletions": 163
    },
    "files": [
      {
        "sha": "eac2853cd7e1251fa9958cb3942037a7676425f6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 173,
        "deletions": 163,
        "changes": 336,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
        "patch": "@@ -1193,6 +1193,178 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams)\n+{\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    size_t nCount = headers.size();\n+\n+    if (nCount == 0) {\n+        // Nothing interesting. Stop asking this peers for more headers.\n+        return true;\n+    }\n+\n+    const CBlockIndex *pindexLast = nullptr;\n+    {\n+        LOCK(cs_main);\n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // If this looks like it could be a block announcement (nCount <\n+        // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n+        // don't connect:\n+        // - Send a getheaders message in response to try to connect the chain.\n+        // - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that\n+        //   don't connect before giving DoS points\n+        // - Once a headers message is received that is valid and does connect,\n+        //   nUnconnectingHeaders gets reset back to 0.\n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+            nodestate->nUnconnectingHeaders++;\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n+                    headers[0].GetHash().ToString(),\n+                    headers[0].hashPrevBlock.ToString(),\n+                    pindexBestHeader->nHeight,\n+                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n+            // Set hashLastUnknownBlock for this peer, so that if we\n+            // eventually get the headers - even from a different peer -\n+            // we can use this peer to download.\n+            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n+\n+            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n+                Misbehaving(pfrom->GetId(), 20);\n+            }\n+            return true;\n+        }\n+\n+        uint256 hashLastBlock;\n+        for (const CBlockHeader& header : headers) {\n+            if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n+                Misbehaving(pfrom->GetId(), 20);\n+                return error(\"non-continuous headers sequence\");\n+            }\n+            hashLastBlock = header.GetHash();\n+        }\n+    }\n+\n+    CValidationState state;\n+    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n+        int nDoS;\n+        if (state.IsInvalid(nDoS)) {\n+            if (nDoS > 0) {\n+                LOCK(cs_main);\n+                Misbehaving(pfrom->GetId(), nDoS);\n+            }\n+            return error(\"invalid header received\");\n+        }\n+    }\n+\n+    {\n+        LOCK(cs_main);\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (nodestate->nUnconnectingHeaders > 0) {\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n+        }\n+        nodestate->nUnconnectingHeaders = 0;\n+\n+        assert(pindexLast);\n+        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+\n+        // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n+        // because it is set in UpdateBlockAvailability. Some nullptr checks\n+        // are still present, however, as belt-and-suspenders.\n+\n+        if (nCount == MAX_HEADERS_RESULTS) {\n+            // Headers message had its maximum size; the peer may have more headers.\n+            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n+            // from there instead.\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n+        }\n+\n+        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n+        // If this set of headers is valid and ends in a block with at least as\n+        // much work as our tip, download as much as possible.\n+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n+            std::vector<const CBlockIndex*> vToFetch;\n+            const CBlockIndex *pindexWalk = pindexLast;\n+            // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n+            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n+                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n+                    // We don't have this block, and it's not yet in flight.\n+                    vToFetch.push_back(pindexWalk);\n+                }\n+                pindexWalk = pindexWalk->pprev;\n+            }\n+            // If pindexWalk still isn't on our main chain, we're looking at a\n+            // very large reorg at a time we think we're close to caught up to\n+            // the main chain -- this shouldn't really happen.  Bail out on the\n+            // direct fetch and rely on parallel download instead.\n+            if (!chainActive.Contains(pindexWalk)) {\n+                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n+                        pindexLast->GetBlockHash().ToString(),\n+                        pindexLast->nHeight);\n+            } else {\n+                std::vector<CInv> vGetData;\n+                // Download as much as possible, from earliest to latest.\n+                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n+                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                        // Can't download any more from this peer\n+                        break;\n+                    }\n+                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n+                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n+                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n+                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n+                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n+                }\n+                if (vGetData.size() > 1) {\n+                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n+                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n+                }\n+                if (vGetData.size() > 0) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                        // In any case, we want to download using a compact block, not a regular one\n+                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n+                    }\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                }\n+            }\n+        }\n+        // If we're in IBD, we want outbound peers that will serve us a useful\n+        // chain. Disconnect peers that are on chains with insufficient work.\n+        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n+            // headers to fetch from this peer.\n+            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+                // This peer has too little work on their headers chain to help\n+                // us sync -- disconnect if using an outbound slot (unless\n+                // whitelisted or addnode).\n+                // Note: We compare their tip to nMinimumChainWork (rather than\n+                // chainActive.Tip()) because we won't start block download\n+                // until we have a headers chain that has at least\n+                // nMinimumChainWork, even if a peer has a chain past our tip,\n+                // as an anti-DoS measure.\n+                if (IsOutboundDisconnectionCandidate(pfrom)) {\n+                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n+                    pfrom->fDisconnect = true;\n+                }\n+            }\n+        }\n+\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n+            // If this is an outbound peer, check to see if we should protect\n+            // it from the bad/lagging chain logic.\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+                nodestate->m_chain_sync.m_protect = true;\n+                ++g_outbound_peers_with_protect_from_disconnect;\n+            }\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n@@ -2286,169 +2458,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        if (nCount == 0) {\n-            // Nothing interesting. Stop asking this peers for more headers.\n-            return true;\n-        }\n-\n-        const CBlockIndex *pindexLast = nullptr;\n-        {\n-        LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n-\n-        // If this looks like it could be a block announcement (nCount <\n-        // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n-        // don't connect:\n-        // - Send a getheaders message in response to try to connect the chain.\n-        // - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that\n-        //   don't connect before giving DoS points\n-        // - Once a headers message is received that is valid and does connect,\n-        //   nUnconnectingHeaders gets reset back to 0.\n-        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n-            nodestate->nUnconnectingHeaders++;\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n-            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n-                    headers[0].GetHash().ToString(),\n-                    headers[0].hashPrevBlock.ToString(),\n-                    pindexBestHeader->nHeight,\n-                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n-            // Set hashLastUnknownBlock for this peer, so that if we\n-            // eventually get the headers - even from a different peer -\n-            // we can use this peer to download.\n-            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n-\n-            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n-                Misbehaving(pfrom->GetId(), 20);\n-            }\n-            return true;\n-        }\n-\n-        uint256 hashLastBlock;\n-        for (const CBlockHeader& header : headers) {\n-            if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n-                Misbehaving(pfrom->GetId(), 20);\n-                return error(\"non-continuous headers sequence\");\n-            }\n-            hashLastBlock = header.GetHash();\n-        }\n-        }\n-\n-        CValidationState state;\n-        if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n-            int nDoS;\n-            if (state.IsInvalid(nDoS)) {\n-                if (nDoS > 0) {\n-                    LOCK(cs_main);\n-                    Misbehaving(pfrom->GetId(), nDoS);\n-                }\n-                return error(\"invalid header received\");\n-            }\n-        }\n-\n-        {\n-        LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n-        if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n-        }\n-        nodestate->nUnconnectingHeaders = 0;\n-\n-        assert(pindexLast);\n-        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n-\n-        // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n-        // because it is set in UpdateBlockAvailability. Some nullptr checks\n-        // are still present, however, as belt-and-suspenders.\n-\n-        if (nCount == MAX_HEADERS_RESULTS) {\n-            // Headers message had its maximum size; the peer may have more headers.\n-            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n-            // from there instead.\n-            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n-        }\n-\n-        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n-        // If this set of headers is valid and ends in a block with at least as\n-        // much work as our tip, download as much as possible.\n-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n-            std::vector<const CBlockIndex*> vToFetch;\n-            const CBlockIndex *pindexWalk = pindexLast;\n-            // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n-            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n-                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n-                    // We don't have this block, and it's not yet in flight.\n-                    vToFetch.push_back(pindexWalk);\n-                }\n-                pindexWalk = pindexWalk->pprev;\n-            }\n-            // If pindexWalk still isn't on our main chain, we're looking at a\n-            // very large reorg at a time we think we're close to caught up to\n-            // the main chain -- this shouldn't really happen.  Bail out on the\n-            // direct fetch and rely on parallel download instead.\n-            if (!chainActive.Contains(pindexWalk)) {\n-                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n-                        pindexLast->GetBlockHash().ToString(),\n-                        pindexLast->nHeight);\n-            } else {\n-                std::vector<CInv> vGetData;\n-                // Download as much as possible, from earliest to latest.\n-                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n-                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                        // Can't download any more from this peer\n-                        break;\n-                    }\n-                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n-                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n-                }\n-                if (vGetData.size() > 1) {\n-                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n-                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n-                }\n-                if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n-                        // In any case, we want to download using a compact block, not a regular one\n-                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n-                    }\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                }\n-            }\n-        }\n-        // If we're in IBD, we want outbound peers that will serve us a useful\n-        // chain. Disconnect peers that are on chains with insufficient work.\n-        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n-            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n-            // headers to fetch from this peer.\n-            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n-                // This peer has too little work on their headers chain to help\n-                // us sync -- disconnect if using an outbound slot (unless\n-                // whitelisted or addnode).\n-                // Note: We compare their tip to nMinimumChainWork (rather than\n-                // chainActive.Tip()) because we won't start block download\n-                // until we have a headers chain that has at least\n-                // nMinimumChainWork, even if a peer has a chain past our tip,\n-                // as an anti-DoS measure.\n-                if (IsOutboundDisconnectionCandidate(pfrom)) {\n-                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n-                    pfrom->fDisconnect = true;\n-                }\n-            }\n-        }\n-\n-        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n-            // If this is an outbound peer, check to see if we should protect\n-            // it from the bad/lagging chain logic.\n-            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n-                nodestate->m_chain_sync.m_protect = true;\n-                ++g_outbound_peers_with_protect_from_disconnect;\n-            }\n-        }\n-        }\n+        return ProcessHeadersMessage(pfrom, connman, headers, chainparams);\n     }\n \n     else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing"
      }
    ]
  },
  {
    "sha": "59b210d9a7fec79afba07d2ea90b190ce1d74209",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OWIyMTBkOWE3ZmVjNzlhZmJhMDdkMmVhOTBiMTkwY2UxZDc0MjA5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T18:54:33Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:19:57Z"
      },
      "message": "Disconnect outbound peers relaying invalid headers\n\nGithub-Pull: #11568\nRebased-From: 37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
      "tree": {
        "sha": "95faab56ca70a01a261875fb84bb3aa8e179a291",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95faab56ca70a01a261875fb84bb3aa8e179a291"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/59b210d9a7fec79afba07d2ea90b190ce1d74209",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/59b210d9a7fec79afba07d2ea90b190ce1d74209",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/59b210d9a7fec79afba07d2ea90b190ce1d74209",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/59b210d9a7fec79afba07d2ea90b190ce1d74209/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc966bbd2b6596f8ac68ef3c345d47fbb5d7e0c9"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 56,
      "deletions": 12
    },
    "files": [
      {
        "sha": "f677915de12eaa36473299647061e38f3d548984",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 10,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/59b210d9a7fec79afba07d2ea90b190ce1d74209/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/59b210d9a7fec79afba07d2ea90b190ce1d74209/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=59b210d9a7fec79afba07d2ea90b190ce1d74209",
        "patch": "@@ -1193,7 +1193,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams)\n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool punish_duplicate_invalid)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1246,13 +1246,48 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     }\n \n     CValidationState state;\n-    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n+    CBlockHeader first_invalid_header;\n+    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             if (nDoS > 0) {\n                 LOCK(cs_main);\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n+            if (punish_duplicate_invalid && mapBlockIndex.find(first_invalid_header.GetHash()) != mapBlockIndex.end()) {\n+                // Goal: don't allow outbound peers to use up our outbound\n+                // connection slots if they are on incompatible chains.\n+                //\n+                // We ask the caller to set punish_invalid appropriately based\n+                // on the peer and the method of header delivery (compact\n+                // blocks are allowed to be invalid in some circumstances,\n+                // under BIP 152).\n+                // Here, we try to detect the narrow situation that we have a\n+                // valid block header (ie it was valid at the time the header\n+                // was received, and hence stored in mapBlockIndex) but know the\n+                // block is invalid, and that a peer has announced that same\n+                // block as being on its active chain.\n+                // Disconnect the peer in such a situation.\n+                //\n+                // Note: if the header that is invalid was not accepted to our\n+                // mapBlockIndex at all, that may also be grounds for\n+                // disconnecting the peer, as the chain they are on is likely\n+                // to be incompatible. However, there is a circumstance where\n+                // that does not hold: if the header's timestamp is more than\n+                // 2 hours ahead of our current time. In that case, the header\n+                // may become valid in the future, and we don't want to\n+                // disconnect a peer merely for serving us one too-far-ahead\n+                // block header, to prevent an attacker from splitting the\n+                // network by mining a block right at the 2 hour boundary.\n+                //\n+                // TODO: update the DoS logic (or, rather, rewrite the\n+                // DoS-interface between validation and net_processing) so that\n+                // the interface is cleaner, and so that we disconnect on all the\n+                // reasons that a peer's headers chain is incompatible\n+                // with ours (eg block->nVersion softforks, MTP violations,\n+                // etc), and not just the duplicate-invalid case.\n+                pfrom->fDisconnect = true;\n+            }\n             return error(\"invalid header received\");\n         }\n     }\n@@ -2197,7 +2232,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // If we end up treating this as a plain headers message, call that as well\n         // without cs_main.\n         bool fRevertToHeaderProcessing = false;\n-        CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n \n         // Keep a CBlock for \"optimistic\" compactblock reconstructions (see\n         // below)\n@@ -2314,10 +2348,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n-                // Dirty hack to process as if it were just a headers message (TODO: move message handling into their own functions)\n-                std::vector<CBlock> headers;\n-                headers.push_back(cmpctblock.header);\n-                vHeadersMsg << headers;\n                 fRevertToHeaderProcessing = true;\n             }\n         }\n@@ -2326,8 +2356,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (fProcessBLOCKTXN)\n             return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n \n-        if (fRevertToHeaderProcessing)\n-            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n+        if (fRevertToHeaderProcessing) {\n+            // Headers received from HB compact block peers are permitted to be\n+            // relayed before full validation (see BIP 152), so we don't want to disconnect\n+            // the peer if the header turns out to be for an invalid block.\n+            // Note that if a peer tries to build on an invalid chain, that\n+            // will be detected and the peer will be banned.\n+            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false);\n+        }\n \n         if (fBlockReconstructed) {\n             // If we got here, we were able to optimistically reconstruct a\n@@ -2458,7 +2494,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        return ProcessHeadersMessage(pfrom, connman, headers, chainparams);\n+        // Headers received via a HEADERS message should be valid, and reflect\n+        // the chain the peer is on. If we receive a known-invalid header,\n+        // disconnect the peer if it is using one of our outbound connection\n+        // slots.\n+        bool should_punish = !pfrom->fInbound && !pfrom->m_manual_connection;\n+        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish);\n     }\n \n     else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing"
      },
      {
        "sha": "c52f8bf70b6037513e0c2c457d0a132f1d35a34a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/59b210d9a7fec79afba07d2ea90b190ce1d74209/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/59b210d9a7fec79afba07d2ea90b190ce1d74209/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=59b210d9a7fec79afba07d2ea90b190ce1d74209",
        "patch": "@@ -3064,13 +3064,15 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n }\n \n // Exposed wrapper for AcceptBlockHeader\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex)\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex, CBlockHeader *first_invalid)\n {\n+    if (first_invalid != nullptr) first_invalid->SetNull();\n     {\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n             if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {\n+                if (first_invalid) *first_invalid = header;\n                 return false;\n             }\n             if (ppindex) {"
      },
      {
        "sha": "4acdac81c92690d01b8758ef18a4f8e3916cc947",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/59b210d9a7fec79afba07d2ea90b190ce1d74209/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/59b210d9a7fec79afba07d2ea90b190ce1d74209/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=59b210d9a7fec79afba07d2ea90b190ce1d74209",
        "patch": "@@ -248,8 +248,9 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n  * @param[out] state This may be set to an Error state if any error occurred processing them\n  * @param[in]  chainparams The params for the chain we want to connect to\n  * @param[out] ppindex If set, the pointer will be set to point to the last new block index object for the given headers\n+ * @param[out] first_invalid First header that fails validation, if one exists\n  */\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr);\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr, CBlockHeader *first_invalid=nullptr);\n \n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);"
      }
    ]
  },
  {
    "sha": "ec8dedff4683220cb30b69df7f987546536565ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzhkZWRmZjQ2ODMyMjBjYjMwYjY5ZGY3Zjk4NzU0NjUzNjU2NWFi",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-10-30T13:28:19Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:20:18Z"
      },
      "message": "net: Add missing lock in ProcessHeadersMessage(...)\n\nReading the variable mapBlockIndex requires holding the mutex cs_main.\n\nThe new \"Disconnect outbound peers relaying invalid headers\" code\nadded in commit 37886d5e2f9992678dea4b1bd893f4f10d61d3ad and merged\nas part of #11568 two days ago did not lock cs_main prior to accessing\nmapBlockIndex.\n\nGithub-Pull: #11578\nRebased-From: 2530bf27b72e53cc6ffec27de35f3b487984833d",
      "tree": {
        "sha": "7f1a9b70ea2cf5d87493dec9af543fe2d0d803c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f1a9b70ea2cf5d87493dec9af543fe2d0d803c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec8dedff4683220cb30b69df7f987546536565ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec8dedff4683220cb30b69df7f987546536565ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec8dedff4683220cb30b69df7f987546536565ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec8dedff4683220cb30b69df7f987546536565ab/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "59b210d9a7fec79afba07d2ea90b190ce1d74209",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/59b210d9a7fec79afba07d2ea90b190ce1d74209",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/59b210d9a7fec79afba07d2ea90b190ce1d74209"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "69db5d74283c6ea91880f064ad28b7543d289377",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec8dedff4683220cb30b69df7f987546536565ab/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec8dedff4683220cb30b69df7f987546536565ab/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ec8dedff4683220cb30b69df7f987546536565ab",
        "patch": "@@ -1250,8 +1250,8 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n+            LOCK(cs_main);\n             if (nDoS > 0) {\n-                LOCK(cs_main);\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n             if (punish_duplicate_invalid && mapBlockIndex.find(first_invalid_header.GetHash()) != mapBlockIndex.end()) {"
      }
    ]
  },
  {
    "sha": "e976c36ddf183982d172da3127dc613111a25b42",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTc2YzM2ZGRmMTgzOTgyZDE3MmRhMzEyN2RjNjEzMTExYTI1YjQy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T19:38:56Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:20:38Z"
      },
      "message": "Rewrite p2p-acceptblock in preparation for slight behavior changes\n\nRemoves checking whitelisted behavior (which will be removed, the\ndifference in behavior here makes little sense) and no longer\nrequires that blocks at the same work as our tip be dropped if not\nrequested (in part because we *do* request those blocks).\n\nGithub-Pull: #11531\nRebased-From: 3b4ac43bc371561b5fa559bccb17dc0702bd4b69",
      "tree": {
        "sha": "a0cd0f54ef0e3bf212632a996b11f75e3d099c87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0cd0f54ef0e3bf212632a996b11f75e3d099c87"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e976c36ddf183982d172da3127dc613111a25b42",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e976c36ddf183982d172da3127dc613111a25b42",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e976c36ddf183982d172da3127dc613111a25b42",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e976c36ddf183982d172da3127dc613111a25b42/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec8dedff4683220cb30b69df7f987546536565ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec8dedff4683220cb30b69df7f987546536565ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec8dedff4683220cb30b69df7f987546536565ab"
      }
    ],
    "stats": {
      "total": 236,
      "additions": 122,
      "deletions": 114
    },
    "files": [
      {
        "sha": "9b2c1a73fc2f2f49f0eee3db4d61c452d1d87e0a",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 122,
        "deletions": 114,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e976c36ddf183982d172da3127dc613111a25b42/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e976c36ddf183982d172da3127dc613111a25b42/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=e976c36ddf183982d172da3127dc613111a25b42",
        "patch": "@@ -4,42 +4,32 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test processing of unrequested blocks.\n \n-Since behavior differs when receiving unrequested blocks from whitelisted peers\n-versus non-whitelisted peers, this tests the behavior of both (effectively two\n-separate tests running in parallel).\n+Setup: two nodes, node0+node1, not connected to each other. Node1 will have\n+nMinimumChainWork set to 0x10, so it won't process low-work unrequested blocks.\n \n-Setup: three nodes, node0+node1+node2, not connected to each other.  Node0 does not\n-whitelist localhost, but node1 does. They will each be on their own chain for\n-this test.  Node2 will have nMinimumChainWork set to 0x10, so it won't process\n-low-work unrequested blocks.\n-\n-We have one NodeConn connection to each, test_node, white_node, and min_work_node,\n-respectively.\n+We have one NodeConn connection to node0 called test_node, and one to node1\n+called min_work_node.\n \n The test:\n 1. Generate one block on each node, to leave IBD.\n \n 2. Mine a new block on each tip, and deliver to each node from node's peer.\n-   The tip should advance for node0 and node1, but node2 should skip processing\n-   due to nMinimumChainWork.\n+   The tip should advance for node0, but node1 should skip processing due to\n+   nMinimumChainWork.\n \n-Node2 is unused in tests 3-7:\n+Node1 is unused in tests 3-7:\n \n-3. Mine a block that forks the previous block, and deliver to each node from\n-   corresponding peer.\n-   Node0 should not process this block (just accept the header), because it is\n-   unrequested and doesn't have more work than the tip.\n-   Node1 should process because this is coming from a whitelisted peer.\n+3. Mine a block that forks from the genesis block, and deliver to test_node.\n+   Node0 should not process this block (just accept the header), because it\n+   is unrequested and doesn't have more or equal work to the tip.\n \n-4. Send another block that builds on the forking block.\n-   Node0 should process this block but be stuck on the shorter chain, because\n-   it's missing an intermediate block.\n-   Node1 should reorg to this longer chain.\n+4a,b. Send another two blocks that build on the forking block.\n+   Node0 should process the second block but be stuck on the shorter chain,\n+   because it's missing an intermediate block.\n \n-4b.Send 288 more blocks on the longer chain.\n+4c.Send 288 more blocks on the longer chain (the number of blocks ahead\n+   we currently store).\n    Node0 should process all but the last block (too far ahead in height).\n-   Send all headers to Node1, and then send the last block in that chain.\n-   Node1 should accept the block because it's coming from a whitelisted peer.\n \n 5. Send a duplicate of the block in #3 to Node0.\n    Node0 should not process the block because it is unrequested, and stay on\n@@ -52,7 +42,7 @@\n 7. Send Node0 the missing block again.\n    Node0 should process and the tip should advance.\n \n-8. Test Node2 is able to sync when connected to node0 (which should have sufficient\n+8. Test Node1 is able to sync when connected to node0 (which should have sufficient\n work on its chain).\n \n \"\"\"\n@@ -71,8 +61,8 @@ def add_options(self, parser):\n \n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 3\n-        self.extra_args = [[], [\"-whitelist=127.0.0.1\"], [\"-minimumchainwork=0x10\"]]\n+        self.num_nodes = 2\n+        self.extra_args = [[], [\"-minimumchainwork=0x10\"]]\n \n     def setup_network(self):\n         # Node0 will be used to test behavior of processing unrequested blocks\n@@ -84,132 +74,149 @@ def setup_network(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = NodeConnCB()   # connects to node0 (not whitelisted)\n-        white_node = NodeConnCB()  # connects to node1 (whitelisted)\n-        min_work_node = NodeConnCB()  # connects to node2 (not whitelisted)\n+        test_node = NodeConnCB()   # connects to node0\n+        min_work_node = NodeConnCB()  # connects to node1\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], white_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], min_work_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], min_work_node))\n         test_node.add_connection(connections[0])\n-        white_node.add_connection(connections[1])\n-        min_work_node.add_connection(connections[2])\n+        min_work_node.add_connection(connections[1])\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # Test logic begins here\n         test_node.wait_for_verack()\n-        white_node.wait_for_verack()\n         min_work_node.wait_for_verack()\n \n-        # 1. Have nodes mine a block (nodes1/2 leave IBD)\n+        # 1. Have nodes mine a block (leave IBD)\n         [ n.generate(1) for n in self.nodes ]\n         tips = [ int(\"0x\" + n.getbestblockhash(), 0) for n in self.nodes ]\n \n         # 2. Send one block that builds on each tip.\n-        # This should be accepted by nodes 1/2\n+        # This should be accepted by node0\n         blocks_h2 = []  # the height 2 blocks on each node's chain\n         block_time = int(time.time()) + 1\n-        for i in range(3):\n+        for i in range(2):\n             blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))\n             blocks_h2[i].solve()\n             block_time += 1\n         test_node.send_message(msg_block(blocks_h2[0]))\n-        white_node.send_message(msg_block(blocks_h2[1]))\n-        min_work_node.send_message(msg_block(blocks_h2[2]))\n+        min_work_node.send_message(msg_block(blocks_h2[1]))\n \n-        for x in [test_node, white_node, min_work_node]:\n+        for x in [test_node, min_work_node]:\n             x.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n-        assert_equal(self.nodes[1].getblockcount(), 2)\n-        assert_equal(self.nodes[2].getblockcount(), 1)\n-        self.log.info(\"First height 2 block accepted by node0/node1; correctly rejected by node2\")\n+        assert_equal(self.nodes[1].getblockcount(), 1)\n+        self.log.info(\"First height 2 block accepted by node0; correctly rejected by node1\")\n \n-        # 3. Send another block that builds on the original tip.\n-        blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n-        for i in range(2):\n-            blocks_h2f.append(create_block(tips[i], create_coinbase(2), blocks_h2[i].nTime+1))\n-            blocks_h2f[i].solve()\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n-        white_node.send_message(msg_block(blocks_h2f[1]))\n+        # 3. Send another block that builds on genesis.\n+        block_h1f = create_block(int(\"0x\" + self.nodes[0].getblockhash(0), 0), create_coinbase(1), block_time)\n+        block_time += 1\n+        block_h1f.solve()\n+        test_node.send_message(msg_block(block_h1f))\n \n-        for x in [test_node, white_node]:\n-            x.sync_with_ping()\n+        test_node.sync_with_ping()\n+        tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n-            if x['hash'] == blocks_h2f[0].hash:\n+            if x['hash'] == block_h1f.hash:\n                 assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_h1f.hash)\n+\n+        # 4. Send another two block that build on the fork.\n+        block_h2f = create_block(block_h1f.sha256, create_coinbase(2), block_time)\n+        block_time += 1\n+        block_h2f.solve()\n+        test_node.send_message(msg_block(block_h2f))\n \n-        for x in self.nodes[1].getchaintips():\n-            if x['hash'] == blocks_h2f[1].hash:\n-                assert_equal(x['status'], \"valid-headers\")\n+        test_node.sync_with_ping()\n+        # Since the earlier block was not processed by node, the new block\n+        # can't be fully validated.\n+        tip_entry_found = False\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == block_h2f.hash:\n+                assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n \n-        self.log.info(\"Second height 2 block accepted only from whitelisted peer\")\n+        # But this block should be accepted by node since it has equal work.\n+        # TODO: We currently drop this block but likely shouldn't\n+        #self.nodes[0].getblock(block_h2f.hash)\n+        self.log.info(\"Second height 2 block accepted, but not reorg'ed to\")\n \n-        # 4. Now send another block that builds on the forking chain.\n-        blocks_h3 = []\n-        for i in range(2):\n-            blocks_h3.append(create_block(blocks_h2f[i].sha256, create_coinbase(3), blocks_h2f[i].nTime+1))\n-            blocks_h3[i].solve()\n-        test_node.send_message(msg_block(blocks_h3[0]))\n-        white_node.send_message(msg_block(blocks_h3[1]))\n+        # 4b. Now send another block that builds on the forking chain.\n+        block_h3 = create_block(block_h2f.sha256, create_coinbase(3), block_h2f.nTime+1)\n+        block_h3.solve()\n+        test_node.send_message(msg_block(block_h3))\n \n-        for x in [test_node, white_node]:\n-            x.sync_with_ping()\n-        # Since the earlier block was not processed by node0, the new block\n+        test_node.sync_with_ping()\n+        # Since the earlier block was not processed by node, the new block\n         # can't be fully validated.\n+        tip_entry_found = False\n         for x in self.nodes[0].getchaintips():\n-            if x['hash'] == blocks_h3[0].hash:\n+            if x['hash'] == block_h3.hash:\n                 assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+        self.nodes[0].getblock(block_h3.hash)\n+\n+        # But this block should be accepted by node since it has more work.\n+        self.nodes[0].getblock(block_h3.hash)\n+        self.log.info(\"Unrequested more-work block accepted\")\n+\n+        # 4c. Now mine 288 more blocks and deliver; all should be processed but\n+        # the last (height-too-high) on node (as long as its not missing any headers)\n+        tip = block_h3\n+        all_blocks = []\n+        for i in range(288):\n+            next_block = create_block(tip.sha256, create_coinbase(i + 4), tip.nTime+1)\n+            next_block.solve()\n+            all_blocks.append(next_block)\n+            tip = next_block\n+\n+        # Now send the block at height 5 and check that it wasn't accepted (missing header)\n+        test_node.send_message(msg_block(all_blocks[1]))\n+        test_node.sync_with_ping()\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblock, all_blocks[1].hash)\n+        assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getblockheader, all_blocks[1].hash)\n \n-        # But this block should be accepted by node0 since it has more work.\n-        self.nodes[0].getblock(blocks_h3[0].hash)\n-        self.log.info(\"Unrequested more-work block accepted from non-whitelisted peer\")\n+        # The block at height 5 should be accepted if we provide the missing header, though\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(all_blocks[0]))\n+        test_node.send_message(headers_message)\n+        test_node.send_message(msg_block(all_blocks[1]))\n+        test_node.sync_with_ping()\n+        self.nodes[0].getblock(all_blocks[1].hash)\n \n-        # Node1 should have accepted and reorged.\n-        assert_equal(self.nodes[1].getblockcount(), 3)\n-        self.log.info(\"Successfully reorged to length 3 chain from whitelisted peer\")\n+        # Now send the blocks in all_blocks\n+        for i in range(288):\n+            test_node.send_message(msg_block(all_blocks[i]))\n+        test_node.sync_with_ping()\n \n-        # 4b. Now mine 288 more blocks and deliver; all should be processed but\n-        # the last (height-too-high) on node0.  Node1 should process the tip if\n-        # we give it the headers chain leading to the tip.\n-        tips = blocks_h3\n-        headers_message = msg_headers()\n-        all_blocks = []   # node0's blocks\n-        for j in range(2):\n-            for i in range(288):\n-                next_block = create_block(tips[j].sha256, create_coinbase(i + 4), tips[j].nTime+1)\n-                next_block.solve()\n-                if j==0:\n-                    test_node.send_message(msg_block(next_block))\n-                    all_blocks.append(next_block)\n-                else:\n-                    headers_message.headers.append(CBlockHeader(next_block))\n-                tips[j] = next_block\n-\n-        time.sleep(2)\n         # Blocks 1-287 should be accepted, block 288 should be ignored because it's too far ahead\n         for x in all_blocks[:-1]:\n             self.nodes[0].getblock(x.hash)\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[-1].hash)\n \n-        headers_message.headers.pop() # Ensure the last block is unrequested\n-        white_node.send_message(headers_message) # Send headers leading to tip\n-        white_node.send_message(msg_block(tips[1]))  # Now deliver the tip\n-        white_node.sync_with_ping()\n-        self.nodes[1].getblock(tips[1].hash)\n-        self.log.info(\"Unrequested block far ahead of tip accepted from whitelisted peer\")\n-\n         # 5. Test handling of unrequested block on the node that didn't process\n         # Should still not be processed (even though it has a child that has more\n         # work).\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n \n-        # Here, if the sleep is too short, the test could falsely succeed (if the\n-        # node hasn't processed the block by the time the sleep returns, and then\n-        # the node processes it and incorrectly advances the tip).\n-        # But this would be caught later on, when we verify that an inv triggers\n-        # a getdata request for this block.\n+        # The node should have requested the blocks at some point, so\n+        # disconnect/reconnect first\n+        connections[0].disconnect_node()\n+        test_node.wait_for_disconnect()\n+\n+        test_node = NodeConnCB()   # connects to node (not whitelisted)\n+        connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n+        test_node.add_connection(connections[0])\n+\n+        test_node.wait_for_verack()\n+        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_message(msg_block(block_h2f)) # This should not be required\n+\n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         self.log.info(\"Unrequested block that would complete more-work chain was ignored\")\n@@ -220,27 +227,28 @@ def run_test(self):\n         with mininode_lock:\n             # Clear state so we can check the getdata request\n             test_node.last_message.pop(\"getdata\", None)\n-            test_node.send_message(msg_inv([CInv(2, blocks_h3[0].sha256)]))\n+            test_node.send_message(msg_inv([CInv(2, block_h3.sha256)]))\n \n         test_node.sync_with_ping()\n         with mininode_lock:\n             getdata = test_node.last_message[\"getdata\"]\n \n         # Check that the getdata includes the right block\n-        assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)\n+        assert_equal(getdata.inv[0].hash, block_h1f.sha256)\n         self.log.info(\"Inv at tip triggered getdata for unprocessed block\")\n \n         # 7. Send the missing block for the third time (now it is requested)\n-        test_node.send_message(msg_block(blocks_h2f[0]))\n+        test_node.send_message(msg_block(block_h1f))\n+        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n-        # 8. Connect node2 to node0 and ensure it is able to sync\n-        connect_nodes(self.nodes[0], 2)\n-        sync_blocks([self.nodes[0], self.nodes[2]])\n-        self.log.info(\"Successfully synced nodes 2 and 0\")\n+        # 8. Connect node1 to node0 and ensure it is able to sync\n+        connect_nodes(self.nodes[0], 1)\n+        sync_blocks([self.nodes[0], self.nodes[1]])\n+        self.log.info(\"Successfully synced nodes 1 and 0\")\n \n         [ c.disconnect_node() for c in connections ]\n "
      }
    ]
  },
  {
    "sha": "c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmU0ZDBjZTgyY2ZkOWZiNzc1YmE1Y2E1ODc0YWYyMDc1ODU4Mzdi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:01:51Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:20:45Z"
      },
      "message": "Stop always storing blocks from whitelisted peers\n\nThere is no reason to wish to store blocks on disk always just\nbecause a peer is whitelisted. This appears to be a historical\nquirk to avoid breaking things when the accept limits were added.\n\nGithub-Pull: #11531\nRebased-From: 3d9c70ca0fd5d42f31114b689714af1825f0ed30",
      "tree": {
        "sha": "c48fc38eeb17af46c9cb054a8d7703e3361c6a31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c48fc38eeb17af46c9cb054a8d7703e3361c6a31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6e4d0ce82cfd9fb775ba5ca5874af207585837b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e976c36ddf183982d172da3127dc613111a25b42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e976c36ddf183982d172da3127dc613111a25b42",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e976c36ddf183982d172da3127dc613111a25b42"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 1,
      "deletions": 5
    },
    "files": [
      {
        "sha": "0697c6bea57e6318d23a820cd2e14b6bbfc5acc5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6e4d0ce82cfd9fb775ba5ca5874af207585837b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6e4d0ce82cfd9fb775ba5ca5874af207585837b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
        "patch": "@@ -2509,11 +2509,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n-        // Process all blocks from whitelisted peers, even if not requested,\n-        // unless we're still syncing with the network.\n-        // Such an unrequested block may still be processed, subject to the\n-        // conditions in AcceptBlock().\n-        bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n+        bool forceProcessing = false;\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);"
      }
    ]
  },
  {
    "sha": "51001d684b1b26ea5109986b7317ffe24bf71b43",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MTAwMWQ2ODRiMWIyNmVhNTEwOTk4NmI3MzE3ZmZlMjRiZjcxYjQz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:04:13Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:20:53Z"
      },
      "message": "Accept unrequested blocks with work equal to our tip\n\nThis is a simple change that makes our accept requirements the\nsame as our request requirements, (ever so slightly) further\ndecoupling our consensus logic from our FindNextBlocksToDownload\nlogic in net_processing.\n\nGithub-Pull: #11531\nRebased-From: 932f118e6a3779bb3d6c3cc83963cf34ac150e42",
      "tree": {
        "sha": "28ea95b7324d688fff13fd90a678800a49857a31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28ea95b7324d688fff13fd90a678800a49857a31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51001d684b1b26ea5109986b7317ffe24bf71b43",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51001d684b1b26ea5109986b7317ffe24bf71b43",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51001d684b1b26ea5109986b7317ffe24bf71b43",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51001d684b1b26ea5109986b7317ffe24bf71b43/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6e4d0ce82cfd9fb775ba5ca5874af207585837b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6e4d0ce82cfd9fb775ba5ca5874af207585837b"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 5,
      "deletions": 8
    },
    "files": [
      {
        "sha": "c641cae7e9b6543f6a610e62d896e728eb742bfa",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51001d684b1b26ea5109986b7317ffe24bf71b43/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51001d684b1b26ea5109986b7317ffe24bf71b43/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=51001d684b1b26ea5109986b7317ffe24bf71b43",
        "patch": "@@ -3102,7 +3102,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);\n+    bool fHasMoreOrSameWork = (chainActive.Tip() ? pindex->nChainWork >= chainActive.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n@@ -3119,9 +3119,9 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     // and unrequested blocks.\n     if (fAlreadyHave) return true;\n     if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n-        if (!fHasMoreWork) return true;     // Don't process less-work chains\n-        if (fTooFarAhead) return true;      // Block height is too high\n+        if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n+        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n+        if (fTooFarAhead) return true;        // Block height is too high\n \n         // Protect against DoS attacks from low-work chains.\n         // If our tip is behind, a peer could try to send us"
      },
      {
        "sha": "36e0bd9ec68ce95bcb70e0e6135ac0f7dd631833",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51001d684b1b26ea5109986b7317ffe24bf71b43/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51001d684b1b26ea5109986b7317ffe24bf71b43/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=51001d684b1b26ea5109986b7317ffe24bf71b43",
        "patch": "@@ -142,8 +142,7 @@ def run_test(self):\n         assert(tip_entry_found)\n \n         # But this block should be accepted by node since it has equal work.\n-        # TODO: We currently drop this block but likely shouldn't\n-        #self.nodes[0].getblock(block_h2f.hash)\n+        self.nodes[0].getblock(block_h2f.hash)\n         self.log.info(\"Second height 2 block accepted, but not reorg'ed to\")\n \n         # 4b. Now send another block that builds on the forking chain.\n@@ -215,7 +214,6 @@ def run_test(self):\n \n         test_node.wait_for_verack()\n         test_node.send_message(msg_block(block_h1f))\n-        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n@@ -239,7 +237,6 @@ def run_test(self):\n \n         # 7. Send the missing block for the third time (now it is requested)\n         test_node.send_message(msg_block(block_h1f))\n-        test_node.send_message(msg_block(block_h2f)) # This should not be required\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)"
      }
    ]
  },
  {
    "sha": "92d6105c4e571e557348771bf39bf7bbacc81cd1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MmQ2MTA1YzRlNTcxZTU1NzM0ODc3MWJmMzliZjdiYmFjYzgxY2Qx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-19T20:55:31Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:21:07Z"
      },
      "message": "Reject headers building on invalid chains by tracking invalidity\n\nThis tracks the set of all known invalid-themselves blocks (ie\nblocks which we attempted to connect but which were found to be\ninvalid). This is used to cheaply check if new headers build on an\ninvalid chain.\n\nWhile we're at it we also resolve an edge-case in invalidateblock\non pruned nodes which results in them needing a reindex if they\nfail to reorg.\n\nGithub-Pull: #11531\nRebased-From: 015a5258adffb0cf394f387a95ac9c8afc34cfc3",
      "tree": {
        "sha": "be7a9abc595acbf2e60835fb4751bf0af329ad7d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/be7a9abc595acbf2e60835fb4751bf0af329ad7d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92d6105c4e571e557348771bf39bf7bbacc81cd1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92d6105c4e571e557348771bf39bf7bbacc81cd1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92d6105c4e571e557348771bf39bf7bbacc81cd1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92d6105c4e571e557348771bf39bf7bbacc81cd1/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "51001d684b1b26ea5109986b7317ffe24bf71b43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51001d684b1b26ea5109986b7317ffe24bf71b43",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/51001d684b1b26ea5109986b7317ffe24bf71b43"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 66,
      "deletions": 8
    },
    "files": [
      {
        "sha": "8a92992dba778042973d36a26407095fd6953ef3",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 8,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92d6105c4e571e557348771bf39bf7bbacc81cd1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92d6105c4e571e557348771bf39bf7bbacc81cd1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=92d6105c4e571e557348771bf39bf7bbacc81cd1",
        "patch": "@@ -153,6 +153,26 @@ namespace {\n     /** chainwork for the last block that preciousblock has been applied to. */\n     arith_uint256 nLastPreciousChainwork = 0;\n \n+    /** In order to efficiently track invalidity of headers, we keep the set of\n+      * blocks which we tried to connect and found to be invalid here (ie which\n+      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n+      * walk this set and check if a new header is a descendant of something in\n+      * this set, preventing us from having to walk mapBlockIndex when we try\n+      * to connect a bad block and fail.\n+      *\n+      * While this is more complicated than marking everything which descends\n+      * from an invalid block as invalid at the time we discover it to be\n+      * invalid, doing so would require walking all of mapBlockIndex to find all\n+      * descendants. Since this case should be very rare, keeping track of all\n+      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n+      * well.\n+      *\n+      * Because we alreardy walk mapBlockIndex in height-order at startup, we go\n+      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n+      * instead of putting things in this set.\n+      */\n+    std::set<CBlockIndex*> g_failed_blocks;\n+\n     /** Dirty block index entries. */\n     std::set<CBlockIndex*> setDirtyBlockIndex;\n \n@@ -1168,6 +1188,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n     if (!state.CorruptionPossible()) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n+        g_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n@@ -2517,17 +2538,18 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n {\n     AssertLockHeld(cs_main);\n \n-    // Mark the block itself as invalid.\n-    pindex->nStatus |= BLOCK_FAILED_VALID;\n-    setDirtyBlockIndex.insert(pindex);\n-    setBlockIndexCandidates.erase(pindex);\n+    // We first disconnect backwards and then mark the blocks as invalid.\n+    // This prevents a case where pruned nodes may fail to invalidateblock\n+    // and be left unable to start as they have no tip candidates (as there\n+    // are no blocks that meet the \"have data and are not invalid per\n+    // nStatus\" criteria for inclusion in setBlockIndexCandidates).\n+\n+    bool pindex_was_in_chain = false;\n+    CBlockIndex *invalid_walk_tip = chainActive.Tip();\n \n     DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Contains(pindex)) {\n-        CBlockIndex *pindexWalk = chainActive.Tip();\n-        pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n-        setDirtyBlockIndex.insert(pindexWalk);\n-        setBlockIndexCandidates.erase(pindexWalk);\n+        pindex_was_in_chain = true;\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n         if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n@@ -2538,6 +2560,21 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n         }\n     }\n \n+    // Now mark the blocks we just disconnected as descendants invalid\n+    // (note this may not be all descendants).\n+    while (pindex_was_in_chain && invalid_walk_tip != pindex) {\n+        invalid_walk_tip->nStatus |= BLOCK_FAILED_CHILD;\n+        setDirtyBlockIndex.insert(invalid_walk_tip);\n+        setBlockIndexCandidates.erase(invalid_walk_tip);\n+        invalid_walk_tip = invalid_walk_tip->pprev;\n+    }\n+\n+    // Mark the block itself as invalid.\n+    pindex->nStatus |= BLOCK_FAILED_VALID;\n+    setDirtyBlockIndex.insert(pindex);\n+    setBlockIndexCandidates.erase(pindex);\n+    g_failed_blocks.insert(pindex);\n+\n     // DisconnectTip will add transactions to disconnectpool; try to add these\n     // back to the mempool.\n     UpdateMempoolForReorg(disconnectpool, true);\n@@ -2575,6 +2612,7 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 pindexBestInvalid = nullptr;\n             }\n+            g_failed_blocks.erase(it->second);\n         }\n         it++;\n     }\n@@ -3051,6 +3089,21 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n             return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+\n+        if (!pindexPrev->IsValid(BLOCK_VALID_SCRIPTS)) {\n+            for (const CBlockIndex* failedit : g_failed_blocks) {\n+                if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {\n+                    assert(failedit->nStatus & BLOCK_FAILED_VALID);\n+                    CBlockIndex* invalid_walk = pindexPrev;\n+                    while (invalid_walk != failedit) {\n+                        invalid_walk->nStatus |= BLOCK_FAILED_CHILD;\n+                        setDirtyBlockIndex.insert(invalid_walk);\n+                        invalid_walk = invalid_walk->pprev;\n+                    }\n+                    return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                }\n+            }\n+        }\n     }\n     if (pindex == nullptr)\n         pindex = AddToBlockIndex(block);\n@@ -3477,6 +3530,10 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n                 pindex->nChainTx = pindex->nTx;\n             }\n         }\n+        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && pindex->pprev && (pindex->pprev->nStatus & BLOCK_FAILED_MASK)) {\n+            pindex->nStatus |= BLOCK_FAILED_CHILD;\n+            setDirtyBlockIndex.insert(pindex);\n+        }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == nullptr))\n             setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n@@ -3867,6 +3924,7 @@ void UnloadBlockIndex()\n     nLastBlockFile = 0;\n     nBlockSequenceId = 1;\n     setDirtyBlockIndex.clear();\n+    g_failed_blocks.clear();\n     setDirtyFileInfo.clear();\n     versionbitscache.Clear();\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {"
      }
    ]
  },
  {
    "sha": "5bec7744d112141848e57d7f628dc17597f89dd5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YmVjNzc0NGQxMTIxNDE4NDhlNTdkN2Y2MjhkYzE3NTk3Zjg5ZGQ1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-11T20:57:43Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:21:23Z"
      },
      "message": "[qa] test that invalid blocks on an invalid chain get a disconnect\n\nGithub-Pull: #11531\nRebased-From: 00dcda60f6ee63d35bec640f27efe2338dd71270",
      "tree": {
        "sha": "70b7d79d4502ae40463bee8bddb3ad9d05fbc4a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70b7d79d4502ae40463bee8bddb3ad9d05fbc4a1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5bec7744d112141848e57d7f628dc17597f89dd5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bec7744d112141848e57d7f628dc17597f89dd5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5bec7744d112141848e57d7f628dc17597f89dd5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bec7744d112141848e57d7f628dc17597f89dd5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "92d6105c4e571e557348771bf39bf7bbacc81cd1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92d6105c4e571e557348771bf39bf7bbacc81cd1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/92d6105c4e571e557348771bf39bf7bbacc81cd1"
      }
    ],
    "stats": {
      "total": 84,
      "additions": 80,
      "deletions": 4
    },
    "files": [
      {
        "sha": "220b7763694ed54f14b3403722ddacc5a544bad8",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 80,
        "deletions": 4,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5bec7744d112141848e57d7f628dc17597f89dd5/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5bec7744d112141848e57d7f628dc17597f89dd5/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=5bec7744d112141848e57d7f628dc17597f89dd5",
        "patch": "@@ -42,16 +42,20 @@\n 7. Send Node0 the missing block again.\n    Node0 should process and the tip should advance.\n \n-8. Test Node1 is able to sync when connected to node0 (which should have sufficient\n-work on its chain).\n+8. Create a fork which is invalid at a height longer than the current chain\n+   (ie to which the node will try to reorg) but which has headers built on top\n+   of the invalid block. Check that we get disconnected if we send more headers\n+   on the chain the node now knows to be invalid.\n \n+9. Test Node1 is able to sync when connected to node0 (which should have sufficient\n+   work on its chain).\n \"\"\"\n \n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n import time\n-from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.blocktools import create_block, create_coinbase, create_transaction\n \n class AcceptBlockTest(BitcoinTestFramework):\n     def add_options(self, parser):\n@@ -240,9 +244,81 @@ def run_test(self):\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n+        self.nodes[0].getblock(all_blocks[286].hash)\n+        assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[287].hash)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n-        # 8. Connect node1 to node0 and ensure it is able to sync\n+        # 8. Create a chain which is invalid at a height longer than the\n+        # current chain, but which has more blocks on top of that\n+        block_289f = create_block(all_blocks[284].sha256, create_coinbase(289), all_blocks[284].nTime+1)\n+        block_289f.solve()\n+        block_290f = create_block(block_289f.sha256, create_coinbase(290), block_289f.nTime+1)\n+        block_290f.solve()\n+        block_291 = create_block(block_290f.sha256, create_coinbase(291), block_290f.nTime+1)\n+        # block_291 spends a coinbase below maturity!\n+        block_291.vtx.append(create_transaction(block_290f.vtx[0], 0, b\"42\", 1))\n+        block_291.hashMerkleRoot = block_291.calc_merkle_root()\n+        block_291.solve()\n+        block_292 = create_block(block_291.sha256, create_coinbase(292), block_291.nTime+1)\n+        block_292.solve()\n+\n+        # Now send all the headers on the chain and enough blocks to trigger reorg\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(block_289f))\n+        headers_message.headers.append(CBlockHeader(block_290f))\n+        headers_message.headers.append(CBlockHeader(block_291))\n+        headers_message.headers.append(CBlockHeader(block_292))\n+        test_node.send_message(headers_message)\n+\n+        test_node.sync_with_ping()\n+        tip_entry_found = False\n+        for x in self.nodes[0].getchaintips():\n+            if x['hash'] == block_292.hash:\n+                assert_equal(x['status'], \"headers-only\")\n+                tip_entry_found = True\n+        assert(tip_entry_found)\n+        assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, block_292.hash)\n+\n+        test_node.send_message(msg_block(block_289f))\n+        test_node.send_message(msg_block(block_290f))\n+\n+        test_node.sync_with_ping()\n+        self.nodes[0].getblock(block_289f.hash)\n+        self.nodes[0].getblock(block_290f.hash)\n+\n+        test_node.send_message(msg_block(block_291))\n+\n+        # At this point we've sent an obviously-bogus block, wait for full processing\n+        # without assuming whether we will be disconnected or not\n+        try:\n+            # Only wait a short while so the test doesn't take forever if we do get\n+            # disconnected\n+            test_node.sync_with_ping(timeout=1)\n+        except AssertionError:\n+            test_node.wait_for_disconnect()\n+\n+            test_node = NodeConnCB()   # connects to node (not whitelisted)\n+            connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n+            test_node.add_connection(connections[0])\n+\n+            NetworkThread().start() # Start up network handling in another thread\n+            test_node.wait_for_verack()\n+\n+        # We should have failed reorg and switched back to 290 (but have block 291)\n+        assert_equal(self.nodes[0].getblockcount(), 290)\n+        assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n+        assert_equal(self.nodes[0].getblock(block_291.hash)[\"confirmations\"], -1)\n+\n+        # Now send a new header on the invalid chain, indicating we're forked off, and expect to get disconnected\n+        block_293 = create_block(block_292.sha256, create_coinbase(293), block_292.nTime+1)\n+        block_293.solve()\n+        headers_message = msg_headers()\n+        headers_message.headers.append(CBlockHeader(block_293))\n+        test_node.send_message(headers_message)\n+        test_node.wait_for_disconnect()\n+\n+        # 9. Connect node1 to node0 and ensure it is able to sync\n         connect_nodes(self.nodes[0], 1)\n         sync_blocks([self.nodes[0], self.nodes[1]])\n         self.log.info(\"Successfully synced nodes 1 and 0\")"
      }
    ]
  },
  {
    "sha": "55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NWI3YWJmYThhN2RkMTQwMGY0Mzk5ZjczNGExYjJiNmI0MzlkNTJh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-31T01:28:42Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T17:22:25Z"
      },
      "message": "Make p2p-acceptablock not an extended test\n\nGithub-Pull: #11531\nRebased-From: f3d4adfa6ff5db180ec09d93f78cdc8bfda26f96",
      "tree": {
        "sha": "41f8397dba29195f6de0b2be5eb64bd3cbba5481",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/41f8397dba29195f6de0b2be5eb64bd3cbba5481"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5bec7744d112141848e57d7f628dc17597f89dd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bec7744d112141848e57d7f628dc17597f89dd5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5bec7744d112141848e57d7f628dc17597f89dd5"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ca74bb68da7dc2acc7728323c7f5062543c109ba",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
        "patch": "@@ -122,6 +122,7 @@\n     'uptime.py',\n     'resendwallettransactions.py',\n     'minchainwork.py',\n+    'p2p-acceptblock.py',\n ]\n \n EXTENDED_SCRIPTS = [\n@@ -149,7 +150,6 @@\n     'txn_clone.py --mineblock',\n     'forknotify.py',\n     'invalidateblock.py',\n-    'p2p-acceptblock.py',\n     'replace-by-fee.py',\n ]\n "
      }
    ]
  },
  {
    "sha": "6baa317b5fa615d463cdf0a2095533f6c10c84de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmFhMzE3YjVmYTYxNWQ0NjNjZGYwYTIwOTU1MzNmNmMxMGM4NGRl",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-02T19:02:48Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-11-02T19:02:48Z"
      },
      "message": "Fix minchainwork test for 0.15 backport",
      "tree": {
        "sha": "aa7da4541ff7c7a274982c9fcf45f18f6494add5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa7da4541ff7c7a274982c9fcf45f18f6494add5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6baa317b5fa615d463cdf0a2095533f6c10c84de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6baa317b5fa615d463cdf0a2095533f6c10c84de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6baa317b5fa615d463cdf0a2095533f6c10c84de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6baa317b5fa615d463cdf0a2095533f6c10c84de/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/55b7abfa8a7dd1400f4399f734a1b2b6b439d52a"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 4,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e136dc2b7c00a94032562aa538ec50d7cab2b310",
        "filename": "test/functional/minchainwork.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6baa317b5fa615d463cdf0a2095533f6c10c84de/test/functional/minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6baa317b5fa615d463cdf0a2095533f6c10c84de/test/functional/minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/minchainwork.py?ref=6baa317b5fa615d463cdf0a2095533f6c10c84de",
        "patch": "@@ -81,6 +81,10 @@ def run_test(self):\n         # we'd expect node1 to have disconnected node0 for serving an\n         # insufficient work chain, in which case we'd need to reconnect them to\n         # continue the test.\n+        # NOTE: before commit 44407100ff9b478d6131a1c38ee993b50b1830df, regtest\n+        # connections were not manual, so the reconnect is necessary.\n+        if (len(self.nodes[0].getpeerinfo()) == 0):\n+            connect_nodes(self.nodes[1], 0)\n \n         self.sync_all()\n         self.log.info(\"Blockcounts: %s\", [n.getblockcount() for n in self.nodes])"
      }
    ]
  },
  {
    "sha": "7871a7d3be4b89e1605ca29c2269c08f3ae68472",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODcxYTdkM2JlNGI4OWUxNjA1Y2EyOWMyMjY5YzA4ZjNhZTY4NDcy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-24T15:36:07Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Deprecate confusing blockmaxsize, fix getmininginfo output\n\n* This removes block-size-limiting code in favor of GBT clients\n  doing the limiting themselves (if at all).\n* -blockmaxsize is deprecated and only used to calculate an implied\n  blockmaxweight, addressing confusion from multiple users.\n* getmininginfo's currentblocksize return value was returning\n  garbage values, and has been removed, also removing a\n  GetSerializeSize call in some block generation inner loops and\n  potentially addressing some performance edge cases.\n\nGithub-Pull: #11100\nRebased-From: ba206d2c63a8d3cbd4a8dd47e9ef126af1bb3bb9",
      "tree": {
        "sha": "2b34fb69d7c925d37af2e3ce8a094930a14219b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b34fb69d7c925d37af2e3ce8a094930a14219b2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7871a7d3be4b89e1605ca29c2269c08f3ae68472",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7871a7d3be4b89e1605ca29c2269c08f3ae68472",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7871a7d3be4b89e1605ca29c2269c08f3ae68472",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7871a7d3be4b89e1605ca29c2269c08f3ae68472/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6baa317b5fa615d463cdf0a2095533f6c10c84de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6baa317b5fa615d463cdf0a2095533f6c10c84de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6baa317b5fa615d463cdf0a2095533f6c10c84de"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 13,
      "deletions": 46
    },
    "files": [
      {
        "sha": "4282b0911dad6a5387565e7e042fbae450125eae",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -500,7 +500,7 @@ std::string HelpMessage(HelpMessageMode mode)\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n-    strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n+    strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", _(\"Set maximum BIP141 block weight to this * 4. Deprecated, use blockmaxweight\"));\n     strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blockversion=<n>\", \"Override block version to test forking scenarios\");\n@@ -802,6 +802,15 @@ void InitParameterInteraction()\n         if (gArgs.SoftSetBoolArg(\"-whitelistrelay\", true))\n             LogPrintf(\"%s: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1\\n\", __func__);\n     }\n+\n+    if (gArgs.IsArgSet(\"-blockmaxsize\")) {\n+        unsigned int max_size = gArgs.GetArg(\"-blockmaxsize\", 0);\n+        if (gArgs.SoftSetArg(\"blockmaxweight\", strprintf(\"%d\", max_size * WITNESS_SCALE_FACTOR))) {\n+            LogPrintf(\"%s: parameter interaction: -blockmaxsize=%d -> setting -blockmaxweight=%d (-blockmaxsize is deprecated!)\\n\", __func__, max_size, max_size * WITNESS_SCALE_FACTOR);\n+        } else {\n+            LogPrintf(\"%s: Ignoring blockmaxsize setting which is overridden by blockmaxweight\", __func__);\n+        }\n+    }\n }\n \n static std::string ResolveErrMsg(const char * const optname, const std::string& strBind)"
      },
      {
        "sha": "9d571a2eb02295837365019d109eba8ca36e7761",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 36,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -43,7 +43,6 @@\n // its ancestors.\n \n uint64_t nLastBlockTx = 0;\n-uint64_t nLastBlockSize = 0;\n uint64_t nLastBlockWeight = 0;\n \n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n@@ -64,18 +63,13 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n BlockAssembler::Options::Options() {\n     blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n-    nBlockMaxSize = DEFAULT_BLOCK_MAX_SIZE;\n }\n \n BlockAssembler::BlockAssembler(const CChainParams& params, const Options& options) : chainparams(params)\n {\n     blockMinFeeRate = options.blockMinFeeRate;\n     // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:\n     nBlockMaxWeight = std::max<size_t>(4000, std::min<size_t>(MAX_BLOCK_WEIGHT - 4000, options.nBlockMaxWeight));\n-    // Limit size to between 1K and MAX_BLOCK_SERIALIZED_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max<size_t>(1000, std::min<size_t>(MAX_BLOCK_SERIALIZED_SIZE - 1000, options.nBlockMaxSize));\n-    // Whether we need to account for byte usage (in addition to weight usage)\n-    fNeedSizeAccounting = (nBlockMaxSize < MAX_BLOCK_SERIALIZED_SIZE - 1000);\n }\n \n static BlockAssembler::Options DefaultOptions(const CChainParams& params)\n@@ -85,20 +79,7 @@ static BlockAssembler::Options DefaultOptions(const CChainParams& params)\n     // If only one is given, only restrict the specified resource.\n     // If both are given, restrict both.\n     BlockAssembler::Options options;\n-    options.nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n-    options.nBlockMaxSize = DEFAULT_BLOCK_MAX_SIZE;\n-    bool fWeightSet = false;\n-    if (gArgs.IsArgSet(\"-blockmaxweight\")) {\n-        options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n-        options.nBlockMaxSize = MAX_BLOCK_SERIALIZED_SIZE;\n-        fWeightSet = true;\n-    }\n-    if (gArgs.IsArgSet(\"-blockmaxsize\")) {\n-        options.nBlockMaxSize = gArgs.GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-        if (!fWeightSet) {\n-            options.nBlockMaxWeight = options.nBlockMaxSize * WITNESS_SCALE_FACTOR;\n-        }\n-    }\n+    options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n     if (gArgs.IsArgSet(\"-blockmintxfee\")) {\n         CAmount n = 0;\n         ParseMoney(gArgs.GetArg(\"-blockmintxfee\", \"\"), n);\n@@ -116,7 +97,6 @@ void BlockAssembler::resetBlock()\n     inBlock.clear();\n \n     // Reserve space for coinbase tx\n-    nBlockSize = 1000;\n     nBlockWeight = 4000;\n     nBlockSigOpsCost = 400;\n     fIncludeWitness = false;\n@@ -175,7 +155,6 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     int64_t nTime1 = GetTimeMicros();\n \n     nLastBlockTx = nBlockTx;\n-    nLastBlockSize = nBlockSize;\n     nLastBlockWeight = nBlockWeight;\n \n     // Create coinbase transaction.\n@@ -190,8 +169,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());\n     pblocktemplate->vTxFees[0] = -nFees;\n \n-    uint64_t nSerializeSize = GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION);\n-    LogPrintf(\"CreateNewBlock(): total size: %u block weight: %u txs: %u fees: %ld sigops %d\\n\", nSerializeSize, GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);\n+    LogPrintf(\"CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\\n\", GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);\n \n     // Fill in header\n     pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n@@ -238,22 +216,13 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n // - transaction finality (locktime)\n // - premature witness (in case segwit transactions are added to mempool before\n //   segwit activation)\n-// - serialized size (in case -blockmaxsize is in use)\n bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\n {\n-    uint64_t nPotentialBlockSize = nBlockSize; // only used with fNeedSizeAccounting\n     for (const CTxMemPool::txiter it : package) {\n         if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n             return false;\n         if (!fIncludeWitness && it->GetTx().HasWitness())\n             return false;\n-        if (fNeedSizeAccounting) {\n-            uint64_t nTxSize = ::GetSerializeSize(it->GetTx(), SER_NETWORK, PROTOCOL_VERSION);\n-            if (nPotentialBlockSize + nTxSize >= nBlockMaxSize) {\n-                return false;\n-            }\n-            nPotentialBlockSize += nTxSize;\n-        }\n     }\n     return true;\n }\n@@ -263,9 +232,6 @@ void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n     pblock->vtx.emplace_back(iter->GetSharedTx());\n     pblocktemplate->vTxFees.push_back(iter->GetFee());\n     pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    if (fNeedSizeAccounting) {\n-        nBlockSize += ::GetSerializeSize(iter->GetTx(), SER_NETWORK, PROTOCOL_VERSION);\n-    }\n     nBlockWeight += iter->GetTxWeight();\n     ++nBlockTx;\n     nBlockSigOpsCost += iter->GetSigOpCost();"
      },
      {
        "sha": "f68f77c0bacc16705e17ed72d40fb5a58ee1d236",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -139,13 +139,11 @@ class BlockAssembler\n \n     // Configuration parameters for the block size\n     bool fIncludeWitness;\n-    unsigned int nBlockMaxWeight, nBlockMaxSize;\n-    bool fNeedSizeAccounting;\n+    unsigned int nBlockMaxWeight;\n     CFeeRate blockMinFeeRate;\n \n     // Information on the current status of the block\n     uint64_t nBlockWeight;\n-    uint64_t nBlockSize;\n     uint64_t nBlockTx;\n     uint64_t nBlockSigOpsCost;\n     CAmount nFees;"
      },
      {
        "sha": "702471383426b77adf735d6b15de7299d6c2984b",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -16,8 +16,6 @@\n class CCoinsViewCache;\n class CTxOut;\n \n-/** Default for -blockmaxsize, which controls the maximum size of block the mining code will create **/\n-static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n /** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = 3000000;\n /** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/"
      },
      {
        "sha": "441cd1e8f4d4b30086274ea0eba2f5e08bb404b6",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -195,7 +195,6 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"blocks\\\": nnn,             (numeric) The current block\\n\"\n-            \"  \\\"currentblocksize\\\": nnn,   (numeric) The last block size\\n\"\n             \"  \\\"currentblockweight\\\": nnn, (numeric) The last block weight\\n\"\n             \"  \\\"currentblocktx\\\": nnn,     (numeric) The last block transaction\\n\"\n             \"  \\\"difficulty\\\": xxx.xxxxx    (numeric) The current difficulty\\n\"\n@@ -214,7 +213,6 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n \n     UniValue obj(UniValue::VOBJ);\n     obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n-    obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n     obj.push_back(Pair(\"currentblockweight\", (uint64_t)nLastBlockWeight));\n     obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));"
      },
      {
        "sha": "804fb644d9943c7cacc351084bd6e3ff495f1679",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -161,7 +161,6 @@ extern CTxMemPool mempool;\n typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern BlockMap mapBlockIndex;\n extern uint64_t nLastBlockTx;\n-extern uint64_t nLastBlockSize;\n extern uint64_t nLastBlockWeight;\n extern const std::string strMessageMagic;\n extern CWaitableCriticalSection csBestBlock;"
      },
      {
        "sha": "9aee06864efce0bbe04f0baa45e3cfd5cc48769d",
        "filename": "test/functional/mining.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7871a7d3be4b89e1605ca29c2269c08f3ae68472/test/functional/mining.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7871a7d3be4b89e1605ca29c2269c08f3ae68472/test/functional/mining.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining.py?ref=7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "patch": "@@ -38,7 +38,6 @@ def run_test(self):\n         mining_info = node.getmininginfo()\n         assert_equal(mining_info['blocks'], 200)\n         assert_equal(mining_info['chain'], 'regtest')\n-        assert_equal(mining_info['currentblocksize'], 0)\n         assert_equal(mining_info['currentblocktx'], 0)\n         assert_equal(mining_info['currentblockweight'], 0)\n         assert_equal(mining_info['difficulty'], Decimal('4.656542373906925E-10'))"
      }
    ]
  },
  {
    "sha": "4c82cea99b514193672d8145c7777f3e715694ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzgyY2VhOTliNTE0MTkzNjcyZDgxNDVjNzc3N2YzZTcxNTY5NGVj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-25T16:06:13Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Use a sensible default for blockmaxweight\n\nNo sensible user will ever keep the default settings here, so not\nhaving sensible defaults only serves to screw users who are\npaying less attention, which makes for terrible defaults.\n\nGithub-Pull: #11100\nRebased-From: 3dc263c9b9068ee9793b6c7a0023eff16d70fb8f",
      "tree": {
        "sha": "fb9cf95bf35d3b270f3da82f70ad560c3c45a372",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb9cf95bf35d3b270f3da82f70ad560c3c45a372"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c82cea99b514193672d8145c7777f3e715694ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c82cea99b514193672d8145c7777f3e715694ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c82cea99b514193672d8145c7777f3e715694ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c82cea99b514193672d8145c7777f3e715694ec/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7871a7d3be4b89e1605ca29c2269c08f3ae68472",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7871a7d3be4b89e1605ca29c2269c08f3ae68472"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ef71dd73bcd574ba64005b0e259722a041afd7f8",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c82cea99b514193672d8145c7777f3e715694ec/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c82cea99b514193672d8145c7777f3e715694ec/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=4c82cea99b514193672d8145c7777f3e715694ec",
        "patch": "@@ -17,7 +17,7 @@ class CCoinsViewCache;\n class CTxOut;\n \n /** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/\n-static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = 3000000;\n+static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = MAX_BLOCK_WEIGHT - 4000;\n /** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/\n static const unsigned int DEFAULT_BLOCK_MIN_TX_FEE = 1000;\n /** The maximum weight for transactions we're willing to relay/mine */"
      }
    ]
  },
  {
    "sha": "bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYjgzZmUxOTAyNmI0ZDg2YTY1MTRlNmYzZWQ1ZjRkNzFmMWJjNGJj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-25T15:27:03Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Add release notes describing blockmaxweight deprecation\n\nGithub-Pull: #11100\nRebased-From: 6f703e9bf11c5f2fcb0fca0e4243fce6b4b9d35a",
      "tree": {
        "sha": "6ee383a28fcaf9209373627f55ca5f071fb913a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6ee383a28fcaf9209373627f55ca5f071fb913a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c82cea99b514193672d8145c7777f3e715694ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c82cea99b514193672d8145c7777f3e715694ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c82cea99b514193672d8145c7777f3e715694ec"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 16,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6e4bd03cd5ae2381ea01144c7a9a0514746b1cd7",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
        "patch": "@@ -72,6 +72,22 @@ Notable changes\n   value is passed, instead of returning a list of all wallet transactions since\n   the genesis block.\n \n+Miner block size limiting deprecated\n+------------------------------------\n+\n+Though blockmaxweight has been preferred for limiting the size of blocks returned by\n+getblocktemplate since 0.13.0, blockmaxsize remained as an option for those who wished\n+to limit their block size directly. Using this option resulted in a few UI issues as\n+well as non-optimal fee selection and ever-so-slightly worse performance, and has thus\n+now been deprecated. Further, the blockmaxsize option is now used only to calculate an\n+implied blockmaxweight, instead of limiting block size directly. Any miners who wish\n+to limit their blocks by size, instead of by weight, will have to do so manually by\n+removing transactions from their block template directly.\n+\n+Low-level RPC changes\n+----------------------\n+- The \"currentblocksize\" value in getmininginfo has been removed.\n+\n Credits\n =======\n "
      }
    ]
  },
  {
    "sha": "49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OWJmMDkwMTg1YWQ3ZjZhYTRkODZiYWU4YWVlZGZjYWYzOTY3NzFj",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-23T17:36:15Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "net: Allow connecting to extra outbound peers\n\nGithub-Pull: #11560\nRebased-From: 2d4327db1973a354e9e4153de6958d49120fcde8",
      "tree": {
        "sha": "9fe4617e8f3d2b5d5535fd81f34cbadac361c061",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9fe4617e8f3d2b5d5535fd81f34cbadac361c061"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49bf090185ad7f6aa4d86bae8aeedfcaf396771c/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bb83fe19026b4d86a6514e6f3ed5f4d71f1bc4bc"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 51,
      "deletions": 1
    },
    "files": [
      {
        "sha": "1687900ed762ca7f5b2930daf163dec1b05ea4d7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/49bf090185ad7f6aa4d86bae8aeedfcaf396771c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/49bf090185ad7f6aa4d86bae8aeedfcaf396771c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
        "patch": "@@ -1670,6 +1670,36 @@ void CConnman::ProcessOneShot()\n     }\n }\n \n+bool CConnman::GetTryNewOutboundPeer()\n+{\n+    return m_try_another_outbound_peer;\n+}\n+\n+void CConnman::SetTryNewOutboundPeer(bool flag)\n+{\n+    m_try_another_outbound_peer = flag;\n+}\n+\n+// Return the number of peers we have over our outbound connection limit\n+// Exclude peers that are marked for disconnect, or are going to be\n+// disconnected soon (eg one-shots and feelers)\n+// Also exclude peers that haven't finished initial connection handshake yet\n+// (so that we don't decide we're over our desired connection limit, and then\n+// evict some peer that has finished the handshake)\n+int CConnman::GetExtraOutboundCount()\n+{\n+    int nOutbound = 0;\n+    {\n+        LOCK(cs_vNodes);\n+        for (CNode* pnode : vNodes) {\n+            if (!pnode->fInbound && !pnode->m_manual_connection && !pnode->fFeeler && !pnode->fDisconnect && !pnode->fOneShot && pnode->fSuccessfullyConnected) {\n+                ++nOutbound;\n+            }\n+        }\n+    }\n+    return std::max(nOutbound - nMaxOutbound, 0);\n+}\n+\n void CConnman::ThreadOpenConnections()\n {\n     // Connect to specific addresses\n@@ -1764,7 +1794,8 @@ void CConnman::ThreadOpenConnections()\n         //  * Only make a feeler connection once every few minutes.\n         //\n         bool fFeeler = false;\n-        if (nOutbound >= nMaxOutbound) {\n+\n+        if (nOutbound >= nMaxOutbound && !GetTryNewOutboundPeer()) {\n             int64_t nTime = GetTimeMicros(); // The current time right now (in microseconds).\n             if (nTime > nNextFeeler) {\n                 nNextFeeler = PoissonNextSend(nTime, FEELER_INTERVAL);\n@@ -2207,6 +2238,7 @@ CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In) : nSeed0(nSeed0In), nSe\n     semOutbound = nullptr;\n     semAddnode = nullptr;\n     flagInterruptMsgProc = false;\n+    SetTryNewOutboundPeer(false);\n \n     Options connOptions;\n     Init(connOptions);"
      },
      {
        "sha": "83f2d967624d6565da23d07c38aa53e621ed049a",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/49bf090185ad7f6aa4d86bae8aeedfcaf396771c/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/49bf090185ad7f6aa4d86bae8aeedfcaf396771c/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
        "patch": "@@ -251,6 +251,19 @@ class CConnman\n     void GetBanned(banmap_t &banmap);\n     void SetBanned(const banmap_t &banmap);\n \n+    // This allows temporarily exceeding nMaxOutbound, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n+\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraOutboundCount();\n+\n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n     std::vector<AddedNodeInfo> GetAddedNodeInfo();\n@@ -416,6 +429,11 @@ class CConnman\n     std::thread threadOpenAddedConnections;\n     std::thread threadOpenConnections;\n     std::thread threadMessageHandler;\n+\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of nMaxOutbound\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n };\n extern std::unique_ptr<CConnman> g_connman;\n void Discover(boost::thread_group& threadGroup);"
      }
    ]
  },
  {
    "sha": "459f2db425eaa3257819d496b37430558653289a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTlmMmRiNDI1ZWFhMzI1NzgxOWQ0OTZiMzc0MzA1NTg2NTMyODlh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-23T17:59:07Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Track tip update time and last new block announcement from each peer\n\nGithub-Pull: #11560\nRebased-From: db32a6589720e5b15931cef82e477118dfd92669",
      "tree": {
        "sha": "7291c214888ffa7f44e60d1c627bcc43eb827983",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7291c214888ffa7f44e60d1c627bcc43eb827983"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/459f2db425eaa3257819d496b37430558653289a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/459f2db425eaa3257819d496b37430558653289a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/459f2db425eaa3257819d496b37430558653289a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/459f2db425eaa3257819d496b37430558653289a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49bf090185ad7f6aa4d86bae8aeedfcaf396771c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/49bf090185ad7f6aa4d86bae8aeedfcaf396771c"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 35,
      "deletions": 2
    },
    "files": [
      {
        "sha": "92c88477c92df9687c02b42336a85d1d8485277a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 2,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/459f2db425eaa3257819d496b37430558653289a/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/459f2db425eaa3257819d496b37430558653289a/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=459f2db425eaa3257819d496b37430558653289a",
        "patch": "@@ -119,6 +119,10 @@ namespace {\n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int g_outbound_peers_with_protect_from_disconnect = 0;\n \n+\n+    /** When our tip was last updated. */\n+    int64_t g_last_tip_update = 0;\n+\n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay;\n@@ -223,6 +227,9 @@ struct CNodeState {\n \n     ChainSyncTimeoutState m_chain_sync;\n \n+    //! Time of last new block announcement\n+    int64_t m_last_block_announcement;\n+\n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n@@ -246,6 +253,7 @@ struct CNodeState {\n         fWantsCmpctWitness = false;\n         fSupportsDesiredCmpctVersion = false;\n         m_chain_sync = { 0, nullptr, false, false };\n+        m_last_block_announcement = 0;\n     }\n };\n \n@@ -779,6 +787,8 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         }\n         LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n+\n+    g_last_tip_update = GetTime();\n }\n \n // All of the following cache a recent block, and are protected by cs_most_recent_block\n@@ -1203,6 +1213,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         return true;\n     }\n \n+    bool received_new_header = false;\n     const CBlockIndex *pindexLast = nullptr;\n     {\n         LOCK(cs_main);\n@@ -1243,6 +1254,12 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             }\n             hashLastBlock = header.GetHash();\n         }\n+\n+        // If we don't have the last header, then they'll have given us\n+        // something new (if these headers are valid).\n+        if (mapBlockIndex.find(hashLastBlock) == mapBlockIndex.end()) {\n+            received_new_header = true;\n+        }\n     }\n \n     CValidationState state;\n@@ -1307,6 +1324,10 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n         // are still present, however, as belt-and-suspenders.\n \n+        if (received_new_header && pindexLast->nChainWork > chainActive.Tip()->nChainWork) {\n+            nodestate->m_last_block_announcement = GetTime();\n+        }\n+\n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n@@ -2197,6 +2218,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         CBlockHeaderAndShortTxIDs cmpctblock;\n         vRecv >> cmpctblock;\n \n+        bool received_new_header = false;\n+\n         {\n         LOCK(cs_main);\n \n@@ -2206,6 +2229,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n+\n+        if (mapBlockIndex.find(cmpctblock.header.GetHash()) == mapBlockIndex.end()) {\n+            received_new_header = true;\n+        }\n         }\n \n         const CBlockIndex *pindex = nullptr;\n@@ -2244,6 +2271,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n \n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // If this was a new header with more work than our tip, update the\n+        // peer's last block announcement time\n+        if (received_new_header && pindex->nChainWork > chainActive.Tip()->nChainWork) {\n+            nodestate->m_last_block_announcement = GetTime();\n+        }\n+\n         std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n@@ -2266,8 +2301,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n             return true;\n \n-        CNodeState *nodestate = State(pfrom->GetId());\n-\n         if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n             // Don't bother trying to process compact blocks from v1 peers\n             // after segwit activates."
      }
    ]
  },
  {
    "sha": "a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNjA3YTk1ZDgxODViMmI4ZDVhNGRlNmYxYmQ5MDU0MzA4ZWJmNjBh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-24T20:56:07Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Connect to an extra outbound peer if our tip is stale\n\nIf our tip hasn't updated in a while, that may be because our peers are\nnot relaying blocks to us that we would consider valid. Allow connection\nto an additional outbound peer in that circumstance.\n\nAlso, periodically check to see if we are exceeding our target number of\noutbound peers, and disconnect the one which has least recently\nannounced a new block to us (choosing the newest such peer in the case\nof tie).\n\nGithub-Pull: #11560\nRebased-From: ac7b37cd2bd612a64a4009ba82f1cd1d57f37434",
      "tree": {
        "sha": "afd3d482cae2da26bc598247698164c3e618ab4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/afd3d482cae2da26bc598247698164c3e618ab4e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "459f2db425eaa3257819d496b37430558653289a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/459f2db425eaa3257819d496b37430558653289a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/459f2db425eaa3257819d496b37430558653289a"
      }
    ],
    "stats": {
      "total": 120,
      "additions": 114,
      "deletions": 6
    },
    "files": [
      {
        "sha": "5196eee9535fbd3cd09162dc7827545c9deb6219",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "patch": "@@ -1287,7 +1287,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     g_connman = std::unique_ptr<CConnman>(new CConnman(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max())));\n     CConnman& connman = *g_connman;\n \n-    peerLogic.reset(new PeerLogicValidation(&connman));\n+    peerLogic.reset(new PeerLogicValidation(&connman, scheduler));\n     RegisterValidationInterface(peerLogic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "b3bc8292fc6fe091dc271aad1c32eba0caddcaa2",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "patch": "@@ -1678,6 +1678,7 @@ bool CConnman::GetTryNewOutboundPeer()\n void CConnman::SetTryNewOutboundPeer(bool flag)\n {\n     m_try_another_outbound_peer = flag;\n+    LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");\n }\n \n // Return the number of peers we have over our outbound connection limit"
      },
      {
        "sha": "0eb01f36b2eb41b42939ae293ae91fc45938c9fa",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 2,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "patch": "@@ -23,6 +23,7 @@\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n #include \"reverse_iterator.h\"\n+#include \"scheduler.h\"\n #include \"tinyformat.h\"\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n@@ -119,7 +120,6 @@ namespace {\n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int g_outbound_peers_with_protect_from_disconnect = 0;\n \n-\n     /** When our tip was last updated. */\n     int64_t g_last_tip_update = 0;\n \n@@ -428,6 +428,15 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     }\n }\n \n+bool TipMayBeStale(const Consensus::Params &consensusParams)\n+{\n+    AssertLockHeld(cs_main);\n+    if (g_last_tip_update == 0) {\n+        g_last_tip_update = GetTime();\n+    }\n+    return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n+}\n+\n // Requires cs_main\n bool CanDirectFetch(const Consensus::Params &consensusParams)\n {\n@@ -754,9 +763,17 @@ void Misbehaving(NodeId pnode, int howmuch)\n // blockchain -> download logic notification\n //\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn) : connman(connmanIn) {\n+PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &scheduler) : connman(connmanIn), m_stale_tip_check_time(0) {\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n+\n+    const Consensus::Params& consensusParams = Params().GetConsensus();\n+    // Stale tip checking and peer eviction are on two different timers, but we\n+    // don't want them to get out of sync due to drift in the scheduler, so we\n+    // combine them in one function and schedule at the quicker (peer-eviction)\n+    // timer.\n+    static_assert(EXTRA_PEER_CHECK_INTERVAL < STALE_CHECK_INTERVAL, \"peer eviction timer should be less than stale tip check timer\");\n+    scheduler.scheduleEvery(std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams), EXTRA_PEER_CHECK_INTERVAL * 1000);\n }\n \n void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n@@ -1412,6 +1429,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             // If this is an outbound peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n             if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+                LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++g_outbound_peers_with_protect_from_disconnect;\n             }\n@@ -2978,6 +2996,83 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n     }\n }\n \n+void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n+{\n+    // Check whether we have too many outbound peers\n+    int extra_peers = connman->GetExtraOutboundCount();\n+    if (extra_peers > 0) {\n+        // If we have more outbound peers than we target, disconnect one.\n+        // Pick the outbound peer that least recently announced\n+        // us a new block, with ties broken by choosing the more recent\n+        // connection (higher node id)\n+        NodeId worst_peer = -1;\n+        int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();\n+\n+        LOCK(cs_main);\n+\n+        connman->ForEachNode([&](CNode* pnode) {\n+            // Ignore non-outbound peers, or nodes marked for disconnect already\n+            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;\n+            CNodeState *state = State(pnode->GetId());\n+            if (state == nullptr) return; // shouldn't be possible, but just in case\n+            // Don't evict our protected peers\n+            if (state->m_chain_sync.m_protect) return;\n+            if (state->m_last_block_announcement < oldest_block_announcement || (state->m_last_block_announcement == oldest_block_announcement && pnode->GetId() > worst_peer)) {\n+                worst_peer = pnode->GetId();\n+                oldest_block_announcement = state->m_last_block_announcement;\n+            }\n+        });\n+        if (worst_peer != -1) {\n+            bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {\n+                // Only disconnect a peer that has been connected to us for\n+                // some reasonable fraction of our check-frequency, to give\n+                // it time for new information to have arrived.\n+                // Also don't disconnect any peer we're trying to download a\n+                // block from.\n+                CNodeState &state = *State(pnode->GetId());\n+                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n+                    LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n+                    pnode->fDisconnect = true;\n+                    return true;\n+                } else {\n+                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);\n+                    return false;\n+                }\n+            });\n+            if (disconnected) {\n+                // If we disconnected an extra peer, that means we successfully\n+                // connected to at least one peer after the last time we\n+                // detected a stale tip. Don't try any more extra peers until\n+                // we next detect a stale tip, to limit the load we put on the\n+                // network from these extra connections.\n+                connman->SetTryNewOutboundPeer(false);\n+            }\n+        }\n+    }\n+}\n+\n+void PeerLogicValidation::CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams)\n+{\n+    if (connman == nullptr) return;\n+\n+    int64_t time_in_seconds = GetTime();\n+\n+    EvictExtraOutboundPeers(time_in_seconds);\n+\n+    if (time_in_seconds > m_stale_tip_check_time) {\n+        LOCK(cs_main);\n+        // Check whether our tip is stale, and if so, allow using an extra\n+        // outbound peer\n+        if (TipMayBeStale(consensusParams)) {\n+            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);\n+            connman->SetTryNewOutboundPeer(true);\n+        } else if (connman->GetTryNewOutboundPeer()) {\n+            connman->SetTryNewOutboundPeer(false);\n+        }\n+        m_stale_tip_check_time = time_in_seconds + STALE_CHECK_INTERVAL;\n+    }\n+}\n+\n class CompareInvMempoolOrder\n {\n     CTxMemPool *mp;"
      },
      {
        "sha": "0a49972eed148f2447e50a2301e905f3b3be4ff7",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"net.h\"\n #include \"validationinterface.h\"\n+#include \"consensus/params.h\"\n \n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n@@ -27,13 +28,19 @@ static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/head\n static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n /** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n+/** How frequently to check for stale tips, in seconds */\n+static constexpr int64_t STALE_CHECK_INTERVAL = 10 * 60; // 10 minutes\n+/** How frequently to check for extra outbound peers and disconnect, in seconds */\n+static constexpr int64_t EXTRA_PEER_CHECK_INTERVAL = 45;\n+/** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict, in seconds */\n+static constexpr int64_t MINIMUM_CONNECT_TIME = 30;\n \n class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n-    CConnman* connman;\n+    CConnman* const connman;\n \n public:\n-    explicit PeerLogicValidation(CConnman* connman);\n+    explicit PeerLogicValidation(CConnman* connman, CScheduler &scheduler);\n \n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n@@ -55,6 +62,11 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n \n     void ConsiderEviction(CNode *pto, int64_t time_in_seconds);\n+    void CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams);\n+    void EvictExtraOutboundPeers(int64_t time_in_seconds);\n+\n+private:\n+    int64_t m_stale_tip_check_time; //! Next time to check for stale tip\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "10959adea0da1a297fe0adb9350d9f1ec0dc8fe1",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "patch": "@@ -85,7 +85,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             threadGroup.create_thread(&ThreadScriptCheck);\n         g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n         connman = g_connman.get();\n-        peerLogic.reset(new PeerLogicValidation(connman));\n+        peerLogic.reset(new PeerLogicValidation(connman, scheduler));\n }\n \n TestingSetup::~TestingSetup()"
      }
    ]
  },
  {
    "sha": "2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZWQwNjQ3YWMxZDZjMTRmZjFiZTExZjhkNTI4NGMwZGM2NDVmYzE4",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-24T08:26:05Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Add CConnmanTest to mutate g_connman in tests\n\nGithub-Pull: #11560\nRebased-From: 83df25736ebaa23777e965d265ed677a8d79f23f",
      "tree": {
        "sha": "a8520afa18dd613d23856d19c9812e39ea9e327f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8520afa18dd613d23856d19c9812e39ea9e327f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a607a95d8185b2b8d5a4de6f1bd9054308ebf60a"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6b57d5cf79d02780843855421b77b16e0d69bd77",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
        "patch": "@@ -434,6 +434,8 @@ class CConnman\n      *  in excess of nMaxOutbound\n      *  This takes the place of a feeler connection */\n     std::atomic_bool m_try_another_outbound_peer;\n+\n+    friend struct CConnmanTest;\n };\n extern std::unique_ptr<CConnman> g_connman;\n void Discover(boost::thread_group& threadGroup);"
      },
      {
        "sha": "01e2a555e60e067b3d024a71bdd97dbbcccec2f5",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
        "patch": "@@ -24,6 +24,18 @@\n \n #include <memory>\n \n+void CConnmanTest::AddNode(CNode& node)\n+{\n+    LOCK(g_connman->cs_vNodes);\n+    g_connman->vNodes.push_back(&node);\n+}\n+\n+void CConnmanTest::ClearNodes()\n+{\n+    LOCK(g_connman->cs_vNodes);\n+    g_connman->vNodes.clear();\n+}\n+\n uint256 insecure_rand_seed = GetRandHash();\n FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n "
      },
      {
        "sha": "642be476a648824cb8284869048e5000624bb91a",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
        "patch": "@@ -49,6 +49,12 @@ struct BasicTestingSetup {\n  * Included are data directory, coins database, script check threads setup.\n  */\n class CConnman;\n+class CNode;\n+struct CConnmanTest {\n+    static void AddNode(CNode& node);\n+    static void ClearNodes();\n+};\n+\n class PeerLogicValidation;\n struct TestingSetup: public BasicTestingSetup {\n     CCoinsViewDB *pcoinsdbview;"
      }
    ]
  },
  {
    "sha": "fc308a6cdb6c6d481b8721fa498e26c630210bf1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzMwOGE2Y2RiNmM2ZDQ4MWI4NzIxZmE0OThlMjZjNjMwMjEwYmYx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T14:32:46Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:18:56Z"
      },
      "message": "Add unit test for stale tip checking\n\nGithub-Pull: #11560\nRebased-From: 626291508c433488439b662f2e88882048fb59fb",
      "tree": {
        "sha": "b72c7bb0ef2ae4c4628177798ff87a2bbc93cb7e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b72c7bb0ef2ae4c4628177798ff87a2bbc93cb7e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc308a6cdb6c6d481b8721fa498e26c630210bf1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc308a6cdb6c6d481b8721fa498e26c630210bf1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc308a6cdb6c6d481b8721fa498e26c630210bf1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc308a6cdb6c6d481b8721fa498e26c630210bf1/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2ed0647ac1d6c14ff1be11f8d5284c0dc645fc18"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 94,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dea4b042e610ba5c9b444c2c797604272d35915b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc308a6cdb6c6d481b8721fa498e26c630210bf1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc308a6cdb6c6d481b8721fa498e26c630210bf1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fc308a6cdb6c6d481b8721fa498e26c630210bf1",
        "patch": "@@ -543,6 +543,15 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+// This function is used for testing the stale tip eviction logic, see\n+// DoS_tests.cpp\n+void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n+{\n+    LOCK(cs_main);\n+    CNodeState *state = State(node);\n+    if (state) state->m_last_block_announcement = time_in_seconds;\n+}\n+\n // Returns true for outbound peers, excluding manual connections, feelers, and\n // one-shots\n bool IsOutboundDisconnectionCandidate(const CNode *node)"
      },
      {
        "sha": "d1f9e63ecf5537b4aced43eac01eb610ae458d5e",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc308a6cdb6c6d481b8721fa498e26c630210bf1/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc308a6cdb6c6d481b8721fa498e26c630210bf1/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=fc308a6cdb6c6d481b8721fa498e26c630210bf1",
        "patch": "@@ -40,6 +40,8 @@ CService ip(uint32_t i)\n \n static NodeId id = 0;\n \n+void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds);\n+\n BOOST_FIXTURE_TEST_SUITE(DoS_tests, TestingSetup)\n \n // Test eviction of an outbound peer whose chain never advances\n@@ -87,6 +89,89 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n+void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidation &peerLogic)\n+{\n+    CAddress addr(ip(GetRandInt(0xffffffff)), NODE_NONE);\n+    vNodes.emplace_back(new CNode(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false));\n+    CNode &node = *vNodes.back();\n+    node.SetSendVersion(PROTOCOL_VERSION);\n+\n+    peerLogic.InitializeNode(&node);\n+    node.nVersion = 1;\n+    node.fSuccessfullyConnected = true;\n+\n+    CConnmanTest::AddNode(node);\n+}\n+\n+BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n+{\n+    const Consensus::Params& consensusParams = Params().GetConsensus();\n+    constexpr int nMaxOutbound = 8;\n+    CConnman::Options options;\n+    options.nMaxConnections = 125;\n+    options.nMaxOutbound = nMaxOutbound;\n+    options.nMaxFeeler = 1;\n+\n+    connman->Init(options);\n+    std::vector<CNode *> vNodes;\n+\n+    // Mock some outbound peers\n+    for (int i=0; i<nMaxOutbound; ++i) {\n+        AddRandomOutboundPeer(vNodes, *peerLogic);\n+    }\n+\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+\n+    // No nodes should be marked for disconnection while we have no extra peers\n+    for (const CNode *node : vNodes) {\n+        BOOST_CHECK(node->fDisconnect == false);\n+    }\n+\n+    SetMockTime(GetTime() + 3*consensusParams.nPowTargetSpacing + 1);\n+\n+    // Now tip should definitely be stale, and we should look for an extra\n+    // outbound peer\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+    BOOST_CHECK(connman->GetTryNewOutboundPeer());\n+\n+    // Still no peers should be marked for disconnection\n+    for (const CNode *node : vNodes) {\n+        BOOST_CHECK(node->fDisconnect == false);\n+    }\n+\n+    // If we add one more peer, something should get marked for eviction\n+    // on the next check (since we're mocking the time to be in the future, the\n+    // required time connected check should be satisfied).\n+    AddRandomOutboundPeer(vNodes, *peerLogic);\n+\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+    for (int i=0; i<nMaxOutbound; ++i) {\n+        BOOST_CHECK(vNodes[i]->fDisconnect == false);\n+    }\n+    // Last added node should get marked for eviction\n+    BOOST_CHECK(vNodes.back()->fDisconnect == true);\n+\n+    vNodes.back()->fDisconnect = false;\n+\n+    // Update the last announced block time for the last\n+    // peer, and check that the next newest node gets evicted.\n+    UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), GetTime());\n+\n+    peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n+    for (int i=0; i<nMaxOutbound-1; ++i) {\n+        BOOST_CHECK(vNodes[i]->fDisconnect == false);\n+    }\n+    BOOST_CHECK(vNodes[nMaxOutbound-1]->fDisconnect == true);\n+    BOOST_CHECK(vNodes.back()->fDisconnect == false);\n+\n+    bool dummy;\n+    for (const CNode *node : vNodes) {\n+        peerLogic->FinalizeNode(node->GetId(), dummy);\n+    }\n+\n+    CConnmanTest::ClearNodes();\n+}\n+\n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     std::atomic<bool> interruptDummy(false);"
      }
    ]
  },
  {
    "sha": "34153a7e4a52be30582d96426e77a7a04e9721fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDE1M2E3ZTRhNTJiZTMwNTgyZDk2NDI2ZTc3YTdhMDRlOTcyMWZi",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-11-01T16:02:57Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:31:18Z"
      },
      "message": "rpc: work-around an upstream libevent bug\n\nA rare race condition may trigger while awaiting the body of a message, see\nupsteam commit 5ff8eb26371c4dc56f384b2de35bea2d87814779 for details.\n\nThis may fix some reported rpc hangs/crashes.\n\nGithub-Pull: #11593\nRebased-From: 6b58360f9b64eb0b680a662fdfd590e47f115f44",
      "tree": {
        "sha": "bcf1aef12fcdd4de91b7a42f1bec8c54259c766d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bcf1aef12fcdd4de91b7a42f1bec8c54259c766d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34153a7e4a52be30582d96426e77a7a04e9721fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34153a7e4a52be30582d96426e77a7a04e9721fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34153a7e4a52be30582d96426e77a7a04e9721fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34153a7e4a52be30582d96426e77a7a04e9721fb/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc308a6cdb6c6d481b8721fa498e26c630210bf1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc308a6cdb6c6d481b8721fa498e26c630210bf1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc308a6cdb6c6d481b8721fa498e26c630210bf1"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 28,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a3a90080ebe038e1bd79682fc1b879f595b42c91",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 4,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34153a7e4a52be30582d96426e77a7a04e9721fb/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34153a7e4a52be30582d96426e77a7a04e9721fb/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=34153a7e4a52be30582d96426e77a7a04e9721fb",
        "patch": "@@ -24,6 +24,7 @@\n \n #include <event2/thread.h>\n #include <event2/buffer.h>\n+#include <event2/bufferevent.h>\n #include <event2/util.h>\n #include <event2/keyvalq_struct.h>\n \n@@ -239,6 +240,16 @@ static std::string RequestMethodString(HTTPRequest::RequestMethod m)\n /** HTTP request callback */\n static void http_request_cb(struct evhttp_request* req, void* arg)\n {\n+    // Disable reading to work around a libevent bug, fixed in 2.2.0.\n+    if (event_get_version_number() < 0x02020001) {\n+        evhttp_connection* conn = evhttp_request_get_connection(req);\n+        if (conn) {\n+            bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n+            if (bev) {\n+                bufferevent_disable(bev, EV_READ);\n+            }\n+        }\n+    }\n     std::unique_ptr<HTTPRequest> hreq(new HTTPRequest(req));\n \n     LogPrint(BCLog::HTTP, \"Received a %s request for %s from %s\\n\",\n@@ -599,11 +610,24 @@ void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n     struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n     assert(evb);\n     evbuffer_add(evb, strReply.data(), strReply.size());\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true,\n-        std::bind(evhttp_send_reply, req, nStatus, (const char*)nullptr, (struct evbuffer *)nullptr));\n-    ev->trigger(0);\n+    auto req_copy = req;\n+    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n+        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n+        // Re-enable reading from the socket. This is the second part of the libevent\n+        // workaround above.\n+        if (event_get_version_number() < 0x02020001) {\n+            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n+            if (conn) {\n+                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n+                if (bev) {\n+                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n+                }\n+            }\n+        }\n+    });\n+    ev->trigger(nullptr);\n     replySent = true;\n-    req = 0; // transferred back to main thread\n+    req = nullptr; // transferred back to main thread\n }\n \n CService HTTPRequest::GetPeer()"
      }
    ]
  },
  {
    "sha": "8195cb0d7fc4f8699b35aff7a43ed2fb3013608c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MTk1Y2IwZDdmYzRmODY5OWIzNWFmZjdhNDNlZDJmYjMwMTM2MDhj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-11-02T18:37:33Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-11-02T19:31:39Z"
      },
      "message": "rpc: further constrain the libevent workaround\n\nThe bug was introduced in 2.1.6-beta, versions before that don't need the\nworkaround.\n\nGithub-Pull: #11593\nRebased-From: 97932cd2689659addfbb58dc6148928b73af3bd0",
      "tree": {
        "sha": "159288b7a528c27545197abf36f271dabd76a9f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/159288b7a528c27545197abf36f271dabd76a9f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8195cb0d7fc4f8699b35aff7a43ed2fb3013608c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8195cb0d7fc4f8699b35aff7a43ed2fb3013608c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8195cb0d7fc4f8699b35aff7a43ed2fb3013608c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8195cb0d7fc4f8699b35aff7a43ed2fb3013608c/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34153a7e4a52be30582d96426e77a7a04e9721fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34153a7e4a52be30582d96426e77a7a04e9721fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34153a7e4a52be30582d96426e77a7a04e9721fb"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "dc7016b85ba9d34be1f9dd4cdddc7910c281eeb1",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8195cb0d7fc4f8699b35aff7a43ed2fb3013608c/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8195cb0d7fc4f8699b35aff7a43ed2fb3013608c/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=8195cb0d7fc4f8699b35aff7a43ed2fb3013608c",
        "patch": "@@ -241,7 +241,7 @@ static std::string RequestMethodString(HTTPRequest::RequestMethod m)\n static void http_request_cb(struct evhttp_request* req, void* arg)\n {\n     // Disable reading to work around a libevent bug, fixed in 2.2.0.\n-    if (event_get_version_number() < 0x02020001) {\n+    if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) {\n         evhttp_connection* conn = evhttp_request_get_connection(req);\n         if (conn) {\n             bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n@@ -615,7 +615,7 @@ void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n         evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n         // Re-enable reading from the socket. This is the second part of the libevent\n         // workaround above.\n-        if (event_get_version_number() < 0x02020001) {\n+        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) {\n             evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n             if (conn) {\n                 bufferevent* bev = evhttp_connection_get_bufferevent(conn);"
      }
    ]
  }
]