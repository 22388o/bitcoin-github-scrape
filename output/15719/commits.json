[
  {
    "sha": "a1c9b8741389abdb9e2bb47941828c1069446582",
    "node_id": "C_kwDOABII59oAKGExYzliODc0MTM4OWFiZGI5ZTJiYjQ3OTQxODI4YzEwNjk0NDY1ODI",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-02-14T17:07:00Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-29T16:20:20Z"
      },
      "message": "lib: Add FoundBlock locator support\n\nAllow retrieving locator from Chain findBlock methods, used in upcoming commit\nby the wallet to get the locator for the chain tip on startup.",
      "tree": {
        "sha": "60e64037d69fd07f2e25bba763351228e81ef3f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/60e64037d69fd07f2e25bba763351228e81ef3f5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1c9b8741389abdb9e2bb47941828c1069446582",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1c9b8741389abdb9e2bb47941828c1069446582",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a1c9b8741389abdb9e2bb47941828c1069446582",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1c9b8741389abdb9e2bb47941828c1069446582/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "383d350bd5107bfe00e3b90a00cab9a3c1397c72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/383d350bd5107bfe00e3b90a00cab9a3c1397c72",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/383d350bd5107bfe00e3b90a00cab9a3c1397c72"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 17,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b68d58ed6abcc6369dab90096e09bdd394c4fce3",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1c9b8741389abdb9e2bb47941828c1069446582/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1c9b8741389abdb9e2bb47941828c1069446582/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=a1c9b8741389abdb9e2bb47941828c1069446582",
        "patch": "@@ -46,6 +46,7 @@ class FoundBlock\n     FoundBlock& time(int64_t& time) { m_time = &time; return *this; }\n     FoundBlock& maxTime(int64_t& max_time) { m_max_time = &max_time; return *this; }\n     FoundBlock& mtpTime(int64_t& mtp_time) { m_mtp_time = &mtp_time; return *this; }\n+    FoundBlock& locator(CBlockLocator& locator) { m_locator = &locator; return *this; }\n     //! Return whether block is in the active (most-work) chain.\n     FoundBlock& inActiveChain(bool& in_active_chain) { m_in_active_chain = &in_active_chain; return *this; }\n     //! Return next block in the active chain if current block is in the active chain.\n@@ -59,6 +60,7 @@ class FoundBlock\n     int64_t* m_time = nullptr;\n     int64_t* m_max_time = nullptr;\n     int64_t* m_mtp_time = nullptr;\n+    CBlockLocator* m_locator = nullptr;\n     bool* m_in_active_chain = nullptr;\n     const FoundBlock* m_next_block = nullptr;\n     CBlock* m_data = nullptr;"
      },
      {
        "sha": "be85c19179055ebac554207f9d59b093bed578c0",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1c9b8741389abdb9e2bb47941828c1069446582/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1c9b8741389abdb9e2bb47941828c1069446582/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=a1c9b8741389abdb9e2bb47941828c1069446582",
        "patch": "@@ -351,6 +351,7 @@ bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec\n     if (block.m_time) *block.m_time = index->GetBlockTime();\n     if (block.m_max_time) *block.m_max_time = index->GetBlockTimeMax();\n     if (block.m_mtp_time) *block.m_mtp_time = index->GetMedianTimePast();\n+    if (block.m_locator) *block.m_locator = active.GetLocator(index);\n     if (block.m_in_active_chain) *block.m_in_active_chain = active[index->nHeight] == index;\n     if (block.m_next_block) FillBlock(active[index->nHeight] == index ? active[index->nHeight + 1] : nullptr, *block.m_next_block, lock, active);\n     if (block.m_data) {"
      },
      {
        "sha": "45b12adf21aeb0d291f04d1474b75d019089bb54",
        "filename": "src/test/interfaces_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1c9b8741389abdb9e2bb47941828c1069446582/src/test/interfaces_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1c9b8741389abdb9e2bb47941828c1069446582/src/test/interfaces_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/interfaces_tests.cpp?ref=a1c9b8741389abdb9e2bb47941828c1069446582",
        "patch": "@@ -15,6 +15,16 @@ using interfaces::FoundBlock;\n \n BOOST_FIXTURE_TEST_SUITE(interfaces_tests, TestChain100Setup)\n \n+namespace {\n+template <typename T>\n+inline std::string Ser(const T& value)\n+{\n+    CDataStream stream(SER_NETWORK, CLIENT_VERSION);\n+    stream << value;\n+    return stream.str();\n+}\n+} // namespace\n+\n BOOST_AUTO_TEST_CASE(findBlock)\n {\n     auto& chain = m_node.chain;\n@@ -44,6 +54,10 @@ BOOST_AUTO_TEST_CASE(findBlock)\n     BOOST_CHECK(chain->findBlock(active[60]->GetBlockHash(), FoundBlock().mtpTime(mtp_time)));\n     BOOST_CHECK_EQUAL(mtp_time, active[60]->GetMedianTimePast());\n \n+    CBlockLocator locator;\n+    BOOST_CHECK(chain->findBlock(active[70]->GetBlockHash(), FoundBlock().locator(locator)));\n+    BOOST_CHECK_EQUAL(Ser(locator), Ser(active.GetLocator(active[70])));\n+\n     bool cur_active{false}, next_active{false};\n     uint256 next_hash;\n     BOOST_CHECK_EQUAL(active.Height(), 100);"
      }
    ]
  },
  {
    "sha": "f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
    "node_id": "C_kwDOABII59oAKGY2YmQyYjFlMmIxNTA4ZTJiOWIwZmI2MmQyZjk5OWE0YzZmZTU3OWY",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-02-14T17:07:00Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-29T16:20:20Z"
      },
      "message": "util: Release logger lock while calling log callbacks\n\nPrevents log callbacks from deadlocking if they call code containing log\nstatements. In most cases it will not make sense to call logging code from a\nlog hook, because it could trigger and endless chain of log messages. But if a\nhook is conditioned on the content of messages, like the DebugLogHelper hook,\nit can make sense and be useful.\n\nThe new functionality is used in the CreateWalletFromFile test in an upcoming\ncommit to be able to create transactions and blocks at specific points during\ntest execution and check for race conditions.",
      "tree": {
        "sha": "2ce71915ece7b228922041cbc08a55fa1351e9f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ce71915ece7b228922041cbc08a55fa1351e9f3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1c9b8741389abdb9e2bb47941828c1069446582",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1c9b8741389abdb9e2bb47941828c1069446582",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1c9b8741389abdb9e2bb47941828c1069446582"
      }
    ],
    "stats": {
      "total": 67,
      "additions": 49,
      "deletions": 18
    },
    "files": [
      {
        "sha": "066be9ac0071e28f63c1f3c869025c659ea7d534",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 6,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
        "patch": "@@ -44,7 +44,7 @@ static int FileWriteStr(const std::string &str, FILE *fp)\n \n bool BCLog::Logger::StartLogging()\n {\n-    StdLockGuard scoped_lock(m_cs);\n+    StdUniqueLock scoped_lock(m_cs);\n \n     assert(m_buffering);\n     assert(m_fileout == nullptr);\n@@ -70,9 +70,16 @@ bool BCLog::Logger::StartLogging()\n \n         if (m_print_to_file) FileWriteStr(s, m_fileout);\n         if (m_print_to_console) fwrite(s.data(), 1, s.size(), stdout);\n-        for (const auto& cb : m_print_callbacks) {\n-            cb(s);\n+        scoped_lock.unlock();\n+        {\n+            StdUniqueLock callbacks_lock(m_callbacks_mutex);\n+            for (auto cb : m_print_callbacks) {\n+                callbacks_lock.unlock();\n+                cb(s);\n+                callbacks_lock.lock();\n+            }\n         }\n+        scoped_lock.lock();\n \n         m_msgs_before_open.pop_front();\n     }\n@@ -87,6 +94,7 @@ void BCLog::Logger::DisconnectTestLogger()\n     m_buffering = true;\n     if (m_fileout != nullptr) fclose(m_fileout);\n     m_fileout = nullptr;\n+    StdLockGuard callbacks_lock(m_callbacks_mutex);\n     m_print_callbacks.clear();\n }\n \n@@ -248,7 +256,7 @@ namespace BCLog {\n \n void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& logging_function, const std::string& source_file, const int source_line)\n {\n-    StdLockGuard scoped_lock(m_cs);\n+    StdUniqueLock scoped_lock(m_cs);\n     std::string str_prefixed = LogEscapeMessage(str);\n \n     if (m_log_sourcelocations && m_started_new_line) {\n@@ -274,9 +282,16 @@ void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& loggi\n         fwrite(str_prefixed.data(), 1, str_prefixed.size(), stdout);\n         fflush(stdout);\n     }\n-    for (const auto& cb : m_print_callbacks) {\n-        cb(str_prefixed);\n+    scoped_lock.unlock();\n+    {\n+        StdUniqueLock callbacks_lock(m_callbacks_mutex);\n+        for (auto cb : m_print_callbacks) {\n+            callbacks_lock.unlock();\n+            cb(str_prefixed);\n+            callbacks_lock.lock();\n+        }\n     }\n+    scoped_lock.lock();\n     if (m_print_to_file) {\n         assert(m_fileout != nullptr);\n "
      },
      {
        "sha": "9998071c0d84a565e074f6d857117d4569d78b92",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
        "patch": "@@ -87,7 +87,8 @@ namespace BCLog {\n         std::string LogTimestampStr(const std::string& str);\n \n         /** Slots that connect to the print signal */\n-        std::list<std::function<void(const std::string&)>> m_print_callbacks GUARDED_BY(m_cs) {};\n+        mutable StdMutex m_callbacks_mutex;\n+        std::list<std::function<void(const std::string&)>> m_print_callbacks GUARDED_BY(m_callbacks_mutex) {};\n \n     public:\n         bool m_print_to_console = false;\n@@ -108,21 +109,22 @@ namespace BCLog {\n         bool Enabled() const\n         {\n             StdLockGuard scoped_lock(m_cs);\n+            StdLockGuard callbacks_lock(m_callbacks_mutex);\n             return m_buffering || m_print_to_console || m_print_to_file || !m_print_callbacks.empty();\n         }\n \n         /** Connect a slot to the print signal and return the connection */\n         std::list<std::function<void(const std::string&)>>::iterator PushBackCallback(std::function<void(const std::string&)> fun)\n         {\n-            StdLockGuard scoped_lock(m_cs);\n+            StdLockGuard scoped_lock(m_callbacks_mutex);\n             m_print_callbacks.push_back(std::move(fun));\n             return --m_print_callbacks.end();\n         }\n \n         /** Delete a connection */\n         void DeleteCallback(std::list<std::function<void(const std::string&)>>::iterator it)\n         {\n-            StdLockGuard scoped_lock(m_cs);\n+            StdLockGuard scoped_lock(m_callbacks_mutex);\n             m_print_callbacks.erase(it);\n         }\n "
      },
      {
        "sha": "6748b391eb0689744125e5318d21454648a86925",
        "filename": "src/threadsafety.h",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/src/threadsafety.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/src/threadsafety.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadsafety.h?ref=f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
        "patch": "@@ -52,26 +52,31 @@\n #define ASSERT_EXCLUSIVE_LOCK(...)\n #endif // __GNUC__\n \n-// StdMutex provides an annotated version of std::mutex for us,\n-// and should only be used when sync.h Mutex/LOCK/etc are not usable.\n-class LOCKABLE StdMutex : public std::mutex\n+template<typename Mutex>\n+class LOCKABLE Lockable : public Mutex\n {\n public:\n #ifdef __clang__\n     //! For negative capabilities in the Clang Thread Safety Analysis.\n     //! A negative requirement uses the EXCLUSIVE_LOCKS_REQUIRED attribute, in conjunction\n     //! with the ! operator, to indicate that a mutex should not be held.\n-    const StdMutex& operator!() const { return *this; }\n+    const Lockable& operator!() const { return *this; }\n #endif // __clang__\n };\n \n-// StdLockGuard provides an annotated version of std::lock_guard for us,\n-// and should only be used when sync.h Mutex/LOCK/etc are not usable.\n-class SCOPED_LOCKABLE StdLockGuard : public std::lock_guard<StdMutex>\n+template<typename Mutex, template<typename> class Lock>\n+class SCOPED_LOCKABLE ScopedLockable : public Lock<Mutex>\n {\n public:\n-    explicit StdLockGuard(StdMutex& cs) EXCLUSIVE_LOCK_FUNCTION(cs) : std::lock_guard<StdMutex>(cs) {}\n-    ~StdLockGuard() UNLOCK_FUNCTION() {}\n+    explicit ScopedLockable(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex) : Lock<Mutex>(mutex) {}\n+    ~ScopedLockable() UNLOCK_FUNCTION() {}\n };\n \n+// StdMutex, StdLockGuard, and StdUniqueLock provide annotated versions of\n+// standard synchronization classes, and should only be used when sync.h\n+// Mutex/LOCK/etc are not usable.\n+using StdMutex = Lockable<std::mutex>;\n+using StdLockGuard = ScopedLockable<std::mutex, std::lock_guard>;\n+using StdUniqueLock = ScopedLockable<std::mutex, std::unique_lock>;\n+\n #endif // BITCOIN_THREADSAFETY_H"
      },
      {
        "sha": "6f5487c79b92afddcf0234b4b8f889ec1a58d624",
        "filename": "test/sanitizer_suppressions/tsan",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/test/sanitizer_suppressions/tsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f/test/sanitizer_suppressions/tsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/tsan?ref=f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
        "patch": "@@ -30,6 +30,15 @@ race:validation_chainstatemanager_tests\n deadlock:libdb\n race:libzmq\n \n+# Disable spurious error about std::cout.\n+# data race /usr/lib/llvm-10/bin/../include/c++/v1/ios:522:12 in std::__1::ios_base::width() const\n+# Location is global 'std::__1::cout' of size 160 at 0x7f492785e270 (libc++.so.1+0x0000000c0290)\n+# https://travis-ci.org/github/bitcoin/bitcoin/jobs/695004018\n+#\n+# Uses of std::cout are guaranteed thread safe by the c++ standard\n+# https://stackoverflow.com/questions/50322790/thread-safety-and-piping-to-streams\n+race:std::__1::ios_base::width\n+\n # Intermittent issues\n # -------------------\n #"
      }
    ]
  },
  {
    "sha": "37977ba4ec63d50765d300983d1322d28de29931",
    "node_id": "C_kwDOABII59oAKDM3OTc3YmE0ZWM2M2Q1MDc2NWQzMDA5ODNkMTMyMmQyOGRlMjk5MzE",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-02-14T17:07:00Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-29T16:20:20Z"
      },
      "message": "refactor: Make CWallet:::AttachChain return scan status\n\nMake AttachChain just responsible for syncing to the chain, moving error\nhandling and chain assignment to the caller before more syncing\nfunctionality is moved in the next commit.\n\nAlso, start using the AttachChain method in tests instead of trying\nattach in a more partial way using Chain::handleNotifications.",
      "tree": {
        "sha": "57f2b7c0d20cc80527cd1c3c102f2f1a468c6e0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/57f2b7c0d20cc80527cd1c3c102f2f1a468c6e0f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37977ba4ec63d50765d300983d1322d28de29931",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37977ba4ec63d50765d300983d1322d28de29931",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37977ba4ec63d50765d300983d1322d28de29931",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37977ba4ec63d50765d300983d1322d28de29931/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6bd2b1e2b1508e2b9b0fb62d2f999a4c6fe579f"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 32,
      "deletions": 26
    },
    "files": [
      {
        "sha": "b1481cf7480b9300cd2e3b70cda9917977e014b3",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37977ba4ec63d50765d300983d1322d28de29931/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37977ba4ec63d50765d300983d1322d28de29931/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=37977ba4ec63d50765d300983d1322d28de29931",
        "patch": "@@ -27,7 +27,7 @@ static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const b\n         wallet.SetupDescriptorScriptPubKeyMans();\n         if (wallet.LoadWallet() != DBErrors::LOAD_OK) assert(false);\n     }\n-    auto handler = test_setup->m_node.chain->handleNotifications({&wallet, [](CWallet*) {}});\n+    CWallet::AttachChain({&wallet, [](CWallet*) {}});\n \n     const std::optional<std::string> address_mine{add_mine ? std::optional<std::string>{getnewaddress(wallet)} : std::nullopt};\n "
      },
      {
        "sha": "12000dca0329cb106965e63562160cbd427922b6",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=37977ba4ec63d50765d300983d1322d28de29931",
        "patch": "@@ -11,7 +11,7 @@ WalletTestingSetup::WalletTestingSetup(const std::string& chainName)\n       m_wallet(m_node.chain.get(), \"\", m_args, CreateMockWalletDatabase())\n {\n     m_wallet.LoadWallet();\n-    m_chain_notifications_handler = m_node.chain->handleNotifications({ &m_wallet, [](CWallet*) {} });\n+    CWallet::AttachChain({ &m_wallet, [](CWallet*) {} });\n     m_wallet_client->registerRpcs();\n }\n "
      },
      {
        "sha": "0c6668a605ddbfb7ac6e27d154dc9c5d594ef389",
        "filename": "src/wallet/test/wallet_test_fixture.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/test/wallet_test_fixture.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/test/wallet_test_fixture.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.h?ref=37977ba4ec63d50765d300983d1322d28de29931",
        "patch": "@@ -23,7 +23,6 @@ struct WalletTestingSetup : public TestingSetup {\n \n     std::unique_ptr<interfaces::WalletClient> m_wallet_client = interfaces::MakeWalletClient(*m_node.chain, *Assert(m_node.args));\n     CWallet m_wallet;\n-    std::unique_ptr<interfaces::Handler> m_chain_notifications_handler;\n };\n \n #endif // BITCOIN_WALLET_TEST_WALLET_TEST_FIXTURE_H"
      },
      {
        "sha": "44567b955174cb21566202d5221397c92fca45bd",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 16,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=37977ba4ec63d50765d300983d1322d28de29931",
        "patch": "@@ -2763,7 +2763,18 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n-    if (chain && !AttachChain(walletInstance, *chain, rescan_required, error, warnings)) {\n+    CWallet::ScanStatus scan_status = chain ? CWallet::AttachChain(walletInstance, !fFirstRun, rescan_required) : CWallet::ScanStatus::SKIPPED;\n+    if (scan_status == CWallet::ScanStatus::FAILED) {\n+        error = _(\"Failed to rescan the wallet during initialization\");\n+        return nullptr;\n+    } else if (scan_status == CWallet::ScanStatus::MISSING_BLOCKS) {\n+        // We can't rescan beyond non-pruned blocks, stop and throw an error.\n+        // This might happen if a user uses an old wallet within a pruned node\n+        // or if they ran -disablewallet for a longer time, then decided to re-enable\n+        // Exit early and print an error.\n+        // If a block is pruned after this check, we will load the wallet,\n+        // but fail the rescan with a generic error.\n+        error = _(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\");\n         return nullptr;\n     }\n \n@@ -2785,12 +2796,11 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri\n     return walletInstance;\n }\n \n-bool CWallet::AttachChain(const std::shared_ptr<CWallet>& walletInstance, interfaces::Chain& chain, const bool rescan_required, bilingual_str& error, std::vector<bilingual_str>& warnings)\n+CWallet::ScanStatus CWallet::AttachChain(std::shared_ptr<CWallet> wallet, bool scan, bool rescan_required)\n {\n+    auto& chain = wallet->chain();\n+    auto& walletInstance = wallet;\n     LOCK(walletInstance->cs_wallet);\n-    // allow setting the chain if it hasn't been set already but prevent changing it\n-    assert(!walletInstance->m_chain || walletInstance->m_chain == &chain);\n-    walletInstance->m_chain = &chain;\n \n     // Register wallet with validationinterface. It's done before rescan to avoid\n     // missing block connections between end of rescan and validation subscribing.\n@@ -2824,6 +2834,7 @@ bool CWallet::AttachChain(const std::shared_ptr<CWallet>& walletInstance, interf\n         walletInstance->m_last_block_processed_height = -1;\n     }\n \n+    ScanStatus scan_status = ScanStatus::SKIPPED;\n     if (tip_height && *tip_height != rescan_height)\n     {\n         if (chain.havePruned()) {\n@@ -2833,14 +2844,7 @@ bool CWallet::AttachChain(const std::shared_ptr<CWallet>& walletInstance, interf\n             }\n \n             if (rescan_height != block_height) {\n-                // We can't rescan beyond non-pruned blocks, stop and throw an error.\n-                // This might happen if a user uses an old wallet within a pruned node\n-                // or if they ran -disablewallet for a longer time, then decided to re-enable\n-                // Exit early and print an error.\n-                // If a block is pruned after this check, we will load the wallet,\n-                // but fail the rescan with a generic error.\n-                error = _(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\");\n-                return false;\n+                return CWallet::ScanStatus::MISSING_BLOCKS;\n             }\n         }\n \n@@ -2861,15 +2865,15 @@ bool CWallet::AttachChain(const std::shared_ptr<CWallet>& walletInstance, interf\n         {\n             WalletRescanReserver reserver(*walletInstance);\n             if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(chain.getBlockHash(rescan_height), rescan_height, {} /* max height */, reserver, true /* update */).status)) {\n-                error = _(\"Failed to rescan the wallet during initialization\");\n-                return false;\n+                return CWallet::ScanStatus::FAILED;\n             }\n+            scan_status = ScanStatus::SUCCESS;\n         }\n         walletInstance->chainStateFlushed(chain.getTipLocator());\n         walletInstance->GetDatabase().IncrementUpdateCounter();\n     }\n \n-    return true;\n+    return scan_status;\n }\n \n const CAddressBookData* CWallet::FindAddressBookEntry(const CTxDestination& dest, bool allow_change) const"
      },
      {
        "sha": "3dd1c298d4c67ecb004ee372bfd737a10617037c",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37977ba4ec63d50765d300983d1322d28de29931/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=37977ba4ec63d50765d300983d1322d28de29931",
        "patch": "@@ -333,13 +333,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     // ScriptPubKeyMan::GetID. In many cases it will be the hash of an internal structure\n     std::map<uint256, std::unique_ptr<ScriptPubKeyMan>> m_spk_managers;\n \n-    /**\n-     * Catch wallet up to current chain, scanning new blocks, updating the best\n-     * block locator and m_last_block_processed, and registering for\n-     * notifications about new blocks and transactions.\n-     */\n-    static bool AttachChain(const std::shared_ptr<CWallet>& wallet, interfaces::Chain& chain, const bool rescan_required, bilingual_str& error, std::vector<bilingual_str>& warnings);\n-\n public:\n     /**\n      * Main wallet lock.\n@@ -405,6 +398,16 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /** Registered interfaces::Chain::Notifications handler. */\n     std::unique_ptr<interfaces::Handler> m_chain_notifications_handler;\n \n+    /** Result of scanning a chain for new transactions */\n+    enum class ScanStatus { SUCCESS, FAILED, MISSING_BLOCKS, SKIPPED };\n+\n+    /**\n+     * Catch wallet up to current chain, scanning new blocks, updating the best\n+     * block locator and m_last_block_processed, and registering for\n+     * notifications about new blocks and transactions.\n+     */\n+    static ScanStatus AttachChain(std::shared_ptr<CWallet> wallet, bool scan = true, bool rescan_required = false);\n+\n     /** Interface for accessing chain state. */\n     interfaces::Chain& chain() const { assert(m_chain); return *m_chain; }\n "
      }
    ]
  },
  {
    "sha": "d6b8f93fb72d3708d54126def0ade00f0637ce61",
    "node_id": "C_kwDOABII59oAKGQ2YjhmOTNmYjcyZDM3MDhkNTQxMjZkZWYwYWRlMDBmMDYzN2NlNjE",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-02-14T17:07:00Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-29T16:20:20Z"
      },
      "message": "Wallet passive startup\n\nMove wallet startup code closer to a simple model where the wallet attaches to\nthe chain with a single chain.handleNotifications() call, and just starts\npassively receiving blocks and mempool notifications from the last update point,\ninstead having to actively rescan blocks and request a mempool snapshot, and\ndeal with the tip changing, and deal with early or stale notifications.\n\nAlso, stop locking the cs_wallet mutex and registering for validationinterface\nnotifications before the rescan. This was new behavior since\n6a72f26968cf931c985d8d4797b6264274cabd06\nhttps://github.com/bitcoin/bitcoin/pull/16426 and is not ideal because it stops\nother wallets and rpcs and the gui from receiving new notifications until after the\nscan completes.\n\nThis change is a half-step towards implementing multiwallet parallel scans\n(https://github.com/bitcoin/bitcoin/issues/11756), since it provides needed\nlocator and birthday timestamp information to the Chain interface, and it\nrationalizes locking and event ordering in the startup code. The second half of\nimplementing parallel rescans requires moving the ScanForWalletTransactions\nimplementation (which this PR does not touch) from the wallet to the node.",
      "tree": {
        "sha": "55f4b2dc76069923ab53520a46860705c6d7c5e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/55f4b2dc76069923ab53520a46860705c6d7c5e4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6b8f93fb72d3708d54126def0ade00f0637ce61",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6b8f93fb72d3708d54126def0ade00f0637ce61",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6b8f93fb72d3708d54126def0ade00f0637ce61",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6b8f93fb72d3708d54126def0ade00f0637ce61/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "37977ba4ec63d50765d300983d1322d28de29931",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37977ba4ec63d50765d300983d1322d28de29931",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/37977ba4ec63d50765d300983d1322d28de29931"
      }
    ],
    "stats": {
      "total": 437,
      "additions": 231,
      "deletions": 206
    },
    "files": [
      {
        "sha": "56bdb49926bb00437be42f295764991eb1b91d5a",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 41,
        "deletions": 26,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "patch": "@@ -89,8 +89,8 @@ class FoundBlock\n //!   should be the consumer.\n //!\n //! * `guessVerificationProgress` and similar methods can go away if rescan\n-//!   logic moves out of the wallet, and the wallet just requests scans from the\n-//!   node (https://github.com/bitcoin/bitcoin/issues/11756)\n+//!   logic is moved on the node side, and the wallet just requests scans from the\n+//!   node (https://github.com/bitcoin/bitcoin/issues/11756#issuecomment-637038714).\n class Chain\n {\n public:\n@@ -101,21 +101,9 @@ class Chain\n     //! any blocks)\n     virtual std::optional<int> getHeight() = 0;\n \n-    //! Get block hash. Height must be valid or this function will abort.\n-    virtual uint256 getBlockHash(int height) = 0;\n-\n-    //! Check that the block is available on disk (i.e. has not been\n-    //! pruned), and contains transactions.\n-    virtual bool haveBlockOnDisk(int height) = 0;\n-\n     //! Get locator for the current chain tip.\n     virtual CBlockLocator getTipLocator() = 0;\n \n-    //! Return height of the highest block on chain in common with the locator,\n-    //! which will either be the original block used to create the locator,\n-    //! or one of its ancestors.\n-    virtual std::optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n-\n     //! Check if transaction will be final given chain height current time.\n     virtual bool checkFinalTx(const CTransaction& tx) = 0;\n \n@@ -247,8 +235,45 @@ class Chain\n         virtual void chainStateFlushed(const CBlockLocator& locator) {}\n     };\n \n-    //! Register handler for notifications.\n-    virtual std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) = 0;\n+    using ScanFn = std::function<std::optional<uint256>(const uint256& start_hash, int start_height, const uint256& tip_hash, int tip_height)>;\n+    using MempoolFn = std::function<void(std::vector<CTransactionRef>)>;\n+\n+    //! Register handler for notifications. Call @ref scan_fn to send existing\n+    //! blocks and @ref mempool_fn to send existing transactions before sending\n+    //! the first notifications about new blocks and transactions back to the\n+    //! caller.\n+    //!\n+    //! @param[in] notifications callback object receiving notifications\n+    //! @param[in] scan_fn       callback invoked before notifications are sent\n+    //!                          to scan blocks after a specified location and\n+    //!                          time. This should return the hash of the last\n+    //!                          block scanned, and may be called more than once\n+    //!                          if new blocks were connected during the scan.\n+    //! @param[in] mempool_fn    callback invoked before notifications are sent\n+    //!                          with snapshot of mempool transactions\n+    //! @param[in] scan_locator  location of last block previously scanned.\n+    //!                          scan_fn will be only be called for blocks after\n+    //!                          this point. Can be null to scan from genesis.\n+    //! @param[in] scan_time     minimum block timestamp for beginning the scan\n+    //!                          scan_fn will only be called for blocks starting\n+    //!                          from this timestamp\n+    //! @param[out] tip          information about chain tip at the point where\n+    //!                          notifications will begin\n+    //!\n+    //! @todo The handleNotifications interface should be simplified so callback\n+    //! arguments @ref scan_fn and @ref mempool_fn are dropped and all arguments\n+    //! except @ref notifications are optional. The @ref scan_fn argument will\n+    //! be dropped when implementing\n+    //! https://github.com/bitcoin/bitcoin/issues/11756, and the @ref mempool_fn\n+    //! argument can be dropped by extending transactionAddedToMempool to accept\n+    //! a span of transactions instead of just a single transaction.\n+    virtual std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications,\n+        ScanFn scan_fn,\n+        MempoolFn mempool_fn,\n+        const CBlockLocator* scan_locator,\n+        int64_t scan_time,\n+        const FoundBlock& tip,\n+        bool& missing_block_data) = 0;\n \n     //! Wait for pending notifications to be processed unless block hash points to the current\n     //! chain tip.\n@@ -279,16 +304,6 @@ class Chain\n     //! Write a setting to <datadir>/settings.json. Optionally just update the\n     //! setting in memory and do not write the file.\n     virtual bool updateRwSetting(const std::string& name, const util::SettingsValue& value, bool write=true) = 0;\n-\n-    //! Synchronously send transactionAddedToMempool notifications about all\n-    //! current mempool transactions to the specified handler and return after\n-    //! the last one is sent. These notifications aren't coordinated with async\n-    //! notifications sent by handleNotifications, so out of date async\n-    //! notifications from handleNotifications can arrive during and after\n-    //! synchronous notifications from requestMempoolTransactions. Clients need\n-    //! to be prepared to handle this by ignoring notifications about unknown\n-    //! removed transactions and already added new transactions.\n-    virtual void requestMempoolTransactions(Notifications& notifications) = 0;\n };\n \n //! Interface to let node manage chain clients (wallets, or maybe tools for"
      },
      {
        "sha": "8cceb32e2360242817c6c89b522db2cc1380225f",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 35,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "patch": "@@ -51,6 +51,7 @@\n #endif\n \n #include <any>\n+#include <future>\n #include <memory>\n #include <optional>\n #include <utility>\n@@ -343,6 +344,15 @@ class NodeImpl : public Node\n     NodeContext* m_context{nullptr};\n };\n \n+//! Return whether block data is missing in block range\n+bool MissingBlockData(const CBlockIndex* start, const CBlockIndex* end)\n+{\n+    for (const CBlockIndex* block = end; block != start; block = block->pprev) {\n+        if ((block->nStatus & BLOCK_HAVE_DATA) == 0 || block->nTx == 0) return true;\n+    }\n+    return false;\n+}\n+\n bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<RecursiveMutex>& lock, const CChain& active)\n {\n     if (!index) return false;\n@@ -466,21 +476,6 @@ class ChainImpl : public Chain\n         }\n         return std::nullopt;\n     }\n-    uint256 getBlockHash(int height) override\n-    {\n-        LOCK(::cs_main);\n-        const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        CBlockIndex* block = active[height];\n-        assert(block);\n-        return block->GetBlockHash();\n-    }\n-    bool haveBlockOnDisk(int height) override\n-    {\n-        LOCK(cs_main);\n-        const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        CBlockIndex* block = active[height];\n-        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n-    }\n     CBlockLocator getTipLocator() override\n     {\n         LOCK(cs_main);\n@@ -492,15 +487,6 @@ class ChainImpl : public Chain\n         LOCK(cs_main);\n         return CheckFinalTx(chainman().ActiveChain().Tip(), tx);\n     }\n-    std::optional<int> findLocatorFork(const CBlockLocator& locator) override\n-    {\n-        LOCK(cs_main);\n-        const CChain& active = Assert(m_node.chainman)->ActiveChain();\n-        if (CBlockIndex* fork = m_node.chainman->m_blockman.FindForkInGlobalIndex(active, locator)) {\n-            return fork->nHeight;\n-        }\n-        return std::nullopt;\n-    }\n     bool findBlock(const uint256& hash, const FoundBlock& block) override\n     {\n         WAIT_LOCK(cs_main, lock);\n@@ -665,9 +651,82 @@ class ChainImpl : public Chain\n     {\n         ::uiInterface.ShowProgress(title, progress, resume_possible);\n     }\n-    std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) override\n-    {\n-        return std::make_unique<NotificationsHandlerImpl>(std::move(notifications));\n+    std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications,\n+        ScanFn scan_fn,\n+        MempoolFn mempool_fn,\n+        const CBlockLocator* scan_locator,\n+        int64_t scan_time,\n+        const FoundBlock& tip,\n+        bool& missing_block_data) override LOCKS_EXCLUDED(::cs_main, m_node.mempool->cs)\n+    {\n+        // Declare an asynchronous task to send a mempool snapshot immediately\n+        // before enabling notifications.\n+        std::vector<CTransactionRef> mempool_snapshot;\n+        std::packaged_task<std::unique_ptr<Handler>()> register_task{[&] {\n+            if (mempool_fn) mempool_fn(std::move(mempool_snapshot));\n+            return std::make_unique<NotificationsHandlerImpl>(std::move(notifications));\n+        }};\n+        std::future<std::unique_ptr<Handler>> register_future{register_task.get_future()};\n+\n+        // Lock cs_main to find forks and trigger rescans, then lock mempool.cs\n+        // to build a mempool snapshot, then release both locks and\n+        // asynchronously send the mempool snapshot to the caller, and enable\n+        // notifications starting from the point when the snapshot was created.\n+        {\n+            AssertLockNotHeld(::cs_main);\n+            WAIT_LOCK(::cs_main, main_lock);\n+\n+            const CChain& active = Assert(m_node.chainman)->ActiveChain();\n+\n+            // Call scan_fn until it has scanned all blocks after specified\n+            // location and time. Looping is necessary because new blocks may\n+            // be connected during rescans.\n+            missing_block_data = false;\n+            if (scan_fn) {\n+                CBlockIndex* scan_start = scan_locator ? m_node.chainman->m_blockman.FindForkInGlobalIndex(active, *scan_locator) : nullptr;\n+                scan_start = active.FindEarliestAtLeast(scan_time, scan_start ? scan_start->nHeight : 0);\n+                while (scan_start) {\n+                    if (MissingBlockData(scan_start, active.Tip())) {\n+                        missing_block_data = true;\n+                        return nullptr;\n+                    }\n+                    uint256 scan_tip_hash = active.Tip()->GetBlockHash();\n+                    int scan_tip_height = active.Height();\n+                    std::optional<uint256> scanned_hash;\n+                    {\n+                        REVERSE_LOCK(main_lock);\n+                        scanned_hash = scan_fn(scan_start->GetBlockHash(), scan_start->nHeight, scan_tip_hash, scan_tip_height);\n+                    }\n+                    if (!scanned_hash) return nullptr;\n+                    scan_start = active.Next(active.FindFork(m_node.chainman->m_blockman.LookupBlockIndex(*scanned_hash)));\n+                }\n+            }\n+            FillBlock(active.Tip(), tip, main_lock, active);\n+\n+            if (m_node.mempool) {\n+                // Take a snapshot of mempool transactions if needed\n+                AssertLockNotHeld(m_node.mempool->cs);\n+                LOCK(m_node.mempool->cs);\n+                if (mempool_fn) {\n+                    for (const CTxMemPoolEntry& entry : m_node.mempool->mapTx) {\n+                        mempool_snapshot.push_back(entry.GetSharedTx());\n+                    }\n+                }\n+\n+                // Register for notifications. Avoid receiving stale notifications\n+                // that may be backed up in the queue by delaying registration with\n+                // CallFunctionInValidationInterfaceQueue. Avoid missing any new\n+                // notifications that happen after scanning blocks and taking the\n+                // mempool snapshot above by holding on to cs_main and mempool.cs\n+                // while calling CallFunctionInValidationInterfaceQueue, so the new\n+                // notifications get enqueued after register_task, and won't be\n+                // handled until after it returns\n+                CallFunctionInValidationInterfaceQueue([&] { register_task(); });\n+            } else {\n+                CallFunctionInValidationInterfaceQueue([&] { register_task(); });\n+            }\n+        }\n+        return register_future.get();\n     }\n     void waitForNotificationsIfTipChanged(const uint256& old_tip) override\n     {\n@@ -717,14 +776,6 @@ class ChainImpl : public Chain\n         });\n         return !write || gArgs.WriteSettingsFile();\n     }\n-    void requestMempoolTransactions(Notifications& notifications) override\n-    {\n-        if (!m_node.mempool) return;\n-        LOCK2(::cs_main, m_node.mempool->cs);\n-        for (const CTxMemPoolEntry& entry : m_node.mempool->mapTx) {\n-            notifications.transactionAddedToMempool(entry.GetSharedTx(), 0 /* mempool_sequence */);\n-        }\n-    }\n     NodeContext& m_node;\n };\n } // namespace"
      },
      {
        "sha": "413297893f8e9fd3522e047e28f3aa68c5938aeb",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 76,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "patch": "@@ -691,20 +691,9 @@ BOOST_FIXTURE_TEST_CASE(wallet_descriptor_test, BasicTestingSetup)\n //! conditions if it's called the same time an incoming transaction shows up in\n //! the mempool or a new block.\n //!\n-//! It isn't possible to verify there aren't race condition in every case, so\n-//! this test just checks two specific cases and ensures that timing of\n-//! notifications in these cases doesn't prevent the wallet from detecting\n-//! transactions.\n-//!\n-//! In the first case, block and mempool transactions are created before the\n-//! wallet is loaded, but notifications about these transactions are delayed\n-//! until after it is loaded. The notifications are superfluous in this case, so\n-//! the test verifies the transactions are detected before they arrive.\n-//!\n-//! In the second case, block and mempool transactions are created after the\n-//! wallet rescan and notifications are immediately synced, to verify the wallet\n-//! must already have a handler in place for them, and there's no gap after\n-//! rescanning where new transactions in new blocks could be lost.\n+//! It isn't possible to verify there aren't race conditions in every case, so\n+//! this just tests specific cases and ensures that timing of notifications in\n+//! these cases doesn't prevent the wallet from detecting transactions.\n BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n {\n     gArgs.ForceSetArg(\"-unsafesqlitesync\", \"1\");\n@@ -718,7 +707,6 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n     AddKey(*wallet, key);\n     TestUnloadWallet(std::move(wallet));\n \n-\n     // Add log hook to detect AddToWallet events from rescans, blockConnected,\n     // and transactionAddedToMempool notifications\n     int addtx_count = 0;\n@@ -727,76 +715,65 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n         return false;\n     });\n \n+    // Declare helper functions that create block and mempool transactions\n+    // paying to the wallet, and check that the wallet adds them to mapWallet\n+    std::vector<uint256> wallet_txs;\n+    auto create_wallet_txs = [&] {\n+        AssertLockNotHeld(::cs_main);\n+        m_node.mempool->clear();\n+        m_coinbase_txns.push_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+        auto block_tx = TestSimpleSpend(*m_coinbase_txns[wallet_txs.size()], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n+        wallet_txs.push_back(block_tx.GetHash());\n+        m_coinbase_txns.push_back(CreateAndProcessBlock({block_tx}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+        auto mempool_tx = TestSimpleSpend(*m_coinbase_txns[wallet_txs.size()], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n+        wallet_txs.push_back(mempool_tx.GetHash());\n+        std::string error;\n+        BOOST_CHECK(m_node.chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+        SyncWithValidationInterfaceQueue();\n+    };\n+    auto check_wallet_txs = [&] {\n+        LOCK(wallet->cs_wallet);\n+        for (const auto& tx : wallet_txs) {\n+            BOOST_CHECK_EQUAL(wallet->mapWallet.count(tx), (size_t)1);\n+        }\n+    };\n+\n+    // Create block and mempool transactions paying to the wallet while wallet\n+    // is unloaded to ensure the wallet doesn't get live notifications about\n+    // them, but does pick them up when it scans the scans the chain and\n+    // mempool.\n+    create_wallet_txs();\n+    wallet = TestLoadWallet(context);\n+    check_wallet_txs();\n+    BOOST_CHECK_EQUAL(wallet_txs.size(), (size_t)2);\n+    BOOST_CHECK_EQUAL(addtx_count, 2);\n+    TestUnloadWallet(std::move(wallet));\n \n-    bool rescan_completed = false;\n+    // Repeat the same test, but this time create transactions in the middle of\n+    // loading. Create new transactions after the first rescan so another rescan\n+    // has to be triggered.\n+    int rescan_count = 0;\n     DebugLogHelper rescan_check(\"[default wallet] Rescan completed\", [&](const std::string* s) {\n-        if (s) rescan_completed = true;\n+        if (s && ++rescan_count == 1) create_wallet_txs();\n         return false;\n     });\n-\n-\n-    // Block the queue to prevent the wallet receiving blockConnected and\n-    // transactionAddedToMempool notifications, and create block and mempool\n-    // transactions paying to the wallet\n-    std::promise<void> promise;\n-    CallFunctionInValidationInterfaceQueue([&promise] {\n-        promise.get_future().wait();\n-    });\n-    std::string error;\n-    m_coinbase_txns.push_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n-    auto block_tx = TestSimpleSpend(*m_coinbase_txns[0], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n-    m_coinbase_txns.push_back(CreateAndProcessBlock({block_tx}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n-    auto mempool_tx = TestSimpleSpend(*m_coinbase_txns[1], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n-    BOOST_CHECK(m_node.chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));\n-\n-\n-    // Reload wallet and make sure new transactions are detected despite events\n-    // being blocked\n     wallet = TestLoadWallet(context);\n-    BOOST_CHECK(rescan_completed);\n-    BOOST_CHECK_EQUAL(addtx_count, 2);\n-    {\n-        LOCK(wallet->cs_wallet);\n-        BOOST_CHECK_EQUAL(wallet->mapWallet.count(block_tx.GetHash()), 1U);\n-        BOOST_CHECK_EQUAL(wallet->mapWallet.count(mempool_tx.GetHash()), 1U);\n-    }\n-\n-\n-    // Unblock notification queue and make sure stale blockConnected and\n-    // transactionAddedToMempool events are processed\n-    promise.set_value();\n     SyncWithValidationInterfaceQueue();\n-    BOOST_CHECK_EQUAL(addtx_count, 4);\n-\n-\n+    check_wallet_txs();\n+    BOOST_CHECK_EQUAL(wallet_txs.size(), (size_t)4);\n+    BOOST_CHECK_EQUAL(addtx_count, 6);\n+    BOOST_CHECK_EQUAL(rescan_count, 2);\n     TestUnloadWallet(std::move(wallet));\n \n-\n-    // Load wallet again, this time creating new block and mempool transactions\n-    // paying to the wallet as the wallet finishes loading and syncing the\n-    // queue so the events have to be handled immediately. Releasing the wallet\n-    // lock during the sync is a little artificial but is needed to avoid a\n-    // deadlock during the sync and simulates a new block notification happening\n-    // as soon as possible.\n-    addtx_count = 0;\n-    auto handler = HandleLoadWallet(context, [&](std::unique_ptr<interfaces::Wallet> wallet) {\n-            BOOST_CHECK(rescan_completed);\n-            m_coinbase_txns.push_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n-            block_tx = TestSimpleSpend(*m_coinbase_txns[2], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n-            m_coinbase_txns.push_back(CreateAndProcessBlock({block_tx}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n-            mempool_tx = TestSimpleSpend(*m_coinbase_txns[3], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n-            BOOST_CHECK(m_node.chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));\n-            SyncWithValidationInterfaceQueue();\n-        });\n+    // Do another loading test creating transactions immediately after loading\n+    // completes and making sure block and mempool notifications are processed.\n     wallet = TestLoadWallet(context);\n-    BOOST_CHECK_EQUAL(addtx_count, 4);\n-    {\n-        LOCK(wallet->cs_wallet);\n-        BOOST_CHECK_EQUAL(wallet->mapWallet.count(block_tx.GetHash()), 1U);\n-        BOOST_CHECK_EQUAL(wallet->mapWallet.count(mempool_tx.GetHash()), 1U);\n-    }\n-\n-\n+    create_wallet_txs();\n+    check_wallet_txs();\n+    BOOST_CHECK_EQUAL(wallet_txs.size(), (size_t)6);\n+    BOOST_CHECK_EQUAL(addtx_count, 11);\n+    BOOST_CHECK_EQUAL(rescan_count, 3);\n     TestUnloadWallet(std::move(wallet));\n }\n "
      },
      {
        "sha": "45440837589a916103f8c1531518a8cd12cb1e8d",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 68,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "patch": "@@ -2778,6 +2778,8 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri\n         return nullptr;\n     }\n \n+    LOCK(walletInstance->cs_wallet);\n+\n     {\n         LOCK(context.wallets_mutex);\n         for (auto& load_wallet : context.wallet_load_fns) {\n@@ -2798,81 +2800,64 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri\n \n CWallet::ScanStatus CWallet::AttachChain(std::shared_ptr<CWallet> wallet, bool scan, bool rescan_required)\n {\n-    auto& chain = wallet->chain();\n-    auto& walletInstance = wallet;\n-    LOCK(walletInstance->cs_wallet);\n-\n-    // Register wallet with validationinterface. It's done before rescan to avoid\n-    // missing block connections between end of rescan and validation subscribing.\n-    // Because of wallet lock being hold, block connection notifications are going to\n-    // be pending on the validation-side until lock release. It's likely to have\n-    // block processing duplicata (if rescan block range overlaps with notification one)\n-    // but we guarantee at least than wallet state is correct after notifications delivery.\n-    // This is temporary until rescan and notifications delivery are unified under same\n-    // interface.\n-    walletInstance->m_chain_notifications_handler = walletInstance->chain().handleNotifications(walletInstance);\n-\n-    // If rescan_required = true, rescan_height remains equal to 0\n-    int rescan_height = 0;\n-    if (!rescan_required)\n-    {\n-        WalletBatch batch(walletInstance->GetDatabase());\n-        CBlockLocator locator;\n-        if (batch.ReadBestBlock(locator)) {\n-            if (const std::optional<int> fork_height = chain.findLocatorFork(locator)) {\n-                rescan_height = *fork_height;\n-            }\n-        }\n-    }\n-\n-    const std::optional<int> tip_height = chain.getHeight();\n-    if (tip_height) {\n-        walletInstance->m_last_block_processed = chain.getBlockHash(*tip_height);\n-        walletInstance->m_last_block_processed_height = *tip_height;\n-    } else {\n-        walletInstance->m_last_block_processed.SetNull();\n-        walletInstance->m_last_block_processed_height = -1;\n-    }\n-\n+    // Register with the validation interface. Skip requesting mempool transactions if wallet is empty.\n+    interfaces::Chain::ScanFn scan_fn;\n+    interfaces::Chain::MempoolFn mempool_fn;\n+    std::optional<CBlockLocator> best_block_locator;\n+    std::optional<int64_t> time_first_key;\n     ScanStatus scan_status = ScanStatus::SKIPPED;\n-    if (tip_height && *tip_height != rescan_height)\n-    {\n-        if (chain.havePruned()) {\n-            int block_height = *tip_height;\n-            while (block_height > 0 && chain.haveBlockOnDisk(block_height - 1) && rescan_height != block_height) {\n-                --block_height;\n-            }\n-\n-            if (rescan_height != block_height) {\n-                return CWallet::ScanStatus::MISSING_BLOCKS;\n-            }\n+    if (scan) {\n+        // Get best block locator to rescan if not going back and rescanning\n+        if (!rescan_required) {\n+            best_block_locator.emplace();\n+            WalletBatch(wallet->GetDatabase()).ReadBestBlock(*best_block_locator);\n         }\n \n-        chain.initMessage(_(\"Rescanning\u2026\").translated);\n-        walletInstance->WalletLogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", *tip_height - rescan_height, rescan_height);\n-\n         // No need to read and scan block if block was created before\n         // our wallet birthday (as adjusted for block time variability)\n-        std::optional<int64_t> time_first_key;\n-        for (auto spk_man : walletInstance->GetAllScriptPubKeyMans()) {\n-            int64_t time = spk_man->GetTimeFirstKey();\n+        for (auto spk_man : wallet->GetAllScriptPubKeyMans()) {\n+            int64_t time = WITH_LOCK(wallet->cs_wallet, return spk_man->GetTimeFirstKey());\n             if (!time_first_key || time < *time_first_key) time_first_key = time;\n         }\n-        if (time_first_key) {\n-            chain.findFirstBlockWithTimeAndHeight(*time_first_key - TIMESTAMP_WINDOW, rescan_height, FoundBlock().height(rescan_height));\n-        }\n-\n-        {\n-            WalletRescanReserver reserver(*walletInstance);\n-            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(chain.getBlockHash(rescan_height), rescan_height, {} /* max height */, reserver, true /* update */).status)) {\n-                return CWallet::ScanStatus::FAILED;\n+        scan_fn = [&](const uint256& rescan_hash, int rescan_height, const uint256& tip_hash, int tip_height) -> std::optional<uint256> {\n+            WITH_LOCK(wallet->cs_wallet, wallet->SetLastBlockProcessed(tip_height, tip_hash));\n+            scan_status = ScanStatus::FAILED;\n+            wallet->chain().initMessage(_(\"Rescanning\u2026\").translated);\n+            wallet->WalletLogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", tip_height - rescan_height, rescan_height);\n+            WalletRescanReserver reserver(*wallet);\n+            if (reserver.reserve()) {\n+                ScanResult result =\n+                    wallet->ScanForWalletTransactions(rescan_hash, rescan_height, {} /* max height */, reserver, true /* update */);\n+                if (result.status == ScanResult::SUCCESS) {\n+                    scan_status = ScanStatus::SUCCESS;\n+                    return result.last_scanned_block;\n+                }\n             }\n-            scan_status = ScanStatus::SUCCESS;\n-        }\n-        walletInstance->chainStateFlushed(chain.getTipLocator());\n-        walletInstance->GetDatabase().IncrementUpdateCounter();\n+            return std::nullopt;\n+        };\n+        mempool_fn = [&](const std::vector<CTransactionRef>& mempool_txs) {\n+            for (const auto& mempool_tx : mempool_txs) {\n+                wallet->transactionAddedToMempool(mempool_tx, 0 /* mempool_sequence */);\n+            }\n+        };\n     }\n \n+    uint256 last_block_processed;\n+    int last_block_processed_height = -1;\n+    CBlockLocator last_block_processed_locator;\n+    bool missing_block_data;\n+    wallet->m_chain_notifications_handler = wallet->chain().handleNotifications(\n+        wallet, scan_fn, mempool_fn, best_block_locator ? &*best_block_locator : nullptr, time_first_key.value_or(0),\n+        FoundBlock().hash(last_block_processed).height(last_block_processed_height).locator(last_block_processed_locator),\n+        missing_block_data);\n+    if (missing_block_data) scan_status = ScanStatus::MISSING_BLOCKS;\n+    {\n+        LOCK(wallet->cs_wallet);\n+        wallet->m_last_block_processed = last_block_processed;\n+        wallet->m_last_block_processed_height = last_block_processed_height;\n+    }\n+    wallet->chainStateFlushed(last_block_processed_locator);\n+    wallet->GetDatabase().IncrementUpdateCounter();\n     return scan_status;\n }\n \n@@ -2926,9 +2911,6 @@ void CWallet::postInitProcess()\n     // Add wallet transactions that aren't already in a block to mempool\n     // Do this here as mempool requires genesis block to be loaded\n     ReacceptWalletTransactions();\n-\n-    // Update wallet transactions with current mempool transactions.\n-    chain().requestMempoolTransactions(*this);\n }\n \n bool CWallet::BackupWallet(const std::string& strDest) const"
      },
      {
        "sha": "766c95e2790380a7aff288f2aa34286f1b257ccd",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6b8f93fb72d3708d54126def0ade00f0637ce61/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "patch": "@@ -406,7 +406,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * block locator and m_last_block_processed, and registering for\n      * notifications about new blocks and transactions.\n      */\n-    static ScanStatus AttachChain(std::shared_ptr<CWallet> wallet, bool scan = true, bool rescan_required = false);\n+    static ScanStatus AttachChain(std::shared_ptr<CWallet> wallet, bool scan = true, bool rescan_required = false) LOCKS_EXCLUDED(wallet->cs_wallet);\n \n     /** Interface for accessing chain state. */\n     interfaces::Chain& chain() const { assert(m_chain); return *m_chain; }"
      }
    ]
  },
  {
    "sha": "2b898a0456d742911c1f74229c9fc64a0012ca42",
    "node_id": "C_kwDOABII59oAKDJiODk4YTA0NTZkNzQyOTExYzFmNzQyMjljOWZjNjRhMDAxMmNhNDI",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-02-14T17:07:00Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-29T16:20:20Z"
      },
      "message": "refactor: Move cs_wallet to ReacceptWalletTransactions\n\nThis is just a code simplification and revert of\n0440481c6bf5683eff669c789bdf6a306d99adc5 from\nhttps://github.com/bitcoin/bitcoin/pull/15652. No behavior is changing.",
      "tree": {
        "sha": "2730da80c7d78ac01e7e66623252be37f94802e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2730da80c7d78ac01e7e66623252be37f94802e2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b898a0456d742911c1f74229c9fc64a0012ca42",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b898a0456d742911c1f74229c9fc64a0012ca42",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b898a0456d742911c1f74229c9fc64a0012ca42",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b898a0456d742911c1f74229c9fc64a0012ca42/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6b8f93fb72d3708d54126def0ade00f0637ce61",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6b8f93fb72d3708d54126def0ade00f0637ce61"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 8,
      "deletions": 23
    },
    "files": [
      {
        "sha": "f96f274b18c0f736f51612d902858849a262d19c",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 20,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b898a0456d742911c1f74229c9fc64a0012ca42/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b898a0456d742911c1f74229c9fc64a0012ca42/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=2b898a0456d742911c1f74229c9fc64a0012ca42",
        "patch": "@@ -310,13 +310,9 @@ RPCHelpMan importaddress()\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address or script\");\n         }\n     }\n-    if (fRescan)\n-    {\n+    if (fRescan) {\n         RescanWallet(*pwallet, reserver);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ReacceptWalletTransactions();\n-        }\n+        pwallet->ReacceptWalletTransactions();\n     }\n \n     return NullUniValue;\n@@ -489,13 +485,9 @@ RPCHelpMan importpubkey()\n \n         pwallet->ImportPubKeys({pubKey.GetID()}, {{pubKey.GetID(), pubKey}} , {} /* key_origins */, false /* add_keypool */, false /* internal */, 1 /* timestamp */);\n     }\n-    if (fRescan)\n-    {\n+    if (fRescan) {\n         RescanWallet(*pwallet, reserver);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ReacceptWalletTransactions();\n-        }\n+        pwallet->ReacceptWalletTransactions();\n     }\n \n     return NullUniValue;\n@@ -1407,10 +1399,7 @@ RPCHelpMan importmulti()\n     }\n     if (fRescan && fRunScan && requests.size()) {\n         int64_t scannedTime = pwallet->RescanFromTime(nLowestTimestamp, reserver, true /* update */);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ReacceptWalletTransactions();\n-        }\n+        pwallet->ReacceptWalletTransactions();\n \n         if (pwallet->IsAbortingRescan()) {\n             throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted by user.\");\n@@ -1696,10 +1685,7 @@ RPCHelpMan importdescriptors()\n     // Rescan the blockchain using the lowest timestamp\n     if (rescan) {\n         int64_t scanned_time = pwallet->RescanFromTime(lowest_timestamp, reserver, true /* update */);\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            pwallet->ReacceptWalletTransactions();\n-        }\n+        pwallet->ReacceptWalletTransactions();\n \n         if (pwallet->IsAbortingRescan()) {\n             throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted by user.\");"
      },
      {
        "sha": "61ab1026ec51a0f8e07f640aa30a46311ca1f092",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b898a0456d742911c1f74229c9fc64a0012ca42/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b898a0456d742911c1f74229c9fc64a0012ca42/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2b898a0456d742911c1f74229c9fc64a0012ca42",
        "patch": "@@ -1693,6 +1693,7 @@ void CWallet::ReacceptWalletTransactions()\n     // If transactions aren't being broadcasted, don't let them into local mempool either\n     if (!fBroadcastTransactions)\n         return;\n+    LOCK(cs_wallet);\n     std::map<int64_t, CWalletTx*> mapSorted;\n \n     // Sort pending wallet transactions based on their initial wallet insertion order\n@@ -2906,8 +2907,6 @@ bool CWallet::UpgradeWallet(int version, bilingual_str& error)\n \n void CWallet::postInitProcess()\n {\n-    LOCK(cs_wallet);\n-\n     // Add wallet transactions that aren't already in a block to mempool\n     // Do this here as mempool requires genesis block to be loaded\n     ReacceptWalletTransactions();"
      },
      {
        "sha": "4d3969d19a6cc6b2552f9409f2a5086eb207ba1e",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b898a0456d742911c1f74229c9fc64a0012ca42/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b898a0456d742911c1f74229c9fc64a0012ca42/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=2b898a0456d742911c1f74229c9fc64a0012ca42",
        "patch": "@@ -536,7 +536,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     };\n     ScanResult ScanForWalletTransactions(const uint256& start_block, int start_height, std::optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate);\n     void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n-    void ReacceptWalletTransactions() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void ReacceptWalletTransactions() LOCKS_EXCLUDED(cs_wallet);\n     void ResendWalletTransactions();\n \n     OutputType TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;"
      }
    ]
  }
]