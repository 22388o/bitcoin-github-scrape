[
  {
    "sha": "8b4a62e308e3144b8a98ec5428106248902b9190",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjRhNjJlMzA4ZTMxNDRiOGE5OGVjNTQyODEwNjI0ODkwMmI5MTkw",
    "commit": {
      "author": {
        "name": "ptschip",
        "email": "peter.tschipper@gmail.com",
        "date": "2015-11-04T02:20:43Z"
      },
      "committer": {
        "name": "ptschip",
        "email": "peter.tschipper@gmail.com",
        "date": "2015-11-30T17:30:19Z"
      },
      "message": "Datastream compression for Blocks and Tx's\n\nCompress blocks and transactions using the\nLZO1x Library before sending. Blocks\nand transactions are concatenated where\npossible.",
      "tree": {
        "sha": "6bbb023385e247cc30055aeb40eae09b9cc27417",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6bbb023385e247cc30055aeb40eae09b9cc27417"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b4a62e308e3144b8a98ec5428106248902b9190",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b4a62e308e3144b8a98ec5428106248902b9190",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b4a62e308e3144b8a98ec5428106248902b9190",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b4a62e308e3144b8a98ec5428106248902b9190/comments",
    "author": {
      "login": "ptschip",
      "id": 12862928,
      "node_id": "MDQ6VXNlcjEyODYyOTI4",
      "avatar_url": "https://avatars.githubusercontent.com/u/12862928?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ptschip",
      "html_url": "https://github.com/ptschip",
      "followers_url": "https://api.github.com/users/ptschip/followers",
      "following_url": "https://api.github.com/users/ptschip/following{/other_user}",
      "gists_url": "https://api.github.com/users/ptschip/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ptschip/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ptschip/subscriptions",
      "organizations_url": "https://api.github.com/users/ptschip/orgs",
      "repos_url": "https://api.github.com/users/ptschip/repos",
      "events_url": "https://api.github.com/users/ptschip/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ptschip/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ptschip",
      "id": 12862928,
      "node_id": "MDQ6VXNlcjEyODYyOTI4",
      "avatar_url": "https://avatars.githubusercontent.com/u/12862928?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ptschip",
      "html_url": "https://github.com/ptschip",
      "followers_url": "https://api.github.com/users/ptschip/followers",
      "following_url": "https://api.github.com/users/ptschip/following{/other_user}",
      "gists_url": "https://api.github.com/users/ptschip/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ptschip/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ptschip/subscriptions",
      "organizations_url": "https://api.github.com/users/ptschip/orgs",
      "repos_url": "https://api.github.com/users/ptschip/repos",
      "events_url": "https://api.github.com/users/ptschip/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ptschip/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eb7741605b32c25893f687e19820dab114d04fe1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb7741605b32c25893f687e19820dab114d04fe1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eb7741605b32c25893f687e19820dab114d04fe1"
      }
    ],
    "stats": {
      "total": 485,
      "additions": 468,
      "deletions": 17
    },
    "files": [
      {
        "sha": "5cdab1202635e0ab45b37741e8357248ac1541bb",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -229,6 +229,7 @@ case $host in\n      AC_CHECK_LIB([shlwapi],      [main],, AC_MSG_ERROR(lib missing))\n      AC_CHECK_LIB([iphlpapi],      [main],, AC_MSG_ERROR(lib missing))\n      AC_CHECK_LIB([crypt32],      [main],, AC_MSG_ERROR(lib missing))\n+     AC_CHECK_LIB([lzo2],      [main],, AC_MSG_ERROR(lib missing))\n \n      # -static is interpreted by libtool, where it has a different meaning.\n      # In libtool-speak, it's -all-static.\n@@ -684,6 +685,7 @@ if test x$use_pkgconfig = xyes; then\n     [\n       PKG_CHECK_MODULES([SSL], [libssl],, [AC_MSG_ERROR(openssl  not found.)])\n       PKG_CHECK_MODULES([CRYPTO], [libcrypto],,[AC_MSG_ERROR(libcrypto  not found.)])\n+      PKG_CHECK_MODULES([lzo2], [liblzo2],, [AC_MSG_ERROR(liblzo2  not found.)])\n       BITCOIN_QT_CHECK([PKG_CHECK_MODULES([PROTOBUF], [protobuf], [have_protobuf=yes], [BITCOIN_QT_FAIL(libprotobuf not found)])])\n       if test x$use_qr != xno; then\n         BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])\n@@ -713,6 +715,8 @@ else\n   AC_CHECK_HEADER([openssl/ssl.h],, AC_MSG_ERROR(libssl headers missing),)\n   AC_CHECK_LIB([ssl],         [main],SSL_LIBS=-lssl, AC_MSG_ERROR(libssl missing))\n \n+  AC_CHECK_LIB([lzo2],         [main],LZOLIB_LIBS=-llzo2, AC_MSG_ERROR(liblzo missing))\n+\n   if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests != xnononono; then\n     AC_CHECK_HEADER([event2/event.h],, AC_MSG_ERROR(libevent headers missing),)\n     AC_CHECK_LIB([event],[main],EVENT_LIBS=-levent,AC_MSG_ERROR(libevent missing))"
      },
      {
        "sha": "e29ed2df876a2da3a09403f264e3804a3918f3fb",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -36,6 +36,7 @@ These dependencies are required:\n  libssl      | Crypto           | Random Number Generation, Elliptic Curve Cryptography\n  libboost    | Utility          | Library for threading, data structures, etc\n  libevent    | Networking       | OS independent asynchronous networking\n+ liblzo2     | Compression      | LZO Library for compressing files\n \n Optional dependencies:\n "
      },
      {
        "sha": "a205d0f7ccb83050324fbe018d07905409598b34",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -92,6 +92,7 @@\n     'blockchain.py',\n     'disablewallet.py',\n     'sendheaders.py',\n+    'compression.py',\n ]\n testScriptsExt = [\n     'bip65-cltv.py',"
      },
      {
        "sha": "2f696a4424b6c1ffb7ea4fc15d1f8bd4c1e96554",
        "filename": "qa/rpc-tests/compression.py",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/qa/rpc-tests/compression.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/qa/rpc-tests/compression.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/compression.py?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -0,0 +1,122 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Exercise various compression levels\n+# Test sending blocks where one node has compression turned on and the other is off\n+# \n+# Do the following:\n+#   a) creates 2 nodes with different compression levels and connect\n+#   b) node0 mines a block\n+#   c) node1 receives block\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class CompressionTest (BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self,split=False):\n+        # Start a node with compressionlevel set\n+        self.nodes = []\n+        self.is_network_split=False\n+\n+    def run_test (self):\n+        #sync compressionlevel:default to compressionlevel:1\n+        # Mine a block, sync nodes, send a transaction, sync nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-compressionlevel=1\"]))\n+        #mining 101 blocks will cause blockblocks to be created as well as give us some coin to spend\n+        self.nodes[0].generate(101)\n+        connect_nodes(self.nodes[0],1)\n+        self.sync_all()\n+        #create many tx's all at once so that some cxblobs will get created\n+        for count in range(20):\n+            self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.05)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[1].getbalance(), 1)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+        #sync compressionlevel:1 to compressionlevel:2\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-compressionlevel=1\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-compressionlevel=2\"]))\n+        self.nodes[0].generate(1)\n+        connect_nodes(self.nodes[0],1)\n+        self.sync_all()\n+        self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        #self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[1].getbalance(), 2)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+        #sync compressionlevel:2 to compressionlevel:1\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-compressionlevel=2\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-compressionlevel=1\"]))\n+        connect_nodes(self.nodes[0],1)\n+        self.nodes[0].generate(1)\n+        connect_nodes(self.nodes[0],1)\n+        self.sync_all()\n+        #self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        #assert_equal(self.nodes[1].getbalance(), 3)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+        #sync compressionlevel:0 to compressionlevel:1\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-compressionlevel=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-compressionlevel=1\"]))\n+        connect_nodes(self.nodes[0],1)\n+        self.nodes[0].generate(1)\n+        connect_nodes(self.nodes[0],1)\n+        self.sync_all()\n+        self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        #self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[1].getbalance(), 3)\n+        #assert_equal(self.nodes[1].getbalance(), 4)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+        #sync compressionlevel:2 to compressionlevel:0\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-compressionlevel=2\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-compressionlevel=0\"]))\n+        self.nodes[0].generate(1)\n+        connect_nodes(self.nodes[0],1)\n+        self.sync_all()\n+        self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        #self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[1].getbalance(), 4)\n+        #assert_equal(self.nodes[1].getbalance(), 5)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+        #sync compressionlevel:0 to compressionlevel:0\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-compressionlevel=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-compressionlevel=0\"]))\n+        self.nodes[0].generate(1)\n+        connect_nodes(self.nodes[0],1)\n+        self.sync_all()\n+        self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        #self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        #assert_equal(self.nodes[1].getbalance(), 6)\n+        assert_equal(self.nodes[1].getbalance(), 5)\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+\n+if __name__ == '__main__':\n+    CompressionTest ().main ()"
      },
      {
        "sha": "44b6c156530f6106b1aa282950864cabc30e11af",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -56,6 +56,8 @@\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n \n+#include <lzo/lzoconf.h>\n+\n #if ENABLE_ZMQ\n #include \"zmq/zmqnotificationinterface.h\"\n #endif\n@@ -477,6 +479,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !Params(CBaseChainParams::TESTNET).RequireStandard()));\n     strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n     strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n+    strUsage += HelpMessageOpt(\"-compressionlevel=<n>\", strprintf(_(\"Set compression level (0 to 2) 0 = no compression, 2 = max compression (default: %d)\"), DEFAULT_COMPRESSION_LEVEL));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n     strUsage += HelpMessageOpt(\"-blockminsize=<n>\", strprintf(_(\"Set minimum block size in bytes (default: %u)\"), DEFAULT_BLOCK_MIN_SIZE));\n@@ -886,6 +889,22 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (nMempoolSizeMax < 0 || nMempoolSizeMax < nMempoolSizeMin)\n         return InitError(strprintf(_(\"-maxmempool must be at least %d MB\"), std::ceil(nMempoolSizeMin / 1000000.0)));\n \n+    // -compressionlevel limits\n+    int nLevel = GetArg(\"-compressionlevel\", DEFAULT_COMPRESSION_LEVEL);\n+    if (nLevel < 0 || nLevel > 2)\n+        return InitError(strprintf(_(\"Error: -compressionlevel must be between 0 and 2: current = %d\"), nLevel));\n+    else if (nLevel > 0) { \n+        // Advertise compression as a service\n+        nLocalServices |= NODE_COMPRESS;\n+\n+        //initialize the LZO compression library\n+        if (lzo_init() != LZO_E_OK) {\n+            LogPrintf(\"Internal error - lzo_init() failed !!!\\n\");\n+            LogPrintf(\"This usually indicates a compiler bug - try recompiling\\nwithout optimizations, and enable '-DLZO_DEBUG' for diagnostics\\n\");\n+            return InitError(_(\"internal error - lzo_init() failed !!!\"));\n+        }\n+    }\n+\n     // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency\n     nScriptCheckThreads = GetArg(\"-par\", DEFAULT_SCRIPTCHECK_THREADS);\n     if (nScriptCheckThreads <= 0)"
      },
      {
        "sha": "29a427f97aaacfaf8c87b859bf9b5b620f08a98b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 205,
        "deletions": 12,
        "changes": 217,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -95,6 +95,9 @@ void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams);\n static void CheckBlockIndex(const Consensus::Params& consensusParams);\n \n+void SendBlob(CNode* pfrom, string blobType, int nElements, CDataStream& blob);\n+\n+\n /** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n \n@@ -3640,7 +3643,7 @@ bool LoadBlockIndex()\n     return true;\n }\n \n-bool InitBlockIndex(const CChainParams& chainparams) \n+bool InitBlockIndex(const CChainParams& chainparams)\n {\n     LOCK(cs_main);\n \n@@ -4076,6 +4079,10 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n \n     LOCK(cs_main);\n \n+    int nBlocksBlobbed = 0;\n+    int nTxBlobbed = 0;\n+    CDataStream txblob(SER_NETWORK, PROTOCOL_VERSION);\n+    CDataStream blockblob(SER_NETWORK, PROTOCOL_VERSION);\n     while (it != pfrom->vRecvGetData.end()) {\n         // Don't bother if send buffer is too full to respond anyway\n         if (pfrom->nSendSize >= SendBufferSize())\n@@ -4127,7 +4134,21 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n-                        pfrom->PushMessage(\"block\", block);\n+                    {\n+                        if ((pfrom->nServices & NODE_COMPRESS) &&\n+                            (nLocalServices & NODE_COMPRESS))\n+                        {\n+                            blockblob << block;\n+                            nBlocksBlobbed++;\n+                            if (blockblob.size() > (MAX_PROTOCOL_MESSAGE_LENGTH - MAX_BLOCK_SIZE))\n+                            {\n+                                SendBlob(pfrom,\"blockblob\",nBlocksBlobbed, blockblob);\n+                                nBlocksBlobbed = 0;\n+                            }\n+                        }\n+                        else\n+                            pfrom->PushMessage(\"block\", block);\n+                    }\n                     else // MSG_FILTERED_BLOCK)\n                     {\n                         LOCK(pfrom->cs_filter);\n@@ -4143,8 +4164,26 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n+                            {\n                                 if (!pfrom->setInventoryKnown.count(CInv(MSG_TX, pair.second)))\n-                                    pfrom->PushMessage(\"tx\", block.vtx[pair.first]);\n+                                {\n+                                    if ((pfrom->nServices & NODE_COMPRESS) && (nLocalServices & NODE_COMPRESS))\n+                                    {\n+                                        // Don't check if txblob size > MAX_PROTOCOL_MESSAGE_LENGTH. It could never happen here.\n+                                        txblob << block.vtx[pair.first];\n+                                        nTxBlobbed++;\n+                                    }\n+                                    else\n+                                        pfrom->PushMessage(\"tx\", block.vtx[pair.first]);\n+                                }\n+                            }\n+                            if ((pfrom->nServices & NODE_COMPRESS) &&\n+                                (nLocalServices & NODE_COMPRESS) &&\n+                                (nTxBlobbed > 0))\n+                            {\n+                                SendBlob(pfrom,\"txblob\",nTxBlobbed, txblob);\n+                                nTxBlobbed = 0;\n+                            }\n                         }\n                         // else\n                             // no response\n@@ -4171,8 +4210,21 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     LOCK(cs_mapRelay);\n                     map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                     if (mi != mapRelay.end()) {\n-                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n-                        pushed = true;\n+                        if ((pfrom->nServices & NODE_COMPRESS) &&\n+                              (nLocalServices & NODE_COMPRESS) &&\n+                              ((std::string)inv.GetCommand() == \"tx\")) {\n+                            txblob << (*mi).second;\n+                            nTxBlobbed++;\n+                            pushed = true;\n+                            if (txblob.size() > (MAX_PROTOCOL_MESSAGE_LENGTH - MAX_STANDARD_TX_SIZE)) {\n+                                SendBlob(pfrom,\"txblob\",nTxBlobbed, txblob);\n+                                nTxBlobbed = 0;\n+                            }\n+                        }\n+                        else {\n+                            pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n+                            pushed = true;\n+                        }\n                     }\n                 }\n                 if (!pushed && inv.type == MSG_TX) {\n@@ -4181,23 +4233,44 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                         ss.reserve(1000);\n                         ss << tx;\n-                        pfrom->PushMessage(\"tx\", ss);\n-                        pushed = true;\n+                        if ((pfrom->nServices & NODE_COMPRESS) &&\n+                            (nLocalServices & NODE_COMPRESS)) {\n+                            txblob << ss;\n+                            nTxBlobbed++;\n+                            pushed = true;\n+                            if (txblob.size() > (MAX_PROTOCOL_MESSAGE_LENGTH - MAX_STANDARD_TX_SIZE)) {\n+                                SendBlob(pfrom,\"txblob\",nTxBlobbed, txblob);\n+                                nTxBlobbed = 0;\n+                            }\n+                        }\n+                        else {\n+                            pfrom->PushMessage(\"tx\", ss);\n+                            pushed = true;\n+                        }\n                     }\n                 }\n-                if (!pushed) {\n+                if (!pushed)\n                     vNotFound.push_back(inv);\n-                }\n             }\n \n             // Track requests for our stuff.\n             GetMainSignals().Inventory(inv.hash);\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK)\n-                break;\n+            if ((!(pfrom->nServices & NODE_COMPRESS) ||\n+                   !(nLocalServices & NODE_COMPRESS)) &&\n+                   (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK))\n+                break; //Break only when compression is not enabled\n         }\n     }\n \n+    if ((pfrom->nServices & NODE_COMPRESS) && (nLocalServices & NODE_COMPRESS))\n+    {\n+        if(nTxBlobbed > 0)\n+            SendBlob(pfrom, \"txblob\", nTxBlobbed, txblob);\n+        if(nBlocksBlobbed > 0)\n+            SendBlob(pfrom, \"blockblob\", nBlocksBlobbed, blockblob);\n+    }\n+\n     pfrom->vRecvGetData.erase(pfrom->vRecvGetData.begin(), it);\n \n     if (!vNotFound.empty()) {\n@@ -4212,6 +4285,47 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n+\n+void SendBlob(CNode* pfrom, string blobType, int nElements, CDataStream& blob)\n+{\n+    LogPrint(\"compress\",\"Blob %s has %d elements\\n\", blobType, nElements);\n+\n+    // Send only if compression is turned on\n+    if ((pfrom->nServices & NODE_COMPRESS) &&\n+        (nLocalServices & NODE_COMPRESS)) {\n+        if(nElements > 0 && blobType == \"txblob\") {\n+            //Do not compress if too Small\n+            if (blob.size() < MIN_TX_COMPRESS_SIZE)\n+                pfrom->PushMessage(\"txblob\", blob);\n+            else {\n+                // Compress\n+                CDataStream cxblob(SER_NETWORK, PROTOCOL_VERSION);\n+                if (blob.compress(cxblob,\n+                    GetArg(\"-compressionlevel\", DEFAULT_COMPRESSION_LEVEL))) {\n+                    if(cxblob.size() < blob.size())\n+                        pfrom->PushMessage(\"cxblob\", cxblob);\n+                    else\n+                        //Send uncompressed if smaller than compressed\n+                        pfrom->PushMessage(\"txblob\", blob);\n+                }\n+                else\n+                    pfrom->PushMessage(\"txblob\", blob);\n+            }\n+        }\n+        else if(nElements > 0 && blobType == \"blockblob\") {\n+            // Compress\n+            CDataStream cblockblob(SER_NETWORK, PROTOCOL_VERSION);\n+            if (blob.compress(cblockblob,\n+                GetArg(\"-compressionlevel\", DEFAULT_COMPRESSION_LEVEL)))\n+                pfrom->PushMessage(\"cblockblob\", cblockblob);\n+            else\n+                pfrom->PushMessage(\"blockblob\", blob);\n+        }\n+    }\n+    blob.clear();\n+}\n+\n+\n bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived)\n {\n     const CChainParams& chainparams = Params();\n@@ -4651,7 +4765,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         pfrom->PushMessage(\"headers\", vHeaders);\n     }\n \n-\n     else if (strCommand == \"tx\")\n     {\n         // Stop processing the transaction early if\n@@ -4665,6 +4778,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         vector<uint256> vWorkQueue;\n         vector<uint256> vEraseQueue;\n         CTransaction tx;\n+\n         vRecv >> tx;\n \n         CInv inv(MSG_TX, tx.GetHash());\n@@ -4889,6 +5003,85 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         CheckBlockIndex(chainparams.GetConsensus());\n     }\n \n+    else if ((strCommand == \"blockblob\") || (strCommand == \"cblockblob\") ||\n+             (strCommand == \"txblob\") || (strCommand == \"cxblob\"))\n+    {\n+        if ((pfrom->nServices & NODE_COMPRESS) &&\n+            (nLocalServices & NODE_COMPRESS))\n+        {\n+            CDataStream ssRecv(SER_NETWORK,PROTOCOL_VERSION);\n+            CTransaction tx;\n+            CBlock block;\n+\n+            // Decompress first\n+            if(strCommand == \"cxblob\" || strCommand == \"cblockblob\") {\n+                if (vRecv.decompress(ssRecv, MAX_PROTOCOL_MESSAGE_LENGTH)) {\n+                    if (strCommand == \"cxblob\")\n+                        strCommand = \"txblob\";\n+                    else\n+                        strCommand = \"blockblob\";\n+                }\n+                else {\n+                    // They sent us data which could not be decompressed.\n+                    //   Decompression failed - unlikely\n+                    //   They are attacking in some way\n+                    LOCK(cs_main);\n+                    Misbehaving(pfrom->GetId(), 20);\n+                    LogPrintf(\"ERROR: blob decompression failed\");\n+                    return false;\n+                }\n+            }\n+            // Then Process messages\n+            if(strCommand == \"txblob\") {\n+                while(ssRecv.size() > 0) {\n+                    CDataStream ss(SER_NETWORK,PROTOCOL_VERSION);\n+                    ssRecv >> tx;\n+                    ss << tx;\n+                    ProcessMessage(pfrom, \"tx\", ss, nTimeReceived);\n+               }\n+            }\n+\n+            if(strCommand == \"blockblob\") {\n+                if(ssRecv.size() > 0)\n+                    vRecv.clear();\n+                while(ssRecv.size() > 0 || vRecv.size() > 0) {\n+                    //CDataStream ss(SER_NETWORK,PROTOCOL_VERSION);\n+                    if(ssRecv.size() > 0)\n+                        ssRecv >> block;\n+                    else\n+                        vRecv >> block;\n+\n+                    CInv inv(MSG_BLOCK, block.GetHash());\n+                    LogPrint(\"net\", \"received block %s peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n+\n+                    pfrom->AddInventoryKnown(inv);\n+\n+                    CValidationState state;\n+                    // Process all blocks from whitelisted peers, even if not requested,\n+                    // unless we're still syncing with the network.\n+                    // Such an unrequested block may still be processed, subject to the\n+                    // conditions in AcceptBlock().\n+                    bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n+                    ProcessNewBlock(state, chainparams, pfrom, &block, forceProcessing, NULL);\n+                    int nDoS;\n+                    if (state.IsInvalid(nDoS)) {\n+                        assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                        pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),\n+                                           state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n+                        if (nDoS > 0) {\n+                            LOCK(cs_main);\n+                            Misbehaving(pfrom->GetId(), nDoS);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        else {\n+            LOCK(cs_main);\n+            Misbehaving(pfrom->GetId(), 50);\n+            return false;\n+        }\n+    }\n     else if (strCommand == \"block\" && !fImporting && !fReindex) // Ignore blocks received while importing\n     {\n         CBlock block;"
      },
      {
        "sha": "6149430da358a7fb9f593b5fbb0f408cfe193c18",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -64,6 +64,10 @@ static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n /** The pre-allocation chunk size for rev?????.dat files (since 0.8) */\n static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n+/** 0 = no compression, 2 = maximum compression. */\n+static const unsigned int DEFAULT_COMPRESSION_LEVEL = 1;\n+/** The size in Bytes below which we do not compress transactions */\n+static const unsigned int MIN_TX_COMPRESS_SIZE = 500;\n \n /** Maximum number of script-checking threads allowed */\n static const int MAX_SCRIPTCHECK_THREADS = 16;"
      },
      {
        "sha": "ab2a71db5b6ad8bad1634220acf49d2da00a56bb",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -79,6 +79,10 @@ enum {\n     // Bitcoin Core nodes used to support this by default, without advertising this bit,\n     // but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)\n     NODE_BLOOM = (1 << 2),\n+    // NODE_COMPRESS means the node supports both compression and decompression of datastreams\n+    // If this is turned off then neither compression nor decompression will not be performed by \n+    // the node.\n+    NODE_COMPRESS = (1 << 28),\n \n     // Bits 24-31 are reserved for temporary experiments. Just pick a bit that\n     // isn't getting used, or one not being used much, and notify the\n@@ -87,6 +91,7 @@ enum {\n     // collisions and other cases where nodes may be advertising a service they\n     // do not actually support. Other service bits should be allocated via the\n     // BIP process.\n+\n };\n \n /** A CService with information about it as peer */"
      },
      {
        "sha": "0c958bdb05e86413a7e52db1ac58e55115c8f4ba",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 107,
        "deletions": 5,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b4a62e308e3144b8a98ec5428106248902b9190/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b4a62e308e3144b8a98ec5428106248902b9190/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=8b4a62e308e3144b8a98ec5428106248902b9190",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"support/allocators/zeroafterfree.h\"\n #include \"serialize.h\"\n+#include \"util.h\"\n \n #include <algorithm>\n #include <assert.h>\n@@ -22,6 +23,16 @@\n #include <utility>\n #include <vector>\n \n+#include <lzo/lzoconf.h>\n+#include <lzo/lzo1x.h>\n+\n+/* portability layer for LZO */\n+static const char *progname = NULL;\n+#define WANT_LZO_MALLOC 1\n+#define WANT_XMALLOC 1\n+#include \"../examples/portab.h\"\n+\n+\n /** Double ended buffer combining vector and stream-like interfaces.\n  *\n  * >> and << read and write unformatted data using the above serialization templates.\n@@ -148,6 +159,18 @@ class CDataStream\n         else\n             vch.insert(it, first, last);\n     }\n+    void insert(iterator it, const unsigned char* first, const unsigned char* last)\n+    {\n+        assert(last - first >= 0);\n+        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n+        {\n+            // special case for inserting at the front when there's room\n+            nReadPos -= (last - first);\n+            memcpy(&vch[nReadPos], &first[0], last - first);\n+        }\n+        else\n+            vch.insert(it, first, last);\n+    }\n #endif\n \n     iterator erase(iterator it)\n@@ -319,12 +342,91 @@ class CDataStream\n                 j = 0;\n         }\n     }\n-};\n-\n-\n-\n-\n+    /**\n+     * Compress the datastream\n+     *    cmpLevel = Compression level\n+     */\n+    bool compress(CDataStream& css, int cmpLevel)\n+    {\n+        int r;\n+        lzo_bytep pUncmp;\n+        lzo_bytep pCmp;\n+        lzo_voidp wrkMem;\n+        lzo_uint wrkMemSize;\n+        lzo_uint unCmpSize = this->size();\n+        lzo_uint cmpSize = unCmpSize + unCmpSize / 16 + 64 + 3;\n+\n+        // Allocate blocks and the work-memory\n+        pUncmp = (lzo_bytep) xmalloc(unCmpSize);\n+        pCmp = (lzo_bytep) xmalloc(cmpSize);\n+        if (cmpLevel == 1)\n+            wrkMemSize = LZO1X_1_MEM_COMPRESS;\n+        else\n+            wrkMemSize = LZO1X_999_MEM_COMPRESS;\n+        wrkMem = (lzo_voidp) xmalloc(wrkMemSize);\n+        if (pCmp == NULL || pUncmp == NULL || wrkMem == NULL) {\n+            LogPrintf(\"ERROR: out of memory!!!\\n\");\n+            return false;\n+        }\n+        memcpy(pUncmp, &(*this->begin()), this->size());\n \n+        // Compress\n+        if (cmpLevel == 1)\n+           r = lzo1x_1_compress(pUncmp, unCmpSize, pCmp, &cmpSize, wrkMem);\n+        else\n+           r = lzo1x_999_compress(pUncmp, unCmpSize, pCmp, &cmpSize, wrkMem);\n+        if (r != LZO_E_OK) {\n+            // This should NEVER happen\n+            LogPrintf(\"ERROR: Compression failed - error code %d\\n\",r);\n+            lzo_free(wrkMem);\n+            lzo_free(pCmp);\n+            lzo_free(pUncmp);\n+            return false;\n+        }\n+        css.insert(css.begin(), (const unsigned char*)&pCmp[0], (const unsigned char*)&pCmp[cmpSize]);\n+        LogPrint(\"compress\",\"Compressed Data from %lu to %lu bytes\\n\", unCmpSize, cmpSize);\n+        lzo_free(wrkMem);\n+        lzo_free(pCmp);\n+        lzo_free(pUncmp);\n+        return true;\n+    }     \n+    /**\n+     * Uncompress the datastream \n+     *    unCmpSize = Maximum size in bytes of the uncompressed data.  \n+     *                It does not need to be exact, just equal to or larger than what you are expecting.\n+     */\n+    bool decompress(CDataStream& ss, unsigned long unCmpSize)\n+    {\n+        int r;\n+        lzo_bytep pCmp;\n+        lzo_bytep pUncmp;\n+        lzo_uint cmpSize = this->size();\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n+        // Allocate blocks\n+        pCmp = (lzo_bytep) xmalloc(cmpSize);\n+        pUncmp = (lzo_bytep) xmalloc(unCmpSize);\n+        if (pCmp == NULL || pUncmp == NULL) {\n+            LogPrintf(\"ERROR: out of memory!!!\\n\");\n+            return false;\n+        }\n+        memcpy(pCmp, &(*this->begin()), this->size());\n+\n+        // Decompress\n+        r = lzo1x_decompress(pCmp, cmpSize, pUncmp, &unCmpSize, NULL);\n+        if (r != LZO_E_OK) {\n+            // This should NEVER happen\n+            LogPrintf(\"ERROR: Decompression failed - error code %d\\n\",r);\n+            lzo_free(pCmp);\n+            lzo_free(pUncmp);\n+            return false;\n+        }\n+        ss.insert(ss.begin(), (const unsigned char*)&pUncmp[0], (const unsigned char*)&pUncmp[unCmpSize]);\n+        LogPrint(\"compress\",\"Decompressed Data from %lu to %lu bytes\\n\", cmpSize, unCmpSize);\n+        lzo_free(pCmp);\n+        lzo_free(pUncmp);\n+        return true;\n+    }     \n+};\n \n \n "
      }
    ]
  }
]