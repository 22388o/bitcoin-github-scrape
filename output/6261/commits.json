[
  {
    "sha": "0b7b8669cd93974622af66baf190ee201cc84c4b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYjdiODY2OWNkOTM5NzQ2MjJhZjY2YmFmMTkwZWUyMDFjYzg0YzRi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-13T17:59:41Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-09-28T15:12:24Z"
      },
      "message": "Refactor: protect mapNodeState with its own lock\n\nEncapsulate mapNodeState in a smart-pointer class with its own lock.\n\nWhy? So Misbehaving() can be called from the sanity-check-a-message code without holding cs_main.\n\nAnd to get better exception safety (the smart-pointer approach gives RAII semantics).\n\nAnd because protecting fewer things with cs_main is a good idea.\n\nTested by compiling with -DDEBUG_LOCKORDER, running all of the qa/rpc-tests, and running a node on the main network overnight.",
      "tree": {
        "sha": "126ca5a9e496f15d597644b95592566cfed9df56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/126ca5a9e496f15d597644b95592566cfed9df56"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0b7b8669cd93974622af66baf190ee201cc84c4b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlYJWNsACgkQdYgkL74406jD/ACbBTvQF/9HcohsNn/uW5rF8+Po\nLJUAoIE7Slj/2aIflG1Ny9eEQMwz9Aev\n=tPSh\n-----END PGP SIGNATURE-----",
        "payload": "tree 126ca5a9e496f15d597644b95592566cfed9df56\nparent 1a9f19a78daa392baf2e062bddff597ce0ce30b6\nauthor Gavin Andresen <gavinandresen@gmail.com> 1436810381 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1443453144 -0400\n\nRefactor: protect mapNodeState with its own lock\n\nEncapsulate mapNodeState in a smart-pointer class with its own lock.\n\nWhy? So Misbehaving() can be called from the sanity-check-a-message code without holding cs_main.\n\nAnd to get better exception safety (the smart-pointer approach gives RAII semantics).\n\nAnd because protecting fewer things with cs_main is a good idea.\n\nTested by compiling with -DDEBUG_LOCKORDER, running all of the qa/rpc-tests, and running a node on the main network overnight.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b7b8669cd93974622af66baf190ee201cc84c4b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0b7b8669cd93974622af66baf190ee201cc84c4b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b7b8669cd93974622af66baf190ee201cc84c4b/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a9f19a78daa392baf2e062bddff597ce0ce30b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a9f19a78daa392baf2e062bddff597ce0ce30b6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a9f19a78daa392baf2e062bddff597ce0ce30b6"
      }
    ],
    "stats": {
      "total": 165,
      "additions": 107,
      "deletions": 58
    },
    "files": [
      {
        "sha": "500edc82e3b9a69cf43748f391d76757655fe21f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 107,
        "deletions": 58,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b7b8669cd93974622af66baf190ee201cc84c4b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b7b8669cd93974622af66baf190ee201cc84c4b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0b7b8669cd93974622af66baf190ee201cc84c4b",
        "patch": "@@ -271,24 +271,71 @@ struct CNodeState {\n     }\n };\n \n-/** Map maintaining per-node state. Requires cs_main. */\n-map<NodeId, CNodeState> mapNodeState;\n+// Class that maintains per-node state, and\n+// acts as a RAII smart-pointer that make sure\n+// the state stays consistent.\n+class NodeStatePtr {\n+private:\n+    static CCriticalSection cs_mapNodeState;\n+    static map<NodeId, CNodeState> mapNodeState;\n+    CNodeState* s;\n+    NodeId id;\n+public:\n+    static void insert(NodeId nodeid, const CNode *pnode) {\n+        LOCK(cs_mapNodeState);\n+        CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;\n+        state.name = pnode->addrName;\n+        state.address = pnode->addr;\n+    }\n \n-// Requires cs_main.\n-CNodeState *State(NodeId pnode) {\n-    map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n-    if (it == mapNodeState.end())\n-        return NULL;\n-    return &it->second;\n-}\n+    NodeStatePtr(NodeId nodeid) {\n+        LOCK(cs_mapNodeState);\n+        map<NodeId, CNodeState>::iterator it = mapNodeState.find(nodeid);\n+        if (it == mapNodeState.end())\n+            s = NULL;\n+        else {\n+            s = &it->second;\n+            id = nodeid;\n+            cs_mapNodeState.lock();\n+        }\n+    }\n+    ~NodeStatePtr() {\n+        if (s)\n+            cs_mapNodeState.unlock();\n+    }\n+    bool IsNull() const { return s == NULL; }\n+\n+    CNodeState* operator ->() { return s; }\n+    const CNodeState* operator ->() const { return s; }\n+\n+    void erase() {\n+        if (s) {\n+            mapNodeState.erase(id);\n+            s = NULL;\n+            cs_mapNodeState.unlock();\n+        }\n+    }\n+\n+    static void clear() {\n+        LOCK(cs_mapNodeState);\n+        mapNodeState.clear();\n+    }\n+\n+private:\n+    // disallow copy/assignment\n+    NodeStatePtr(const NodeStatePtr&) {}\n+    NodeStatePtr& operator=(const NodeStatePtr& p) { return *this; }\n+};\n+CCriticalSection NodeStatePtr::cs_mapNodeState;\n+map<NodeId, CNodeState> NodeStatePtr::mapNodeState;\n \n int GetHeight()\n {\n     LOCK(cs_main);\n     return chainActive.Height();\n }\n \n-void UpdatePreferredDownload(CNode* node, CNodeState* state)\n+void UpdatePreferredDownload(CNode* node, NodeStatePtr& state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n \n@@ -305,15 +352,12 @@ int64_t GetBlockTimeout(int64_t nTime, int nValidatedQueuedBefore, const Consens\n }\n \n void InitializeNode(NodeId nodeid, const CNode *pnode) {\n-    LOCK(cs_main);\n-    CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;\n-    state.name = pnode->addrName;\n-    state.address = pnode->addr;\n+    NodeStatePtr::insert(nodeid, pnode);\n }\n \n void FinalizeNode(NodeId nodeid) {\n     LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n+    NodeStatePtr state(nodeid);\n \n     if (state->fSyncStarted)\n         nSyncStarted--;\n@@ -327,15 +371,16 @@ void FinalizeNode(NodeId nodeid) {\n     EraseOrphansFor(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n \n-    mapNodeState.erase(nodeid);\n+    state.erase();\n }\n \n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n bool MarkBlockAsReceived(const uint256& hash) {\n+    AssertLockHeld(cs_main);\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n+        NodeStatePtr state(itInFlight->second.first);\n         nQueuedValidatedHeaders -= itInFlight->second.second->fValidatedHeaders;\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n@@ -349,12 +394,14 @@ bool MarkBlockAsReceived(const uint256& hash) {\n \n // Requires cs_main.\n void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    AssertLockHeld(cs_main);\n \n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n+    NodeStatePtr state(nodeid);\n+    assert(!state.IsNull());\n+\n     int64_t nNow = GetTimeMicros();\n     QueuedBlock newentry = {hash, pindex, nNow, pindex != NULL, GetBlockTimeout(nNow, nQueuedValidatedHeaders, consensusParams)};\n     nQueuedValidatedHeaders += newentry.fValidatedHeaders;\n@@ -365,9 +412,8 @@ void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n }\n \n /** Check whether the last unknown block a peer advertized is not yet known. */\n-void ProcessBlockAvailability(NodeId nodeid) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+static void ProcessBlockAvailability(NodeStatePtr& state) {\n+    AssertLockHeld(cs_main);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n         BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n@@ -381,10 +427,11 @@ void ProcessBlockAvailability(NodeId nodeid) {\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    AssertLockHeld(cs_main);\n+    NodeStatePtr state(nodeid);\n+    assert(!state.IsNull());\n \n-    ProcessBlockAvailability(nodeid);\n+    ProcessBlockAvailability(state);\n \n     BlockMap::iterator it = mapBlockIndex.find(hash);\n     if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {\n@@ -422,12 +469,13 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n     if (count == 0)\n         return;\n \n+    AssertLockHeld(cs_main);\n     vBlocks.reserve(vBlocks.size() + count);\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    NodeStatePtr state(nodeid);\n+    assert(!state.IsNull());\n \n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n-    ProcessBlockAvailability(nodeid);\n+    ProcessBlockAvailability(state);\n \n     if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n         // This peer has nothing interesting.\n@@ -503,9 +551,8 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n } // anon namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n-    LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n-    if (state == NULL)\n+    NodeStatePtr state(nodeid);\n+    if (state.IsNull())\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n@@ -1196,14 +1243,13 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n-// Requires cs_main.\n void Misbehaving(NodeId pnode, int howmuch)\n {\n     if (howmuch == 0)\n         return;\n \n-    CNodeState *state = State(pnode);\n-    if (state == NULL)\n+    NodeStatePtr state(pnode);\n+    if (state.IsNull())\n         return;\n \n     state->nMisbehavior += howmuch;\n@@ -1237,10 +1283,11 @@ void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state\n     int nDoS = 0;\n     if (state.IsInvalid(nDoS)) {\n         std::map<uint256, NodeId>::iterator it = mapBlockSource.find(pindex->GetBlockHash());\n-        if (it != mapBlockSource.end() && State(it->second)) {\n+        NodeStatePtr nodeState(it->second);\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+        if (it != mapBlockSource.end() && !nodeState.IsNull()) {\n             CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), pindex->GetBlockHash()};\n-            State(it->second)->rejects.push_back(reject);\n+            nodeState->rejects.push_back(reject);\n             if (nDoS > 0)\n                 Misbehaving(it->second, nDoS);\n         }\n@@ -3285,7 +3332,7 @@ void UnloadBlockIndex()\n     nPreferredDownload = 0;\n     setDirtyBlockIndex.clear();\n     setDirtyFileInfo.clear();\n-    mapNodeState.clear();\n+    NodeStatePtr::clear();\n     recentRejects.reset(NULL);\n \n     BOOST_FOREACH(BlockMap::value_type& entry, mapBlockIndex) {\n@@ -3944,7 +3991,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n         // Potentially mark this peer as a preferred download peer.\n-        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n+        {\n+            NodeStatePtr nodeState(pfrom->GetId());\n+            UpdatePreferredDownload(pfrom, nodeState);\n+        }\n \n         // Change version\n         pfrom->PushMessage(\"verack\");\n@@ -4018,8 +4068,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // Mark this node as currently connected, so we update its timestamp later.\n         if (pfrom->fNetworkNode) {\n-            LOCK(cs_main);\n-            State(pfrom->GetId())->fCurrentlyConnected = true;\n+            NodeStatePtr(pfrom->GetId())->fCurrentlyConnected = true;\n         }\n     }\n \n@@ -4130,7 +4179,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // doing this will result in the received block being rejected as an orphan in case it is\n                     // not a direct successor.\n                     pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexBestHeader), inv.hash);\n-                    CNodeState *nodestate = State(pfrom->GetId());\n+                    NodeStatePtr nodestate(pfrom->GetId());\n                     if (chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - chainparams.GetConsensus().nPowTargetSpacing * 20 &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         vToFetch.push_back(inv);\n@@ -4926,8 +4975,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 pto->PushMessage(\"addr\", vAddr);\n         }\n \n-        CNodeState &state = *State(pto->GetId());\n-        if (state.fShouldBan) {\n+        NodeStatePtr statePtr(pto->GetId());\n+        if (statePtr->fShouldBan) {\n             if (pto->fWhitelisted)\n                 LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n             else {\n@@ -4939,21 +4988,21 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     CNode::Ban(pto->addr, BanReasonNodeMisbehaving);\n                 }\n             }\n-            state.fShouldBan = false;\n+            statePtr->fShouldBan = false;\n         }\n \n-        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n+        BOOST_FOREACH(const CBlockReject& reject, statePtr->rejects)\n             pto->PushMessage(\"reject\", (string)\"block\", reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n-        state.rejects.clear();\n+        statePtr->rejects.clear();\n \n         // Start block sync\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n-        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        bool fFetch = statePtr->fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n+        if (!statePtr->fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n-                state.fSyncStarted = true;\n+                statePtr->fSyncStarted = true;\n                 nSyncStarted++;\n                 CBlockIndex *pindexStart = pindexBestHeader->pprev ? pindexBestHeader->pprev : pindexBestHeader;\n                 LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n@@ -5019,7 +5068,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n         // Detect whether we're stalling\n         int64_t nNow = GetTimeMicros();\n-        if (!pto->fDisconnect && state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+        if (!pto->fDisconnect && statePtr->nStallingSince && statePtr->nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n@@ -5036,9 +5085,9 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // only looking at this peer's oldest request).  This way a large queue in the past doesn't result in a\n         // permanently large window for this block to be delivered (ie if the number of blocks in flight is decreasing\n         // more quickly than once every 5 minutes, then we'll shorten the download window for this block).\n-        if (!pto->fDisconnect && state.vBlocksInFlight.size() > 0) {\n-            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int64_t nTimeoutIfRequestedNow = GetBlockTimeout(nNow, nQueuedValidatedHeaders - state.nBlocksInFlightValidHeaders, consensusParams);\n+        if (!pto->fDisconnect && statePtr->vBlocksInFlight.size() > 0) {\n+            QueuedBlock &queuedBlock = statePtr->vBlocksInFlight.front();\n+            int64_t nTimeoutIfRequestedNow = GetBlockTimeout(nNow, nQueuedValidatedHeaders - statePtr->nBlocksInFlightValidHeaders, consensusParams);\n             if (queuedBlock.nTimeDisconnect > nTimeoutIfRequestedNow) {\n                 LogPrint(\"net\", \"Reducing block download timeout for peer=%d block=%s, orig=%d new=%d\\n\", pto->id, queuedBlock.hash.ToString(), queuedBlock.nTimeDisconnect, nTimeoutIfRequestedNow);\n                 queuedBlock.nTimeDisconnect = nTimeoutIfRequestedNow;\n@@ -5053,19 +5102,19 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && statePtr->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             vector<CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - statePtr->nBlocksInFlight, vToDownload, staller);\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n                 vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n                 LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->id);\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n-                if (State(staller)->nStallingSince == 0) {\n-                    State(staller)->nStallingSince = nNow;\n+            if (statePtr->nBlocksInFlight == 0 && staller != -1) {\n+                if (NodeStatePtr(staller)->nStallingSince == 0) {\n+                    NodeStatePtr(staller)->nStallingSince = nNow;\n                     LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "6edddab5e51f3d666444312b179b0fb53edf5bec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZWRkZGFiNWU1MWYzZDY2NjQ0NDMxMmIxNzliMGZiNTNlZGY1YmVj",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-05T18:21:24Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-09-28T15:18:41Z"
      },
      "message": "Refactor, new CNode::FinalizeHeader method\n\nI need this to write some unit tests for the\nCNode::ReceiveMsgBytes() function.",
      "tree": {
        "sha": "55d6c72f3ec863343bcc472cef5a707d0b4c18af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/55d6c72f3ec863343bcc472cef5a707d0b4c18af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6edddab5e51f3d666444312b179b0fb53edf5bec",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlYJWlUACgkQdYgkL74406ipWgCeIouoY7kvFK6Ht9+RMSG0SHw8\nfnoAn3o2aDMebxI+fS2BsnZLkbVQQ5i1\n=r94T\n-----END PGP SIGNATURE-----",
        "payload": "tree 55d6c72f3ec863343bcc472cef5a707d0b4c18af\nparent 0b7b8669cd93974622af66baf190ee201cc84c4b\nauthor Gavin Andresen <gavinandresen@gmail.com> 1433528484 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1443453521 -0400\n\nRefactor, new CNode::FinalizeHeader method\n\nI need this to write some unit tests for the\nCNode::ReceiveMsgBytes() function.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6edddab5e51f3d666444312b179b0fb53edf5bec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6edddab5e51f3d666444312b179b0fb53edf5bec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6edddab5e51f3d666444312b179b0fb53edf5bec/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0b7b8669cd93974622af66baf190ee201cc84c4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b7b8669cd93974622af66baf190ee201cc84c4b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0b7b8669cd93974622af66baf190ee201cc84c4b"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 20,
      "deletions": 9
    },
    "files": [
      {
        "sha": "048c00ec20296c92fb6174ad9734be653e281336",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6edddab5e51f3d666444312b179b0fb53edf5bec/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6edddab5e51f3d666444312b179b0fb53edf5bec/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6edddab5e51f3d666444312b179b0fb53edf5bec",
        "patch": "@@ -675,6 +675,22 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n     return true;\n }\n \n+unsigned int CNetMessage::FinalizeHeader(CDataStream& s)\n+{\n+    // Set the size\n+    unsigned int nSize = s.size() - CMessageHeader::HEADER_SIZE;\n+    WriteLE32((uint8_t*)&s[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n+\n+    // Set the checksum\n+    uint256 hash = Hash(s.begin() + CMessageHeader::HEADER_SIZE, s.end());\n+    unsigned int nChecksum = 0;\n+    memcpy(&nChecksum, &hash, sizeof(nChecksum));\n+    assert(s.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n+    memcpy((char*)&s[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n+\n+    return nSize;\n+}\n+\n int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n {\n     // copy data to temporary parsing buffer\n@@ -2356,16 +2372,8 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n         LEAVE_CRITICAL_SECTION(cs_vSend);\n         return;\n     }\n-    // Set the size\n-    unsigned int nSize = ssSend.size() - CMessageHeader::HEADER_SIZE;\n-    WriteLE32((uint8_t*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n \n-    // Set the checksum\n-    uint256 hash = Hash(ssSend.begin() + CMessageHeader::HEADER_SIZE, ssSend.end());\n-    unsigned int nChecksum = 0;\n-    memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-    assert(ssSend.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n-    memcpy((char*)&ssSend[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n+    unsigned int nSize = CNetMessage::FinalizeHeader(ssSend);\n \n     LogPrint(\"net\", \"(%d bytes) peer=%d\\n\", nSize, id);\n "
      },
      {
        "sha": "5e4ce1a9872bc98b72e2084627417119bfe59a76",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6edddab5e51f3d666444312b179b0fb53edf5bec/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6edddab5e51f3d666444312b179b0fb53edf5bec/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=6edddab5e51f3d666444312b179b0fb53edf5bec",
        "patch": "@@ -217,6 +217,9 @@ class CNetMessage {\n         nTime = 0;\n     }\n \n+    // Called by CNode::EndMessage() and unit tests: modify stream to set size/checksum of header\n+    static unsigned int FinalizeHeader(CDataStream& s);\n+\n     bool complete() const\n     {\n         if (!in_data)"
      }
    ]
  },
  {
    "sha": "8dbdcd59969ecab320b03205fa1a20591707eae3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZGJkY2Q1OTk2OWVjYWIzMjBiMDMyMDVmYTFhMjA1OTE3MDdlYWUz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-05T19:09:21Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-09-28T15:23:34Z"
      },
      "message": "Unit test for CNode::ReceiveMsgBytes",
      "tree": {
        "sha": "b08b9fc9b83cd378e9d16224735f39ac8312ecbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b08b9fc9b83cd378e9d16224735f39ac8312ecbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8dbdcd59969ecab320b03205fa1a20591707eae3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlYJW3gACgkQdYgkL74406i3gwCfdCCaIs6iUwfegk/pDRHthCsS\nLp4AoM3Z09g6EDO7HCYKV5Z17ONx0Nwh\n=3Vne\n-----END PGP SIGNATURE-----",
        "payload": "tree b08b9fc9b83cd378e9d16224735f39ac8312ecbf\nparent 6edddab5e51f3d666444312b179b0fb53edf5bec\nauthor Gavin Andresen <gavinandresen@gmail.com> 1433531361 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1443453814 -0400\n\nUnit test for CNode::ReceiveMsgBytes\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8dbdcd59969ecab320b03205fa1a20591707eae3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8dbdcd59969ecab320b03205fa1a20591707eae3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8dbdcd59969ecab320b03205fa1a20591707eae3/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6edddab5e51f3d666444312b179b0fb53edf5bec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6edddab5e51f3d666444312b179b0fb53edf5bec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6edddab5e51f3d666444312b179b0fb53edf5bec"
      }
    ],
    "stats": {
      "total": 91,
      "additions": 91,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a07c4dd9fb1bb300cba0984cbb0854af08661d20",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8dbdcd59969ecab320b03205fa1a20591707eae3/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8dbdcd59969ecab320b03205fa1a20591707eae3/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=8dbdcd59969ecab320b03205fa1a20591707eae3",
        "patch": "@@ -63,6 +63,7 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/reverselock_tests.cpp \\\n+  test/ReceiveMsgBytes_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\"
      },
      {
        "sha": "51daef5c9998f28170c37b896bb3ddb79982afba",
        "filename": "src/test/ReceiveMsgBytes_tests.cpp",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8dbdcd59969ecab320b03205fa1a20591707eae3/src/test/ReceiveMsgBytes_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8dbdcd59969ecab320b03205fa1a20591707eae3/src/test/ReceiveMsgBytes_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ReceiveMsgBytes_tests.cpp?ref=8dbdcd59969ecab320b03205fa1a20591707eae3",
        "patch": "@@ -0,0 +1,90 @@\n+// Copyright (c) 2011-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+//\n+// Unit tests for CNode::ReceiveMsgBytes\n+//\n+\n+\n+#include \"chainparams.h\"\n+#include \"main.h\"\n+#include \"net.h\"\n+#include \"pow.h\"\n+#include \"serialize.h\"\n+#include \"util.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(ReceiveMsgBytes_tests, TestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(FullMessages)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params(CBaseChainParams::MAIN).MessageStart(), \"ping\", 0);\n+    s << (uint64_t)11; // ping nonce\n+    CNetMessage::FinalizeHeader(s);\n+\n+    LOCK(testNode.cs_vRecvMsg);\n+\n+    // Receive a full 'ping' message\n+    {\n+        BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        CNetMessage& msg = testNode.vRecvMsg[0];\n+        BOOST_CHECK(msg.complete());\n+        BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n+        uint64_t nonce;\n+        msg.vRecv >> nonce;\n+        BOOST_CHECK_EQUAL(nonce, (uint64_t)11);\n+    }\n+\n+\n+    testNode.vRecvMsg.clear();\n+\n+    // ...receive it one byte at a time:\n+    {\n+        for (size_t i = 0; i < s.size(); i++) {\n+            BOOST_CHECK(testNode.ReceiveMsgBytes(&s[i], 1));\n+        }\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        CNetMessage& msg = testNode.vRecvMsg[0];\n+        BOOST_CHECK(msg.complete());\n+        BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n+        uint64_t nonce;\n+        msg.vRecv >> nonce;\n+        BOOST_CHECK_EQUAL(nonce, (uint64_t)11);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(TooLarge)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params(CBaseChainParams::MAIN).MessageStart(), \"ping\", 0);\n+    size_t headerLen = s.size();\n+    s << (uint64_t)11; // ping nonce\n+\n+    // Test: too large\n+    s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen+1);\n+    CNetMessage::FinalizeHeader(s);\n+\n+    BOOST_CHECK(!testNode.ReceiveMsgBytes(&s[0], s.size()));\n+\n+    testNode.vRecvMsg.clear();\n+\n+    // Test: exactly at max:\n+    s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen);\n+    CNetMessage::FinalizeHeader(s);\n+\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "a4a18f03690b64e641afe49b757e1ef126e7bfb3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNGExOGYwMzY5MGI2NGU2NDFhZmU0OWI3NTdlMWVmMTI2ZTdiZmIz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-05T20:44:18Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-09-28T15:30:00Z"
      },
      "message": "Allow per-message sanity checking when reading from wire",
      "tree": {
        "sha": "0e305b65217a60e89db0b788c0b61042475cfb28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e305b65217a60e89db0b788c0b61042475cfb28"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a4a18f03690b64e641afe49b757e1ef126e7bfb3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlYJXPoACgkQdYgkL74406hfQACeIsD0hq9YpPFMLa58O4HNlN2M\ngogAoK/DxRJvALZhBjz0Tbrs3WP/nds9\n=3FAM\n-----END PGP SIGNATURE-----",
        "payload": "tree 0e305b65217a60e89db0b788c0b61042475cfb28\nparent 8dbdcd59969ecab320b03205fa1a20591707eae3\nauthor Gavin Andresen <gavinandresen@gmail.com> 1433537058 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1443454200 -0400\n\nAllow per-message sanity checking when reading from wire\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4a18f03690b64e641afe49b757e1ef126e7bfb3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a4a18f03690b64e641afe49b757e1ef126e7bfb3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4a18f03690b64e641afe49b757e1ef126e7bfb3/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8dbdcd59969ecab320b03205fa1a20591707eae3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8dbdcd59969ecab320b03205fa1a20591707eae3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8dbdcd59969ecab320b03205fa1a20591707eae3"
      }
    ],
    "stats": {
      "total": 108,
      "additions": 94,
      "deletions": 14
    },
    "files": [
      {
        "sha": "c90699d6e08a48077c4b0d70b9bcc6625833fa77",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=a4a18f03690b64e641afe49b757e1ef126e7bfb3",
        "patch": "@@ -37,6 +37,7 @@\n #include <sstream>\n \n #include <boost/algorithm/string/replace.hpp>\n+#include <boost/assign/list_of.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n #include <boost/math/distributions/poisson.hpp>\n@@ -87,6 +88,8 @@ map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);;\n map<uint256, set<uint256> > mapOrphanTransactionsByPrev GUARDED_BY(cs_main);;\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+static bool SanityCheckMessage(CNode* peer, const CNetMessage& msg);\n+\n /**\n  * Returns true if there are nRequired or more blocks of minVersion or above\n  * in the last Consensus::Params::nMajorityWindow blocks, starting at pstart and going backwards.\n@@ -567,6 +570,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n void RegisterNodeSignals(CNodeSignals& nodeSignals)\n {\n     nodeSignals.GetHeight.connect(&GetHeight);\n+    nodeSignals.SanityCheckMessages.connect(&SanityCheckMessage);\n     nodeSignals.ProcessMessages.connect(&ProcessMessages);\n     nodeSignals.SendMessages.connect(&SendMessages);\n     nodeSignals.InitializeNode.connect(&InitializeNode);\n@@ -576,6 +580,7 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals)\n void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n {\n     nodeSignals.GetHeight.disconnect(&GetHeight);\n+    nodeSignals.SanityCheckMessages.disconnect(&SanityCheckMessage);\n     nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n     nodeSignals.SendMessages.disconnect(&SendMessages);\n     nodeSignals.InitializeNode.disconnect(&InitializeNode);\n@@ -3753,6 +3758,30 @@ std::string GetWarnings(const std::string& strFor)\n // Messages\n //\n \n+static std::map<std::string, size_t> maxMessageSizes = boost::assign::map_list_of\n+    (\"getaddr\",0)\n+    (\"mempool\",0)\n+    (\"ping\",8)\n+    (\"pong\",8)\n+    (\"verack\", 0)\n+    ;\n+\n+bool static SanityCheckMessage(CNode* peer, const CNetMessage& msg)\n+{\n+    const std::string& strCommand = msg.hdr.GetCommand();\n+    if (msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH ||\n+        (maxMessageSizes.count(strCommand) && msg.hdr.nMessageSize > maxMessageSizes[strCommand])) {\n+        LogPrint(\"net\", \"Oversized %s message from peer=%i (%d bytes)\\n\",\n+                 SanitizeString(strCommand), peer->GetId(), msg.hdr.nMessageSize);\n+        Misbehaving(peer->GetId(), 20);\n+        return msg.hdr.nMessageSize <= MAX_PROTOCOL_MESSAGE_LENGTH;\n+    }\n+    // This would be a good place for more sophisticated DoS detection/prevention.\n+    // (e.g. disconnect a peer that is flooding us with excessive messages)\n+\n+    return true;\n+}\n+\n \n bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {"
      },
      {
        "sha": "0dfb8f42a5290f63e9bd2f14723b97658d484c85",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=a4a18f03690b64e641afe49b757e1ef126e7bfb3",
        "patch": "@@ -79,6 +79,8 @@ static const unsigned int DATABASE_WRITE_INTERVAL = 60 * 60;\n static const unsigned int DATABASE_FLUSH_INTERVAL = 24 * 60 * 60;\n /** Maximum length of reject messages. */\n static const unsigned int MAX_REJECT_MESSAGE_LENGTH = 111;\n+/** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n \n struct BlockHasher\n {"
      },
      {
        "sha": "90b0dd2429b8bb844989d9d6c3d3bb43417ffaaa",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a4a18f03690b64e641afe49b757e1ef126e7bfb3",
        "patch": "@@ -656,12 +656,10 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n             handled = msg.readData(pch, nBytes);\n \n         if (handled < 0)\n-                return false;\n+            return false;\n \n-        if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n-            LogPrint(\"net\", \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n+        if (msg.in_data && !g_signals.SanityCheckMessages(this, boost::ref(msg)))\n             return false;\n-        }\n \n         pch += handled;\n         nBytes -= handled;"
      },
      {
        "sha": "e971c220e5956e75ae8c8a3f16cdefe53686a9d0",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a4a18f03690b64e641afe49b757e1ef126e7bfb3",
        "patch": "@@ -30,6 +30,7 @@\n \n class CAddrMan;\n class CScheduler;\n+class CNetMessage;\n class CNode;\n \n namespace boost {\n@@ -44,8 +45,6 @@ static const int TIMEOUT_INTERVAL = 20 * 60;\n static const unsigned int MAX_INV_SZ = 50000;\n /** The maximum number of new addresses to accumulate before announcing. */\n static const unsigned int MAX_ADDR_TO_SEND = 1000;\n-/** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n-static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n /** Maximum length of strSubVer in `version` message */\n static const unsigned int MAX_SUBVERSION_LENGTH = 256;\n /** -listen default */\n@@ -96,10 +95,14 @@ struct CombinerAll\n     }\n };\n \n-// Signals for message handling\n+// Signals are used to communicate with higher-level code.\n struct CNodeSignals\n {\n     boost::signals2::signal<int ()> GetHeight;\n+    // register a handler for this signal to do sanity checks as the bytes of a message are being\n+    // received. Note that the message may not be completely read (so this can be\n+    // used to prevent DoS attacks using over-size messages).\n+    boost::signals2::signal<bool (CNode*, const CNetMessage&), CombinerAll> SanityCheckMessages;\n     boost::signals2::signal<bool (CNode*), CombinerAll> ProcessMessages;\n     boost::signals2::signal<bool (CNode*, bool), CombinerAll> SendMessages;\n     boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;"
      },
      {
        "sha": "2a9635b4f9925d73b531aeac4fd78cb9fdf67c89",
        "filename": "src/test/ReceiveMsgBytes_tests.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 7,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/test/ReceiveMsgBytes_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4a18f03690b64e641afe49b757e1ef126e7bfb3/src/test/ReceiveMsgBytes_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ReceiveMsgBytes_tests.cpp?ref=a4a18f03690b64e641afe49b757e1ef126e7bfb3",
        "patch": "@@ -12,7 +12,7 @@\n #include \"net.h\"\n #include \"pow.h\"\n #include \"serialize.h\"\n-#include \"util.h\"\n+#include \"utilstrencodings.h\"\n \n #include \"test/test_bitcoin.h\"\n \n@@ -35,7 +35,7 @@ BOOST_AUTO_TEST_CASE(FullMessages)\n     // Receive a full 'ping' message\n     {\n         BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n-        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(),1UL);\n         CNetMessage& msg = testNode.vRecvMsg[0];\n         BOOST_CHECK(msg.complete());\n         BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n@@ -52,25 +52,31 @@ BOOST_AUTO_TEST_CASE(FullMessages)\n         for (size_t i = 0; i < s.size(); i++) {\n             BOOST_CHECK(testNode.ReceiveMsgBytes(&s[i], 1));\n         }\n-        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(),1UL);\n         CNetMessage& msg = testNode.vRecvMsg[0];\n         BOOST_CHECK(msg.complete());\n         BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n         uint64_t nonce;\n         msg.vRecv >> nonce;\n         BOOST_CHECK_EQUAL(nonce, (uint64_t)11);\n-    }\n+   }\n }\n \n-BOOST_AUTO_TEST_CASE(TooLarge)\n+BOOST_AUTO_TEST_CASE(TooLargeBlock)\n {\n+    // Random real block (000000000000dab0130bbcc991d3d7ae6b81aa6f50a798888dfe62337458dc45)\n+    // With one tx\n+    CBlock block;\n+    CDataStream stream(ParseHex(\"0100000079cda856b143d9db2c1caff01d1aecc8630d30625d10e8b4b8b0000000000000b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f196367291b4d4c86041b8fa45d630101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff08044c86041b020a02ffffffff0100f2052a01000000434104ecd3229b0571c3be876feaac0442a9f13c5a572742927af1dc623353ecf8c202225f64868137a18cdd85cbbb4c74fbccfd4f49639cf1bdc94a5672bb15ad5d4cac00000000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    stream >> block;\n+\n     CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n     testNode.nVersion = 1;\n \n     CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n-    s << CMessageHeader(Params(CBaseChainParams::MAIN).MessageStart(), \"ping\", 0);\n+    s << CMessageHeader(Params(CBaseChainParams::MAIN).MessageStart(), \"block\", 0);\n     size_t headerLen = s.size();\n-    s << (uint64_t)11; // ping nonce\n+    s << block;\n \n     // Test: too large\n     s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen+1);\n@@ -87,4 +93,46 @@ BOOST_AUTO_TEST_CASE(TooLarge)\n     BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n }\n \n+BOOST_AUTO_TEST_CASE(TooLargeVerack)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params().MessageStart(), \"verack\", 0);\n+    size_t headerLen = s.size();\n+\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+\n+    // verack is zero-length, so even one byte bigger is too big:\n+    s.resize(headerLen+1);\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+    CNodeStateStats stats;\n+    GetNodeStateStats(testNode.GetId(), stats);\n+    BOOST_CHECK(stats.nMisbehavior > 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(TooLargePing)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params().MessageStart(), \"ping\", 0);\n+    s << (uint64_t)11; // 8-byte nonce\n+\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+\n+    // Add another nonce, sanity check should fail\n+    s << (uint64_t)11; // 8-byte nonce\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+    CNodeStateStats stats;\n+    GetNodeStateStats(testNode.GetId(), stats);\n+    BOOST_CHECK(stats.nMisbehavior > 0);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]