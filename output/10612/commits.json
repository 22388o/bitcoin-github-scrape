[
  {
    "sha": "76859e6a7665faef97edf339810aa56d2e4d0ad6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3Njg1OWU2YTc2NjVmYWVmOTdlZGYzMzk4MTBhYTU2ZDJlNGQwYWQ2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-15T16:43:03Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-27T09:04:52Z"
      },
      "message": "[tests] Update functional tests documentation",
      "tree": {
        "sha": "686ee41ec54e7062f57b42a445031f6af1d9e675",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/686ee41ec54e7062f57b42a445031f6af1d9e675"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/76859e6a7665faef97edf339810aa56d2e4d0ad6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76859e6a7665faef97edf339810aa56d2e4d0ad6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/76859e6a7665faef97edf339810aa56d2e4d0ad6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76859e6a7665faef97edf339810aa56d2e4d0ad6/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c2ab38bdd57a16e6c708dcc633d9162331c9d311",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c2ab38bdd57a16e6c708dcc633d9162331c9d311",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c2ab38bdd57a16e6c708dcc633d9162331c9d311"
      }
    ],
    "stats": {
      "total": 328,
      "additions": 221,
      "deletions": 107
    },
    "files": [
      {
        "sha": "15f6df790f9ba6142baf85319dcec6cc52d2119d",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 111,
        "deletions": 43,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76859e6a7665faef97edf339810aa56d2e4d0ad6/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76859e6a7665faef97edf339810aa56d2e4d0ad6/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=76859e6a7665faef97edf339810aa56d2e4d0ad6",
        "patch": "@@ -15,84 +15,152 @@ The util tests are run as part of `make check` target. The functional\n tests are run by the travis continuous build process whenever a pull\n request is opened. Both sets of tests can also be run locally.\n \n-Functional Test dependencies\n-============================\n+# Running tests locally\n+\n+Build for your system first. Be sure to enable wallet, utils and daemon when you configure. Tests will not run otherwise.\n+\n+### Functional tests\n+\n+#### Dependencies\n+\n The ZMQ functional test requires a python ZMQ library. To install it:\n \n - on Unix, run `sudo apt-get install python3-zmq`\n - on mac OS, run `pip3 install pyzmq`\n \n-Running tests locally\n-=====================\n+#### Running the tests\n \n-Build for your system first. Be sure to enable wallet, utils and daemon when you configure. Tests will not run otherwise.\n+Individual tests can be run by directly calling the test script, eg:\n \n-Functional tests\n-----------------\n+```\n+test/functional/replace-by-fee.py\n+```\n \n-You can run any single test by calling\n+or can be run through the test_runner harness, eg:\n \n-    test/functional/test_runner.py <testname>\n+```\n+test/functional/test_runner.py replace-by-fee.py\n+```\n \n-Or you can run any combination (incl. duplicates) of tests by calling\n+You can run any combination (incl. duplicates) of tests by calling:\n \n-    test/functional/test_runner.py <testname1> <testname2> <testname3> ...\n+```\n+test/functional/test_runner.py <testname1> <testname2> <testname3> ...\n+```\n \n-Run the regression test suite with\n+Run the regression test suite with:\n \n-    test/functional/test_runner.py\n+```\n+test/functional/test_runner.py\n+```\n \n Run all possible tests with\n \n-    test/functional/test_runner.py --extended\n+```\n+test/functional/test_runner.py --extended\n+```\n+\n+By default, up to 4 tests will be run in parallel by test_runner. To specify\n+how many jobs to run, append `--jobs=n`\n \n-By default, tests will be run in parallel. To specify how many jobs to run,\n-append `--jobs=n` (default n=4).\n+The individual tests and the test_runner harness have many command-line\n+options. Run `test_runner.py -h` to see them all.\n \n-If you want to create a basic coverage report for the RPC test suite, append `--coverage`.\n+#### Troubleshooting and debugging test failures\n \n-Possible options, which apply to each individual test run:\n+##### Resource contention\n \n+The P2P and RPC ports used by the bitcoind nodes-under-test are chosen to make\n+conflicts with other processes unlikely. However, if there is another bitcoind\n+process running on the system (perhaps from a previous test which hasn't successfully\n+killed all its bitcoind nodes), then there may be a port conflict which will\n+cause the test to fail. It is recommended that you run the tests on a system\n+where no other bitcoind processes are running.\n+\n+On linux, the test_framework will warn if there is another\n+bitcoind process running when the tests are started.\n+\n+If there are zombie bitcoind processes after test failure, you can kill them\n+by running the following commands. **Note that these commands will kill all\n+bitcoind processes running on the system, so should not be used if any non-test\n+bitcoind processes are being run.**\n+\n+```bash\n+killall bitcoind\n ```\n-  -h, --help            show this help message and exit\n-  --nocleanup           Leave bitcoinds and test.* datadir on exit or error\n-  --noshutdown          Don't stop bitcoinds after the test execution\n-  --srcdir=SRCDIR       Source directory containing bitcoind/bitcoin-cli\n-                        (default: ../../src)\n-  --tmpdir=TMPDIR       Root directory for datadirs\n-  --tracerpc            Print out all RPC calls as they are made\n-  --coveragedir=COVERAGEDIR\n-                        Write tested RPC commands into this directory\n-```\n \n-If you set the environment variable `PYTHON_DEBUG=1` you will get some debug\n-output (example: `PYTHON_DEBUG=1 test/functional/test_runner.py wallet`).\n+or\n+\n+```bash\n+pkill -9 bitcoind\n+```\n \n-A 200-block -regtest blockchain and wallets for four nodes\n-is created the first time a regression test is run and\n-is stored in the cache/ directory. Each node has 25 mature\n-blocks (25*50=1250 BTC) in its wallet.\n \n-After the first run, the cache/ blockchain and wallets are\n-copied into a temporary directory and used as the initial\n-test state.\n+##### Data directory cache\n \n-If you get into a bad state, you should be able\n-to recover with:\n+A pre-mined blockchain with 200 blocks is generated the first time a\n+functional test is run and is stored in test/cache. This speeds up\n+test startup times since new blockchains don't need to be generated for\n+each test. However, the cache may get into a bad state, in which case\n+tests will fail. If this happens, remove the cache directory (and make\n+sure bitcoind processes are stopped as above):\n \n ```bash\n rm -rf cache\n killall bitcoind\n ```\n \n-Util tests\n-----------\n+##### Test logging\n+\n+The tests contain logging at different levels (debug, info, warning, etc). By\n+default:\n+\n+- when run through the test_runner harness, *all* logs are written to\n+  `test_framework.log` and no logs are output to the console.\n+- when run directly, *all* logs are written to `test_framework.log` and INFO\n+  level and above are output to the console.\n+- when run on Travis, no logs are output to the console. However, if a test\n+  fails, the `test_framework.log` and bitcoind `debug.log`s will all be dumped\n+  to the console to help troubleshooting.\n+\n+To change the level of logs output to the console, use the `-l` command line\n+argument.\n+\n+`test_framework.log` and bitcoind `debug.log`s can be combined into a single\n+aggregate log by running the `combine_logs.py` script. The output can be plain\n+text, colorized text or html. For example:\n+\n+```\n+combine_logs.py -c <test data directory> | less -r\n+```\n+\n+will pipe the colorized logs from the test into less.\n+\n+Use `--tracerpc` to trace out all the RPC calls and responses to the console. For\n+some tests (eg any that use `submitblock` to submit a full block over RPC),\n+this can result in a lot of screen output.\n+\n+By default, the test data directory will be deleted after a successful run.\n+Use `--nocleanup` to leave the test data directory intact. The test data\n+directory is never deleted after a failed test.\n+\n+##### Attaching a debugger\n+\n+A python debugger can be attached to tests at any point. Just add the line:\n+\n+```py\n+import pdb; pdb.set_trace()\n+```\n+\n+anywhere in the test. You will then be able to inspect variables, as well as\n+call methods that interact with the bitcoind nodes-under-test.\n+\n+### Util tests\n \n Util tests can be run locally by running `test/util/bitcoin-util-test.py`. \n Use the `-v` option for verbose output.\n \n-Writing functional tests\n-========================\n+# Writing functional tests\n \n You are encouraged to write functional tests for new or existing features.\n Further information about the functional test framework and individual "
      },
      {
        "sha": "96fe0beccea9c0b50bcdfb2e8064e72901878cd3",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 110,
        "deletions": 64,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76859e6a7665faef97edf339810aa56d2e4d0ad6/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76859e6a7665faef97edf339810aa56d2e4d0ad6/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=76859e6a7665faef97edf339810aa56d2e4d0ad6",
        "patch": "@@ -1,108 +1,154 @@\n-Regression tests\n-================\n+# Functional tests\n \n-### [test_framework/authproxy.py](test_framework/authproxy.py)\n-Taken from the [python-bitcoinrpc repository](https://github.com/jgarzik/python-bitcoinrpc).\n+### Writing Functional Tests\n \n-### [test_framework/test_framework.py](test_framework/test_framework.py)\n-Base class for new regression tests.\n+#### Example test\n \n-### [test_framework/util.py](test_framework/util.py)\n-Generally useful functions.\n+The [example_test.py](example_test.py) is a heavily commented example of a test case that uses both\n+the RPC and P2P interfaces. If you are writing your first test, copy that file\n+and modify to fit your needs.\n \n-### [test_framework/mininode.py](test_framework/mininode.py)\n-Basic code to support p2p connectivity to a bitcoind.\n+#### Coverage\n \n-### [test_framework/comptool.py](test_framework/comptool.py)\n-Framework for comparison-tool style, p2p tests.\n+Running `test_runner.py` with the `--coverage` argument tracks which RPCs are\n+called by the tests and prints a report of uncovered RPCs in the summary. This\n+can be used (along with the `--extended` argument) to find out which RPCs we\n+don't have test cases for.\n \n-### [test_framework/script.py](test_framework/script.py)\n-Utilities for manipulating transaction scripts (originally from python-bitcoinlib)\n+#### Style guidelines\n \n-### [test_framework/blockstore.py](test_framework/blockstore.py)\n-Implements disk-backed block and tx storage.\n+- Where possible, try to adhere to [PEP-8 guidelines]([https://www.python.org/dev/peps/pep-0008/)\n+- Use a python linter like flake8 before submitting PRs to catch common style\n+  nits (eg trailing whitespace, unused imports, etc)\n+- Avoid wildcard imports where possible\n+- Use a module-level docstring to describe what the test is testing, and how it\n+  is testing it.\n+- When subclassing the BitcoinTestFramwork, place overrides for the\n+  `__init__()`, and `setup_xxxx()` methods at the top of the subclass, then\n+  locally-defined helper methods, then the `run_test()` method.\n \n-### [test_framework/key.py](test_framework/key.py)\n-Wrapper around OpenSSL EC_Key (originally from python-bitcoinlib)\n+#### General test-writing advice\n \n-### [test_framework/bignum.py](test_framework/bignum.py)\n-Helpers for script.py\n+- Set `self.num_nodes` to the minimum number of nodes necessary for the test.\n+  Having additional unrequired nodes adds to the execution time of the test as\n+  well as memory/CPU/disk requirements (which is important when running tests in\n+  parallel or on Travis).\n+- Avoid stop-starting the nodes multiple times during the test if possible. A\n+  stop-start takes several seconds, so doing it several times blows up the\n+  runtime of the test.\n+- Set the `self.setup_clean_chain` variable in `__init__()` to control whether\n+  or not to use the cached data directories. The cached data directories\n+  contain a 200-block pre-mined blockchain and wallets for four nodes. Each node\n+  has 25 mature blocks (25x50=1250 BTC) in its wallet.\n+- When calling RPCs with lots of arguments, consider using named keyword\n+  arguments instead of positional arguments to make the intent of the call\n+  clear to readers.\n \n-### [test_framework/blocktools.py](test_framework/blocktools.py)\n-Helper functions for creating blocks and transactions.\n+#### RPC and P2P definitions\n \n-P2P test design notes\n----------------------\n+Test writers may find it helpful to refer to the definitions for the RPC and\n+P2P messages. These can be found in the following source files:\n \n-## Mininode\n+- `/src/rpc/*` for RPCs\n+- `/src/wallet/rpc*` for wallet RPCs\n+- `ProcessMessage()` in `/src/net_processing.cpp` for parsing P2P messages\n \n-* ```mininode.py``` contains all the definitions for objects that pass\n-over the network (```CBlock```, ```CTransaction```, etc, along with the network-level\n-wrappers for them, ```msg_block```, ```msg_tx```, etc).\n+#### Using the P2P interface\n \n-* P2P tests have two threads.  One thread handles all network communication\n+- `mininode.py` contains all the definitions for objects that pass\n+over the network (`CBlock`, `CTransaction`, etc, along with the network-level\n+wrappers for them, `msg_block`, `msg_tx`, etc).\n+\n+- P2P tests have two threads. One thread handles all network communication\n with the bitcoind(s) being tested (using python's asyncore package); the other\n implements the test logic.\n \n-* ```NodeConn``` is the class used to connect to a bitcoind.  If you implement\n-a callback class that derives from ```NodeConnCB``` and pass that to the\n-```NodeConn``` object, your code will receive the appropriate callbacks when\n+- `NodeConn` is the class used to connect to a bitcoind.  If you implement\n+a callback class that derives from `NodeConnCB` and pass that to the\n+`NodeConn` object, your code will receive the appropriate callbacks when\n events of interest arrive.\n \n-* You can pass the same handler to multiple ```NodeConn```'s if you like, or pass\n-different ones to each -- whatever makes the most sense for your test.\n-\n-* Call ```NetworkThread.start()``` after all ```NodeConn``` objects are created to\n+- Call `NetworkThread.start()` after all `NodeConn` objects are created to\n start the networking thread.  (Continue with the test logic in your existing\n thread.)\n \n-* RPC calls are available in p2p tests.\n+- Can be used to write tests where specific P2P protocol behavior is tested.\n+Examples tests are `p2p-accept-block.py`, `p2p-compactblocks.py`.\n \n-* Can be used to write free-form tests, where specific p2p-protocol behavior\n-is tested.  Examples: ```p2p-accept-block.py```, ```p2p-compactblocks.py```.\n+#### Comptool\n \n-## Comptool\n+- Comptool is a Testing framework for writing tests that compare the block/tx acceptance\n+behavior of a bitcoind against 1 or more other bitcoind instances. It should not be used\n+to write static tests with known outcomes, since that type of test is easier to write and\n+maintain using the standard BitcoinTestFramework.\n \n-* Testing framework for writing tests that compare the block/tx acceptance\n-behavior of a bitcoind against 1 or more other bitcoind instances, or against\n-known outcomes, or both.\n-\n-* Set the ```num_nodes``` variable (defined in ```ComparisonTestFramework```) to start up\n-1 or more nodes.  If using 1 node, then ```--testbinary``` can be used as a command line\n+- Set the `num_nodes` variable (defined in `ComparisonTestFramework`) to start up\n+1 or more nodes.  If using 1 node, then `--testbinary` can be used as a command line\n option to change the bitcoind binary used by the test.  If using 2 or more nodes,\n-then ```--refbinary``` can be optionally used to change the bitcoind that will be used\n+then `--refbinary` can be optionally used to change the bitcoind that will be used\n on nodes 2 and up.\n \n-* Implement a (generator) function called ```get_tests()``` which yields ```TestInstance```s.\n-Each ```TestInstance``` consists of:\n-  - a list of ```[object, outcome, hash]``` entries\n-    * ```object``` is a ```CBlock```, ```CTransaction```, or\n-    ```CBlockHeader```.  ```CBlock```'s and ```CTransaction```'s are tested for\n-    acceptance.  ```CBlockHeader```s can be used so that the test runner can deliver\n+- Implement a (generator) function called `get_tests()` which yields `TestInstance`s.\n+Each `TestInstance` consists of:\n+  - a list of `[object, outcome, hash]` entries\n+    * `object` is a `CBlock`, `CTransaction`, or\n+    `CBlockHeader`.  `CBlock`'s and `CTransaction`'s are tested for\n+    acceptance.  `CBlockHeader`s can be used so that the test runner can deliver\n     complete headers-chains when requested from the bitcoind, to allow writing\n     tests where blocks can be delivered out of order but still processed by\n     headers-first bitcoind's.\n-    * ```outcome``` is ```True```, ```False```, or ```None```.  If ```True```\n-    or ```False```, the tip is compared with the expected tip -- either the\n+    * `outcome` is `True`, `False`, or `None`.  If `True`\n+    or `False`, the tip is compared with the expected tip -- either the\n     block passed in, or the hash specified as the optional 3rd entry.  If\n-    ```None``` is specified, then the test will compare all the bitcoind's\n+    `None` is specified, then the test will compare all the bitcoind's\n     being tested to see if they all agree on what the best tip is.\n-    * ```hash``` is the block hash of the tip to compare against. Optional to\n+    * `hash` is the block hash of the tip to compare against. Optional to\n     specify; if left out then the hash of the block passed in will be used as\n     the expected tip.  This allows for specifying an expected tip while testing\n     the handling of either invalid blocks or blocks delivered out of order,\n     which complete a longer chain.\n-  - ```sync_every_block```: ```True/False```.  If ```False```, then all blocks\n+  - `sync_every_block`: `True/False`.  If `False`, then all blocks\n     are inv'ed together, and the test runner waits until the node receives the\n     last one, and tests only the last block for tip acceptance using the\n-    outcome and specified tip.  If ```True```, then each block is tested in\n+    outcome and specified tip.  If `True`, then each block is tested in\n     sequence and synced (this is slower when processing many blocks).\n-  - ```sync_every_transaction```: ```True/False```.  Analogous to\n-    ```sync_every_block```, except if the outcome on the last tx is \"None\",\n+  - `sync_every_transaction`: `True/False`.  Analogous to\n+    `sync_every_block`, except if the outcome on the last tx is \"None\",\n     then the contents of the entire mempool are compared across all bitcoind\n-    connections.  If ```True``` or ```False```, then only the last tx's\n+    connections.  If `True` or `False`, then only the last tx's\n     acceptance is tested against the given outcome.\n \n-* For examples of tests written in this framework, see\n-  ```invalidblockrequest.py``` and ```p2p-fullblocktest.py```.\n+- For examples of tests written in this framework, see\n+  `invalidblockrequest.py` and `p2p-fullblocktest.py`.\n+\n+### test-framework modules\n+\n+#### [test_framework/authproxy.py](test_framework/authproxy.py)\n+Taken from the [python-bitcoinrpc repository](https://github.com/jgarzik/python-bitcoinrpc).\n+\n+#### [test_framework/test_framework.py](test_framework/test_framework.py)\n+Base class for functional tests.\n \n+#### [test_framework/util.py](test_framework/util.py)\n+Generally useful functions.\n+\n+#### [test_framework/mininode.py](test_framework/mininode.py)\n+Basic code to support P2P connectivity to a bitcoind.\n+\n+#### [test_framework/comptool.py](test_framework/comptool.py)\n+Framework for comparison-tool style, P2P tests.\n+\n+#### [test_framework/script.py](test_framework/script.py)\n+Utilities for manipulating transaction scripts (originally from python-bitcoinlib)\n+\n+#### [test_framework/blockstore.py](test_framework/blockstore.py)\n+Implements disk-backed block and tx storage.\n+\n+#### [test_framework/key.py](test_framework/key.py)\n+Wrapper around OpenSSL EC_Key (originally from python-bitcoinlib)\n+\n+#### [test_framework/bignum.py](test_framework/bignum.py)\n+Helpers for script.py\n+\n+#### [test_framework/blocktools.py](test_framework/blocktools.py)\n+Helper functions for creating blocks and transactions."
      }
    ]
  },
  {
    "sha": "e7ba6c16b34443cf0774d707d9918ebc9835d6ca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplN2JhNmMxNmIzNDQ0M2NmMDc3NGQ3MDdkOTkxOGViYzk4MzVkNmNh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-15T19:29:53Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-27T09:04:52Z"
      },
      "message": "[tests] add example test",
      "tree": {
        "sha": "015b2e7815a31e0d4fdb9b8aecc9ba9d64fb7929",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/015b2e7815a31e0d4fdb9b8aecc9ba9d64fb7929"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7ba6c16b34443cf0774d707d9918ebc9835d6ca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7ba6c16b34443cf0774d707d9918ebc9835d6ca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e7ba6c16b34443cf0774d707d9918ebc9835d6ca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7ba6c16b34443cf0774d707d9918ebc9835d6ca/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76859e6a7665faef97edf339810aa56d2e4d0ad6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76859e6a7665faef97edf339810aa56d2e4d0ad6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76859e6a7665faef97edf339810aa56d2e4d0ad6"
      }
    ],
    "stats": {
      "total": 220,
      "additions": 220,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1ba5f756cd4a05cd4f7388ffad125b0f899bceef",
        "filename": "test/functional/example_test.py",
        "status": "added",
        "additions": 219,
        "deletions": 0,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7ba6c16b34443cf0774d707d9918ebc9835d6ca/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7ba6c16b34443cf0774d707d9918ebc9835d6ca/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=e7ba6c16b34443cf0774d707d9918ebc9835d6ca",
        "patch": "@@ -0,0 +1,219 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"An example functional test\n+\n+The module-level docstring should include a high-level description of\n+what the test is doing. It's the first thing people see when they open\n+the file and should give the reader information about *what* the test\n+is testing and *how* it's being tested\n+\"\"\"\n+# Imports should be in PEP8 ordering (std library first, then third party\n+# libraries then local imports).\n+from collections import defaultdict\n+\n+# Avoid wildcard * imports if possible\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.mininode import (\n+    CInv,\n+    NetworkThread,\n+    NodeConn,\n+    NodeConnCB,\n+    mininode_lock,\n+    msg_block,\n+    msg_getdata,\n+    wait_until,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    p2p_port,\n+)\n+\n+# NodeConnCB is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass NodeConnCB and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(NodeConnCB):\n+    def __init__(self):\n+        \"\"\"Initialize the NodeConnCB\n+\n+        Used to inialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the NodeConnCB\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+        self.block_receive_map = defaultdict(int)\n+\n+    def on_block(self, conn, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+def custom_function():\n+    \"\"\"Do some custom behaviour\n+\n+    If this function is more generally useful for other tests, consider\n+    moving it to a module in test_framework.\"\"\"\n+    # self.log.info(\"running custom_function\")  # Oops! Can't run self.log outside the BitcoinTestFramework\n+    pass\n+\n+class ExampleTest(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the __init__(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def __init__(self):\n+        \"\"\"Initialize the test\n+\n+        Call super().__init__() first, and then override any test parameters\n+        for your individual test.\"\"\"\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+        # Use self.extra_args to change command-line arguments for the nodes\n+        self.extra_args = [[], [\"-logips\"], []]\n+\n+        # self.log.info(\"I've finished __init__\")  # Oops! Can't run self.log before run_test()\n+\n+    # Use add_options() to add specific command-line options for your test.\n+    # In practice this is not used very much, since the tests are mostly written\n+    # to be run in automated environments without command-line options.\n+    # def add_options()\n+    #     pass\n+\n+    # Use setup_chain() to customize the node data directories. In practice\n+    # this is not used very much since the default behaviour is almost always\n+    # fine\n+    # def setup_chain():\n+    #     pass\n+\n+    def setup_network(self):\n+        \"\"\"Setup the test network topology\n+\n+        Often you won't need to override this, since the standard network topology\n+        (linear: node0 <-> node1 <-> node2 <-> ...) is fine for most tests.\n+\n+        If you do override this method, remember to start the nodes, assign\n+        them to self.nodes, connect them and then sync.\"\"\"\n+\n+        self.setup_nodes()\n+\n+        # In this test, we're not connecting node2 to node0 or node1. Calls to\n+        # sync_all() should not include node2, since we're not expecting it to\n+        # sync.\n+        connect_nodes(self.nodes[0], 1)\n+        self.sync_all([self.nodes[0:1]])\n+\n+    # Use setup_nodes() to customize the node start behaviour (for example if\n+    # you don't want to start all nodes at the start of the test).\n+    # def setup_nodes():\n+    #     pass\n+\n+    def custom_method(self):\n+        \"\"\"Do some custom behaviour for this test\n+\n+        Define it in a method here because you're going to use it repeatedly.\n+        If you think it's useful in general, consider moving it to the base\n+        BitcoinTestFramework class so other tests can use it.\"\"\"\n+\n+        self.log.info(\"Running custom_method\")\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create a P2P connection to one of the nodes\n+        node0 = BaseNode()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n+        node0.add_connection(connections[0])\n+\n+        # Start up network handling in another thread. This needs to be called\n+        # after the P2P connections have been created.\n+        NetworkThread().start()\n+        # wait_for_verack ensures that the P2P connection is fully up.\n+        node0.wait_for_verack()\n+\n+        # Generating a block on one of the nodes will get us out of IBD\n+        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        self.sync_all([self.nodes[0:1]])\n+\n+        # Notice above how we called an RPC by calling a method with the same\n+        # name on the node object. Notice also how we used a keyword argument\n+        # to specify a named RPC argument. Neither of those are defined on the\n+        # node object. Instead there's some __getattr__() magic going on under\n+        # the covers to dispatch unrecognised attribute calls to the RPC\n+        # interface.\n+\n+        # Logs are nice. Do plenty of them. They can be used in place of comments for\n+        # breaking the test into sub-sections.\n+        self.log.info(\"Starting test!\")\n+\n+        self.log.info(\"Calling a custom function\")\n+        custom_function()\n+\n+        self.log.info(\"Calling a custom method\")\n+        self.custom_method()\n+\n+        self.log.info(\"Create some blocks\")\n+        self.tip = int(self.nodes[0].getbestblockhash(), 16)\n+        self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+\n+        height = 1\n+\n+        for i in range(10):\n+            # Use the mininode and blocktools functionality to manually build a block\n+            # Calling the generate() rpc is easier, but this allows us to exactly\n+            # control the blocks and transactions.\n+            block = create_block(self.tip, create_coinbase(height), self.block_time)\n+            block.solve()\n+            block_message = msg_block(block)\n+            # Send message is used to send a P2P message to the node over our NodeConn connection\n+            node0.send_message(block_message)\n+            self.tip = block.sha256\n+            blocks.append(self.tip)\n+            self.block_time += 1\n+            height += 1\n+\n+        self.log.info(\"Wait for node1 to reach current tip (height 11) using RPC\")\n+        self.nodes[1].waitforblockheight(11)\n+\n+        self.log.info(\"Connect node2 and node1\")\n+        connect_nodes(self.nodes[1], 2)\n+\n+        self.log.info(\"Add P2P connection to node2\")\n+        node2 = BaseNode()\n+        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n+        node2.add_connection(connections[1])\n+        node2.wait_for_verack()\n+\n+        self.log.info(\"Wait for node2 reach current tip. Test that it has propogated all the blocks to us\")\n+\n+        for block in blocks:\n+            getdata_request = msg_getdata()\n+            getdata_request.inv.append(CInv(2, block))\n+            node2.send_message(getdata_request)\n+\n+        # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n+        # NodeConnCB objects.\n+        assert wait_until(lambda: sorted(blocks) == sorted(list(node2.block_receive_map.keys())), timeout=5)\n+\n+        self.log.info(\"Check that each block was received only once\")\n+        # The network thread uses a global lock on data access to the NodeConn objects when sending and receiving\n+        # messages. The test thread should acquire the global lock before accessing any NodeConn data to avoid locking\n+        # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n+        with mininode_lock:\n+            for block in node2.block_receive_map.values():\n+                assert_equal(block, 1)\n+\n+if __name__ == '__main__':\n+    ExampleTest().main()"
      },
      {
        "sha": "1cac61d9097ef69d7a69d0aac462431d9af7ae42",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7ba6c16b34443cf0774d707d9918ebc9835d6ca/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7ba6c16b34443cf0774d707d9918ebc9835d6ca/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=e7ba6c16b34443cf0774d707d9918ebc9835d6ca",
        "patch": "@@ -137,6 +137,7 @@\n     'bip65-cltv-p2p.py',\n     'bipdersig-p2p.py',\n     'bipdersig.py',\n+    'example_test.py',\n     'getblocktemplate_proposals.py',\n     'txn_doublespend.py',\n     'txn_clone.py --mineblock',"
      }
    ]
  }
]