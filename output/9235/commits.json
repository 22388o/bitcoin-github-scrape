[
  {
    "sha": "2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYmZlZjAzMTAyY2Q1MDYzZTBhN2I4ZDMwZjcxZDJlNmJmN2UwOTAw",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2016-11-28T01:14:13Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2016-12-05T09:16:07Z"
      },
      "message": "Removes all uses of `using namespace <xxx>` in all source files, including test and bench related files.",
      "tree": {
        "sha": "7397c971696917a95a168f3929f6c752fb6d0237",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7397c971696917a95a168f3929f6c752fb6d0237"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d04aebaec7bbf4095bd4f6a715eb6ee834857115",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d04aebaec7bbf4095bd4f6a715eb6ee834857115",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d04aebaec7bbf4095bd4f6a715eb6ee834857115"
      }
    ],
    "stats": {
      "total": 2071,
      "additions": 977,
      "deletions": 1094
    },
    "files": [
      {
        "sha": "8f9432e11c90e64a17373f9a9d794c4934527996",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 8,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -9,39 +9,37 @@\n #include <iomanip>\n #include <sys/time.h>\n \n-using namespace benchmark;\n-\n-std::map<std::string, BenchFunction> BenchRunner::benchmarks;\n+std::map<std::string, benchmark::BenchFunction> benchmark::BenchRunner::benchmarks;\n \n static double gettimedouble(void) {\n     struct timeval tv;\n     gettimeofday(&tv, NULL);\n     return tv.tv_usec * 0.000001 + tv.tv_sec;\n }\n \n-BenchRunner::BenchRunner(std::string name, BenchFunction func)\n+benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func)\n {\n     benchmarks.insert(std::make_pair(name, func));\n }\n \n void\n-BenchRunner::RunAll(double elapsedTimeForOne)\n+benchmark::BenchRunner::RunAll(double elapsedTimeForOne)\n {\n     perf_init();\n     std::cout << \"#Benchmark\" << \",\" << \"count\" << \",\" << \"min\" << \",\" << \"max\" << \",\" << \"average\" << \",\"\n               << \"min_cycles\" << \",\" << \"max_cycles\" << \",\" << \"average_cycles\" << \"\\n\";\n \n-    for (std::map<std::string,BenchFunction>::iterator it = benchmarks.begin();\n+    for (std::map<std::string,benchmark::BenchFunction>::iterator it = benchmarks.begin();\n          it != benchmarks.end(); ++it) {\n \n         State state(it->first, elapsedTimeForOne);\n-        BenchFunction& func = it->second;\n+        benchmark::BenchFunction& func = it->second;\n         func(state);\n     }\n     perf_fini();\n }\n \n-bool State::KeepRunning()\n+bool benchmark::State::KeepRunning()\n {\n     if (count & countMask) {\n       ++count;"
      },
      {
        "sha": "6c539aa98dcfc95f0b45ccd59131c88eb7bcdfb0",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -8,9 +8,7 @@\n #include <boost/foreach.hpp>\n #include <set>\n \n-using namespace std;\n-\n-static void addCoin(const CAmount& nValue, const CWallet& wallet, vector<COutput>& vCoins)\n+static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<COutput>& vCoins)\n {\n     int nInput = 0;\n \n@@ -36,7 +34,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, vector<COutput\n static void CoinSelection(benchmark::State& state)\n {\n     const CWallet wallet;\n-    vector<COutput> vCoins;\n+    std::vector<COutput> vCoins;\n     LOCK(wallet.cs_wallet);\n \n     while (state.KeepRunning()) {\n@@ -50,7 +48,7 @@ static void CoinSelection(benchmark::State& state)\n             addCoin(1000 * COIN, wallet, vCoins);\n         addCoin(3 * COIN, wallet, vCoins);\n \n-        set<pair<const CWalletTx*, unsigned int> > setCoinsRet;\n+        std::set<std::pair<const CWalletTx*, unsigned int> > setCoinsRet;\n         CAmount nValueRet;\n         bool success = wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, vCoins, setCoinsRet, nValueRet);\n         assert(success);"
      },
      {
        "sha": "edc41a6512087d5dc5529d1755cd60a20a9b46f7",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -19,23 +19,21 @@\n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n \n-using namespace std;\n-\n CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n     /**\n      * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n      * - nElements * log(fp rate) / ln(2)^2\n      * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n      */\n-    vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+    vData(std::min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n     /**\n      * The ideal number of hash functions is filter size * ln(2) / number of elements\n      * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n      * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n      */\n     isFull(false),\n     isEmpty(true),\n-    nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n+    nHashFuncs(std::min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n     nTweak(nTweakIn),\n     nFlags(nFlagsIn)\n {\n@@ -58,7 +56,7 @@ inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<\n     return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n }\n \n-void CBloomFilter::insert(const vector<unsigned char>& vKey)\n+void CBloomFilter::insert(const std::vector<unsigned char>& vKey)\n {\n     if (isFull)\n         return;\n@@ -75,17 +73,17 @@ void CBloomFilter::insert(const COutPoint& outpoint)\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n-    vector<unsigned char> data(stream.begin(), stream.end());\n+    std::vector<unsigned char> data(stream.begin(), stream.end());\n     insert(data);\n }\n \n void CBloomFilter::insert(const uint256& hash)\n {\n-    vector<unsigned char> data(hash.begin(), hash.end());\n+    std::vector<unsigned char> data(hash.begin(), hash.end());\n     insert(data);\n }\n \n-bool CBloomFilter::contains(const vector<unsigned char>& vKey) const\n+bool CBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n {\n     if (isFull)\n         return true;\n@@ -105,13 +103,13 @@ bool CBloomFilter::contains(const COutPoint& outpoint) const\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n-    vector<unsigned char> data(stream.begin(), stream.end());\n+    std::vector<unsigned char> data(stream.begin(), stream.end());\n     return contains(data);\n }\n \n bool CBloomFilter::contains(const uint256& hash) const\n {\n-    vector<unsigned char> data(hash.begin(), hash.end());\n+    std::vector<unsigned char> data(hash.begin(), hash.end());\n     return contains(data);\n }\n \n@@ -154,7 +152,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n         // This means clients don't have to update the filter themselves when a new relevant tx \n         // is discovered in order to find spending transactions, which avoids round-tripping and race conditions.\n         CScript::const_iterator pc = txout.scriptPubKey.begin();\n-        vector<unsigned char> data;\n+        std::vector<unsigned char> data;\n         while (pc < txout.scriptPubKey.end())\n         {\n             opcodetype opcode;\n@@ -168,7 +166,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n                 else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n                 {\n                     txnouttype type;\n-                    vector<vector<unsigned char> > vSolutions;\n+                    std::vector<std::vector<unsigned char> > vSolutions;\n                     if (Solver(txout.scriptPubKey, type, vSolutions) &&\n                             (type == TX_PUBKEY || type == TX_MULTISIG))\n                         insert(COutPoint(hash, i));\n@@ -189,7 +187,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n \n         // Match if the filter contains any arbitrary script data element in any scriptSig in tx\n         CScript::const_iterator pc = txin.scriptSig.begin();\n-        vector<unsigned char> data;\n+        std::vector<unsigned char> data;\n         while (pc < txin.scriptSig.end())\n         {\n             opcodetype opcode;\n@@ -280,7 +278,7 @@ void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n \n void CRollingBloomFilter::insert(const uint256& hash)\n {\n-    vector<unsigned char> vData(hash.begin(), hash.end());\n+    std::vector<unsigned char> vData(hash.begin(), hash.end());\n     insert(vData);\n }\n \n@@ -300,7 +298,7 @@ bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n \n bool CRollingBloomFilter::contains(const uint256& hash) const\n {\n-    vector<unsigned char> vData(hash.begin(), hash.end());\n+    std::vector<unsigned char> vData(hash.begin(), hash.end());\n     return contains(vData);\n }\n "
      },
      {
        "sha": "6f2aaaad5598730dfa9a8e8a680c7203ffaa2d5d",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -5,8 +5,6 @@\n \n #include \"chain.h\"\n \n-using namespace std;\n-\n /**\n  * CChain implementation\n  */"
      },
      {
        "sha": "e13185ddee3dedbc2062877b36ce8a49ac264e19",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 16,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -20,13 +20,11 @@\n #include <boost/algorithm/string/split.hpp>\n #include <boost/assign/list_of.hpp>\n \n-using namespace std;\n-\n CScript ParseScript(const std::string& s)\n {\n     CScript result;\n \n-    static map<string, opcodetype> mapOpNames;\n+    static std::map<std::string, opcodetype> mapOpNames;\n \n     if (mapOpNames.empty())\n     {\n@@ -39,15 +37,15 @@ CScript ParseScript(const std::string& s)\n             const char* name = GetOpName((opcodetype)op);\n             if (strcmp(name, \"OP_UNKNOWN\") == 0)\n                 continue;\n-            string strName(name);\n+            std::string strName(name);\n             mapOpNames[strName] = (opcodetype)op;\n             // Convenience: OP_ADD and just ADD are both recognized:\n             boost::algorithm::replace_first(strName, \"OP_\", \"\");\n             mapOpNames[strName] = (opcodetype)op;\n         }\n     }\n \n-    vector<string> words;\n+    std::vector<std::string> words;\n     boost::algorithm::split(words, s, boost::algorithm::is_any_of(\" \\t\\n\"), boost::algorithm::token_compress_on);\n \n     for (std::vector<std::string>::const_iterator w = words.begin(); w != words.end(); ++w)\n@@ -57,16 +55,16 @@ CScript ParseScript(const std::string& s)\n             // Empty string, ignore. (boost::split given '' will return one word)\n         }\n         else if (all(*w, boost::algorithm::is_digit()) ||\n-            (boost::algorithm::starts_with(*w, \"-\") && all(string(w->begin()+1, w->end()), boost::algorithm::is_digit())))\n+            (boost::algorithm::starts_with(*w, \"-\") && all(std::string(w->begin()+1, w->end()), boost::algorithm::is_digit())))\n         {\n             // Number\n             int64_t n = atoi64(*w);\n             result << n;\n         }\n-        else if (boost::algorithm::starts_with(*w, \"0x\") && (w->begin()+2 != w->end()) && IsHex(string(w->begin()+2, w->end())))\n+        else if (boost::algorithm::starts_with(*w, \"0x\") && (w->begin()+2 != w->end()) && IsHex(std::string(w->begin()+2, w->end())))\n         {\n             // Raw hex data, inserted NOT pushed onto stack:\n-            std::vector<unsigned char> raw = ParseHex(string(w->begin()+2, w->end()));\n+            std::vector<unsigned char> raw = ParseHex(std::string(w->begin()+2, w->end()));\n             result.insert(result.end(), raw.begin(), raw.end());\n         }\n         else if (w->size() >= 2 && boost::algorithm::starts_with(*w, \"'\") && boost::algorithm::ends_with(*w, \"'\"))\n@@ -83,7 +81,7 @@ CScript ParseScript(const std::string& s)\n         }\n         else\n         {\n-            throw runtime_error(\"script parse error\");\n+            throw std::runtime_error(\"script parse error\");\n         }\n     }\n \n@@ -95,7 +93,7 @@ bool DecodeHexTx(CMutableTransaction& tx, const std::string& strHexTx, bool fTry\n     if (!IsHex(strHexTx))\n         return false;\n \n-    vector<unsigned char> txData(ParseHex(strHexTx));\n+    std::vector<unsigned char> txData(ParseHex(strHexTx));\n \n     if (fTryNoWitness) {\n         CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n@@ -138,9 +136,9 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n-uint256 ParseHashUV(const UniValue& v, const string& strName)\n+uint256 ParseHashUV(const UniValue& v, const std::string& strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.getValStr();\n     return ParseHashStr(strHex, strName);  // Note: ParseHashStr(\"\") throws a runtime_error\n@@ -149,19 +147,19 @@ uint256 ParseHashUV(const UniValue& v, const string& strName)\n uint256 ParseHashStr(const std::string& strHex, const std::string& strName)\n {\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw std::runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n \n     uint256 result;\n     result.SetHex(strHex);\n     return result;\n }\n \n-vector<unsigned char> ParseHexUV(const UniValue& v, const string& strName)\n+std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.getValStr();\n     if (!IsHex(strHex))\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw std::runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n     return ParseHex(strHex);\n }"
      },
      {
        "sha": "311b211c6eefe2132bf52824ef84b1b86e2e0256",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 22,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -18,16 +18,14 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n-string FormatScript(const CScript& script)\n+std::string FormatScript(const CScript& script)\n {\n-    string ret;\n+    std::string ret;\n     CScript::const_iterator it = script.begin();\n     opcodetype op;\n     while (it != script.end()) {\n         CScript::const_iterator it2 = it;\n-        vector<unsigned char> vch;\n+        std::vector<unsigned char> vch;\n         if (script.GetOp2(it, op, &vch)) {\n             if (op == OP_0) {\n                 ret += \"0 \";\n@@ -36,9 +34,9 @@ string FormatScript(const CScript& script)\n                 ret += strprintf(\"%i \", op - OP_1NEGATE - 1);\n                 continue;\n             } else if (op >= OP_NOP && op <= OP_NOP10) {\n-                string str(GetOpName(op));\n-                if (str.substr(0, 3) == string(\"OP_\")) {\n-                    ret += str.substr(3, string::npos) + \" \";\n+                std::string str(GetOpName(op));\n+                if (str.substr(0, 3) == std::string(\"OP_\")) {\n+                    ret += str.substr(3, std::string::npos) + \" \";\n                     continue;\n                 }\n             }\n@@ -55,14 +53,14 @@ string FormatScript(const CScript& script)\n     return ret.substr(0, ret.size() - 1);\n }\n \n-const map<unsigned char, string> mapSigHashTypes =\n+const std::map<unsigned char, std::string> mapSigHashTypes =\n     boost::assign::map_list_of\n-    (static_cast<unsigned char>(SIGHASH_ALL), string(\"ALL\"))\n-    (static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), string(\"ALL|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE), string(\"NONE\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), string(\"NONE|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE), string(\"SINGLE\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), string(\"SINGLE|ANYONECANPAY\"))\n+    (static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\"))\n+    (static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\"))\n+    (static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\"))\n+    (static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\"))\n+    (static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\"))\n+    (static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\"))\n     ;\n \n /**\n@@ -72,11 +70,11 @@ const map<unsigned char, string> mapSigHashTypes =\n  *                                     of a signature. Only pass true for scripts you believe could contain signatures. For example,\n  *                                     pass false, or omit the this argument (defaults to false), for scriptPubKeys.\n  */\n-string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n+std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n {\n-    string str;\n+    std::string str;\n     opcodetype opcode;\n-    vector<unsigned char> vch;\n+    std::vector<unsigned char> vch;\n     CScript::const_iterator pc = script.begin();\n     while (pc < script.end()) {\n         if (!str.empty()) {\n@@ -87,12 +85,12 @@ string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n             return str;\n         }\n         if (0 <= opcode && opcode <= OP_PUSHDATA4) {\n-            if (vch.size() <= static_cast<vector<unsigned char>::size_type>(4)) {\n+            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) {\n                 str += strprintf(\"%d\", CScriptNum(vch, false).getint());\n             } else {\n                 // the IsUnspendable check makes sure not to try to decode OP_RETURN data that may match the format of a signature\n                 if (fAttemptSighashDecode && !script.IsUnspendable()) {\n-                    string strSigHashDecode;\n+                    std::string strSigHashDecode;\n                     // goal: only attempt to decode a defined sighash type from data that looks like a signature within a scriptSig.\n                     // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to\n                     // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the\n@@ -116,7 +114,7 @@ string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n     return str;\n }\n \n-string EncodeHexTx(const CTransaction& tx)\n+std::string EncodeHexTx(const CTransaction& tx)\n {\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n     ssTx << tx;\n@@ -127,7 +125,7 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n                         UniValue& out, bool fIncludeHex)\n {\n     txnouttype type;\n-    vector<CTxDestination> addresses;\n+    std::vector<CTxDestination> addresses;\n     int nRequired;\n \n     out.pushKV(\"asm\", ScriptToAsmStr(scriptPubKey));"
      },
      {
        "sha": "6e94427500c514559627f7bdcabec90177f9cd72",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 16,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -64,8 +64,6 @@\n #include \"zmq/zmqnotificationinterface.h\"\n #endif\n \n-using namespace std;\n-\n bool fFeeEstimatesInitialized = false;\n static const bool DEFAULT_PROXYRANDOMIZE = true;\n static const bool DEFAULT_REST_ENABLE = false;\n@@ -305,10 +303,10 @@ void OnRPCStopped()\n void OnRPCPreCommand(const CRPCCommand& cmd)\n {\n     // Observe safe mode\n-    string strWarning = GetWarnings(\"rpc\");\n+    std::string strWarning = GetWarnings(\"rpc\");\n     if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\", DEFAULT_DISABLE_SAFEMODE) &&\n         !cmd.okSafeMode)\n-        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, string(\"Safe mode: \") + strWarning);\n+        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, std::string(\"Safe mode: \") + strWarning);\n }\n \n std::string HelpMessage(HelpMessageMode mode)\n@@ -317,7 +315,7 @@ std::string HelpMessage(HelpMessageMode mode)\n \n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n     // Do not translate _(...) -help-debug options, Many technical terms, and only a very small audience, so is unnecessary stress to translators.\n-    string strUsage = HelpMessageGroup(_(\"Options:\"));\n+    std::string strUsage = HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"Print this help message and exit\"));\n     strUsage += HelpMessageOpt(\"-version\", _(\"Print version and exit\"));\n     strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"));\n@@ -428,7 +426,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified BIP9 deployment (regtest-only)\");\n     }\n-    string debugCategories = \"addrman, alert, bench, cmpctblock, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n+    std::string debugCategories = \"addrman, alert, bench, cmpctblock, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n         debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n@@ -564,15 +562,14 @@ struct CImportingNow\n // works correctly.\n void CleanupBlockRevFiles()\n {\n-    using namespace boost::filesystem;\n-    map<string, path> mapBlockFiles;\n+    std::map<std::string, boost::filesystem::path> mapBlockFiles;\n \n     // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    path blocksdir = GetDataDir() / \"blocks\";\n-    for (directory_iterator it(blocksdir); it != directory_iterator(); it++) {\n+    boost::filesystem::path blocksdir = GetDataDir() / \"blocks\";\n+    for (boost::filesystem::directory_iterator it(blocksdir); it != boost::filesystem::directory_iterator(); it++) {\n         if (is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n             it->path().filename().string().substr(8,4) == \".dat\")\n@@ -589,7 +586,7 @@ void CleanupBlockRevFiles()\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    BOOST_FOREACH(const PAIRTYPE(string, path)& item, mapBlockFiles) {\n+    BOOST_FOREACH(const PAIRTYPE(std::string, boost::filesystem::path)& item, mapBlockFiles) {\n         if (atoi(item.first) == nContigCounter) {\n             nContigCounter++;\n             continue;\n@@ -880,8 +877,8 @@ bool AppInitParameterInteraction()\n \n     fDebug = !mapMultiArgs[\"-debug\"].empty();\n     // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n-    const vector<string>& categories = mapMultiArgs[\"-debug\"];\n-    if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), string(\"0\")) != categories.end())\n+    const std::vector<std::string>& categories = mapMultiArgs[\"-debug\"];\n+    if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), std::string(\"0\")) != categories.end())\n         fDebug = false;\n \n     // Check for -debugnet\n@@ -1000,7 +997,7 @@ bool AppInitParameterInteraction()\n         if (!chainparams.MineBlocksOnDemand()) {\n             return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n         }\n-        const vector<string>& deployments = mapMultiArgs[\"-bip9params\"];\n+        const std::vector<std::string>& deployments = mapMultiArgs[\"-bip9params\"];\n         for (auto i : deployments) {\n             std::vector<std::string> vDeploymentParams;\n             boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n@@ -1143,8 +1140,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     RegisterNodeSignals(GetNodeSignals());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n-    std::vector<string> uacomments;\n-    BOOST_FOREACH(string cmt, mapMultiArgs[\"-uacomment\"])\n+    std::vector<std::string> uacomments;\n+    BOOST_FOREACH(std::string cmt, mapMultiArgs[\"-uacomment\"])\n     {\n         if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n             return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));"
      },
      {
        "sha": "50ce3ad8c62b10c8678b343a9c2045333e0bf4d4",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -9,14 +9,12 @@\n #include \"consensus/consensus.h\"\n #include \"utilstrencodings.h\"\n \n-using namespace std;\n-\n CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n {\n     header = block.GetBlockHeader();\n \n-    vector<bool> vMatch;\n-    vector<uint256> vHashes;\n+    std::vector<bool> vMatch;\n+    std::vector<uint256> vHashes;\n \n     vMatch.reserve(block.vtx.size());\n     vHashes.reserve(block.vtx.size());\n@@ -27,7 +25,7 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n         if (filter.IsRelevantAndUpdate(*block.vtx[i]))\n         {\n             vMatch.push_back(true);\n-            vMatchedTxn.push_back(make_pair(i, hash));\n+            vMatchedTxn.push_back(std::make_pair(i, hash));\n         }\n         else\n             vMatch.push_back(false);\n@@ -41,8 +39,8 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, const std::set<uint256>& txids)\n {\n     header = block.GetBlockHeader();\n \n-    vector<bool> vMatch;\n-    vector<uint256> vHashes;\n+    std::vector<bool> vMatch;\n+    std::vector<uint256> vHashes;\n \n     vMatch.reserve(block.vtx.size());\n     vHashes.reserve(block.vtx.size());"
      },
      {
        "sha": "3c1a58e70af6df46b63115d1771617bda1bb71cb",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -31,8 +31,6 @@\n #include <queue>\n #include <utility>\n \n-using namespace std;\n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // BitcoinMiner\n@@ -494,7 +492,7 @@ void BlockAssembler::addPackageTxs()\n         }\n \n         // Package can be added. Sort the entries in a valid order.\n-        vector<CTxMemPool::txiter> sortedEntries;\n+        std::vector<CTxMemPool::txiter> sortedEntries;\n         SortForBlock(ancestors, iter, sortedEntries);\n \n         for (size_t i=0; i<sortedEntries.size(); ++i) {\n@@ -523,7 +521,7 @@ void BlockAssembler::addPriorityTxs()\n     fNeedSizeAccounting = true;\n \n     // This vector will be sorted into a priority queue:\n-    vector<TxCoinAgePriority> vecPriority;\n+    std::vector<TxCoinAgePriority> vecPriority;\n     TxCoinAgePriorityCompare pricomparer;\n     std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash> waitPriMap;\n     typedef std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash>::iterator waitPriIter;"
      },
      {
        "sha": "4e86ba4a4cb25b48414fc2a0d33bf73f155064d7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 53,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -32,8 +32,6 @@\n \n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -54,8 +52,8 @@ struct COrphanTx {\n     NodeId fromPeer;\n     int64_t nTimeExpire;\n };\n-map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);\n-map<COutPoint, set<map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(cs_main);\n+std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);\n+std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(cs_main);\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n static const uint64_t RANDOMIZER_ID_ADDRESS_RELAY = 0x3cac0035b5866b90ULL; // SHA256(\"main address relay\")[0:8]\n@@ -72,7 +70,7 @@ namespace {\n      * Set mapBlockSource[hash].second to false if the node should not be\n      * punished if the block is invalid.\n      */\n-    map<uint256, std::pair<NodeId, bool>> mapBlockSource;\n+    std::map<uint256, std::pair<NodeId, bool>> mapBlockSource;\n \n     /**\n      * Filter for transactions that were recently rejected by\n@@ -104,10 +102,10 @@ namespace {\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n-    list<NodeId> lNodesAnnouncingHeaderAndIDs;\n+    std::list<NodeId> lNodesAnnouncingHeaderAndIDs;\n \n     /** Number of preferable block download peers. */\n     int nPreferredDownload = 0;\n@@ -131,7 +129,7 @@ namespace {\n \n struct CBlockReject {\n     unsigned char chRejectCode;\n-    string strRejectReason;\n+    std::string strRejectReason;\n     uint256 hashBlock;\n };\n \n@@ -168,7 +166,7 @@ struct CNodeState {\n     bool fSyncStarted;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n     int64_t nStallingSince;\n-    list<QueuedBlock> vBlocksInFlight;\n+    std::list<QueuedBlock> vBlocksInFlight;\n     //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n     int64_t nDownloadingSince;\n     int nBlocksInFlight;\n@@ -220,11 +218,11 @@ struct CNodeState {\n };\n \n /** Map maintaining per-node state. Requires cs_main. */\n-map<NodeId, CNodeState> mapNodeState;\n+std::map<NodeId, CNodeState> mapNodeState;\n \n // Requires cs_main.\n CNodeState *State(NodeId pnode) {\n-    map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n+    std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n     if (it == mapNodeState.end())\n         return NULL;\n     return &it->second;\n@@ -306,7 +304,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n-    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n@@ -330,12 +328,12 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, std::list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n     // Short-circuit most stuff in case its from the same node\n-    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n         *pit = &itInFlight->second.second;\n         return false;\n@@ -344,7 +342,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n-    list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n+    std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n     state->nBlocksInFlight++;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n@@ -618,7 +616,7 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n \n int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n+    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n     BOOST_FOREACH(const CTxIn& txin, it->second.tx.vin)\n@@ -637,10 +635,10 @@ int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n void EraseOrphansFor(NodeId peer)\n {\n     int nErased = 0;\n-    map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+    std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n     while (iter != mapOrphanTransactions.end())\n     {\n-        map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n+        std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n         if (maybeErase->second.fromPeer == peer)\n         {\n             nErased += EraseOrphanTx(maybeErase->second.tx.GetHash());\n@@ -659,10 +657,10 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n         // Sweep out expired orphan pool entries:\n         int nErased = 0;\n         int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n-        map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+        std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n         while (iter != mapOrphanTransactions.end())\n         {\n-            map<uint256, COrphanTx>::iterator maybeErase = iter++;\n+            std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n             if (maybeErase->second.nTimeExpire <= nNow) {\n                 nErased += EraseOrphanTx(maybeErase->second.tx.GetHash());\n             } else {\n@@ -677,7 +675,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n     {\n         // Evict a random orphan:\n         uint256 randomhash = GetRandHash();\n-        map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n+        std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n         if (it == mapOrphanTransactions.end())\n             it = mapOrphanTransactions.begin();\n         EraseOrphanTx(it->first);\n@@ -889,7 +887,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     unsigned int nMaxSendBufferSize = connman.GetSendBufferSize();\n-    vector<CInv> vNotFound;\n+    std::vector<CInv> vNotFound;\n     CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     LOCK(cs_main);\n \n@@ -994,7 +992,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // Bypass PushInventory, this must send even if redundant,\n                         // and we want it right after the last block so they don't\n                         // wait for other stuff first.\n-                        vector<CInv> vInv;\n+                        std::vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n                         connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                         pfrom->hashContinue.SetNull();\n@@ -1054,7 +1052,7 @@ uint32_t GetFetchFlags(CNode* pfrom, CBlockIndex* pprev, const Consensus::Params\n     return nFetchFlags;\n }\n \n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman)\n+bool static ProcessMessage(CNode* pfrom, std::string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman)\n {\n     unsigned int nMaxSendBufferSize = connman.GetSendBufferSize();\n \n@@ -1086,7 +1084,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\")));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -1207,7 +1205,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        string remoteAddr;\n+        std::string remoteAddr;\n         if (fLogIPs)\n             remoteAddr = \", peeraddr=\" + pfrom->addr.ToString();\n \n@@ -1242,7 +1240,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     if (strCommand == NetMsgType::VERACK)\n     {\n-        pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+        pfrom->SetRecvVersion(std::min(pfrom->nVersion, PROTOCOL_VERSION));\n \n         if (!pfrom->fInbound) {\n             // Mark this node as currently connected, so we update its timestamp later.\n@@ -1275,7 +1273,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::ADDR)\n     {\n-        vector<CAddress> vAddr;\n+        std::vector<CAddress> vAddr;\n         vRecv >> vAddr;\n \n         // Don't want addr from older versions unless seeding\n@@ -1289,7 +1287,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         // Store the new addresses\n-        vector<CAddress> vAddrOk;\n+        std::vector<CAddress> vAddrOk;\n         int64_t nNow = GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n         BOOST_FOREACH(CAddress& addr, vAddr)\n@@ -1351,7 +1349,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::INV)\n     {\n-        vector<CInv> vInv;\n+        std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n@@ -1422,7 +1420,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::GETDATA)\n     {\n-        vector<CInv> vInv;\n+        std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n@@ -1564,7 +1562,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n-        vector<CBlock> vHeaders;\n+        std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(\"net\", \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n@@ -1592,8 +1590,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n-        deque<COutPoint> vWorkQueue;\n-        vector<uint256> vEraseQueue;\n+        std::deque<COutPoint> vWorkQueue;\n+        std::vector<uint256> vEraseQueue;\n         CTransaction tx(deserialize, vRecv);\n \n         CInv inv(MSG_TX, tx.GetHash());\n@@ -1622,7 +1620,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n             // Recursively process any orphan transactions that depended on this one\n-            set<NodeId> setMisbehaving;\n+            std::set<NodeId> setMisbehaving;\n             while (!vWorkQueue.empty()) {\n                 auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());\n                 vWorkQueue.pop_front();\n@@ -1785,7 +1783,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n \n-        std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n@@ -1820,7 +1818,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n-                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                std::list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n@@ -1899,7 +1897,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         {\n             LOCK(cs_main);\n \n-            map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n                 LogPrint(\"net\", \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n@@ -2056,7 +2054,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n-            vector<CBlockIndex *> vToFetch;\n+            std::vector<CBlockIndex *> vToFetch;\n             CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n@@ -2077,7 +2075,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n             } else {\n-                vector<CInv> vGetData;\n+                std::vector<CInv> vGetData;\n                 // Download as much as possible, from earliest to latest.\n                 BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vToFetch) {\n                     if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n@@ -2159,7 +2157,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         pfrom->fSentAddr = true;\n \n         pfrom->vAddrToSend.clear();\n-        vector<CAddress> vAddr = connman.GetAddresses();\n+        std::vector<CAddress> vAddr = connman.GetAddresses();\n         FastRandomContext insecure_rand;\n         BOOST_FOREACH(const CAddress &addr, vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n@@ -2290,7 +2288,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::FILTERADD)\n     {\n-        vector<unsigned char> vData;\n+        std::vector<unsigned char> vData;\n         vRecv >> vData;\n \n         // Nodes must NEVER send a data item > 520 bytes (the max size for a script data object,\n@@ -2328,10 +2326,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     {\n         if (fDebug) {\n             try {\n-                string strMsg; unsigned char ccode; string strReason;\n+                std::string strMsg; unsigned char ccode; std::string strReason;\n                 vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);\n \n-                ostringstream ss;\n+                std::ostringstream ss;\n                 ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;\n \n                 if (strMsg == NetMsgType::BLOCK || strMsg == NetMsgType::TX)\n@@ -2434,7 +2432,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman)\n             LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n             continue;\n         }\n-        string strCommand = hdr.GetCommand();\n+        std::string strCommand = hdr.GetCommand();\n \n         // Message size\n         unsigned int nMessageSize = hdr.nMessageSize;\n@@ -2460,7 +2458,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman)\n         }\n         catch (const std::ios_base::failure& e)\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\")));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n@@ -2567,7 +2565,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         CNodeState &state = *State(pto->GetId());\n \n         BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+            connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n         state.rejects.clear();\n \n         if (state.fShouldBan) {\n@@ -2598,7 +2596,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         //\n         if (pto->nNextAddrSend < nNow) {\n             pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n-            vector<CAddress> vAddr;\n+            std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());\n             BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n             {\n@@ -2666,7 +2664,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             // blocks, or if the peer doesn't want headers, just\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n-            vector<CBlock> vHeaders;\n+            std::vector<CBlock> vHeaders;\n             bool fRevertToInv = ((!state.fPreferHeaders &&\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n@@ -2781,7 +2779,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         //\n         // Message: inventory\n         //\n-        vector<CInv> vInv;\n+        std::vector<CInv> vInv;\n         {\n             LOCK(pto->cs_inventory);\n             vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n@@ -2846,7 +2844,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             // Determine transactions to relay\n             if (fSendTrickle) {\n                 // Produce a vector with all candidates for sending\n-                vector<std::set<uint256>::iterator> vInvTx;\n+                std::vector<std::set<uint256>::iterator> vInvTx;\n                 vInvTx.reserve(pto->setInventoryTxToSend.size());\n                 for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n                     vInvTx.push_back(it);\n@@ -2940,9 +2938,9 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         //\n         // Message: getdata (blocks)\n         //\n-        vector<CInv> vGetData;\n+        std::vector<CInv> vGetData;\n         if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            vector<CBlockIndex*> vToDownload;\n+            std::vector<CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {"
      },
      {
        "sha": "843be02f783bc2ffb82b9033be1c5cbb148d07bb",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 28,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -21,8 +21,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n \n enum RetFormat {\n@@ -65,7 +63,7 @@ extern UniValue mempoolToJSON(bool fVerbose = false);\n extern void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n extern UniValue blockheaderToJSON(const CBlockIndex* blockindex);\n \n-static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, string message)\n+static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string message)\n {\n     req->WriteHeader(\"Content-Type\", \"text/plain\");\n     req->WriteReply(status, message + \"\\r\\n\");\n@@ -88,14 +86,14 @@ static enum RetFormat ParseDataFormat(std::string& param, const std::string& str\n         if (suff == rf_names[i].name)\n             return rf_names[i].rf;\n \n-    /* If no suffix is found, return original string.  */\n+    /* If no suffix is found, return original std::string.  */\n     param = strReq;\n     return rf_names[0].rf;\n }\n \n-static string AvailableDataFormatsString()\n+static std::string AvailableDataFormatsString()\n {\n-    string formats = \"\";\n+    std::string formats = \"\";\n     for (unsigned int i = 0; i < ARRAYLEN(rf_names); i++)\n         if (strlen(rf_names[i].name) > 0) {\n             formats.append(\".\");\n@@ -109,7 +107,7 @@ static string AvailableDataFormatsString()\n     return formats;\n }\n \n-static bool ParseHashStr(const string& strReq, uint256& v)\n+static bool ParseHashStr(const std::string& strReq, uint256& v)\n {\n     if (!IsHex(strReq) || (strReq.size() != 64))\n         return false;\n@@ -133,7 +131,7 @@ static bool rest_headers(HTTPRequest* req,\n         return false;\n     std::string param;\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n-    vector<string> path;\n+    std::vector<std::string> path;\n     boost::split(path, param, boost::is_any_of(\"/\"));\n \n     if (path.size() != 2)\n@@ -143,7 +141,7 @@ static bool rest_headers(HTTPRequest* req,\n     if (count < 1 || count > 2000)\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n \n-    string hashStr = path[1];\n+    std::string hashStr = path[1];\n     uint256 hash;\n     if (!ParseHashStr(hashStr, hash))\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n@@ -169,14 +167,14 @@ static bool rest_headers(HTTPRequest* req,\n \n     switch (rf) {\n     case RF_BINARY: {\n-        string binaryHeader = ssHeader.str();\n+        std::string binaryHeader = ssHeader.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n@@ -186,7 +184,7 @@ static bool rest_headers(HTTPRequest* req,\n         BOOST_FOREACH(const CBlockIndex *pindex, headers) {\n             jsonHeaders.push_back(blockheaderToJSON(pindex));\n         }\n-        string strJSON = jsonHeaders.write() + \"\\n\";\n+        std::string strJSON = jsonHeaders.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -233,22 +231,22 @@ static bool rest_block(HTTPRequest* req,\n \n     switch (rf) {\n     case RF_BINARY: {\n-        string binaryBlock = ssBlock.str();\n+        std::string binaryBlock = ssBlock.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n     case RF_JSON: {\n         UniValue objBlock = blockToJSON(block, pblockindex, showTxDetails);\n-        string strJSON = objBlock.write() + \"\\n\";\n+        std::string strJSON = objBlock.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -288,7 +286,7 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n         JSONRPCRequest jsonRequest;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\n-        string strJSON = chainInfoObject.write() + \"\\n\";\n+        std::string strJSON = chainInfoObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -313,7 +311,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n     case RF_JSON: {\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n-        string strJSON = mempoolInfoObject.write() + \"\\n\";\n+        std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -338,7 +336,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n     case RF_JSON: {\n         UniValue mempoolObject = mempoolToJSON(true);\n \n-        string strJSON = mempoolObject.write() + \"\\n\";\n+        std::string strJSON = mempoolObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -373,14 +371,14 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n \n     switch (rf) {\n     case RF_BINARY: {\n-        string binaryTx = ssTx.str();\n+        std::string binaryTx = ssTx.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n@@ -389,7 +387,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     case RF_JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToJSON(*tx, hashBlock, objTx);\n-        string strJSON = objTx.write() + \"\\n\";\n+        std::string strJSON = objTx.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -411,7 +409,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     std::string param;\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n-    vector<string> uriParts;\n+    std::vector<std::string> uriParts;\n     if (param.length() > 1)\n     {\n         std::string strUriParams = param.substr(1);\n@@ -425,7 +423,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n \n     bool fInputParsed = false;\n     bool fCheckMemPool = false;\n-    vector<COutPoint> vOutPoints;\n+    std::vector<COutPoint> vOutPoints;\n \n     // parse/deserialize input\n     // input-format = output-format, rest/getutxos/bin requires binary input, gives binary output, ...\n@@ -499,8 +497,8 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\n \n     // check spentness and form a bitmap (as well as a JSON capable human-readable string representation)\n-    vector<unsigned char> bitmap;\n-    vector<CCoin> outs;\n+    std::vector<unsigned char> bitmap;\n+    std::vector<CCoin> outs;\n     std::string bitmapStringRepresentation;\n     boost::dynamic_bitset<unsigned char> hits(vOutPoints.size());\n     {\n@@ -544,7 +542,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n-        string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n+        std::string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n \n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, ssGetUTXOResponseString);\n@@ -554,7 +552,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     case RF_HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n-        string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n \n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n@@ -586,7 +584,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         objGetUTXOResponse.push_back(Pair(\"utxos\", utxos));\n \n         // return json string\n-        string strJSON = objGetUTXOResponse.write() + \"\\n\";\n+        std::string strJSON = objGetUTXOResponse.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;"
      },
      {
        "sha": "ddcd0224387487fcb9af071b7ac52a8796e0ad72",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 27,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -28,7 +28,6 @@\n \n #include <mutex>\n #include <condition_variable>\n-using namespace std;\n \n struct CUpdatedBlock\n {\n@@ -149,7 +148,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n UniValue getblockcount(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockcount\\n\"\n             \"\\nReturns the number of blocks in the longest blockchain.\\n\"\n             \"\\nResult:\\n\"\n@@ -166,7 +165,7 @@ UniValue getblockcount(const JSONRPCRequest& request)\n UniValue getbestblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getbestblockhash\\n\"\n             \"\\nReturns the hash of the best (tip) block in the longest blockchain.\\n\"\n             \"\\nResult\\n\"\n@@ -193,7 +192,7 @@ void RPCNotifyBlockChange(bool ibd, const CBlockIndex * pindex)\n UniValue waitfornewblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"waitfornewblock (timeout)\\n\"\n             \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n             \"\\nReturns the current block on timeout or exit.\\n\"\n@@ -231,7 +230,7 @@ UniValue waitfornewblock(const JSONRPCRequest& request)\n UniValue waitforblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"waitforblock <blockhash> (timeout)\\n\"\n             \"\\nWaits for a specific new block and returns useful info about it.\\n\"\n             \"\\nReturns the current block on timeout or exit.\\n\"\n@@ -273,7 +272,7 @@ UniValue waitforblock(const JSONRPCRequest& request)\n UniValue waitforblockheight(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"waitforblockheight <blockheight> (timeout)\\n\"\n             \"\\nWaits for (at least) block height and returns the height and hash\\n\"\n             \"of the current tip.\\n\"\n@@ -315,7 +314,7 @@ UniValue waitforblockheight(const JSONRPCRequest& request)\n UniValue getdifficulty(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getdifficulty\\n\"\n             \"\\nReturns the proof-of-work difficulty as a multiple of the minimum difficulty.\\n\"\n             \"\\nResult:\\n\"\n@@ -367,15 +366,15 @@ void entryToJSON(UniValue &info, const CTxMemPoolEntry &e)\n     info.push_back(Pair(\"ancestorsize\", e.GetSizeWithAncestors()));\n     info.push_back(Pair(\"ancestorfees\", e.GetModFeesWithAncestors()));\n     const CTransaction& tx = e.GetTx();\n-    set<string> setDepends;\n+    std::set<std::string> setDepends;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n     {\n         if (mempool.exists(txin.prevout.hash))\n             setDepends.insert(txin.prevout.hash.ToString());\n     }\n \n     UniValue depends(UniValue::VARR);\n-    BOOST_FOREACH(const string& dep, setDepends)\n+    BOOST_FOREACH(const std::string& dep, setDepends)\n     {\n         depends.push_back(dep);\n     }\n@@ -400,7 +399,7 @@ UniValue mempoolToJSON(bool fVerbose = false)\n     }\n     else\n     {\n-        vector<uint256> vtxid;\n+        std::vector<uint256> vtxid;\n         mempool.queryHashes(vtxid);\n \n         UniValue a(UniValue::VARR);\n@@ -414,7 +413,7 @@ UniValue mempoolToJSON(bool fVerbose = false)\n UniValue getrawmempool(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getrawmempool ( verbose )\\n\"\n             \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\"\n             \"\\nArguments:\\n\"\n@@ -445,7 +444,7 @@ UniValue getrawmempool(const JSONRPCRequest& request)\n UniValue getmempoolancestors(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempoolancestors txid (verbose)\\n\"\n             \"\\nIf txid is in the mempool, returns all in-mempool ancestors.\\n\"\n             \"\\nArguments:\\n\"\n@@ -509,7 +508,7 @@ UniValue getmempoolancestors(const JSONRPCRequest& request)\n UniValue getmempooldescendants(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempooldescendants txid (verbose)\\n\"\n             \"\\nIf txid is in the mempool, returns all in-mempool descendants.\\n\"\n             \"\\nArguments:\\n\"\n@@ -573,7 +572,7 @@ UniValue getmempooldescendants(const JSONRPCRequest& request)\n UniValue getmempoolentry(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempoolentry txid\\n\"\n             \"\\nReturns mempool data for given transaction\\n\"\n             \"\\nArguments:\\n\"\n@@ -606,7 +605,7 @@ UniValue getmempoolentry(const JSONRPCRequest& request)\n UniValue getblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockhash index\\n\"\n             \"\\nReturns hash of block in best-block-chain at index provided.\\n\"\n             \"\\nArguments:\\n\"\n@@ -631,7 +630,7 @@ UniValue getblockhash(const JSONRPCRequest& request)\n UniValue getblockheader(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockheader \\\"hash\\\" ( verbose )\\n\"\n             \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'.\\n\"\n             \"If verbose is true, returns an Object with information about blockheader <hash>.\\n\"\n@@ -690,7 +689,7 @@ UniValue getblockheader(const JSONRPCRequest& request)\n UniValue getblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblock \\\"hash\\\" ( verbose )\\n\"\n             \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.\\n\"\n             \"If verbose is true, returns an Object with information about block <hash>.\\n\"\n@@ -817,7 +816,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettxoutsetinfo\\n\"\n             \"\\nReturns statistics about the unspent transaction output set.\\n\"\n             \"Note this call may take some time.\\n\"\n@@ -857,7 +856,7 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n UniValue gettxout(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettxout \\\"txid\\\" n ( includemempool )\\n\"\n             \"\\nReturns details about an unspent transaction output.\\n\"\n             \"\\nArguments:\\n\"\n@@ -939,7 +938,7 @@ UniValue verifychain(const JSONRPCRequest& request)\n     int nCheckLevel = GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL);\n     int nCheckDepth = GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS);\n     if (request.fHelp || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"verifychain ( checklevel numblocks )\\n\"\n             \"\\nVerifies blockchain database.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1025,7 +1024,7 @@ void BIP9SoftForkDescPushBack(UniValue& bip9_softforks, const std::string &name,\n UniValue getblockchaininfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblockchaininfo\\n\"\n             \"Returns an object containing various state info regarding blockchain processing.\\n\"\n             \"\\nResult:\\n\"\n@@ -1118,7 +1117,7 @@ struct CompareBlocksByHeight\n UniValue getchaintips(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getchaintips\\n\"\n             \"Return information about all known tips in the block tree,\"\n             \" including the main chain as well as orphaned branches.\\n\"\n@@ -1190,7 +1189,7 @@ UniValue getchaintips(const JSONRPCRequest& request)\n         const int branchLen = block->nHeight - chainActive.FindFork(block)->nHeight;\n         obj.push_back(Pair(\"branchlen\", branchLen));\n \n-        string status;\n+        std::string status;\n         if (chainActive.Contains(block)) {\n             // This block is part of the currently active chain.\n             status = \"active\";\n@@ -1234,7 +1233,7 @@ UniValue mempoolInfoToJSON()\n UniValue getmempoolinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmempoolinfo\\n\"\n             \"\\nReturns details on the active state of the TX memory pool.\\n\"\n             \"\\nResult:\\n\"\n@@ -1256,7 +1255,7 @@ UniValue getmempoolinfo(const JSONRPCRequest& request)\n UniValue preciousblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"preciousblock \\\"hash\\\"\\n\"\n             \"\\nTreats a block as if it were received before others with the same work.\\n\"\n             \"\\nA later preciousblock call can override the effect of an earlier one.\\n\"\n@@ -1294,7 +1293,7 @@ UniValue preciousblock(const JSONRPCRequest& request)\n UniValue invalidateblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"invalidateblock \\\"hash\\\"\\n\"\n             \"\\nPermanently marks a block as invalid, as if it violated a consensus rule.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1332,7 +1331,7 @@ UniValue invalidateblock(const JSONRPCRequest& request)\n UniValue reconsiderblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"reconsiderblock \\\"hash\\\"\\n\"\n             \"\\nRemoves invalidity status of a block and its descendants, reconsider them for activation.\\n\"\n             \"This can be used to undo the effects of invalidateblock.\\n\""
      },
      {
        "sha": "c229aa1aedc7fcd601daa1ce5d843c6b1442ceca",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -13,8 +13,6 @@\n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <univalue.h>\n \n-using namespace std;\n-\n class CRPCConvertParam\n {\n public:\n@@ -148,7 +146,7 @@ UniValue ParseNonRFCJSONValue(const std::string& strVal)\n     UniValue jVal;\n     if (!jVal.read(std::string(\"[\")+strVal+std::string(\"]\")) ||\n         !jVal.isArray() || jVal.size()!=1)\n-        throw runtime_error(string(\"Error parsing JSON:\")+strVal);\n+        throw std::runtime_error(std::string(\"Error parsing JSON:\")+strVal);\n     return jVal[0];\n }\n "
      },
      {
        "sha": "df1e94ac1efc58b84a7f60b4e4d4d2ec5c963f7d",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -30,8 +30,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n /**\n  * Return average network hashes per second based on the last 'lookup' blocks,\n  * or from the last difficulty change if 'lookup' is nonpositive.\n@@ -77,7 +75,7 @@ UniValue GetNetworkHashPS(int lookup, int height) {\n UniValue getnetworkhashps(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnetworkhashps ( blocks height )\\n\"\n             \"\\nReturns the estimated network hashes per second based on the last n blocks.\\n\"\n             \"Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\\n\"\n@@ -149,7 +147,7 @@ UniValue generateBlocks(boost::shared_ptr<CReserveScript> coinbaseScript, int nG\n UniValue generate(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"generate numblocks ( maxtries )\\n\"\n             \"\\nMine up to numblocks blocks immediately (before the RPC call returns)\\n\"\n             \"\\nArguments:\\n\"\n@@ -185,7 +183,7 @@ UniValue generate(const JSONRPCRequest& request)\n UniValue generatetoaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"generatetoaddress numblocks address (maxtries)\\n\"\n             \"\\nMine blocks immediately to a specified address (before the RPC call returns)\\n\"\n             \"\\nArguments:\\n\"\n@@ -218,7 +216,7 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n UniValue getmininginfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmininginfo\\n\"\n             \"\\nReturns a json object containing mining-related information.\"\n             \"\\nResult:\\n\"\n@@ -259,7 +257,7 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"prioritisetransaction <txid> <priority delta> <fee delta>\\n\"\n             \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\n             \"\\nArguments:\\n\"\n@@ -318,7 +316,7 @@ std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n UniValue getblocktemplate(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getblocktemplate ( TemplateRequest )\\n\"\n             \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\n             \"It returns data needed to construct a block to work on.\\n\"\n@@ -556,7 +554,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n     UniValue transactions(UniValue::VARR);\n-    map<uint256, int64_t> setTxIndex;\n+    std::map<uint256, int64_t> setTxIndex;\n     int i = 0;\n     for (const auto& it : pblock->vtx) {\n         const CTransaction& tx = *it;\n@@ -711,7 +709,7 @@ class submitblock_StateCatcher : public CValidationInterface\n UniValue submitblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"submitblock \\\"hexdata\\\" ( \\\"jsonparametersobject\\\" )\\n\"\n             \"\\nAttempts to submit new block to network.\\n\"\n             \"The 'jsonparametersobject' parameter is currently ignored.\\n\"\n@@ -776,7 +774,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n UniValue estimatefee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"estimatefee nblocks\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n             \"confirmation within nblocks blocks.\\n\"\n@@ -809,7 +807,7 @@ UniValue estimatefee(const JSONRPCRequest& request)\n UniValue estimatepriority(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"estimatepriority nblocks\\n\"\n             \"\\nDEPRECATED. Estimates the approximate priority a zero-fee transaction needs to begin\\n\"\n             \"confirmation within nblocks blocks.\\n\"\n@@ -836,7 +834,7 @@ UniValue estimatepriority(const JSONRPCRequest& request)\n UniValue estimatesmartfee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"estimatesmartfee nblocks\\n\"\n             \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n@@ -872,7 +870,7 @@ UniValue estimatesmartfee(const JSONRPCRequest& request)\n UniValue estimatesmartpriority(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"estimatesmartpriority nblocks\\n\"\n             \"\\nDEPRECATED. WARNING: This interface is unstable and may disappear or change!\\n\"\n             \"\\nEstimates the approximate priority a zero-fee transaction needs to begin\\n\""
      },
      {
        "sha": "3faa7ea64af42c067a904c32bad4a56fa8892777",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 29,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -24,8 +24,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n /**\n  * @note Do not add or change anything in the information returned by this\n  * method. `getinfo` exists for backwards-compatibility only. It combines\n@@ -42,7 +40,7 @@ using namespace std;\n UniValue getinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getinfo\\n\"\n             \"\\nDEPRECATED. Returns an object containing various state info.\\n\"\n             \"\\nResult:\\n\"\n@@ -91,7 +89,7 @@ UniValue getinfo(const JSONRPCRequest& request)\n     obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n     if(g_connman)\n         obj.push_back(Pair(\"connections\",   (int)g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL)));\n-    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : std::string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"testnet\",       Params().NetworkIDString() == CBaseChainParams::TESTNET));\n #ifdef ENABLE_WALLET\n@@ -151,7 +149,7 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n UniValue validateaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"validateaddress \\\"bitcoinaddress\\\"\\n\"\n             \"\\nReturn information about the given bitcoin address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -189,7 +187,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n     if (isValid)\n     {\n         CTxDestination dest = address.Get();\n-        string currentAddress = address.ToString();\n+        std::string currentAddress = address.ToString();\n         ret.push_back(Pair(\"address\", currentAddress));\n \n         CScript scriptPubKey = GetScriptForDestination(dest);\n@@ -224,13 +222,13 @@ CScript _createmultisig_redeemScript(const UniValue& params)\n \n     // Gather public keys\n     if (nRequired < 1)\n-        throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n+        throw std::runtime_error(\"a multisignature address must require at least one key to redeem\");\n     if ((int)keys.size() < nRequired)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             strprintf(\"not enough keys supplied \"\n                       \"(got %u keys, but need at least %d to redeem)\", keys.size(), nRequired));\n     if (keys.size() > 16)\n-        throw runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n+        throw std::runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n     std::vector<CPubKey> pubkeys;\n     pubkeys.resize(keys.size());\n     for (unsigned int i = 0; i < keys.size(); i++)\n@@ -243,14 +241,14 @@ CScript _createmultisig_redeemScript(const UniValue& params)\n         {\n             CKeyID keyID;\n             if (!address.GetKeyID(keyID))\n-                throw runtime_error(\n+                throw std::runtime_error(\n                     strprintf(\"%s does not refer to a key\",ks));\n             CPubKey vchPubKey;\n             if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n-                throw runtime_error(\n+                throw std::runtime_error(\n                     strprintf(\"no full public key for address %s\",ks));\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw std::runtime_error(\" Invalid public key: \"+ks);\n             pubkeys[i] = vchPubKey;\n         }\n \n@@ -261,18 +259,18 @@ CScript _createmultisig_redeemScript(const UniValue& params)\n         {\n             CPubKey vchPubKey(ParseHex(ks));\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw std::runtime_error(\" Invalid public key: \"+ks);\n             pubkeys[i] = vchPubKey;\n         }\n         else\n         {\n-            throw runtime_error(\" Invalid public key: \"+ks);\n+            throw std::runtime_error(\" Invalid public key: \"+ks);\n         }\n     }\n     CScript result = GetScriptForMultisig(nRequired, pubkeys);\n \n     if (result.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                 strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n \n     return result;\n@@ -282,7 +280,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)\n     {\n-        string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n+        std::string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n             \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n             \"It returns a json object with the address and redeemScript.\\n\"\n \n@@ -306,7 +304,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n             \"\\nAs a json rpc call\\n\"\n             + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n         ;\n-        throw runtime_error(msg);\n+        throw std::runtime_error(msg);\n     }\n \n     // Construct using pay-to-script-hash:\n@@ -324,7 +322,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n UniValue verifymessage(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"verifymessage \\\"bitcoinaddress\\\" \\\"signature\\\" \\\"message\\\"\\n\"\n             \"\\nVerify a signed message\\n\"\n             \"\\nArguments:\\n\"\n@@ -346,9 +344,9 @@ UniValue verifymessage(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    string strAddress  = request.params[0].get_str();\n-    string strSign     = request.params[1].get_str();\n-    string strMessage  = request.params[2].get_str();\n+    std::string strAddress  = request.params[0].get_str();\n+    std::string strSign     = request.params[1].get_str();\n+    std::string strMessage  = request.params[2].get_str();\n \n     CBitcoinAddress addr(strAddress);\n     if (!addr.IsValid())\n@@ -359,7 +357,7 @@ UniValue verifymessage(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n \n     bool fInvalid = false;\n-    vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n+    std::vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n \n     if (fInvalid)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Malformed base64 encoding\");\n@@ -378,7 +376,7 @@ UniValue verifymessage(const JSONRPCRequest& request)\n UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"signmessagewithprivkey \\\"privkey\\\" \\\"message\\\"\\n\"\n             \"\\nSign a message with the private key of an address\\n\"\n             \"\\nArguments:\\n\"\n@@ -395,8 +393,8 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"signmessagewithprivkey\", \"\\\"privkey\\\", \\\"my message\\\"\")\n         );\n \n-    string strPrivkey = request.params[0].get_str();\n-    string strMessage = request.params[1].get_str();\n+    std::string strPrivkey = request.params[0].get_str();\n+    std::string strMessage = request.params[1].get_str();\n \n     CBitcoinSecret vchSecret;\n     bool fGood = vchSecret.SetString(strPrivkey);\n@@ -410,7 +408,7 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n     ss << strMessageMagic;\n     ss << strMessage;\n \n-    vector<unsigned char> vchSig;\n+    std::vector<unsigned char> vchSig;\n     if (!key.SignCompact(ss.GetHash(), vchSig))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n \n@@ -420,7 +418,7 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n UniValue setmocktime(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"setmocktime timestamp\\n\"\n             \"\\nSet the local time to given timestamp (-regtest only)\\n\"\n             \"\\nArguments:\\n\"\n@@ -429,7 +427,7 @@ UniValue setmocktime(const JSONRPCRequest& request)\n         );\n \n     if (!Params().MineBlocksOnDemand())\n-        throw runtime_error(\"setmocktime for regression testing (-regtest mode) only\");\n+        throw std::runtime_error(\"setmocktime for regression testing (-regtest mode) only\");\n \n     // cs_vNodes is locked and node send/receive times are updated\n     // atomically with the time change to prevent peers from being\n@@ -469,7 +467,7 @@ UniValue getmemoryinfo(const JSONRPCRequest& request)\n      * as users will undoubtedly confuse it with the other \"memory pool\"\n      */\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getmemoryinfo\\n\"\n             \"Returns an object containing information about memory usage.\\n\"\n             \"\\nResult:\\n\""
      },
      {
        "sha": "d4f1ab88ee09c645217b1bb152a354b4ca037718",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 20,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -22,12 +22,10 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n UniValue getconnectioncount(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getconnectioncount\\n\"\n             \"\\nReturns the number of connections to other nodes.\\n\"\n             \"\\nResult:\\n\"\n@@ -46,7 +44,7 @@ UniValue getconnectioncount(const JSONRPCRequest& request)\n UniValue ping(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"ping\\n\"\n             \"\\nRequests that a ping be sent to all other nodes, to measure ping time.\\n\"\n             \"Results provided in getpeerinfo, pingtime and pingwait fields are decimal seconds.\\n\"\n@@ -69,7 +67,7 @@ UniValue ping(const JSONRPCRequest& request)\n UniValue getpeerinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getpeerinfo\\n\"\n             \"\\nReturns data about each connected network node as a json array of objects.\\n\"\n             \"\\nResult:\\n\"\n@@ -119,7 +117,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    vector<CNodeStats> vstats;\n+    std::vector<CNodeStats> vstats;\n     g_connman->GetNodeStats(vstats);\n \n     UniValue ret(UniValue::VARR);\n@@ -187,12 +185,12 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n \n UniValue addnode(const JSONRPCRequest& request)\n {\n-    string strCommand;\n+    std::string strCommand;\n     if (request.params.size() == 2)\n         strCommand = request.params[1].get_str();\n     if (request.fHelp || request.params.size() != 2 ||\n         (strCommand != \"onetry\" && strCommand != \"add\" && strCommand != \"remove\"))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n             \"\\nAttempts add or remove a node from the addnode list.\\n\"\n             \"Or try a connection to a node once.\\n\"\n@@ -207,7 +205,7 @@ UniValue addnode(const JSONRPCRequest& request)\n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    string strNode = request.params[0].get_str();\n+    std::string strNode = request.params[0].get_str();\n \n     if (strCommand == \"onetry\")\n     {\n@@ -233,7 +231,7 @@ UniValue addnode(const JSONRPCRequest& request)\n UniValue disconnectnode(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"disconnectnode \\\"node\\\" \\n\"\n             \"\\nImmediately disconnects from the specified node.\\n\"\n             \"\\nArguments:\\n\"\n@@ -256,7 +254,7 @@ UniValue disconnectnode(const JSONRPCRequest& request)\n UniValue getaddednodeinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaddednodeinfo ( \\\"node\\\" )\\n\"\n             \"\\nReturns information about the given added node, or all added nodes\\n\"\n             \"(note that onetry addnodes are not listed here)\\n\"\n@@ -324,7 +322,7 @@ UniValue getaddednodeinfo(const JSONRPCRequest& request)\n UniValue getnettotals(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnettotals\\n\"\n             \"\\nReturns information about network traffic, including bytes in, bytes out,\\n\"\n             \"and current time.\\n\"\n@@ -380,7 +378,7 @@ static UniValue GetNetworksInfo()\n         obj.push_back(Pair(\"name\", GetNetworkName(network)));\n         obj.push_back(Pair(\"limited\", IsLimited(network)));\n         obj.push_back(Pair(\"reachable\", IsReachable(network)));\n-        obj.push_back(Pair(\"proxy\", proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string()));\n+        obj.push_back(Pair(\"proxy\", proxy.IsValid() ? proxy.proxy.ToStringIPPort() : std::string()));\n         obj.push_back(Pair(\"proxy_randomize_credentials\", proxy.randomize_credentials));\n         networks.push_back(obj);\n     }\n@@ -390,7 +388,7 @@ static UniValue GetNetworksInfo()\n UniValue getnetworkinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnetworkinfo\\n\"\n             \"Returns an object containing various state info regarding P2P networking.\\n\"\n             \"\\nResult:\\n\"\n@@ -462,12 +460,12 @@ UniValue getnetworkinfo(const JSONRPCRequest& request)\n \n UniValue setban(const JSONRPCRequest& request)\n {\n-    string strCommand;\n+    std::string strCommand;\n     if (request.params.size() >= 2)\n         strCommand = request.params[1].get_str();\n     if (request.fHelp || request.params.size() < 2 ||\n         (strCommand != \"add\" && strCommand != \"remove\"))\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"setban \\\"ip(/netmask)\\\" \\\"add|remove\\\" (bantime) (absolute)\\n\"\n                             \"\\nAttempts add or remove a IP/Subnet from the banned list.\\n\"\n                             \"\\nArguments:\\n\"\n@@ -487,7 +485,7 @@ UniValue setban(const JSONRPCRequest& request)\n     CNetAddr netAddr;\n     bool isSubnet = false;\n \n-    if (request.params[0].get_str().find(\"/\") != string::npos)\n+    if (request.params[0].get_str().find(\"/\") != std::string::npos)\n         isSubnet = true;\n \n     if (!isSubnet) {\n@@ -527,7 +525,7 @@ UniValue setban(const JSONRPCRequest& request)\n UniValue listbanned(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"listbanned\\n\"\n                             \"\\nList all banned IPs/Subnets.\\n\"\n                             \"\\nExamples:\\n\"\n@@ -560,7 +558,7 @@ UniValue listbanned(const JSONRPCRequest& request)\n UniValue clearbanned(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"clearbanned\\n\"\n                             \"\\nClear all banned IPs.\\n\"\n                             \"\\nExamples:\\n\"\n@@ -578,7 +576,7 @@ UniValue clearbanned(const JSONRPCRequest& request)\n UniValue setnetworkactive(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"setnetworkactive true|false\\n\"\n             \"Disable/enable all p2p network activity.\"\n         );"
      },
      {
        "sha": "50de574817f01b6f698d888c76757a2287065fad",
        "filename": "src/rpc/protocol.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -15,8 +15,6 @@\n #include <stdint.h>\n #include <fstream>\n \n-using namespace std;\n-\n /**\n  * JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n  * but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were\n@@ -26,7 +24,7 @@ using namespace std;\n  * 1.2 spec: http://jsonrpc.org/historical/json-rpc-over-http.html\n  */\n \n-UniValue JSONRPCRequestObj(const string& strMethod, const UniValue& params, const UniValue& id)\n+UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id)\n {\n     UniValue request(UniValue::VOBJ);\n     request.push_back(Pair(\"method\", strMethod));\n@@ -47,13 +45,13 @@ UniValue JSONRPCReplyObj(const UniValue& result, const UniValue& error, const Un\n     return reply;\n }\n \n-string JSONRPCReply(const UniValue& result, const UniValue& error, const UniValue& id)\n+std::string JSONRPCReply(const UniValue& result, const UniValue& error, const UniValue& id)\n {\n     UniValue reply = JSONRPCReplyObj(result, error, id);\n     return reply.write() + \"\\n\";\n }\n \n-UniValue JSONRPCError(int code, const string& message)\n+UniValue JSONRPCError(int code, const std::string& message)\n {\n     UniValue error(UniValue::VOBJ);\n     error.push_back(Pair(\"code\", code));\n@@ -125,4 +123,3 @@ void DeleteAuthCookie()\n         LogPrintf(\"%s: Unable to remove random auth cookie file: %s\\n\", __func__, e.what());\n     }\n }\n-"
      },
      {
        "sha": "f4d39a3f6110961f1fa27633fff771deb1cb9350",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 36,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -33,12 +33,10 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex)\n {\n     txnouttype type;\n-    vector<CTxDestination> addresses;\n+    std::vector<CTxDestination> addresses;\n     int nRequired;\n \n     out.push_back(Pair(\"asm\", ScriptToAsmStr(scriptPubKey)));\n@@ -129,7 +127,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n UniValue getrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getrawtransaction \\\"txid\\\" ( verbose )\\n\"\n             \"\\nNOTE: By default this function only works sometimes. This is when the tx is in the mempool\\n\"\n             \"or there is an unspent output in the utxo for this transaction. To make it always work,\\n\"\n@@ -223,7 +221,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n     if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n \n-    string strHex = EncodeHexTx(*tx);\n+    std::string strHex = EncodeHexTx(*tx);\n \n     if (!fVerbose)\n         return strHex;\n@@ -237,7 +235,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n UniValue gettxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || (request.params.size() != 1 && request.params.size() != 2))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettxoutproof [\\\"txid\\\",...] ( blockhash )\\n\"\n             \"\\nReturns a hex-encoded proof that \\\"txid\\\" was included in a block.\\n\"\n             \"\\nNOTE: By default this function only works sometimes. This is when there is an\\n\"\n@@ -256,16 +254,16 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n             \"\\\"data\\\"           (string) A string that is a serialized, hex-encoded data for the proof.\\n\"\n         );\n \n-    set<uint256> setTxids;\n+    std::set<uint256> setTxids;\n     uint256 oneTxid;\n     UniValue txids = request.params[0].get_array();\n     for (unsigned int idx = 0; idx < txids.size(); idx++) {\n         const UniValue& txid = txids[idx];\n         if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid txid \")+txid.get_str());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid txid \")+txid.get_str());\n         uint256 hash(uint256S(txid.get_str()));\n         if (setTxids.count(hash))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated txid: \")+txid.get_str());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated txid: \")+txid.get_str());\n        setTxids.insert(hash);\n        oneTxid = hash;\n     }\n@@ -318,7 +316,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n UniValue verifytxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"verifytxoutproof \\\"proof\\\"\\n\"\n             \"\\nVerifies that a proof points to a transaction in a block, returning the transaction it commits to\\n\"\n             \"and throwing an RPC error if the block is not in our best chain\\n\"\n@@ -334,8 +332,8 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n \n     UniValue res(UniValue::VARR);\n \n-    vector<uint256> vMatch;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatch;\n+    std::vector<unsigned int> vIndex;\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot)\n         return res;\n \n@@ -352,7 +350,7 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime )\\n\"\n             \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n             \"Outputs can be addresses or data.\\n\"\n@@ -433,9 +431,9 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         rawTx.vin.push_back(in);\n     }\n \n-    set<CBitcoinAddress> setAddress;\n-    vector<string> addrList = sendTo.getKeys();\n-    BOOST_FOREACH(const string& name_, addrList) {\n+    std::set<CBitcoinAddress> setAddress;\n+    std::vector<std::string> addrList = sendTo.getKeys();\n+    BOOST_FOREACH(const std::string& name_, addrList) {\n \n         if (name_ == \"data\") {\n             std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),\"Data\");\n@@ -445,10 +443,10 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         } else {\n             CBitcoinAddress address(name_);\n             if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+name_);\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+name_);\n \n             if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+name_);\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+name_);\n             setAddress.insert(address);\n \n             CScript scriptPubKey = GetScriptForDestination(address.Get());\n@@ -465,7 +463,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n UniValue decoderawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"decoderawtransaction \\\"hexstring\\\"\\n\"\n             \"\\nReturn a JSON object representing the serialized, hex-encoded transaction.\\n\"\n \n@@ -534,7 +532,7 @@ UniValue decoderawtransaction(const JSONRPCRequest& request)\n UniValue decodescript(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"decodescript \\\"hex\\\"\\n\"\n             \"\\nDecode a hex-encoded script.\\n\"\n             \"\\nArguments:\\n\"\n@@ -561,7 +559,7 @@ UniValue decodescript(const JSONRPCRequest& request)\n     UniValue r(UniValue::VOBJ);\n     CScript script;\n     if (request.params[0].get_str().size() > 0){\n-        vector<unsigned char> scriptData(ParseHexV(request.params[0], \"argument\"));\n+        std::vector<unsigned char> scriptData(ParseHexV(request.params[0], \"argument\"));\n         script = CScript(scriptData.begin(), scriptData.end());\n     } else {\n         // Empty scripts are valid\n@@ -595,7 +593,7 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n UniValue signrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"signrawtransaction \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] [\\\"privatekey1\\\",...] sighashtype )\\n\"\n             \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n             \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n@@ -660,9 +658,9 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n #endif\n     RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VARR)(UniValue::VARR)(UniValue::VSTR), true);\n \n-    vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n+    std::vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    vector<CMutableTransaction> txVariants;\n+    std::vector<CMutableTransaction> txVariants;\n     while (!ssData.empty()) {\n         try {\n             CMutableTransaction tx;\n@@ -744,13 +742,13 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n             if (nOut < 0)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n \n-            vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n+            std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n                 CCoinsModifier coins = view.ModifyCoins(txid);\n                 if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n-                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n+                    std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n                     err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n@@ -776,7 +774,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n                     });\n                 UniValue v = find_value(prevOut, \"redeemScript\");\n                 if (!v.isNull()) {\n-                    vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\n+                    std::vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\n                     CScript redeemScript(rsData.begin(), rsData.end());\n                     tempKeystore.AddCScript(redeemScript);\n                 }\n@@ -792,16 +790,16 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n     int nHashType = SIGHASH_ALL;\n     if (request.params.size() > 3 && !request.params[3].isNull()) {\n-        static map<string, int> mapSigHashValues =\n+        static std::map<std::string, int> mapSigHashValues =\n             boost::assign::map_list_of\n-            (string(\"ALL\"), int(SIGHASH_ALL))\n-            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n-            (string(\"NONE\"), int(SIGHASH_NONE))\n-            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n-            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n-            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n+            (std::string(\"ALL\"), int(SIGHASH_ALL))\n+            (std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n+            (std::string(\"NONE\"), int(SIGHASH_NONE))\n+            (std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n+            (std::string(\"SINGLE\"), int(SIGHASH_SINGLE))\n+            (std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n             ;\n-        string strHashType = request.params[3].get_str();\n+        std::string strHashType = request.params[3].get_str();\n         if (mapSigHashValues.count(strHashType))\n             nHashType = mapSigHashValues[strHashType];\n         else\n@@ -859,7 +857,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n UniValue sendrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendrawtransaction \\\"hexstring\\\" ( allowhighfees )\\n\"\n             \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\n             \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\""
      },
      {
        "sha": "a4150f49fbe631a964109b55cd0ce9ca0ad1fffb",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 31,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -27,9 +27,6 @@\n \n #include <memory> // for unique_ptr\n \n-using namespace RPCServer;\n-using namespace std;\n-\n static bool fRPCRunning = false;\n static bool fRPCInWarmup = true;\n static std::string rpcWarmupStatus(\"RPC server started\");\n@@ -68,7 +65,7 @@ void RPCServer::OnPostCommand(boost::function<void (const CRPCCommand&)> slot)\n }\n \n void RPCTypeCheck(const UniValue& params,\n-                  const list<UniValue::VType>& typesExpected,\n+                  const std::list<UniValue::VType>& typesExpected,\n                   bool fAllowNull)\n {\n     unsigned int i = 0;\n@@ -80,7 +77,7 @@ void RPCTypeCheck(const UniValue& params,\n         const UniValue& v = params[i];\n         if (!((v.type() == t) || (fAllowNull && (v.isNull()))))\n         {\n-            string err = strprintf(\"Expected type %s, got %s\",\n+            std::string err = strprintf(\"Expected type %s, got %s\",\n                                    uvTypeName(t), uvTypeName(v.type()));\n             throw JSONRPCError(RPC_TYPE_ERROR, err);\n         }\n@@ -89,7 +86,7 @@ void RPCTypeCheck(const UniValue& params,\n }\n \n void RPCTypeCheckObj(const UniValue& o,\n-    const map<string, UniValueType>& typesExpected,\n+    const std::map<std::string, UniValueType>& typesExpected,\n     bool fAllowNull,\n     bool fStrict)\n {\n@@ -99,19 +96,19 @@ void RPCTypeCheckObj(const UniValue& o,\n             throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first));\n \n         if (!(t.second.typeAny || v.type() == t.second.type || (fAllowNull && v.isNull()))) {\n-            string err = strprintf(\"Expected type %s for %s, got %s\",\n+            std::string err = strprintf(\"Expected type %s for %s, got %s\",\n                 uvTypeName(t.second.type), t.first, uvTypeName(v.type()));\n             throw JSONRPCError(RPC_TYPE_ERROR, err);\n         }\n     }\n \n     if (fStrict)\n     {\n-        BOOST_FOREACH(const string& k, o.getKeys())\n+        BOOST_FOREACH(const std::string& k, o.getKeys())\n         {\n             if (typesExpected.count(k) == 0)\n             {\n-                string err = strprintf(\"Unexpected key %s\", k);\n+                std::string err = strprintf(\"Unexpected key %s\", k);\n                 throw JSONRPCError(RPC_TYPE_ERROR, err);\n             }\n         }\n@@ -140,9 +137,9 @@ UniValue ValueFromAmount(const CAmount& amount)\n             strprintf(\"%s%d.%08d\", sign ? \"-\" : \"\", quotient, remainder));\n }\n \n-uint256 ParseHashV(const UniValue& v, string strName)\n+uint256 ParseHashV(const UniValue& v, std::string strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.get_str();\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n@@ -153,20 +150,20 @@ uint256 ParseHashV(const UniValue& v, string strName)\n     result.SetHex(strHex);\n     return result;\n }\n-uint256 ParseHashO(const UniValue& o, string strKey)\n+uint256 ParseHashO(const UniValue& o, std::string strKey)\n {\n     return ParseHashV(find_value(o, strKey), strKey);\n }\n-vector<unsigned char> ParseHexV(const UniValue& v, string strName)\n+std::vector<unsigned char> ParseHexV(const UniValue& v, std::string strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.get_str();\n     if (!IsHex(strHex))\n         throw JSONRPCError(RPC_INVALID_PARAMETER, strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n     return ParseHex(strHex);\n }\n-vector<unsigned char> ParseHexO(const UniValue& o, string strKey)\n+std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey)\n {\n     return ParseHexV(find_value(o, strKey), strKey);\n }\n@@ -177,21 +174,21 @@ vector<unsigned char> ParseHexO(const UniValue& o, string strKey)\n \n std::string CRPCTable::help(const std::string& strCommand) const\n {\n-    string strRet;\n-    string category;\n-    set<rpcfn_type> setDone;\n-    vector<pair<string, const CRPCCommand*> > vCommands;\n+    std::string strRet;\n+    std::string category;\n+    std::set<rpcfn_type> setDone;\n+    std::vector<std::pair<std::string, const CRPCCommand*> > vCommands;\n \n-    for (map<string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n+    for (std::map<std::string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n         vCommands.push_back(make_pair(mi->second->category + mi->first, mi->second));\n     sort(vCommands.begin(), vCommands.end());\n \n-    BOOST_FOREACH(const PAIRTYPE(string, const CRPCCommand*)& command, vCommands)\n+    BOOST_FOREACH(const PAIRTYPE(std::string, const CRPCCommand*)& command, vCommands)\n     {\n         const CRPCCommand *pcmd = command.second;\n-        string strMethod = pcmd->name;\n+        std::string strMethod = pcmd->name;\n         // We already filter duplicates, but these deprecated screw up the sort order\n-        if (strMethod.find(\"label\") != string::npos)\n+        if (strMethod.find(\"label\") != std::string::npos)\n             continue;\n         if ((strCommand != \"\" || pcmd->category == \"hidden\") && strMethod != strCommand)\n             continue;\n@@ -206,18 +203,18 @@ std::string CRPCTable::help(const std::string& strCommand) const\n         catch (const std::exception& e)\n         {\n             // Help text is returned in an exception\n-            string strHelp = string(e.what());\n+            std::string strHelp = std::string(e.what());\n             if (strCommand == \"\")\n             {\n-                if (strHelp.find('\\n') != string::npos)\n+                if (strHelp.find('\\n') != std::string::npos)\n                     strHelp = strHelp.substr(0, strHelp.find('\\n'));\n \n                 if (category != pcmd->category)\n                 {\n                     if (!category.empty())\n                         strRet += \"\\n\";\n                     category = pcmd->category;\n-                    string firstLetter = category.substr(0,1);\n+                    std::string firstLetter = category.substr(0,1);\n                     boost::to_upper(firstLetter);\n                     strRet += \"== \" + firstLetter + category.substr(1) + \" ==\\n\";\n                 }\n@@ -234,7 +231,7 @@ std::string CRPCTable::help(const std::string& strCommand) const\n UniValue help(const JSONRPCRequest& jsonRequest)\n {\n     if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"help ( \\\"command\\\" )\\n\"\n             \"\\nList all commands, or get help for a specified command.\\n\"\n             \"\\nArguments:\\n\"\n@@ -243,7 +240,7 @@ UniValue help(const JSONRPCRequest& jsonRequest)\n             \"\\\"text\\\"     (string) The help text\\n\"\n         );\n \n-    string strCommand;\n+    std::string strCommand;\n     if (jsonRequest.params.size() > 0)\n         strCommand = jsonRequest.params[0].get_str();\n \n@@ -255,7 +252,7 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n {\n     // Accept the deprecated and ignored 'detach' boolean argument\n     if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"stop\\n\"\n             \"\\nStop Bitcoin server.\");\n     // Event loop will exit after current HTTP requests have been handled, so\n@@ -289,7 +286,7 @@ CRPCTable::CRPCTable()\n \n const CRPCCommand *CRPCTable::operator[](const std::string &name) const\n {\n-    map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n+    std::map<std::string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it == mapCommands.end())\n         return NULL;\n     return (*it).second;\n@@ -301,7 +298,7 @@ bool CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)\n         return false;\n \n     // don't allow overwriting for now\n-    map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n+    std::map<std::string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it != mapCommands.end())\n         return false;\n "
      },
      {
        "sha": "fc78b8ac3dcfde0ca0e38858f15d5953248cdea6",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -13,9 +13,7 @@\n #include \"script/script.h\"\n #include \"uint256.h\"\n \n-using namespace std;\n-\n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n namespace {\n \n@@ -56,10 +54,10 @@ bool CastToBool(const valtype& vch)\n  */\n #define stacktop(i)  (stack.at(stack.size()+(i)))\n #define altstacktop(i)  (altstack.at(altstack.size()+(i)))\n-static inline void popstack(vector<valtype>& stack)\n+static inline void popstack(std::vector<valtype>& stack)\n {\n     if (stack.empty())\n-        throw runtime_error(\"popstack(): stack empty\");\n+        throw std::runtime_error(\"popstack(): stack empty\");\n     stack.pop_back();\n }\n \n@@ -194,7 +192,7 @@ bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n     return true;\n }\n \n-bool CheckSignatureEncoding(const vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror) {\n+bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror) {\n     // Empty signature. Not strictly DER encoded, but allowed to provide a\n     // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n     if (vchSig.size() == 0) {\n@@ -245,7 +243,7 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n@@ -260,8 +258,8 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    vector<bool> vfExec;\n-    vector<valtype> altstack;\n+    std::vector<bool> vfExec;\n+    std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n     if (script.size() > MAX_SCRIPT_SIZE)\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n@@ -1250,14 +1248,14 @@ bool TransactionSignatureChecker::VerifySignature(const std::vector<unsigned cha\n     return pubkey.Verify(sighash, vchSig);\n }\n \n-bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+bool TransactionSignatureChecker::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n         return false;\n \n     // Hash type is one byte tacked on to the end of the signature\n-    vector<unsigned char> vchSig(vchSigIn);\n+    std::vector<unsigned char> vchSig(vchSigIn);\n     if (vchSig.empty())\n         return false;\n     int nHashType = vchSig.back();\n@@ -1355,7 +1353,7 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n \n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n-    vector<vector<unsigned char> > stack;\n+    std::vector<std::vector<unsigned char> > stack;\n     CScript scriptPubKey;\n \n     if (witversion == 0) {\n@@ -1420,7 +1418,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n     }\n \n-    vector<vector<unsigned char> > stack, stackCopy;\n+    std::vector<std::vector<unsigned char> > stack, stackCopy;\n     if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n@@ -1558,7 +1556,7 @@ size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey,\n \n     if (scriptPubKey.IsPayToScriptHash() && scriptSig.IsPushOnly()) {\n         CScript::const_iterator pc = scriptSig.begin();\n-        vector<unsigned char> data;\n+        std::vector<unsigned char> data;\n         while (pc < scriptSig.end()) {\n             opcodetype opcode;\n             scriptSig.GetOp(pc, opcode, data);"
      },
      {
        "sha": "211f032a3969b2ddf8c717e1186058c417b3237d",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -13,11 +13,9 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n+typedef std::vector<unsigned char> valtype;\n \n-typedef vector<unsigned char> valtype;\n-\n-unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n+unsigned int HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n {\n     unsigned int nResult = 0;\n     BOOST_FOREACH(const valtype& pubkey, pubkeys)\n@@ -49,7 +47,7 @@ isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& i\n \n isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions)) {\n         if (keystore.HaveWatchOnly(scriptPubKey))\n@@ -132,7 +130,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         // partially owned (somebody else has a key that can spend\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n-        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n         if (sigversion != SIGVERSION_BASE) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {"
      },
      {
        "sha": "82f55da545ffd50129aef8d2ec843093c16ac4e3",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -8,8 +8,6 @@\n #include \"tinyformat.h\"\n #include \"utilstrencodings.h\"\n \n-using namespace std;\n-\n const char* GetOpName(opcodetype opcode)\n {\n     switch (opcode)\n@@ -186,7 +184,7 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     // get the last item that the scriptSig\n     // pushes onto the stack:\n     const_iterator pc = scriptSig.begin();\n-    vector<unsigned char> data;\n+    std::vector<unsigned char> data;\n     while (pc < scriptSig.end())\n     {\n         opcodetype opcode;"
      },
      {
        "sha": "7a13b7ead0aec713d3e86c059eb8f988deccf7c2",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -14,8 +14,6 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n typedef std::vector<unsigned char> valtype;\n \n TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n@@ -39,14 +37,14 @@ bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig,\n \n static bool Sign1(const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n-    vector<unsigned char> vchSig;\n+    std::vector<unsigned char> vchSig;\n     if (!creator.CreateSig(vchSig, address, scriptCode, sigversion))\n         return false;\n     ret.push_back(vchSig);\n     return true;\n }\n \n-static bool SignN(const vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n+static bool SignN(const std::vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n@@ -73,7 +71,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n     uint160 h160;\n     ret.clear();\n \n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n         return false;\n \n@@ -125,7 +123,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n     }\n }\n \n-static CScript PushAll(const vector<valtype>& values)\n+static CScript PushAll(const std::vector<valtype>& values)\n {\n     CScript result;\n     BOOST_FOREACH(const valtype& v, values) {\n@@ -233,12 +231,12 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutab\n     return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n-static vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                               const vector<valtype>& vSolutions,\n-                               const vector<valtype>& sigs1, const vector<valtype>& sigs2, SigVersion sigversion)\n+static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+                               const std::vector<valtype>& vSolutions,\n+                               const std::vector<valtype>& sigs1, const std::vector<valtype>& sigs2, SigVersion sigversion)\n {\n     // Combine all the signatures we've got:\n-    set<valtype> allsigs;\n+    std::set<valtype> allsigs;\n     BOOST_FOREACH(const valtype& v, sigs1)\n     {\n         if (!v.empty())\n@@ -254,7 +252,7 @@ static vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSi\n     assert(vSolutions.size() > 1);\n     unsigned int nSigsRequired = vSolutions.front()[0];\n     unsigned int nPubKeys = vSolutions.size()-2;\n-    map<valtype, valtype> sigs;\n+    std::map<valtype, valtype> sigs;\n     BOOST_FOREACH(const valtype& sig, allsigs)\n     {\n         for (unsigned int i = 0; i < nPubKeys; i++)\n@@ -311,7 +309,7 @@ struct Stacks\n }\n \n static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                                 const txnouttype txType, const vector<valtype>& vSolutions,\n+                                 const txnouttype txType, const std::vector<valtype>& vSolutions,\n                                  Stacks sigs1, Stacks sigs2, SigVersion sigversion)\n {\n     switch (txType)\n@@ -345,7 +343,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             CScript pubKey2(spk.begin(), spk.end());\n \n             txnouttype txType2;\n-            vector<vector<unsigned char> > vSolutions2;\n+            std::vector<std::vector<unsigned char> > vSolutions2;\n             Solver(pubKey2, txType2, vSolutions2);\n             sigs1.script.pop_back();\n             sigs2.script.pop_back();\n@@ -365,7 +363,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             // Recur to combine:\n             CScript pubKey2(sigs1.witness.back().begin(), sigs1.witness.back().end());\n             txnouttype txType2;\n-            vector<valtype> vSolutions2;\n+            std::vector<valtype> vSolutions2;\n             Solver(pubKey2, txType2, vSolutions2);\n             sigs1.witness.pop_back();\n             sigs1.script = sigs1.witness;\n@@ -388,7 +386,7 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n                           const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n {\n     txnouttype txType;\n-    vector<vector<unsigned char> > vSolutions;\n+    std::vector<std::vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n     return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();"
      },
      {
        "sha": "a92c3818312d765de8836bc6b9c60a6aa98c9bee",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 13,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -12,9 +12,7 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n bool fAcceptDatacarrier = DEFAULT_ACCEPT_DATACARRIER;\n unsigned nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY;\n@@ -40,20 +38,20 @@ const char* GetTxnOutputType(txnouttype t)\n /**\n  * Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n  */\n-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet)\n {\n     // Templates\n-    static multimap<txnouttype, CScript> mTemplates;\n+    static std::multimap<txnouttype, CScript> mTemplates;\n     if (mTemplates.empty())\n     {\n         // Standard tx, sender provides pubkey, receiver adds signature\n-        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n+        mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n \n         // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n+        mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n \n         // Sender provides N pubkeys, receivers provides M signatures\n-        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n+        mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n     }\n \n     vSolutionsRet.clear();\n@@ -63,7 +61,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n     if (scriptPubKey.IsPayToScriptHash())\n     {\n         typeRet = TX_SCRIPTHASH;\n-        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n+        std::vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n         vSolutionsRet.push_back(hashBytes);\n         return true;\n     }\n@@ -102,7 +100,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n         vSolutionsRet.clear();\n \n         opcodetype opcode1, opcode2;\n-        vector<unsigned char> vch1, vch2;\n+        std::vector<unsigned char> vch1, vch2;\n \n         // Compare\n         CScript::const_iterator pc1 = script1.begin();\n@@ -181,7 +179,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n \n bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n {\n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n@@ -209,11 +207,11 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n     return false;\n }\n \n-bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n+bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet)\n {\n     addressRet.clear();\n     typeRet = TX_NONSTANDARD;\n-    vector<valtype> vSolutions;\n+    std::vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, typeRet, vSolutions))\n         return false;\n     if (typeRet == TX_NULL_DATA){"
      },
      {
        "sha": "1e284609abf8b858f6315ef876b88ff02a352c18",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -10,8 +10,6 @@\n #include \"netbase.h\"\n #include \"random.h\"\n \n-using namespace std;\n-\n class CAddrManTest : public CAddrMan\n {\n     uint64_t state;\n@@ -365,7 +363,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     // Test 22: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n     BOOST_CHECK(addrman.size() == 0);\n-    vector<CAddress> vAddr1 = addrman.GetAddr();\n+    std::vector<CAddress> vAddr1 = addrman.GetAddr();\n     BOOST_CHECK(vAddr1.size() == 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n@@ -401,7 +399,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         int octet1 = i % 256;\n         int octet2 = (i / 256) % 256;\n         int octet3 = (i / (256 * 2)) % 256;\n-        string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n+        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n         \n         // Ensure that for all addrs in addrman, isTerrible == false.\n@@ -410,7 +408,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         if (i % 8 == 0)\n             addrman.Good(addr);\n     }\n-    vector<CAddress> vAddr = addrman.GetAddr();\n+    std::vector<CAddress> vAddr = addrman.GetAddr();\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n     BOOST_CHECK(vAddr.size() == percent23);\n@@ -452,7 +450,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1) != info2.GetTriedBucket(nKey1));\n \n-    set<int> buckets;\n+    std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n@@ -505,7 +503,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n \n-    set<int> buckets;\n+    std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),"
      },
      {
        "sha": "3956c32e55d2a50e0531bd93d7d5994c7c8d175f",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 29,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -21,8 +21,6 @@\n #include <boost/test/unit_test.hpp>\n #include <boost/tuple/tuple.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(bloom_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n@@ -43,8 +41,8 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << filter;\n \n-    vector<unsigned char> vch = ParseHex(\"03614e9b050000000000000001\");\n-    vector<char> expected(vch.size());\n+    std::vector<unsigned char> vch = ParseHex(\"03614e9b050000000000000001\");\n+    std::vector<char> expected(vch.size());\n \n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n@@ -75,8 +73,8 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << filter;\n \n-    vector<unsigned char> vch = ParseHex(\"03ce4299050000000100008001\");\n-    vector<char> expected(vch.size());\n+    std::vector<unsigned char> vch = ParseHex(\"03ce4299050000000100008001\");\n+    std::vector<char> expected(vch.size());\n \n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n@@ -86,24 +84,24 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n \n BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n {\n-    string strSecret = string(\"5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C\");\n+    std::string strSecret = std::string(\"5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C\");\n     CBitcoinSecret vchSecret;\n     BOOST_CHECK(vchSecret.SetString(strSecret));\n \n     CKey key = vchSecret.GetKey();\n     CPubKey pubkey = key.GetPubKey();\n-    vector<unsigned char> vchPubKey(pubkey.begin(), pubkey.end());\n+    std::vector<unsigned char> vchPubKey(pubkey.begin(), pubkey.end());\n \n     CBloomFilter filter(2, 0.001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(vchPubKey);\n     uint160 hash = pubkey.GetID();\n-    filter.insert(vector<unsigned char>(hash.begin(), hash.end()));\n+    filter.insert(std::vector<unsigned char>(hash.begin(), hash.end()));\n \n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << filter;\n \n-    vector<unsigned char> vch = ParseHex(\"038fc16b080000000000000001\");\n-    vector<char> expected(vch.size());\n+    std::vector<unsigned char> vch = ParseHex(\"038fc16b080000000000000001\");\n+    std::vector<char> expected(vch.size());\n \n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n@@ -119,7 +117,7 @@ BOOST_AUTO_TEST_CASE(bloom_match)\n \n     // and one which spends it (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n     unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n-    vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n+    std::vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n     CDataStream spendStream(vch, SER_DISK, CLIENT_VERSION);\n     CTransaction spendingTx(deserialize, spendStream);\n \n@@ -156,7 +154,7 @@ BOOST_AUTO_TEST_CASE(bloom_match)\n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     COutPoint prevOutPoint(uint256S(\"0x90c122d70786e899529d71dbeba91ba216982fb6ba58f3bdaab65e73b7e9260b\"), 0);\n     {\n-        vector<unsigned char> data(32 + sizeof(unsigned int));\n+        std::vector<unsigned char> data(32 + sizeof(unsigned int));\n         memcpy(&data[0], prevOutPoint.hash.begin(), 32);\n         memcpy(&data[32], &prevOutPoint.n, sizeof(unsigned int));\n         filter.insert(data);\n@@ -196,13 +194,13 @@ BOOST_AUTO_TEST_CASE(merkle_block_1)\n     BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n-    pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n+    std::pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x74d681e0e03bafa802c8aa084379aa98d9fcd632ddc2ed9782b586ec87451f20\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 8);\n \n-    vector<uint256> vMatched;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatched;\n+    std::vector<unsigned int> vIndex;\n     BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n@@ -242,13 +240,13 @@ BOOST_AUTO_TEST_CASE(merkle_block_2)\n     BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n-    pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n+    std::pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n-    vector<uint256> vMatched;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatched;\n+    std::vector<unsigned int> vIndex;\n     BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n@@ -297,13 +295,13 @@ BOOST_AUTO_TEST_CASE(merkle_block_2_with_update_none)\n     BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n-    pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n+    std::pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xe980fe9f792d014e73b95203dc1335c5f9ce19ac537a419e6df5b47aecb93b70\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n-    vector<uint256> vMatched;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatched;\n+    std::vector<unsigned int> vIndex;\n     BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n@@ -353,8 +351,8 @@ BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x63194f18be0af63f2c6bc9dc0f777cbefed3d9415c4af83f3ee3a3d669c00cb5\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n-    vector<uint256> vMatched;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatched;\n+    std::vector<unsigned int> vIndex;\n     BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n@@ -363,8 +361,8 @@ BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n     CDataStream merkleStream(SER_NETWORK, PROTOCOL_VERSION);\n     merkleStream << merkleBlock;\n \n-    vector<unsigned char> vch = ParseHex(\"0100000079cda856b143d9db2c1caff01d1aecc8630d30625d10e8b4b8b0000000000000b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f196367291b4d4c86041b8fa45d630100000001b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f19630101\");\n-    vector<char> expected(vch.size());\n+    std::vector<unsigned char> vch = ParseHex(\"0100000079cda856b143d9db2c1caff01d1aecc8630d30625d10e8b4b8b0000000000000b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f196367291b4d4c86041b8fa45d630100000001b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f19630101\");\n+    std::vector<char> expected(vch.size());\n \n     for (unsigned int i = 0; i < vch.size(); i++)\n         expected[i] = (char)vch[i];\n@@ -388,13 +386,13 @@ BOOST_AUTO_TEST_CASE(merkle_block_4)\n     BOOST_CHECK(merkleBlock.header.GetHash() == block.GetHash());\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn.size() == 1);\n-    pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n+    std::pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x0a2a92f0bda4727d0a13eaddf4dd9ac6b5c61a1429e6b2b818f19b15df0ac154\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 6);\n \n-    vector<uint256> vMatched;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatched;\n+    std::vector<unsigned int> vIndex;\n     BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched, vIndex) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)"
      },
      {
        "sha": "86022541bdade3e2535617911615321f6d9b7e7e",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 19,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -10,13 +10,11 @@\n #include <boost/assign/std/vector.hpp> // for 'operator+=()'\n #include <boost/assert.hpp>\n #include <boost/test/unit_test.hpp>\n-                    \n-using namespace std;\n-using namespace boost::assign; // bring 'operator+=()' into scope\n-using namespace boost::filesystem;\n-         \n+\n+namespace io = boost::filesystem;\n+\n // Test if a string consists entirely of null characters\n-bool is_null_key(const vector<unsigned char>& key) {\n+bool is_null_key(const std::vector<unsigned char>& key) {\n     bool isnull = true;\n \n     for (unsigned int i = 0; i < key.size(); i++)\n@@ -32,7 +30,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n     // Perform tests both obfuscated and non-obfuscated.\n     for (int i = 0; i < 2; i++) {\n         bool obfuscate = (bool)i;\n-        path ph = temp_directory_path() / unique_path();\n+        io::path ph = io::temp_directory_path() / io::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n         char key = 'k';\n         uint256 in = GetRandHash();\n@@ -53,7 +51,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n     // Perform tests both obfuscated and non-obfuscated.\n     for (int i = 0; i < 2; i++) {\n         bool obfuscate = (bool)i;\n-        path ph = temp_directory_path() / unique_path();\n+        io::path ph = io::temp_directory_path() / io::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n         char key = 'i';\n@@ -90,7 +88,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n     // Perform tests both obfuscated and non-obfuscated.\n     for (int i = 0; i < 2; i++) {\n         bool obfuscate = (bool)i;\n-        path ph = temp_directory_path() / unique_path();\n+        io::path ph = io::temp_directory_path() / io::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n         // The two keys are intentionally chosen for ordering\n@@ -129,8 +127,8 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n // Test that we do not obfuscation if there is existing data.\n BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n {\n-    // We're going to share this path between two wrappers\n-    path ph = temp_directory_path() / unique_path();\n+    // We're going to share this io::path between two wrappers\n+    io::path ph = io::temp_directory_path() / io::unique_path();\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n@@ -170,8 +168,8 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n // Ensure that we start obfuscating during a reindex.\n BOOST_AUTO_TEST_CASE(existing_data_reindex)\n {\n-    // We're going to share this path between two wrappers\n-    path ph = temp_directory_path() / unique_path();\n+    // We're going to share this io::path between two wrappers\n+    io::path ph = io::temp_directory_path() / io::unique_path();\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n@@ -206,7 +204,7 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n \n BOOST_AUTO_TEST_CASE(iterator_ordering)\n {\n-    path ph = temp_directory_path() / unique_path();\n+    io::path ph = io::temp_directory_path() / io::unique_path();\n     CDBWrapper dbw(ph, (1 << 20), true, false, false);\n     for (int x=0x00; x<256; ++x) {\n         uint8_t key = x;\n@@ -241,11 +239,11 @@ BOOST_AUTO_TEST_CASE(iterator_ordering)\n struct StringContentsSerializer {\n     // Used to make two serialized objects the same while letting them have a different lengths\n     // This is a terrible idea\n-    string str;\n+    std::string str;\n     StringContentsSerializer() {}\n-    StringContentsSerializer(const string& inp) : str(inp) {}\n+    StringContentsSerializer(const std::string& inp) : str(inp) {}\n \n-    StringContentsSerializer& operator+=(const string& s) {\n+    StringContentsSerializer& operator+=(const std::string& s) {\n         str += s;\n         return *this;\n     }\n@@ -277,7 +275,7 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n {\n     char buf[10];\n \n-    path ph = temp_directory_path() / unique_path();\n+    io::path ph = io::temp_directory_path() / io::unique_path();\n     CDBWrapper dbw(ph, (1 << 20), true, false, false);\n     for (int x=0x00; x<10; ++x) {\n         for (int y = 0; y < 10; y++) {\n@@ -303,7 +301,7 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n         for (int x=seek_start; x<10; ++x) {\n             for (int y = 0; y < 10; y++) {\n                 sprintf(buf, \"%d\", x);\n-                string exp_key(buf);\n+                std::string exp_key(buf);\n                 for (int z = 0; z < y; z++)\n                     exp_key += exp_key;\n                 StringContentsSerializer key;"
      },
      {
        "sha": "13dd7485164c7b463a29eea7db30d440e5baff1a",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -10,8 +10,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(hash_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(murmurhash3)"
      },
      {
        "sha": "40a7fdf11d0537b88a74616043e4c9c497db2237",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 13,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -16,19 +16,17 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n-static const string strSecret1     (\"5HxWvvfubhXpYYpS3tJkw6fq9jE9j18THftkZjHHfmFiWtmAbrj\");\n-static const string strSecret2     (\"5KC4ejrDjv152FGwP386VD1i2NYc5KkfSMyv1nGy1VGDxGHqVY3\");\n-static const string strSecret1C    (\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n-static const string strSecret2C    (\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n+static const std::string strSecret1     (\"5HxWvvfubhXpYYpS3tJkw6fq9jE9j18THftkZjHHfmFiWtmAbrj\");\n+static const std::string strSecret2     (\"5KC4ejrDjv152FGwP386VD1i2NYc5KkfSMyv1nGy1VGDxGHqVY3\");\n+static const std::string strSecret1C    (\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n+static const std::string strSecret2C    (\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n static const CBitcoinAddress addr1 (\"1QFqqMUD55ZV3PJEJZtaKCsQmjLT6JkjvJ\");\n static const CBitcoinAddress addr2 (\"1F5y5E5FMc5YzdJtB9hLaUe43GDxEKXENJ\");\n static const CBitcoinAddress addr1C(\"1NoJrossxPBKfCHuJXT4HadJrXRE9Fxiqs\");\n static const CBitcoinAddress addr2C(\"1CRj2HyM1CXWzHAXLQtiGLyggNT9WQqsDs\");\n \n \n-static const string strAddressBad(\"1HV9Lc3sNHZxwj4Zk6fB38tEmBryq2cBiF\");\n+static const std::string strAddressBad(\"1HV9Lc3sNHZxwj4Zk6fB38tEmBryq2cBiF\");\n \n \n #ifdef KEY_TESTS_DUMPINFO\n@@ -37,7 +35,7 @@ void dumpKeyInfo(uint256 privkey)\n     CKey key;\n     key.resize(32);\n     memcpy(&secret[0], &privkey, 32);\n-    vector<unsigned char> sec;\n+    std::vector<unsigned char> sec;\n     sec.resize(32);\n     memcpy(&sec[0], &secret[0], 32);\n     printf(\"  * secret (hex): %s\\n\", HexStr(sec).c_str());\n@@ -51,7 +49,7 @@ void dumpKeyInfo(uint256 privkey)\n         printf(\"    * secret (base58): %s\\n\", bsecret.ToString().c_str());\n         CKey key;\n         key.SetSecret(secret, fCompressed);\n-        vector<unsigned char> vchPubKey = key.GetPubKey();\n+        std::vector<unsigned char> vchPubKey = key.GetPubKey();\n         printf(\"    * pubkey (hex): %s\\n\", HexStr(vchPubKey).c_str());\n         printf(\"    * address (base58): %s\\n\", CBitcoinAddress(vchPubKey).ToString().c_str());\n     }\n@@ -111,12 +109,12 @@ BOOST_AUTO_TEST_CASE(key_test1)\n \n     for (int n=0; n<16; n++)\n     {\n-        string strMsg = strprintf(\"Very secret message %i: 11\", n);\n+        std::string strMsg = strprintf(\"Very secret message %i: 11\", n);\n         uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());\n \n         // normal signatures\n \n-        vector<unsigned char> sign1, sign2, sign1C, sign2C;\n+        std::vector<unsigned char> sign1, sign2, sign1C, sign2C;\n \n         BOOST_CHECK(key1.Sign (hashMsg, sign1));\n         BOOST_CHECK(key2.Sign (hashMsg, sign2));\n@@ -145,7 +143,7 @@ BOOST_AUTO_TEST_CASE(key_test1)\n \n         // compact signatures (with key recovery)\n \n-        vector<unsigned char> csign1, csign2, csign1C, csign2C;\n+        std::vector<unsigned char> csign1, csign2, csign1C, csign2C;\n \n         BOOST_CHECK(key1.SignCompact (hashMsg, csign1));\n         BOOST_CHECK(key2.SignCompact (hashMsg, csign2));\n@@ -168,7 +166,7 @@ BOOST_AUTO_TEST_CASE(key_test1)\n     // test deterministic signing\n \n     std::vector<unsigned char> detsig, detsigc;\n-    string strMsg = \"Very deterministic message\";\n+    std::string strMsg = \"Very deterministic message\";\n     uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());\n     BOOST_CHECK(key1.Sign(hashMsg, detsig));\n     BOOST_CHECK(key1C.Sign(hashMsg, detsigc));"
      },
      {
        "sha": "34d7fc9d11d770298d372bd7d0faa920b7de6c2b",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -17,22 +17,20 @@\n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n \n CScript\n-sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction, int whichIn)\n+sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\n {\n     uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround\n     BOOST_FOREACH(const CKey &key, keys)\n     {\n-        vector<unsigned char> vchSig;\n+        std::vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         result << vchSig;\n@@ -75,7 +73,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         txTo[i].vout[0].nValue = 1;\n     }\n \n-    vector<CKey> keys;\n+    std::vector<CKey> keys;\n     CScript s;\n \n     // Test a AND b:\n@@ -200,7 +198,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     partialkeystore.AddKey(key[0]);\n \n     {\n-        vector<valtype> solutions;\n+        std::vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n@@ -213,7 +211,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n         BOOST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n-        vector<valtype> solutions;\n+        std::vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_DUP << OP_HASH160 << ToByteVector(key[0].GetPubKey().GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n@@ -226,7 +224,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n         BOOST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n-        vector<valtype> solutions;\n+        std::vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n@@ -239,13 +237,13 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n         BOOST_CHECK(!IsMine(partialkeystore, s));\n     }\n     {\n-        vector<valtype> solutions;\n+        std::vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n         BOOST_CHECK(Solver(s, whichType, solutions));\n         BOOST_CHECK_EQUAL(solutions.size(), 4U);\n-        vector<CTxDestination> addrs;\n+        std::vector<CTxDestination> addrs;\n         int nRequired;\n         BOOST_CHECK(ExtractDestinations(s, whichType, addrs, nRequired));\n         BOOST_CHECK(addrs[0] == keyaddr[0]);\n@@ -256,7 +254,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n         BOOST_CHECK(!IsMine(partialkeystore, s));\n     }\n     {\n-        vector<valtype> solutions;\n+        std::vector<valtype> solutions;\n         txnouttype whichType;\n         CScript s;\n         s << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;"
      },
      {
        "sha": "0bd7869f32fc40608189c685d76966a3e9271d7b",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -12,8 +12,6 @@\n #include \"netbase.h\"\n #include \"chainparams.h\"\n \n-using namespace std;\n-\n class CAddrManSerializationMock : public CAddrMan\n {\n public:\n@@ -68,7 +66,7 @@ CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n     ssPeersIn << FLATDATA(Params().MessageStart());\n     ssPeersIn << _addrman;\n     std::string str = ssPeersIn.str();\n-    vector<unsigned char> vchData(str.begin(), str.end());\n+    std::vector<unsigned char> vchData(str.begin(), str.end());\n     return CDataStream(vchData, SER_DISK, CLIENT_VERSION);\n }\n "
      },
      {
        "sha": "b4dff75a0912fba3b37a2f615acb7726347c8701",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -10,8 +10,6 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(netbase_tests, BasicTestingSetup)\n \n static CNetAddr ResolveIP(const char* ip)\n@@ -64,9 +62,9 @@ BOOST_AUTO_TEST_CASE(netbase_properties)\n \n }\n \n-bool static TestSplitHost(string test, string host, int port)\n+bool static TestSplitHost(std::string test, std::string host, int port)\n {\n-    string hostOut;\n+    std::string hostOut;\n     int portOut = -1;\n     SplitHostPort(test, portOut, hostOut);\n     return hostOut == host && port == portOut;\n@@ -91,7 +89,7 @@ BOOST_AUTO_TEST_CASE(netbase_splithost)\n     BOOST_CHECK(TestSplitHost(\"\", \"\", -1));\n }\n \n-bool static TestParse(string src, string canon)\n+bool static TestParse(std::string src, std::string canon)\n {\n     CService addr(LookupNumeric(src.c_str(), 65535));\n     return canon == addr.ToString();"
      },
      {
        "sha": "c5796277b012db6ffd60c0548cd832c0ac264d1c",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -17,8 +17,6 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n class CPartialMerkleTreeTester : public CPartialMerkleTree\n {\n public:"
      },
      {
        "sha": "4ca6f1caf0a25588b831701d7581b1e2a68ffcce",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -11,8 +11,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(pow_tests, BasicTestingSetup)\n \n /* Test calculation of next difficulty target with no constraints applying */"
      },
      {
        "sha": "fd86ba5d80de52277ed6958f3645360324886fed",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 70,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -16,13 +16,11 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n-UniValue CallRPC(string args)\n+UniValue CallRPC(std::string args)\n {\n-    vector<string> vArgs;\n+    std::vector<std::string> vArgs;\n     boost::split(vArgs, args, boost::is_any_of(\" \\t\"));\n-    string strMethod = vArgs[0];\n+    std::string strMethod = vArgs[0];\n     vArgs.erase(vArgs.begin());\n     JSONRPCRequest request;\n     request.strMethod = strMethod;\n@@ -35,7 +33,7 @@ UniValue CallRPC(string args)\n         return result;\n     }\n     catch (const UniValue& objError) {\n-        throw runtime_error(find_value(objError, \"message\").get_str());\n+        throw std::runtime_error(find_value(objError, \"message\").get_str());\n     }\n }\n \n@@ -47,41 +45,41 @@ BOOST_AUTO_TEST_CASE(rpc_rawparams)\n     // Test raw transaction API argument handling\n     UniValue r;\n \n-    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction not_hex\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed not_int\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction not_hex\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"getrawtransaction a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed not_int\"), std::runtime_error);\n \n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction null null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction not_array\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] []\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction {} {}\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction null null\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction not_array\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] []\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction {} {}\"), std::runtime_error);\n     BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [] {}\"));\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] {} extra\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] {} extra\"), std::runtime_error);\n \n-    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction DEADBEEF\"), runtime_error);\n-    string rawtx = \"0100000001a15d57094aa7a21a28cb20b59aab8fc7d1149a3bdbcddba9c622e4f5f6a99ece010000006c493046022100f93bb0e7d8db7bd46e40132d1f8242026e045f03a0efe71bbb8e3f475e970d790221009337cd7f1f929f00cc6ff01f03729b069a7c21b59b1736ddfee5db5946c5da8c0121033b9b137ee87d5a812d6f506efdd37f0affa7ffc310711c06c7f3e097c9447c52ffffffff0100e1f505000000001976a9140389035a9225b3839e2bbf32d826a1e222031fd888ac00000000\";\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx));\n+    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction null\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"decoderawtransaction DEADBEEF\"), std::runtime_error);\n+    std::string rawtx = \"0100000001a15d57094aa7a21a28cb20b59aab8fc7d1149a3bdbcddba9c622e4f5f6a99ece010000006c493046022100f93bb0e7d8db7bd46e40132d1f8242026e045f03a0efe71bbb8e3f475e970d790221009337cd7f1f929f00cc6ff01f03729b069a7c21b59b1736ddfee5db5946c5da8c0121033b9b137ee87d5a812d6f506efdd37f0affa7ffc310711c06c7f3e097c9447c52ffffffff0100e1f505000000001976a9140389035a9225b3839e2bbf32d826a1e222031fd888ac00000000\";\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"decoderawtransaction \")+rawtx));\n     BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"size\").get_int(), 193);\n     BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"version\").get_int(), 1);\n     BOOST_CHECK_EQUAL(find_value(r.get_obj(), \"locktime\").get_int(), 0);\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"decoderawtransaction \")+rawtx+\" extra\"), runtime_error);\n+    BOOST_CHECK_THROW(r = CallRPC(std::string(\"decoderawtransaction \")+rawtx+\" extra\"), std::runtime_error);\n \n-    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction ff00\"), runtime_error);\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx));\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null NONE|ANYONECANPAY\"));\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" [] [] NONE|ANYONECANPAY\"));\n-    BOOST_CHECK_THROW(CallRPC(string(\"signrawtransaction \")+rawtx+\" null null badenum\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction null\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"signrawtransaction ff00\"), std::runtime_error);\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"signrawtransaction \")+rawtx));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"signrawtransaction \")+rawtx+\" null null NONE|ANYONECANPAY\"));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"signrawtransaction \")+rawtx+\" [] [] NONE|ANYONECANPAY\"));\n+    BOOST_CHECK_THROW(CallRPC(std::string(\"signrawtransaction \")+rawtx+\" null null badenum\"), std::runtime_error);\n \n     // Only check failure cases for sendrawtransaction, there's no network to send to...\n-    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction null\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction DEADBEEF\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(string(\"sendrawtransaction \")+rawtx+\" extra\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction null\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"sendrawtransaction DEADBEEF\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(std::string(\"sendrawtransaction \")+rawtx+\" extra\"), std::runtime_error);\n }\n \n BOOST_AUTO_TEST_CASE(rpc_togglenetwork)\n@@ -110,18 +108,18 @@ BOOST_AUTO_TEST_CASE(rpc_rawsign)\n {\n     UniValue r;\n     // input is a 1-of-2 multisig (so is output):\n-    string prevout =\n+    std::string prevout =\n       \"[{\\\"txid\\\":\\\"b4cc287e58f87cdae59417329f710f3ecd75a4ee1d2872b7248f50977c8493f3\\\",\"\n       \"\\\"vout\\\":1,\\\"scriptPubKey\\\":\\\"a914b10c9df5f7edf436c697f02f1efdba4cf399615187\\\",\"\n       \"\\\"redeemScript\\\":\\\"512103debedc17b3df2badbcdd86d5feb4562b86fe182e5998abd8bcd4f122c6155b1b21027e940bb73ab8732bfdf7f9216ecefca5b94d6df834e77e108f68e66f126044c052ae\\\"}]\";\n-    r = CallRPC(string(\"createrawtransaction \")+prevout+\" \"+\n+    r = CallRPC(std::string(\"createrawtransaction \")+prevout+\" \"+\n       \"{\\\"3HqAe9LtNBjnsfM4CyYaWTnvCaUYT7v4oZ\\\":11}\");\n-    string notsigned = r.get_str();\n-    string privkey1 = \"\\\"KzsXybp9jX64P5ekX1KUxRQ79Jht9uzW7LorgwE65i5rWACL6LQe\\\"\";\n-    string privkey2 = \"\\\"Kyhdf5LuKTRx4ge69ybABsiUAWjVRK4XGxAKk2FQLp2HjGMy87Z4\\\"\";\n-    r = CallRPC(string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[]\");\n+    std::string notsigned = r.get_str();\n+    std::string privkey1 = \"\\\"KzsXybp9jX64P5ekX1KUxRQ79Jht9uzW7LorgwE65i5rWACL6LQe\\\"\";\n+    std::string privkey2 = \"\\\"Kyhdf5LuKTRx4ge69ybABsiUAWjVRK4XGxAKk2FQLp2HjGMy87Z4\\\"\";\n+    r = CallRPC(std::string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[]\");\n     BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == false);\n-    r = CallRPC(string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[\"+privkey1+\",\"+privkey2+\"]\");\n+    r = CallRPC(std::string(\"signrawtransaction \")+notsigned+\" \"+prevout+\" \"+\"[\"+privkey1+\",\"+privkey2+\"]\");\n     BOOST_CHECK(find_value(r.get_obj(), \"complete\").get_bool() == true);\n }\n \n@@ -133,11 +131,11 @@ BOOST_AUTO_TEST_CASE(rpc_createraw_op_return)\n     BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"68656c6c6f776f726c64\\\",\\\"data\\\":\\\"68656c6c6f776f726c64\\\"}\"));\n \n     // Key not \"data\" (bad address)\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"somedata\\\":\\\"68656c6c6f776f726c64\\\"}\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"somedata\\\":\\\"68656c6c6f776f726c64\\\"}\"), std::runtime_error);\n \n     // Bad hex encoding of data output\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345\\\"}\"), runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345g\\\"}\"), runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345\\\"}\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"12345g\\\"}\"), std::runtime_error);\n \n     // Data 81 bytes long\n     BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [{\\\"txid\\\":\\\"a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed\\\",\\\"vout\\\":0}] {\\\"data\\\":\\\"010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\\\"}\"));\n@@ -241,34 +239,34 @@ BOOST_AUTO_TEST_CASE(json_parse_errors)\n \n BOOST_AUTO_TEST_CASE(rpc_ban)\n {\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    \n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n+\n     UniValue r;\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0 add\")));\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.0.0:8334\")), runtime_error); //portnumber for setban not allowed\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0 add\")));\n+    BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.0.0:8334\")), std::runtime_error); //portnumber for setban not allowed\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     UniValue ar = r.get_array();\n     UniValue o1 = ar[0].get_obj();\n     UniValue adr = find_value(o1, \"address\");\n     BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/32\");\n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"setban 127.0.0.0 remove\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"setban 127.0.0.0 remove\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     BOOST_CHECK_EQUAL(ar.size(), 0);\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/24 add 1607731200 true\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/24 add 1607731200 true\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n     UniValue banned_until = find_value(o1, \"banned_until\");\n     BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n     BOOST_CHECK_EQUAL(banned_until.get_int64(), 1607731200); // absolute time check\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/24 add 200\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/24 add 200\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n@@ -279,43 +277,43 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     BOOST_CHECK(banned_until.get_int64()-now <= 200);\n \n     // must throw an exception because 127.0.0.1 is in already banned suubnet range\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.0.1 add\")), runtime_error);\n+    BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.0.1 add\")), std::runtime_error);\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"setban 127.0.0.0/24 remove\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"setban 127.0.0.0/24 remove\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     BOOST_CHECK_EQUAL(ar.size(), 0);\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 127.0.0.0/255.255.0.0 add\")));\n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban 127.0.1.1 add\")), runtime_error);\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/255.255.0.0 add\")));\n+    BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.1.1 add\")), std::runtime_error);\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     BOOST_CHECK_EQUAL(ar.size(), 0);\n \n \n-    BOOST_CHECK_THROW(r = CallRPC(string(\"setban test add\")), runtime_error); //invalid IP\n+    BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban test add\")), std::runtime_error); //invalid IP\n \n     //IPv6 tests\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban FE80:0000:0000:0000:0202:B3FF:FE1E:8329 add\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban FE80:0000:0000:0000:0202:B3FF:FE1E:8329 add\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n     BOOST_CHECK_EQUAL(adr.get_str(), \"fe80::202:b3ff:fe1e:8329/128\");\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 2001:db8::/ffff:fffc:0:0:0:0:0:0 add\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 2001:db8::/ffff:fffc:0:0:0:0:0:0 add\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n     BOOST_CHECK_EQUAL(adr.get_str(), \"2001:db8::/30\");\n \n-    BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"setban 2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/128 add\")));\n-    BOOST_CHECK_NO_THROW(r = CallRPC(string(\"listbanned\")));\n+    BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/128 add\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");"
      },
      {
        "sha": "ce8071e4e9e4e07f19c97093516a5de0b4276740",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -17,8 +17,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n // Helpers:\n static std::vector<unsigned char>\n Serialize(const CScript& s)\n@@ -80,7 +78,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     }\n \n     CMutableTransaction txFrom;  // Funding transaction:\n-    string reason;\n+    std::string reason;\n     txFrom.vout.resize(8);\n     for (int i = 0; i < 4; i++)\n     {\n@@ -178,7 +176,7 @@ BOOST_AUTO_TEST_CASE(set)\n     }\n \n     CMutableTransaction txFrom;  // Funding transaction:\n-    string reason;\n+    std::string reason;\n     txFrom.vout.resize(4);\n     for (int i = 0; i < 4; i++)\n     {\n@@ -263,7 +261,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     CCoinsViewCache coins(&coinsDummy);\n     CBasicKeyStore keystore;\n     CKey key[6];\n-    vector<CPubKey> keys;\n+    std::vector<CPubKey> keys;\n     for (int i = 0; i < 6; i++)\n     {\n         key[i].MakeNewKey(true);\n@@ -335,8 +333,8 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     // SignSignature doesn't know how to sign these. We're\n     // not testing validating signatures, so just create\n     // dummy signatures that DO include the correct P2SH scripts:\n-    txTo.vin[3].scriptSig << OP_11 << OP_11 << vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n-    txTo.vin[4].scriptSig << vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n+    txTo.vin[3].scriptSig << OP_11 << OP_11 << std::vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n+    txTo.vin[4].scriptSig << std::vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n \n     BOOST_CHECK(::AreInputsStandard(txTo, coins));\n     // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n@@ -349,7 +347,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd1.vin.resize(1);\n     txToNonStd1.vin[0].prevout.n = 5;\n     txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd1.vin[0].scriptSig << vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n+    txToNonStd1.vin[0].scriptSig << std::vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n \n     BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n     BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n@@ -361,7 +359,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd2.vin.resize(1);\n     txToNonStd2.vin[0].prevout.n = 6;\n     txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd2.vin[0].scriptSig << vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n+    txToNonStd2.vin[0].scriptSig << std::vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n \n     BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n     BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);"
      },
      {
        "sha": "8660a1ae8637716bf83abbe15a6ea582ed875ef7",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 21,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -29,15 +29,13 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n // Uncomment if you want to output updated JSON tests.\n // #define UPDATE_JSON_TESTS\n \n static const unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n \n-unsigned int ParseScriptFlags(string strFlags);\n-string FormatScriptFlags(unsigned int flags);\n+unsigned int ParseScriptFlags(std::string strFlags);\n+std::string FormatScriptFlags(unsigned int flags);\n \n UniValue\n read_json(const std::string& jsondata)\n@@ -801,7 +799,7 @@ BOOST_AUTO_TEST_CASE(script_build)\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0);\n         uint256 hash;\n         CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n-        vector<unsigned char> hashBytes = ToByteVector(hash);\n+        std::vector<unsigned char> hashBytes = ToByteVector(hash);\n         hashBytes.pop_back();\n         tests.push_back(TestBuilder(CScript() << OP_0 << hashBytes,\n                                     \"P2WPKH with wrong witness program length\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false\n@@ -966,7 +964,7 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n \n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n         UniValue test = tests[idx];\n-        string strTest = test.write();\n+        std::string strTest = test.write();\n         CScriptWitness witness;\n         CAmount nValue = 0;\n         unsigned int pos = 0;\n@@ -985,9 +983,9 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n             }\n             continue;\n         }\n-        string scriptSigString = test[pos++].get_str();\n+        std::string scriptSigString = test[pos++].get_str();\n         CScript scriptSig = ParseScript(scriptSigString);\n-        string scriptPubKeyString = test[pos++].get_str();\n+        std::string scriptPubKeyString = test[pos++].get_str();\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n         unsigned int scriptflags = ParseScriptFlags(test[pos++].get_str());\n         int scriptError = ParseScriptError(test[pos++].get_str());\n@@ -1006,21 +1004,21 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n \n     ScriptError err;\n-    vector<vector<unsigned char> > directStack;\n+    std::vector<std::vector<unsigned char> > directStack;\n     BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n-    vector<vector<unsigned char> > pushdata1Stack;\n+    std::vector<std::vector<unsigned char> > pushdata1Stack;\n     BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n-    vector<vector<unsigned char> > pushdata2Stack;\n+    std::vector<std::vector<unsigned char> > pushdata2Stack;\n     BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n-    vector<vector<unsigned char> > pushdata4Stack;\n+    std::vector<std::vector<unsigned char> > pushdata4Stack;\n     BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n@@ -1043,7 +1041,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     result << OP_0;\n     BOOST_FOREACH(const CKey &key, keys)\n     {\n-        vector<unsigned char> vchSig;\n+        std::vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         result << vchSig;\n@@ -1162,8 +1160,8 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     // Test the CombineSignatures function\n     CAmount amount = 0;\n     CBasicKeyStore keystore;\n-    vector<CKey> keys;\n-    vector<CPubKey> pubkeys;\n+    std::vector<CKey> keys;\n+    std::vector<CPubKey> pubkeys;\n     for (int i = 0; i < 3; i++)\n     {\n         CKey key;\n@@ -1224,15 +1222,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     BOOST_CHECK(combined.scriptSig == scriptSig);\n \n     // A couple of partially-signed versions:\n-    vector<unsigned char> sig1;\n+    std::vector<unsigned char> sig1;\n     uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n     BOOST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n-    vector<unsigned char> sig2;\n+    std::vector<unsigned char> sig2;\n     uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n     BOOST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n-    vector<unsigned char> sig3;\n+    std::vector<unsigned char> sig3;\n     uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n     BOOST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n@@ -1306,9 +1304,9 @@ BOOST_AUTO_TEST_CASE(script_GetScriptAsm)\n     BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2));\n     BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY));\n \n-    string derSig(\"304502207fa7a6d1e0ee81132a269ad84e68d695483745cde8b541e3bf630749894e342a022100c1f7ab20e13e22fb95281a870f3dcf38d782e53023ee313d741ad0cfbc0c5090\");\n-    string pubKey(\"03b0da749730dc9b4b1f4a14d6902877a92541f5368778853d9c4a0cb7802dcfb2\");\n-    vector<unsigned char> vchPubKey = ToByteVector(ParseHex(pubKey));\n+    std::string derSig(\"304502207fa7a6d1e0ee81132a269ad84e68d695483745cde8b541e3bf630749894e342a022100c1f7ab20e13e22fb95281a870f3dcf38d782e53023ee313d741ad0cfbc0c5090\");\n+    std::string pubKey(\"03b0da749730dc9b4b1f4a14d6902877a92541f5368778853d9c4a0cb7802dcfb2\");\n+    std::vector<unsigned char> vchPubKey = ToByteVector(ParseHex(pubKey));\n \n     BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey, true));\n     BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey, true));"
      },
      {
        "sha": "447428a836af4d9a0bbe46ef4cd2d414ac19694e",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -10,7 +10,6 @@\n #include <stdint.h>\n \n #include <boost/test/unit_test.hpp>\n-using namespace std;\n \n BOOST_FIXTURE_TEST_SUITE(serialize_tests, BasicTestingSetup)\n \n@@ -227,7 +226,7 @@ BOOST_AUTO_TEST_CASE(varints_bitpatterns)\n BOOST_AUTO_TEST_CASE(compactsize)\n {\n     CDataStream ss(SER_DISK, 0);\n-    vector<char>::size_type i, j;\n+    std::vector<char>::size_type i, j;\n \n     for (i = 1; i <= MAX_SIZE; i *= 2)\n     {\n@@ -260,7 +259,7 @@ BOOST_AUTO_TEST_CASE(noncanonical)\n     // Write some non-canonical CompactSize encodings, and\n     // make sure an exception is thrown when read back.\n     CDataStream ss(SER_DISK, 0);\n-    vector<char>::size_type n;\n+    std::vector<char>::size_type n;\n \n     // zero encoded with three bytes:\n     ss.write(\"\\xfd\\x00\\x00\", 3);"
      },
      {
        "sha": "b7d762b80d3ef0f1eeee4e61b081297c811b72e9",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -15,8 +15,6 @@\n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n // Helpers:\n static std::vector<unsigned char>\n Serialize(const CScript& s)\n@@ -163,8 +161,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         CScript scriptSig = CScript();\n         CTxInWitness witness;\n         CScriptWitness scriptWitness;\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n         witness.scriptWitness = scriptWitness;\n \n \n@@ -195,8 +193,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         scriptSig = CScript() << ToByteVector(scriptSig);\n         CTxInWitness witness;\n         CScriptWitness scriptWitness;\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n         witness.scriptWitness = scriptWitness;\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n@@ -211,9 +209,9 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         CScript scriptSig = CScript();\n         CTxInWitness witness;\n         CScriptWitness scriptWitness;\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n-        scriptWitness.stack.push_back(vector<unsigned char>(witnessScript.begin(), witnessScript.end()));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(witnessScript.begin(), witnessScript.end()));\n         witness.scriptWitness = scriptWitness;\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n@@ -230,9 +228,9 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         CScript scriptSig = CScript() << ToByteVector(redeemScript);\n         CTxInWitness witness;\n         CScriptWitness scriptWitness;\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n-        scriptWitness.stack.push_back(vector<unsigned char>(0));\n-        scriptWitness.stack.push_back(vector<unsigned char>(witnessScript.begin(), witnessScript.end()));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(std::vector<unsigned char>(witnessScript.begin(), witnessScript.end()));\n         witness.scriptWitness = scriptWitness;\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);"
      },
      {
        "sha": "cafed7616f5ede878f6e41270ebaea4315c50706",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -9,8 +9,7 @@\n #include <boost/assign/std/vector.hpp> // for 'operator+=()'\n #include <boost/assert.hpp>\n #include <boost/test/unit_test.hpp>\n-                    \n-using namespace std;\n+\n using namespace boost::assign; // bring 'operator+=()' into scope\n \n BOOST_FIXTURE_TEST_SUITE(streams_tests, BasicTestingSetup)"
      },
      {
        "sha": "34863fd9d06fda3574fe15dcaa3e83aea6763400",
        "filename": "src/test/timedata_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/timedata_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/timedata_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/timedata_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -7,8 +7,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(timedata_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(util_MedianFilter)"
      },
      {
        "sha": "bfc7161f5d437aefd9ef38a299202c45ebf1de44",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 41,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -32,42 +32,40 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n-typedef vector<unsigned char> valtype;\n+typedef std::vector<unsigned char> valtype;\n \n // In script_tests.cpp\n extern UniValue read_json(const std::string& jsondata);\n \n-static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n-    (string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)\n-    (string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)\n-    (string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)\n-    (string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)\n-    (string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)\n-    (string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)\n-    (string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)\n-    (string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n-    (string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n-    (string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n-    (string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF)\n-    (string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL)\n-    (string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n-    (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n-    (string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n-    (string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n-    (string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n-\n-unsigned int ParseScriptFlags(string strFlags)\n+static std::map<std::string, unsigned int> mapFlagNames = boost::assign::map_list_of\n+    (std::string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)\n+    (std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)\n+    (std::string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)\n+    (std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)\n+    (std::string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)\n+    (std::string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)\n+    (std::string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)\n+    (std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n+    (std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n+    (std::string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n+    (std::string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF)\n+    (std::string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL)\n+    (std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n+    (std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n+    (std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n+    (std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n+    (std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n+\n+unsigned int ParseScriptFlags(std::string strFlags)\n {\n     if (strFlags.empty()) {\n         return 0;\n     }\n     unsigned int flags = 0;\n-    vector<string> words;\n+    std::vector<std::string> words;\n     boost::algorithm::split(words, strFlags, boost::algorithm::is_any_of(\",\"));\n \n-    BOOST_FOREACH(string word, words)\n+    BOOST_FOREACH(std::string word, words)\n     {\n         if (!mapFlagNames.count(word))\n             BOOST_ERROR(\"Bad test: unknown verification flag '\" << word << \"'\");\n@@ -77,13 +75,13 @@ unsigned int ParseScriptFlags(string strFlags)\n     return flags;\n }\n \n-string FormatScriptFlags(unsigned int flags)\n+std::string FormatScriptFlags(unsigned int flags)\n {\n     if (flags == 0) {\n         return \"\";\n     }\n-    string ret;\n-    std::map<string, unsigned int>::const_iterator it = mapFlagNames.begin();\n+    std::string ret;\n+    std::map<std::string, unsigned int>::const_iterator it = mapFlagNames.begin();\n     while (it != mapFlagNames.end()) {\n         if (flags & it->second) {\n             ret += it->first + \",\";\n@@ -109,7 +107,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n     ScriptError err;\n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n         UniValue test = tests[idx];\n-        string strTest = test.write();\n+        std::string strTest = test.write();\n         if (test[0].isArray())\n         {\n             if (test.size() != 3 || !test[1].isStr() || !test[2].isStr())\n@@ -118,8 +116,8 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 continue;\n             }\n \n-            map<COutPoint, CScript> mapprevOutScriptPubKeys;\n-            map<COutPoint, int64_t> mapprevOutValues;\n+            std::map<COutPoint, CScript> mapprevOutScriptPubKeys;\n+            std::map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n \t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n@@ -148,7 +146,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 continue;\n             }\n \n-            string transaction = test[1].get_str();\n+            std::string transaction = test[1].get_str();\n             CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\n             CTransaction tx(deserialize, stream);\n \n@@ -194,7 +192,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n     ScriptError err;\n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n         UniValue test = tests[idx];\n-        string strTest = test.write();\n+        std::string strTest = test.write();\n         if (test[0].isArray())\n         {\n             if (test.size() != 3 || !test[1].isStr() || !test[2].isStr())\n@@ -203,8 +201,8 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                 continue;\n             }\n \n-            map<COutPoint, CScript> mapprevOutScriptPubKeys;\n-            map<COutPoint, int64_t> mapprevOutValues;\n+            std::map<COutPoint, CScript> mapprevOutScriptPubKeys;\n+            std::map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n \t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n@@ -233,7 +231,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                 continue;\n             }\n \n-            string transaction = test[1].get_str();\n+            std::string transaction = test[1].get_str();\n             CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION );\n             CTransaction tx(deserialize, stream);\n \n@@ -268,7 +266,7 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n {\n     // Random real transaction (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n     unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n-    vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n+    std::vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n     CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n     CMutableTransaction tx;\n     stream >> tx;\n@@ -399,7 +397,7 @@ void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& inp\n     assert(ret == success);\n }\n \n-static CScript PushAll(const vector<valtype>& values)\n+static CScript PushAll(const std::vector<valtype>& values)\n {\n     CScript result;\n     BOOST_FOREACH(const valtype& v, values) {\n@@ -416,7 +414,7 @@ static CScript PushAll(const vector<valtype>& values)\n \n void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n {\n-    vector<valtype> stack;\n+    std::vector<valtype> stack;\n     EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n     assert(stack.size() > 0);\n     stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n@@ -434,7 +432,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     CKeyID hash = key.GetPubKey().GetID();\n     CScript scriptPubKey = CScript() << OP_0 << std::vector<unsigned char>(hash.begin(), hash.end());\n \n-    vector<int> sigHashes;\n+    std::vector<int> sigHashes;\n     sigHashes.push_back(SIGHASH_NONE | SIGHASH_ANYONECANPAY);\n     sigHashes.push_back(SIGHASH_SINGLE | SIGHASH_ANYONECANPAY);\n     sigHashes.push_back(SIGHASH_ALL | SIGHASH_ANYONECANPAY);\n@@ -697,7 +695,7 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     key.MakeNewKey(true);\n     t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n \n-    string reason;\n+    std::string reason;\n     BOOST_CHECK(IsStandardTx(t, reason));\n \n     // Check dust with default relay fee:"
      },
      {
        "sha": "2c20b14ea0d858a109194b5d405a549a15e75858",
        "filename": "src/test/univalue_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 20,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/univalue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/univalue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/univalue_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -12,8 +12,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(univalue_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(univalue_constructor)\n@@ -53,7 +51,7 @@ BOOST_AUTO_TEST_CASE(univalue_constructor)\n     BOOST_CHECK(v7.isNum());\n     BOOST_CHECK_EQUAL(v7.getValStr(), \"-7.21\");\n \n-    string vs(\"yawn\");\n+    std::string vs(\"yawn\");\n     UniValue v8(vs);\n     BOOST_CHECK(v8.isStr());\n     BOOST_CHECK_EQUAL(v8.getValStr(), \"yawn\");\n@@ -69,41 +67,41 @@ BOOST_AUTO_TEST_CASE(univalue_typecheck)\n     UniValue v1;\n     BOOST_CHECK(v1.setNumStr(\"1\"));\n     BOOST_CHECK(v1.isNum());\n-    BOOST_CHECK_THROW(v1.get_bool(), runtime_error);\n+    BOOST_CHECK_THROW(v1.get_bool(), std::runtime_error);\n \n     UniValue v2;\n     BOOST_CHECK(v2.setBool(true));\n     BOOST_CHECK_EQUAL(v2.get_bool(), true);\n-    BOOST_CHECK_THROW(v2.get_int(), runtime_error);\n+    BOOST_CHECK_THROW(v2.get_int(), std::runtime_error);\n \n     UniValue v3;\n     BOOST_CHECK(v3.setNumStr(\"32482348723847471234\"));\n-    BOOST_CHECK_THROW(v3.get_int64(), runtime_error);\n+    BOOST_CHECK_THROW(v3.get_int64(), std::runtime_error);\n     BOOST_CHECK(v3.setNumStr(\"1000\"));\n     BOOST_CHECK_EQUAL(v3.get_int64(), 1000);\n \n     UniValue v4;\n     BOOST_CHECK(v4.setNumStr(\"2147483648\"));\n     BOOST_CHECK_EQUAL(v4.get_int64(), 2147483648);\n-    BOOST_CHECK_THROW(v4.get_int(), runtime_error);\n+    BOOST_CHECK_THROW(v4.get_int(), std::runtime_error);\n     BOOST_CHECK(v4.setNumStr(\"1000\"));\n     BOOST_CHECK_EQUAL(v4.get_int(), 1000);\n-    BOOST_CHECK_THROW(v4.get_str(), runtime_error);\n+    BOOST_CHECK_THROW(v4.get_str(), std::runtime_error);\n     BOOST_CHECK_EQUAL(v4.get_real(), 1000);\n-    BOOST_CHECK_THROW(v4.get_array(), runtime_error);\n-    BOOST_CHECK_THROW(v4.getKeys(), runtime_error);\n-    BOOST_CHECK_THROW(v4.getValues(), runtime_error);\n-    BOOST_CHECK_THROW(v4.get_obj(), runtime_error);\n+    BOOST_CHECK_THROW(v4.get_array(), std::runtime_error);\n+    BOOST_CHECK_THROW(v4.getKeys(), std::runtime_error);\n+    BOOST_CHECK_THROW(v4.getValues(), std::runtime_error);\n+    BOOST_CHECK_THROW(v4.get_obj(), std::runtime_error);\n \n     UniValue v5;\n     BOOST_CHECK(v5.read(\"[true, 10]\"));\n     BOOST_CHECK_NO_THROW(v5.get_array());\n     std::vector<UniValue> vals = v5.getValues();\n-    BOOST_CHECK_THROW(vals[0].get_int(), runtime_error);\n+    BOOST_CHECK_THROW(vals[0].get_int(), std::runtime_error);\n     BOOST_CHECK_EQUAL(vals[0].get_bool(), true);\n \n     BOOST_CHECK_EQUAL(vals[1].get_int(), 10);\n-    BOOST_CHECK_THROW(vals[1].get_bool(), runtime_error);\n+    BOOST_CHECK_THROW(vals[1].get_bool(), std::runtime_error);\n }\n \n BOOST_AUTO_TEST_CASE(univalue_set)\n@@ -172,13 +170,13 @@ BOOST_AUTO_TEST_CASE(univalue_array)\n     UniValue v((int64_t)1023LL);\n     BOOST_CHECK(arr.push_back(v));\n \n-    string vStr(\"zippy\");\n+    std::string vStr(\"zippy\");\n     BOOST_CHECK(arr.push_back(vStr));\n \n     const char *s = \"pippy\";\n     BOOST_CHECK(arr.push_back(s));\n \n-    vector<UniValue> vec;\n+    std::vector<UniValue> vec;\n     v.setStr(\"boing\");\n     vec.push_back(v);\n \n@@ -206,7 +204,7 @@ BOOST_AUTO_TEST_CASE(univalue_array)\n BOOST_AUTO_TEST_CASE(univalue_object)\n {\n     UniValue obj(UniValue::VOBJ);\n-    string strKey, strVal;\n+    std::string strKey, strVal;\n     UniValue v;\n \n     strKey = \"age\";\n@@ -266,7 +264,7 @@ BOOST_AUTO_TEST_CASE(univalue_object)\n \n     BOOST_CHECK(!obj.exists(\"nyuknyuknyuk\"));\n \n-    map<string, UniValue::VType> objTypes;\n+    std::map<std::string, UniValue::VType> objTypes;\n     objTypes[\"age\"] = UniValue::VNUM;\n     objTypes[\"first\"] = UniValue::VSTR;\n     objTypes[\"last\"] = UniValue::VSTR;\n@@ -294,7 +292,7 @@ BOOST_AUTO_TEST_CASE(univalue_readwrite)\n     UniValue v;\n     BOOST_CHECK(v.read(json1));\n \n-    string strJson1(json1);\n+    std::string strJson1(json1);\n     BOOST_CHECK(v.read(strJson1));\n \n     BOOST_CHECK(v.isArray());\n@@ -333,4 +331,3 @@ BOOST_AUTO_TEST_CASE(univalue_readwrite)\n }\n \n BOOST_AUTO_TEST_SUITE_END()\n-"
      },
      {
        "sha": "30d6165283e0217254b5fc5dd9ad748b6b46f4c4",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -17,8 +17,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-using namespace std;\n-\n BOOST_FIXTURE_TEST_SUITE(util_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(util_criticalsection)"
      },
      {
        "sha": "9dfaeec08579cbe13aa544ef0876ad76948110e0",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -16,8 +16,6 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n static CCriticalSection cs_nTimeOffset;\n static int64_t nTimeOffset = 0;\n \n@@ -50,7 +48,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n     // Ignore duplicates\n-    static set<CNetAddr> setKnown;\n+    static std::set<CNetAddr> setKnown;\n     if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n         return;\n     if (!setKnown.insert(ip).second)\n@@ -103,7 +101,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n                 if (!fMatch)\n                 {\n                     fDone = true;\n-                    string strMessage = strprintf(_(\"Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.\"), _(PACKAGE_NAME));\n+                    std::string strMessage = strprintf(_(\"Please check that your computer's date and time are correct! If your clock is wrong, %s will not work properly.\"), _(PACKAGE_NAME));\n                     strMiscWarning = strMessage;\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n                 }\n@@ -113,7 +111,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n         BOOST_FOREACH(int64_t n, vSorted)\n             LogPrint(\"net\", \"%+d  \", n);\n         LogPrint(\"net\", \"|  \");\n-        \n+\n         LogPrint(\"net\", \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n     }\n }"
      },
      {
        "sha": "fb585434baef98d185fd50b71d55642795460b83",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -14,8 +14,6 @@\n \n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n@@ -32,11 +30,11 @@ CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(Get\n }\n \n bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    return db.Read(make_pair(DB_COINS, txid), coins);\n+    return db.Read(std::make_pair(DB_COINS, txid), coins);\n }\n \n bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n-    return db.Exists(make_pair(DB_COINS, txid));\n+    return db.Exists(std::make_pair(DB_COINS, txid));\n }\n \n uint256 CCoinsViewDB::GetBestBlock() const {\n@@ -53,9 +51,9 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             if (it->second.coins.IsPruned())\n-                batch.Erase(make_pair(DB_COINS, it->first));\n+                batch.Erase(std::make_pair(DB_COINS, it->first));\n             else\n-                batch.Write(make_pair(DB_COINS, it->first), it->second.coins);\n+                batch.Write(std::make_pair(DB_COINS, it->first), it->second.coins);\n             changed++;\n         }\n         count++;\n@@ -73,7 +71,7 @@ CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWra\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n-    return Read(make_pair(DB_BLOCK_FILES, nFile), info);\n+    return Read(std::make_pair(DB_BLOCK_FILES, nFile), info);\n }\n \n bool CBlockTreeDB::WriteReindexing(bool fReindexing) {\n@@ -139,23 +137,23 @@ void CCoinsViewDBCursor::Next()\n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<int, const CBlockFileInfo*> >::const_iterator it=fileInfo.begin(); it != fileInfo.end(); it++) {\n-        batch.Write(make_pair(DB_BLOCK_FILES, it->first), *it->second);\n+        batch.Write(std::make_pair(DB_BLOCK_FILES, it->first), *it->second);\n     }\n     batch.Write(DB_LAST_BLOCK, nLastFile);\n     for (std::vector<const CBlockIndex*>::const_iterator it=blockinfo.begin(); it != blockinfo.end(); it++) {\n-        batch.Write(make_pair(DB_BLOCK_INDEX, (*it)->GetBlockHash()), CDiskBlockIndex(*it));\n+        batch.Write(std::make_pair(DB_BLOCK_INDEX, (*it)->GetBlockHash()), CDiskBlockIndex(*it));\n     }\n     return WriteBatch(batch, true);\n }\n \n bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n-    return Read(make_pair(DB_TXINDEX, txid), pos);\n+    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n }\n \n bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n-        batch.Write(make_pair(DB_TXINDEX, it->first), it->second);\n+        batch.Write(std::make_pair(DB_TXINDEX, it->first), it->second);\n     return WriteBatch(batch);\n }\n \n@@ -175,7 +173,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());\n \n-    pcursor->Seek(make_pair(DB_BLOCK_INDEX, uint256()));\n+    pcursor->Seek(std::make_pair(DB_BLOCK_INDEX, uint256()));\n \n     // Load mapBlockIndex\n     while (pcursor->Valid()) {"
      },
      {
        "sha": "9d7f5c5c682fd856f5d0d41ffc781c402b39bdad",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -18,8 +18,6 @@\n #include \"utiltime.h\"\n #include \"version.h\"\n \n-using namespace std;\n-\n CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, double _entryPriority, unsigned int _entryHeight,\n                                  bool poolHasNoInputsOf, CAmount _inChainInputValue,\n@@ -662,7 +660,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     const int64_t nSpendHeight = GetSpendHeight(mempoolDuplicate);\n \n     LOCK(cs);\n-    list<const CTxMemPoolEntry*> waitingOnDependants;\n+    std::list<const CTxMemPoolEntry*> waitingOnDependants;\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n         checkTotal += it->GetTxSize();\n@@ -820,7 +818,7 @@ std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::Get\n     return iters;\n }\n \n-void CTxMemPool::queryHashes(vector<uint256>& vtxid)\n+void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n {\n     LOCK(cs);\n     auto iters = GetSortedDepthAndScore();\n@@ -924,7 +922,7 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n     return true;\n }\n \n-void CTxMemPool::PrioritiseTransaction(const uint256 hash, const string strHash, double dPriorityDelta, const CAmount& nFeeDelta)\n+void CTxMemPool::PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount& nFeeDelta)\n {\n     {\n         LOCK(cs);"
      },
      {
        "sha": "1e6a41b79d4eea8d0a476e1bd5e3228f40c9c737",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -97,17 +97,17 @@ namespace boost {\n \n } // namespace boost\n \n-using namespace std;\n+\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n \n-map<string, string> mapArgs;\n-map<string, vector<string> > mapMultiArgs;\n+std::map<std::string, std::string> mapArgs;\n+std::map<std::string, std::vector<std::string> > mapMultiArgs;\n bool fDebug = false;\n bool fPrintToConsole = false;\n bool fPrintToDebugLog = true;\n-string strMiscWarning;\n+std::string strMiscWarning;\n bool fLogTimestamps = DEFAULT_LOGTIMESTAMPS;\n bool fLogTimeMicros = DEFAULT_LOGTIMEMICROS;\n bool fLogIPs = DEFAULT_LOGIPS;\n@@ -189,7 +189,7 @@ static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;\n  */\n static FILE* fileout = NULL;\n static boost::mutex* mutexDebugLog = NULL;\n-static list<string> *vMsgsBeforeOpenLog;\n+static std::list<std::string> *vMsgsBeforeOpenLog;\n \n static int FileWriteStr(const std::string &str, FILE *fp)\n {\n@@ -200,7 +200,7 @@ static void DebugPrintInit()\n {\n     assert(mutexDebugLog == NULL);\n     mutexDebugLog = new boost::mutex();\n-    vMsgsBeforeOpenLog = new list<string>;\n+    vMsgsBeforeOpenLog = new std::list<std::string>;\n }\n \n void OpenDebugLog()\n@@ -235,19 +235,19 @@ bool LogAcceptCategory(const char* category)\n         // This helps prevent issues debugging global destructors,\n         // where mapMultiArgs might be deleted before another\n         // global destructor calls LogPrint()\n-        static boost::thread_specific_ptr<set<string> > ptrCategory;\n+        static boost::thread_specific_ptr<std::set<std::string> > ptrCategory;\n         if (ptrCategory.get() == NULL)\n         {\n-            const vector<string>& categories = mapMultiArgs[\"-debug\"];\n-            ptrCategory.reset(new set<string>(categories.begin(), categories.end()));\n+            const std::vector<std::string>& categories = mapMultiArgs[\"-debug\"];\n+            ptrCategory.reset(new std::set<std::string>(categories.begin(), categories.end()));\n             // thread_specific_ptr automatically deletes the set when the thread ends.\n         }\n-        const set<string>& setCategories = *ptrCategory.get();\n+        const std::set<std::string>& setCategories = *ptrCategory.get();\n \n         // if not debugging everything and not debugging specific category, LogPrint does nothing.\n-        if (setCategories.count(string(\"\")) == 0 &&\n-            setCategories.count(string(\"1\")) == 0 &&\n-            setCategories.count(string(category)) == 0)\n+        if (setCategories.count(std::string(\"\")) == 0 &&\n+            setCategories.count(std::string(\"1\")) == 0 &&\n+            setCategories.count(std::string(category)) == 0)\n             return false;\n     }\n     return true;\n@@ -260,7 +260,7 @@ bool LogAcceptCategory(const char* category)\n  */\n static std::string LogTimestampStr(const std::string &str, std::atomic_bool *fStartedNewLine)\n {\n-    string strStamped;\n+    std::string strStamped;\n \n     if (!fLogTimestamps)\n         return str;\n@@ -287,7 +287,7 @@ int LogPrintStr(const std::string &str)\n     int ret = 0; // Returns total number of characters written\n     static std::atomic_bool fStartedNewLine(true);\n \n-    string strTimestamped = LogTimestampStr(str, &fStartedNewLine);\n+    std::string strTimestamped = LogTimestampStr(str, &fStartedNewLine);\n \n     if (fPrintToConsole)\n     {\n@@ -527,21 +527,21 @@ boost::filesystem::path GetConfigFile(const std::string& confPath)\n }\n \n void ReadConfigFile(const std::string& confPath,\n-                    map<string, string>& mapSettingsRet,\n-                    map<string, vector<string> >& mapMultiSettingsRet)\n+                    std::map<std::string, std::string>& mapSettingsRet,\n+                    std::map<std::string, std::vector<std::string> >& mapMultiSettingsRet)\n {\n     boost::filesystem::ifstream streamConfig(GetConfigFile(confPath));\n     if (!streamConfig.good())\n         return; // No bitcoin.conf file is OK\n \n-    set<string> setOptions;\n+    std::set<std::string> setOptions;\n     setOptions.insert(\"*\");\n \n     for (boost::program_options::detail::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n     {\n         // Don't overwrite existing settings so command line settings override bitcoin.conf\n-        string strKey = string(\"-\") + it->string_key;\n-        string strValue = it->value[0];\n+        std::string strKey = std::string(\"-\") + it->string_key;\n+        std::string strValue = it->value[0];\n         InterpretNegativeSetting(strKey, strValue);\n         if (mapSettingsRet.count(strKey) == 0)\n             mapSettingsRet[strKey] = strValue;"
      },
      {
        "sha": "6e6e33184ed5a1344d7fd3b4a0aaf402a2972edb",
        "filename": "src/utilmoneystr.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/utilmoneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/utilmoneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilmoneystr.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -9,16 +9,14 @@\n #include \"tinyformat.h\"\n #include \"utilstrencodings.h\"\n \n-using namespace std;\n-\n std::string FormatMoney(const CAmount& n)\n {\n     // Note: not using straight sprintf here because we do NOT want\n     // localized number formatting.\n     int64_t n_abs = (n > 0 ? n : -n);\n     int64_t quotient = n_abs/COIN;\n     int64_t remainder = n_abs%COIN;\n-    string str = strprintf(\"%d.%08d\", quotient, remainder);\n+    std::string str = strprintf(\"%d.%08d\", quotient, remainder);\n \n     // Right-trim excess zeros before the decimal point:\n     int nTrim = 0;\n@@ -33,14 +31,14 @@ std::string FormatMoney(const CAmount& n)\n }\n \n \n-bool ParseMoney(const string& str, CAmount& nRet)\n+bool ParseMoney(const std::string& str, CAmount& nRet)\n {\n     return ParseMoney(str.c_str(), nRet);\n }\n \n bool ParseMoney(const char* pszIn, CAmount& nRet)\n {\n-    string strWhole;\n+    std::string strWhole;\n     int64_t nUnits = 0;\n     const char* p = pszIn;\n     while (isspace(*p))"
      },
      {
        "sha": "6640d0fb0fd0d333ec017da28b2241d5434da274",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 26,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -12,19 +12,17 @@\n #include <errno.h>\n #include <limits>\n \n-using namespace std;\n+static const std::string CHARS_ALPHA_NUM = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n \n-static const string CHARS_ALPHA_NUM = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-static const string SAFE_CHARS[] =\n+static const std::string SAFE_CHARS[] =\n {\n     CHARS_ALPHA_NUM + \" .,;-_/:?@()\", // SAFE_CHARS_DEFAULT\n     CHARS_ALPHA_NUM + \" .,;-_?@\" // SAFE_CHARS_UA_COMMENT\n };\n \n-string SanitizeString(const string& str, int rule)\n+std::string SanitizeString(const std::string& str, int rule)\n {\n-    string strResult;\n+    std::string strResult;\n     for (std::string::size_type i = 0; i < str.size(); i++)\n     {\n         if (SAFE_CHARS[rule].find(str[i]) != std::string::npos)\n@@ -56,7 +54,7 @@ signed char HexDigit(char c)\n     return p_util_hexdigit[(unsigned char)c];\n }\n \n-bool IsHex(const string& str)\n+bool IsHex(const std::string& str)\n {\n     for(std::string::const_iterator it(str.begin()); it != str.end(); ++it)\n     {\n@@ -66,10 +64,10 @@ bool IsHex(const string& str)\n     return (str.size() > 0) && (str.size()%2 == 0);\n }\n \n-vector<unsigned char> ParseHex(const char* psz)\n+std::vector<unsigned char> ParseHex(const char* psz)\n {\n     // convert hex dump to vector\n-    vector<unsigned char> vch;\n+    std::vector<unsigned char> vch;\n     while (true)\n     {\n         while (isspace(*psz))\n@@ -87,16 +85,16 @@ vector<unsigned char> ParseHex(const char* psz)\n     return vch;\n }\n \n-vector<unsigned char> ParseHex(const string& str)\n+std::vector<unsigned char> ParseHex(const std::string& str)\n {\n     return ParseHex(str.c_str());\n }\n \n-string EncodeBase64(const unsigned char* pch, size_t len)\n+std::string EncodeBase64(const unsigned char* pch, size_t len)\n {\n     static const char *pbase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n \n-    string strRet=\"\";\n+    std::string strRet=\"\";\n     strRet.reserve((len+2)/3*4);\n \n     int mode=0, left=0;\n@@ -138,12 +136,12 @@ string EncodeBase64(const unsigned char* pch, size_t len)\n     return strRet;\n }\n \n-string EncodeBase64(const string& str)\n+std::string EncodeBase64(const std::string& str)\n {\n     return EncodeBase64((const unsigned char*)str.c_str(), str.size());\n }\n \n-vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n+std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n {\n     static const int decode64_table[256] =\n     {\n@@ -165,7 +163,7 @@ vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n     if (pfInvalid)\n         *pfInvalid = false;\n \n-    vector<unsigned char> vchRet;\n+    std::vector<unsigned char> vchRet;\n     vchRet.reserve(strlen(p)*3/4);\n \n     int mode = 0;\n@@ -226,17 +224,17 @@ vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n     return vchRet;\n }\n \n-string DecodeBase64(const string& str)\n+std::string DecodeBase64(const std::string& str)\n {\n-    vector<unsigned char> vchRet = DecodeBase64(str.c_str());\n-    return (vchRet.size() == 0) ? string() : string((const char*)&vchRet[0], vchRet.size());\n+    std::vector<unsigned char> vchRet = DecodeBase64(str.c_str());\n+    return (vchRet.size() == 0) ? std::string() : std::string((const char*)&vchRet[0], vchRet.size());\n }\n \n-string EncodeBase32(const unsigned char* pch, size_t len)\n+std::string EncodeBase32(const unsigned char* pch, size_t len)\n {\n     static const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n \n-    string strRet=\"\";\n+    std::string strRet=\"\";\n     strRet.reserve((len+4)/5*8);\n \n     int mode=0, left=0;\n@@ -291,12 +289,12 @@ string EncodeBase32(const unsigned char* pch, size_t len)\n     return strRet;\n }\n \n-string EncodeBase32(const string& str)\n+std::string EncodeBase32(const std::string& str)\n {\n     return EncodeBase32((const unsigned char*)str.c_str(), str.size());\n }\n \n-vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n+std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n {\n     static const int decode32_table[256] =\n     {\n@@ -318,7 +316,7 @@ vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n     if (pfInvalid)\n         *pfInvalid = false;\n \n-    vector<unsigned char> vchRet;\n+    std::vector<unsigned char> vchRet;\n     vchRet.reserve((strlen(p))*5/8);\n \n     int mode = 0;\n@@ -413,10 +411,10 @@ vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n     return vchRet;\n }\n \n-string DecodeBase32(const string& str)\n+std::string DecodeBase32(const std::string& str)\n {\n-    vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n-    return (vchRet.size() == 0) ? string() : string((const char*)&vchRet[0], vchRet.size());\n+    std::vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n+    return (vchRet.size() == 0) ? std::string() : std::string((const char*)&vchRet[0], vchRet.size());\n }\n \n static bool ParsePrechecks(const std::string& str)"
      },
      {
        "sha": "a9a79c5154bb952291c396245354ff13ff9b7fc9",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -12,8 +12,6 @@\n #include <boost/date_time/posix_time/posix_time.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n static int64_t nMockTime = 0; //!< For unit testing\n \n int64_t GetTime()"
      },
      {
        "sha": "2eb775c539328aa9d1f2b6877444609e4f6b0a1c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 27,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -45,8 +45,6 @@\n #include <boost/math/distributions/poisson.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -88,7 +86,7 @@ static void CheckBlockIndex(const Consensus::Params& consensusParams);\n /** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n \n-const string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n \n // Internal stuff\n namespace {\n@@ -121,11 +119,11 @@ namespace {\n      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n      * missing the data for the block.\n      */\n-    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n     /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n      */\n-    multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n+    std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n@@ -149,10 +147,10 @@ namespace {\n     arith_uint256 nLastPreciousChainwork = 0;\n \n     /** Dirty block index entries. */\n-    set<CBlockIndex*> setDirtyBlockIndex;\n+    std::set<CBlockIndex*> setDirtyBlockIndex;\n \n     /** Dirty block file entries. */\n-    set<int> setDirtyFileInfo;\n+    std::set<int> setDirtyFileInfo;\n } // anon namespace\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -481,7 +479,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n     if (fCheckDuplicateInputs) {\n-        set<COutPoint> vInOutPoints;\n+        std::set<COutPoint> vInOutPoints;\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n@@ -555,7 +553,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n-    string reason;\n+    std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n         return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n \n@@ -570,7 +568,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-in-mempool\");\n \n     // Check for conflicts with in-memory transactions\n-    set<uint256> setConflicts;\n+    std::set<uint256> setConflicts;\n     {\n     LOCK(pool.cs); // protect pool.mapNextTx\n     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n@@ -788,7 +786,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (setConflicts.size())\n         {\n             CFeeRate newFeeRate(nModifiedFees, nSize);\n-            set<uint256> setConflictsParents;\n+            std::set<uint256> setConflictsParents;\n             const int maxDescendantsToVisit = 100;\n             CTxMemPool::setEntries setIterConflicting;\n             BOOST_FOREACH(const uint256 &hashConflicting, setConflicts)\n@@ -1977,13 +1975,13 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n         {\n             std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;\n             vFiles.reserve(setDirtyFileInfo.size());\n-            for (set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n-                vFiles.push_back(make_pair(*it, &vinfoBlockFile[*it]));\n+            for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n+                vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));\n                 setDirtyFileInfo.erase(it++);\n             }\n             std::vector<const CBlockIndex*> vBlocks;\n             vBlocks.reserve(setDirtyBlockIndex.size());\n-            for (set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n+            for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n                 vBlocks.push_back(*it);\n                 setDirtyBlockIndex.erase(it++);\n             }\n@@ -2581,7 +2579,7 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n+    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n     if (miPrev != mapBlockIndex.end())\n@@ -2617,7 +2615,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n \n     if (pindexNew->pprev == NULL || pindexNew->pprev->nChainTx) {\n         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n-        deque<CBlockIndex*> queue;\n+        std::deque<CBlockIndex*> queue;\n         queue.push_back(pindexNew);\n \n         // Recursively process any descendant blocks that now may be eligible to be connected.\n@@ -3229,7 +3227,7 @@ void PruneOneBlockFile(const int fileNumber)\n \n void UnlinkPrunedFiles(std::set<int>& setFilesToPrune)\n {\n-    for (set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n+    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n         CDiskBlockPos pos(*it, 0);\n         boost::filesystem::remove(GetBlockPosFilename(pos, \"blk\"));\n         boost::filesystem::remove(GetBlockPosFilename(pos, \"rev\"));\n@@ -3345,8 +3343,8 @@ CBlockIndex * InsertBlockIndex(uint256 hash)\n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n     if (!pindexNew)\n-        throw runtime_error(std::string(__func__) + \": new CBlockIndex failed\");\n-    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n+        throw std::runtime_error(std::string(__func__) + \": new CBlockIndex failed\");\n+    mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n \n     return pindexNew;\n@@ -3360,12 +3358,12 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     boost::this_thread::interruption_point();\n \n     // Calculate nChainWork\n-    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n+    std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(mapBlockIndex.size());\n     BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n-        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n+        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n     BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n@@ -3415,7 +3413,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n \n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n-    set<int> setBlkDataFiles;\n+    std::set<int> setBlkDataFiles;\n     BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n@@ -3801,7 +3799,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 NotifyHeaderTip();\n \n                 // Recursively process earlier encountered successors of this block\n-                deque<uint256> queue;\n+                std::deque<uint256> queue;\n                 queue.push_back(hash);\n                 while (!queue.empty()) {\n                     uint256 head = queue.front();\n@@ -4024,10 +4022,10 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n \n std::string GetWarnings(const std::string& strFor)\n {\n-    string strStatusBar;\n-    string strRPC;\n-    string strGUI;\n-    const string uiAlertSeperator = \"<hr />\";\n+    std::string strStatusBar;\n+    std::string strRPC;\n+    std::string strGUI;\n+    const std::string uiAlertSeperator = \"<hr />\";\n \n     if (!CLIENT_VERSION_IS_RELEASE) {\n         strStatusBar = \"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\";"
      },
      {
        "sha": "9a0759b40a43bcfff50d34db048128350b3d2ccd",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 18,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -21,12 +21,8 @@\n #include <boost/thread.hpp>\n #include <boost/version.hpp>\n \n-using namespace std;\n-\n-\n unsigned int nWalletDBUpdated;\n \n-\n //\n // CDB\n //\n@@ -119,7 +115,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n void CDBEnv::MakeMock()\n {\n     if (fDbEnvInit)\n-        throw runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n+        throw std::runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n \n     boost::this_thread::interruption_point();\n \n@@ -142,7 +138,7 @@ void CDBEnv::MakeMock()\n                              DB_PRIVATE,\n                          S_IRUSR | S_IWUSR);\n     if (ret > 0)\n-        throw runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n+        throw std::runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n \n     fDbEnvInit = true;\n     fMockDb = true;\n@@ -179,7 +175,7 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n     if (fAggressive)\n         flags |= DB_AGGRESSIVE;\n \n-    stringstream strDump;\n+    std::stringstream strDump;\n \n     Db db(dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n@@ -203,7 +199,7 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n     //  ... repeated\n     // DATA=END\n \n-    string strLine;\n+    std::string strLine;\n     while (!strDump.eof() && strLine != HEADER_END)\n         getline(strDump, strLine); // Skip past header\n \n@@ -256,7 +252,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n     {\n         LOCK(bitdb.cs_db);\n         if (!bitdb.Open(GetDataDir()))\n-            throw runtime_error(\"CDB: Failed to open database environment.\");\n+            throw std::runtime_error(\"CDB: Failed to open database environment.\");\n \n         strFile = strFilename;\n         ++bitdb.mapFileUseCount[strFile];\n@@ -269,7 +265,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n                 DbMpoolFile* mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n                 if (ret != 0)\n-                    throw runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n+                    throw std::runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n             }\n \n             ret = pdb->open(NULL,                               // Txn pointer\n@@ -284,10 +280,10 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n                 pdb = NULL;\n                 --bitdb.mapFileUseCount[strFile];\n                 strFile = \"\";\n-                throw runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n+                throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n             }\n \n-            if (fCreate && !Exists(string(\"version\"))) {\n+            if (fCreate && !Exists(std::string(\"version\"))) {\n                 bool fTmp = fReadOnly;\n                 fReadOnly = false;\n                 WriteVersion(CLIENT_VERSION);\n@@ -330,7 +326,7 @@ void CDB::Close()\n     }\n }\n \n-void CDBEnv::CloseDb(const string& strFile)\n+void CDBEnv::CloseDb(const std::string& strFile)\n {\n     {\n         LOCK(cs_db);\n@@ -344,7 +340,7 @@ void CDBEnv::CloseDb(const string& strFile)\n     }\n }\n \n-bool CDBEnv::RemoveDb(const string& strFile)\n+bool CDBEnv::RemoveDb(const std::string& strFile)\n {\n     this->CloseDb(strFile);\n \n@@ -353,7 +349,7 @@ bool CDBEnv::RemoveDb(const string& strFile)\n     return (rc == 0);\n }\n \n-bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n+bool CDB::Rewrite(const std::string& strFile, const char* pszSkip)\n {\n     while (true) {\n         {\n@@ -366,7 +362,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n \n                 bool fSuccess = true;\n                 LogPrintf(\"CDB::Rewrite: Rewriting %s...\\n\", strFile);\n-                string strFileRes = strFile + \".rewrite\";\n+                std::string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n                     CDB db(strFile.c_str(), \"r\");\n                     Db* pdbCopy = new Db(bitdb.dbenv, 0);\n@@ -446,9 +442,9 @@ void CDBEnv::Flush(bool fShutdown)\n         return;\n     {\n         LOCK(cs_db);\n-        map<string, int>::iterator mi = mapFileUseCount.begin();\n+        std::map<std::string, int>::iterator mi = mapFileUseCount.begin();\n         while (mi != mapFileUseCount.end()) {\n-            string strFile = (*mi).first;\n+            std::string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n             LogPrint(\"db\", \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n             if (nRefCount == 0) {"
      },
      {
        "sha": "9c491f8e7b2c46de7ee8e03a5b58b4bbde782a99",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 32,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -27,8 +27,6 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n void EnsureWalletIsUnlocked();\n bool EnsureWalletIsAvailable(bool avoidException);\n \n@@ -81,7 +79,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         return NullUniValue;\n     \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importprivkey \\\"bitcoinprivkey\\\" ( \\\"label\\\" rescan )\\n\"\n             \"\\nAdds a private key (as returned by dumpprivkey) to your wallet.\\n\"\n             \"\\nArguments:\\n\"\n@@ -105,8 +103,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked();\n \n-    string strSecret = request.params[0].get_str();\n-    string strLabel = \"\";\n+    std::string strSecret = request.params[0].get_str();\n+    std::string strLabel = \"\";\n     if (request.params.size() > 1)\n         strLabel = request.params[1].get_str();\n \n@@ -153,8 +151,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-void ImportAddress(const CBitcoinAddress& address, const string& strLabel);\n-void ImportScript(const CScript& script, const string& strLabel, bool isRedeemScript)\n+void ImportAddress(const CBitcoinAddress& address, const std::string& strLabel);\n+void ImportScript(const CScript& script, const std::string& strLabel, bool isRedeemScript)\n {\n     if (!isRedeemScript && ::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n@@ -176,7 +174,7 @@ void ImportScript(const CScript& script, const string& strLabel, bool isRedeemSc\n     }\n }\n \n-void ImportAddress(const CBitcoinAddress& address, const string& strLabel)\n+void ImportAddress(const CBitcoinAddress& address, const std::string& strLabel)\n {\n     CScript script = GetScriptForDestination(address.Get());\n     ImportScript(script, strLabel, false);\n@@ -191,7 +189,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n     \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importaddress \\\"address\\\" ( \\\"label\\\" rescan p2sh )\\n\"\n             \"\\nAdds a script (in hex) or address that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n             \"\\nArguments:\\n\"\n@@ -213,7 +211,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n         );\n \n \n-    string strLabel = \"\";\n+    std::string strLabel = \"\";\n     if (request.params.size() > 1)\n         strLabel = request.params[1].get_str();\n \n@@ -259,7 +257,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importprunedfunds\\n\"\n             \"\\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\\n\"\n             \"\\nArguments:\\n\"\n@@ -278,8 +276,8 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     ssMB >> merkleBlock;\n \n     //Search partial merkle tree in proof for our transaction and index in valid block\n-    vector<uint256> vMatch;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatch;\n+    std::vector<unsigned int> vIndex;\n     unsigned int txnIndex = 0;\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n@@ -288,7 +286,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n         if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n \n-        vector<uint256>::const_iterator it;\n+        std::vector<uint256>::const_iterator it;\n         if ((it = std::find(vMatch.begin(), vMatch.end(), hashTx))==vMatch.end()) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction given doesn't exist in proof\");\n         }\n@@ -318,7 +316,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"removeprunedfunds \\\"txid\\\"\\n\"\n             \"\\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.\\n\"\n             \"\\nArguments:\\n\"\n@@ -333,9 +331,9 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n-    vector<uint256> vHash;\n+    std::vector<uint256> vHash;\n     vHash.push_back(hash);\n-    vector<uint256> vHashOut;\n+    std::vector<uint256> vHashOut;\n \n     if(pwalletMain->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Could not properly delete the transaction.\");\n@@ -354,7 +352,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importpubkey \\\"pubkey\\\" ( \\\"label\\\" rescan )\\n\"\n             \"\\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n             \"\\nArguments:\\n\"\n@@ -372,7 +370,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n         );\n \n \n-    string strLabel = \"\";\n+    std::string strLabel = \"\";\n     if (request.params.size() > 1)\n         strLabel = request.params[1].get_str();\n \n@@ -412,7 +410,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n         return NullUniValue;\n     \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importwallet \\\"filename\\\"\\n\"\n             \"\\nImports keys from a wallet dump file (see dumpwallet).\\n\"\n             \"\\nArguments:\\n\"\n@@ -433,7 +431,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked();\n \n-    ifstream file;\n+    std::ifstream file;\n     file.open(request.params[0].get_str().c_str(), std::ios::in | std::ios::ate);\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n@@ -519,7 +517,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n         return NullUniValue;\n     \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"dumpprivkey \\\"bitcoinaddress\\\"\\n\"\n             \"\\nReveals the private key corresponding to 'bitcoinaddress'.\\n\"\n             \"Then the importprivkey can be used with this output\\n\"\n@@ -537,7 +535,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked();\n \n-    string strAddress = request.params[0].get_str();\n+    std::string strAddress = request.params[0].get_str();\n     CBitcoinAddress address;\n     if (!address.SetString(strAddress))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -557,7 +555,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n         return NullUniValue;\n     \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"dumpwallet \\\"filename\\\"\\n\"\n             \"\\nDumps all wallet keys in a human-readable format.\\n\"\n             \"\\nArguments:\\n\"\n@@ -571,7 +569,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked();\n \n-    ofstream file;\n+    std::ofstream file;\n     file.open(request.params[0].get_str().c_str());\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n@@ -653,17 +651,17 @@ UniValue processImport(const UniValue& data) {\n         }\n \n         // Optional fields.\n-        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n         const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n         const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n \n         bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n         bool isP2SH = strRedeemScript.length() > 0;\n-        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n \n         // Parse the output.\n         CScript script;\n@@ -750,7 +748,7 @@ UniValue processImport(const UniValue& data) {\n             // Import private keys.\n             if (keys.size()) {\n                 for (size_t i = 0; i < keys.size(); i++) {\n-                    const string& privkey = keys[i].get_str();\n+                    const std::string& privkey = keys[i].get_str();\n \n                     CBitcoinSecret vchSecret;\n                     bool fGood = vchSecret.SetString(privkey);\n@@ -792,7 +790,7 @@ UniValue processImport(const UniValue& data) {\n         } else {\n             // Import public keys.\n             if (pubKeys.size() && keys.size() == 0) {\n-                const string& strPubKey = pubKeys[0].get_str();\n+                const std::string& strPubKey = pubKeys[0].get_str();\n \n                 if (!IsHex(strPubKey)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n@@ -860,7 +858,7 @@ UniValue processImport(const UniValue& data) {\n \n             // Import private keys.\n             if (keys.size()) {\n-                const string& strPrivkey = keys[0].get_str();\n+                const std::string& strPrivkey = keys[0].get_str();\n \n                 // Checks.\n                 CBitcoinSecret vchSecret;\n@@ -962,7 +960,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n {\n     // clang-format off\n     if (mainRequest.fHelp || mainRequest.params.size() < 1 || mainRequest.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importmulti '[<json import requests>]' '<json options>' \\n\\n\"\n             \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n             \"Arguments:\\n\""
      },
      {
        "sha": "33c5e897330bca8d23fda238a93af2fcb352cda2",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 121,
        "deletions": 123,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -25,8 +25,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n int64_t nWalletUnlockTime;\n static CCriticalSection cs_nWalletUnlockTime;\n \n@@ -90,13 +88,13 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     }\n     entry.push_back(Pair(\"bip125-replaceable\", rbfStatus));\n \n-    BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n+    BOOST_FOREACH(const PAIRTYPE(std::string,std::string)& item, wtx.mapValue)\n         entry.push_back(Pair(item.first, item.second));\n }\n \n-string AccountFromValue(const UniValue& value)\n+std::string AccountFromValue(const UniValue& value)\n {\n-    string strAccount = value.get_str();\n+    std::string strAccount = value.get_str();\n     if (strAccount == \"*\")\n         throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid account name\");\n     return strAccount;\n@@ -108,7 +106,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnewaddress ( \\\"account\\\" )\\n\"\n             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n             \"If 'account' is specified (DEPRECATED), it is added to the address book \\n\"\n@@ -125,7 +123,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n-    string strAccount;\n+    std::string strAccount;\n     if (request.params.size() > 0)\n         strAccount = AccountFromValue(request.params[0]);\n \n@@ -144,7 +142,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n }\n \n \n-CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n+CBitcoinAddress GetAccountAddress(std::string strAccount, bool bForceNew=false)\n {\n     CPubKey pubKey;\n     if (!pwalletMain->GetAccountPubkey(pubKey, strAccount, bForceNew)) {\n@@ -160,7 +158,7 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaccountaddress \\\"account\\\"\\n\"\n             \"\\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\\n\"\n             \"\\nArguments:\\n\"\n@@ -177,7 +175,7 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n \n     UniValue ret(UniValue::VSTR);\n \n@@ -192,7 +190,7 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getrawchangeaddress\\n\"\n             \"\\nReturns a new Bitcoin address, for receiving change.\\n\"\n             \"This is for use with raw transactions, NOT normal use.\\n\"\n@@ -227,7 +225,7 @@ UniValue setaccount(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"setaccount \\\"bitcoinaddress\\\" \\\"account\\\"\\n\"\n             \"\\nDEPRECATED. Sets the account associated with the given address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -244,7 +242,7 @@ UniValue setaccount(const JSONRPCRequest& request)\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n-    string strAccount;\n+    std::string strAccount;\n     if (request.params.size() > 1)\n         strAccount = AccountFromValue(request.params[1]);\n \n@@ -254,7 +252,7 @@ UniValue setaccount(const JSONRPCRequest& request)\n         // Detect when changing the account of an address that is the 'unused current key' of another account:\n         if (pwalletMain->mapAddressBook.count(address.Get()))\n         {\n-            string strOldAccount = pwalletMain->mapAddressBook[address.Get()].name;\n+            std::string strOldAccount = pwalletMain->mapAddressBook[address.Get()].name;\n             if (address == GetAccountAddress(strOldAccount))\n                 GetAccountAddress(strOldAccount, true);\n         }\n@@ -273,7 +271,7 @@ UniValue getaccount(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaccount \\\"bitcoinaddress\\\"\\n\"\n             \"\\nDEPRECATED. Returns the account associated with the given address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -291,8 +289,8 @@ UniValue getaccount(const JSONRPCRequest& request)\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n-    string strAccount;\n-    map<CTxDestination, CAddressBookData>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n+    std::string strAccount;\n+    std::map<CTxDestination, CAddressBookData>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n     if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.name.empty())\n         strAccount = (*mi).second.name;\n     return strAccount;\n@@ -305,7 +303,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaddressesbyaccount \\\"account\\\"\\n\"\n             \"\\nDEPRECATED. Returns the list of addresses for the given account.\\n\"\n             \"\\nArguments:\\n\"\n@@ -322,14 +320,14 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n-        const string& strName = item.second.name;\n+        const std::string& strName = item.second.name;\n         if (strName == strAccount)\n             ret.push_back(address.ToString());\n     }\n@@ -357,7 +355,7 @@ static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtr\n     CReserveKey reservekey(pwalletMain);\n     CAmount nFeeRequired;\n     std::string strError;\n-    vector<CRecipient> vecSend;\n+    std::vector<CRecipient> vecSend;\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n@@ -379,7 +377,7 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendtoaddress \\\"bitcoinaddress\\\" amount ( \\\"comment\\\" \\\"comment-to\\\" subtractfeefromamount )\\n\"\n             \"\\nSend an amount to a given address.\\n\"\n             + HelpRequiringPassphrase() +\n@@ -437,7 +435,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listaddressgroupings\\n\"\n             \"\\nLists groups of addresses which have had their common ownership\\n\"\n             \"made public by common use as inputs or as the resulting change\\n\"\n@@ -462,8 +460,8 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    map<CTxDestination, CAmount> balances = pwalletMain->GetAddressBalances();\n-    BOOST_FOREACH(set<CTxDestination> grouping, pwalletMain->GetAddressGroupings())\n+    std::map<CTxDestination, CAmount> balances = pwalletMain->GetAddressBalances();\n+    BOOST_FOREACH(std::set<CTxDestination> grouping, pwalletMain->GetAddressGroupings())\n     {\n         UniValue jsonGrouping(UniValue::VARR);\n         BOOST_FOREACH(CTxDestination address, grouping)\n@@ -488,7 +486,7 @@ UniValue signmessage(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"signmessage \\\"bitcoinaddress\\\" \\\"message\\\"\\n\"\n             \"\\nSign a message with the private key of an address\"\n             + HelpRequiringPassphrase() + \"\\n\"\n@@ -512,8 +510,8 @@ UniValue signmessage(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked();\n \n-    string strAddress = request.params[0].get_str();\n-    string strMessage = request.params[1].get_str();\n+    std::string strAddress = request.params[0].get_str();\n+    std::string strMessage = request.params[1].get_str();\n \n     CBitcoinAddress addr(strAddress);\n     if (!addr.IsValid())\n@@ -531,7 +529,7 @@ UniValue signmessage(const JSONRPCRequest& request)\n     ss << strMessageMagic;\n     ss << strMessage;\n \n-    vector<unsigned char> vchSig;\n+    std::vector<unsigned char> vchSig;\n     if (!key.SignCompact(ss.GetHash(), vchSig))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n \n@@ -544,7 +542,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getreceivedbyaddress \\\"bitcoinaddress\\\" ( minconf )\\n\"\n             \"\\nReturns the total amount received by the given bitcoinaddress in transactions with at least minconf confirmations.\\n\"\n             \"\\nArguments:\\n\"\n@@ -580,7 +578,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n@@ -602,7 +600,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getreceivedbyaccount \\\"account\\\" ( minconf )\\n\"\n             \"\\nDEPRECATED. Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\\n\"\n             \"\\nArguments:\\n\"\n@@ -629,12 +627,12 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n         nMinDepth = request.params[1].get_int();\n \n     // Get the set of pub keys assigned to account\n-    string strAccount = AccountFromValue(request.params[0]);\n-    set<CTxDestination> setAddress = pwalletMain->GetAccountAddresses(strAccount);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::set<CTxDestination> setAddress = pwalletMain->GetAccountAddresses(strAccount);\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n@@ -659,7 +657,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getbalance ( \\\"account\\\" minconf includeWatchonly )\\n\"\n             \"\\nIf account is not specified, returns the server's total available balance.\\n\"\n             \"If account is specified (DEPRECATED), returns the balance in the account.\\n\"\n@@ -698,16 +696,16 @@ UniValue getbalance(const JSONRPCRequest& request)\n         // (GetBalance() sums up all unspent TxOuts)\n         // getbalance and \"getbalance * 1 true\" should return the same number\n         CAmount nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n                 continue;\n \n             CAmount allFee;\n-            string strSentAccount;\n-            list<COutputEntry> listReceived;\n-            list<COutputEntry> listSent;\n+            std::string strSentAccount;\n+            std::list<COutputEntry> listReceived;\n+            std::list<COutputEntry> listSent;\n             wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n             if (wtx.GetDepthInMainChain() >= nMinDepth)\n             {\n@@ -721,7 +719,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n         return  ValueFromAmount(nBalance);\n     }\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n \n     CAmount nBalance = pwalletMain->GetAccountBalance(strAccount, nMinDepth, filter);\n \n@@ -734,7 +732,7 @@ UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                 \"getunconfirmedbalance\\n\"\n                 \"Returns the server's total unconfirmed balance\\n\");\n \n@@ -750,7 +748,7 @@ UniValue movecmd(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 3 || request.params.size() > 5)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"move \\\"fromaccount\\\" \\\"toaccount\\\" amount ( minconf \\\"comment\\\" )\\n\"\n             \"\\nDEPRECATED. Move a specified amount from one account in your wallet to another.\\n\"\n             \"\\nArguments:\\n\"\n@@ -772,15 +770,15 @@ UniValue movecmd(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strFrom = AccountFromValue(request.params[0]);\n-    string strTo = AccountFromValue(request.params[1]);\n+    std::string strFrom = AccountFromValue(request.params[0]);\n+    std::string strTo = AccountFromValue(request.params[1]);\n     CAmount nAmount = AmountFromValue(request.params[2]);\n     if (nAmount <= 0)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n     if (request.params.size() > 3)\n         // unused parameter, used to be nMinDepth, keep type-checking it though\n         (void)request.params[3].get_int();\n-    string strComment;\n+    std::string strComment;\n     if (request.params.size() > 4)\n         strComment = request.params[4].get_str();\n \n@@ -797,7 +795,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 3 || request.params.size() > 6)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendfrom \\\"fromaccount\\\" \\\"tobitcoinaddress\\\" amount ( minconf \\\"comment\\\" \\\"comment-to\\\" )\\n\"\n             \"\\nDEPRECATED (use sendtoaddress). Sent an amount from an account to a bitcoin address.\"\n             + HelpRequiringPassphrase() + \"\\n\"\n@@ -824,7 +822,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n     CBitcoinAddress address(request.params[1].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -861,7 +859,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendmany \\\"fromaccount\\\" {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" [\\\"address\\\",...] )\\n\"\n             \"\\nSend multiple times. Amounts are double-precision floating point numbers.\"\n             + HelpRequiringPassphrase() + \"\\n\"\n@@ -901,7 +899,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     if (pwalletMain->GetBroadcastTransactions() && !g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n     UniValue sendTo = request.params[1].get_obj();\n     int nMinDepth = 1;\n     if (request.params.size() > 2)\n@@ -916,19 +914,19 @@ UniValue sendmany(const JSONRPCRequest& request)\n     if (request.params.size() > 4)\n         subtractFeeFromAmount = request.params[4].get_array();\n \n-    set<CBitcoinAddress> setAddress;\n-    vector<CRecipient> vecSend;\n+    std::set<CBitcoinAddress> setAddress;\n+    std::vector<CRecipient> vecSend;\n \n     CAmount totalAmount = 0;\n-    vector<string> keys = sendTo.getKeys();\n-    BOOST_FOREACH(const string& name_, keys)\n+    std::vector<std::string> keys = sendTo.getKeys();\n+    BOOST_FOREACH(const std::string& name_, keys)\n     {\n         CBitcoinAddress address(name_);\n         if (!address.IsValid())\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+name_);\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+name_);\n \n         if (setAddress.count(address))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+name_);\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+name_);\n         setAddress.insert(address);\n \n         CScript scriptPubKey = GetScriptForDestination(address.Get());\n@@ -959,7 +957,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     CReserveKey keyChange(pwalletMain);\n     CAmount nFeeRequired = 0;\n     int nChangePosRet = -1;\n-    string strFailReason;\n+    std::string strFailReason;\n     bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n@@ -982,7 +980,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n     {\n-        string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" )\\n\"\n+        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" )\\n\"\n             \"\\nAdd a nrequired-to-sign multisignature address to the wallet.\\n\"\n             \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n             \"If 'account' is specified (DEPRECATED), assign address to that account.\\n\"\n@@ -1005,12 +1003,12 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n             \"\\nAs json rpc call\\n\"\n             + HelpExampleRpc(\"addmultisigaddress\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n         ;\n-        throw runtime_error(msg);\n+        throw std::runtime_error(msg);\n     }\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strAccount;\n+    std::string strAccount;\n     if (request.params.size() > 2)\n         strAccount = AccountFromValue(request.params[2]);\n \n@@ -1075,7 +1073,7 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 1)\n     {\n-        string msg = \"addwitnessaddress \\\"address\\\"\\n\"\n+        std::string msg = \"addwitnessaddress \\\"address\\\"\\n\"\n             \"\\nAdd a witness address for a script (with pubkey or redeemscript known).\\n\"\n             \"It returns the witness script.\\n\"\n \n@@ -1086,7 +1084,7 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n             \"\\\"witnessaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n             \"}\\n\"\n         ;\n-        throw runtime_error(msg);\n+        throw std::runtime_error(msg);\n     }\n \n     {\n@@ -1116,7 +1114,7 @@ struct tallyitem\n {\n     CAmount nAmount;\n     int nConf;\n-    vector<uint256> txids;\n+    std::vector<uint256> txids;\n     bool fIsWatchonly;\n     tallyitem()\n     {\n@@ -1144,8 +1142,8 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     // Tally\n-    map<CBitcoinAddress, tallyitem> mapTally;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    std::map<CBitcoinAddress, tallyitem> mapTally;\n+    for (std::map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n \n@@ -1168,7 +1166,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n \n             tallyitem& item = mapTally[address];\n             item.nAmount += txout.nValue;\n-            item.nConf = min(item.nConf, nDepth);\n+            item.nConf = std::min(item.nConf, nDepth);\n             item.txids.push_back(wtx.GetHash());\n             if (mine & ISMINE_WATCH_ONLY)\n                 item.fIsWatchonly = true;\n@@ -1177,12 +1175,12 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n \n     // Reply\n     UniValue ret(UniValue::VARR);\n-    map<string, tallyitem> mapAccountTally;\n+    std::map<std::string, tallyitem> mapAccountTally;\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n-        const string& strAccount = item.second.name;\n-        map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n+        const std::string& strAccount = item.second.name;\n+        std::map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n \n@@ -1200,7 +1198,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n         {\n             tallyitem& _item = mapAccountTally[strAccount];\n             _item.nAmount += nAmount;\n-            _item.nConf = min(_item.nConf, nConf);\n+            _item.nConf = std::min(_item.nConf, nConf);\n             _item.fIsWatchonly = fIsWatchonly;\n         }\n         else\n@@ -1229,7 +1227,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n \n     if (fByAccounts)\n     {\n-        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n+        for (std::map<std::string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n         {\n             CAmount nAmount = (*it).second.nAmount;\n             int nConf = (*it).second.nConf;\n@@ -1252,7 +1250,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listreceivedbyaddress ( minconf includeempty includeWatchonly)\\n\"\n             \"\\nList balances by receiving address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1290,7 +1288,7 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listreceivedbyaccount ( minconf includeempty includeWatchonly)\\n\"\n             \"\\nDEPRECATED. List balances by account.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1328,16 +1326,16 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n         entry.push_back(Pair(\"address\", addr.ToString()));\n }\n \n-void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)\n+void ListTransactions(const CWalletTx& wtx, const std::string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)\n {\n     CAmount nFee;\n-    string strSentAccount;\n-    list<COutputEntry> listReceived;\n-    list<COutputEntry> listSent;\n+    std::string strSentAccount;\n+    std::list<COutputEntry> listReceived;\n+    std::list<COutputEntry> listSent;\n \n     wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, filter);\n \n-    bool fAllAccounts = (strAccount == string(\"*\"));\n+    bool fAllAccounts = (strAccount == std::string(\"*\"));\n     bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n \n     // Sent\n@@ -1368,7 +1366,7 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     {\n         BOOST_FOREACH(const COutputEntry& r, listReceived)\n         {\n-            string account;\n+            std::string account;\n             if (pwalletMain->mapAddressBook.count(r.destination))\n                 account = pwalletMain->mapAddressBook[r.destination].name;\n             if (fAllAccounts || (account == strAccount))\n@@ -1403,9 +1401,9 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     }\n }\n \n-void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, UniValue& ret)\n+void AcentryToJSON(const CAccountingEntry& acentry, const std::string& strAccount, UniValue& ret)\n {\n-    bool fAllAccounts = (strAccount == string(\"*\"));\n+    bool fAllAccounts = (strAccount == std::string(\"*\"));\n \n     if (fAllAccounts || acentry.strAccount == strAccount)\n     {\n@@ -1426,7 +1424,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listtransactions ( \\\"account\\\" count from includeWatchonly)\\n\"\n             \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1486,7 +1484,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strAccount = \"*\";\n+    std::string strAccount = \"*\";\n     if (request.params.size() > 0)\n         strAccount = request.params[0].get_str();\n     int nCount = 10;\n@@ -1528,11 +1526,11 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     if ((nFrom + nCount) > (int)ret.size())\n         nCount = ret.size() - nFrom;\n \n-    vector<UniValue> arrTmp = ret.getValues();\n+    std::vector<UniValue> arrTmp = ret.getValues();\n \n-    vector<UniValue>::iterator first = arrTmp.begin();\n+    std::vector<UniValue>::iterator first = arrTmp.begin();\n     std::advance(first, nFrom);\n-    vector<UniValue>::iterator last = arrTmp.begin();\n+    std::vector<UniValue>::iterator last = arrTmp.begin();\n     std::advance(last, nFrom+nCount);\n \n     if (last != arrTmp.end()) arrTmp.erase(last, arrTmp.end());\n@@ -1553,7 +1551,7 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listaccounts ( minconf includeWatchonly)\\n\"\n             \"\\nDEPRECATED. Returns Object that has account names as keys, account balances as values.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1585,19 +1583,19 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         if(request.params[1].get_bool())\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n-    map<string, CAmount> mapAccountBalances;\n+    std::map<std::string, CAmount> mapAccountBalances;\n     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n         if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n     }\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         CAmount nFee;\n-        string strSentAccount;\n-        list<COutputEntry> listReceived;\n-        list<COutputEntry> listSent;\n+        std::string strSentAccount;\n+        std::list<COutputEntry> listReceived;\n+        std::list<COutputEntry> listSent;\n         int nDepth = wtx.GetDepthInMainChain();\n         if (wtx.GetBlocksToMaturity() > 0 || nDepth < 0)\n             continue;\n@@ -1615,12 +1613,12 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         }\n     }\n \n-    const list<CAccountingEntry> & acentries = pwalletMain->laccentries;\n+    const std::list<CAccountingEntry> & acentries = pwalletMain->laccentries;\n     BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n     UniValue ret(UniValue::VOBJ);\n-    BOOST_FOREACH(const PAIRTYPE(string, CAmount)& accountBalance, mapAccountBalances) {\n+    BOOST_FOREACH(const PAIRTYPE(std::string, CAmount)& accountBalance, mapAccountBalances) {\n         ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n     }\n     return ret;\n@@ -1632,7 +1630,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listsinceblock ( \\\"blockhash\\\" target-confirmations includeWatchonly)\\n\"\n             \"\\nGet all transactions in blocks since block [blockhash], or all transactions if omitted\\n\"\n             \"\\nArguments:\\n\"\n@@ -1700,7 +1698,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n \n     UniValue transactions(UniValue::VARR);\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n+    for (std::map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n     {\n         CWalletTx tx = (*it).second;\n \n@@ -1724,7 +1722,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettransaction \\\"txid\\\" ( includeWatchonly )\\n\"\n             \"\\nGet detailed information about in-wallet transaction <txid>\\n\"\n             \"\\nArguments:\\n\"\n@@ -1792,7 +1790,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n     ListTransactions(wtx, \"*\", 0, false, details, filter);\n     entry.push_back(Pair(\"details\", details));\n \n-    string strHex = EncodeHexTx(static_cast<CTransaction>(wtx));\n+    std::string strHex = EncodeHexTx(static_cast<CTransaction>(wtx));\n     entry.push_back(Pair(\"hex\", strHex));\n \n     return entry;\n@@ -1804,7 +1802,7 @@ UniValue abandontransaction(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"abandontransaction \\\"txid\\\"\\n\"\n             \"\\nMark in-wallet transaction <txid> as abandoned\\n\"\n             \"This will mark this transaction and all its in-wallet descendants as abandoned which will allow\\n\"\n@@ -1839,7 +1837,7 @@ UniValue backupwallet(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"backupwallet \\\"destination\\\"\\n\"\n             \"\\nSafely copies current wallet file to destination, which can be a directory or a path with filename.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1851,7 +1849,7 @@ UniValue backupwallet(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    string strDest = request.params[0].get_str();\n+    std::string strDest = request.params[0].get_str();\n     if (!pwalletMain->BackupWallet(strDest))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n \n@@ -1865,7 +1863,7 @@ UniValue keypoolrefill(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"keypoolrefill ( newsize )\\n\"\n             \"\\nFills the keypool.\"\n             + HelpRequiringPassphrase() + \"\\n\"\n@@ -1909,7 +1907,7 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 2))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrase \\\"passphrase\\\" timeout\\n\"\n             \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n             \"This is needed prior to performing transactions related to private keys such as sending bitcoins\\n\"\n@@ -1948,7 +1946,7 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n     }\n     else\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrase <passphrase> <timeout>\\n\"\n             \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n \n@@ -1969,7 +1967,7 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 2))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrasechange \\\"oldpassphrase\\\" \\\"newpassphrase\\\"\\n\"\n             \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1998,7 +1996,7 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n     strNewWalletPass = request.params[1].get_str().c_str();\n \n     if (strOldWalletPass.length() < 1 || strNewWalletPass.length() < 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n             \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n \n@@ -2015,7 +2013,7 @@ UniValue walletlock(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 0))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletlock\\n\"\n             \"\\nRemoves the wallet encryption key from memory, locking the wallet.\\n\"\n             \"After calling this method, you will need to call walletpassphrase again\\n\"\n@@ -2054,7 +2052,7 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (!pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 1))\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"encryptwallet \\\"passphrase\\\"\\n\"\n             \"\\nEncrypts the wallet with 'passphrase'. This is for first time encryption.\\n\"\n             \"After this, any calls that interact with private keys such as sending or signing \\n\"\n@@ -2091,7 +2089,7 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n     strWalletPass = request.params[0].get_str().c_str();\n \n     if (strWalletPass.length() < 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"encryptwallet <passphrase>\\n\"\n             \"Encrypts the wallet with <passphrase>.\");\n \n@@ -2111,7 +2109,7 @@ UniValue lockunspent(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"lockunspent unlock ([{\\\"txid\\\":\\\"txid\\\",\\\"vout\\\":n},...])\\n\"\n             \"\\nUpdates list of temporarily unspendable outputs.\\n\"\n             \"Temporarily lock (unlock=false) or unlock (unlock=true) specified transaction outputs.\\n\"\n@@ -2175,7 +2173,7 @@ UniValue lockunspent(const JSONRPCRequest& request)\n                 {\"vout\", UniValueType(UniValue::VNUM)},\n             });\n \n-        string txid = find_value(o, \"txid\").get_str();\n+        std::string txid = find_value(o, \"txid\").get_str();\n         if (!IsHex(txid))\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected hex txid\");\n \n@@ -2200,7 +2198,7 @@ UniValue listlockunspent(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listlockunspent\\n\"\n             \"\\nReturns list of temporarily unspendable outputs.\\n\"\n             \"See the lockunspent call to lock and unlock transactions for spending.\\n\"\n@@ -2227,7 +2225,7 @@ UniValue listlockunspent(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n-    vector<COutPoint> vOutpts;\n+    std::vector<COutPoint> vOutpts;\n     pwalletMain->ListLockedCoins(vOutpts);\n \n     UniValue ret(UniValue::VARR);\n@@ -2249,7 +2247,7 @@ UniValue settxfee(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"settxfee amount\\n\"\n             \"\\nSet the transaction fee per kB. Overwrites the paytxfee parameter.\\n\"\n             \"\\nArguments:\\n\"\n@@ -2276,7 +2274,7 @@ UniValue getwalletinfo(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getwalletinfo\\n\"\n             \"Returns an object containing various wallet state info.\\n\"\n             \"\\nResult:\\n\"\n@@ -2322,7 +2320,7 @@ UniValue resendwallettransactions(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"resendwallettransactions\\n\"\n             \"Immediately re-broadcast unconfirmed wallet transactions to all peers.\\n\"\n             \"Intended only for testing; the wallet code periodically re-broadcasts\\n\"\n@@ -2350,7 +2348,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listunspent ( minconf maxconf  [\\\"address\\\",...] )\\n\"\n             \"\\nReturns array of unspent transaction outputs\\n\"\n             \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n@@ -2396,22 +2394,22 @@ UniValue listunspent(const JSONRPCRequest& request)\n     if (request.params.size() > 1)\n         nMaxDepth = request.params[1].get_int();\n \n-    set<CBitcoinAddress> setAddress;\n+    std::set<CBitcoinAddress> setAddress;\n     if (request.params.size() > 2) {\n         UniValue inputs = request.params[2].get_array();\n         for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n             const UniValue& input = inputs[idx];\n             CBitcoinAddress address(input.get_str());\n             if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+input.get_str());\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+input.get_str());\n             if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+input.get_str());\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+input.get_str());\n            setAddress.insert(address);\n         }\n     }\n \n     UniValue results(UniValue::VARR);\n-    vector<COutput> vecOutputs;\n+    std::vector<COutput> vecOutputs;\n     assert(pwalletMain != NULL);\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n     pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n@@ -2461,7 +2459,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"fundrawtransaction \\\"hexstring\\\" ( options )\\n\"\n                             \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n                             \"This will not modify existing inputs, and will add one change output to the outputs.\\n\"\n@@ -2568,7 +2566,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"changePosition out of bounds\");\n \n     CAmount nFeeOut;\n-    string strFailReason;\n+    std::string strFailReason;\n \n     if(!pwalletMain->FundTransaction(tx, nFeeOut, overrideEstimatedFeerate, feeRate, changePosition, strFailReason, includeWatching, lockUnspents, changeAddress))\n         throw JSONRPCError(RPC_INTERNAL_ERROR, strFailReason);"
      },
      {
        "sha": "e87feb505157d906a2b02d060d448d286b16f2c1",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -21,14 +21,12 @@\n // we repeat those tests this many times and only complain if all iterations of the test fail\n #define RANDOM_REPEATS 5\n \n-using namespace std;\n-\n-typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+typedef std::set<std::pair<const CWalletTx*,unsigned int> > CoinSet;\n \n BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletTestingSetup)\n \n static const CWallet wallet;\n-static vector<COutput> vCoins;\n+static std::vector<COutput> vCoins;\n \n static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n {\n@@ -61,7 +59,7 @@ static void empty_wallet(void)\n \n static bool equal_sets(CoinSet a, CoinSet b)\n {\n-    pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n     return ret.first == a.end() && ret.second == b.end();\n }\n "
      },
      {
        "sha": "c21baffa6f6d72c2219e59722e33773205e23d66",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 102,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -32,8 +32,6 @@\n #include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n CWallet* pwalletMain = NULL;\n /** Transaction fee set by the user */\n CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n@@ -66,8 +64,8 @@ const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"00000000000000000000000000000000\n \n struct CompareValueOnly\n {\n-    bool operator()(const pair<CAmount, pair<const CWalletTx*, unsigned int> >& t1,\n-                    const pair<CAmount, pair<const CWalletTx*, unsigned int> >& t2) const\n+    bool operator()(const std::pair<CAmount, std::pair<const CWalletTx*, unsigned int> >& t1,\n+                    const std::pair<CAmount, std::pair<const CWalletTx*, unsigned int> >& t2) const\n     {\n         return t1.first < t2.first;\n     }\n@@ -187,7 +185,7 @@ bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n }\n \n bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n-                            const vector<unsigned char> &vchCryptedSecret)\n+                            const std::vector<unsigned char> &vchCryptedSecret)\n {\n     if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n         return false;\n@@ -388,9 +386,9 @@ bool CWallet::SetMaxVersion(int nVersion)\n     return true;\n }\n \n-set<uint256> CWallet::GetConflicts(const uint256& txid) const\n+std::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n {\n-    set<uint256> result;\n+    std::set<uint256> result;\n     AssertLockHeld(cs_wallet);\n \n     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(txid);\n@@ -442,21 +440,21 @@ bool CWallet::Verify()\n         } catch (const boost::filesystem::filesystem_error&) {\n             // failure is ok (well, not really, but it's not worse than what we started with)\n         }\n-        \n+\n         // try again\n         if (!bitdb.Open(GetDataDir())) {\n             // if it still fails, it probably means we can't even create the database env\n             return InitError(strprintf(_(\"Error initializing wallet database environment %s!\"), GetDataDir()));\n         }\n     }\n-    \n+\n     if (GetBoolArg(\"-salvagewallet\", false))\n     {\n         // Recover readable keypairs:\n         if (!CWalletDB::Recover(bitdb, walletFile, true))\n             return false;\n     }\n-    \n+\n     if (boost::filesystem::exists(GetDataDir() / walletFile))\n     {\n         CDBEnv::VerifyResult r = bitdb.Verify(walletFile, CWalletDB::Recover);\n@@ -471,11 +469,11 @@ bool CWallet::Verify()\n         if (r == CDBEnv::RECOVER_FAIL)\n             return InitError(strprintf(_(\"%s corrupt, salvage failed\"), walletFile));\n     }\n-    \n+\n     return true;\n }\n \n-void CWallet::SyncMetaData(pair<TxSpends::iterator, TxSpends::iterator> range)\n+void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n {\n     // We want all the wallet transactions in range to have the same metadata as\n     // the oldest (smallest nOrderPos).\n@@ -519,7 +517,7 @@ void CWallet::SyncMetaData(pair<TxSpends::iterator, TxSpends::iterator> range)\n bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n {\n     const COutPoint outpoint(hash, n);\n-    pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n     range = mapTxSpends.equal_range(outpoint);\n \n     for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n@@ -537,9 +535,9 @@ bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n \n void CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n {\n-    mapTxSpends.insert(make_pair(outpoint, wtxid));\n+    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n \n-    pair<TxSpends::iterator, TxSpends::iterator> range;\n+    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n     range = mapTxSpends.equal_range(outpoint);\n     SyncMetaData(range);\n }\n@@ -665,20 +663,20 @@ DBErrors CWallet::ReorderTransactions()\n     // Probably a bad idea to change the output of this\n \n     // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n-    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n-    typedef multimap<int64_t, TxPair > TxItems;\n+    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n+    typedef std::multimap<int64_t, TxPair> TxItems;\n     TxItems txByTime;\n \n-    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n         CWalletTx* wtx = &((*it).second);\n-        txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n+        txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n     }\n-    list<CAccountingEntry> acentries;\n+    std::list<CAccountingEntry> acentries;\n     walletdb.ListAccountCreditDebit(\"\", acentries);\n     BOOST_FOREACH(CAccountingEntry& entry, acentries)\n     {\n-        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+        txByTime.insert(std::make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n     }\n \n     nOrderPosNext = 0;\n@@ -792,7 +790,7 @@ bool CWallet::GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bFo\n         else {\n             // Check if the current key has been used\n             CScript scriptPubKey = GetScriptForDestination(account.vchPubKey.GetID());\n-            for (map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n+            for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n                  it != mapWallet.end() && account.vchPubKey.IsValid();\n                  ++it)\n                 BOOST_FOREACH(const CTxOut& txout, (*it).second.tx->vout)\n@@ -835,15 +833,15 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n     uint256 hash = wtxIn.GetHash();\n \n     // Inserts only if not already there, returns tx inserted or tx found\n-    pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n+    std::pair<std::map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(std::make_pair(hash, wtxIn));\n     CWalletTx& wtx = (*ret.first).second;\n     wtx.BindWallet(this);\n     bool fInsertedNew = ret.second;\n     if (fInsertedNew)\n     {\n         wtx.nTimeReceived = GetAdjustedTime();\n         wtx.nOrderPos = IncOrderPosNext(&walletdb);\n-        wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+        wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n \n         wtx.nTimeSmart = wtx.nTimeReceived;\n         if (!wtxIn.hashUnset())\n@@ -952,7 +950,7 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n     mapWallet[hash] = wtxIn;\n     CWalletTx& wtx = mapWallet[hash];\n     wtx.BindWallet(this);\n-    wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+    wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n     AddToSpends(hash);\n     BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin) {\n         if (mapWallet.count(txin.prevout.hash)) {\n@@ -1144,7 +1142,7 @@ isminetype CWallet::IsMine(const CTxIn &txin) const\n {\n     {\n         LOCK(cs_wallet);\n-        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n             const CWalletTx& prev = (*mi).second;\n@@ -1159,7 +1157,7 @@ CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n {\n     {\n         LOCK(cs_wallet);\n-        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n             const CWalletTx& prev = (*mi).second;\n@@ -1312,7 +1310,7 @@ bool CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n {\n     LOCK(cs_wallet);\n     if (!memonly && !CWalletDB(strWalletFile).WriteHDChain(chain))\n-        throw runtime_error(std::string(__func__) + \": writing chain failed\");\n+        throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n \n     hdChain = chain;\n     return true;\n@@ -1340,23 +1338,23 @@ int CWalletTx::GetRequestCount() const\n             // Generated block\n             if (!hashUnset())\n             {\n-                map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n+                std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                 if (mi != pwallet->mapRequestCount.end())\n                     nRequests = (*mi).second;\n             }\n         }\n         else\n         {\n             // Did anyone request this transaction?\n-            map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n+            std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n             if (mi != pwallet->mapRequestCount.end())\n             {\n                 nRequests = (*mi).second;\n \n                 // How about the block it's in?\n                 if (nRequests == 0 && !hashUnset())\n                 {\n-                    map<uint256, int>::const_iterator _mi = pwallet->mapRequestCount.find(hashBlock);\n+                    std::map<uint256, int>::const_iterator _mi = pwallet->mapRequestCount.find(hashBlock);\n                     if (_mi != pwallet->mapRequestCount.end())\n                         nRequests = (*_mi).second;\n                     else\n@@ -1368,8 +1366,8 @@ int CWalletTx::GetRequestCount() const\n     return nRequests;\n }\n \n-void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,\n-                           list<COutputEntry>& listSent, CAmount& nFee, string& strSentAccount, const isminefilter& filter) const\n+void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n+                           std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const\n {\n     nFee = 0;\n     listReceived.clear();\n@@ -1424,15 +1422,15 @@ void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,\n \n }\n \n-void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,\n+void CWalletTx::GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n                                   CAmount& nSent, CAmount& nFee, const isminefilter& filter) const\n {\n     nReceived = nSent = nFee = 0;\n \n     CAmount allFee;\n-    string strSentAccount;\n-    list<COutputEntry> listReceived;\n-    list<COutputEntry> listSent;\n+    std::string strSentAccount;\n+    std::list<COutputEntry> listReceived;\n+    std::list<COutputEntry> listSent;\n     GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n \n     if (strAccount == strSentAccount)\n@@ -1447,7 +1445,7 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,\n         {\n             if (pwallet->mapAddressBook.count(r.destination))\n             {\n-                map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);\n+                std::map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);\n                 if (mi != pwallet->mapAddressBook.end() && (*mi).second.name == strAccount)\n                     nReceived += r.amount;\n             }\n@@ -1559,9 +1557,9 @@ bool CWalletTx::RelayWalletTransaction(CConnman* connman)\n     return false;\n }\n \n-set<uint256> CWalletTx::GetConflicts() const\n+std::set<uint256> CWalletTx::GetConflicts() const\n {\n-    set<uint256> result;\n+    std::set<uint256> result;\n     if (pwallet != NULL)\n     {\n         uint256 myHash = GetHash();\n@@ -1786,14 +1784,14 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CCon\n \n     LOCK(cs_wallet);\n     // Sort them in chronological order\n-    multimap<unsigned int, CWalletTx*> mapSorted;\n+    std::multimap<unsigned int, CWalletTx*> mapSorted;\n     BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n     {\n         CWalletTx& wtx = item.second;\n         // Don't rebroadcast if newer than nTime:\n         if (wtx.nTimeReceived > nTime)\n             continue;\n-        mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n+        mapSorted.insert(std::make_pair(wtx.nTimeReceived, &wtx));\n     }\n     BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n     {\n@@ -1843,7 +1841,7 @@ CAmount CWallet::GetBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (pcoin->IsTrusted())\n@@ -1859,7 +1857,7 @@ CAmount CWallet::GetUnconfirmedBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n@@ -1874,7 +1872,7 @@ CAmount CWallet::GetImmatureBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             nTotal += pcoin->GetImmatureCredit();\n@@ -1888,7 +1886,7 @@ CAmount CWallet::GetWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (pcoin->IsTrusted())\n@@ -1904,7 +1902,7 @@ CAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n@@ -1919,7 +1917,7 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             nTotal += pcoin->GetImmatureWatchOnlyCredit();\n@@ -1928,13 +1926,13 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n     return nTotal;\n }\n \n-void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const\n+void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const\n {\n     vCoins.clear();\n \n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const uint256& wtxid = it->first;\n             const CWalletTx* pcoin = &(*it).second;\n@@ -1971,10 +1969,10 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n     }\n }\n \n-static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,unsigned int> > >vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n-                                  vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n+static void ApproximateBestSubset(std::vector<std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > > vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n+                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n {\n-    vector<char> vfIncluded;\n+    std::vector<char> vfIncluded;\n \n     vfBest.assign(vValue.size(), true);\n     nBest = nTotalLower;\n@@ -2017,17 +2015,17 @@ static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,uns\n     }\n }\n \n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,\n-                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const\n+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins,\n+                                 std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n     // List of values less than target\n-    pair<CAmount, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n+    std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n     coinLowestLarger.first = std::numeric_limits<CAmount>::max();\n     coinLowestLarger.second.first = NULL;\n-    vector<pair<CAmount, pair<const CWalletTx*,unsigned int> > > vValue;\n+    std::vector<std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > > vValue;\n     CAmount nTotalLower = 0;\n \n     random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n@@ -2045,7 +2043,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int\n         int i = output.i;\n         CAmount n = pcoin->tx->vout[i].nValue;\n \n-        pair<CAmount,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n+        std::pair<CAmount,std::pair<const CWalletTx*,unsigned int> > coin = std::make_pair(n,std::make_pair(pcoin, i));\n \n         if (n == nTargetValue)\n         {\n@@ -2086,7 +2084,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int\n     // Solve subset sum by stochastic approximation\n     std::sort(vValue.begin(), vValue.end(), CompareValueOnly());\n     std::reverse(vValue.begin(), vValue.end());\n-    vector<char> vfBest;\n+    std::vector<char> vfBest;\n     CAmount nBest;\n \n     ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);\n@@ -2119,9 +2117,9 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int\n     return true;\n }\n \n-bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n {\n-    vector<COutput> vCoins(vAvailableCoins);\n+    std::vector<COutput> vCoins(vAvailableCoins);\n \n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n     if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n@@ -2131,37 +2129,37 @@ bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount&\n             if (!out.fSpendable)\n                  continue;\n             nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(make_pair(out.tx, out.i));\n+            setCoinsRet.insert(std::make_pair(out.tx, out.i));\n         }\n         return (nValueRet >= nTargetValue);\n     }\n \n     // calculate value from preset inputs and store them\n-    set<pair<const CWalletTx*, uint32_t> > setPresetCoins;\n+    std::set<std::pair<const CWalletTx*, uint32_t> > setPresetCoins;\n     CAmount nValueFromPresetInputs = 0;\n \n     std::vector<COutPoint> vPresetInputs;\n     if (coinControl)\n         coinControl->ListSelected(vPresetInputs);\n     BOOST_FOREACH(const COutPoint& outpoint, vPresetInputs)\n     {\n-        map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n+        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())\n         {\n             const CWalletTx* pcoin = &it->second;\n             // Clearly invalid input, fail\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n             nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n-            setPresetCoins.insert(make_pair(pcoin, outpoint.n));\n+            setPresetCoins.insert(std::make_pair(pcoin, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n     // remove preset inputs from vCoins\n-    for (vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n+    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n     {\n-        if (setPresetCoins.count(make_pair(it->tx, it->i)))\n+        if (setPresetCoins.count(std::make_pair(it->tx, it->i)))\n             it = vCoins.erase(it);\n         else\n             ++it;\n@@ -2183,7 +2181,7 @@ bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount&\n \n bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool overrideEstimatedFeeRate, const CFeeRate& specificFeeRate, int& nChangePosInOut, std::string& strFailReason, bool includeWatching, bool lockUnspents, const CTxDestination& destChange)\n {\n-    vector<CRecipient> vecSend;\n+    std::vector<CRecipient> vecSend;\n \n     // Turn the txout set into a CRecipient vector\n     BOOST_FOREACH(const CTxOut& txOut, tx.vout)\n@@ -2228,7 +2226,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool ov\n     return true;\n }\n \n-bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n+bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n                                 int& nChangePosInOut, std::string& strFailReason, const CCoinControl* coinControl, bool sign)\n {\n     CAmount nValue = 0;\n@@ -2342,7 +2340,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 }\n \n                 // Choose coins to use\n-                set<pair<const CWalletTx*,unsigned int> > setCoins;\n+                std::set<std::pair<const CWalletTx*,unsigned int> > setCoins;\n                 CAmount nValueIn = 0;\n                 if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl))\n                 {\n@@ -2439,7 +2437,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                             return false;\n                         }\n \n-                        vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                         txNew.vout.insert(position, newTxOut);\n                     }\n                 }\n@@ -2609,7 +2607,7 @@ bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwa\n \n     laccentries.push_back(acentry);\n     CAccountingEntry & entry = laccentries.back();\n-    wtxOrdered.insert(make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n+    wtxOrdered.insert(std::make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n \n     return true;\n }\n@@ -2669,7 +2667,7 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     return DB_LOAD_OK;\n }\n \n-DBErrors CWallet::ZapSelectTx(vector<uint256>& vHashIn, vector<uint256>& vHashOut)\n+DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n     if (!fFileBacked)\n         return DB_LOAD_OK;\n@@ -2719,7 +2717,7 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n }\n \n \n-bool CWallet::SetAddressBook(const CTxDestination& address, const string& strName, const string& strPurpose)\n+bool CWallet::SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& strPurpose)\n {\n     bool fUpdated = false;\n     {\n@@ -2748,7 +2746,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n         {\n             // Delete destdata tuples associated with address\n             std::string strAddress = CBitcoinAddress(address).ToString();\n-            BOOST_FOREACH(const PAIRTYPE(string, string) &item, mapAddressBook[address].destdata)\n+            BOOST_FOREACH(const PAIRTYPE(std::string, std::string) &item, mapAddressBook[address].destdata)\n             {\n                 CWalletDB(strWalletFile).EraseDestData(strAddress, item.first);\n             }\n@@ -2791,7 +2789,7 @@ bool CWallet::NewKeyPool()\n         if (IsLocked())\n             return false;\n \n-        int64_t nKeys = max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t)0);\n+        int64_t nKeys = std::max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t)0);\n         for (int i = 0; i < nKeys; i++)\n         {\n             int64_t nIndex = i+1;\n@@ -2818,15 +2816,15 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n         if (kpSize > 0)\n             nTargetSize = kpSize;\n         else\n-            nTargetSize = max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n+            nTargetSize = std::max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n \n         while (setKeyPool.size() < (nTargetSize + 1))\n         {\n             int64_t nEnd = 1;\n             if (!setKeyPool.empty())\n                 nEnd = *(--setKeyPool.end()) + 1;\n             if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n-                throw runtime_error(std::string(__func__) + \": writing generated key failed\");\n+                throw std::runtime_error(std::string(__func__) + \": writing generated key failed\");\n             setKeyPool.insert(nEnd);\n             LogPrintf(\"keypool added key %d, size=%u\\n\", nEnd, setKeyPool.size());\n         }\n@@ -2853,9 +2851,9 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n         nIndex = *(setKeyPool.begin());\n         setKeyPool.erase(setKeyPool.begin());\n         if (!walletdb.ReadPool(nIndex, keypool))\n-            throw runtime_error(std::string(__func__) + \": read failed\");\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n         if (!HaveKey(keypool.vchPubKey.GetID()))\n-            throw runtime_error(std::string(__func__) + \": unknown key in key pool\");\n+            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n         assert(keypool.vchPubKey.IsValid());\n         LogPrintf(\"keypool reserve %d\\n\", nIndex);\n     }\n@@ -2914,14 +2912,14 @@ int64_t CWallet::GetOldestKeyPoolTime()\n     CWalletDB walletdb(strWalletFile);\n     int64_t nIndex = *(setKeyPool.begin());\n     if (!walletdb.ReadPool(nIndex, keypool))\n-        throw runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n+        throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n     assert(keypool.vchPubKey.IsValid());\n     return keypool.nTime;\n }\n \n std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n {\n-    map<CTxDestination, CAmount> balances;\n+    std::map<CTxDestination, CAmount> balances;\n \n     {\n         LOCK(cs_wallet);\n@@ -2959,11 +2957,11 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n     return balances;\n }\n \n-set< set<CTxDestination> > CWallet::GetAddressGroupings()\n+std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n {\n     AssertLockHeld(cs_wallet); // mapWallet\n-    set< set<CTxDestination> > groupings;\n-    set<CTxDestination> grouping;\n+    std::set< std::set<CTxDestination> > groupings;\n+    std::set<CTxDestination> grouping;\n \n     BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n     {\n@@ -3016,20 +3014,20 @@ set< set<CTxDestination> > CWallet::GetAddressGroupings()\n             }\n     }\n \n-    set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n-    map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n-    BOOST_FOREACH(set<CTxDestination> _grouping, groupings)\n+    std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n+    std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n+    BOOST_FOREACH(std::set<CTxDestination> _grouping, groupings)\n     {\n         // make a set of all the groups hit by this new group\n-        set< set<CTxDestination>* > hits;\n-        map< CTxDestination, set<CTxDestination>* >::iterator it;\n+        std::set< std::set<CTxDestination>* > hits;\n+        std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n         BOOST_FOREACH(CTxDestination address, _grouping)\n             if ((it = setmap.find(address)) != setmap.end())\n                 hits.insert((*it).second);\n \n         // merge all hit groups into a new single group and delete old groups\n-        set<CTxDestination>* merged = new set<CTxDestination>(_grouping);\n-        BOOST_FOREACH(set<CTxDestination>* hit, hits)\n+        std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n+        BOOST_FOREACH(std::set<CTxDestination>* hit, hits)\n         {\n             merged->insert(hit->begin(), hit->end());\n             uniqueGroupings.erase(hit);\n@@ -3042,8 +3040,8 @@ set< set<CTxDestination> > CWallet::GetAddressGroupings()\n             setmap[element] = merged;\n     }\n \n-    set< set<CTxDestination> > ret;\n-    BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n+    std::set< std::set<CTxDestination> > ret;\n+    BOOST_FOREACH(std::set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n     {\n         ret.insert(*uniqueGrouping);\n         delete uniqueGrouping;\n@@ -3063,7 +3061,7 @@ CAmount CWallet::GetAccountBalance(CWalletDB& walletdb, const std::string& strAc\n     CAmount nBalance = 0;\n \n     // Tally wallet transactions\n-    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n@@ -3086,11 +3084,11 @@ CAmount CWallet::GetAccountBalance(CWalletDB& walletdb, const std::string& strAc\n std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n {\n     LOCK(cs_wallet);\n-    set<CTxDestination> result;\n+    std::set<CTxDestination> result;\n     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n-        const string& strName = item.second.name;\n+        const std::string& strName = item.second.name;\n         if (strName == strAccount)\n             result.insert(address);\n     }\n@@ -3130,7 +3128,7 @@ void CReserveKey::ReturnKey()\n     vchPubKey = CPubKey();\n }\n \n-void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n+void CWallet::GetAllReserveKeys(std::set<CKeyID>& setAddress) const\n {\n     setAddress.clear();\n \n@@ -3141,11 +3139,11 @@ void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n     {\n         CKeyPool keypool;\n         if (!walletdb.ReadPool(id, keypool))\n-            throw runtime_error(std::string(__func__) + \": read failed\");\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n         assert(keypool.vchPubKey.IsValid());\n         CKeyID keyID = keypool.vchPubKey.GetID();\n         if (!HaveKey(keyID))\n-            throw runtime_error(std::string(__func__) + \": unknown key in key pool\");\n+            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n         setAddress.insert(keyID);\n     }\n }\n@@ -3155,7 +3153,7 @@ void CWallet::UpdatedTransaction(const uint256 &hashTx)\n     {\n         LOCK(cs_wallet);\n         // Only notify UI if this transaction is in this wallet\n-        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n         if (mi != mapWallet.end())\n             NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n     }\n@@ -3742,7 +3740,7 @@ int CMerkleTx::GetBlocksToMaturity() const\n {\n     if (!IsCoinBase())\n         return 0;\n-    return max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n+    return std::max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n }\n \n "
      },
      {
        "sha": "53bfcc82893c3f98a4e98a58f32c55899b7e88fe",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 43,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=2bfef03102cd5063e0a7b8d30f71d2e6bf7e0900",
        "patch": "@@ -20,38 +20,36 @@\n #include <boost/foreach.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n static uint64_t nAccountingEntryNumber = 0;\n \n //\n // CWalletDB\n //\n \n-bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n+bool CWalletDB::WriteName(const std::string& strAddress, const std::string& strName)\n {\n     nWalletDBUpdated++;\n-    return Write(make_pair(string(\"name\"), strAddress), strName);\n+    return Write(make_pair(std::string(\"name\"), strAddress), strName);\n }\n \n-bool CWalletDB::EraseName(const string& strAddress)\n+bool CWalletDB::EraseName(const std::string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n     nWalletDBUpdated++;\n-    return Erase(make_pair(string(\"name\"), strAddress));\n+    return Erase(make_pair(std::string(\"name\"), strAddress));\n }\n \n-bool CWalletDB::WritePurpose(const string& strAddress, const string& strPurpose)\n+bool CWalletDB::WritePurpose(const std::string& strAddress, const std::string& strPurpose)\n {\n     nWalletDBUpdated++;\n-    return Write(make_pair(string(\"purpose\"), strAddress), strPurpose);\n+    return Write(make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n }\n \n-bool CWalletDB::ErasePurpose(const string& strPurpose)\n+bool CWalletDB::ErasePurpose(const std::string& strPurpose)\n {\n     nWalletDBUpdated++;\n-    return Erase(make_pair(string(\"purpose\"), strPurpose));\n+    return Erase(make_pair(std::string(\"purpose\"), strPurpose));\n }\n \n bool CWalletDB::WriteTx(const CWalletTx& wtx)\n@@ -175,15 +173,15 @@ bool CWalletDB::WriteMinVersion(int nVersion)\n     return Write(std::string(\"minversion\"), nVersion);\n }\n \n-bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n+bool CWalletDB::ReadAccount(const std::string& strAccount, CAccount& account)\n {\n     account.SetNull();\n-    return Read(make_pair(string(\"acc\"), strAccount), account);\n+    return Read(make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n-bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n+bool CWalletDB::WriteAccount(const std::string& strAccount, const CAccount& account)\n {\n-    return Write(make_pair(string(\"acc\"), strAccount), account);\n+    return Write(make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n@@ -196,9 +194,9 @@ bool CWalletDB::WriteAccountingEntry_Backend(const CAccountingEntry& acentry)\n     return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n }\n \n-CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n+CAmount CWalletDB::GetAccountCreditDebit(const std::string& strAccount)\n {\n-    list<CAccountingEntry> entries;\n+    std::list<CAccountingEntry> entries;\n     ListAccountCreditDebit(strAccount, entries);\n \n     CAmount nCreditDebit = 0;\n@@ -208,20 +206,20 @@ CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n     return nCreditDebit;\n }\n \n-void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n+void CWalletDB::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries)\n {\n     bool fAllAccounts = (strAccount == \"*\");\n \n     Dbc* pcursor = GetCursor();\n     if (!pcursor)\n-        throw runtime_error(std::string(__func__) + \": cannot create DB cursor\");\n+        throw std::runtime_error(std::string(__func__) + \": cannot create DB cursor\");\n     bool setRange = true;\n     while (true)\n     {\n         // Read next record\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         if (setRange)\n-            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? string(\"\") : strAccount), uint64_t(0)));\n+            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? std::string(\"\") : strAccount), uint64_t(0)));\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         int ret = ReadAtCursor(pcursor, ssKey, ssValue, setRange);\n         setRange = false;\n@@ -230,11 +228,11 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n         else if (ret != 0)\n         {\n             pcursor->close();\n-            throw runtime_error(std::string(__func__) + \": error scanning DB\");\n+            throw std::runtime_error(std::string(__func__) + \": error scanning DB\");\n         }\n \n         // Unserialize\n-        string strType;\n+        std::string strType;\n         ssKey >> strType;\n         if (strType != \"acentry\")\n             break;\n@@ -259,7 +257,7 @@ class CWalletScanState {\n     bool fIsEncrypted;\n     bool fAnyUnordered;\n     int nFileVersion;\n-    vector<uint256> vWalletUpgrade;\n+    std::vector<uint256> vWalletUpgrade;\n \n     CWalletScanState() {\n         nKeys = nCKeys = nKeyMeta = 0;\n@@ -271,7 +269,7 @@ class CWalletScanState {\n \n bool\n ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, string& strType, string& strErr)\n+             CWalletScanState &wss, std::string& strType, std::string& strErr)\n {\n     try {\n         // Unserialize\n@@ -280,13 +278,13 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         ssKey >> strType;\n         if (strType == \"name\")\n         {\n-            string strAddress;\n+            std::string strAddress;\n             ssKey >> strAddress;\n             ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].name;\n         }\n         else if (strType == \"purpose\")\n         {\n-            string strAddress;\n+            std::string strAddress;\n             ssKey >> strAddress;\n             ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].purpose;\n         }\n@@ -327,7 +325,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         }\n         else if (strType == \"acentry\")\n         {\n-            string strAccount;\n+            std::string strAccount;\n             ssKey >> strAccount;\n             uint64_t nNumber;\n             ssKey >> nNumber;\n@@ -443,7 +441,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                 strErr = \"Error reading wallet database: CPubKey corrupt\";\n                 return false;\n             }\n-            vector<unsigned char> vchPrivKey;\n+            std::vector<unsigned char> vchPrivKey;\n             ssValue >> vchPrivKey;\n             wss.nCKeys++;\n \n@@ -533,7 +531,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n     return true;\n }\n \n-static bool IsKeyType(string strType)\n+static bool IsKeyType(std::string strType)\n {\n     return (strType== \"key\" || strType == \"wkey\" ||\n             strType == \"mkey\" || strType == \"ckey\");\n@@ -549,7 +547,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     try {\n         LOCK(pwallet->cs_wallet);\n         int nMinVersion = 0;\n-        if (Read((string)\"minversion\", nMinVersion))\n+        if (Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DB_TOO_NEW;\n@@ -579,7 +577,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             }\n \n             // Try to be tolerant of single corrupt records:\n-            string strType, strErr;\n+            std::string strType, strErr;\n             if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n             {\n                 // losing keys is considered a catastrophic error, anything else\n@@ -646,7 +644,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     return result;\n }\n \n-DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vector<CWalletTx>& vWtx)\n+DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n {\n     pwallet->vchDefaultKey = CPubKey();\n     bool fNoncriticalErrors = false;\n@@ -655,7 +653,7 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n     try {\n         LOCK(pwallet->cs_wallet);\n         int nMinVersion = 0;\n-        if (Read((string)\"minversion\", nMinVersion))\n+        if (Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DB_TOO_NEW;\n@@ -684,7 +682,7 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n                 return DB_CORRUPT;\n             }\n \n-            string strType;\n+            std::string strType;\n             ssKey >> strType;\n             if (strType == \"tx\") {\n                 uint256 hash;\n@@ -712,11 +710,11 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n     return result;\n }\n \n-DBErrors CWalletDB::ZapSelectTx(CWallet* pwallet, vector<uint256>& vTxHashIn, vector<uint256>& vTxHashOut)\n+DBErrors CWalletDB::ZapSelectTx(CWallet* pwallet, std::vector<uint256>& vTxHashIn, std::vector<uint256>& vTxHashOut)\n {\n     // build list of wallet TXs and hashes\n-    vector<uint256> vTxHash;\n-    vector<CWalletTx> vWtx;\n+    std::vector<uint256> vTxHash;\n+    std::vector<CWalletTx> vWtx;\n     DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx);\n     if (err != DB_LOAD_OK) {\n         return err;\n@@ -727,7 +725,7 @@ DBErrors CWalletDB::ZapSelectTx(CWallet* pwallet, vector<uint256>& vTxHashIn, ve\n \n     // erase each matching wallet TX\n     bool delerror = false;\n-    vector<uint256>::iterator it = vTxHashIn.begin();\n+    std::vector<uint256>::iterator it = vTxHashIn.begin();\n     BOOST_FOREACH (uint256 hash, vTxHash) {\n         while (it < vTxHashIn.end() && (*it) < hash) {\n             it++;\n@@ -751,10 +749,10 @@ DBErrors CWalletDB::ZapSelectTx(CWallet* pwallet, vector<uint256>& vTxHashIn, ve\n     return DB_LOAD_OK;\n }\n \n-DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n+DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n-    vector<uint256> vTxHash;\n+    std::vector<uint256> vTxHash;\n     DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx);\n     if (err != DB_LOAD_OK)\n         return err;\n@@ -768,7 +766,7 @@ DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n     return DB_LOAD_OK;\n }\n \n-void ThreadFlushWalletDB(const string& strFile)\n+void ThreadFlushWalletDB(const std::string& strFile)\n {\n     // Make this thread recognisable as the wallet flushing thread\n     RenameThread(\"bitcoin-wallet\");\n@@ -800,7 +798,7 @@ void ThreadFlushWalletDB(const string& strFile)\n             {\n                 // Don't do this if any databases are in use\n                 int nRefCount = 0;\n-                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n+                std::map<std::string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n                 while (mi != bitdb.mapFileUseCount.end())\n                 {\n                     nRefCount += (*mi).second;\n@@ -810,7 +808,7 @@ void ThreadFlushWalletDB(const string& strFile)\n                 if (nRefCount == 0)\n                 {\n                     boost::this_thread::interruption_point();\n-                    map<string, int>::iterator _mi = bitdb.mapFileUseCount.find(strFile);\n+                    std::map<std::string, int>::iterator _mi = bitdb.mapFileUseCount.find(strFile);\n                     if (_mi != bitdb.mapFileUseCount.end())\n                     {\n                         LogPrint(\"db\", \"Flushing %s\\n\", strFile);\n@@ -886,7 +884,7 @@ bool CWalletDB::Recover(CDBEnv& dbenv, const std::string& filename, bool fOnlyKe\n         {\n             CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n             CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n-            string strType, strErr;\n+            std::string strType, strErr;\n             bool fReadOK;\n             {\n                 // Required in LoadKeyMetadata():"
      }
    ]
  }
]