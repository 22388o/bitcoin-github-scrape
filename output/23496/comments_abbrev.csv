mjdietzx,2021-11-16 16:38:49,Code Review ACK fa186314840a7da165adbfa86a316d8a4c34b706,https://github.com/bitcoin/bitcoin/pull/23496#issuecomment-970453631,970453631,
MarcoFalke,2021-11-16 16:43:13,Rebased to fix silent merge conflict. Should be trivial to re-ACK,https://github.com/bitcoin/bitcoin/pull/23496#issuecomment-970457611,970457611,
mjdietzx,2021-11-16 20:16:27,re-ACK fa74d45,https://github.com/bitcoin/bitcoin/pull/23496#issuecomment-970643926,970643926,
sipa,2021-11-16 20:33:54,utACK fa74d4530615cfa02cf32a16fab6b13908266e6f,https://github.com/bitcoin/bitcoin/pull/23496#issuecomment-970656427,970656427,
mjdietzx,2021-11-16 15:53:30,"I'm a little confused about this. At first I was wondering why `KeepDiff` couldn't just simply do:\n\n```c++\ndiff[entry] = true;\n```\n\nBut it seems that you're actually trying to account for the case where we encounter the same `entry` value at different iterations. ie `sketch_a.Add(7);` and then later on `sketch_b.Add(7);`, and you want to track that this is not a difference b/w the sets",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750416849,750416849,src/test/fuzz/minisketch.cpp
mjdietzx,2021-11-16 16:00:16,"We'll probably only hit this condition ~3% of the time, right (very roughly)?",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750423977,750423977,src/test/fuzz/minisketch.cpp
mjdietzx,2021-11-16 16:15:51,"Am I correct in my understanding of Minisketch, that if `if (capacity < num_diff)` then `ssize_t num_differences = minisketch_decode(sketch_diff, capacity, differences);` will return `<0` indicating that there are more than `capacity` differences in the set? Can we add an `else` clause and assert this?",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750439210,750439210,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 16:24:52,"> Am I correct?\n\nYes",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750448194,750448194,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 16:26:13,"> We'll probably only hit this condition ~3% of the time, right (very roughly)?\n\nThat depends on the fuzz engine's randomness and exploration algorithm.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750449440,750449440,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 16:27:10,"> will return <0\n\nI had the same thinking, but it may still succeed ""accidentally"" on some inputs.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750450423,750450423,src/test/fuzz/minisketch.cpp
mjdietzx,2021-11-16 16:31:31,"Ok, then my concern is: collisions like this should be so rare that I'm not even sure we should have the logic to catch these cases (maybe just a comment would be good enough)?\n\nBut, if we do want to account for these collisions correctly, then I'm not sure this does the job. Bc/ in this case if you add the same element to `sketch_a` twice, it looks like the diff gets flipped. etc...\n\nAll ",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750454600,750454600,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 16:33:10,"Adding the same element twice to a minisketch set will erase it. This is a feature, not a rare edge case.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750456205,750456205,src/test/fuzz/minisketch.cpp
mjdietzx,2021-11-16 16:33:43,"Yep that makes sense. That's where I arrived after reading the Minisketch README more, but wanted to double check anyways",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750456662,750456662,src/test/fuzz/minisketch.cpp
mjdietzx,2021-11-16 16:36:23,"Ah wow, interesting. I kinda wondered this while reading the README but figured it wasn't the case. Anyways, would it make sense to reduce the max possible value of `const auto entry{fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1, std::numeric_limits<uint32_t>::max() - 1)};` so that we see these ""collisions"" normally and get more test coverage?",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750459221,750459221,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 16:37:49,"I expect the fuzz engine to copy the bytes in the input, so a collision might even be the ""normal"" case.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750460636,750460636,src/test/fuzz/minisketch.cpp
sipa,2021-11-16 16:39:19,"What @MarcoFalke said, but also: ""rare"" isn't relevant for fuzz tests. The inputs are *not* uniformly distributed; the fuzzer is actively trying to bias the inputs to trigger ""rare"" edge cases.\n\nEDIT: wrote this seeing marco's latest comment above.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750462054,750462054,src/test/fuzz/minisketch.cpp
mjdietzx,2021-11-16 16:48:28,"Interesting, thanks",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750470906,750470906,src/test/fuzz/minisketch.cpp
sipa,2021-11-16 16:52:00,"I find this piece of code to compare `dec` with the expected diff a bit convoluted. What about:\n\n```\nassert(dec.size() == num_diff));\nfor (auto d : dec) assert(diff[d]);\n```\n\n?",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750474162,750474162,src/test/fuzz/minisketch.cpp
sipa,2021-11-16 17:04:33,"FWIW, you can use `[](auto n, const auto e&) { return n + e.second; }` as lambda too.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750485672,750485672,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 18:19:02,"Good idea, done.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750544727,750544727,src/test/fuzz/minisketch.cpp
MarcoFalke,2021-11-16 18:19:18,"Nice. I didn't know this was added in C++14.\n\nDone.",https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750544950,750544950,src/test/fuzz/minisketch.cpp
sipa,2021-11-16 20:33:33,Micronit: `diff[entry] ^= true;` or `diff[entry] ^= 1;` also works (feel free to ignore).,https://github.com/bitcoin/bitcoin/pull/23496#discussion_r750640068,750640068,src/test/fuzz/minisketch.cpp
