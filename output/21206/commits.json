[
  {
    "sha": "d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
    "node_id": "C_kwDOABII59oAKGQ4ZWU4ZjNjZDMyYmJmZWZlYzkzMTcyNGY1Nzk4Y2JiMDg4Y2ViNmY",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-02-17T03:36:26Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-11-15T14:11:44Z"
      },
      "message": "refactor: Make CWalletTx sync state type-safe\n\nCurrent CWalletTx state representation makes it possible to set\ninconsistent states that won't be handled correctly by wallet sync code\nor serialized & deserialized back into the same form.\n\nFor example, it is possible to call setConflicted without setting a\nconflicting block hash, or setConfirmed with no transaction index. And\nit's possible update individual m_confirm and fInMempool data fields\nwithout setting an overall consistent state that can be serialized and\nhandled correctly.\n\nFix this without changing behavior by using std::variant, instead of an\nenum and collection of fields, to represent sync state, so state\ntracking code is safer and more legible.\n\nThis is a first step to fixing state tracking bugs\nhttps://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Transaction-Conflict-Tracking,\nby adding an extra margin of safety that can prevent new bugs from being\nintroduced as existing bugs are fixed.",
      "tree": {
        "sha": "09bea6475822b6b37ca0050d03a4394946af35a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/09bea6475822b6b37ca0050d03a4394946af35a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2efc8c0999a4b99cfe3076f7312806e83e778261",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2efc8c0999a4b99cfe3076f7312806e83e778261",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2efc8c0999a4b99cfe3076f7312806e83e778261"
      }
    ],
    "stats": {
      "total": 431,
      "additions": 257,
      "deletions": 174
    },
    "files": [
      {
        "sha": "59043c6dd080cbe7c5d69998c20d53c7196be6f7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -246,6 +246,7 @@ BITCOIN_CORE_H = \\\n   util/macros.h \\\n   util/message.h \\\n   util/moneystr.h \\\n+  util/overloaded.h \\\n   util/rbf.h \\\n   util/readwritefile.h \\\n   util/serfloat.h \\"
      },
      {
        "sha": "f5d5f07c25c1fe690fc541ff7a02b65785a468f7",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -159,6 +159,7 @@ BITCOIN_TESTS += \\\n   wallet/test/wallet_tests.cpp \\\n   wallet/test/walletdb_tests.cpp \\\n   wallet/test/wallet_crypto_tests.cpp \\\n+  wallet/test/wallet_transaction_tests.cpp \\\n   wallet/test/coinselector_tests.cpp \\\n   wallet/test/init_tests.cpp \\\n   wallet/test/ismine_tests.cpp \\"
      },
      {
        "sha": "3c24fee60f7aad87fa001b5c0274e1c258297519",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -18,7 +18,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n     tx.nLockTime = nextLockTime++; // so all transactions get different hashes\n     tx.vout.resize(1);\n     tx.vout[0].nValue = nValue;\n-    wtxs.push_back(std::make_unique<CWalletTx>(MakeTransactionRef(std::move(tx))));\n+    wtxs.push_back(std::make_unique<CWalletTx>(MakeTransactionRef(std::move(tx)), TxStateInactive{}));\n }\n \n // Simple benchmark for wallet coin selection. Note that it maybe be necessary"
      },
      {
        "sha": "6be7453f813f27b22120ed74bf4389ddc0c2e2f3",
        "filename": "src/util/overloaded.h",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/util/overloaded.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/util/overloaded.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/overloaded.h?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -0,0 +1,22 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_OVERLOADED_H\n+#define BITCOIN_UTIL_OVERLOADED_H\n+\n+namespace util {\n+//! Overloaded helper for std::visit. This helper and std::visit in general are\n+//! useful to write code that switches on a variant type. Unlike if/else-if and\n+//! switch/case statements, std::visit will trigger compile errors if there are\n+//! unhandled cases.\n+//!\n+//! Implementation comes from and example usage can be found at\n+//! https://en.cppreference.com/w/cpp/utility/variant/visit#Example\n+template<class... Ts> struct Overloaded : Ts... { using Ts::operator()...; };\n+\n+//! Explicit deduction guide (not needed as of C++20)\n+template<class... Ts> Overloaded(Ts...) -> Overloaded<Ts...>;\n+} // namespace util\n+\n+#endif // BITCOIN_UTIL_OVERLOADED_H"
      },
      {
        "sha": "6489e2a5fcddabd4e073d6c8785f7e4b95b5e1cc",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -82,7 +82,10 @@ WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n WalletTxStatus MakeWalletTxStatus(const CWallet& wallet, const CWalletTx& wtx)\n {\n     WalletTxStatus result;\n-    result.block_height = wtx.m_confirm.block_height > 0 ? wtx.m_confirm.block_height : std::numeric_limits<int>::max();\n+    result.block_height =\n+        wtx.state<TxStateConfirmed>() ? wtx.state<TxStateConfirmed>()->confirmed_block_height :\n+        wtx.state<TxStateConflicted>() ? wtx.state<TxStateConflicted>()->conflicting_block_height :\n+        std::numeric_limits<int>::max();\n     result.blocks_to_maturity = wallet.GetTxBlocksToMaturity(wtx);\n     result.depth_in_main_chain = wallet.GetTxDepthInMainChain(wtx);\n     result.time_received = wtx.nTimeReceived;"
      },
      {
        "sha": "ef276d4a040020ca36bcbde4880ade83fe13e709",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -369,11 +369,9 @@ RPCHelpMan importprunedfunds()\n \n     unsigned int txnIndex = vIndex[it - vMatch.begin()];\n \n-    CWalletTx::Confirmation confirm(CWalletTx::Status::CONFIRMED, height, merkleBlock.header.GetHash(), txnIndex);\n-\n     CTransactionRef tx_ref = MakeTransactionRef(tx);\n     if (pwallet->IsMine(*tx_ref)) {\n-        pwallet->AddToWallet(std::move(tx_ref), confirm);\n+        pwallet->AddToWallet(std::move(tx_ref), TxStateConfirmed{merkleBlock.header.GetHash(), height, static_cast<int>(txnIndex)});\n         return NullUniValue;\n     }\n "
      },
      {
        "sha": "4d63f99999c0c15d1aa79d8cefb0a8570f45721e",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -166,13 +166,13 @@ static void WalletTxToJSON(const CWallet& wallet, const CWalletTx& wtx, UniValue\n     entry.pushKV(\"confirmations\", confirms);\n     if (wtx.IsCoinBase())\n         entry.pushKV(\"generated\", true);\n-    if (confirms > 0)\n+    if (auto* conf = wtx.state<TxStateConfirmed>())\n     {\n-        entry.pushKV(\"blockhash\", wtx.m_confirm.hashBlock.GetHex());\n-        entry.pushKV(\"blockheight\", wtx.m_confirm.block_height);\n-        entry.pushKV(\"blockindex\", wtx.m_confirm.nIndex);\n+        entry.pushKV(\"blockhash\", conf->confirmed_block_hash.GetHex());\n+        entry.pushKV(\"blockheight\", conf->confirmed_block_height);\n+        entry.pushKV(\"blockindex\", conf->position_in_block);\n         int64_t block_time;\n-        CHECK_NONFATAL(chain.findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(block_time)));\n+        CHECK_NONFATAL(chain.findBlock(conf->confirmed_block_hash, FoundBlock().time(block_time)));\n         entry.pushKV(\"blocktime\", block_time);\n     } else {\n         entry.pushKV(\"trusted\", CachedTxIsTrusted(wallet, wtx));"
      },
      {
        "sha": "8f985f31eec64b40a60954f89bccf4ccfd8816ab",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -74,7 +74,7 @@ static void add_coin(std::vector<COutput>& coins, CWallet& wallet, const CAmount\n     uint256 txid = tx.GetHash();\n \n     LOCK(wallet.cs_wallet);\n-    auto ret = wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(txid), std::forward_as_tuple(MakeTransactionRef(std::move(tx))));\n+    auto ret = wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(txid), std::forward_as_tuple(MakeTransactionRef(std::move(tx)), TxStateInactive{}));\n     assert(ret.second);\n     CWalletTx& wtx = (*ret.first).second;\n     if (fIsFromMe)"
      },
      {
        "sha": "7bc2bb5583ec6f2d20184daee3a1e56ef84da116",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -34,12 +34,12 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)\n     CDataStream s_prev_tx1(ParseHex(\"0200000000010158e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7501000000171600145f275f436b09a8cc9a2eb2a2f528485c68a56323feffffff02d8231f1b0100000017a914aed962d6654f9a2b36608eb9d64d2b260db4f1118700c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88702483045022100a22edcc6e5bc511af4cc4ae0de0fcd75c7e04d8c1c3a8aa9d820ed4b967384ec02200642963597b9b1bc22c75e9f3e117284a962188bf5e8a74c895089046a20ad770121035509a48eb623e10aace8bfd0212fdb8a8e5af3c94b0b133b95e114cab89e4f7965000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx1;\n     s_prev_tx1 >> prev_tx1;\n-    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx1->GetHash()), std::forward_as_tuple(prev_tx1));\n+    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx1->GetHash()), std::forward_as_tuple(prev_tx1, TxStateInactive{}));\n \n     CDataStream s_prev_tx2(ParseHex(\"0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx2;\n     s_prev_tx2 >> prev_tx2;\n-    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx2->GetHash()), std::forward_as_tuple(prev_tx2));\n+    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx2->GetHash()), std::forward_as_tuple(prev_tx2, TxStateInactive{}));\n \n     // Import descriptors for keys and scripts\n     import_descriptor(m_wallet, \"sh(multi(2,xprv9s21ZrQH143K2LE7W4Xf3jATf9jECxSb7wj91ZnmY4qEJrS66Qru9RFqq8xbkgT32ya6HqYJweFdJUEDf5Q6JFV7jMiUws7kQfe6Tv4RbfN/0h/0h/0h,xprv9s21ZrQH143K2LE7W4Xf3jATf9jECxSb7wj91ZnmY4qEJrS66Qru9RFqq8xbkgT32ya6HqYJweFdJUEDf5Q6JFV7jMiUws7kQfe6Tv4RbfN/0h/0h/1h))\");"
      },
      {
        "sha": "9a1398e970ca427f5b5f9cafc7cb269b9e07beec",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 13,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -330,17 +330,14 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n     CWallet wallet(m_node.chain.get(), \"\", m_args, CreateDummyWalletDatabase());\n-    CWalletTx wtx(m_coinbase_txns.back());\n+    CWalletTx wtx{m_coinbase_txns.back(), TxStateConfirmed{m_node.chainman->ActiveChain().Tip()->GetBlockHash(), m_node.chainman->ActiveChain().Height(), /*position_in_block=*/0}};\n \n     LOCK(wallet.cs_wallet);\n     wallet.SetWalletFlag(WALLET_FLAG_DESCRIPTORS);\n     wallet.SetupDescriptorScriptPubKeyMans();\n \n     wallet.SetLastBlockProcessed(m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n \n-    CWalletTx::Confirmation confirm(CWalletTx::Status::CONFIRMED, m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash(), 0);\n-    wtx.m_confirm = confirm;\n-\n     // Call GetImmatureCredit() once before adding the key to the wallet to\n     // cache the current immature credit amount, which is 0.\n     BOOST_CHECK_EQUAL(CachedTxGetImmatureCredit(wallet, wtx), 0);\n@@ -355,7 +352,7 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n {\n     CMutableTransaction tx;\n-    CWalletTx::Confirmation confirm;\n+    TxState state = TxStateInactive{};\n     tx.nLockTime = lockTime;\n     SetMockTime(mockTime);\n     CBlockIndex* block = nullptr;\n@@ -367,13 +364,13 @@ static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lock\n         block = inserted.first->second;\n         block->nTime = blockTime;\n         block->phashBlock = &hash;\n-        confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, hash, 0};\n+        state = TxStateConfirmed{hash, block->nHeight, /*position_in_block=*/0};\n     }\n-\n-    // If transaction is already in map, to avoid inconsistencies, unconfirmation\n-    // is needed before confirm again with different block.\n-    return wallet.AddToWallet(MakeTransactionRef(tx), confirm, [&](CWalletTx& wtx, bool /* new_tx */) {\n-        wtx.setUnconfirmed();\n+    return wallet.AddToWallet(MakeTransactionRef(tx), state, [&](CWalletTx& wtx, bool /* new_tx */) {\n+        // Assign wtx.m_state to simplify test and avoid the need to simulate\n+        // reorg events. Without this, AddToWallet asserts false when the same\n+        // transaction is confirmed in different blocks.\n+        wtx.m_state = state;\n         return true;\n     })->nTimeSmart;\n }\n@@ -534,8 +531,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         wallet->SetLastBlockProcessed(wallet->GetLastBlockHeight() + 1, m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n         auto it = wallet->mapWallet.find(tx->GetHash());\n         BOOST_CHECK(it != wallet->mapWallet.end());\n-        CWalletTx::Confirmation confirm(CWalletTx::Status::CONFIRMED, m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash(), 1);\n-        it->second.m_confirm = confirm;\n+        it->second.m_state = TxStateConfirmed{m_node.chainman->ActiveChain().Tip()->GetBlockHash(), m_node.chainman->ActiveChain().Height(), /*position_in_block=*/1};\n         return it->second;\n     }\n "
      },
      {
        "sha": "5ef2904f669b5607054b5622ef0d4feaf790091f",
        "filename": "src/wallet/test/wallet_transaction_tests.cpp",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/wallet_transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/test/wallet_transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_transaction_tests.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/transaction.h>\n+\n+#include <wallet/test/wallet_test_fixture.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(wallet_transaction_tests, WalletTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(roundtrip)\n+{\n+    for (uint8_t hash = 0; hash < 5; ++hash) {\n+        for (int index = -2; index < 3; ++index) {\n+            TxState state = TxStateInterpretSerialized(TxStateUnrecognized{uint256{hash}, index});\n+            BOOST_CHECK_EQUAL(TxStateSerializedBlockHash(state), uint256{hash});\n+            BOOST_CHECK_EQUAL(TxStateSerializedIndex(state), index);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a926c0ecc15721c8a0fef6386bcec8b4de1f2f25",
        "filename": "src/wallet/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/transaction.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -15,7 +15,7 @@ bool CWalletTx::IsEquivalentTo(const CWalletTx& _tx) const\n \n bool CWalletTx::InMempool() const\n {\n-    return fInMempool;\n+    return state<TxStateInMempool>();\n }\n \n int64_t CWalletTx::GetTxTime() const"
      },
      {
        "sha": "52d72cccf3d2f1e0ec43bb5735f604b9644e1a29",
        "filename": "src/wallet/transaction.h",
        "status": "modified",
        "additions": 105,
        "deletions": 75,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/transaction.h?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -11,12 +11,102 @@\n #include <wallet/ismine.h>\n #include <threadsafety.h>\n #include <tinyformat.h>\n+#include <util/overloaded.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n \n #include <list>\n+#include <variant>\n #include <vector>\n \n+//! State of transaction confirmed in a block.\n+struct TxStateConfirmed {\n+    uint256 confirmed_block_hash;\n+    int confirmed_block_height;\n+    int position_in_block;\n+\n+    explicit TxStateConfirmed(const uint256& block_hash, int height, int index) : confirmed_block_hash(block_hash), confirmed_block_height(height), position_in_block(index) {}\n+};\n+\n+//! State of transaction added to mempool.\n+struct TxStateInMempool {\n+};\n+\n+//! State of rejected transaction that conflicts with a confirmed block.\n+struct TxStateConflicted {\n+    uint256 conflicting_block_hash;\n+    int conflicting_block_height;\n+\n+    explicit TxStateConflicted(const uint256& block_hash, int height) : conflicting_block_hash(block_hash), conflicting_block_height(height) {}\n+};\n+\n+//! State of transaction not confirmed or conflicting with a known block and\n+//! not in the mempool. May conflict with the mempool, or with an unknown block,\n+//! or be abandoned, never broadcast, or rejected from the mempool for another\n+//! reason.\n+struct TxStateInactive {\n+    bool abandoned;\n+\n+    explicit TxStateInactive(bool abandoned = false) : abandoned(abandoned) {}\n+};\n+\n+//! State of transaction loaded in an unrecognized state with unexpected hash or\n+//! index values. Treated as inactive (with serialized hash and index values\n+//! preserved) by default, but may enter another state if transaction is added\n+//! to the mempool, or confirmed, or abandoned, or found conflicting.\n+struct TxStateUnrecognized {\n+    uint256 block_hash;\n+    int index;\n+\n+    TxStateUnrecognized(const uint256& block_hash, int index) : block_hash(block_hash), index(index) {}\n+};\n+\n+//! All possible CWalletTx states\n+using TxState = std::variant<TxStateConfirmed, TxStateInMempool, TxStateConflicted, TxStateInactive, TxStateUnrecognized>;\n+\n+//! Subset of states transaction sync logic is implemented to handle.\n+using SyncTxState = std::variant<TxStateConfirmed, TxStateInMempool, TxStateInactive>;\n+\n+//! Try to interpret deserialized TxStateUnrecognized data as a recognized state.\n+static inline TxState TxStateInterpretSerialized(TxStateUnrecognized data)\n+{\n+    if (data.block_hash == uint256::ZERO) {\n+        if (data.index == 0) return TxStateInactive{};\n+    } else if (data.block_hash == uint256::ONE) {\n+        if (data.index == -1) return TxStateInactive{/*abandoned=*/true};\n+    } else if (data.index >= 0) {\n+        return TxStateConfirmed{data.block_hash, /*height=*/-1, data.index};\n+    } else if (data.index == -1) {\n+        return TxStateConflicted{data.block_hash, /*height=*/-1};\n+    }\n+    return data;\n+}\n+\n+//! Get TxState serialized block hash. Inverse of TxStateInterpretSerialized.\n+static inline uint256 TxStateSerializedBlockHash(const TxState& state)\n+{\n+    return std::visit(util::Overloaded{\n+        [](const TxStateInactive& inactive) { return inactive.abandoned ? uint256::ONE : uint256::ZERO; },\n+        [](const TxStateInMempool& in_mempool) { return uint256::ZERO; },\n+        [](const TxStateConfirmed& confirmed) { return confirmed.confirmed_block_hash; },\n+        [](const TxStateConflicted& conflicted) { return conflicted.conflicting_block_hash; },\n+        [](const TxStateUnrecognized& unrecognized) { return unrecognized.block_hash; }\n+    }, state);\n+}\n+\n+//! Get TxState serialized block index. Inverse of TxStateInterpretSerialized.\n+static inline int TxStateSerializedIndex(const TxState& state)\n+{\n+    return std::visit(util::Overloaded{\n+        [](const TxStateInactive& inactive) { return inactive.abandoned ? -1 : 0; },\n+        [](const TxStateInMempool& in_mempool) { return 0; },\n+        [](const TxStateConfirmed& confirmed) { return confirmed.position_in_block; },\n+        [](const TxStateConflicted& conflicted) { return -1; },\n+        [](const TxStateUnrecognized& unrecognized) { return unrecognized.index; }\n+    }, state);\n+}\n+\n+\n typedef std::map<std::string, std::string> mapValue_t;\n \n /** Legacy class used for deserializing vtxPrev for backwards compatibility.\n@@ -45,12 +135,6 @@ class CMerkleTx\n  */\n class CWalletTx\n {\n-private:\n-    /** Constant used in hashBlock to indicate tx has been abandoned, only used at\n-     * serialization/deserialization to avoid ambiguity with conflicted.\n-     */\n-    static constexpr const uint256& ABANDON_HASH = uint256::ONE;\n-\n public:\n     /**\n      * Key/value map with information about the transaction.\n@@ -111,11 +195,9 @@ class CWalletTx\n      */\n     mutable bool m_is_cache_empty{true};\n     mutable bool fChangeCached;\n-    mutable bool fInMempool;\n     mutable CAmount nChangeCached;\n \n-    CWalletTx(CTransactionRef arg)\n-        : tx(std::move(arg))\n+    CWalletTx(CTransactionRef tx, const TxState& state) : tx(std::move(tx)), m_state(state)\n     {\n         Init();\n     }\n@@ -129,44 +211,12 @@ class CWalletTx\n         nTimeSmart = 0;\n         fFromMe = false;\n         fChangeCached = false;\n-        fInMempool = false;\n         nChangeCached = 0;\n         nOrderPos = -1;\n-        m_confirm = Confirmation{};\n     }\n \n     CTransactionRef tx;\n-\n-    /** New transactions start as UNCONFIRMED. At BlockConnected,\n-     * they will transition to CONFIRMED. In case of reorg, at BlockDisconnected,\n-     * they roll back to UNCONFIRMED. If we detect a conflicting transaction at\n-     * block connection, we update conflicted tx and its dependencies as CONFLICTED.\n-     * If tx isn't confirmed and outside of mempool, the user may switch it to ABANDONED\n-     * by using the abandontransaction call. This last status may be override by a CONFLICTED\n-     * or CONFIRMED transition.\n-     */\n-    enum Status {\n-        UNCONFIRMED,\n-        CONFIRMED,\n-        CONFLICTED,\n-        ABANDONED\n-    };\n-\n-    /** Confirmation includes tx status and a triplet of {block height/block hash/tx index in block}\n-     * at which tx has been confirmed. All three are set to 0 if tx is unconfirmed or abandoned.\n-     * Meaning of these fields changes with CONFLICTED state where they instead point to block hash\n-     * and block height of the deepest conflicting tx.\n-     */\n-    struct Confirmation {\n-        Status status;\n-        int block_height;\n-        uint256 hashBlock;\n-        int nIndex;\n-        Confirmation(Status status = UNCONFIRMED, int block_height = 0, uint256 block_hash = uint256(), int block_index = 0)\n-            : status{status}, block_height{block_height}, hashBlock{block_hash}, nIndex{block_index} {}\n-    };\n-\n-    Confirmation m_confirm;\n+    TxState m_state;\n \n     template<typename Stream>\n     void Serialize(Stream& s) const\n@@ -184,8 +234,8 @@ class CWalletTx\n         std::vector<uint8_t> dummy_vector1; //!< Used to be vMerkleBranch\n         std::vector<uint8_t> dummy_vector2; //!< Used to be vtxPrev\n         bool dummy_bool = false; //!< Used to be fSpent\n-        uint256 serializedHash = isAbandoned() ? ABANDON_HASH : m_confirm.hashBlock;\n-        int serializedIndex = isAbandoned() || isConflicted() ? -1 : m_confirm.nIndex;\n+        uint256 serializedHash = TxStateSerializedBlockHash(m_state);\n+        int serializedIndex = TxStateSerializedIndex(m_state);\n         s << tx << serializedHash << dummy_vector1 << serializedIndex << dummy_vector2 << mapValueCopy << vOrderForm << fTimeReceivedIsTxTime << nTimeReceived << fFromMe << dummy_bool;\n     }\n \n@@ -197,24 +247,11 @@ class CWalletTx\n         std::vector<uint256> dummy_vector1; //!< Used to be vMerkleBranch\n         std::vector<CMerkleTx> dummy_vector2; //!< Used to be vtxPrev\n         bool dummy_bool; //! Used to be fSpent\n+        uint256 serialized_block_hash;\n         int serializedIndex;\n-        s >> tx >> m_confirm.hashBlock >> dummy_vector1 >> serializedIndex >> dummy_vector2 >> mapValue >> vOrderForm >> fTimeReceivedIsTxTime >> nTimeReceived >> fFromMe >> dummy_bool;\n-\n-        /* At serialization/deserialization, an nIndex == -1 means that hashBlock refers to\n-         * the earliest block in the chain we know this or any in-wallet ancestor conflicts\n-         * with. If nIndex == -1 and hashBlock is ABANDON_HASH, it means transaction is abandoned.\n-         * In same context, an nIndex >= 0 refers to a confirmed transaction (if hashBlock set) or\n-         * unconfirmed one. Older clients interpret nIndex == -1 as unconfirmed for backward\n-         * compatibility (pre-commit 9ac63d6).\n-         */\n-        if (serializedIndex == -1 && m_confirm.hashBlock == ABANDON_HASH) {\n-            setAbandoned();\n-        } else if (serializedIndex == -1) {\n-            setConflicted();\n-        } else if (!m_confirm.hashBlock.IsNull()) {\n-            m_confirm.nIndex = serializedIndex;\n-            setConfirmed();\n-        }\n+        s >> tx >> serialized_block_hash >> dummy_vector1 >> serializedIndex >> dummy_vector2 >> mapValue >> vOrderForm >> fTimeReceivedIsTxTime >> nTimeReceived >> fFromMe >> dummy_bool;\n+\n+        m_state = TxStateInterpretSerialized({serialized_block_hash, serializedIndex});\n \n         const auto it_op = mapValue.find(\"n\");\n         nOrderPos = (it_op != mapValue.end()) ? LocaleIndependentAtoi<int64_t>(it_op->second) : -1;\n@@ -250,20 +287,13 @@ class CWalletTx\n \n     int64_t GetTxTime() const;\n \n-    bool isAbandoned() const { return m_confirm.status == CWalletTx::ABANDONED; }\n-    void setAbandoned()\n-    {\n-        m_confirm.status = CWalletTx::ABANDONED;\n-        m_confirm.hashBlock = uint256();\n-        m_confirm.block_height = 0;\n-        m_confirm.nIndex = 0;\n-    }\n-    bool isConflicted() const { return m_confirm.status == CWalletTx::CONFLICTED; }\n-    void setConflicted() { m_confirm.status = CWalletTx::CONFLICTED; }\n-    bool isUnconfirmed() const { return m_confirm.status == CWalletTx::UNCONFIRMED; }\n-    void setUnconfirmed() { m_confirm.status = CWalletTx::UNCONFIRMED; }\n-    bool isConfirmed() const { return m_confirm.status == CWalletTx::CONFIRMED; }\n-    void setConfirmed() { m_confirm.status = CWalletTx::CONFIRMED; }\n+    template<typename T> const T* state() const { return std::get_if<T>(&m_state); }\n+    template<typename T> T* state() { return std::get_if<T>(&m_state); }\n+\n+    bool isAbandoned() const { return state<TxStateInactive>() && state<TxStateInactive>()->abandoned; }\n+    bool isConflicted() const { return state<TxStateConflicted>(); }\n+    bool isUnconfirmed() const { return !isAbandoned() && !isConflicted() && !isConfirmed(); }\n+    bool isConfirmed() const { return state<TxStateConfirmed>(); }\n     const uint256& GetHash() const { return tx->GetHash(); }\n     bool IsCoinBase() const { return tx->IsCoinBase(); }\n "
      },
      {
        "sha": "5b8a174fcb9bee3eb2fecdfce63d46275e484f72",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 67,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -99,7 +99,11 @@ static void UpdateWalletSetting(interfaces::Chain& chain,\n  */\n static void RefreshMempoolStatus(CWalletTx& tx, interfaces::Chain& chain)\n {\n-    tx.fInMempool = chain.isInMempool(tx.GetHash());\n+    if (chain.isInMempool(tx.GetHash())) {\n+        tx.m_state = TxStateInMempool();\n+    } else if (tx.state<TxStateInMempool>()) {\n+        tx.m_state = TxStateInactive();\n+    }\n }\n \n bool AddWallet(WalletContext& context, const std::shared_ptr<CWallet>& wallet)\n@@ -885,7 +889,7 @@ bool CWallet::IsSpentKey(const uint256& hash, unsigned int n) const\n     return false;\n }\n \n-CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx, bool fFlushOnClose, bool rescanning_old_block)\n+CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const TxState& state, const UpdateWalletTxFn& update_wtx, bool fFlushOnClose, bool rescanning_old_block)\n {\n     LOCK(cs_wallet);\n \n@@ -906,12 +910,11 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n     }\n \n     // Inserts only if not already there, returns tx inserted or tx found\n-    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(tx));\n+    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(tx, state));\n     CWalletTx& wtx = (*ret.first).second;\n     bool fInsertedNew = ret.second;\n     bool fUpdated = update_wtx && update_wtx(wtx, fInsertedNew);\n     if (fInsertedNew) {\n-        wtx.m_confirm = confirm;\n         wtx.nTimeReceived = chain().getAdjustedTime();\n         wtx.nOrderPos = IncOrderPosNext(&batch);\n         wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));\n@@ -921,16 +924,12 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n \n     if (!fInsertedNew)\n     {\n-        if (confirm.status != wtx.m_confirm.status) {\n-            wtx.m_confirm.status = confirm.status;\n-            wtx.m_confirm.nIndex = confirm.nIndex;\n-            wtx.m_confirm.hashBlock = confirm.hashBlock;\n-            wtx.m_confirm.block_height = confirm.block_height;\n+        if (state.index() != wtx.m_state.index()) {\n+            wtx.m_state = state;\n             fUpdated = true;\n         } else {\n-            assert(wtx.m_confirm.nIndex == confirm.nIndex);\n-            assert(wtx.m_confirm.hashBlock == confirm.hashBlock);\n-            assert(wtx.m_confirm.block_height == confirm.block_height);\n+            assert(TxStateSerializedIndex(wtx.m_state) == TxStateSerializedIndex(state));\n+            assert(TxStateSerializedBlockHash(wtx.m_state) == TxStateSerializedBlockHash(state));\n         }\n         // If we have a witness-stripped version of this transaction, and we\n         // see a new version with a witness, then we must be upgrading a pre-segwit\n@@ -964,10 +963,10 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n     if (!strCmd.empty())\n     {\n         boost::replace_all(strCmd, \"%s\", hash.GetHex());\n-        if (confirm.status == CWalletTx::Status::CONFIRMED)\n+        if (auto* conf = wtx.state<TxStateConfirmed>())\n         {\n-            boost::replace_all(strCmd, \"%b\", confirm.hashBlock.GetHex());\n-            boost::replace_all(strCmd, \"%h\", ToString(confirm.block_height));\n+            boost::replace_all(strCmd, \"%b\", conf->confirmed_block_hash.GetHex());\n+            boost::replace_all(strCmd, \"%h\", ToString(conf->confirmed_block_height));\n         } else {\n             boost::replace_all(strCmd, \"%b\", \"unconfirmed\");\n             boost::replace_all(strCmd, \"%h\", \"-1\");\n@@ -990,30 +989,29 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n \n bool CWallet::LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx)\n {\n-    const auto& ins = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(nullptr));\n+    const auto& ins = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(nullptr, TxStateInactive{}));\n     CWalletTx& wtx = ins.first->second;\n     if (!fill_wtx(wtx, ins.second)) {\n         return false;\n     }\n     // If wallet doesn't have a chain (e.g wallet-tool), don't bother to update txn.\n     if (HaveChain()) {\n         bool active;\n-        int height;\n-        if (chain().findBlock(wtx.m_confirm.hashBlock, FoundBlock().inActiveChain(active).height(height)) && active) {\n-            // Update cached block height variable since it not stored in the\n-            // serialized transaction.\n-            wtx.m_confirm.block_height = height;\n-        } else if (wtx.isConflicted() || wtx.isConfirmed()) {\n+        auto lookup_block = [&](const uint256& hash, int& height, TxState& state) {\n             // If tx block (or conflicting block) was reorged out of chain\n             // while the wallet was shutdown, change tx status to UNCONFIRMED\n             // and reset block height, hash, and index. ABANDONED tx don't have\n             // associated blocks and don't need to be updated. The case where a\n             // transaction was reorged out while online and then reconfirmed\n             // while offline is covered by the rescan logic.\n-            wtx.setUnconfirmed();\n-            wtx.m_confirm.hashBlock = uint256();\n-            wtx.m_confirm.block_height = 0;\n-            wtx.m_confirm.nIndex = 0;\n+            if (!chain().findBlock(hash, FoundBlock().inActiveChain(active).height(height)) || !active) {\n+                state = TxStateInactive{};\n+            }\n+        };\n+        if (auto* conf = wtx.state<TxStateConfirmed>()) {\n+            lookup_block(conf->confirmed_block_hash, conf->confirmed_block_height, wtx.m_state);\n+        } else if (auto* conf = wtx.state<TxStateConflicted>()) {\n+            lookup_block(conf->conflicting_block_hash, conf->conflicting_block_height, wtx.m_state);\n         }\n     }\n     if (/* insertion took place */ ins.second) {\n@@ -1024,27 +1022,27 @@ bool CWallet::LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx\n         auto it = mapWallet.find(txin.prevout.hash);\n         if (it != mapWallet.end()) {\n             CWalletTx& prevtx = it->second;\n-            if (prevtx.isConflicted()) {\n-                MarkConflicted(prevtx.m_confirm.hashBlock, prevtx.m_confirm.block_height, wtx.GetHash());\n+            if (auto* prev = prevtx.state<TxStateConflicted>()) {\n+                MarkConflicted(prev->conflicting_block_hash, prev->conflicting_block_height, wtx.GetHash());\n             }\n         }\n     }\n     return true;\n }\n \n-bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Confirmation confirm, bool fUpdate, bool rescanning_old_block)\n+bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const SyncTxState& state, bool fUpdate, bool rescanning_old_block)\n {\n     const CTransaction& tx = *ptx;\n     {\n         AssertLockHeld(cs_wallet);\n \n-        if (!confirm.hashBlock.IsNull()) {\n+        if (auto* conf = std::get_if<TxStateConfirmed>(&state)) {\n             for (const CTxIn& txin : tx.vin) {\n                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                 while (range.first != range.second) {\n                     if (range.first->second != tx.GetHash()) {\n-                        WalletLogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), confirm.hashBlock.ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n-                        MarkConflicted(confirm.hashBlock, confirm.block_height, range.first->second);\n+                        WalletLogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), conf->confirmed_block_hash.ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n+                        MarkConflicted(conf->confirmed_block_hash, conf->confirmed_block_height, range.first->second);\n                     }\n                     range.first++;\n                 }\n@@ -1070,7 +1068,8 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Co\n \n             // Block disconnection override an abandoned tx as unconfirmed\n             // which means user may have to call abandontransaction again\n-            return AddToWallet(MakeTransactionRef(tx), confirm, /* update_wtx= */ nullptr, /* fFlushOnClose= */ false, rescanning_old_block);\n+            TxState tx_state = std::visit([](auto&& s) -> TxState { return s; }, state);\n+            return AddToWallet(MakeTransactionRef(tx), tx_state, /*update_wtx=*/nullptr, /*fFlushOnClose=*/false, rescanning_old_block);\n         }\n     }\n     return false;\n@@ -1126,7 +1125,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n         if (currentconfirm == 0 && !wtx.isAbandoned()) {\n             // If the orig tx was not in block/mempool, none of its spends can be in mempool\n             assert(!wtx.InMempool());\n-            wtx.setAbandoned();\n+            wtx.m_state = TxStateInactive{/*abandoned=*/true};\n             wtx.MarkDirty();\n             batch.WriteTx(wtx);\n             NotifyTransactionChanged(wtx.GetHash(), CT_UPDATED);\n@@ -1178,10 +1177,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, int conflicting_height, c\n         if (conflictconfirms < currentconfirm) {\n             // Block is 'more conflicted' than current confirm; update.\n             // Mark transaction as conflicted with this block.\n-            wtx.m_confirm.nIndex = 0;\n-            wtx.m_confirm.hashBlock = hashBlock;\n-            wtx.m_confirm.block_height = conflicting_height;\n-            wtx.setConflicted();\n+            wtx.m_state = TxStateConflicted{hashBlock, conflicting_height};\n             wtx.MarkDirty();\n             batch.WriteTx(wtx);\n             // Iterate over all its outputs, and mark transactions in the wallet that spend them conflicted too\n@@ -1199,9 +1195,9 @@ void CWallet::MarkConflicted(const uint256& hashBlock, int conflicting_height, c\n     }\n }\n \n-void CWallet::SyncTransaction(const CTransactionRef& ptx, CWalletTx::Confirmation confirm, bool update_tx, bool rescanning_old_block)\n+void CWallet::SyncTransaction(const CTransactionRef& ptx, const SyncTxState& state, bool update_tx, bool rescanning_old_block)\n {\n-    if (!AddToWalletIfInvolvingMe(ptx, confirm, update_tx, rescanning_old_block))\n+    if (!AddToWalletIfInvolvingMe(ptx, state, update_tx, rescanning_old_block))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -1212,7 +1208,7 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, CWalletTx::Confirmatio\n \n void CWallet::transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {\n     LOCK(cs_wallet);\n-    SyncTransaction(tx, {CWalletTx::Status::UNCONFIRMED, /*block_height=*/0, /*block_hash=*/{}, /*block_index=*/0});\n+    SyncTransaction(tx, TxStateInMempool{});\n \n     auto it = mapWallet.find(tx->GetHash());\n     if (it != mapWallet.end()) {\n@@ -1253,7 +1249,7 @@ void CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRe\n         // distinguishing between conflicted and unconfirmed transactions are\n         // imperfect, and could be improved in general, see\n         // https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Transaction-Conflict-Tracking\n-        SyncTransaction(tx, {CWalletTx::Status::UNCONFIRMED, /*block_height=*/0, /*block_hash=*/{}, /*block_index=*/0});\n+        SyncTransaction(tx, TxStateInactive{});\n     }\n }\n \n@@ -1265,7 +1261,7 @@ void CWallet::blockConnected(const CBlock& block, int height)\n     m_last_block_processed_height = height;\n     m_last_block_processed = block_hash;\n     for (size_t index = 0; index < block.vtx.size(); index++) {\n-        SyncTransaction(block.vtx[index], {CWalletTx::Status::CONFIRMED, height, block_hash, (int)index});\n+        SyncTransaction(block.vtx[index], TxStateConfirmed{block_hash, height, static_cast<int>(index)});\n         transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);\n     }\n }\n@@ -1281,7 +1277,7 @@ void CWallet::blockDisconnected(const CBlock& block, int height)\n     m_last_block_processed_height = height - 1;\n     m_last_block_processed = block.hashPrevBlock;\n     for (const CTransactionRef& ptx : block.vtx) {\n-        SyncTransaction(ptx, {CWalletTx::Status::UNCONFIRMED, /*block_height=*/0, /*block_hash=*/{}, /*block_index=*/0});\n+        SyncTransaction(ptx, TxStateInactive{});\n     }\n }\n \n@@ -1645,7 +1641,7 @@ CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_bloc\n                 break;\n             }\n             for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                SyncTransaction(block.vtx[posInBlock], {CWalletTx::Status::CONFIRMED, block_height, block_hash, (int)posInBlock}, fUpdate, /* rescanning_old_block */ true);\n+                SyncTransaction(block.vtx[posInBlock], TxStateConfirmed{block_hash, block_height, static_cast<int>(posInBlock)}, fUpdate, /*rescanning_old_block=*/true);\n             }\n             // scan succeeded, record block as most recent successfully scanned\n             result.last_scanned_block = block_hash;\n@@ -1720,7 +1716,7 @@ void CWallet::ReacceptWalletTransactions()\n     }\n }\n \n-bool CWallet::SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const\n+bool CWallet::SubmitTxMemoryPoolAndRelay(CWalletTx& wtx, std::string& err_string, bool relay) const\n {\n     // Can't relay if wallet is not broadcasting\n     if (!GetBroadcastTransactions()) return false;\n@@ -1734,17 +1730,17 @@ bool CWallet::SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_\n \n     // Submit transaction to mempool for relay\n     WalletLogPrintf(\"Submitting wtx %s to mempool for relay\\n\", wtx.GetHash().ToString());\n-    // We must set fInMempool here - while it will be re-set to true by the\n+    // We must set TxStateInMempool here. Even though it will also be set later by the\n     // entered-mempool callback, if we did not there would be a race where a\n     // user could call sendmoney in a loop and hit spurious out of funds errors\n     // because we think that this newly generated transaction's change is\n     // unavailable as we're not yet aware that it is in the mempool.\n     //\n-    // Irrespective of the failure reason, un-marking fInMempool\n-    // out-of-order is incorrect - it should be unmarked when\n+    // If broadcast fails for any reason, trying to set wtx.m_state here would be incorrect.\n+    // If transaction was previously in the mempool, it should be updated when\n     // TransactionRemovedFromMempool fires.\n     bool ret = chain().broadcastTransaction(wtx.tx, m_default_max_tx_fee, relay, err_string);\n-    wtx.fInMempool |= ret;\n+    if (ret) wtx.m_state = TxStateInMempool{};\n     return ret;\n }\n \n@@ -1831,7 +1827,8 @@ bool CWallet::SignTransaction(CMutableTransaction& tx) const\n             return false;\n         }\n         const CWalletTx& wtx = mi->second;\n-        coins[input.prevout] = Coin(wtx.tx->vout[input.prevout.n], wtx.m_confirm.block_height, wtx.IsCoinBase());\n+        int prev_height = wtx.state<TxStateConfirmed>() ? wtx.state<TxStateConfirmed>()->confirmed_block_height : 0;\n+        coins[input.prevout] = Coin(wtx.tx->vout[input.prevout.n], prev_height, wtx.IsCoinBase());\n     }\n     std::map<int, bilingual_str> input_errors;\n     return SignTransaction(tx, coins, SIGHASH_DEFAULT, input_errors);\n@@ -1956,7 +1953,7 @@ void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n \n     // Add tx to wallet, because if it has change it's also ours,\n     // otherwise just for transaction history.\n-    AddToWallet(tx, {}, [&](CWalletTx& wtx, bool new_tx) {\n+    AddToWallet(tx, TxStateInactive{}, [&](CWalletTx& wtx, bool new_tx) {\n         CHECK_NONFATAL(wtx.mapValue.empty());\n         CHECK_NONFATAL(wtx.vOrderForm.empty());\n         wtx.mapValue = std::move(mapValue);\n@@ -1974,7 +1971,7 @@ void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n     }\n \n     // Get the inserted-CWalletTx from mapWallet so that the\n-    // fInMempool flag is cached properly\n+    // wtx cached mempool state is updated correctly\n     CWalletTx& wtx = mapWallet.at(tx->GetHash());\n \n     if (!fBroadcastTransactions) {\n@@ -2321,10 +2318,10 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n     mapKeyBirth.clear();\n \n     // map in which we'll infer heights of other keys\n-    std::map<CKeyID, const CWalletTx::Confirmation*> mapKeyFirstBlock;\n-    CWalletTx::Confirmation max_confirm;\n-    max_confirm.block_height = GetLastBlockHeight() > 144 ? GetLastBlockHeight() - 144 : 0; // the tip can be reorganized; use a 144-block safety margin\n-    CHECK_NONFATAL(chain().findAncestorByHeight(GetLastBlockHash(), max_confirm.block_height, FoundBlock().hash(max_confirm.hashBlock)));\n+    std::map<CKeyID, const TxStateConfirmed*> mapKeyFirstBlock;\n+    TxStateConfirmed max_confirm{uint256{}, /*height=*/-1, /*index=*/-1};\n+    max_confirm.confirmed_block_height = GetLastBlockHeight() > 144 ? GetLastBlockHeight() - 144 : 0; // the tip can be reorganized; use a 144-block safety margin\n+    CHECK_NONFATAL(chain().findAncestorByHeight(GetLastBlockHash(), max_confirm.confirmed_block_height, FoundBlock().hash(max_confirm.confirmed_block_hash)));\n \n     {\n         LegacyScriptPubKeyMan* spk_man = GetLegacyScriptPubKeyMan();\n@@ -2352,15 +2349,15 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n         for (const auto& entry : mapWallet) {\n             // iterate over all wallet transactions...\n             const CWalletTx &wtx = entry.second;\n-            if (wtx.m_confirm.status == CWalletTx::CONFIRMED) {\n+            if (auto* conf = wtx.state<TxStateConfirmed>()) {\n                 // ... which are already in a block\n                 for (const CTxOut &txout : wtx.tx->vout) {\n                     // iterate over all their outputs\n                     for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *spk_man)) {\n                         // ... and all their affected keys\n                         auto rit = mapKeyFirstBlock.find(keyid);\n-                        if (rit != mapKeyFirstBlock.end() && wtx.m_confirm.block_height < rit->second->block_height) {\n-                            rit->second = &wtx.m_confirm;\n+                        if (rit != mapKeyFirstBlock.end() && conf->confirmed_block_height < rit->second->confirmed_block_height) {\n+                            rit->second = conf;\n                         }\n                     }\n                 }\n@@ -2371,7 +2368,7 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n     // Extract block timestamps for those keys\n     for (const auto& entry : mapKeyFirstBlock) {\n         int64_t block_time;\n-        CHECK_NONFATAL(chain().findBlock(entry.second->hashBlock, FoundBlock().time(block_time)));\n+        CHECK_NONFATAL(chain().findBlock(entry.second->confirmed_block_hash, FoundBlock().time(block_time)));\n         mapKeyBirth[entry.first] = block_time - TIMESTAMP_WINDOW; // block times can be 2h off\n     }\n }\n@@ -2401,11 +2398,18 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n  */\n unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx, bool rescanning_old_block) const\n {\n+    std::optional<uint256> block_hash;\n+    if (auto* conf = wtx.state<TxStateConfirmed>()) {\n+        block_hash = conf->confirmed_block_hash;\n+    } else if (auto* conf = wtx.state<TxStateConflicted>()) {\n+        block_hash = conf->conflicting_block_hash;\n+    }\n+\n     unsigned int nTimeSmart = wtx.nTimeReceived;\n-    if (!wtx.isUnconfirmed() && !wtx.isAbandoned()) {\n+    if (block_hash) {\n         int64_t blocktime;\n         int64_t block_max_time;\n-        if (chain().findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(blocktime).maxTime(block_max_time))) {\n+        if (chain().findBlock(*block_hash, FoundBlock().time(blocktime).maxTime(block_max_time))) {\n             if (rescanning_old_block) {\n                 nTimeSmart = block_max_time;\n             } else {\n@@ -2437,7 +2441,7 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx, bool rescanning_old\n                 nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n             }\n         } else {\n-            WalletLogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.m_confirm.hashBlock.ToString());\n+            WalletLogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), block_hash->ToString());\n         }\n     }\n     return nTimeSmart;\n@@ -2944,9 +2948,13 @@ CKeyPool::CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn)\n int CWallet::GetTxDepthInMainChain(const CWalletTx& wtx) const\n {\n     AssertLockHeld(cs_wallet);\n-    if (wtx.isUnconfirmed() || wtx.isAbandoned()) return 0;\n-\n-    return (GetLastBlockHeight() - wtx.m_confirm.block_height + 1) * (wtx.isConflicted() ? -1 : 1);\n+    if (auto* conf = wtx.state<TxStateConfirmed>()) {\n+        return GetLastBlockHeight() - conf->confirmed_block_height + 1;\n+    } else if (auto* conf = wtx.state<TxStateConflicted>()) {\n+        return -1 * (GetLastBlockHeight() - conf->conflicting_block_height + 1);\n+    } else {\n+        return 0;\n+    }\n }\n \n int CWallet::GetTxBlocksToMaturity(const CWalletTx& wtx) const"
      },
      {
        "sha": "cb7178fc0133103d9b6656d43f9a62d1e4a6ac22",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -275,7 +275,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * Should be called with rescanning_old_block set to true, if the transaction is\n      * not discovered in real time, but during a rescan of old blocks.\n      */\n-    bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool fUpdate, bool rescanning_old_block) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, const SyncTxState& state, bool fUpdate, bool rescanning_old_block) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /** Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n     void MarkConflicted(const uint256& hashBlock, int conflicting_height, const uint256& hashTx);\n@@ -285,7 +285,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    void SyncTransaction(const CTransactionRef& tx, CWalletTx::Confirmation confirm, bool update_tx = true, bool rescanning_old_block = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void SyncTransaction(const CTransactionRef& tx, const SyncTxState& state, bool update_tx = true, bool rescanning_old_block = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /** WalletFlags set on this wallet. */\n     std::atomic<uint64_t> m_wallet_flags{0};\n@@ -508,7 +508,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     //! @return true if wtx is changed and needs to be saved to disk, otherwise false\n     using UpdateWalletTxFn = std::function<bool(CWalletTx& wtx, bool new_tx)>;\n \n-    CWalletTx* AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true, bool rescanning_old_block = false);\n+    CWalletTx* AddToWallet(CTransactionRef tx, const TxState& state, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true, bool rescanning_old_block = false);\n     bool LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override;\n     void blockConnected(const CBlock& block, int height) override;\n@@ -576,7 +576,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     void CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm);\n \n     /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n-    bool SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const;\n+    bool SubmitTxMemoryPoolAndRelay(CWalletTx& wtx, std::string& err_string, bool relay) const;\n \n     bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts, const CCoinControl* coin_control = nullptr) const\n     {"
      },
      {
        "sha": "f392649bd9fa52f5aae139f4e8ecdec5afa08d27",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8ee8f3cd32bbfefec931724f5798cbb088ceb6f/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=d8ee8f3cd32bbfefec931724f5798cbb088ceb6f",
        "patch": "@@ -987,7 +987,7 @@ DBErrors WalletBatch::FindWalletTx(std::vector<uint256>& vTxHash, std::list<CWal\n                 uint256 hash;\n                 ssKey >> hash;\n                 vTxHash.push_back(hash);\n-                vWtx.emplace_back(nullptr /* tx */);\n+                vWtx.emplace_back(/*tx=*/nullptr, TxStateInactive{});\n                 ssValue >> vWtx.back();\n             }\n         }"
      }
    ]
  }
]