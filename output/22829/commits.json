[
  {
    "sha": "574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
    "node_id": "C_kwDOABII59oAKDU3NGNjNDI3MWFiMDlhNGM4ZjhkMDc2Y2IxYTNhMmQ1YjM5MjRiNzM",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-08-28T17:51:08Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-11-24T18:19:42Z"
      },
      "message": "refactor: remove RecursiveMutex cs_totalBytesRecv, use std::atomic instead\n\nThe RecursiveMutex cs_totalBytesRecv is only used at two places: in\nCConnman::RecordBytesRecv() to increment the nTotalBytesRecv member, and in\nCConnman::GetTotalBytesRecv() to read it. For this simple use-case, we can\nmake the member std::atomic instead to achieve the same result.",
      "tree": {
        "sha": "58f1db991f8c3d93be532636288d832e75adeefc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/58f1db991f8c3d93be532636288d832e75adeefc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "64059b78f59e45cc4200ca76d0af8c6dff8a20d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64059b78f59e45cc4200ca76d0af8c6dff8a20d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/64059b78f59e45cc4200ca76d0af8c6dff8a20d4"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 1,
      "deletions": 4
    },
    "files": [
      {
        "sha": "5406e7e49dd539840490d632f25aeaaf7a264ec5",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
        "patch": "@@ -2879,7 +2879,6 @@ bool CConnman::DisconnectNode(NodeId id)\n \n void CConnman::RecordBytesRecv(uint64_t bytes)\n {\n-    LOCK(cs_totalBytesRecv);\n     nTotalBytesRecv += bytes;\n }\n \n@@ -2956,7 +2955,6 @@ uint64_t CConnman::GetOutboundTargetBytesLeft() const\n \n uint64_t CConnman::GetTotalBytesRecv() const\n {\n-    LOCK(cs_totalBytesRecv);\n     return nTotalBytesRecv;\n }\n "
      },
      {
        "sha": "7092a6524a5215b38bb3dbff3865de0e931cc356",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
        "patch": "@@ -1074,9 +1074,8 @@ class CConnman\n     static bool NodeFullyConnected(const CNode* pnode);\n \n     // Network usage totals\n-    mutable RecursiveMutex cs_totalBytesRecv;\n     mutable RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    std::atomic<uint64_t> nTotalBytesRecv{0};\n     uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n     // outbound limit & stats"
      }
    ]
  },
  {
    "sha": "d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
    "node_id": "C_kwDOABII59oAKGQ1MWQyYTNiYjViMDAxMWVmYTFiNGYxZTJjOTUxMmExNmNlOWIzNDc",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-08-28T18:57:52Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-11-24T18:34:21Z"
      },
      "message": "scripted-diff: rename node vector/mutex members in CConnman\n\n-BEGIN VERIFY SCRIPT-\n\nren() { sed -i \"s/$1/$2/g\" $3 $4 $5; }\n\nren cs_vAddedNodes         m_added_nodes_mutex     src/net.h src/net.cpp\nren vAddedNodes            m_added_nodes           src/net.h src/net.cpp\nren cs_vNodes              m_nodes_mutex           src/net.h src/net.cpp src/test/util/net.h\nren vNodesDisconnectedCopy nodes_disconnected_copy src/net.cpp\nren vNodesDisconnected     m_nodes_disconnected    src/net.h src/net.cpp\nren vNodesCopy             nodes_copy              src/net.cpp\nren vNodesSize             nodes_size              src/net.cpp\nren vNodes                 m_nodes                 src/net.h src/net.cpp src/test/util/net.h\n\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "ede7eec7e77def2fbded1bfef685dac3af3a3966",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ede7eec7e77def2fbded1bfef685dac3af3a3966"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/574cc4271ab09a4c8f8d076cb1a3a2d5b3924b73"
      }
    ],
    "stats": {
      "total": 198,
      "additions": 99,
      "deletions": 99
    },
    "files": [
      {
        "sha": "db496c21856b9e8927eaee194573d0e06c2b9d54",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 79,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
        "patch": "@@ -326,8 +326,8 @@ bool IsLocal(const CService& addr)\n \n CNode* CConnman::FindNode(const CNetAddr& ip)\n {\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (CNode* pnode : m_nodes) {\n       if (static_cast<CNetAddr>(pnode->addr) == ip) {\n             return pnode;\n         }\n@@ -337,8 +337,8 @@ CNode* CConnman::FindNode(const CNetAddr& ip)\n \n CNode* CConnman::FindNode(const CSubNet& subNet)\n {\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (CNode* pnode : m_nodes) {\n         if (subNet.Match(static_cast<CNetAddr>(pnode->addr))) {\n             return pnode;\n         }\n@@ -348,8 +348,8 @@ CNode* CConnman::FindNode(const CSubNet& subNet)\n \n CNode* CConnman::FindNode(const std::string& addrName)\n {\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (CNode* pnode : m_nodes) {\n         if (pnode->m_addr_name == addrName) {\n             return pnode;\n         }\n@@ -359,8 +359,8 @@ CNode* CConnman::FindNode(const std::string& addrName)\n \n CNode* CConnman::FindNode(const CService& addr)\n {\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (CNode* pnode : m_nodes) {\n         if (static_cast<CService>(pnode->addr) == addr) {\n             return pnode;\n         }\n@@ -375,8 +375,8 @@ bool CConnman::AlreadyConnectedToAddress(const CAddress& addr)\n \n bool CConnman::CheckIncomingNonce(uint64_t nonce)\n {\n-    LOCK(cs_vNodes);\n-    for (const CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (const CNode* pnode : m_nodes) {\n         if (!pnode->fSuccessfullyConnected && !pnode->IsInboundConn() && pnode->GetLocalNonce() == nonce)\n             return false;\n     }\n@@ -435,7 +435,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n             }\n             // It is possible that we already have a connection to the IP/port pszDest resolved to.\n             // In that case, drop the connection that was just created.\n-            LOCK(cs_vNodes);\n+            LOCK(m_nodes_mutex);\n             CNode* pnode = FindNode(static_cast<CService>(addrConnect));\n             if (pnode) {\n                 LogPrintf(\"Failed to open new connection, already connected\\n\");\n@@ -1056,8 +1056,8 @@ bool CConnman::AttemptToEvictConnection()\n     std::vector<NodeEvictionCandidate> vEvictionCandidates;\n     {\n \n-        LOCK(cs_vNodes);\n-        for (const CNode* node : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (const CNode* node : m_nodes) {\n             if (node->HasPermission(NetPermissionFlags::NoBan))\n                 continue;\n             if (!node->IsInboundConn())\n@@ -1084,8 +1084,8 @@ bool CConnman::AttemptToEvictConnection()\n     if (!node_id_to_evict) {\n         return false;\n     }\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (CNode* pnode : m_nodes) {\n         if (pnode->GetId() == *node_id_to_evict) {\n             LogPrint(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());\n             pnode->fDisconnect = true;\n@@ -1141,8 +1141,8 @@ void CConnman::CreateNodeFromAcceptedSocket(SOCKET hSocket,\n     }\n \n     {\n-        LOCK(cs_vNodes);\n-        for (const CNode* pnode : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (const CNode* pnode : m_nodes) {\n             if (pnode->IsInboundConn()) nInbound++;\n         }\n     }\n@@ -1210,8 +1210,8 @@ void CConnman::CreateNodeFromAcceptedSocket(SOCKET hSocket,\n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n     {\n-        LOCK(cs_vNodes);\n-        vNodes.push_back(pnode);\n+        LOCK(m_nodes_mutex);\n+        m_nodes.push_back(pnode);\n     }\n \n     // We received a new connection, harvest entropy from the time (and our peer count)\n@@ -1238,8 +1238,8 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\n     } // no default case, so the compiler can warn about missing cases\n \n     // Count existing connections\n-    int existing_connections = WITH_LOCK(cs_vNodes,\n-                                         return std::count_if(vNodes.begin(), vNodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););\n+    int existing_connections = WITH_LOCK(m_nodes_mutex,\n+                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););\n \n     // Max connections of specified type already exist\n     if (max_connections != std::nullopt && existing_connections >= max_connections) return false;\n@@ -1255,11 +1255,11 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\n void CConnman::DisconnectNodes()\n {\n     {\n-        LOCK(cs_vNodes);\n+        LOCK(m_nodes_mutex);\n \n         if (!fNetworkActive) {\n             // Disconnect any connected nodes\n-            for (CNode* pnode : vNodes) {\n+            for (CNode* pnode : m_nodes) {\n                 if (!pnode->fDisconnect) {\n                     LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n                     pnode->fDisconnect = true;\n@@ -1268,13 +1268,13 @@ void CConnman::DisconnectNodes()\n         }\n \n         // Disconnect unused nodes\n-        std::vector<CNode*> vNodesCopy = vNodes;\n-        for (CNode* pnode : vNodesCopy)\n+        std::vector<CNode*> nodes_copy = m_nodes;\n+        for (CNode* pnode : nodes_copy)\n         {\n             if (pnode->fDisconnect)\n             {\n-                // remove from vNodes\n-                vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n+                // remove from m_nodes\n+                m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());\n \n                 // release outbound grant (if any)\n                 pnode->grantOutbound.Release();\n@@ -1284,18 +1284,18 @@ void CConnman::DisconnectNodes()\n \n                 // hold in disconnected pool until all refs are released\n                 pnode->Release();\n-                vNodesDisconnected.push_back(pnode);\n+                m_nodes_disconnected.push_back(pnode);\n             }\n         }\n     }\n     {\n         // Delete disconnected nodes\n-        std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-        for (CNode* pnode : vNodesDisconnectedCopy)\n+        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;\n+        for (CNode* pnode : nodes_disconnected_copy)\n         {\n             // Destroy the object only after other threads have stopped using it.\n             if (pnode->GetRefCount() <= 0) {\n-                vNodesDisconnected.remove(pnode);\n+                m_nodes_disconnected.remove(pnode);\n                 DeleteNode(pnode);\n             }\n         }\n@@ -1304,15 +1304,15 @@ void CConnman::DisconnectNodes()\n \n void CConnman::NotifyNumConnectionsChanged()\n {\n-    size_t vNodesSize;\n+    size_t nodes_size;\n     {\n-        LOCK(cs_vNodes);\n-        vNodesSize = vNodes.size();\n+        LOCK(m_nodes_mutex);\n+        nodes_size = m_nodes.size();\n     }\n-    if(vNodesSize != nPrevNodeCount) {\n-        nPrevNodeCount = vNodesSize;\n+    if(nodes_size != nPrevNodeCount) {\n+        nPrevNodeCount = nodes_size;\n         if (m_client_interface) {\n-            m_client_interface->NotifyNumConnectionsChanged(vNodesSize);\n+            m_client_interface->NotifyNumConnectionsChanged(nodes_size);\n         }\n     }\n }\n@@ -1716,8 +1716,8 @@ void CConnman::ThreadDNSAddressSeed()\n \n                     int nRelevant = 0;\n                     {\n-                        LOCK(cs_vNodes);\n-                        for (const CNode* pnode : vNodes) {\n+                        LOCK(m_nodes_mutex);\n+                        for (const CNode* pnode : m_nodes) {\n                             if (pnode->fSuccessfullyConnected && pnode->IsFullOutboundConn()) ++nRelevant;\n                         }\n                     }\n@@ -1825,8 +1825,8 @@ int CConnman::GetExtraFullOutboundCount() const\n {\n     int full_outbound_peers = 0;\n     {\n-        LOCK(cs_vNodes);\n-        for (const CNode* pnode : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (const CNode* pnode : m_nodes) {\n             if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {\n                 ++full_outbound_peers;\n             }\n@@ -1839,8 +1839,8 @@ int CConnman::GetExtraBlockRelayCount() const\n {\n     int block_relay_peers = 0;\n     {\n-        LOCK(cs_vNodes);\n-        for (const CNode* pnode : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (const CNode* pnode : m_nodes) {\n             if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {\n                 ++block_relay_peers;\n             }\n@@ -1911,8 +1911,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n \n             // Checking !dnsseed is cheaper before locking 2 mutexes.\n             if (!add_fixed_seeds_now && !dnsseed) {\n-                LOCK2(m_addr_fetches_mutex, cs_vAddedNodes);\n-                if (m_addr_fetches.empty() && vAddedNodes.empty()) {\n+                LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex);\n+                if (m_addr_fetches.empty() && m_added_nodes.empty()) {\n                     add_fixed_seeds_now = true;\n                     LogPrintf(\"Adding fixed seeds as -dnsseed=0, -addnode is not provided and all -seednode(s) attempted\\n\");\n                 }\n@@ -1937,8 +1937,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         std::set<std::vector<unsigned char> > setConnected;\n \n         {\n-            LOCK(cs_vNodes);\n-            for (const CNode* pnode : vNodes) {\n+            LOCK(m_nodes_mutex);\n+            for (const CNode* pnode : m_nodes) {\n                 if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;\n                 if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;\n \n@@ -2126,8 +2126,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const\n {\n     std::vector<CAddress> ret;\n-    LOCK(cs_vNodes);\n-    for (const CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (const CNode* pnode : m_nodes) {\n         if (pnode->IsBlockOnlyConn()) {\n             ret.push_back(pnode->addr);\n         }\n@@ -2142,18 +2142,18 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const\n \n     std::list<std::string> lAddresses(0);\n     {\n-        LOCK(cs_vAddedNodes);\n-        ret.reserve(vAddedNodes.size());\n-        std::copy(vAddedNodes.cbegin(), vAddedNodes.cend(), std::back_inserter(lAddresses));\n+        LOCK(m_added_nodes_mutex);\n+        ret.reserve(m_added_nodes.size());\n+        std::copy(m_added_nodes.cbegin(), m_added_nodes.cend(), std::back_inserter(lAddresses));\n     }\n \n \n     // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService\n     std::map<CService, bool> mapConnected;\n     std::map<std::string, std::pair<bool, CService>> mapConnectedByName;\n     {\n-        LOCK(cs_vNodes);\n-        for (const CNode* pnode : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (const CNode* pnode : m_nodes) {\n             if (pnode->addr.IsValid()) {\n                 mapConnected[pnode->addr] = pnode->IsInboundConn();\n             }\n@@ -2249,8 +2249,8 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n \n     m_msgproc->InitializeNode(pnode);\n     {\n-        LOCK(cs_vNodes);\n-        vNodes.push_back(pnode);\n+        LOCK(m_nodes_mutex);\n+        m_nodes.push_back(pnode);\n     }\n }\n \n@@ -2264,7 +2264,7 @@ void CConnman::ThreadMessageHandler()\n         {\n             // Randomize the order in which we process messages from/to our peers.\n             // This prevents attacks in which an attacker exploits having multiple\n-            // consecutive connections in the vNodes list.\n+            // consecutive connections in the m_nodes list.\n             const NodesSnapshot snap{*this, /*shuffle=*/true};\n \n             for (CNode* pnode : snap.Nodes()) {\n@@ -2694,7 +2694,7 @@ void CConnman::StopNodes()\n \n     // Delete peer connections.\n     std::vector<CNode*> nodes;\n-    WITH_LOCK(cs_vNodes, nodes.swap(vNodes));\n+    WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));\n     for (CNode* pnode : nodes) {\n         pnode->CloseSocketDisconnect();\n         DeleteNode(pnode);\n@@ -2709,10 +2709,10 @@ void CConnman::StopNodes()\n         }\n     }\n \n-    for (CNode* pnode : vNodesDisconnected) {\n+    for (CNode* pnode : m_nodes_disconnected) {\n         DeleteNode(pnode);\n     }\n-    vNodesDisconnected.clear();\n+    m_nodes_disconnected.clear();\n     vhListenSocket.clear();\n     semOutbound.reset();\n     semAddnode.reset();\n@@ -2785,21 +2785,21 @@ std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addres\n \n bool CConnman::AddNode(const std::string& strNode)\n {\n-    LOCK(cs_vAddedNodes);\n-    for (const std::string& it : vAddedNodes) {\n+    LOCK(m_added_nodes_mutex);\n+    for (const std::string& it : m_added_nodes) {\n         if (strNode == it) return false;\n     }\n \n-    vAddedNodes.push_back(strNode);\n+    m_added_nodes.push_back(strNode);\n     return true;\n }\n \n bool CConnman::RemoveAddedNode(const std::string& strNode)\n {\n-    LOCK(cs_vAddedNodes);\n-    for(std::vector<std::string>::iterator it = vAddedNodes.begin(); it != vAddedNodes.end(); ++it) {\n+    LOCK(m_added_nodes_mutex);\n+    for(std::vector<std::string>::iterator it = m_added_nodes.begin(); it != m_added_nodes.end(); ++it) {\n         if (strNode == *it) {\n-            vAddedNodes.erase(it);\n+            m_added_nodes.erase(it);\n             return true;\n         }\n     }\n@@ -2808,12 +2808,12 @@ bool CConnman::RemoveAddedNode(const std::string& strNode)\n \n size_t CConnman::GetNodeCount(ConnectionDirection flags) const\n {\n-    LOCK(cs_vNodes);\n+    LOCK(m_nodes_mutex);\n     if (flags == ConnectionDirection::Both) // Shortcut if we want total\n-        return vNodes.size();\n+        return m_nodes.size();\n \n     int nNum = 0;\n-    for (const auto& pnode : vNodes) {\n+    for (const auto& pnode : m_nodes) {\n         if (flags & (pnode->IsInboundConn() ? ConnectionDirection::In : ConnectionDirection::Out)) {\n             nNum++;\n         }\n@@ -2825,9 +2825,9 @@ size_t CConnman::GetNodeCount(ConnectionDirection flags) const\n void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n {\n     vstats.clear();\n-    LOCK(cs_vNodes);\n-    vstats.reserve(vNodes.size());\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    vstats.reserve(m_nodes.size());\n+    for (CNode* pnode : m_nodes) {\n         vstats.emplace_back();\n         pnode->CopyStats(vstats.back());\n         vstats.back().m_mapped_as = pnode->addr.GetMappedAS(addrman.GetAsmap());\n@@ -2836,7 +2836,7 @@ void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n \n bool CConnman::DisconnectNode(const std::string& strNode)\n {\n-    LOCK(cs_vNodes);\n+    LOCK(m_nodes_mutex);\n     if (CNode* pnode = FindNode(strNode)) {\n         LogPrint(BCLog::NET, \"disconnect by address%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", strNode) : \"\"), pnode->GetId());\n         pnode->fDisconnect = true;\n@@ -2848,8 +2848,8 @@ bool CConnman::DisconnectNode(const std::string& strNode)\n bool CConnman::DisconnectNode(const CSubNet& subnet)\n {\n     bool disconnected = false;\n-    LOCK(cs_vNodes);\n-    for (CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (CNode* pnode : m_nodes) {\n         if (subnet.Match(pnode->addr)) {\n             LogPrint(BCLog::NET, \"disconnect by subnet%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", subnet.ToString()) : \"\"), pnode->GetId());\n             pnode->fDisconnect = true;\n@@ -2866,8 +2866,8 @@ bool CConnman::DisconnectNode(const CNetAddr& addr)\n \n bool CConnman::DisconnectNode(NodeId id)\n {\n-    LOCK(cs_vNodes);\n-    for(CNode* pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for(CNode* pnode : m_nodes) {\n         if (id == pnode->GetId()) {\n             LogPrint(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());\n             pnode->fDisconnect = true;\n@@ -3057,8 +3057,8 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n {\n     CNode* found = nullptr;\n-    LOCK(cs_vNodes);\n-    for (auto&& pnode : vNodes) {\n+    LOCK(m_nodes_mutex);\n+    for (auto&& pnode : m_nodes) {\n         if(pnode->GetId() == id) {\n             found = pnode;\n             break;"
      },
      {
        "sha": "a10b055a97568fef0cac22987559e113b6a68707",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
        "patch": "@@ -791,8 +791,8 @@ class CConnman\n         }\n         vWhitelistedRange = connOptions.vWhitelistedRange;\n         {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n+            LOCK(m_added_nodes_mutex);\n+            m_added_nodes = connOptions.m_added_nodes;\n         }\n         m_onion_binds = connOptions.onion_binds;\n     }\n@@ -823,17 +823,17 @@ class CConnman\n     using NodeFn = std::function<void(CNode*)>;\n     void ForEachNode(const NodeFn& func)\n     {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (auto&& node : m_nodes) {\n             if (NodeFullyConnected(node))\n                 func(node);\n         }\n     };\n \n     void ForEachNode(const NodeFn& func) const\n     {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (auto&& node : m_nodes) {\n             if (NodeFullyConnected(node))\n                 func(node);\n         }\n@@ -968,7 +968,7 @@ class CConnman\n \n     /**\n      * Create a `CNode` object from a socket that has just been accepted and add the node to\n-     * the `vNodes` member.\n+     * the `m_nodes` member.\n      * @param[in] hSocket Connected socket to communicate with the peer.\n      * @param[in] permissionFlags The peer's permissions.\n      * @param[in] addr_bind The address and port at our side of the connection.\n@@ -1099,11 +1099,11 @@ class CConnman\n     AddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    mutable RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n+    std::vector<std::string> m_added_nodes GUARDED_BY(m_added_nodes_mutex);\n+    mutable RecursiveMutex m_added_nodes_mutex;\n+    std::vector<CNode*> m_nodes GUARDED_BY(m_nodes_mutex);\n+    std::list<CNode*> m_nodes_disconnected;\n+    mutable RecursiveMutex m_nodes_mutex;\n     std::atomic<NodeId> nLastNodeId{0};\n     unsigned int nPrevNodeCount{0};\n \n@@ -1225,7 +1225,7 @@ class CConnman\n     std::vector<CService> m_onion_binds;\n \n     /**\n-     * RAII helper to atomically create a copy of `vNodes` and add a reference\n+     * RAII helper to atomically create a copy of `m_nodes` and add a reference\n      * to each of the nodes. The nodes are released when this object is destroyed.\n      */\n     class NodesSnapshot\n@@ -1234,8 +1234,8 @@ class CConnman\n         explicit NodesSnapshot(const CConnman& connman, bool shuffle)\n         {\n             {\n-                LOCK(connman.cs_vNodes);\n-                m_nodes_copy = connman.vNodes;\n+                LOCK(connman.m_nodes_mutex);\n+                m_nodes_copy = connman.m_nodes;\n                 for (auto& node : m_nodes_copy) {\n                     node->AddRef();\n                 }"
      },
      {
        "sha": "2de6e712a259f2680d0322ef89e20de2e849fe9f",
        "filename": "src/test/util/net.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/src/test/util/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347/src/test/util/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.h?ref=d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
        "patch": "@@ -25,16 +25,16 @@ struct ConnmanTestMsg : public CConnman {\n \n     void AddTestNode(CNode& node)\n     {\n-        LOCK(cs_vNodes);\n-        vNodes.push_back(&node);\n+        LOCK(m_nodes_mutex);\n+        m_nodes.push_back(&node);\n     }\n     void ClearTestNodes()\n     {\n-        LOCK(cs_vNodes);\n-        for (CNode* node : vNodes) {\n+        LOCK(m_nodes_mutex);\n+        for (CNode* node : m_nodes) {\n             delete node;\n         }\n-        vNodes.clear();\n+        m_nodes.clear();\n     }\n \n     void ProcessMessagesOnce(CNode& node) { m_msgproc->ProcessMessages(&node, flagInterruptMsgProc); }"
      }
    ]
  },
  {
    "sha": "7d52ff5c389643cde613d86fee33d7087f47b8b4",
    "node_id": "C_kwDOABII59oAKDdkNTJmZjVjMzg5NjQzY2RlNjEzZDg2ZmVlMzNkNzA4N2Y0N2I4YjQ",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-08-28T17:59:41Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-11-24T18:34:26Z"
      },
      "message": "refactor: replace RecursiveMutex m_addr_fetches_mutex with Mutex\n\nThe RecursiveMutex m_addr_fetches_mutex is used at three places:\n    - CConnman::AddAddrFetch()\n    - CConnman::ProcessAddrFetch()\n    - CConnman::ThreadOpenConnections()\nIn each of the critical sections, only the the m_addr_fetches is accessed\n(and in the last case, also vAddedNodes), without any chance that within\none section another one is called. Hence, we can use an ordinary Mutex\ninstead of RecursiveMutex.",
      "tree": {
        "sha": "2acf44d95f919d267f7b1bba38648c4d60a60630",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2acf44d95f919d267f7b1bba38648c4d60a60630"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d52ff5c389643cde613d86fee33d7087f47b8b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d52ff5c389643cde613d86fee33d7087f47b8b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d52ff5c389643cde613d86fee33d7087f47b8b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d52ff5c389643cde613d86fee33d7087f47b8b4/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d51d2a3bb5b0011efa1b4f1e2c9512a16ce9b347"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "93d36a6e3db8d137ead2a58e45203d7e0e87b863",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d52ff5c389643cde613d86fee33d7087f47b8b4/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d52ff5c389643cde613d86fee33d7087f47b8b4/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7d52ff5c389643cde613d86fee33d7087f47b8b4",
        "patch": "@@ -1098,7 +1098,7 @@ class CConnman\n     bool fAddressesInitialized{false};\n     AddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n+    Mutex m_addr_fetches_mutex;\n     std::vector<std::string> m_added_nodes GUARDED_BY(m_added_nodes_mutex);\n     mutable RecursiveMutex m_added_nodes_mutex;\n     std::vector<CNode*> m_nodes GUARDED_BY(m_nodes_mutex);"
      }
    ]
  },
  {
    "sha": "3726a4595837b66d37f151faf1cec2796d6b74d7",
    "node_id": "C_kwDOABII59oAKDM3MjZhNDU5NTgzN2I2NmQzN2YxNTFmYWYxY2VjMjc5NmQ2Yjc0ZDc",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-08-28T19:02:28Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-11-24T18:34:26Z"
      },
      "message": "refactor: replace RecursiveMutex m_added_nodes_mutex with Mutex\n\nThe RecursiveMutex m_added_nodes_mutex is used at three places:\n    - CConnman::GetAddedNodeInfo()\n    - CConnman::AddNode()\n    - CConnman::ThreadOpenConnections()\nIn each of the critical sections, only the the m_added_nodes member is\naccessed (and in the last case, also m_addr_fetches), without any chance\nthat within one section another one is called. Hence, we can use an\nordinary Mutex instead of RecursiveMutex.",
      "tree": {
        "sha": "9978b2b75ae7c381dd3041aec93541adf815d644",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9978b2b75ae7c381dd3041aec93541adf815d644"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3726a4595837b66d37f151faf1cec2796d6b74d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3726a4595837b66d37f151faf1cec2796d6b74d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3726a4595837b66d37f151faf1cec2796d6b74d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3726a4595837b66d37f151faf1cec2796d6b74d7/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d52ff5c389643cde613d86fee33d7087f47b8b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d52ff5c389643cde613d86fee33d7087f47b8b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d52ff5c389643cde613d86fee33d7087f47b8b4"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "dd5cc66a0486bad98d5086f7120e31f3c8ae8bb4",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3726a4595837b66d37f151faf1cec2796d6b74d7/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3726a4595837b66d37f151faf1cec2796d6b74d7/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=3726a4595837b66d37f151faf1cec2796d6b74d7",
        "patch": "@@ -1100,7 +1100,7 @@ class CConnman\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     Mutex m_addr_fetches_mutex;\n     std::vector<std::string> m_added_nodes GUARDED_BY(m_added_nodes_mutex);\n-    mutable RecursiveMutex m_added_nodes_mutex;\n+    mutable Mutex m_added_nodes_mutex;\n     std::vector<CNode*> m_nodes GUARDED_BY(m_nodes_mutex);\n     std::list<CNode*> m_nodes_disconnected;\n     mutable RecursiveMutex m_nodes_mutex;"
      }
    ]
  }
]