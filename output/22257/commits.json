[
  {
    "sha": "2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyY2U3YjQ3OTU4YzRhMTBiYTIwZGM4NmMwMTFkNzFjZGE0YjA3MGE1",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-15T21:02:28Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-21T12:28:05Z"
      },
      "message": "test: introduce `tx_from_hex` helper for tx deserialization\n\n`FromHex` is mostly used for transactions, so we introduce a\nshortcut `tx_from_hex` for `FromHex(CTransaction, hex_str)`.",
      "tree": {
        "sha": "9d3ad9433f7b5b054f5b072ebf33462399d9f502",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9d3ad9433f7b5b054f5b072ebf33462399d9f502"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "965e93743454112c0c3c66bf24852f63ee07b862",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/965e93743454112c0c3c66bf24852f63ee07b862",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/965e93743454112c0c3c66bf24852f63ee07b862"
      }
    ],
    "stats": {
      "total": 409,
      "additions": 257,
      "deletions": 152
    },
    "files": [
      {
        "sha": "0c3a9c145e2165bdb5a6d0452f30fba94ee62f2d",
        "filename": "contrib/signet/miner",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/contrib/signet/miner",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/contrib/signet/miner",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/miner?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -23,7 +23,7 @@ PATH_BASE_TEST_FUNCTIONAL = os.path.abspath(os.path.join(PATH_BASE_CONTRIB_SIGNE\n sys.path.insert(0, PATH_BASE_TEST_FUNCTIONAL)\n \n from test_framework.blocktools import WITNESS_COMMITMENT_HEADER, script_BIP34_coinbase_height # noqa: E402\n-from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, ToHex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, uint256_from_str # noqa: E402\n+from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, ToHex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, tx_from_hex, uint256_from_str # noqa: E402\n from test_framework.script import CScriptOp # noqa: E402\n \n logging.basicConfig(\n@@ -216,7 +216,7 @@ def generate_psbt(tmpl, reward_spk, *, blocktime=None):\n         block.nTime = tmpl[\"mintime\"]\n     block.nBits = int(tmpl[\"bits\"], 16)\n     block.nNonce = 0\n-    block.vtx = [cbtx] + [FromHex(CTransaction(), t[\"data\"]) for t in tmpl[\"transactions\"]]\n+    block.vtx = [cbtx] + [tx_from_hex(t[\"data\"]) for t in tmpl[\"transactions\"]]\n \n     witnonce = 0\n     witroot = block.calc_witness_merkle_root()"
      },
      {
        "sha": "2b2341fb03478c7ea6bf1021a37933aa6904bbce",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 19,
        "deletions": 7,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -6,8 +6,20 @@\n \n import time\n \n-from test_framework.blocktools import create_block, NORMAL_GBT_REQUEST_PARAMS, add_witness_commitment\n-from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, FromHex, ToHex\n+from test_framework.blocktools import (\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    add_witness_commitment,\n+    create_block,\n+)\n+from test_framework.messages import (\n+    COIN,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+    ToHex,\n+    tx_from_hex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -215,7 +227,7 @@ def test_sequence_lock_unconfirmed_inputs(self):\n \n         # Create a mempool tx.\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n-        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx1 = tx_from_hex(self.nodes[0].getrawtransaction(txid))\n         tx1.rehash()\n \n         # Anyone-can-spend mempool tx.\n@@ -225,7 +237,7 @@ def test_sequence_lock_unconfirmed_inputs(self):\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n         tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n-        tx2 = FromHex(tx2, tx2_raw)\n+        tx2 = tx_from_hex(tx2_raw)\n         tx2.rehash()\n \n         self.nodes[0].sendrawtransaction(tx2_raw)\n@@ -348,7 +360,7 @@ def test_bip68_not_consensus(self):\n         assert not softfork_active(self.nodes[0], 'csv')\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n \n-        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx1 = tx_from_hex(self.nodes[0].getrawtransaction(txid))\n         tx1.rehash()\n \n         # Make an anyone-can-spend transaction\n@@ -359,7 +371,7 @@ def test_bip68_not_consensus(self):\n \n         # sign tx2\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n-        tx2 = FromHex(tx2, tx2_raw)\n+        tx2 = tx_from_hex(tx2_raw)\n         tx2.rehash()\n \n         self.nodes[0].sendrawtransaction(ToHex(tx2))\n@@ -404,7 +416,7 @@ def test_version2_relay(self):\n         outputs = { self.nodes[1].getnewaddress() : 1.0 }\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         rawtxfund = self.nodes[1].fundrawtransaction(rawtx)['hex']\n-        tx = FromHex(CTransaction(), rawtxfund)\n+        tx = tx_from_hex(rawtxfund)\n         tx.nVersion = 2\n         tx_signed = self.nodes[1].signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n         self.nodes[1].sendrawtransaction(tx_signed)"
      },
      {
        "sha": "0f62701305af2bb9502d5816bb96477b7b256e1e",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 34,
        "deletions": 11,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -5,7 +5,6 @@\n \"\"\"Test the SegWit changeover logic.\"\"\"\n \n from decimal import Decimal\n-from io import BytesIO\n \n from test_framework.address import (\n     key_to_p2pkh,\n@@ -14,9 +13,35 @@\n     script_to_p2sh_p2wsh,\n     script_to_p2wsh,\n )\n-from test_framework.blocktools import witness_script, send_to_witness\n-from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, FromHex, sha256, ToHex\n-from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG, OP_TRUE, OP_DROP\n+from test_framework.blocktools import (\n+    send_to_witness,\n+    witness_script,\n+)\n+from test_framework.messages import (\n+    COIN,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+    ToHex,\n+    sha256,\n+    tx_from_hex,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKSIG,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_TRUE,\n+    hash160,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -179,7 +204,7 @@ def run_test(self):\n         assert self.nodes[1].getblock(blockhash, False) == self.nodes[2].getblock(blockhash, False)\n \n         for tx_id in segwit_tx_list:\n-            tx = FromHex(CTransaction(), self.nodes[2].gettransaction(tx_id)[\"hex\"])\n+            tx = tx_from_hex(self.nodes[2].gettransaction(tx_id)[\"hex\"])\n             assert self.nodes[2].getrawtransaction(tx_id, False, blockhash) != self.nodes[0].getrawtransaction(tx_id, False, blockhash)\n             assert self.nodes[1].getrawtransaction(tx_id, False, blockhash) == self.nodes[2].getrawtransaction(tx_id, False, blockhash)\n             assert self.nodes[0].getrawtransaction(tx_id, False, blockhash) != self.nodes[2].gettransaction(tx_id)[\"hex\"]\n@@ -225,12 +250,12 @@ def run_test(self):\n         # tx1 is allowed to appear in the block, but no others.\n         txid1 = send_to_witness(1, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.996\"))\n         hex_tx = self.nodes[0].gettransaction(txid)['hex']\n-        tx = FromHex(CTransaction(), hex_tx)\n+        tx = tx_from_hex(hex_tx)\n         assert tx.wit.is_null()  # This should not be a segwit input\n         assert txid1 in self.nodes[0].getrawmempool()\n \n         tx1_hex = self.nodes[0].gettransaction(txid1)['hex']\n-        tx1 = FromHex(CTransaction(), tx1_hex)\n+        tx1 = tx_from_hex(tx1_hex)\n \n         # Check that wtxid is properly reported in mempool entry (txid1)\n         assert_equal(int(self.nodes[0].getmempoolentry(txid1)[\"wtxid\"], 16), tx1.calc_sha256(True))\n@@ -245,7 +270,7 @@ def run_test(self):\n         tx.vout.append(CTxOut(int(49.99 * COIN), CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n         tx2_hex = self.nodes[0].signrawtransactionwithwallet(ToHex(tx))['hex']\n         txid2 = self.nodes[0].sendrawtransaction(tx2_hex)\n-        tx = FromHex(CTransaction(), tx2_hex)\n+        tx = tx_from_hex(tx2_hex)\n         assert not tx.wit.is_null()\n \n         # Check that wtxid is properly reported in mempool entry (txid2)\n@@ -611,10 +636,8 @@ def p2pkh_address_to_script(self, v):\n     def create_and_mine_tx_from_txids(self, txids, success=True):\n         tx = CTransaction()\n         for i in txids:\n-            txtmp = CTransaction()\n             txraw = self.nodes[0].getrawtransaction(i, 0, txs_mined[i])\n-            f = BytesIO(hex_str_to_bytes(txraw))\n-            txtmp.deserialize(f)\n+            txtmp = tx_from_hex(txraw)\n             for j in range(len(txtmp.vout)):\n                 tx.vin.append(CTxIn(COutPoint(int('0x' + i, 0), j)))\n         tx.vout.append(CTxOut(0, CScript()))"
      },
      {
        "sha": "0534618d06150e91c3fd6e4a77f5dff7bacc35b3",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -8,7 +8,11 @@\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE, ADDRESS_BCRT1_P2WSH_OP_TRUE\n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.messages import CTransaction, hash256, FromHex\n+from test_framework.messages import (\n+    CTransaction,\n+    hash256,\n+    tx_from_hex,\n+)\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n@@ -393,10 +397,10 @@ def test_sequence(self):\n             bump_info = self.nodes[0].bumpfee(orig_txid)\n             # Mine the pre-bump tx\n             block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1))\n-            tx = FromHex(CTransaction(), raw_tx)\n+            tx = tx_from_hex(raw_tx)\n             block.vtx.append(tx)\n             for txid in more_tx:\n-                tx = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+                tx = tx_from_hex(self.nodes[0].getrawtransaction(txid))\n                 block.vtx.append(tx)\n             add_witness_commitment(block)\n             block.solve()"
      },
      {
        "sha": "1705d957aa03b6147eeaf84db0ebbb0cdeeaabe4",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 27,
        "deletions": 30,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -5,7 +5,6 @@\n \"\"\"Test mempool acceptance of raw transactions.\"\"\"\n \n from decimal import Decimal\n-from io import BytesIO\n import math\n \n from test_framework.test_framework import BitcoinTestFramework\n@@ -14,10 +13,10 @@\n     BIP125_SEQUENCE_NUMBER,\n     COIN,\n     COutPoint,\n-    CTransaction,\n     CTxOut,\n     MAX_BLOCK_BASE_SIZE,\n     MAX_MONEY,\n+    tx_from_hex,\n )\n from test_framework.script import (\n     hash160,\n@@ -33,7 +32,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n-    hex_str_to_bytes,\n )\n \n \n@@ -91,8 +89,7 @@ def run_test(self):\n             inputs=[{\"txid\": txid_in_block, \"vout\": 0, \"sequence\": BIP125_SEQUENCE_NUMBER}],  # RBF is used later\n             outputs=[{node.getnewaddress(): Decimal('0.3') - fee}],\n         ))['hex']\n-        tx = CTransaction()\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx = tx_from_hex(raw_tx_0)\n         txid_0 = tx.rehash()\n         self.check_mempool_result(\n             result_expected=[{'txid': txid_0, 'allowed': True, 'vsize': tx.get_vsize(), 'fees': {'base': fee}}],\n@@ -107,7 +104,7 @@ def run_test(self):\n             outputs=[{node.getnewaddress(): output_amount}],\n             locktime=node.getblockcount() + 2000,  # Can be anything\n         ))['hex']\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_final)))\n+        tx = tx_from_hex(raw_tx_final)\n         fee_expected = coin['amount'] - output_amount\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': True, 'vsize': tx.get_vsize(), 'fees': {'base': fee_expected}}],\n@@ -126,11 +123,11 @@ def run_test(self):\n         )\n \n         self.log.info('A transaction that replaces a mempool transaction')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx = tx_from_hex(raw_tx_0)\n         tx.vout[0].nValue -= int(fee * COIN)  # Double the fee\n         tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER + 1  # Now, opt out of RBF\n         raw_tx_0 = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx = tx_from_hex(raw_tx_0)\n         txid_0 = tx.rehash()\n         self.check_mempool_result(\n             result_expected=[{'txid': txid_0, 'allowed': True, 'vsize': tx.get_vsize(), 'fees': {'base': (2 * fee)}}],\n@@ -141,7 +138,7 @@ def run_test(self):\n         # Send the transaction that replaces the mempool transaction and opts out of replaceability\n         node.sendrawtransaction(hexstring=tx.serialize().hex(), maxfeerate=0)\n         # take original raw_tx_0\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx = tx_from_hex(raw_tx_0)\n         tx.vout[0].nValue -= int(4 * fee * COIN)  # Set more fee\n         # skip re-signing the tx\n         self.check_mempool_result(\n@@ -151,7 +148,7 @@ def run_test(self):\n         )\n \n         self.log.info('A transaction with missing inputs, that never existed')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx = tx_from_hex(raw_tx_0)\n         tx.vin[0].prevout = COutPoint(hash=int('ff' * 32, 16), n=14)\n         # skip re-signing the tx\n         self.check_mempool_result(\n@@ -160,7 +157,7 @@ def run_test(self):\n         )\n \n         self.log.info('A transaction with missing inputs, that existed once in the past')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n+        tx = tx_from_hex(raw_tx_0)\n         tx.vin[0].prevout.n = 1  # Set vout to 1, to spend the other outpoint (49 coins) of the in-chain-tx we want to double spend\n         raw_tx_1 = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n         txid_1 = node.sendrawtransaction(hexstring=raw_tx_1, maxfeerate=0)\n@@ -190,7 +187,7 @@ def run_test(self):\n             inputs=[{'txid': txid_spend_both, 'vout': 0}],\n             outputs=[{node.getnewaddress(): 0.05}],\n         ))['hex']\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         # Reference tx should be valid on itself\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': True, 'vsize': tx.get_vsize(), 'fees': { 'base': Decimal('0.1') - Decimal('0.05')}}],\n@@ -199,25 +196,25 @@ def run_test(self):\n         )\n \n         self.log.info('A transaction with no outputs')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout = []\n         # Skip re-signing the transaction for context independent checks from now on\n-        # tx.deserialize(BytesIO(hex_str_to_bytes(node.signrawtransactionwithwallet(tx.serialize().hex())['hex'])))\n+        # tx = tx_from_hex(node.signrawtransactionwithwallet(tx.serialize().hex())['hex'])\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-vout-empty'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A really large transaction')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vin = [tx.vin[0]] * math.ceil(MAX_BLOCK_BASE_SIZE / len(tx.vin[0].serialize()))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-oversize'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with negative output value')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout[0].nValue *= -1\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-vout-negative'}],\n@@ -226,15 +223,15 @@ def run_test(self):\n \n         # The following two validations prevent overflow of the output amounts (see CVE-2010-5139).\n         self.log.info('A transaction with too large output value')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout[0].nValue = MAX_MONEY + 1\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-vout-toolarge'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with too large sum of output values')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout = [tx.vout[0]] * 2\n         tx.vout[0].nValue = MAX_MONEY\n         self.check_mempool_result(\n@@ -243,7 +240,7 @@ def run_test(self):\n         )\n \n         self.log.info('A transaction with duplicate inputs')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vin = [tx.vin[0]] * 2\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-inputs-duplicate'}],\n@@ -253,26 +250,26 @@ def run_test(self):\n         self.log.info('A coinbase transaction')\n         # Pick the input of the first tx we signed, so it has to be a coinbase tx\n         raw_tx_coinbase_spent = node.getrawtransaction(txid=node.decoderawtransaction(hexstring=raw_tx_in_block)['vin'][0]['txid'])\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_coinbase_spent)))\n+        tx = tx_from_hex(raw_tx_coinbase_spent)\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'coinbase'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('Some nonstandard transactions')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.nVersion = 3  # A version currently non-standard\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'version'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout[0].scriptPubKey = CScript([OP_0])  # Some non-standard script\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'scriptpubkey'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         key = ECKey()\n         key.generate()\n         pubkey = key.get_pubkey().get_bytes()\n@@ -281,34 +278,34 @@ def run_test(self):\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bare-multisig'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vin[0].scriptSig = CScript([OP_HASH160])  # Some not-pushonly scriptSig\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'scriptsig-not-pushonly'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vin[0].scriptSig = CScript([b'a' * 1648]) # Some too large scriptSig (>1650 bytes)\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'scriptsig-size'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         output_p2sh_burn = CTxOut(nValue=540, scriptPubKey=CScript([OP_HASH160, hash160(b'burn'), OP_EQUAL]))\n         num_scripts = 100000 // len(output_p2sh_burn.serialize())  # Use enough outputs to make the tx too large for our policy\n         tx.vout = [output_p2sh_burn] * num_scripts\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'tx-size'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout[0] = output_p2sh_burn\n         tx.vout[0].nValue -= 1  # Make output smaller, such that it is dust for our policy\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'dust'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vout[0].scriptPubKey = CScript([OP_RETURN, b'\\xff'])\n         tx.vout = [tx.vout[0]] * 2\n         self.check_mempool_result(\n@@ -317,7 +314,7 @@ def run_test(self):\n         )\n \n         self.log.info('A timelocked transaction')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vin[0].nSequence -= 1  # Should be non-max, so locktime is not ignored\n         tx.nLockTime = node.getblockcount() + 1\n         self.check_mempool_result(\n@@ -326,7 +323,7 @@ def run_test(self):\n         )\n \n         self.log.info('A transaction that is locked by BIP68 sequence logic')\n-        tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n+        tx = tx_from_hex(raw_tx_reference)\n         tx.vin[0].nSequence = 2  # We could include it in the second block mined from now, but not the very next one\n         # Can skip re-signing the tx because of early rejection\n         self.check_mempool_result("
      },
      {
        "sha": "3c771df0aa8fdb50e238148c33ebfca6a91c1c5b",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 47,
        "deletions": 4,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -15,9 +15,52 @@\n     add_witness_commitment,\n     create_block,\n )\n-from test_framework.messages import BlockTransactions, BlockTransactionsRequest, calculate_shortid, CBlock, CBlockHeader, CInv, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, HeaderAndShortIDs, msg_no_witness_block, msg_no_witness_blocktxn, msg_cmpctblock, msg_getblocktxn, msg_getdata, msg_getheaders, msg_headers, msg_inv, msg_sendcmpct, msg_sendheaders, msg_tx, msg_block, msg_blocktxn, MSG_BLOCK, MSG_CMPCT_BLOCK, MSG_WITNESS_FLAG, NODE_NETWORK, P2PHeaderAndShortIDs, PrefilledTransaction, ser_uint256, ToHex\n-from test_framework.p2p import p2p_lock, P2PInterface\n-from test_framework.script import CScript, OP_TRUE, OP_DROP\n+from test_framework.messages import (\n+    BlockTransactions,\n+    BlockTransactionsRequest,\n+    CBlock,\n+    CBlockHeader,\n+    CInv,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    FromHex,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    MSG_CMPCT_BLOCK,\n+    MSG_WITNESS_FLAG,\n+    NODE_NETWORK,\n+    P2PHeaderAndShortIDs,\n+    PrefilledTransaction,\n+    ToHex,\n+    calculate_shortid,\n+    msg_block,\n+    msg_blocktxn,\n+    msg_cmpctblock,\n+    msg_getblocktxn,\n+    msg_getdata,\n+    msg_getheaders,\n+    msg_headers,\n+    msg_inv,\n+    msg_no_witness_block,\n+    msg_no_witness_blocktxn,\n+    msg_sendcmpct,\n+    msg_sendheaders,\n+    msg_tx,\n+    ser_uint256,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_DROP,\n+    OP_TRUE,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, softfork_active\n \n@@ -257,7 +300,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         for _ in range(num_transactions):\n             txid = node.sendtoaddress(address, 0.1)\n             hex_tx = node.gettransaction(txid)[\"hex\"]\n-            tx = FromHex(CTransaction(), hex_tx)\n+            tx = tx_from_hex(hex_tx)\n             if not tx.wit.is_null():\n                 segwit_tx_generated = True\n "
      },
      {
        "sha": "35bce7c69e4aaf474249afa6ead814c8a80a78ea",
        "filename": "test/functional/p2p_eviction.py",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_eviction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_eviction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_eviction.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -20,7 +20,11 @@\n     create_block,\n     create_coinbase,\n )\n-from test_framework.messages import CTransaction, FromHex, msg_pong, msg_tx\n+from test_framework.messages import (\n+    msg_pong,\n+    msg_tx,\n+    tx_from_hex,\n+)\n from test_framework.p2p import P2PDataStore, P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n@@ -89,7 +93,7 @@ def run_test(self):\n                     'scriptPubKey': prevtx['vout'][0]['scriptPubKey']['hex'],\n                 }],\n             )['hex']\n-            txpeer.send_message(msg_tx(FromHex(CTransaction(), sigtx)))\n+            txpeer.send_message(msg_tx(tx_from_hex(sigtx)))\n             protected_peers.add(current_peer)\n \n         self.log.info(\"Create 8 peers and protect them from eviction by having faster pings\")"
      },
      {
        "sha": "594a28d6626583451623ea076e9ca07e2a7637a9",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -9,9 +9,8 @@\n \n from test_framework.address import ADDRESS_BCRT1_P2WSH_OP_TRUE\n from test_framework.messages import (\n-    CTransaction,\n     CTxInWitness,\n-    FromHex,\n+    tx_from_hex,\n )\n from test_framework.p2p import P2PDataStore\n from test_framework.script import (\n@@ -105,8 +104,7 @@ def check_tx_relay(self):\n         p2p_rebroadcast_wallet = self.nodes[1].add_p2p_connection(P2PDataStore())\n \n         self.log.debug(\"Send a tx from the wallet initially\")\n-        tx = FromHex(\n-            CTransaction(),\n+        tx = tx_from_hex(\n             self.nodes[0].createrawtransaction(\n                 inputs=[{\n                     'txid': block_op_true['tx'][0],"
      },
      {
        "sha": "95c7aec3181323c2e95c68048c7876f2e579ccee",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -40,8 +40,8 @@\n     ser_uint256,\n     ser_vector,\n     sha256,\n+    tx_from_hex,\n     uint256_from_str,\n-    FromHex,\n )\n from test_framework.p2p import (\n     P2PInterface,\n@@ -2122,14 +2122,14 @@ def serialize(self):\n         unspent = next(u for u in self.nodes[0].listunspent() if u['spendable'] and u['address'].startswith('bcrt'))\n \n         raw = self.nodes[0].createrawtransaction([{\"txid\": unspent['txid'], \"vout\": unspent['vout']}], {self.nodes[0].getnewaddress(): 1})\n-        tx = FromHex(CTransaction(), raw)\n+        tx = tx_from_hex(raw)\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, hexstring=serialize_with_bogus_witness(tx).hex(), iswitness=True)\n         with self.nodes[0].assert_debug_log(['Superfluous witness record']):\n             self.test_node.send_and_ping(msg_bogus_tx(tx))\n         raw = self.nodes[0].signrawtransactionwithwallet(raw)\n         assert raw['complete']\n         raw = raw['hex']\n-        tx = FromHex(CTransaction(), raw)\n+        tx = tx_from_hex(raw)\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decoderawtransaction, hexstring=serialize_with_bogus_witness(tx).hex(), iswitness=True)\n         with self.nodes[0].assert_debug_log(['Unknown transaction optional data']):\n             self.test_node.send_and_ping(msg_bogus_tx(tx))"
      },
      {
        "sha": "3e962b4450ff949b8a2bc23f8fc8e75f7ba14a6a",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -8,13 +8,12 @@\n \n from test_framework.messages import (\n     CInv,\n-    CTransaction,\n-    FromHex,\n     MSG_TX,\n     MSG_TYPE_MASK,\n     MSG_WTX,\n     msg_inv,\n     msg_notfound,\n+    tx_from_hex,\n )\n from test_framework.p2p import (\n     P2PInterface,\n@@ -100,7 +99,7 @@ def test_inv_block(self):\n             hexstring=tx,\n             privkeys=[self.nodes[0].get_deterministic_priv_key().key],\n         )['hex']\n-        ctx = FromHex(CTransaction(), tx)\n+        ctx = tx_from_hex(tx)\n         txid = int(ctx.rehash(), 16)\n \n         self.log.info("
      },
      {
        "sha": "ac430f5b39e3250a2c71808ab1ac7f1d2e25da57",
        "filename": "test/functional/rpc_addresses_deprecation.py",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_addresses_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_addresses_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_addresses_deprecation.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -4,9 +4,9 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test deprecation of reqSigs and addresses RPC fields.\"\"\"\n \n-from io import BytesIO\n-\n-from test_framework.messages import CTransaction\n+from test_framework.messages import (\n+    tx_from_hex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -35,8 +35,7 @@ def test_addresses_deprecation(self):\n         signed = node.signrawtransactionwithwallet(raw)['hex']\n \n         # This transaction is derived from test/util/data/txcreatemultisig1.json\n-        tx = CTransaction()\n-        tx.deserialize(BytesIO(hex_str_to_bytes(signed)))\n+        tx = tx_from_hex(signed)\n         tx.vout[0].scriptPubKey = hex_str_to_bytes(\"522102a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff39721021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d2102df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb48553ae\")\n         tx_signed = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n         txid = node.sendrawtransaction(hexstring=tx_signed, maxfeerate=0)"
      },
      {
        "sha": "f6643c7167febb8ca2b855af7b8dc60f5ec00bba",
        "filename": "test/functional/rpc_decodescript.py",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_decodescript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_decodescript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_decodescript.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -4,11 +4,16 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test decoding scripts via decodescript RPC command.\"\"\"\n \n-from test_framework.messages import CTransaction, sha256\n+from test_framework.messages import (\n+    sha256,\n+    tx_from_hex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, hex_str_to_bytes\n+from test_framework.util import (\n+    assert_equal,\n+    hex_str_to_bytes,\n+)\n \n-from io import BytesIO\n \n class DecodeScriptTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -179,8 +184,7 @@ def decoderawtransaction_asm_sighashtype(self):\n         assert_equal('0 3045022100ae3b4e589dfc9d48cb82d41008dc5fa6a86f94d5c54f9935531924602730ab8002202f88cf464414c4ed9fa11b773c5ee944f66e9b05cc1e51d97abc22ce098937ea[ALL] 3045022100b44883be035600e9328a01b66c7d8439b74db64187e76b99a68f7893b701d5380220225bf286493e4c4adcf928c40f785422572eb232f84a0b83b0dea823c3a19c75[ALL] 5221020743d44be989540d27b1b4bbbcfd17721c337cb6bc9af20eb8a32520b393532f2102c0120a1dda9e51a938d39ddd9fe0ebc45ea97e1d27a7cbd671d5431416d3dd87210213820eb3d5f509d7438c9eeecb4157b2f595105e7cd564b3cdbb9ead3da41eed53ae', rpc_result['vin'][0]['scriptSig']['asm'])\n         assert_equal('OP_DUP OP_HASH160 dc863734a218bfe83ef770ee9d41a27f824a6e56 OP_EQUALVERIFY OP_CHECKSIG', rpc_result['vout'][0]['scriptPubKey']['asm'])\n         assert_equal('OP_HASH160 2a5edea39971049a540474c6a99edf0aa4074c58 OP_EQUAL', rpc_result['vout'][1]['scriptPubKey']['asm'])\n-        txSave = CTransaction()\n-        txSave.deserialize(BytesIO(hex_str_to_bytes(tx)))\n+        txSave = tx_from_hex(tx)\n \n         # make sure that a specifically crafted op_return value will not pass all the IsDERSignature checks and then get decoded as a sighash type\n         tx = '01000000015ded05872fdbda629c7d3d02b194763ce3b9b1535ea884e3c8e765d42e316724020000006b48304502204c10d4064885c42638cbff3585915b322de33762598321145ba033fc796971e2022100bb153ad3baa8b757e30a2175bd32852d2e1cb9080f84d7e32fcdfd667934ef1b012103163c0ff73511ea1743fb5b98384a2ff09dd06949488028fd819f4d83f56264efffffffff0200000000000000000b6a0930060201000201000180380100000000001976a9141cabd296e753837c086da7a45a6c2fe0d49d7b7b88ac00000000'"
      },
      {
        "sha": "4b2ed20958d1ec0b4137657192bde9c99ea25e2d",
        "filename": "test/functional/rpc_packages.py",
        "status": "modified",
        "additions": 12,
        "deletions": 24,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_packages.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -5,24 +5,22 @@\n \"\"\"RPCs that handle raw transaction packages.\"\"\"\n \n from decimal import Decimal\n-from io import BytesIO\n import random\n \n from test_framework.address import ADDRESS_BCRT1_P2WSH_OP_TRUE\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.messages import (\n     BIP125_SEQUENCE_NUMBER,\n     COIN,\n-    CTransaction,\n     CTxInWitness,\n+    tx_from_hex,\n )\n from test_framework.script import (\n     CScript,\n     OP_TRUE,\n )\n from test_framework.util import (\n     assert_equal,\n-    hex_str_to_bytes,\n )\n \n class RPCPackagesTest(BitcoinTestFramework):\n@@ -97,9 +95,8 @@ def chain_transaction(self, parent_txid, parent_value, n=0, parent_locking_scrip\n             \"amount\": parent_value,\n         }] if parent_locking_script else None\n         signedtx = node.signrawtransactionwithkey(hexstring=rawtx, privkeys=self.privkeys, prevtxs=prevtxs)\n-        tx = CTransaction()\n         assert signedtx[\"complete\"]\n-        tx.deserialize(BytesIO(hex_str_to_bytes(signedtx[\"hex\"])))\n+        tx = tx_from_hex(signedtx[\"hex\"])\n         return (tx, signedtx[\"hex\"], my_value, tx.vout[0].scriptPubKey.hex())\n \n     def test_independent(self):\n@@ -110,8 +107,7 @@ def test_independent(self):\n \n         self.log.info(\"Test an otherwise valid package with an extra garbage tx appended\")\n         garbage_tx = node.createrawtransaction([{\"txid\": \"00\" * 32, \"vout\": 5}], {self.address: 1})\n-        tx = CTransaction()\n-        tx.deserialize(BytesIO(hex_str_to_bytes(garbage_tx)))\n+        tx = tx_from_hex(garbage_tx)\n         # Only the txid and wtxids are returned because validation is incomplete for the independent txns.\n         # Package validation is atomic: if the node cannot find a UTXO for any single tx in the package,\n         # it terminates immediately to avoid unnecessary, expensive signature verification.\n@@ -123,8 +119,7 @@ def test_independent(self):\n         coin = self.coins.pop()\n         tx_bad_sig_hex = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": 0}],\n                                            {self.address : coin[\"amount\"] - Decimal(\"0.0001\")})\n-        tx_bad_sig = CTransaction()\n-        tx_bad_sig.deserialize(BytesIO(hex_str_to_bytes(tx_bad_sig_hex)))\n+        tx_bad_sig = tx_from_hex(tx_bad_sig_hex)\n         testres_bad_sig = node.testmempoolaccept(self.independent_txns_hex + [tx_bad_sig_hex])\n         # By the time the signature for the last transaction is checked, all the other transactions\n         # have been fully validated, which is why the node returns full validation results for all\n@@ -141,8 +136,7 @@ def test_independent(self):\n                                            {self.address : coin[\"amount\"] - Decimal(\"0.999\")})\n         tx_high_fee_signed = node.signrawtransactionwithkey(hexstring=tx_high_fee_raw, privkeys=self.privkeys)\n         assert tx_high_fee_signed[\"complete\"]\n-        tx_high_fee = CTransaction()\n-        tx_high_fee.deserialize(BytesIO(hex_str_to_bytes(tx_high_fee_signed[\"hex\"])))\n+        tx_high_fee = tx_from_hex(tx_high_fee_signed[\"hex\"])\n         testres_high_fee = node.testmempoolaccept([tx_high_fee_signed[\"hex\"]])\n         assert_equal(testres_high_fee, [\n             {\"txid\": tx_high_fee.rehash(), \"wtxid\": tx_high_fee.getwtxid(), \"allowed\": False, \"reject-reason\": \"max-fee-exceeded\"}\n@@ -198,9 +192,8 @@ def test_multiple_children(self):\n         rawtx = node.createrawtransaction(inputs, outputs)\n \n         parent_signed = node.signrawtransactionwithkey(hexstring=rawtx, privkeys=self.privkeys)\n-        parent_tx = CTransaction()\n         assert parent_signed[\"complete\"]\n-        parent_tx.deserialize(BytesIO(hex_str_to_bytes(parent_signed[\"hex\"])))\n+        parent_tx = tx_from_hex(parent_signed[\"hex\"])\n         parent_txid = parent_tx.rehash()\n         assert node.testmempoolaccept([parent_signed[\"hex\"]])[0][\"allowed\"]\n \n@@ -213,8 +206,7 @@ def test_multiple_children(self):\n \n         # Child B\n         rawtx_b = node.createrawtransaction([{\"txid\": parent_txid, \"vout\": 1}], {self.address : child_value})\n-        tx_child_b = CTransaction()\n-        tx_child_b.deserialize(BytesIO(hex_str_to_bytes(rawtx_b)))\n+        tx_child_b = tx_from_hex(rawtx_b)\n         tx_child_b.wit.vtxinwit = [CTxInWitness()]\n         tx_child_b.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n         tx_child_b_hex = tx_child_b.serialize().hex()\n@@ -293,10 +285,8 @@ def test_conflicting(self):\n         rawtx2 = node.createrawtransaction(inputs, output2)\n         signedtx1 = node.signrawtransactionwithkey(hexstring=rawtx1, privkeys=self.privkeys)\n         signedtx2 = node.signrawtransactionwithkey(hexstring=rawtx2, privkeys=self.privkeys)\n-        tx1 = CTransaction()\n-        tx1.deserialize(BytesIO(hex_str_to_bytes(signedtx1[\"hex\"])))\n-        tx2 = CTransaction()\n-        tx2.deserialize(BytesIO(hex_str_to_bytes(signedtx2[\"hex\"])))\n+        tx1 = tx_from_hex(signedtx1[\"hex\"])\n+        tx2 = tx_from_hex(signedtx2[\"hex\"])\n         assert signedtx1[\"complete\"]\n         assert signedtx2[\"complete\"]\n \n@@ -327,19 +317,17 @@ def test_rbf(self):\n         raw_replaceable_tx = node.createrawtransaction(inputs, output)\n         signed_replaceable_tx = node.signrawtransactionwithkey(hexstring=raw_replaceable_tx, privkeys=self.privkeys)\n         testres_replaceable = node.testmempoolaccept([signed_replaceable_tx[\"hex\"]])\n-        replaceable_tx = CTransaction()\n-        replaceable_tx.deserialize(BytesIO(hex_str_to_bytes(signed_replaceable_tx[\"hex\"])))\n+        replaceable_tx = tx_from_hex(signed_replaceable_tx[\"hex\"])\n         assert_equal(testres_replaceable, [\n             {\"txid\": replaceable_tx.rehash(), \"wtxid\": replaceable_tx.getwtxid(),\n             \"allowed\": True, \"vsize\": replaceable_tx.get_vsize(), \"fees\": { \"base\": fee }}\n         ])\n \n         # Replacement transaction is identical except has double the fee\n-        replacement_tx = CTransaction()\n-        replacement_tx.deserialize(BytesIO(hex_str_to_bytes(signed_replaceable_tx[\"hex\"])))\n+        replacement_tx = tx_from_hex(signed_replaceable_tx[\"hex\"])\n         replacement_tx.vout[0].nValue -= int(fee * COIN)  # Doubled fee\n         signed_replacement_tx = node.signrawtransactionwithkey(replacement_tx.serialize().hex(), self.privkeys)\n-        replacement_tx.deserialize(BytesIO(hex_str_to_bytes(signed_replacement_tx[\"hex\"])))\n+        replacement_tx = tx_from_hex(signed_replacement_tx[\"hex\"])\n \n         self.log.info(\"Test that transactions within a package cannot replace each other\")\n         testres_rbf_conflicting = node.testmempoolaccept([signed_replaceable_tx[\"hex\"], signed_replacement_tx[\"hex\"]])"
      },
      {
        "sha": "b3d57715349a036dd0466c5e0079c8b421eef8f9",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -14,16 +14,18 @@\n \n from collections import OrderedDict\n from decimal import Decimal\n-from io import BytesIO\n \n from test_framework.blocktools import COINBASE_MATURITY\n-from test_framework.messages import CTransaction, ToHex\n+from test_framework.messages import (\n+    CTransaction,\n+    ToHex,\n+    tx_from_hex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n     find_vout_for_address,\n-    hex_str_to_bytes,\n )\n \n \n@@ -127,23 +129,22 @@ def run_test(self):\n         assert_raises_rpc_error(-3, \"Expected type bool\", self.nodes[0].createrawtransaction, [], {}, 0, 'foo')\n \n         self.log.info('Check that createrawtransaction accepts an array and object as outputs')\n-        tx = CTransaction()\n         # One output\n-        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs={address: 99}))))\n+        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs={address: 99}))\n         assert_equal(len(tx.vout), 1)\n         assert_equal(\n             tx.serialize().hex(),\n             self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}]),\n         )\n         # Two outputs\n-        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=OrderedDict([(address, 99), (address2, 99)])))))\n+        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=OrderedDict([(address, 99), (address2, 99)])))\n         assert_equal(len(tx.vout), 2)\n         assert_equal(\n             tx.serialize().hex(),\n             self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}]),\n         )\n         # Multiple mixed outputs\n-        tx.deserialize(BytesIO(hex_str_to_bytes(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))))\n+        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))\n         assert_equal(len(tx.vout), 3)\n         assert_equal(\n             tx.serialize().hex(),"
      },
      {
        "sha": "ef5d08e7b9803eb62ce32d6c0bbfe5438004d356",
        "filename": "test/functional/rpc_signrawtransaction.py",
        "status": "modified",
        "additions": 36,
        "deletions": 11,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_signrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/rpc_signrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signrawtransaction.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -5,17 +5,44 @@\n \"\"\"Test transaction signing using the signrawtransaction* RPCs.\"\"\"\n \n from test_framework.blocktools import COINBASE_MATURITY\n-from test_framework.address import check_script, script_to_p2sh, script_to_p2wsh\n+from test_framework.address import (\n+    check_script,\n+    script_to_p2sh,\n+    script_to_p2wsh,\n+)\n from test_framework.key import ECKey\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error, find_vout_for_address, hex_str_to_bytes\n-from test_framework.messages import sha256, CTransaction, CTxInWitness\n-from test_framework.script import CScript, OP_0, OP_CHECKSIG, OP_CHECKSEQUENCEVERIFY, OP_CHECKLOCKTIMEVERIFY, OP_DROP, OP_TRUE\n-from test_framework.script_util import key_to_p2pkh_script, script_to_p2sh_p2wsh_script, script_to_p2wsh_script\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+    find_vout_for_address,\n+    hex_str_to_bytes,\n+)\n+from test_framework.messages import (\n+    CTxInWitness,\n+    sha256,\n+    tx_from_hex,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    OP_CHECKLOCKTIMEVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSEQUENCEVERIFY,\n+    OP_DROP,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    key_to_p2pkh_script,\n+    script_to_p2sh_p2wsh_script,\n+    script_to_p2wsh_script,\n+)\n from test_framework.wallet_util import bytes_to_wif\n \n-from decimal import Decimal, getcontext\n-from io import BytesIO\n+from decimal import (\n+    Decimal,\n+    getcontext,\n+)\n \n class SignRawTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -265,8 +292,7 @@ def test_signing_with_csv(self):\n         )\n \n         # Set the witness script\n-        ctx = CTransaction()\n-        ctx.deserialize(BytesIO(hex_str_to_bytes(tx)))\n+        ctx = tx_from_hex(tx)\n         ctx.wit.vtxinwit.append(CTxInWitness())\n         ctx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE]), script]\n         tx = ctx.serialize_with_witness().hex()\n@@ -301,8 +327,7 @@ def test_signing_with_cltv(self):\n         )\n \n         # Set the witness script\n-        ctx = CTransaction()\n-        ctx.deserialize(BytesIO(hex_str_to_bytes(tx)))\n+        ctx = tx_from_hex(tx)\n         ctx.wit.vtxinwit.append(CTxInWitness())\n         ctx.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE]), script]\n         tx = ctx.serialize_with_witness().hex()"
      },
      {
        "sha": "0019b7a42626a6a66641a797df38d04a37c4b2f4",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -23,12 +23,12 @@\n     CTxIn,\n     CTxInWitness,\n     CTxOut,\n-    FromHex,\n     ToHex,\n     hash256,\n     hex_str_to_bytes,\n     ser_uint256,\n     sha256,\n+    tx_from_hex,\n     uint256_from_str,\n )\n from .script import (\n@@ -79,7 +79,7 @@ def create_block(hashprev=None, coinbase=None, ntime=None, *, version=None, tmpl\n     if txlist:\n         for tx in txlist:\n             if not hasattr(tx, 'calc_sha256'):\n-                tx = FromHex(CTransaction(), tx)\n+                tx = tx_from_hex(tx)\n             block.vtx.append(tx)\n     block.hashMerkleRoot = block.calc_merkle_root()\n     block.calc_sha256()\n@@ -166,7 +166,7 @@ def create_transaction(node, txid, to_address, *, amount):\n         sign for the output that is being spent.\n     \"\"\"\n     raw_tx = create_raw_transaction(node, txid, to_address, amount=amount)\n-    tx = FromHex(CTransaction(), raw_tx)\n+    tx = tx_from_hex(raw_tx)\n     return tx\n \n def create_raw_transaction(node, txid, to_address, *, amount):\n@@ -248,7 +248,7 @@ def send_to_witness(use_p2wsh, node, utxo, pubkey, encode_p2sh, amount, sign=Tru\n         return node.sendrawtransaction(signed[\"hex\"])\n     else:\n         if (insert_redeem_script):\n-            tx = FromHex(CTransaction(), tx_to_witness)\n+            tx = tx_from_hex(tx_to_witness)\n             tx.vin[0].scriptSig += CScript([hex_str_to_bytes(insert_redeem_script)])\n             tx_to_witness = ToHex(tx)\n "
      },
      {
        "sha": "43c80fa7a8f87fd6e9574efa5c1bb2a2957b9754",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -195,10 +195,17 @@ def FromHex(obj, hex_string):\n     obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n     return obj\n \n+\n # Convert a binary-serializable object to hex (eg for submission via RPC)\n def ToHex(obj):\n     return obj.serialize().hex()\n \n+\n+def tx_from_hex(hex_string):\n+    \"\"\"Deserialize from hex string to a transaction object\"\"\"\n+    return FromHex(CTransaction(), hex_string)\n+\n+\n # Objects that map to bitcoind objects, which can be serialized/deserialized\n \n "
      },
      {
        "sha": "35dbfbba8dc576f3d25c3e9d5be9813aa1293b52",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -19,7 +19,6 @@\n \n from . import coverage\n from .authproxy import AuthServiceProxy, JSONRPCException\n-from io import BytesIO\n from typing import Callable, Optional\n \n logger = logging.getLogger(\"TestFramework.utils\")\n@@ -528,16 +527,15 @@ def gen_return_txouts():\n def create_lots_of_big_transactions(node, txouts, utxos, num, fee):\n     addr = node.getnewaddress()\n     txids = []\n-    from .messages import CTransaction\n+    from .messages import tx_from_hex\n     for _ in range(num):\n         t = utxos.pop()\n         inputs = [{\"txid\": t[\"txid\"], \"vout\": t[\"vout\"]}]\n         outputs = {}\n         change = t['amount'] - fee\n         outputs[addr] = satoshi_round(change)\n         rawtx = node.createrawtransaction(inputs, outputs)\n-        tx = CTransaction()\n-        tx.deserialize(BytesIO(hex_str_to_bytes(rawtx)))\n+        tx = tx_from_hex(rawtx)\n         for txout in txouts:\n             tx.vout.append(txout)\n         newtx = tx.serialize().hex()"
      },
      {
        "sha": "c04986038dd93178fc339dbf56de76419c3cc383",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -14,17 +14,23 @@\n make assumptions about execution order.\n \"\"\"\n from decimal import Decimal\n-import io\n \n-from test_framework.blocktools import COINBASE_MATURITY\n-from test_framework.blocktools import add_witness_commitment, create_block, create_coinbase, send_to_witness\n-from test_framework.messages import BIP125_SEQUENCE_NUMBER, CTransaction\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    add_witness_commitment,\n+    create_block,\n+    create_coinbase,\n+    send_to_witness,\n+)\n+from test_framework.messages import (\n+    BIP125_SEQUENCE_NUMBER,\n+    tx_from_hex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n-    hex_str_to_bytes,\n )\n \n WALLET_PASSPHRASE = \"test\"\n@@ -576,9 +582,7 @@ def spend_one_input(node, dest_address, change_size=Decimal(\"0.00049000\")):\n \n \n def submit_block_with_tx(node, tx):\n-    ctx = CTransaction()\n-    ctx.deserialize(io.BytesIO(hex_str_to_bytes(tx)))\n-\n+    ctx = tx_from_hex(tx)\n     tip = node.getbestblockhash()\n     height = node.getblockcount() + 1\n     block_time = node.getblockheader(tip)[\"mediantime\"] + 1"
      },
      {
        "sha": "1b52ddcba5569fc1a1b135fe99faa12e9d8f2570",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -6,7 +6,10 @@\n \n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.messages import CTransaction, FromHex, ToHex\n+from test_framework.messages import (\n+    ToHex,\n+    tx_from_hex,\n+)\n from test_framework.util import (\n     assert_approx,\n     assert_equal,\n@@ -154,7 +157,7 @@ def run_test(self):\n         self.log.info(\"Fill a wallet with 10,000 outputs corresponding to the same scriptPubKey\")\n         for _ in range(5):\n             raw_tx = self.nodes[0].createrawtransaction([{\"txid\":\"0\"*64, \"vout\":0}], [{addr2[0]: 0.05}])\n-            tx = FromHex(CTransaction(), raw_tx)\n+            tx = tx_from_hex(raw_tx)\n             tx.vin = []\n             tx.vout = [tx.vout[0]] * 2000\n             funded_tx = self.nodes[0].fundrawtransaction(ToHex(tx))"
      },
      {
        "sha": "8b503f5971ba8b43feba7ae3bef8e133edab8b98",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -4,22 +4,17 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the listtransactions API.\"\"\"\n from decimal import Decimal\n-from io import BytesIO\n \n-from test_framework.messages import COIN, CTransaction\n+from test_framework.messages import (\n+    COIN,\n+    tx_from_hex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_array_result,\n     assert_equal,\n-    hex_str_to_bytes,\n )\n \n-def tx_from_hex(hexstring):\n-    tx = CTransaction()\n-    f = BytesIO(hex_str_to_bytes(hexstring))\n-    tx.deserialize(f)\n-    return tx\n-\n class ListTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2"
      },
      {
        "sha": "76b39201e310faa748e530a922cc0930117db1fa",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ce7b47958c4a10ba20dc86c011d71cda4b070a5/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "patch": "@@ -4,12 +4,14 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet accounts properly when there are cloned transactions with malleated scriptsigs.\"\"\"\n \n-import io\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n )\n-from test_framework.messages import CTransaction, COIN\n+from test_framework.messages import (\n+    COIN,\n+    tx_from_hex,\n+)\n \n \n class TxnMallTest(BitcoinTestFramework):\n@@ -71,8 +73,7 @@ def run_test(self):\n         clone_raw = self.nodes[0].createrawtransaction(clone_inputs, clone_outputs, clone_locktime)\n \n         # createrawtransaction randomizes the order of its outputs, so swap them if necessary.\n-        clone_tx = CTransaction()\n-        clone_tx.deserialize(io.BytesIO(bytes.fromhex(clone_raw)))\n+        clone_tx = tx_from_hex(clone_raw)\n         if (rawtx1[\"vout\"][0][\"value\"] == 40 and clone_tx.vout[0].nValue != 40*COIN or rawtx1[\"vout\"][0][\"value\"] != 40 and clone_tx.vout[0].nValue == 40*COIN):\n             (clone_tx.vout[0], clone_tx.vout[1]) = (clone_tx.vout[1], clone_tx.vout[0])\n "
      }
    ]
  },
  {
    "sha": "a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNzkzOTZmZTVmOGY4MWM3OGNmODQxMTdhODcwNzRjNmZmNmM5ZDk1",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-15T22:32:18Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-21T12:30:03Z"
      },
      "message": "test: remove `ToHex` helper, use .serialize().hex() instead",
      "tree": {
        "sha": "6d5a3a187d6968bd1c5236f1b20bb5ba7759628e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d5a3a187d6968bd1c5236f1b20bb5ba7759628e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ce7b47958c4a10ba20dc86c011d71cda4b070a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2ce7b47958c4a10ba20dc86c011d71cda4b070a5"
      }
    ],
    "stats": {
      "total": 230,
      "additions": 128,
      "deletions": 102
    },
    "files": [
      {
        "sha": "d36813a59105bbc0f32288cc63af4462eff7a125",
        "filename": "contrib/signet/miner",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/contrib/signet/miner",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/contrib/signet/miner",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/miner?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -23,7 +23,7 @@ PATH_BASE_TEST_FUNCTIONAL = os.path.abspath(os.path.join(PATH_BASE_CONTRIB_SIGNE\n sys.path.insert(0, PATH_BASE_TEST_FUNCTIONAL)\n \n from test_framework.blocktools import WITNESS_COMMITMENT_HEADER, script_BIP34_coinbase_height # noqa: E402\n-from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, ToHex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, tx_from_hex, uint256_from_str # noqa: E402\n+from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, tx_from_hex, uint256_from_str # noqa: E402\n from test_framework.script import CScriptOp # noqa: E402\n \n logging.basicConfig(\n@@ -274,7 +274,7 @@ def do_genpsbt(args):\n def do_solvepsbt(args):\n     block, signet_solution = do_decode_psbt(sys.stdin.read())\n     block = finish_block(block, signet_solution, args.grind_cmd)\n-    print(ToHex(block))\n+    print(block.serialize().hex())\n \n def nbits_to_target(nbits):\n     shift = (nbits >> 24) & 0xff\n@@ -503,7 +503,7 @@ def do_generate(args):\n         block = finish_block(block, signet_solution, args.grind_cmd)\n \n         # submit block\n-        r = args.bcli(\"-stdin\", \"submitblock\", input=ToHex(block).encode('utf8'))\n+        r = args.bcli(\"-stdin\", \"submitblock\", input=block.serialize().hex().encode('utf8'))\n \n         # report\n         bstr = \"block\" if is_mine else \"backup block\""
      },
      {
        "sha": "e44ce9b57d1c8568416c6b77641b5e895c6064f5",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 14,
        "deletions": 15,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -17,7 +17,6 @@\n     CTransaction,\n     CTxIn,\n     CTxOut,\n-    ToHex,\n     tx_from_hex,\n )\n from test_framework.test_framework import BitcoinTestFramework\n@@ -101,7 +100,7 @@ def test_disable_flag(self):\n         tx1.vin = [CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=sequence_value)]\n         tx1.vout = [CTxOut(value, DUMMY_P2WPKH_SCRIPT)]\n \n-        tx1_signed = self.nodes[0].signrawtransactionwithwallet(ToHex(tx1))[\"hex\"]\n+        tx1_signed = self.nodes[0].signrawtransactionwithwallet(tx1.serialize().hex())[\"hex\"]\n         tx1_id = self.nodes[0].sendrawtransaction(tx1_signed)\n         tx1_id = int(tx1_id, 16)\n \n@@ -114,13 +113,13 @@ def test_disable_flag(self):\n         tx2.vout = [CTxOut(int(value - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2.rehash()\n \n-        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx2))\n+        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, tx2.serialize().hex())\n \n         # Setting the version back down to 1 should disable the sequence lock,\n         # so this should be accepted.\n         tx2.nVersion = 1\n \n-        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        self.nodes[0].sendrawtransaction(tx2.serialize().hex())\n \n     # Calculate the median time past of a prior block (\"confirmations\" before\n     # the current tip).\n@@ -205,9 +204,9 @@ def test_sequence_lock_confirmed_inputs(self):\n                 tx.vin.append(CTxIn(COutPoint(int(utxos[j][\"txid\"], 16), utxos[j][\"vout\"]), nSequence=sequence_value))\n                 value += utxos[j][\"amount\"]*COIN\n             # Overestimate the size of the tx - signatures should be less than 120 bytes, and leave 50 for the output\n-            tx_size = len(ToHex(tx))//2 + 120*num_inputs + 50\n+            tx_size = len(tx.serialize().hex())//2 + 120*num_inputs + 50\n             tx.vout.append(CTxOut(int(value-self.relayfee*tx_size*COIN/1000), DUMMY_P2WPKH_SCRIPT))\n-            rawtx = self.nodes[0].signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n+            rawtx = self.nodes[0].signrawtransactionwithwallet(tx.serialize().hex())[\"hex\"]\n \n             if (using_sequence_locks and not should_pass):\n                 # This transaction should be rejected\n@@ -236,7 +235,7 @@ def test_sequence_lock_unconfirmed_inputs(self):\n         tx2.nVersion = 2\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n         tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n+        tx2_raw = self.nodes[0].signrawtransactionwithwallet(tx2.serialize().hex())[\"hex\"]\n         tx2 = tx_from_hex(tx2_raw)\n         tx2.rehash()\n \n@@ -258,10 +257,10 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n \n             if (orig_tx.hash in node.getrawmempool()):\n                 # sendrawtransaction should fail if the tx is in the mempool\n-                assert_raises_rpc_error(-26, NOT_FINAL_ERROR, node.sendrawtransaction, ToHex(tx))\n+                assert_raises_rpc_error(-26, NOT_FINAL_ERROR, node.sendrawtransaction, tx.serialize().hex())\n             else:\n                 # sendrawtransaction should succeed if the tx is not in the mempool\n-                node.sendrawtransaction(ToHex(tx))\n+                node.sendrawtransaction(tx.serialize().hex())\n \n             return tx\n \n@@ -311,7 +310,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         utxos = self.nodes[0].listunspent()\n         tx5.vin.append(CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"vout\"]), nSequence=1))\n         tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n-        raw_tx5 = self.nodes[0].signrawtransactionwithwallet(ToHex(tx5))[\"hex\"]\n+        raw_tx5 = self.nodes[0].signrawtransactionwithwallet(tx5.serialize().hex())[\"hex\"]\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, raw_tx5)\n \n@@ -337,7 +336,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             block.rehash()\n             block.solve()\n             tip = block.sha256\n-            assert_equal(None if i == 1 else 'inconclusive', self.nodes[0].submitblock(ToHex(block)))\n+            assert_equal(None if i == 1 else 'inconclusive', self.nodes[0].submitblock(block.serialize().hex()))\n             tmpl = self.nodes[0].getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n             tmpl['previousblockhash'] = '%x' % tip\n             tmpl['transactions'] = []\n@@ -370,11 +369,11 @@ def test_bip68_not_consensus(self):\n         tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), DUMMY_P2WPKH_SCRIPT)]\n \n         # sign tx2\n-        tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n+        tx2_raw = self.nodes[0].signrawtransactionwithwallet(tx2.serialize().hex())[\"hex\"]\n         tx2 = tx_from_hex(tx2_raw)\n         tx2.rehash()\n \n-        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        self.nodes[0].sendrawtransaction(tx2.serialize().hex())\n \n         # Now make an invalid spend of tx2 according to BIP68\n         sequence_value = 100 # 100 block relative locktime\n@@ -385,7 +384,7 @@ def test_bip68_not_consensus(self):\n         tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx3.rehash()\n \n-        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx3))\n+        assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, tx3.serialize().hex())\n \n         # make a block that violates bip68; ensure that the tip updates\n         block = create_block(tmpl=self.nodes[0].getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n@@ -418,7 +417,7 @@ def test_version2_relay(self):\n         rawtxfund = self.nodes[1].fundrawtransaction(rawtx)['hex']\n         tx = tx_from_hex(rawtxfund)\n         tx.nVersion = 2\n-        tx_signed = self.nodes[1].signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n+        tx_signed = self.nodes[1].signrawtransactionwithwallet(tx.serialize().hex())[\"hex\"]\n         self.nodes[1].sendrawtransaction(tx_signed)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "48c6d82c135ad7e37e08e04559e2553476179df3",
        "filename": "test/functional/feature_coinstatsindex.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_coinstatsindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_coinstatsindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_coinstatsindex.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -22,7 +22,6 @@\n     CTransaction,\n     CTxIn,\n     CTxOut,\n-    ToHex,\n )\n from test_framework.script import (\n     CScript,\n@@ -170,7 +169,7 @@ def _test_coin_stats_index(self):\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(int(tx1_txid, 16), n), b''))\n         tx2.vout.append(CTxOut(int(20.99 * COIN), CScript([OP_RETURN] + [OP_FALSE]*30)))\n-        tx2_hex = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))['hex']\n+        tx2_hex = self.nodes[0].signrawtransactionwithwallet(tx2.serialize().hex())['hex']\n         self.nodes[0].sendrawtransaction(tx2_hex)\n \n         # Include both txs in a block\n@@ -207,7 +206,7 @@ def _test_coin_stats_index(self):\n         block_time = self.nodes[0].getblock(tip)['time'] + 1\n         block = create_block(int(tip, 16), cb, block_time)\n         block.solve()\n-        self.nodes[0].submitblock(ToHex(block))\n+        self.nodes[0].submitblock(block.serialize().hex())\n         self.sync_all()\n \n         self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))"
      },
      {
        "sha": "c532300ce2106ed69d4ab3d92a8a7c60965b63a0",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -36,7 +36,6 @@\n     CTransaction,\n     CTxIn,\n     CTxOut,\n-    ToHex,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -208,7 +207,7 @@ def generate_small_transactions(self, node, count, utxo_list):\n                 tx.vout.append(CTxOut(output_amount, hex_str_to_bytes(utxo['scriptPubKey'])))\n \n             # Sign and send the transaction to get into the mempool\n-            tx_signed_hex = node.signrawtransactionwithwallet(ToHex(tx))['hex']\n+            tx_signed_hex = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n             node.sendrawtransaction(tx_signed_hex)\n             num_transactions += 1\n "
      },
      {
        "sha": "8ccdf87ff392fe2e03aa9e6f77d01508963d84ac",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 21,
        "deletions": 6,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -6,8 +6,23 @@\n from decimal import Decimal\n import random\n \n-from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, ToHex, COIN\n-from test_framework.script import CScript, OP_1, OP_DROP, OP_2, OP_HASH160, OP_EQUAL, hash160, OP_TRUE\n+from test_framework.messages import (\n+    COIN,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_1,\n+    OP_2,\n+    OP_DROP,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_TRUE,\n+    hash160,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -64,11 +79,11 @@ def small_txpuzzle_randfee(from_node, conflist, unconflist, amount, min_fee, fee\n     # the ScriptSig that will satisfy the ScriptPubKey.\n     for inp in tx.vin:\n         inp.scriptSig = SCRIPT_SIG[inp.prevout.n]\n-    txid = from_node.sendrawtransaction(hexstring=ToHex(tx), maxfeerate=0)\n+    txid = from_node.sendrawtransaction(hexstring=tx.serialize().hex(), maxfeerate=0)\n     unconflist.append({\"txid\": txid, \"vout\": 0, \"amount\": total_in - amount - fee})\n     unconflist.append({\"txid\": txid, \"vout\": 1, \"amount\": amount})\n \n-    return (ToHex(tx), fee)\n+    return (tx.serialize().hex(), fee)\n \n \n def split_inputs(from_node, txins, txouts, initial_split=False):\n@@ -91,10 +106,10 @@ def split_inputs(from_node, txins, txouts, initial_split=False):\n     # If this is the initial split we actually need to sign the transaction\n     # Otherwise we just need to insert the proper ScriptSig\n     if (initial_split):\n-        completetx = from_node.signrawtransactionwithwallet(ToHex(tx))[\"hex\"]\n+        completetx = from_node.signrawtransactionwithwallet(tx.serialize().hex())[\"hex\"]\n     else:\n         tx.vin[0].scriptSig = SCRIPT_SIG[prevtxout[\"vout\"]]\n-        completetx = ToHex(tx)\n+        completetx = tx.serialize().hex()\n     txid = from_node.sendrawtransaction(hexstring=completetx, maxfeerate=0)\n     txouts.append({\"txid\": txid, \"vout\": 0, \"amount\": half_change})\n     txouts.append({\"txid\": txid, \"vout\": 1, \"amount\": rem_change})"
      },
      {
        "sha": "cedb7b57caa14eb5daf6ce68e748a9cd065dd8ae",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -11,8 +11,12 @@\n import os\n \n from test_framework.blocktools import create_coinbase\n-from test_framework.messages import CBlock, ToHex\n-from test_framework.script import CScript, OP_RETURN, OP_NOP\n+from test_framework.messages import CBlock\n+from test_framework.script import (\n+    CScript,\n+    OP_NOP,\n+    OP_RETURN,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -62,7 +66,7 @@ def mine_large_blocks(node, n):\n         block.solve()\n \n         # Submit to the node\n-        node.submitblock(ToHex(block))\n+        node.submitblock(block.serialize().hex())\n \n         previousblockhash = block.sha256\n         height += 1"
      },
      {
        "sha": "e42f8045dbecf00a77cd106932e123667a02959f",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 42,
        "deletions": 39,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -7,7 +7,14 @@\n from decimal import Decimal\n \n from test_framework.blocktools import COINBASE_MATURITY\n-from test_framework.messages import COIN, COutPoint, CTransaction, CTxIn, CTxOut, BIP125_SEQUENCE_NUMBER\n+from test_framework.messages import (\n+    BIP125_SEQUENCE_NUMBER,\n+    COIN,\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxOut,\n+)\n from test_framework.script import CScript, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, satoshi_round\n@@ -17,10 +24,6 @@\n MAX_REPLACEMENT_LIMIT = 100\n \n \n-def txToHex(tx):\n-    return tx.serialize().hex()\n-\n-\n def make_utxo(node, amount, confirmed=True, scriptPubKey=DUMMY_P2WPKH_SCRIPT):\n     \"\"\"Create a txout with a given amount and scriptPubKey\n \n@@ -44,7 +47,7 @@ def make_utxo(node, amount, confirmed=True, scriptPubKey=DUMMY_P2WPKH_SCRIPT):\n     tx2.vout = [CTxOut(amount, scriptPubKey)]\n     tx2.rehash()\n \n-    signed_tx = node.signrawtransactionwithwallet(txToHex(tx2))\n+    signed_tx = node.signrawtransactionwithwallet(tx2.serialize().hex())\n \n     txid = node.sendrawtransaction(signed_tx['hex'], 0)\n \n@@ -133,7 +136,7 @@ def test_simple_doublespend(self):\n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx1a_hex = txToHex(tx1a)\n+        tx1a_hex = tx1a.serialize().hex()\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n         self.sync_all()\n@@ -142,7 +145,7 @@ def test_simple_doublespend(self):\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(1 * COIN, DUMMY_2_P2WPKH_SCRIPT)]\n-        tx1b_hex = txToHex(tx1b)\n+        tx1b_hex = tx1b.serialize().hex()\n \n         # This will raise an exception due to insufficient fee\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n@@ -151,7 +154,7 @@ def test_simple_doublespend(self):\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx1b_hex = txToHex(tx1b)\n+        tx1b_hex = tx1b.serialize().hex()\n         # Works when enabled\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n \n@@ -176,7 +179,7 @@ def test_doublespend_chain(self):\n             tx = CTransaction()\n             tx.vin = [CTxIn(prevout, nSequence=0)]\n             tx.vout = [CTxOut(remaining_value, CScript([1, OP_DROP] * 15 + [1]))]\n-            tx_hex = txToHex(tx)\n+            tx_hex = tx.serialize().hex()\n             txid = self.nodes[0].sendrawtransaction(tx_hex, 0)\n             chain_txids.append(txid)\n             prevout = COutPoint(int(txid, 16), 0)\n@@ -186,7 +189,7 @@ def test_doublespend_chain(self):\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(initial_nValue - 30 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        dbl_tx_hex = txToHex(dbl_tx)\n+        dbl_tx_hex = dbl_tx.serialize().hex()\n \n         # This will raise an exception due to insufficient fee\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n@@ -195,7 +198,7 @@ def test_doublespend_chain(self):\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        dbl_tx_hex = txToHex(dbl_tx)\n+        dbl_tx_hex = dbl_tx.serialize().hex()\n         self.nodes[0].sendrawtransaction(dbl_tx_hex, 0)\n \n         mempool = self.nodes[0].getrawmempool()\n@@ -223,7 +226,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001 * COIN, _to\n             tx = CTransaction()\n             tx.vin = [CTxIn(prevout, nSequence=0)]\n             tx.vout = vout\n-            tx_hex = txToHex(tx)\n+            tx_hex = tx.serialize().hex()\n \n             assert len(tx.serialize()) < 100000\n             txid = self.nodes[0].sendrawtransaction(tx_hex, 0)\n@@ -248,15 +251,15 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001 * COIN, _to\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(initial_nValue - fee * n, DUMMY_P2WPKH_SCRIPT)]\n-        dbl_tx_hex = txToHex(dbl_tx)\n+        dbl_tx_hex = dbl_tx.serialize().hex()\n         # This will raise an exception due to insufficient fee\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n \n         # 1 BTC fee is enough\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(initial_nValue - fee * n - 1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        dbl_tx_hex = txToHex(dbl_tx)\n+        dbl_tx_hex = dbl_tx.serialize().hex()\n         self.nodes[0].sendrawtransaction(dbl_tx_hex, 0)\n \n         mempool = self.nodes[0].getrawmempool()\n@@ -276,7 +279,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001 * COIN, _to\n             dbl_tx = CTransaction()\n             dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n             dbl_tx.vout = [CTxOut(initial_nValue - 2 * fee * n, DUMMY_P2WPKH_SCRIPT)]\n-            dbl_tx_hex = txToHex(dbl_tx)\n+            dbl_tx_hex = dbl_tx.serialize().hex()\n             # This will raise an exception\n             assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n \n@@ -291,15 +294,15 @@ def test_replacement_feeperkb(self):\n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx1a_hex = txToHex(tx1a)\n+        tx1a_hex = tx1a.serialize().hex()\n         self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n         # Higher fee, but the fee per KB is much lower, so the replacement is\n         # rejected.\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(int(0.001 * COIN), CScript([b'a' * 999000]))]\n-        tx1b_hex = txToHex(tx1b)\n+        tx1b_hex = tx1b.serialize().hex()\n \n         # This will raise an exception due to insufficient fee\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n@@ -312,7 +315,7 @@ def test_spends_of_conflicting_outputs(self):\n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(utxo1, nSequence=0)]\n         tx1a.vout = [CTxOut(int(1.1 * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx1a_hex = txToHex(tx1a)\n+        tx1a_hex = tx1a.serialize().hex()\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n         tx1a_txid = int(tx1a_txid, 16)\n@@ -322,7 +325,7 @@ def test_spends_of_conflicting_outputs(self):\n         tx2.vin = [CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0)]\n         tx2.vin.append(CTxIn(COutPoint(tx1a_txid, 0), nSequence=0))\n         tx2.vout = tx1a.vout\n-        tx2_hex = txToHex(tx2)\n+        tx2_hex = tx2.serialize().hex()\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n@@ -331,15 +334,15 @@ def test_spends_of_conflicting_outputs(self):\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n         tx1b.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx1b_hex = txToHex(tx1b)\n+        tx1b_hex = tx1b.serialize().hex()\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n         tx1b_txid = int(tx1b_txid, 16)\n \n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0),\n                    CTxIn(COutPoint(tx1b_txid, 0))]\n         tx2.vout = tx1a.vout\n-        tx2_hex = txToHex(tx2)\n+        tx2_hex = tx2.serialize().hex()\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n@@ -352,13 +355,13 @@ def test_new_unconfirmed_inputs(self):\n         tx1 = CTransaction()\n         tx1.vin = [CTxIn(confirmed_utxo)]\n         tx1.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx1_hex = txToHex(tx1)\n+        tx1_hex = tx1.serialize().hex()\n         self.nodes[0].sendrawtransaction(tx1_hex, 0)\n \n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)]\n         tx2.vout = tx1.vout\n-        tx2_hex = txToHex(tx2)\n+        tx2_hex = tx2.serialize().hex()\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"replacement-adds-unconfirmed\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n@@ -381,7 +384,7 @@ def test_too_many_replacements(self):\n         splitting_tx = CTransaction()\n         splitting_tx.vin = [CTxIn(utxo, nSequence=0)]\n         splitting_tx.vout = outputs\n-        splitting_tx_hex = txToHex(splitting_tx)\n+        splitting_tx_hex = splitting_tx.serialize().hex()\n \n         txid = self.nodes[0].sendrawtransaction(splitting_tx_hex, 0)\n         txid = int(txid, 16)\n@@ -391,7 +394,7 @@ def test_too_many_replacements(self):\n             tx_i = CTransaction()\n             tx_i.vin = [CTxIn(COutPoint(txid, i), nSequence=0)]\n             tx_i.vout = [CTxOut(split_value - fee, DUMMY_P2WPKH_SCRIPT)]\n-            tx_i_hex = txToHex(tx_i)\n+            tx_i_hex = tx_i.serialize().hex()\n             self.nodes[0].sendrawtransaction(tx_i_hex, 0)\n \n         # Now create doublespend of the whole lot; should fail.\n@@ -404,7 +407,7 @@ def test_too_many_replacements(self):\n         double_tx = CTransaction()\n         double_tx.vin = inputs\n         double_tx.vout = [CTxOut(double_spend_value, CScript([b'a']))]\n-        double_tx_hex = txToHex(double_tx)\n+        double_tx_hex = double_tx.serialize().hex()\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, double_tx_hex, 0)\n@@ -413,7 +416,7 @@ def test_too_many_replacements(self):\n         double_tx = CTransaction()\n         double_tx.vin = inputs[0:-1]\n         double_tx.vout = [CTxOut(double_spend_value, CScript([b'a']))]\n-        double_tx_hex = txToHex(double_tx)\n+        double_tx_hex = double_tx.serialize().hex()\n         self.nodes[0].sendrawtransaction(double_tx_hex, 0)\n \n     def test_opt_in(self):\n@@ -424,7 +427,7 @@ def test_opt_in(self):\n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0xffffffff)]\n         tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx1a_hex = txToHex(tx1a)\n+        tx1a_hex = tx1a.serialize().hex()\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n         # This transaction isn't shown as replaceable\n@@ -434,7 +437,7 @@ def test_opt_in(self):\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx1b_hex = txToHex(tx1b)\n+        tx1b_hex = tx1b.serialize().hex()\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n@@ -445,14 +448,14 @@ def test_opt_in(self):\n         tx2a = CTransaction()\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0xfffffffe)]\n         tx2a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx2a_hex = txToHex(tx2a)\n+        tx2a_hex = tx2a.serialize().hex()\n         tx2a_txid = self.nodes[0].sendrawtransaction(tx2a_hex, 0)\n \n         # Still shouldn't be able to double-spend\n         tx2b = CTransaction()\n         tx2b.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n         tx2b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx2b_hex = txToHex(tx2b)\n+        tx2b_hex = tx2b.serialize().hex()\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx2b_hex, 0)\n@@ -468,7 +471,7 @@ def test_opt_in(self):\n         tx3a.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0xffffffff),\n                     CTxIn(COutPoint(tx2a_txid, 0), nSequence=0xfffffffd)]\n         tx3a.vout = [CTxOut(int(0.9 * COIN), CScript([b'c'])), CTxOut(int(0.9 * COIN), CScript([b'd']))]\n-        tx3a_hex = txToHex(tx3a)\n+        tx3a_hex = tx3a.serialize().hex()\n \n         tx3a_txid = self.nodes[0].sendrawtransaction(tx3a_hex, 0)\n \n@@ -478,12 +481,12 @@ def test_opt_in(self):\n         tx3b = CTransaction()\n         tx3b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n         tx3b.vout = [CTxOut(int(0.5 * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx3b_hex = txToHex(tx3b)\n+        tx3b_hex = tx3b.serialize().hex()\n \n         tx3c = CTransaction()\n         tx3c.vin = [CTxIn(COutPoint(tx2a_txid, 0), nSequence=0)]\n         tx3c.vout = [CTxOut(int(0.5 * COIN), DUMMY_P2WPKH_SCRIPT)]\n-        tx3c_hex = txToHex(tx3c)\n+        tx3c_hex = tx3c.serialize().hex()\n \n         self.nodes[0].sendrawtransaction(tx3b_hex, 0)\n         # If tx3b was accepted, tx3c won't look like a replacement,\n@@ -500,14 +503,14 @@ def test_prioritised_transactions(self):\n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx1a_hex = txToHex(tx1a)\n+        tx1a_hex = tx1a.serialize().hex()\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n         # Higher fee, but the actual fee per KB is much lower.\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(int(0.001 * COIN), CScript([b'a' * 740000]))]\n-        tx1b_hex = txToHex(tx1b)\n+        tx1b_hex = tx1b.serialize().hex()\n \n         # Verify tx1b cannot replace tx1a.\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n@@ -526,15 +529,15 @@ def test_prioritised_transactions(self):\n         tx2a = CTransaction()\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n         tx2a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n-        tx2a_hex = txToHex(tx2a)\n+        tx2a_hex = tx2a.serialize().hex()\n         self.nodes[0].sendrawtransaction(tx2a_hex, 0)\n \n         # Lower fee, but we'll prioritise it\n         tx2b = CTransaction()\n         tx2b.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n         tx2b.vout = [CTxOut(int(1.01 * COIN), DUMMY_P2WPKH_SCRIPT)]\n         tx2b.rehash()\n-        tx2b_hex = txToHex(tx2b)\n+        tx2b_hex = tx2b.serialize().hex()\n \n         # Verify tx2b cannot replace tx2a.\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx2b_hex, 0)"
      },
      {
        "sha": "42910904d78e85053852e802ee5545f557428076",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -23,7 +23,6 @@\n     CTransaction,\n     CTxIn,\n     CTxOut,\n-    ToHex,\n     sha256,\n     tx_from_hex,\n )\n@@ -268,7 +267,7 @@ def run_test(self):\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(int(txid1, 16), 0), b''))\n         tx.vout.append(CTxOut(int(49.99 * COIN), CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))\n-        tx2_hex = self.nodes[0].signrawtransactionwithwallet(ToHex(tx))['hex']\n+        tx2_hex = self.nodes[0].signrawtransactionwithwallet(tx.serialize().hex())['hex']\n         txid2 = self.nodes[0].sendrawtransaction(tx2_hex)\n         tx = tx_from_hex(tx2_hex)\n         assert not tx.wit.is_null()\n@@ -285,7 +284,7 @@ def run_test(self):\n         tx.vin.append(CTxIn(COutPoint(int(txid2, 16), 0), b\"\"))\n         tx.vout.append(CTxOut(int(49.95 * COIN), CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])))  # Huge fee\n         tx.calc_sha256()\n-        txid3 = self.nodes[0].sendrawtransaction(hexstring=ToHex(tx), maxfeerate=0)\n+        txid3 = self.nodes[0].sendrawtransaction(hexstring=tx.serialize().hex(), maxfeerate=0)\n         assert tx.wit.is_null()\n         assert txid3 in self.nodes[0].getrawmempool()\n "
      },
      {
        "sha": "99283b69b0cbc1d04b04d9210b95cd7310bc05fd",
        "filename": "test/functional/feature_taproot.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -19,7 +19,6 @@\n     CTxIn,\n     CTxInWitness,\n     CTxOut,\n-    ToHex,\n )\n from test_framework.script import (\n     ANNEX_TAG,\n@@ -1306,7 +1305,7 @@ def test_spenders(self, node, spenders, input_counts):\n             # Add change\n             fund_tx.vout.append(CTxOut(balance - 10000, random.choice(host_spks)))\n             # Ask the wallet to sign\n-            ss = BytesIO(bytes.fromhex(node.signrawtransactionwithwallet(ToHex(fund_tx))[\"hex\"]))\n+            ss = BytesIO(bytes.fromhex(node.signrawtransactionwithwallet(fund_tx.serialize().hex())[\"hex\"]))\n             fund_tx.deserialize(ss)\n             # Construct UTXOData entries\n             fund_tx.rehash()"
      },
      {
        "sha": "15f352d68cc65a55cdd9e5b8b65b5c143229da34",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -5,8 +5,15 @@\n \"\"\"Test the ZMQ notification interface.\"\"\"\n import struct\n \n-from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE, ADDRESS_BCRT1_P2WSH_OP_TRUE\n-from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n+from test_framework.address import (\n+    ADDRESS_BCRT1_P2WSH_OP_TRUE,\n+    ADDRESS_BCRT1_UNSPENDABLE,\n+)\n+from test_framework.blocktools import (\n+    add_witness_commitment,\n+    create_block,\n+    create_coinbase,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.messages import (\n     CTransaction,"
      },
      {
        "sha": "6b8e2b305076d789244db017546a628e982ce47e",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -34,7 +34,6 @@\n     NODE_NETWORK,\n     P2PHeaderAndShortIDs,\n     PrefilledTransaction,\n-    ToHex,\n     calculate_shortid,\n     msg_block,\n     msg_blocktxn,\n@@ -62,7 +61,10 @@\n     OP_TRUE,\n )\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, softfork_active\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n \n # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n class TestP2PConn(P2PInterface):\n@@ -715,9 +717,9 @@ def test_end_to_end_block_relay(self, listeners):\n \n         [l.clear_block_announcement() for l in listeners]\n \n-        # ToHex() won't serialize with witness, but this block has no witnesses\n-        # anyway. TODO: repeat this test with witness tx's to a segwit node.\n-        node.submitblock(ToHex(block))\n+        # serialize without witness (this block has no witnesses anyway).\n+        # TODO: repeat this test with witness tx's to a segwit node.\n+        node.submitblock(block.serialize().hex())\n \n         for l in listeners:\n             l.wait_until(lambda: \"cmpctblock\" in l.last_message, timeout=30)"
      },
      {
        "sha": "db57368eae87cb3f5f38c5bb746125d596cbc9a9",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -18,7 +18,6 @@\n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.messages import (\n     CTransaction,\n-    ToHex,\n     tx_from_hex,\n )\n from test_framework.test_framework import BitcoinTestFramework\n@@ -451,14 +450,14 @@ def run_test(self):\n         # As transaction version is unsigned, this should convert to its unsigned equivalent.\n         tx = CTransaction()\n         tx.nVersion = -0x80000000\n-        rawtx = ToHex(tx)\n+        rawtx = tx.serialize().hex()\n         decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n         assert_equal(decrawtx['version'], 0x80000000)\n \n         # Test the maximum transaction version number that fits in a signed 32-bit integer.\n         tx = CTransaction()\n         tx.nVersion = 0x7fffffff\n-        rawtx = ToHex(tx)\n+        rawtx = tx.serialize().hex()\n         decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n         assert_equal(decrawtx['version'], 0x7fffffff)\n "
      },
      {
        "sha": "9afeeaff1089984d4ed1422b07c98d3f19fb3009",
        "filename": "test/functional/rpc_txoutproof.py",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/rpc_txoutproof.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/rpc_txoutproof.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_txoutproof.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -5,9 +5,15 @@\n \"\"\"Test gettxoutproof and verifytxoutproof RPCs.\"\"\"\n \n from test_framework.blocktools import COINBASE_MATURITY\n-from test_framework.messages import CMerkleBlock, FromHex, ToHex\n+from test_framework.messages import (\n+    CMerkleBlock,\n+    FromHex,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n from test_framework.wallet import MiniWallet\n \n \n@@ -91,7 +97,7 @@ def run_test(self):\n         tweaked_proof = FromHex(CMerkleBlock(), proof)\n \n         # Make sure that our serialization/deserialization is working\n-        assert txid1 in self.nodes[0].verifytxoutproof(ToHex(tweaked_proof))\n+        assert txid1 in self.nodes[0].verifytxoutproof(tweaked_proof.serialize().hex())\n \n         # Check to see if we can go up the merkle tree and pass this off as a\n         # single-transaction block\n@@ -100,7 +106,7 @@ def run_test(self):\n         tweaked_proof.txn.vBits = [True] + [False]*7\n \n         for n in self.nodes:\n-            assert not n.verifytxoutproof(ToHex(tweaked_proof))\n+            assert not n.verifytxoutproof(tweaked_proof.serialize().hex())\n \n         # TODO: try more variants, eg transactions at different depths, and\n         # verify that the proofs are invalid"
      },
      {
        "sha": "fa943cb716e6a9bd67bbb5ad5691dc83317ee223",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -23,7 +23,6 @@\n     CTxIn,\n     CTxInWitness,\n     CTxOut,\n-    ToHex,\n     hash256,\n     hex_str_to_bytes,\n     ser_uint256,\n@@ -250,7 +249,7 @@ def send_to_witness(use_p2wsh, node, utxo, pubkey, encode_p2sh, amount, sign=Tru\n         if (insert_redeem_script):\n             tx = tx_from_hex(tx_to_witness)\n             tx.vin[0].scriptSig += CScript([hex_str_to_bytes(insert_redeem_script)])\n-            tx_to_witness = ToHex(tx)\n+            tx_to_witness = tx.serialize().hex()\n \n     return node.sendrawtransaction(tx_to_witness)\n "
      },
      {
        "sha": "f43c1eb10f48cb9688831d97351052df289e1886",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -196,11 +196,6 @@ def FromHex(obj, hex_string):\n     return obj\n \n \n-# Convert a binary-serializable object to hex (eg for submission via RPC)\n-def ToHex(obj):\n-    return obj.serialize().hex()\n-\n-\n def tx_from_hex(hex_string):\n     \"\"\"Deserialize from hex string to a transaction object\"\"\"\n     return FromHex(CTransaction(), hex_string)"
      },
      {
        "sha": "d9d135a98675e686cd09419235352dd6cd341eaa",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -7,7 +7,6 @@\n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.messages import (\n-    ToHex,\n     tx_from_hex,\n )\n from test_framework.util import (\n@@ -160,7 +159,7 @@ def run_test(self):\n             tx = tx_from_hex(raw_tx)\n             tx.vin = []\n             tx.vout = [tx.vout[0]] * 2000\n-            funded_tx = self.nodes[0].fundrawtransaction(ToHex(tx))\n+            funded_tx = self.nodes[0].fundrawtransaction(tx.serialize().hex())\n             signed_tx = self.nodes[0].signrawtransactionwithwallet(funded_tx['hex'])\n             self.nodes[0].sendrawtransaction(signed_tx['hex'])\n             self.nodes[0].generate(1)"
      },
      {
        "sha": "37dee219e733d743cbd9288b7c5d630a6ecf7df5",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a79396fe5f8f81c78cf84117a87074c6ff6c9d95/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "patch": "@@ -5,8 +5,10 @@\n \"\"\"Test that the wallet resends transactions periodically.\"\"\"\n import time\n \n-from test_framework.blocktools import create_block, create_coinbase\n-from test_framework.messages import ToHex\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n from test_framework.p2p import P2PTxInvStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n@@ -48,7 +50,7 @@ def run_test(self):\n         block = create_block(int(node.getbestblockhash(), 16), create_coinbase(node.getblockcount() + 1), block_time)\n         block.rehash()\n         block.solve()\n-        node.submitblock(ToHex(block))\n+        node.submitblock(block.serialize().hex())\n \n         # Set correct m_best_block_time, which is used in ResendWalletTransactions\n         node.syncwithvalidationinterfacequeue()"
      }
    ]
  },
  {
    "sha": "191405420815d49ab50184513717a303fc2744d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOTE0MDU0MjA4MTVkNDlhYjUwMTg0NTEzNzE3YTMwM2ZjMjc0NGQ2",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-20T12:01:36Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-21T12:33:59Z"
      },
      "message": "scripted-diff: test: rename `FromHex` to `from_hex`\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/\\<FromHex\\>/from_hex/g' $(git grep -l FromHex)\n-END VERIFY SCRIPT-\n\nCo-authored-by: MarcoFalke <falke.marco@gmail.com>",
      "tree": {
        "sha": "64c9af3f017abdf55e4b7f6da8e3f164a4c14bc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64c9af3f017abdf55e4b7f6da8e3f164a4c14bc7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/191405420815d49ab50184513717a303fc2744d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/191405420815d49ab50184513717a303fc2744d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/191405420815d49ab50184513717a303fc2744d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/191405420815d49ab50184513717a303fc2744d6/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a79396fe5f8f81c78cf84117a87074c6ff6c9d95",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a79396fe5f8f81c78cf84117a87074c6ff6c9d95"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 18,
      "deletions": 18
    },
    "files": [
      {
        "sha": "78e1fa5ecd2663a2fbd37ef575fd6850fba5f424",
        "filename": "contrib/signet/miner",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/contrib/signet/miner",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/contrib/signet/miner",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/miner?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -23,7 +23,7 @@ PATH_BASE_TEST_FUNCTIONAL = os.path.abspath(os.path.join(PATH_BASE_CONTRIB_SIGNE\n sys.path.insert(0, PATH_BASE_TEST_FUNCTIONAL)\n \n from test_framework.blocktools import WITNESS_COMMITMENT_HEADER, script_BIP34_coinbase_height # noqa: E402\n-from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, tx_from_hex, uint256_from_str # noqa: E402\n+from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, from_hex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, tx_from_hex, uint256_from_str # noqa: E402\n from test_framework.script import CScriptOp # noqa: E402\n \n logging.basicConfig(\n@@ -37,7 +37,7 @@ RE_MULTIMINER = re.compile(\"^(\\d+)(-(\\d+))?/(\\d+)$\")\n \n # #### some helpers that could go into test_framework\n \n-# like FromHex, but without the hex part\n+# like from_hex, but without the hex part\n def FromBinary(cls, stream):\n     \"\"\"deserialize a binary stream (or bytes object) into an object\"\"\"\n     # handle bytes object by turning it into a stream\n@@ -195,7 +195,7 @@ def finish_block(block, signet_solution, grind_cmd):\n         headhex = CBlockHeader.serialize(block).hex()\n         cmd = grind_cmd.split(\" \") + [headhex]\n         newheadhex = subprocess.run(cmd, stdout=subprocess.PIPE, input=b\"\", check=True).stdout.strip()\n-        newhead = FromHex(CBlockHeader(), newheadhex.decode('utf8'))\n+        newhead = from_hex(CBlockHeader(), newheadhex.decode('utf8'))\n         block.nNonce = newhead.nNonce\n         block.rehash()\n     return block"
      },
      {
        "sha": "afc0bdb8c53b85562a2659bb3038e9614c1f9a9c",
        "filename": "test/functional/feature_utxo_set_hash.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/test/functional/feature_utxo_set_hash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/test/functional/feature_utxo_set_hash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_utxo_set_hash.py?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -9,7 +9,7 @@\n from test_framework.messages import (\n     CBlock,\n     COutPoint,\n-    FromHex,\n+    from_hex,\n )\n from test_framework.muhash import MuHash3072\n from test_framework.test_framework import BitcoinTestFramework\n@@ -32,13 +32,13 @@ def test_muhash_implementation(self):\n         # Generate 100 blocks and remove the first since we plan to spend its\n         # coinbase\n         block_hashes = wallet.generate(1) + node.generate(99)\n-        blocks = list(map(lambda block: FromHex(CBlock(), node.getblock(block, False)), block_hashes))\n+        blocks = list(map(lambda block: from_hex(CBlock(), node.getblock(block, False)), block_hashes))\n         blocks.pop(0)\n \n         # Create a spending transaction and mine a block which includes it\n         txid = wallet.send_self_transfer(from_node=node)['txid']\n         tx_block = node.generateblock(output=wallet.get_address(), transactions=[txid])\n-        blocks.append(FromHex(CBlock(), node.getblock(tx_block['hash'], False)))\n+        blocks.append(from_hex(CBlock(), node.getblock(tx_block['hash'], False)))\n \n         # Serialize the outputs that should be in the UTXO set and add them to\n         # a MuHash object"
      },
      {
        "sha": "b4e662de2e2a830ab9b248de876be41cd0f90b29",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -26,7 +26,7 @@\n     CTxIn,\n     CTxInWitness,\n     CTxOut,\n-    FromHex,\n+    from_hex,\n     HeaderAndShortIDs,\n     MSG_BLOCK,\n     MSG_CMPCT_BLOCK,\n@@ -321,7 +321,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         block_hash = int(node.generate(1)[0], 16)\n \n         # Store the raw block in our internal format.\n-        block = FromHex(CBlock(), node.getblock(\"%064x\" % block_hash, False))\n+        block = from_hex(CBlock(), node.getblock(\"%064x\" % block_hash, False))\n         for tx in block.vtx:\n             tx.calc_sha256()\n         block.rehash()\n@@ -614,7 +614,7 @@ def test_getblocktxn_handler(self, test_node):\n         current_height = chain_height\n         while (current_height >= chain_height - MAX_GETBLOCKTXN_DEPTH):\n             block_hash = node.getblockhash(current_height)\n-            block = FromHex(CBlock(), node.getblock(block_hash, False))\n+            block = from_hex(CBlock(), node.getblock(block_hash, False))\n \n             msg = msg_getblocktxn()\n             msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])"
      },
      {
        "sha": "52a47c9bc2ce1ffd22ddd0bd239c12db6a206d7a",
        "filename": "test/functional/p2p_dos_header_tree.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/test/functional/p2p_dos_header_tree.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/test/functional/p2p_dos_header_tree.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_dos_header_tree.py?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -6,7 +6,7 @@\n \n from test_framework.messages import (\n     CBlockHeader,\n-    FromHex,\n+    from_hex,\n )\n from test_framework.p2p import (\n     P2PInterface,\n@@ -42,8 +42,8 @@ def run_test(self):\n         self.headers = [l for l in h_lines if not l.startswith(FORK_PREFIX)]\n         self.headers_fork = [l[len(FORK_PREFIX):] for l in h_lines if l.startswith(FORK_PREFIX)]\n \n-        self.headers = [FromHex(CBlockHeader(), h) for h in self.headers]\n-        self.headers_fork = [FromHex(CBlockHeader(), h) for h in self.headers_fork]\n+        self.headers = [from_hex(CBlockHeader(), h) for h in self.headers]\n+        self.headers_fork = [from_hex(CBlockHeader(), h) for h in self.headers_fork]\n \n         self.log.info(\"Feed all non-fork headers, including and up to the first checkpoint\")\n         peer_checkpoint = self.nodes[0].add_p2p_connection(P2PInterface())"
      },
      {
        "sha": "90715cae2689b5d83563f63a812b69c9affbdeb4",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -31,7 +31,7 @@\n )\n from test_framework.messages import (\n     CBlockHeader,\n-    FromHex,\n+    from_hex,\n     msg_block,\n )\n from test_framework.p2p import P2PInterface\n@@ -314,7 +314,7 @@ def _test_getblockheader(self):\n         header_hex = node.getblockheader(blockhash=besthash, verbose=False)\n         assert_is_hex_string(header_hex)\n \n-        header = FromHex(CBlockHeader(), header_hex)\n+        header = from_hex(CBlockHeader(), header_hex)\n         header.calc_sha256()\n         assert_equal(header.hash, besthash)\n "
      },
      {
        "sha": "67af6b8f8eb3d832c2ebdb00f0b0053fb88d29cc",
        "filename": "test/functional/rpc_txoutproof.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/test/functional/rpc_txoutproof.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/test/functional/rpc_txoutproof.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_txoutproof.py?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -7,7 +7,7 @@\n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.messages import (\n     CMerkleBlock,\n-    FromHex,\n+    from_hex,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -94,7 +94,7 @@ def run_test(self):\n         assert txid1 in self.nodes[0].verifytxoutproof(proof)\n         assert txid2 in self.nodes[1].verifytxoutproof(proof)\n \n-        tweaked_proof = FromHex(CMerkleBlock(), proof)\n+        tweaked_proof = from_hex(CMerkleBlock(), proof)\n \n         # Make sure that our serialization/deserialization is working\n         assert txid1 in self.nodes[0].verifytxoutproof(tweaked_proof.serialize().hex())"
      },
      {
        "sha": "a0e1a6bc127519ac90d288683f678bdef369d87b",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/191405420815d49ab50184513717a303fc2744d6/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/191405420815d49ab50184513717a303fc2744d6/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=191405420815d49ab50184513717a303fc2744d6",
        "patch": "@@ -191,14 +191,14 @@ def ser_string_vector(l):\n \n \n # Deserialize from a hex string representation (eg from RPC)\n-def FromHex(obj, hex_string):\n+def from_hex(obj, hex_string):\n     obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n     return obj\n \n \n def tx_from_hex(hex_string):\n     \"\"\"Deserialize from hex string to a transaction object\"\"\"\n-    return FromHex(CTransaction(), hex_string)\n+    return from_hex(CTransaction(), hex_string)\n \n \n # Objects that map to bitcoind objects, which can be serialized/deserialized"
      }
    ]
  },
  {
    "sha": "bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGI4YjlhMzQ3ZTY4ZjgwYTJlOGQ0NGNlNTU5MGEyZTgyMTRiNmJi",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-17T15:43:02Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-06-21T12:36:02Z"
      },
      "message": "test: doc: improve doc for `from_hex` helper (mention `to_hex` alternative)",
      "tree": {
        "sha": "44c20c0c5f798681b66ea0d82c4f44df27c7fc3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44c20c0c5f798681b66ea0d82c4f44df27c7fc3d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "191405420815d49ab50184513717a303fc2744d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/191405420815d49ab50184513717a303fc2744d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/191405420815d49ab50184513717a303fc2744d6"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 5,
      "deletions": 1
    },
    "files": [
      {
        "sha": "504c8c70d431e050fec4a29aee49d531a0892432",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=bdb8b9a347e68f80a2e8d44ce5590a2e8214b6bb",
        "patch": "@@ -190,8 +190,12 @@ def ser_string_vector(l):\n     return r\n \n \n-# Deserialize from a hex string representation (eg from RPC)\n def from_hex(obj, hex_string):\n+    \"\"\"Deserialize from a hex string representation (e.g. from RPC)\n+\n+    Note that there is no complementary helper like e.g. `to_hex` for the\n+    inverse operation. To serialize a message object to a hex string, simply\n+    use obj.serialize().hex()\"\"\"\n     obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n     return obj\n "
      }
    ]
  }
]