[
  {
    "sha": "fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
    "node_id": "C_kwDOABII59oAKGZiNmVhOTAwOWM1ZjFkNWMyMDA2ODkzYmQ5NjhlMTk5OGI4YTExOWE",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-24T21:18:46Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-07T01:44:42Z"
      },
      "message": "Move pindexBest{Header,Invalid} to BlockManager",
      "tree": {
        "sha": "6150db15a27448f860ef1a8065ab2781cdf42161",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6150db15a27448f860ef1a8065ab2781cdf42161"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "571bb94dfb5047c9be8fcbae5dae71de7256b86c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/571bb94dfb5047c9be8fcbae5dae71de7256b86c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/571bb94dfb5047c9be8fcbae5dae71de7256b86c"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 45,
      "deletions": 48
    },
    "files": [
      {
        "sha": "335b2e3d6f6ff5f7ee6ff3816258330eff4fd157",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "patch": "@@ -1686,9 +1686,9 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n             tip_info->block_time = chainman.ActiveChain().Tip() ? chainman.ActiveChain().Tip()->GetBlockTime() : Params().GenesisBlock().GetBlockTime();\n             tip_info->verification_progress = GuessVerificationProgress(Params().TxData(), chainman.ActiveChain().Tip());\n         }\n-        if (tip_info && ::pindexBestHeader) {\n-            tip_info->header_height = ::pindexBestHeader->nHeight;\n-            tip_info->header_time = ::pindexBestHeader->GetBlockTime();\n+        if (tip_info && chainman.m_blockman.pindexBestHeader) {\n+            tip_info->header_height = chainman.m_blockman.pindexBestHeader->nHeight;\n+            tip_info->header_time = chainman.m_blockman.pindexBestHeader->GetBlockTime();\n         }\n     }\n     LogPrintf(\"nBestHeight = %d\\n\", chain_active_height);"
      },
      {
        "sha": "a351d9d5ab9031deb479eef9381634e9ff9a0e95",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "patch": "@@ -1414,9 +1414,9 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n {\n     AssertLockHeld(cs_main);\n     if (m_chainman.ActiveChain().Contains(pindex)) return true;\n-    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n-           (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n-           (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n+    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (m_chainman.m_blockman.pindexBestHeader != nullptr) &&\n+           (m_chainman.m_blockman.pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n+           (GetBlockProofEquivalentTime(*m_chainman.m_blockman.pindexBestHeader, *pindex, *m_chainman.m_blockman.pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n@@ -1776,7 +1776,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     if (m_connman.OutboundTargetReached(true) &&\n-        (((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&\n+        (((m_chainman.m_blockman.pindexBestHeader != nullptr) && (m_chainman.m_blockman.pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&\n         !pfrom.HasPermission(NetPermissionFlags::Download) // nodes with the download permission may exceed target\n     ) {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n@@ -2054,11 +2054,11 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (!m_chainman.m_blockman.LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(m_chainman.m_blockman.pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n-                    pindexBestHeader->nHeight,\n+                    m_chainman.m_blockman.pindexBestHeader->nHeight,\n                     pfrom.GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n@@ -2967,8 +2967,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         if (best_block != nullptr) {\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), *best_block));\n-            LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(m_chainman.m_blockman.pindexBestHeader), *best_block));\n+            LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", m_chainman.m_blockman.pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n         return;\n@@ -3413,7 +3413,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (!m_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!m_chainman.ActiveChainstate().IsInitialBlockDownload())\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(m_chainman.m_blockman.pindexBestHeader), uint256()));\n             return;\n         }\n \n@@ -4524,28 +4524,28 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         CNodeState &state = *State(pto->GetId());\n \n         // Start block sync\n-        if (pindexBestHeader == nullptr)\n-            pindexBestHeader = m_chainman.ActiveChain().Tip();\n+        if (m_chainman.m_blockman.pindexBestHeader == nullptr)\n+            m_chainman.m_blockman.pindexBestHeader = m_chainman.ActiveChain().Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->IsAddrFetchConn()); // Download if this is a nice peer, or we have no nice peers and this one might do.\n         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n-            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n+            if ((nSyncStarted == 0 && fFetch) || m_chainman.m_blockman.pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n                 state.m_headers_sync_timeout = current_time + HEADERS_DOWNLOAD_TIMEOUT_BASE +\n                     (\n                         // Convert HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER to microseconds before scaling\n                         // to maintain precision\n                         std::chrono::microseconds{HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER} *\n-                        (GetAdjustedTime() - pindexBestHeader->GetBlockTime()) / consensusParams.nPowTargetSpacing\n+                        (GetAdjustedTime() - m_chainman.m_blockman.pindexBestHeader->GetBlockTime()) / consensusParams.nPowTargetSpacing\n                     );\n                 nSyncStarted++;\n-                const CBlockIndex *pindexStart = pindexBestHeader;\n+                const CBlockIndex *pindexStart = m_chainman.m_blockman.pindexBestHeader;\n                 /* If possible, start at the block preceding the currently\n                    best known header.  This ensures that we always get a\n                    non-empty list of headers back as long as the peer\n                    is up-to-date.  With a non-empty response, we can initialise\n                    the peer's known best block.  This wouldn't be possible\n-                   if we requested starting at pindexBestHeader and\n+                   if we requested starting at m_chainman.m_blockman.pindexBestHeader and\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n@@ -4870,7 +4870,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // Check for headers sync timeouts\n         if (state.fSyncStarted && state.m_headers_sync_timeout < std::chrono::microseconds::max()) {\n             // Detect whether this is a stalling initial-headers-sync peer\n-            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24 * 60 * 60) {\n+            if (m_chainman.m_blockman.pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24 * 60 * 60) {\n                 if (current_time > state.m_headers_sync_timeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n                     // Disconnect a peer (without NetPermissionFlags::NoBan permission) if it is our only sync peer,\n                     // and we have others we could be using instead."
      },
      {
        "sha": "c2149f35861f8b61e73408b9e6bc80ddeafac892",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "patch": "@@ -197,9 +197,9 @@ class NodeImpl : public Node\n     bool getHeaderTip(int& height, int64_t& block_time) override\n     {\n         LOCK(::cs_main);\n-        if (::pindexBestHeader) {\n-            height = ::pindexBestHeader->nHeight;\n-            block_time = ::pindexBestHeader->GetBlockTime();\n+        if (m_context->chainman->m_blockman.pindexBestHeader) {\n+            height = m_context->chainman->m_blockman.pindexBestHeader->nHeight;\n+            block_time = m_context->chainman->m_blockman.pindexBestHeader->GetBlockTime();\n             return true;\n         }\n         return false;"
      },
      {
        "sha": "f9cb13b58d8beb6d82ad57a48df65d3554de723a",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "patch": "@@ -1480,7 +1480,7 @@ RPCHelpMan getblockchaininfo()\n     UniValue obj(UniValue::VOBJ);\n     obj.pushKV(\"chain\",                 Params().NetworkIDString());\n     obj.pushKV(\"blocks\",                height);\n-    obj.pushKV(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1);\n+    obj.pushKV(\"headers\",               chainman.m_blockman.pindexBestHeader ? chainman.m_blockman.pindexBestHeader->nHeight : -1);\n     obj.pushKV(\"bestblockhash\",         tip->GetBlockHash().GetHex());\n     obj.pushKV(\"difficulty\",            (double)GetDifficulty(tip));\n     obj.pushKV(\"time\",                  (int64_t)tip->nTime);"
      },
      {
        "sha": "375db484c5caa08e1d59af3aaba7e2e669a13937",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 22,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "patch": "@@ -116,7 +116,6 @@ bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIn\n  */\n RecursiveMutex cs_main;\n \n-CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n uint256 g_best_block;\n@@ -131,11 +130,6 @@ arith_uint256 nMinimumChainWork;\n \n CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n \n-// Internal stuff\n-namespace {\n-    CBlockIndex* pindexBestInvalid = nullptr;\n-} // namespace\n-\n // Internal stuff from blockstorage ...\n extern RecursiveMutex cs_LastBlockFile;\n extern std::vector<CBlockFileInfo> vinfoBlockFile;\n@@ -324,7 +318,7 @@ static bool IsCurrentForFeeEstimation(CChainState& active_chainstate) EXCLUSIVE_\n         return false;\n     if (active_chainstate.m_chain.Tip()->GetBlockTime() < count_seconds(GetTime<std::chrono::seconds>() - MAX_FEE_ESTIMATION_TIP_AGE))\n         return false;\n-    if (active_chainstate.m_chain.Height() < pindexBestHeader->nHeight - 1)\n+    if (active_chainstate.m_chain.Height() < active_chainstate.m_blockman.pindexBestHeader->nHeight - 1)\n         return false;\n     return true;\n }\n@@ -1184,7 +1178,7 @@ void CChainState::CheckForkWarningConditions()\n         return;\n     }\n \n-    if (pindexBestInvalid && pindexBestInvalid->nChainWork > m_chain.Tip()->nChainWork + (GetBlockProof(*m_chain.Tip()) * 6)) {\n+    if (m_blockman.pindexBestInvalid && m_blockman.pindexBestInvalid->nChainWork > m_chain.Tip()->nChainWork + (GetBlockProof(*m_chain.Tip()) * 6)) {\n         LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__);\n         SetfLargeWorkInvalidChainFound(true);\n     } else {\n@@ -1195,10 +1189,10 @@ void CChainState::CheckForkWarningConditions()\n // Called both upon regular invalid block discovery *and* InvalidateBlock\n void CChainState::InvalidChainFound(CBlockIndex* pindexNew)\n {\n-    if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n-        pindexBestInvalid = pindexNew;\n-    if (pindexBestHeader != nullptr && pindexBestHeader->GetAncestor(pindexNew->nHeight) == pindexNew) {\n-        pindexBestHeader = m_chain.Tip();\n+    if (!m_blockman.pindexBestInvalid || pindexNew->nChainWork > m_blockman.pindexBestInvalid->nChainWork)\n+        m_blockman.pindexBestInvalid = pindexNew;\n+    if (m_blockman.pindexBestHeader != nullptr && m_blockman.pindexBestHeader->GetAncestor(pindexNew->nHeight) == pindexNew) {\n+        m_blockman.pindexBestHeader = m_chain.Tip();\n     }\n \n     LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%f  date=%s\\n\", __func__,\n@@ -1638,8 +1632,8 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         BlockMap::const_iterator  it = m_blockman.m_block_index.find(hashAssumeValid);\n         if (it != m_blockman.m_block_index.end()) {\n             if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n-                pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n-                pindexBestHeader->nChainWork >= nMinimumChainWork) {\n+                m_blockman.pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n+                m_blockman.pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n                 // Script verification is skipped when connecting blocks under the\n                 // assumevalid block. Assuming the assumevalid block is valid this\n@@ -1654,7 +1648,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n                 //  artificially set the default assumed verified block further back.\n                 // The test against nMinimumChainWork prevents the skipping when denied access to any chain at\n                 //  least as good as the expected chain.\n-                fScriptChecks = (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_params.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);\n+                fScriptChecks = (GetBlockProofEquivalentTime(*m_blockman.pindexBestHeader, *pindex, *m_blockman.pindexBestHeader, m_params.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);\n             }\n         }\n     }\n@@ -2368,8 +2362,8 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n             if (fFailedChain || fMissingData) {\n                 // Candidate chain is not usable (either invalid or missing data)\n-                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n-                    pindexBestInvalid = pindexNew;\n+                if (fFailedChain && (m_blockman.pindexBestInvalid == nullptr || pindexNew->nChainWork > m_blockman.pindexBestInvalid->nChainWork))\n+                    m_blockman.pindexBestInvalid = pindexNew;\n                 CBlockIndex *pindexFailed = pindexNew;\n                 // Remove the entire chain from the set.\n                 while (pindexTest != pindexFailed) {\n@@ -2513,7 +2507,7 @@ static bool NotifyHeaderTip(CChainState& chainstate) LOCKS_EXCLUDED(cs_main) {\n     CBlockIndex* pindexHeader = nullptr;\n     {\n         LOCK(cs_main);\n-        pindexHeader = pindexBestHeader;\n+        pindexHeader = chainstate.m_blockman.pindexBestHeader;\n \n         if (pindexHeader != pindexHeaderOld) {\n             fNotify = true;\n@@ -2821,9 +2815,9 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n             if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n-            if (it->second == pindexBestInvalid) {\n+            if (it->second == m_blockman.pindexBestInvalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n-                pindexBestInvalid = nullptr;\n+                m_blockman.pindexBestInvalid = nullptr;\n             }\n             m_blockman.m_failed_blocks.erase(it->second);\n         }\n@@ -3680,6 +3674,9 @@ void BlockManager::Unload() {\n     }\n \n     m_block_index.clear();\n+\n+    pindexBestInvalid = nullptr;\n+    pindexBestHeader = nullptr;\n }\n \n bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n@@ -4012,8 +4009,6 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n {\n     LOCK(cs_main);\n     chainman.Unload();\n-    pindexBestInvalid = nullptr;\n-    pindexBestHeader = nullptr;\n     if (mempool) mempool->clear();\n     vinfoBlockFile.clear();\n     nLastBlockFile = 0;"
      },
      {
        "sha": "8a770604b61b15d007addb7df15ce360ba9c0b4b",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb6ea9009c5f1d5c2006893bd968e1998b8a119a/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "patch": "@@ -120,9 +120,6 @@ extern uint256 hashAssumeValid;\n /** Minimum work we will assume exists on some valid chain. */\n extern arith_uint256 nMinimumChainWork;\n \n-/** Best header we've seen so far (used for getheaders queries' starting points). */\n-extern CBlockIndex *pindexBestHeader;\n-\n /** Documentation for argument 'checklevel'. */\n extern const std::vector<std::string> CHECKLEVEL_DOC;\n \n@@ -422,6 +419,11 @@ class BlockManager\n       */\n     std::set<CBlockIndex*> m_failed_blocks;\n \n+    CBlockIndex* pindexBestInvalid = nullptr;\n+\n+    /** Best header we've seen so far (used for getheaders queries' starting points). */\n+    CBlockIndex *pindexBestHeader = nullptr;\n+\n     /**\n      * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data."
      }
    ]
  },
  {
    "sha": "89cfb54ddb6213c057ddf939d9fe93581e5bd246",
    "node_id": "C_kwDOABII59oAKDg5Y2ZiNTRkZGI2MjEzYzA1N2RkZjkzOWQ5ZmU5MzU4MWU1YmQyNDY",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-24T22:50:09Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T21:05:28Z"
      },
      "message": "Move setDirty{BlockIndex,FileInfo} to BlockManager\n\nMove these variables to BlockManager because they are used when updating\nthe block index on disk.\n\nIn the future it might make sense to move more logic responsible for\nupdating and writing the block index to the BlockManager class and make\nthese variables private instead of public. See instances of CChainState\nreaching into m_blockman.setDirty* for inspiration.\n\nAlso move standalone functions which use these variables to be members\nof BlockManager:\n\n    - FindBlockPos\n          - Uses setDirtyFileInfo\n    - FindUndoPos\n          - Uses setDirtyFileInfo\n    - WriteUndoDataForBlock\n          - Uses setDirtyBlockIndex\n    - SaveBlockToDisk\n          - Calls FindBlockPos",
      "tree": {
        "sha": "b2e71082ee211c46f40bb3d7c8638eb868f6ffc6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2e71082ee211c46f40bb3d7c8638eb868f6ffc6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89cfb54ddb6213c057ddf939d9fe93581e5bd246",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89cfb54ddb6213c057ddf939d9fe93581e5bd246",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/89cfb54ddb6213c057ddf939d9fe93581e5bd246",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89cfb54ddb6213c057ddf939d9fe93581e5bd246/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb6ea9009c5f1d5c2006893bd968e1998b8a119a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb6ea9009c5f1d5c2006893bd968e1998b8a119a"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 38,
      "deletions": 36
    },
    "files": [
      {
        "sha": "7d321ad39814a15d7e376f480aff1cd3dfa7c156",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=89cfb54ddb6213c057ddf939d9fe93581e5bd246",
        "patch": "@@ -34,12 +34,6 @@ int nLastBlockFile = 0;\n *  or if we allocate more file space when we're in prune mode\n */\n bool fCheckForPruning = false;\n-\n-/** Dirty block index entries. */\n-std::set<CBlockIndex*> setDirtyBlockIndex;\n-\n-/** Dirty block file entries. */\n-std::set<int> setDirtyFileInfo;\n // } // namespace\n \n static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);\n@@ -233,7 +227,7 @@ fs::path GetBlockPosFilename(const FlatFilePos& pos)\n     return BlockFileSeq().FileName(pos);\n }\n \n-bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n+bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n {\n     LOCK(cs_LastBlockFile);\n \n@@ -288,7 +282,7 @@ bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight,\n     return true;\n }\n \n-static bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize)\n+bool BlockManager::FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -333,7 +327,7 @@ static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessa\n     return true;\n }\n \n-bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)\n+bool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)\n {\n     // Write undo information to disk\n     if (pindex->GetUndoPos().IsNull()) {\n@@ -453,7 +447,7 @@ bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex\n }\n \n /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n-FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp)\n+FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp)\n {\n     unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);\n     FlatFilePos blockPos;"
      },
      {
        "sha": "92284d36baa3ab6c5c80fbebe80e30f7101f4341",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=89cfb54ddb6213c057ddf939d9fe93581e5bd246",
        "patch": "@@ -73,9 +73,6 @@ bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, c\n bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);\n \n bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);\n-bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams);\n-\n-FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);\n \n void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args);\n "
      },
      {
        "sha": "2524ade12b7e1598d27cf0d223f44e4aba402a6f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 23,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=89cfb54ddb6213c057ddf939d9fe93581e5bd246",
        "patch": "@@ -135,8 +135,6 @@ extern RecursiveMutex cs_LastBlockFile;\n extern std::vector<CBlockFileInfo> vinfoBlockFile;\n extern int nLastBlockFile;\n extern bool fCheckForPruning;\n-extern std::set<CBlockIndex*> setDirtyBlockIndex;\n-extern std::set<int> setDirtyFileInfo;\n void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n // ... TODO move fully to blockstorage\n \n@@ -1213,7 +1211,7 @@ void CChainState::InvalidBlockFound(CBlockIndex* pindex, const BlockValidationSt\n     if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         m_blockman.m_failed_blocks.insert(pindex);\n-        setDirtyBlockIndex.insert(pindex);\n+        m_blockman.setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n     }\n@@ -1859,13 +1857,13 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     if (fJustCheck)\n         return true;\n \n-    if (!WriteUndoDataForBlock(blockundo, state, pindex, m_params)) {\n+    if (!m_blockman.WriteUndoDataForBlock(blockundo, state, pindex, m_params)) {\n         return false;\n     }\n \n     if (!pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n         pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);\n-        setDirtyBlockIndex.insert(pindex);\n+        m_blockman.setDirtyBlockIndex.insert(pindex);\n     }\n \n     assert(pindex->phashBlock);\n@@ -2002,16 +2000,16 @@ bool CChainState::FlushStateToDisk(\n                 LOG_TIME_MILLIS_WITH_CATEGORY(\"write block index to disk\", BCLog::BENCH);\n \n                 std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;\n-                vFiles.reserve(setDirtyFileInfo.size());\n-                for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n+                vFiles.reserve(m_blockman.setDirtyFileInfo.size());\n+                for (std::set<int>::iterator it = m_blockman.setDirtyFileInfo.begin(); it != m_blockman.setDirtyFileInfo.end(); ) {\n                     vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));\n-                    setDirtyFileInfo.erase(it++);\n+                    m_blockman.setDirtyFileInfo.erase(it++);\n                 }\n                 std::vector<const CBlockIndex*> vBlocks;\n-                vBlocks.reserve(setDirtyBlockIndex.size());\n-                for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n+                vBlocks.reserve(m_blockman.setDirtyBlockIndex.size());\n+                for (std::set<CBlockIndex*>::iterator it = m_blockman.setDirtyBlockIndex.begin(); it != m_blockman.setDirtyBlockIndex.end(); ) {\n                     vBlocks.push_back(*it);\n-                    setDirtyBlockIndex.erase(it++);\n+                    m_blockman.setDirtyBlockIndex.erase(it++);\n                 }\n                 if (!m_blockman.m_block_tree_db->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {\n                     return AbortNode(state, \"Failed to write to block index database\");\n@@ -2735,14 +2733,14 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n         // are no blocks that meet the \"have data and are not invalid per\n         // nStatus\" criteria for inclusion in setBlockIndexCandidates).\n         invalid_walk_tip->nStatus |= BLOCK_FAILED_VALID;\n-        setDirtyBlockIndex.insert(invalid_walk_tip);\n+        m_blockman.setDirtyBlockIndex.insert(invalid_walk_tip);\n         setBlockIndexCandidates.erase(invalid_walk_tip);\n         setBlockIndexCandidates.insert(invalid_walk_tip->pprev);\n         if (invalid_walk_tip->pprev == to_mark_failed && (to_mark_failed->nStatus & BLOCK_FAILED_VALID)) {\n             // We only want to mark the last disconnected block as BLOCK_FAILED_VALID; its children\n             // need to be BLOCK_FAILED_CHILD instead.\n             to_mark_failed->nStatus = (to_mark_failed->nStatus ^ BLOCK_FAILED_VALID) | BLOCK_FAILED_CHILD;\n-            setDirtyBlockIndex.insert(to_mark_failed);\n+            m_blockman.setDirtyBlockIndex.insert(to_mark_failed);\n         }\n \n         // Add any equal or more work headers to setBlockIndexCandidates\n@@ -2772,7 +2770,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n \n         // Mark pindex (or the last disconnected block) as invalid, even when it never was in the main chain\n         to_mark_failed->nStatus |= BLOCK_FAILED_VALID;\n-        setDirtyBlockIndex.insert(to_mark_failed);\n+        m_blockman.setDirtyBlockIndex.insert(to_mark_failed);\n         setBlockIndexCandidates.erase(to_mark_failed);\n         m_blockman.m_failed_blocks.insert(to_mark_failed);\n \n@@ -2811,7 +2809,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     while (it != m_blockman.m_block_index.end()) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n-            setDirtyBlockIndex.insert(it->second);\n+            m_blockman.setDirtyBlockIndex.insert(it->second);\n             if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n@@ -2828,7 +2826,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     while (pindex != nullptr) {\n         if (pindex->nStatus & BLOCK_FAILED_MASK) {\n             pindex->nStatus &= ~BLOCK_FAILED_MASK;\n-            setDirtyBlockIndex.insert(pindex);\n+            m_blockman.setDirtyBlockIndex.insert(pindex);\n             m_blockman.m_failed_blocks.erase(pindex);\n         }\n         pindex = pindex->pprev;\n@@ -2884,7 +2882,7 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n         pindexNew->nStatus |= BLOCK_OPT_WITNESS;\n     }\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n-    setDirtyBlockIndex.insert(pindexNew);\n+    m_blockman.setDirtyBlockIndex.insert(pindexNew);\n \n     if (pindexNew->pprev == nullptr || pindexNew->pprev->HaveTxsDownloaded()) {\n         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n@@ -3357,7 +3355,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n         !ContextualCheckBlock(block, state, m_params.GetConsensus(), pindex->pprev)) {\n         if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n-            setDirtyBlockIndex.insert(pindex);\n+            m_blockman.setDirtyBlockIndex.insert(pindex);\n         }\n         return error(\"%s: %s\", __func__, state.ToString());\n     }\n@@ -3370,7 +3368,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos = SaveBlockToDisk(block, pindex->nHeight, m_chain, m_params, dbp);\n+        FlatFilePos blockPos = m_blockman.SaveBlockToDisk(block, pindex->nHeight, m_chain, m_params, dbp);\n         if (blockPos.IsNull()) {\n             state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n             return false;\n@@ -3677,6 +3675,9 @@ void BlockManager::Unload() {\n \n     pindexBestInvalid = nullptr;\n     pindexBestHeader = nullptr;\n+\n+    setDirtyBlockIndex.clear();\n+    setDirtyFileInfo.clear();\n }\n \n bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n@@ -4012,8 +4013,6 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     if (mempool) mempool->clear();\n     vinfoBlockFile.clear();\n     nLastBlockFile = 0;\n-    setDirtyBlockIndex.clear();\n-    setDirtyFileInfo.clear();\n     g_versionbitscache.Clear();\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n         warningcache[b].clear();\n@@ -4057,7 +4056,7 @@ bool CChainState::LoadGenesisBlock()\n \n     try {\n         const CBlock& block = m_params.GenesisBlock();\n-        FlatFilePos blockPos = SaveBlockToDisk(block, 0, m_chain, m_params, nullptr);\n+        FlatFilePos blockPos = m_blockman.SaveBlockToDisk(block, 0, m_chain, m_params, nullptr);\n         if (blockPos.IsNull())\n             return error(\"%s: writing genesis block to disk failed\", __func__);\n         CBlockIndex *pindex = m_blockman.AddToBlockIndex(block);\n@@ -4937,7 +4936,7 @@ bool ChainstateManager::PopulateAndValidateSnapshot(\n             index->nStatus |= BLOCK_OPT_WITNESS;\n         }\n \n-        setDirtyBlockIndex.insert(index);\n+        m_blockman.setDirtyBlockIndex.insert(index);\n         // Changes to the block index will be flushed to disk after this call\n         // returns in `ActivateSnapshot()`, when `MaybeRebalanceCaches()` is\n         // called, since we've added a snapshot chainstate and therefore will"
      },
      {
        "sha": "34b8d048f91c11d6f2a1dfbbf6bd476518da900a",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89cfb54ddb6213c057ddf939d9fe93581e5bd246/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=89cfb54ddb6213c057ddf939d9fe93581e5bd246",
        "patch": "@@ -39,6 +39,7 @@\n \n class CChainState;\n class CBlockTreeDB;\n+class CBlockUndo;\n class CChainParams;\n struct CCheckpointData;\n class CTxMemPool;\n@@ -424,6 +425,12 @@ class BlockManager\n     /** Best header we've seen so far (used for getheaders queries' starting points). */\n     CBlockIndex *pindexBestHeader = nullptr;\n \n+    /** Dirty block index entries. */\n+    std::set<CBlockIndex*> setDirtyBlockIndex;\n+\n+    /** Dirty block file entries. */\n+    std::set<int> setDirtyFileInfo;\n+\n     /**\n      * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n@@ -482,6 +489,11 @@ class BlockManager\n      */\n     int GetSpendHeight(const CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown);\n+    bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize);\n+    bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams);\n+    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);\n+\n     ~BlockManager() {\n         Unload();\n     }"
      }
    ]
  },
  {
    "sha": "d22a874bdef4f999e932ff28457fb40df81d9e22",
    "node_id": "C_kwDOABII59oAKGQyMmE4NzRiZGVmNGY5OTllOTMyZmYyODQ1N2ZiNDBkZjgxZDllMjI",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-01-17T20:18:32Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T21:56:36Z"
      },
      "message": "validation: Add missing cs_LastBlockFile locks in PruneAndFlush() and UnloadBlockIndex(). Add missing locking annotation for nLastBlockFile and fCheckForPruning.",
      "tree": {
        "sha": "cb5b33b027cb477a4c6e56b7a98061e19d31b7ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb5b33b027cb477a4c6e56b7a98061e19d31b7ed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d22a874bdef4f999e932ff28457fb40df81d9e22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d22a874bdef4f999e932ff28457fb40df81d9e22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d22a874bdef4f999e932ff28457fb40df81d9e22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d22a874bdef4f999e932ff28457fb40df81d9e22/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89cfb54ddb6213c057ddf939d9fe93581e5bd246",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89cfb54ddb6213c057ddf939d9fe93581e5bd246",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89cfb54ddb6213c057ddf939d9fe93581e5bd246"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 14,
      "deletions": 7
    },
    "files": [
      {
        "sha": "5ff5564cfb4edb2dd8bc5e07ac95297213ac971c",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d22a874bdef4f999e932ff28457fb40df81d9e22/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d22a874bdef4f999e932ff28457fb40df81d9e22/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=d22a874bdef4f999e932ff28457fb40df81d9e22",
        "patch": "@@ -28,12 +28,12 @@ uint64_t nPruneTarget = 0;\n // TODO make namespace {\n RecursiveMutex cs_LastBlockFile;\n std::vector<CBlockFileInfo> vinfoBlockFile;\n-int nLastBlockFile = 0;\n+int nLastBlockFile GUARDED_BY(cs_LastBlockFile) = 0;\n /** Global flag to indicate we should check to see if there are\n *  block/undo files that should be deleted.  Set on startup\n *  or if we allocate more file space when we're in prune mode\n */\n-bool fCheckForPruning = false;\n+bool fCheckForPruning GUARDED_BY(cs_LastBlockFile) = false;\n // } // namespace\n \n static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);\n@@ -343,7 +343,7 @@ bool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid\n         // in the block file info as below; note that this does not catch the case where the undo writes are keeping up\n         // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in\n         // the FindBlockPos function\n-        if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n+        if (_pos.nFile < WITH_LOCK(cs_LastBlockFile, return nLastBlockFile) && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n             FlushUndoFile(_pos.nFile, true);\n         }\n "
      },
      {
        "sha": "97f10e0e194802559a258f32648b49ee8690b8ed",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d22a874bdef4f999e932ff28457fb40df81d9e22/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d22a874bdef4f999e932ff28457fb40df81d9e22/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d22a874bdef4f999e932ff28457fb40df81d9e22",
        "patch": "@@ -133,8 +133,8 @@ CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n // Internal stuff from blockstorage ...\n extern RecursiveMutex cs_LastBlockFile;\n extern std::vector<CBlockFileInfo> vinfoBlockFile;\n-extern int nLastBlockFile;\n-extern bool fCheckForPruning;\n+extern int nLastBlockFile GUARDED_BY(cs_LastBlockFile);\n+extern bool fCheckForPruning GUARDED_BY(cs_LastBlockFile);\n void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n // ... TODO move fully to blockstorage\n \n@@ -2064,7 +2064,10 @@ void CChainState::ForceFlushStateToDisk()\n void CChainState::PruneAndFlush()\n {\n     BlockValidationState state;\n-    fCheckForPruning = true;\n+    {\n+        LOCK(cs_LastBlockFile);\n+        fCheckForPruning = true;\n+    }\n     if (!this->FlushStateToDisk(state, FlushStateMode::NONE)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n     }\n@@ -3688,6 +3691,7 @@ bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar\n         return false;\n     }\n \n+    LOCK(cs_LastBlockFile);\n     // Load block file info\n     m_block_tree_db->ReadLastBlockFile(nLastBlockFile);\n     vinfoBlockFile.resize(nLastBlockFile + 1);\n@@ -4012,7 +4016,10 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     chainman.Unload();\n     if (mempool) mempool->clear();\n     vinfoBlockFile.clear();\n-    nLastBlockFile = 0;\n+    {\n+        LOCK(cs_LastBlockFile);\n+        nLastBlockFile = 0;\n+    }\n     g_versionbitscache.Clear();\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n         warningcache[b].clear();"
      }
    ]
  },
  {
    "sha": "3977132d06258701cc3bbf9309a02f6e7e6f46fc",
    "node_id": "C_kwDOABII59oAKDM5NzcxMzJkMDYyNTg3MDFjYzNiYmY5MzA5YTAyZjZlN2U2ZjQ2ZmM",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-09-13T17:29:44Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T21:59:36Z"
      },
      "message": "Guard vinfoBlockFile with cs_LastBlockFile as well",
      "tree": {
        "sha": "3ae2eec357caf556a41b42f462ad59f20e31e08c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ae2eec357caf556a41b42f462ad59f20e31e08c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3977132d06258701cc3bbf9309a02f6e7e6f46fc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3977132d06258701cc3bbf9309a02f6e7e6f46fc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3977132d06258701cc3bbf9309a02f6e7e6f46fc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3977132d06258701cc3bbf9309a02f6e7e6f46fc/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d22a874bdef4f999e932ff28457fb40df81d9e22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d22a874bdef4f999e932ff28457fb40df81d9e22",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d22a874bdef4f999e932ff28457fb40df81d9e22"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 9,
      "deletions": 5
    },
    "files": [
      {
        "sha": "ad2fa55f2dc1d9736a9f987c7b74ea340091cb28",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3977132d06258701cc3bbf9309a02f6e7e6f46fc/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3977132d06258701cc3bbf9309a02f6e7e6f46fc/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=3977132d06258701cc3bbf9309a02f6e7e6f46fc",
        "patch": "@@ -27,7 +27,7 @@ uint64_t nPruneTarget = 0;\n \n // TODO make namespace {\n RecursiveMutex cs_LastBlockFile;\n-std::vector<CBlockFileInfo> vinfoBlockFile;\n+std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);\n int nLastBlockFile GUARDED_BY(cs_LastBlockFile) = 0;\n /** Global flag to indicate we should check to see if there are\n *  block/undo files that should be deleted.  Set on startup\n@@ -162,6 +162,7 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n \n static void FlushUndoFile(int block_file, bool finalize = false)\n {\n+    LOCK(cs_LastBlockFile);\n     FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);\n     if (!UndoFileSeq().Flush(undo_pos_old, finalize)) {\n         AbortNode(\"Flushing undo file to disk failed. This is likely the result of an I/O error.\");\n@@ -343,8 +344,11 @@ bool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid\n         // in the block file info as below; note that this does not catch the case where the undo writes are keeping up\n         // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in\n         // the FindBlockPos function\n-        if (_pos.nFile < WITH_LOCK(cs_LastBlockFile, return nLastBlockFile) && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n-            FlushUndoFile(_pos.nFile, true);\n+        {\n+            LOCK(cs_LastBlockFile);\n+            if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n+                FlushUndoFile(_pos.nFile, true);\n+            }\n         }\n \n         // update nUndoPos in block index"
      },
      {
        "sha": "e325c9f0ea2b9938c801047a825f6cc79adf8ac7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3977132d06258701cc3bbf9309a02f6e7e6f46fc/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3977132d06258701cc3bbf9309a02f6e7e6f46fc/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3977132d06258701cc3bbf9309a02f6e7e6f46fc",
        "patch": "@@ -132,7 +132,7 @@ CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n \n // Internal stuff from blockstorage ...\n extern RecursiveMutex cs_LastBlockFile;\n-extern std::vector<CBlockFileInfo> vinfoBlockFile;\n+extern std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);\n extern int nLastBlockFile GUARDED_BY(cs_LastBlockFile);\n extern bool fCheckForPruning GUARDED_BY(cs_LastBlockFile);\n void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n@@ -4015,9 +4015,9 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     LOCK(cs_main);\n     chainman.Unload();\n     if (mempool) mempool->clear();\n-    vinfoBlockFile.clear();\n     {\n         LOCK(cs_LastBlockFile);\n+        vinfoBlockFile.clear();\n         nLastBlockFile = 0;\n     }\n     g_versionbitscache.Clear();"
      }
    ]
  },
  {
    "sha": "1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
    "node_id": "C_kwDOABII59oAKDFhNjcyZGRhNTA3ZmE5Y2QzMWEyMWU2NzVmNjFkMjRlYjVkOGJlYjk",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-25T00:06:16Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:28Z"
      },
      "message": "Move cs_LastBlockFile guarded objects to BlockManager",
      "tree": {
        "sha": "83ee862d178375034d75ff44fcaab7296a30a40b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83ee862d178375034d75ff44fcaab7296a30a40b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3977132d06258701cc3bbf9309a02f6e7e6f46fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3977132d06258701cc3bbf9309a02f6e7e6f46fc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3977132d06258701cc3bbf9309a02f6e7e6f46fc"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 48,
      "deletions": 50
    },
    "files": [
      {
        "sha": "b4e2595ea0d208be06cec6691d5ce59fdf6d161c",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 15,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -25,17 +25,6 @@ bool fHavePruned = false;\n bool fPruneMode = false;\n uint64_t nPruneTarget = 0;\n \n-// TODO make namespace {\n-RecursiveMutex cs_LastBlockFile;\n-std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);\n-int nLastBlockFile GUARDED_BY(cs_LastBlockFile) = 0;\n-/** Global flag to indicate we should check to see if there are\n-*  block/undo files that should be deleted.  Set on startup\n-*  or if we allocate more file space when we're in prune mode\n-*/\n-bool fCheckForPruning GUARDED_BY(cs_LastBlockFile) = false;\n-// } // namespace\n-\n static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n@@ -92,7 +81,7 @@ std::string CBlockFileInfo::ToString() const\n     return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, FormatISO8601Date(nTimeFirst), FormatISO8601Date(nTimeLast));\n }\n \n-CBlockFileInfo* GetBlockFileInfo(size_t n)\n+CBlockFileInfo* BlockManager::GetBlockFileInfo(size_t n)\n {\n     LOCK(cs_LastBlockFile);\n \n@@ -160,7 +149,7 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n     return true;\n }\n \n-static void FlushUndoFile(int block_file, bool finalize = false)\n+void BlockManager::FlushUndoFile(int block_file, bool finalize)\n {\n     LOCK(cs_LastBlockFile);\n     FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);\n@@ -169,7 +158,7 @@ static void FlushUndoFile(int block_file, bool finalize = false)\n     }\n }\n \n-void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)\n+void BlockManager::FlushBlockFile(bool fFinalize, bool finalize_undo)\n {\n     LOCK(cs_LastBlockFile);\n     FlatFilePos block_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nSize);\n@@ -181,7 +170,7 @@ void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)\n     if (!fFinalize || finalize_undo) FlushUndoFile(nLastBlockFile, finalize_undo);\n }\n \n-uint64_t CalculateCurrentUsage()\n+uint64_t BlockManager::CalculateCurrentUsage()\n {\n     LOCK(cs_LastBlockFile);\n "
      },
      {
        "sha": "434a8b2d7c695f80da783e5b3b139e9ee93d8ae1",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -55,12 +55,6 @@ FILE* OpenBlockFile(const FlatFilePos& pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n fs::path GetBlockPosFilename(const FlatFilePos& pos);\n \n-/** Get block file info entry for one block file */\n-CBlockFileInfo* GetBlockFileInfo(size_t n);\n-\n-/** Calculate the amount of disk space the block & undo files currently use */\n-uint64_t CalculateCurrentUsage();\n-\n /**\n  *  Actually unlink the specified files\n  */"
      },
      {
        "sha": "6ff6ffae1fd147efb390fae68af26c4fc927c881",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -1488,7 +1488,7 @@ RPCHelpMan getblockchaininfo()\n     obj.pushKV(\"verificationprogress\",  GuessVerificationProgress(Params().TxData(), tip));\n     obj.pushKV(\"initialblockdownload\",  active_chainstate.IsInitialBlockDownload());\n     obj.pushKV(\"chainwork\",             tip->nChainWork.GetHex());\n-    obj.pushKV(\"size_on_disk\",          CalculateCurrentUsage());\n+    obj.pushKV(\"size_on_disk\",          chainman.m_blockman.CalculateCurrentUsage());\n     obj.pushKV(\"pruned\",                fPruneMode);\n     if (fPruneMode) {\n         const CBlockIndex* block = tip;"
      },
      {
        "sha": "b58cb8ccc7fe2091ed4c42d28bd75fd09089842c",
        "filename": "src/test/validation_chainstate_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/test/validation_chainstate_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/test/validation_chainstate_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstate_tests.cpp?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -16,15 +16,14 @@\n \n #include <boost/test/unit_test.hpp>\n \n-BOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, TestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, ChainTestingSetup)\n \n //! Test resizing coins-related CChainState caches during runtime.\n //!\n BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n {\n-    ChainstateManager manager;\n-    WITH_LOCK(::cs_main, manager.m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(1 << 20, true));\n-    CTxMemPool mempool;\n+    ChainstateManager& manager = *m_node.chainman;\n+    CTxMemPool& mempool = *m_node.mempool;\n \n     //! Create and add a Coin with DynamicMemoryUsage of 80 bytes to the given view.\n     auto add_coin = [](CCoinsViewCache& coins_view) -> COutPoint {\n@@ -42,11 +41,14 @@ BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n     CChainState& c1 = WITH_LOCK(cs_main, return manager.InitializeChainstate(&mempool));\n     c1.InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n-    WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));\n \n     // Add a coin to the in-memory cache, upsize once, then downsize.\n     {\n         LOCK(::cs_main);\n+\n+        c1.InitCoinsCache(1 << 23);\n+        BOOST_REQUIRE(c1.LoadGenesisBlock());\n+\n         auto outpoint = add_coin(c1.CoinsTip());\n \n         // Set a meaningless bestblock value in the coinsview cache - otherwise we won't"
      },
      {
        "sha": "0dd23297e3f82d9610b6e0930f47c65be6c41422",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 21,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -130,14 +130,6 @@ arith_uint256 nMinimumChainWork;\n \n CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n \n-// Internal stuff from blockstorage ...\n-extern RecursiveMutex cs_LastBlockFile;\n-extern std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);\n-extern int nLastBlockFile GUARDED_BY(cs_LastBlockFile);\n-extern bool fCheckForPruning GUARDED_BY(cs_LastBlockFile);\n-void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n-// ... TODO move fully to blockstorage\n-\n CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n {\n     AssertLockHeld(cs_main);\n@@ -1937,8 +1929,8 @@ bool CChainState::FlushStateToDisk(\n         bool fDoFullFlush = false;\n \n         CoinsCacheSizeState cache_state = GetCoinsCacheSizeState();\n-        LOCK(cs_LastBlockFile);\n-        if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {\n+        LOCK(m_blockman.cs_LastBlockFile);\n+        if (fPruneMode && (m_blockman.fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {\n             // make sure we don't prune above the blockfilterindexes bestblocks\n             // pruning is height-based\n             int last_prune = m_chain.Height(); // last height we can prune\n@@ -1954,7 +1946,7 @@ bool CChainState::FlushStateToDisk(\n                 LOG_TIME_MILLIS_WITH_CATEGORY(\"find files to prune\", BCLog::BENCH);\n \n                 m_blockman.FindFilesToPrune(setFilesToPrune, m_params.PruneAfterHeight(), m_chain.Height(), last_prune, IsInitialBlockDownload());\n-                fCheckForPruning = false;\n+                m_blockman.fCheckForPruning = false;\n             }\n             if (!setFilesToPrune.empty()) {\n                 fFlushForPrune = true;\n@@ -1992,7 +1984,7 @@ bool CChainState::FlushStateToDisk(\n                 LOG_TIME_MILLIS_WITH_CATEGORY(\"write block and undo data to disk\", BCLog::BENCH);\n \n                 // First make sure all block and undo data is flushed to disk.\n-                FlushBlockFile();\n+                m_blockman.FlushBlockFile();\n             }\n \n             // Then update all block file information (which may refer to block and undo files).\n@@ -2002,7 +1994,7 @@ bool CChainState::FlushStateToDisk(\n                 std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;\n                 vFiles.reserve(m_blockman.setDirtyFileInfo.size());\n                 for (std::set<int>::iterator it = m_blockman.setDirtyFileInfo.begin(); it != m_blockman.setDirtyFileInfo.end(); ) {\n-                    vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));\n+                    vFiles.push_back(std::make_pair(*it, &m_blockman.vinfoBlockFile[*it]));\n                     m_blockman.setDirtyFileInfo.erase(it++);\n                 }\n                 std::vector<const CBlockIndex*> vBlocks;\n@@ -2011,7 +2003,7 @@ bool CChainState::FlushStateToDisk(\n                     vBlocks.push_back(*it);\n                     m_blockman.setDirtyBlockIndex.erase(it++);\n                 }\n-                if (!m_blockman.m_block_tree_db->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {\n+                if (!m_blockman.m_block_tree_db->WriteBatchSync(vFiles, m_blockman.nLastBlockFile, vBlocks)) {\n                     return AbortNode(state, \"Failed to write to block index database\");\n                 }\n             }\n@@ -2065,8 +2057,8 @@ void CChainState::PruneAndFlush()\n {\n     BlockValidationState state;\n     {\n-        LOCK(cs_LastBlockFile);\n-        fCheckForPruning = true;\n+        LOCK(m_blockman.cs_LastBlockFile);\n+        m_blockman.fCheckForPruning = true;\n     }\n     if (!this->FlushStateToDisk(state, FlushStateMode::NONE)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, state.ToString());\n@@ -3681,6 +3673,13 @@ void BlockManager::Unload() {\n \n     setDirtyBlockIndex.clear();\n     setDirtyFileInfo.clear();\n+\n+    {\n+        LOCK(cs_LastBlockFile);\n+        vinfoBlockFile.clear();\n+        nLastBlockFile = 0;\n+        // TODO: reset fCheckForPruning?\n+    }\n }\n \n bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n@@ -4015,11 +4014,6 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     LOCK(cs_main);\n     chainman.Unload();\n     if (mempool) mempool->clear();\n-    {\n-        LOCK(cs_LastBlockFile);\n-        vinfoBlockFile.clear();\n-        nLastBlockFile = 0;\n-    }\n     g_versionbitscache.Clear();\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n         warningcache[b].clear();"
      },
      {
        "sha": "d158291901e4f8517abbd1be9e895662973ad992",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -431,6 +431,15 @@ class BlockManager\n     /** Dirty block file entries. */\n     std::set<int> setDirtyFileInfo;\n \n+    RecursiveMutex cs_LastBlockFile;\n+    std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);\n+    int nLastBlockFile GUARDED_BY(cs_LastBlockFile) = 0;\n+    /** Global flag to indicate we should check to see if there are\n+     *  block/undo files that should be deleted.  Set on startup\n+     *  or if we allocate more file space when we're in prune mode\n+     */\n+    bool fCheckForPruning GUARDED_BY(cs_LastBlockFile) = false;\n+\n     /**\n      * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n@@ -494,6 +503,16 @@ class BlockManager\n     bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams);\n     FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);\n \n+    void FlushUndoFile(int block_file, bool finalize = false);\n+\n+    void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n+\n+    /** Calculate the amount of disk space the block & undo files currently use */\n+    uint64_t CalculateCurrentUsage();\n+\n+    /** Get block file info entry for one block file */\n+    CBlockFileInfo* GetBlockFileInfo(size_t n);\n+\n     ~BlockManager() {\n         Unload();\n     }"
      },
      {
        "sha": "3190f33fe60bb9ebc2b05ff6ba2bde6bbb7f00c4",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a672dda507fa9cd31a21e675f61d24eb5d8beb9/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "patch": "@@ -86,7 +86,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n {\n     // Cap last block file size, and mine new block in a new block file.\n     CBlockIndex* oldTip = m_node.chainman->ActiveChain().Tip();\n-    GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n+    (*WITH_LOCK(::cs_main, return &m_node.chainman->m_blockman)).GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n     CBlockIndex* newTip = m_node.chainman->ActiveChain().Tip();\n \n@@ -183,7 +183,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n {\n     // Cap last block file size, and mine new block in a new block file.\n     CBlockIndex* oldTip = m_node.chainman->ActiveChain().Tip();\n-    GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n+    (*WITH_LOCK(::cs_main, return &m_node.chainman->m_blockman)).GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n     CBlockIndex* newTip = m_node.chainman->ActiveChain().Tip();\n "
      }
    ]
  },
  {
    "sha": "5fba79313adf21757546dbe2760eee6d93342c6e",
    "node_id": "C_kwDOABII59oAKDVmYmE3OTMxM2FkZjIxNzU3NTQ2ZGJlMjc2MGVlZTZkOTMzNDJjNmU",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-09-13T17:38:10Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "validation: Guard nBlockReverseSequenceId with cs_main\n\nIt is only used in CChainState::PreciousBlock with ::cs_main locked.",
      "tree": {
        "sha": "a84f05558f5010477440f55703f72aa16c9c12a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a84f05558f5010477440f55703f72aa16c9c12a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5fba79313adf21757546dbe2760eee6d93342c6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fba79313adf21757546dbe2760eee6d93342c6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5fba79313adf21757546dbe2760eee6d93342c6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fba79313adf21757546dbe2760eee6d93342c6e/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a672dda507fa9cd31a21e675f61d24eb5d8beb9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a672dda507fa9cd31a21e675f61d24eb5d8beb9"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "8ee17d48f5f558095c4090af6284b4c336aa6c67",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5fba79313adf21757546dbe2760eee6d93342c6e/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5fba79313adf21757546dbe2760eee6d93342c6e/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=5fba79313adf21757546dbe2760eee6d93342c6e",
        "patch": "@@ -586,7 +586,7 @@ class CChainState\n     /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */\n     int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;\n     /** Decreasing counter (used by subsequent preciousblock calls). */\n-    int32_t nBlockReverseSequenceId = -1;\n+    int32_t nBlockReverseSequenceId GUARDED_BY(::cs_main) = -1;\n     /** chainwork for the last block that preciousblock has been applied to. */\n     arith_uint256 nLastPreciousChainwork = 0;\n "
      }
    ]
  },
  {
    "sha": "485248a4faab91f350f0247492898226addcbcf7",
    "node_id": "C_kwDOABII59oAKDQ4NTI0OGE0ZmFhYjkxZjM1MGYwMjQ3NDkyODk4MjI2YWRkY2JjZjc",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2020-12-25T01:06:34Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "Move fHavePruned to BlockManager",
      "tree": {
        "sha": "17b7c3f44cbaeafeb93a05864ffb33537a5af83b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/17b7c3f44cbaeafeb93a05864ffb33537a5af83b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/485248a4faab91f350f0247492898226addcbcf7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/485248a4faab91f350f0247492898226addcbcf7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/485248a4faab91f350f0247492898226addcbcf7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/485248a4faab91f350f0247492898226addcbcf7/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5fba79313adf21757546dbe2760eee6d93342c6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fba79313adf21757546dbe2760eee6d93342c6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5fba79313adf21757546dbe2760eee6d93342c6e"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 34,
      "deletions": 34
    },
    "files": [
      {
        "sha": "49abdeee733d7521f4fbeec50d1b08edd2f9178f",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -40,7 +40,7 @@ static void BlockToJsonVerbose(benchmark::Bench& bench)\n {\n     TestBlockAndIndex data;\n     bench.run([&] {\n-        auto univalue = blockToJSON(data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);\n+        auto univalue = blockToJSON(WITH_LOCK(::cs_main, return std::ref(data.testing_setup->m_node.chainman->m_blockman)), data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);\n         ankerl::nanobench::doNotOptimizeAway(univalue);\n     });\n }\n@@ -50,7 +50,7 @@ BENCHMARK(BlockToJsonVerbose);\n static void BlockToJsonVerboseWrite(benchmark::Bench& bench)\n {\n     TestBlockAndIndex data;\n-    auto univalue = blockToJSON(data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);\n+    auto univalue = blockToJSON(WITH_LOCK(::cs_main, return std::ref(data.testing_setup->m_node.chainman->m_blockman)), data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);\n     bench.run([&] {\n         auto str = univalue.write();\n         ankerl::nanobench::doNotOptimizeAway(str);"
      },
      {
        "sha": "91d3dbb97430cfffcb3853f545b06238d26be837",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -1410,7 +1410,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n                 // in the past, but is now trying to run unpruned.\n-                if (fHavePruned && !fPruneMode) {\n+                if (chainman.m_blockman.fHavePruned && !fPruneMode) {\n                     strLoadError = _(\"You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain\");\n                     break;\n                 }\n@@ -1499,7 +1499,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n                 for (CChainState* chainstate : chainman.GetAll()) {\n                     if (!is_coinsview_empty(chainstate)) {\n                         uiInterface.InitMessage(_(\"Verifying blocks\u2026\").translated);\n-                        if (fHavePruned && args.GetIntArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n+                        if (chainman.m_blockman.fHavePruned && args.GetIntArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n                             LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\\n\",\n                                 MIN_BLOCKS_TO_KEEP);\n                         }"
      },
      {
        "sha": "e533b1bffbc326d0e47b62b17a77167b763ccba6",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -21,15 +21,14 @@\n \n std::atomic_bool fImporting(false);\n std::atomic_bool fReindex(false);\n-bool fHavePruned = false;\n bool fPruneMode = false;\n uint64_t nPruneTarget = 0;\n \n static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n \n-bool IsBlockPruned(const CBlockIndex* pblockindex)\n+bool BlockManager::IsBlockPruned(const CBlockIndex* pblockindex)\n {\n     return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);\n }"
      },
      {
        "sha": "ceada9158951652b869f0f9965d4b95e5ebf36e2",
        "filename": "src/node/blockstorage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/node/blockstorage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/node/blockstorage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.h?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -38,16 +38,11 @@ static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n extern std::atomic_bool fImporting;\n extern std::atomic_bool fReindex;\n /** Pruning-related variables and constants */\n-/** True if any block files have ever been pruned. */\n-extern bool fHavePruned;\n /** True if we're running in -prune mode. */\n extern bool fPruneMode;\n /** Number of MiB of block files that we're trying to stay below. */\n extern uint64_t nPruneTarget;\n \n-//! Check whether the block associated with this index entry is pruned or not.\n-bool IsBlockPruned(const CBlockIndex* pblockindex);\n-\n void CleanupBlockRevFiles();\n \n /** Open a block file (blk?????.dat) */"
      },
      {
        "sha": "715f80cbb3a610144dec8939d88067a7cd6a663f",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -623,7 +623,7 @@ class ChainImpl : public Chain\n     bool havePruned() override\n     {\n         LOCK(cs_main);\n-        return ::fHavePruned;\n+        return m_node.chainman->m_blockman.fHavePruned;\n     }\n     bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n     bool isInitialBlockDownload() override {"
      },
      {
        "sha": "9d292c15fc5439749c34a6646afe9e1056b53b0f",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -274,18 +274,18 @@ static bool rest_block(const std::any& context,\n     CBlock block;\n     CBlockIndex* pblockindex = nullptr;\n     CBlockIndex* tip = nullptr;\n+    ChainstateManager* maybe_chainman = GetChainman(context, req);\n+    if (!maybe_chainman) return false;\n+    ChainstateManager& chainman = *maybe_chainman;\n     {\n-        ChainstateManager* maybe_chainman = GetChainman(context, req);\n-        if (!maybe_chainman) return false;\n-        ChainstateManager& chainman = *maybe_chainman;\n         LOCK(cs_main);\n         tip = chainman.ActiveChain().Tip();\n         pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n         if (!pblockindex) {\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n         }\n \n-        if (IsBlockPruned(pblockindex))\n+        if (chainman.m_blockman.IsBlockPruned(pblockindex))\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n \n         if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n@@ -312,7 +312,7 @@ static bool rest_block(const std::any& context,\n     }\n \n     case RetFormat::JSON: {\n-        UniValue objBlock = blockToJSON(block, tip, pblockindex, showTxDetails);\n+        UniValue objBlock = blockToJSON(WITH_LOCK(::cs_main, return std::ref(chainman.m_blockman)), block, tip, pblockindex, showTxDetails);\n         std::string strJSON = objBlock.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);"
      },
      {
        "sha": "46a1dcf9de87834837cb045ac4522803972beea7",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -200,7 +200,7 @@ UniValue blockheaderToJSON(const CBlockIndex* tip, const CBlockIndex* blockindex\n     return result;\n }\n \n-UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails)\n+UniValue blockToJSON(BlockManager& blockman, const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails)\n {\n     UniValue result = blockheaderToJSON(tip, blockindex);\n \n@@ -210,7 +210,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIn\n     UniValue txs(UniValue::VARR);\n     if (txDetails) {\n         CBlockUndo blockUndo;\n-        const bool have_undo = !IsBlockPruned(blockindex) && UndoReadFromDisk(blockUndo, blockindex);\n+        const bool have_undo = !blockman.IsBlockPruned(blockindex) && UndoReadFromDisk(blockUndo, blockindex);\n         for (size_t i = 0; i < block.vtx.size(); ++i) {\n             const CTransactionRef& tx = block.vtx.at(i);\n             // coinbase transaction (i == 0) doesn't have undo data\n@@ -895,10 +895,10 @@ static RPCHelpMan getblockheader()\n     };\n }\n \n-static CBlock GetBlockChecked(const CBlockIndex* pblockindex)\n+static CBlock GetBlockChecked(BlockManager& blockman, const CBlockIndex* pblockindex)\n {\n     CBlock block;\n-    if (IsBlockPruned(pblockindex)) {\n+    if (blockman.IsBlockPruned(pblockindex)) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not available (pruned data)\");\n     }\n \n@@ -912,10 +912,10 @@ static CBlock GetBlockChecked(const CBlockIndex* pblockindex)\n     return block;\n }\n \n-static CBlockUndo GetUndoChecked(const CBlockIndex* pblockindex)\n+static CBlockUndo GetUndoChecked(BlockManager& blockman, const CBlockIndex* pblockindex)\n {\n     CBlockUndo blockUndo;\n-    if (IsBlockPruned(pblockindex)) {\n+    if (blockman.IsBlockPruned(pblockindex)) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Undo data not available (pruned data)\");\n     }\n \n@@ -997,8 +997,8 @@ static RPCHelpMan getblock()\n     CBlock block;\n     const CBlockIndex* pblockindex;\n     const CBlockIndex* tip;\n+    ChainstateManager& chainman = EnsureAnyChainman(request.context);\n     {\n-        ChainstateManager& chainman = EnsureAnyChainman(request.context);\n         LOCK(cs_main);\n         pblockindex = chainman.m_blockman.LookupBlockIndex(hash);\n         tip = chainman.ActiveChain().Tip();\n@@ -1007,7 +1007,7 @@ static RPCHelpMan getblock()\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n \n-        block = GetBlockChecked(pblockindex);\n+        block = GetBlockChecked(chainman.m_blockman, pblockindex);\n     }\n \n     if (verbosity <= 0)\n@@ -1018,7 +1018,7 @@ static RPCHelpMan getblock()\n         return strHex;\n     }\n \n-    return blockToJSON(block, tip, pblockindex, verbosity >= 2);\n+    return blockToJSON(WITH_LOCK(::cs_main, return std::ref(chainman.m_blockman)), block, tip, pblockindex, verbosity >= 2);\n },\n     };\n }\n@@ -2017,8 +2017,8 @@ static RPCHelpMan getblockstats()\n         }\n     }\n \n-    const CBlock block = GetBlockChecked(pindex);\n-    const CBlockUndo blockUndo = GetUndoChecked(pindex);\n+    const CBlock block = GetBlockChecked(chainman.m_blockman, pindex);\n+    const CBlockUndo blockUndo = GetUndoChecked(chainman.m_blockman, pindex);\n \n     const bool do_all = stats.size() == 0; // Calculate everything if nothing selected (default)\n     const bool do_mediantxsize = do_all || stats.count(\"mediantxsize\") != 0;"
      },
      {
        "sha": "870b821ad4001ee7d9fa2602f4922a5719447816",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -8,6 +8,7 @@\n #include <amount.h>\n #include <streams.h>\n #include <sync.h>\n+#include <validation.h>\n \n #include <any>\n #include <stdint.h>\n@@ -38,7 +39,7 @@ double GetDifficulty(const CBlockIndex* blockindex);\n void RPCNotifyBlockChange(const CBlockIndex*);\n \n /** Block description to JSON */\n-UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails = false) LOCKS_EXCLUDED(cs_main);\n+UniValue blockToJSON(BlockManager& blockman, const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails = false) LOCKS_EXCLUDED(cs_main);\n \n /** Mempool information to JSON */\n UniValue MempoolInfoToJSON(const CTxMemPool& pool);"
      },
      {
        "sha": "1b0e7a3bffcaa900e17713ea259b59ec7a7153e4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -1950,9 +1950,9 @@ bool CChainState::FlushStateToDisk(\n             }\n             if (!setFilesToPrune.empty()) {\n                 fFlushForPrune = true;\n-                if (!fHavePruned) {\n+                if (!m_blockman.fHavePruned) {\n                     m_blockman.m_block_tree_db->WriteFlag(\"prunedblockfiles\", true);\n-                    fHavePruned = true;\n+                    m_blockman.fHavePruned = true;\n                 }\n             }\n         }\n@@ -4018,7 +4018,6 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n         warningcache[b].clear();\n     }\n-    fHavePruned = false;\n }\n \n bool ChainstateManager::LoadBlockIndex()\n@@ -4270,7 +4269,7 @@ void CChainState::CheckBlockIndex()\n         // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.\n         // Unless these indexes are assumed valid and pending block download on a\n         // background chainstate.\n-        if (!fHavePruned && !pindex->IsAssumedValid()) {\n+        if (!m_blockman.fHavePruned && !pindex->IsAssumedValid()) {\n             // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0\n             assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));\n             assert(pindexFirstMissing == pindexFirstNeverProcessed);\n@@ -4344,7 +4343,7 @@ void CChainState::CheckBlockIndex()\n         if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.\n         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {\n             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n-            assert(fHavePruned); // We must have pruned.\n+            assert(m_blockman.fHavePruned); // We must have pruned.\n             // This block may have entered m_blocks_unlinked if:\n             //  - it has a descendant that at some point had more work than the\n             //    tip, and"
      },
      {
        "sha": "7ac0371daa80ad300b6bd8c1eef6477cd25e185a",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/485248a4faab91f350f0247492898226addcbcf7/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/485248a4faab91f350f0247492898226addcbcf7/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=485248a4faab91f350f0247492898226addcbcf7",
        "patch": "@@ -450,6 +450,9 @@ class BlockManager\n \n     bool LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n+    /** True if any block files have ever been pruned. */\n+    bool fHavePruned = false;\n+\n     /**\n      * Load the blocktree off disk and into memory. Populate certain metadata\n      * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral\n@@ -513,6 +516,9 @@ class BlockManager\n     /** Get block file info entry for one block file */\n     CBlockFileInfo* GetBlockFileInfo(size_t n);\n \n+    //! Check whether the block associated with this index entry is pruned or not.\n+    bool IsBlockPruned(const CBlockIndex* pblockindex);\n+\n     ~BlockManager() {\n         Unload();\n     }"
      }
    ]
  },
  {
    "sha": "6ce125d3980fc271baabde2ca335fa22e33c372c",
    "node_id": "C_kwDOABII59oAKDZjZTEyNWQzOTgwZmMyNzFiYWFiZGUyY2EzMzVmYTIyZTMzYzM3MmM",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-07-09T00:49:05Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "Move versionbitscache to BlockManager",
      "tree": {
        "sha": "f36b2e2c8ad5acfa2fe38bb0675c75997bc7db8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f36b2e2c8ad5acfa2fe38bb0675c75997bc7db8c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ce125d3980fc271baabde2ca335fa22e33c372c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ce125d3980fc271baabde2ca335fa22e33c372c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6ce125d3980fc271baabde2ca335fa22e33c372c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ce125d3980fc271baabde2ca335fa22e33c372c/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "485248a4faab91f350f0247492898226addcbcf7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/485248a4faab91f350f0247492898226addcbcf7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/485248a4faab91f350f0247492898226addcbcf7"
      }
    ],
    "stats": {
      "total": 115,
      "additions": 59,
      "deletions": 56
    },
    "files": [
      {
        "sha": "a1cc37c64f8c06894fd260618d0db4716c45f8ff",
        "filename": "src/deploymentstatus.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/deploymentstatus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/deploymentstatus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/deploymentstatus.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -9,8 +9,6 @@\n \n #include <type_traits>\n \n-VersionBitsCache g_versionbitscache;\n-\n /* Basic sanity checking for BuriedDeployment/DeploymentPos enums and\n  * ValidDeployment check */\n "
      },
      {
        "sha": "5b4a5ccdb93365b6e0531f45eefb06ec2b6014ee",
        "filename": "src/deploymentstatus.h",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/deploymentstatus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/deploymentstatus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/deploymentstatus.h?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -10,20 +10,17 @@\n \n #include <limits>\n \n-/** Global cache for versionbits deployment status */\n-extern VersionBitsCache g_versionbitscache;\n-\n /** Determine if a deployment is active for the next block */\n inline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::BuriedDeployment dep)\n {\n     assert(Consensus::ValidDeployment(dep));\n     return (pindexPrev == nullptr ? 0 : pindexPrev->nHeight + 1) >= params.DeploymentHeight(dep);\n }\n \n-inline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos dep)\n+inline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos dep, VersionBitsCache& versionbitscache)\n {\n     assert(Consensus::ValidDeployment(dep));\n-    return ThresholdState::ACTIVE == g_versionbitscache.State(pindexPrev, params, dep);\n+    return ThresholdState::ACTIVE == versionbitscache.State(pindexPrev, params, dep);\n }\n \n /** Determine if a deployment is active for this block */\n@@ -33,10 +30,10 @@ inline bool DeploymentActiveAt(const CBlockIndex& index, const Consensus::Params\n     return index.nHeight >= params.DeploymentHeight(dep);\n }\n \n-inline bool DeploymentActiveAt(const CBlockIndex& index, const Consensus::Params& params, Consensus::DeploymentPos dep)\n+inline bool DeploymentActiveAt(const CBlockIndex& index, const Consensus::Params& params, Consensus::DeploymentPos dep, VersionBitsCache& versionbitscache)\n {\n     assert(Consensus::ValidDeployment(dep));\n-    return DeploymentActiveAfter(index.pprev, params, dep);\n+    return DeploymentActiveAfter(index.pprev, params, dep, versionbitscache);\n }\n \n /** Determine if a deployment is enabled (can ever be active) */"
      },
      {
        "sha": "0f95eefc1a79061ed6726bf1db5a2fbeac63ca78",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -121,7 +121,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     assert(pindexPrev != nullptr);\n     nHeight = pindexPrev->nHeight + 1;\n \n-    pblock->nVersion = g_versionbitscache.ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n+    pblock->nVersion = m_chainstate.m_blockman.versionbitscache.ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n     // -regtest only: allow overriding block.nVersion with\n     // -blockversion=N to test forking scenarios\n     if (chainparams.MineBlocksOnDemand())"
      },
      {
        "sha": "b84e895226190329ea71b59624bfdfc599699d97",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -702,7 +702,7 @@ class ChainImpl : public Chain\n     {\n         LOCK(::cs_main);\n         const CBlockIndex* tip = Assert(m_node.chainman)->ActiveChain().Tip();\n-        return DeploymentActiveAfter(tip, Params().GetConsensus(), Consensus::DEPLOYMENT_TAPROOT);\n+        return DeploymentActiveAfter(tip, Params().GetConsensus(), Consensus::DEPLOYMENT_TAPROOT, m_node.chainman->m_blockman.versionbitscache);\n     }\n     NodeContext& m_node;\n };"
      },
      {
        "sha": "e24e309e16714f61644e897e12f79e3be6cc9cac",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -1365,14 +1365,14 @@ static void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue&\n     softforks.pushKV(DeploymentName(dep), rv);\n }\n \n-static void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue& softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n+static void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue& softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id, VersionBitsCache& versionbitscache)\n {\n     // For BIP9 deployments.\n \n     if (!DeploymentEnabled(consensusParams, id)) return;\n \n     UniValue bip9(UniValue::VOBJ);\n-    const ThresholdState thresholdState = g_versionbitscache.State(active_chain_tip, consensusParams, id);\n+    const ThresholdState thresholdState = versionbitscache.State(active_chain_tip, consensusParams, id);\n     switch (thresholdState) {\n     case ThresholdState::DEFINED: bip9.pushKV(\"status\", \"defined\"); break;\n     case ThresholdState::STARTED: bip9.pushKV(\"status\", \"started\"); break;\n@@ -1386,11 +1386,11 @@ static void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue&\n     }\n     bip9.pushKV(\"start_time\", consensusParams.vDeployments[id].nStartTime);\n     bip9.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n-    int64_t since_height = g_versionbitscache.StateSinceHeight(active_chain_tip, consensusParams, id);\n+    int64_t since_height = versionbitscache.StateSinceHeight(active_chain_tip, consensusParams, id);\n     bip9.pushKV(\"since\", since_height);\n     if (has_signal) {\n         UniValue statsUV(UniValue::VOBJ);\n-        BIP9Stats statsStruct = g_versionbitscache.Statistics(active_chain_tip, consensusParams, id);\n+        BIP9Stats statsStruct = versionbitscache.Statistics(active_chain_tip, consensusParams, id);\n         statsUV.pushKV(\"period\", statsStruct.period);\n         statsUV.pushKV(\"elapsed\", statsStruct.elapsed);\n         statsUV.pushKV(\"count\", statsStruct.count);\n@@ -1509,13 +1509,14 @@ RPCHelpMan getblockchaininfo()\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     UniValue softforks(UniValue::VOBJ);\n+    VersionBitsCache& versionbitscache = chainman.m_blockman.versionbitscache;\n     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_HEIGHTINCB);\n     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_DERSIG);\n     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_CLTV);\n     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_CSV);\n     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_SEGWIT);\n-    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);\n-    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TAPROOT);\n+    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TESTDUMMY, versionbitscache);\n+    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache);\n     obj.pushKV(\"softforks\", softforks);\n \n     obj.pushKV(\"warnings\", GetWarnings(false).original);"
      },
      {
        "sha": "d50f5360d875426d692872a6e687f0a436ed9d77",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -844,17 +844,18 @@ static RPCHelpMan getblocktemplate()\n     }\n \n     UniValue vbavailable(UniValue::VOBJ);\n+    VersionBitsCache& versionbitscache = chainman.m_blockman.versionbitscache;\n     for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\n         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n-        ThresholdState state = g_versionbitscache.State(pindexPrev, consensusParams, pos);\n+        ThresholdState state = versionbitscache.State(pindexPrev, consensusParams, pos);\n         switch (state) {\n             case ThresholdState::DEFINED:\n             case ThresholdState::FAILED:\n                 // Not exposed to GBT at all\n                 break;\n             case ThresholdState::LOCKED_IN:\n                 // Ensure bit is set in block version\n-                pblock->nVersion |= g_versionbitscache.Mask(consensusParams, pos);\n+                pblock->nVersion |= versionbitscache.Mask(consensusParams, pos);\n                 [[fallthrough]];\n             case ThresholdState::STARTED:\n             {\n@@ -863,7 +864,7 @@ static RPCHelpMan getblocktemplate()\n                 if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n                     if (!vbinfo.gbt_force) {\n                         // If the client doesn't support this, don't indicate it in the [default] version\n-                        pblock->nVersion &= ~g_versionbitscache.Mask(consensusParams, pos);\n+                        pblock->nVersion &= ~versionbitscache.Mask(consensusParams, pos);\n                     }\n                 }\n                 break;"
      },
      {
        "sha": "94a277fac6d6132a90cb9a6f4194e3ff89ceac9a",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 26,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -257,18 +257,18 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n }\n \n /** Check that ComputeBlockVersion will set the appropriate bit correctly */\n-static void check_computeblockversion(const Consensus::Params& params, Consensus::DeploymentPos dep)\n+static void check_computeblockversion(const Consensus::Params& params, Consensus::DeploymentPos dep, VersionBitsCache& versionbitscache)\n {\n-    // This implicitly uses g_versionbitscache, so clear it every time\n-    g_versionbitscache.Clear();\n+    // This implicitly uses versionbitscache, so clear it every time\n+    versionbitscache.Clear();\n \n     int64_t bit = params.vDeployments[dep].bit;\n     int64_t nStartTime = params.vDeployments[dep].nStartTime;\n     int64_t nTimeout = params.vDeployments[dep].nTimeout;\n     int min_activation_height = params.vDeployments[dep].min_activation_height;\n \n     // should not be any signalling for first block\n-    BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(nullptr, params), VERSIONBITS_TOP_BITS);\n+    BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(nullptr, params), VERSIONBITS_TOP_BITS);\n \n     // always/never active deployments shouldn't need to be tested further\n     if (nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE ||\n@@ -288,7 +288,7 @@ static void check_computeblockversion(const Consensus::Params& params, Consensus\n     // Check min_activation_height is on a retarget boundary\n     BOOST_REQUIRE_EQUAL(min_activation_height % params.nMinerConfirmationWindow, 0U);\n \n-    const uint32_t bitmask{g_versionbitscache.Mask(params, dep)};\n+    const uint32_t bitmask{versionbitscache.Mask(params, dep)};\n     BOOST_CHECK_EQUAL(bitmask, uint32_t{1} << bit);\n \n     // In the first chain, test that the bit is set by CBV until it has failed.\n@@ -307,38 +307,38 @@ static void check_computeblockversion(const Consensus::Params& params, Consensus\n         // earlier time, so will transition from DEFINED to STARTED at the\n         // end of the first period by mining blocks at nTime == 0\n         lastBlock = firstChain.Mine(params.nMinerConfirmationWindow - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n+        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n         lastBlock = firstChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+        BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n         // then we'll keep mining at nStartTime...\n     } else {\n         // use a time 1s earlier than start time to check we stay DEFINED\n         --nTime;\n \n         // Start generating blocks before nStartTime\n         lastBlock = firstChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n+        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n \n         // Mine more blocks (4 less than the adjustment period) at the old time, and check that CBV isn't setting the bit yet.\n         for (uint32_t i = 1; i < params.nMinerConfirmationWindow - 4; i++) {\n             lastBlock = firstChain.Mine(params.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-            BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n+            BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n         }\n         // Now mine 5 more blocks at the start time -- MTP should not have passed yet, so\n         // CBV should still not yet set the bit.\n         nTime = nStartTime;\n         for (uint32_t i = params.nMinerConfirmationWindow - 4; i <= params.nMinerConfirmationWindow; i++) {\n             lastBlock = firstChain.Mine(params.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-            BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n+            BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n         }\n         // Next we will advance to the next period and transition to STARTED,\n     }\n \n     lastBlock = firstChain.Mine(params.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n     // so ComputeBlockVersion should now set the bit,\n-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n     // and should also be using the VERSIONBITS_TOP_BITS.\n-    BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+    BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n \n     // Check that ComputeBlockVersion will set the bit until nTimeout\n     nTime += 600;\n@@ -347,8 +347,8 @@ static void check_computeblockversion(const Consensus::Params& params, Consensus\n     // These blocks are all before nTimeout is reached.\n     while (nTime < nTimeout && blocksToMine > 0) {\n         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n+        BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);\n         blocksToMine--;\n         nTime += 600;\n         nHeight += 1;\n@@ -362,20 +362,20 @@ static void check_computeblockversion(const Consensus::Params& params, Consensus\n         // finish the last period before we start timing out\n         while (nHeight % params.nMinerConfirmationWindow != 0) {\n             lastBlock = firstChain.Mine(nHeight+1, nTime - 1, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-            BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+            BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n             nHeight += 1;\n         }\n \n         // FAILED is only triggered at the end of a period, so CBV should be setting\n         // the bit until the period transition.\n         for (uint32_t i = 0; i < params.nMinerConfirmationWindow - 1; i++) {\n             lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-            BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+            BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n             nHeight += 1;\n         }\n         // The next block should trigger no longer setting the bit.\n         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n+        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n     }\n \n     // On a new chain:\n@@ -386,34 +386,36 @@ static void check_computeblockversion(const Consensus::Params& params, Consensus\n     // Mine one period worth of blocks, and check that the bit will be on for the\n     // next period.\n     lastBlock = secondChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n \n     // Mine another period worth of blocks, signaling the new bit.\n     lastBlock = secondChain.Mine(params.nMinerConfirmationWindow * 2, nTime, VERSIONBITS_TOP_BITS | (1<<bit)).Tip();\n     // After one period of setting the bit on each block, it should have locked in.\n     // We keep setting the bit for one more period though, until activation.\n-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n \n     // Now check that we keep mining the block until the end of this period, and\n     // then stop at the beginning of the next period.\n     lastBlock = secondChain.Mine((params.nMinerConfirmationWindow * 3) - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n     lastBlock = secondChain.Mine(params.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n \n     if (lastBlock->nHeight + 1 < min_activation_height) {\n         // check signalling continues while min_activation_height is not reached\n         lastBlock = secondChain.Mine(min_activation_height - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n-        BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n+        BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);\n         // then reach min_activation_height, which was already REQUIRE'd to start a new period\n         lastBlock = secondChain.Mine(min_activation_height, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n     }\n \n     // Check that we don't signal after activation\n-    BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n+    BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);\n }\n \n BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n {\n+    VersionBitsCache& versionbitscache = WITH_LOCK(::cs_main, return std::ref(m_node.chainman->m_blockman.versionbitscache));\n+\n     // check that any deployment on any chain can conceivably reach both\n     // ACTIVE and FAILED states in roughly the way we expect\n     for (const auto& chain_name : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::SIGNET, CBaseChainParams::REGTEST}) {\n@@ -426,10 +428,10 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n             // not take precedence over STARTED/LOCKED_IN. So all softforks on\n             // the same bit might overlap, even when non-overlapping start-end\n             // times are picked.\n-            const uint32_t dep_mask{g_versionbitscache.Mask(chainParams->GetConsensus(), dep)};\n+            const uint32_t dep_mask{versionbitscache.Mask(chainParams->GetConsensus(), dep)};\n             BOOST_CHECK(!(chain_all_vbits & dep_mask));\n             chain_all_vbits |= dep_mask;\n-            check_computeblockversion(chainParams->GetConsensus(), dep);\n+            check_computeblockversion(chainParams->GetConsensus(), dep, versionbitscache);\n         }\n     }\n \n@@ -439,7 +441,7 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n         ArgsManager args;\n         args.ForceSetArg(\"-vbparams\", \"testdummy:1199145601:1230767999\"); // January 1, 2008 - December 31, 2008\n         const auto chainParams = CreateChainParams(args, CBaseChainParams::REGTEST);\n-        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY);\n+        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY, versionbitscache);\n     }\n \n     {\n@@ -449,7 +451,7 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n         ArgsManager args;\n         args.ForceSetArg(\"-vbparams\", \"testdummy:1199145601:1230767999:403200\"); // January 1, 2008 - December 31, 2008, min act height 403200\n         const auto chainParams = CreateChainParams(args, CBaseChainParams::REGTEST);\n-        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY);\n+        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY, versionbitscache);\n     }\n }\n "
      },
      {
        "sha": "4c839c36df129d2e3d41135800f88506a7f4cfbb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -285,7 +285,7 @@ bool CheckSequenceLocks(CBlockIndex* tip,\n }\n \n // Returns the script flags which should be checked for a given block\n-static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams, VersionBitsCache& versionbitscache);\n \n static void LimitMempoolSize(CTxMemPool& pool, CCoinsViewCache& coins_cache, size_t limit, std::chrono::seconds age)\n     EXCLUSIVE_LOCKS_REQUIRED(pool.cs, ::cs_main)\n@@ -654,7 +654,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     }\n \n     // Check for non-standard pay-to-script-hash in inputs\n-    const bool taproot_active = DeploymentActiveAfter(m_active_chainstate.m_chain.Tip(), args.m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_TAPROOT);\n+    const bool taproot_active = DeploymentActiveAfter(m_active_chainstate.m_chain.Tip(), args.m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_TAPROOT, m_active_chainstate.m_blockman.versionbitscache);\n     if (fRequireStandard && !AreInputsStandard(tx, m_view, taproot_active)) {\n         return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, \"bad-txns-nonstandard-inputs\");\n     }\n@@ -847,7 +847,7 @@ bool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, P\n     // There is a similar check in CreateNewBlock() to prevent creating\n     // invalid blocks (using TestBlockValidity), however allowing such\n     // transactions into the mempool can be exploited as a DoS attack.\n-    unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(m_active_chainstate.m_chain.Tip(), chainparams.GetConsensus());\n+    unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(m_active_chainstate.m_chain.Tip(), chainparams.GetConsensus(), m_active_chainstate.m_blockman.versionbitscache);\n     if (!CheckInputsFromMempoolAndCache(tx, state, m_view, m_pool, currentBlockScriptVerifyFlags, txdata, m_active_chainstate.CoinsTip())) {\n         return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputScripts failed against latest-block but not STANDARD flags %s, %s\",\n                 __func__, hash.ToString(), state.ToString());\n@@ -1489,9 +1489,10 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n {\n private:\n     int bit;\n+    VersionBitsCache& m_versionbitscache;\n \n public:\n-    explicit WarningBitsConditionChecker(int bitIn) : bit(bitIn) {}\n+    explicit WarningBitsConditionChecker(int bitIn, VersionBitsCache& versionbitscache) : bit(bitIn), m_versionbitscache(versionbitscache) {}\n \n     int64_t BeginTime(const Consensus::Params& params) const override { return 0; }\n     int64_t EndTime(const Consensus::Params& params) const override { return std::numeric_limits<int64_t>::max(); }\n@@ -1503,13 +1504,13 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n         return pindex->nHeight >= params.MinBIP9WarningHeight &&\n                ((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) &&\n                ((pindex->nVersion >> bit) & 1) != 0 &&\n-               ((g_versionbitscache.ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;\n+               ((m_versionbitscache.ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;\n     }\n };\n \n static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS] GUARDED_BY(cs_main);\n \n-static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams)\n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams, VersionBitsCache& versionbitscache)\n {\n     unsigned int flags = SCRIPT_VERIFY_NONE;\n \n@@ -1542,7 +1543,7 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n     }\n \n     // Enforce Taproot (BIP340-BIP342)\n-    if (DeploymentActiveAt(*pindex, consensusparams, Consensus::DEPLOYMENT_TAPROOT)) {\n+    if (DeploymentActiveAt(*pindex, consensusparams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache)) {\n         flags |= SCRIPT_VERIFY_TAPROOT;\n     }\n \n@@ -1743,7 +1744,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     }\n \n     // Get the script flags for this block\n-    unsigned int flags = GetBlockScriptFlags(pindex, m_params.GetConsensus());\n+    unsigned int flags = GetBlockScriptFlags(pindex, m_params.GetConsensus(), m_blockman.versionbitscache);\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n     LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs (%.2fms/blk)]\\n\", MILLI * (nTime2 - nTime1), nTimeForks * MICRO, nTimeForks * MILLI / nBlocksTotal);\n@@ -2133,7 +2134,7 @@ void CChainState::UpdateTip(const CBlockIndex* pindexNew)\n     if (!this->IsInitialBlockDownload()) {\n         const CBlockIndex* pindex = pindexNew;\n         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n-            WarningBitsConditionChecker checker(bit);\n+            WarningBitsConditionChecker checker(bit, m_blockman.versionbitscache);\n             ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), warningcache[bit]);\n             if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {\n                 const bilingual_str warning = strprintf(_(\"Unknown new rules activated (versionbit %i)\"), bit);\n@@ -4014,7 +4015,6 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     LOCK(cs_main);\n     chainman.Unload();\n     if (mempool) mempool->clear();\n-    g_versionbitscache.Clear();\n     for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n         warningcache[b].clear();\n     }"
      },
      {
        "sha": "61c9401bcae9644fd941c3b17f9df932154de59d",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ce125d3980fc271baabde2ca335fa22e33c372c/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ce125d3980fc271baabde2ca335fa22e33c372c/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=6ce125d3980fc271baabde2ca335fa22e33c372c",
        "patch": "@@ -25,6 +25,7 @@\n #include <util/check.h>\n #include <util/hasher.h>\n #include <util/translation.h>\n+#include <versionbits.h>\n \n #include <atomic>\n #include <map>\n@@ -519,6 +520,9 @@ class BlockManager\n     //! Check whether the block associated with this index entry is pruned or not.\n     bool IsBlockPruned(const CBlockIndex* pblockindex);\n \n+    /** Global cache for versionbits deployment status */\n+    VersionBitsCache versionbitscache;\n+\n     ~BlockManager() {\n         Unload();\n     }"
      }
    ]
  },
  {
    "sha": "92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
    "node_id": "C_kwDOABII59oAKDkyNDkyZWY2NWZlYTNjNWE5N2E1Y2U1NGY2YzU0OTg4ZWQ2NmZmNzk",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-01-07T21:41:51Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "warningcache: C-array to std::array",
      "tree": {
        "sha": "1e462b5b445e754c26c932f6be093fbe56249287",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e462b5b445e754c26c932f6be093fbe56249287"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92492ef65fea3c5a97a5ce54f6c54988ed66ff79/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6ce125d3980fc271baabde2ca335fa22e33c372c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ce125d3980fc271baabde2ca335fa22e33c372c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6ce125d3980fc271baabde2ca335fa22e33c372c"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "ff0a886e3a1ff95e9c56914a75688b462db108b0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92492ef65fea3c5a97a5ce54f6c54988ed66ff79/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92492ef65fea3c5a97a5ce54f6c54988ed66ff79/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
        "patch": "@@ -1508,7 +1508,7 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n     }\n };\n \n-static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS] GUARDED_BY(cs_main);\n+static std::array<ThresholdConditionCache, VERSIONBITS_NUM_BITS> warningcache GUARDED_BY(cs_main);\n \n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams, VersionBitsCache& versionbitscache)\n {\n@@ -2135,7 +2135,7 @@ void CChainState::UpdateTip(const CBlockIndex* pindexNew)\n         const CBlockIndex* pindex = pindexNew;\n         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n             WarningBitsConditionChecker checker(bit, m_blockman.versionbitscache);\n-            ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), warningcache[bit]);\n+            ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), warningcache.at(bit));\n             if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {\n                 const bilingual_str warning = strprintf(_(\"Unknown new rules activated (versionbit %i)\"), bit);\n                 if (state == ThresholdState::ACTIVE) {\n@@ -4015,8 +4015,8 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     LOCK(cs_main);\n     chainman.Unload();\n     if (mempool) mempool->clear();\n-    for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {\n-        warningcache[b].clear();\n+    for (auto& i : warningcache) {\n+        i.clear();\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "7dea2f7101f5eee99306f5e38018f87fb69a8685",
    "node_id": "C_kwDOABII59oAKDdkZWEyZjcxMDFmNWVlZTk5MzA2ZjVlMzgwMThmODdmYjY5YTg2ODU",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-07-09T00:52:24Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "Move warningcache to BlockManager",
      "tree": {
        "sha": "47574de469baf8fb4576d2602e0664f8feb2ab7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47574de469baf8fb4576d2602e0664f8feb2ab7f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dea2f7101f5eee99306f5e38018f87fb69a8685",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dea2f7101f5eee99306f5e38018f87fb69a8685",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7dea2f7101f5eee99306f5e38018f87fb69a8685",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dea2f7101f5eee99306f5e38018f87fb69a8685/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92492ef65fea3c5a97a5ce54f6c54988ed66ff79",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/92492ef65fea3c5a97a5ce54f6c54988ed66ff79"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 3,
      "deletions": 6
    },
    "files": [
      {
        "sha": "dd0e68767820be21a458e9f8b3e6f80d5052d322",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dea2f7101f5eee99306f5e38018f87fb69a8685/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dea2f7101f5eee99306f5e38018f87fb69a8685/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7dea2f7101f5eee99306f5e38018f87fb69a8685",
        "patch": "@@ -1508,8 +1508,6 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n     }\n };\n \n-static std::array<ThresholdConditionCache, VERSIONBITS_NUM_BITS> warningcache GUARDED_BY(cs_main);\n-\n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams, VersionBitsCache& versionbitscache)\n {\n     unsigned int flags = SCRIPT_VERIFY_NONE;\n@@ -2135,7 +2133,7 @@ void CChainState::UpdateTip(const CBlockIndex* pindexNew)\n         const CBlockIndex* pindex = pindexNew;\n         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n             WarningBitsConditionChecker checker(bit, m_blockman.versionbitscache);\n-            ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), warningcache.at(bit));\n+            ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), m_blockman.warningcache.at(bit));\n             if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {\n                 const bilingual_str warning = strprintf(_(\"Unknown new rules activated (versionbit %i)\"), bit);\n                 if (state == ThresholdState::ACTIVE) {\n@@ -4015,9 +4013,6 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n     LOCK(cs_main);\n     chainman.Unload();\n     if (mempool) mempool->clear();\n-    for (auto& i : warningcache) {\n-        i.clear();\n-    }\n }\n \n bool ChainstateManager::LoadBlockIndex()"
      },
      {
        "sha": "a4061c7a43ab2c2b8a5e0a91371988208620a0dd",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7dea2f7101f5eee99306f5e38018f87fb69a8685/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7dea2f7101f5eee99306f5e38018f87fb69a8685/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=7dea2f7101f5eee99306f5e38018f87fb69a8685",
        "patch": "@@ -523,6 +523,8 @@ class BlockManager\n     /** Global cache for versionbits deployment status */\n     VersionBitsCache versionbitscache;\n \n+    std::array<ThresholdConditionCache, VERSIONBITS_NUM_BITS> warningcache GUARDED_BY(cs_main);\n+\n     ~BlockManager() {\n         Unload();\n     }"
      }
    ]
  },
  {
    "sha": "eeef5c5c4887b856d63a0b931623237af271dcb1",
    "node_id": "C_kwDOABII59oAKGVlZWY1YzVjNDg4N2I4NTZkNjNhMGI5MzE2MjMyMzdhZjI3MWRjYjE",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-01-08T23:56:48Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "No more heap BlockIndices\n\n- Also make BlockManager::LookupBlockIndex non-const\n\nSee next commit for some weirdness that this eliminates.",
      "tree": {
        "sha": "66417ba914e16c7104999ab398fa88494025763c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66417ba914e16c7104999ab398fa88494025763c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eeef5c5c4887b856d63a0b931623237af271dcb1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeef5c5c4887b856d63a0b931623237af271dcb1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eeef5c5c4887b856d63a0b931623237af271dcb1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeef5c5c4887b856d63a0b931623237af271dcb1/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7dea2f7101f5eee99306f5e38018f87fb69a8685",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7dea2f7101f5eee99306f5e38018f87fb69a8685",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7dea2f7101f5eee99306f5e38018f87fb69a8685"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 51,
      "deletions": 47
    },
    "files": [
      {
        "sha": "5344e7b98cef3d3fec88195993cde4839fba8551",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eeef5c5c4887b856d63a0b931623237af271dcb1/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eeef5c5c4887b856d63a0b931623237af271dcb1/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=eeef5c5c4887b856d63a0b931623237af271dcb1",
        "patch": "@@ -1582,10 +1582,10 @@ static RPCHelpMan getchaintips()\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n-    for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {\n-        if (!active_chain.Contains(item.second)) {\n-            setOrphans.insert(item.second);\n-            setPrevs.insert(item.second->pprev);\n+    for (const std::pair<const uint256, CBlockIndex>& item : chainman.BlockIndex()) {\n+        if (!active_chain.Contains(&item.second)) {\n+            setOrphans.insert(&item.second);\n+            setPrevs.insert(item.second.pprev);\n         }\n     }\n "
      },
      {
        "sha": "0dc450f6ebec4fb8329e6d92c4eebd89bcc1c46f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 39,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eeef5c5c4887b856d63a0b931623237af271dcb1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eeef5c5c4887b856d63a0b931623237af271dcb1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=eeef5c5c4887b856d63a0b931623237af271dcb1",
        "patch": "@@ -130,11 +130,11 @@ arith_uint256 nMinimumChainWork;\n \n CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n \n-CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n+CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash)\n {\n     AssertLockHeld(cs_main);\n-    BlockMap::const_iterator it = m_block_index.find(hash);\n-    return it == m_block_index.end() ? nullptr : it->second;\n+    BlockMap::iterator it = m_block_index.find(hash);\n+    return it == m_block_index.end() ? nullptr : &it->second;\n }\n \n CBlockIndex* BlockManager::FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -1620,7 +1620,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         //  effectively caching the result of part of the verification.\n         BlockMap::const_iterator  it = m_blockman.m_block_index.find(hashAssumeValid);\n         if (it != m_blockman.m_block_index.end()) {\n-            if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n+            if (it->second.GetAncestor(pindex->nHeight) == pindex &&\n                 m_blockman.pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 m_blockman.pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n@@ -2677,8 +2677,8 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n \n     {\n         LOCK(cs_main);\n-        for (const auto& entry : m_blockman.m_block_index) {\n-            CBlockIndex *candidate = entry.second;\n+        for (auto& entry : m_blockman.m_block_index) {\n+            CBlockIndex *candidate = &entry.second;\n             // We don't need to put anything in our active chain into the\n             // multimap, because those candidates will be found and considered\n             // as we disconnect.\n@@ -2777,8 +2777,8 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n         // to setBlockIndexCandidates.\n         BlockMap::iterator it = m_blockman.m_block_index.begin();\n         while (it != m_blockman.m_block_index.end()) {\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {\n-                setBlockIndexCandidates.insert(it->second);\n+            if (it->second.IsValid(BLOCK_VALID_TRANSACTIONS) && it->second.HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(&it->second, m_chain.Tip())) {\n+                setBlockIndexCandidates.insert(&it->second);\n             }\n             it++;\n         }\n@@ -2801,17 +2801,17 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     // Remove the invalidity flag from this block and all its descendants.\n     BlockMap::iterator it = m_blockman.m_block_index.begin();\n     while (it != m_blockman.m_block_index.end()) {\n-        if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n-            it->second->nStatus &= ~BLOCK_FAILED_MASK;\n-            m_blockman.setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n-                setBlockIndexCandidates.insert(it->second);\n+        if (!it->second.IsValid() && it->second.GetAncestor(nHeight) == pindex) {\n+            it->second.nStatus &= ~BLOCK_FAILED_MASK;\n+            m_blockman.setDirtyBlockIndex.insert(&it->second);\n+            if (it->second.IsValid(BLOCK_VALID_TRANSACTIONS) && it->second.HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), &it->second)) {\n+                setBlockIndexCandidates.insert(&it->second);\n             }\n-            if (it->second == m_blockman.pindexBestInvalid) {\n+            if (&it->second == m_blockman.pindexBestInvalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 m_blockman.pindexBestInvalid = nullptr;\n             }\n-            m_blockman.m_failed_blocks.erase(it->second);\n+            m_blockman.m_failed_blocks.erase(&it->second);\n         }\n         it++;\n     }\n@@ -2835,20 +2835,21 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n     uint256 hash = block.GetHash();\n     BlockMap::iterator it = m_block_index.find(hash);\n     if (it != m_block_index.end())\n-        return it->second;\n+        return &it->second;\n \n     // Construct new block index object\n-    CBlockIndex* pindexNew = new CBlockIndex(block);\n+    CBlockIndex new_index(block);\n     // We assign the sequence id to blocks only when the full data is available,\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n-    pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n+    new_index.nSequenceId = 0;\n+    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, std::move(new_index))).first;\n+    CBlockIndex* pindexNew = &(*mi).second;\n     pindexNew->phashBlock = &((*mi).first);\n     BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n     if (miPrev != m_block_index.end())\n     {\n-        pindexNew->pprev = (*miPrev).second;\n+        pindexNew->pprev = &(*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n         pindexNew->BuildSkip();\n     }\n@@ -3191,7 +3192,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n         if (miSelf != m_block_index.end()) {\n             // Block header is already known.\n-            CBlockIndex* pindex = miSelf->second;\n+            CBlockIndex* pindex = &(miSelf->second);\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n@@ -3213,7 +3214,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n             LogPrintf(\"ERROR: %s: prev block not found\\n\", __func__);\n             return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, \"prev-blk-not-found\");\n         }\n-        pindexPrev = (*mi).second;\n+        pindexPrev = &((*mi).second);\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n             LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n             return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, \"bad-prevblk\");\n@@ -3459,8 +3460,8 @@ void BlockManager::PruneOneBlockFile(const int fileNumber)\n     AssertLockHeld(cs_main);\n     LOCK(cs_LastBlockFile);\n \n-    for (const auto& entry : m_block_index) {\n-        CBlockIndex* pindex = entry.second;\n+    for (auto& entry : m_block_index) {\n+        CBlockIndex* pindex = &entry.second;\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n             pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n@@ -3590,11 +3591,12 @@ CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n     // Return existing\n     BlockMap::iterator mi = m_block_index.find(hash);\n     if (mi != m_block_index.end())\n-        return (*mi).second;\n+        return &(*mi).second;\n \n     // Create new\n-    CBlockIndex* pindexNew = new CBlockIndex();\n-    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n+    CBlockIndex new_index;\n+    mi = m_block_index.insert(std::make_pair(hash, std::move(new_index))).first;\n+    CBlockIndex* pindexNew = &(*mi).second;\n     pindexNew->phashBlock = &((*mi).first);\n \n     return pindexNew;\n@@ -3611,9 +3613,9 @@ bool BlockManager::LoadBlockIndex(\n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(m_block_index.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n+    for (std::pair<const uint256, CBlockIndex>& item : m_block_index)\n     {\n-        CBlockIndex* pindex = item.second;\n+        CBlockIndex* pindex = &item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n@@ -3661,10 +3663,6 @@ void BlockManager::Unload() {\n     m_failed_blocks.clear();\n     m_blocks_unlinked.clear();\n \n-    for (const BlockMap::value_type& entry : m_block_index) {\n-        delete entry.second;\n-    }\n-\n     m_block_index.clear();\n \n     pindexBestInvalid = nullptr;\n@@ -3710,8 +3708,8 @@ bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n-        CBlockIndex* pindex = item.second;\n+    for (const std::pair<const uint256, CBlockIndex>& item : m_block_index) {\n+        const CBlockIndex* pindex = &item.second;\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n@@ -3936,13 +3934,13 @@ bool CChainState::ReplayBlocks()\n     if (m_blockman.m_block_index.count(hashHeads[0]) == 0) {\n         return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n     }\n-    pindexNew = m_blockman.m_block_index[hashHeads[0]];\n+    pindexNew = &(m_blockman.m_block_index[hashHeads[0]]);\n \n     if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n         if (m_blockman.m_block_index.count(hashHeads[1]) == 0) {\n             return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n         }\n-        pindexOld = m_blockman.m_block_index[hashHeads[1]];\n+        pindexOld = &(m_blockman.m_block_index[hashHeads[1]]);\n         pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n         assert(pindexFork != nullptr);\n     }\n@@ -4199,8 +4197,8 @@ void CChainState::CheckBlockIndex()\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (const std::pair<const uint256, CBlockIndex*>& entry : m_blockman.m_block_index) {\n-        forward.insert(std::make_pair(entry.second->pprev, entry.second));\n+    for (std::pair<const uint256, CBlockIndex>& entry : m_blockman.m_block_index) {\n+        forward.insert(std::make_pair(entry.second.pprev, &entry.second));\n     }\n \n     assert(forward.size() == m_blockman.m_block_index.size());"
      },
      {
        "sha": "1e8d470a9c263cfca331b718ae7986cc21284cbf",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eeef5c5c4887b856d63a0b931623237af271dcb1/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eeef5c5c4887b856d63a0b931623237af271dcb1/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=eeef5c5c4887b856d63a0b931623237af271dcb1",
        "patch": "@@ -99,7 +99,13 @@ enum class SynchronizationState {\n };\n \n extern RecursiveMutex cs_main;\n-typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n+\n+// Because validation code takes pointers to the map's CBlockIndex objects, if\n+// we ever switch to another associative container, we need to either use a\n+// container that has stable addressing (true of all std associative\n+// containers), or make the key a `std::unique_ptr<CBlockIndex>`\n+typedef std::unordered_map<uint256, CBlockIndex, BlockHasher> BlockMap;\n+\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n /** Used to notify getblocktemplate RPC of new tips. */\n@@ -487,7 +493,7 @@ class BlockManager\n         const CChainParams& chainparams,\n         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CBlockIndex* LookupBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Find the last common block between the parameter chain and a locator. */\n     CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      },
      {
        "sha": "74239a397b287cf4416a1a958d2cf31aef15138e",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eeef5c5c4887b856d63a0b931623237af271dcb1/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eeef5c5c4887b856d63a0b931623237af271dcb1/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=eeef5c5c4887b856d63a0b931623237af271dcb1",
        "patch": "@@ -349,10 +349,10 @@ static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lock\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n         LOCK(cs_main);\n-        auto inserted = chainman.BlockIndex().emplace(GetRandHash(), new CBlockIndex);\n+        auto inserted = chainman.BlockIndex().emplace(std::piecewise_construct, std::make_tuple(GetRandHash()), std::make_tuple());\n         assert(inserted.second);\n         const uint256& hash = inserted.first->first;\n-        block = inserted.first->second;\n+        block = &inserted.first->second;\n         block->nTime = blockTime;\n         block->phashBlock = &hash;\n         confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, hash, 0};"
      }
    ]
  },
  {
    "sha": "dc3d6905c4470894bdc450f070e7a68b85fff904",
    "node_id": "C_kwDOABII59oAKGRjM2Q2OTA1YzQ0NzA4OTRiZGM0NTBmMDcwZTdhNjhiODVmZmY5MDQ",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-07-12T19:09:26Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-08T22:03:31Z"
      },
      "message": "No more heap, no mo weirdneess",
      "tree": {
        "sha": "6363f6dd6174f635bd26a89b95dc849530cc13b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6363f6dd6174f635bd26a89b95dc849530cc13b4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc3d6905c4470894bdc450f070e7a68b85fff904",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc3d6905c4470894bdc450f070e7a68b85fff904",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dc3d6905c4470894bdc450f070e7a68b85fff904",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc3d6905c4470894bdc450f070e7a68b85fff904/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eeef5c5c4887b856d63a0b931623237af271dcb1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeef5c5c4887b856d63a0b931623237af271dcb1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eeef5c5c4887b856d63a0b931623237af271dcb1"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 0,
      "deletions": 5
    },
    "files": [
      {
        "sha": "4f425ec8fe35bcb3df3bb7e1afed6d20a24d063b",
        "filename": "src/test/validation_chainstate_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc3d6905c4470894bdc450f070e7a68b85fff904/src/test/validation_chainstate_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc3d6905c4470894bdc450f070e7a68b85fff904/src/test/validation_chainstate_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstate_tests.cpp?ref=dc3d6905c4470894bdc450f070e7a68b85fff904",
        "patch": "@@ -73,9 +73,6 @@ BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n         // The view cache should be empty since we had to destruct to downsize.\n         BOOST_CHECK(!c1.CoinsTip().HaveCoinInCache(outpoint));\n     }\n-\n-    // Avoid triggering the address sanitizer.\n-    WITH_LOCK(::cs_main, manager.Unload());\n }\n \n //! Test UpdateTip behavior for both active and background chainstates."
      },
      {
        "sha": "a91ff94e1d5401d8d600f8b02a554eaff5aa7d37",
        "filename": "src/test/validation_chainstatemanager_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc3d6905c4470894bdc450f070e7a68b85fff904/src/test/validation_chainstatemanager_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc3d6905c4470894bdc450f070e7a68b85fff904/src/test/validation_chainstatemanager_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstatemanager_tests.cpp?ref=dc3d6905c4470894bdc450f070e7a68b85fff904",
        "patch": "@@ -97,8 +97,6 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n \n     // Let scheduler events finish running to avoid accessing memory that is going to be unloaded\n     SyncWithValidationInterfaceQueue();\n-\n-    WITH_LOCK(::cs_main, manager.Unload());\n }\n \n //! Test rebalancing the caches associated with each chainstate."
      }
    ]
  },
  {
    "sha": "9677780f3858bc5ae4511a51fc6a90bee1e2df34",
    "node_id": "C_kwDOABII59oAKDk2Nzc3ODBmMzg1OGJjNWFlNDUxMWE1MWZjNmE5MGJlZTFlMmRmMzQ",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-09-13T21:02:55Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-09T00:12:05Z"
      },
      "message": "init: Reset mempool and chainman via reconstruction\n\nFixes https://github.com/bitcoin/bitcoin/issues/22964\n\nPreviously, we used UnloadBlockIndex() in order to reset node.mempool\nand node.chainman. However, that has proven to be fragile (see\nhttps://github.com/bitcoin/bitcoin/issues/22964), and requires\nUnloadBlockIndex and its callees to be updated manually for each member\nthat's introduced to the mempool and chainman classes.\n\nIn this commit, we stop using the UnloadBlockIndex function and we\nsimply reconstruct node.mempool and node.chainman.\n\nSince PeerManager needs a valid reference to both node.mempool and\nnode.chainman, we also move PeerManager's construction via `::make` to\nafter the chainstate activation sequence is complete.\n\nThere are no more callers to UnloadBlockIndex after this commit, so it\nand its sole callees can be pruned.",
      "tree": {
        "sha": "fed0bc473771dfc01911bf4765d97235ec721365",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fed0bc473771dfc01911bf4765d97235ec721365"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9677780f3858bc5ae4511a51fc6a90bee1e2df34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9677780f3858bc5ae4511a51fc6a90bee1e2df34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9677780f3858bc5ae4511a51fc6a90bee1e2df34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9677780f3858bc5ae4511a51fc6a90bee1e2df34/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc3d6905c4470894bdc450f070e7a68b85fff904",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc3d6905c4470894bdc450f070e7a68b85fff904",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc3d6905c4470894bdc450f070e7a68b85fff904"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 18,
      "deletions": 15
    },
    "files": [
      {
        "sha": "3e772ca29807f7827cb1f0793e79e8fee465c660",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 15,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9677780f3858bc5ae4511a51fc6a90bee1e2df34/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9677780f3858bc5ae4511a51fc6a90bee1e2df34/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=9677780f3858bc5ae4511a51fc6a90bee1e2df34",
        "patch": "@@ -1217,18 +1217,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     // as they would never get updated.\n     if (!ignores_incoming_txs) node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();\n \n-    assert(!node.mempool);\n     int check_ratio = std::min<int>(std::max<int>(args.GetIntArg(\"-checkmempool\", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);\n-    node.mempool = std::make_unique<CTxMemPool>(node.fee_estimator.get(), check_ratio);\n-\n-    assert(!node.chainman);\n-    node.chainman = std::make_unique<ChainstateManager>();\n-    ChainstateManager& chainman = *node.chainman;\n-\n-    assert(!node.peerman);\n-    node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),\n-                                     chainman, *node.mempool, ignores_incoming_txs);\n-    RegisterValidationInterface(node.peerman.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n@@ -1356,8 +1345,18 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     LogPrintf(\"* Using %.1f MiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n+    assert(!node.mempool);\n+    assert(!node.chainman);\n     bool fLoaded = false;\n     while (!fLoaded && !ShutdownRequested()) {\n+        node.mempool = std::make_unique<CTxMemPool>(node.fee_estimator.get(), check_ratio);\n+        CTxMemPool& mempool = *Assert(node.mempool);\n+\n+        node.chainman = std::make_unique<ChainstateManager>();\n+        ChainstateManager& chainman = *Assert(node.chainman);\n+        chainman.m_total_coinstip_cache = nCoinCacheUsage;\n+        chainman.m_total_coinsdb_cache = nCoinDBCache;\n+\n         const bool fReset = fReindex;\n         auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n             return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();\n@@ -1370,11 +1369,8 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n             const int64_t load_block_index_start_time = GetTimeMillis();\n             try {\n                 LOCK(cs_main);\n-                chainman.InitializeChainstate(Assert(node.mempool.get()));\n-                chainman.m_total_coinstip_cache = nCoinCacheUsage;\n-                chainman.m_total_coinsdb_cache = nCoinDBCache;\n \n-                UnloadBlockIndex(node.mempool.get(), chainman);\n+                chainman.InitializeChainstate(&mempool);\n \n                 auto& pblocktree{chainman.m_blockman.m_block_tree_db};\n                 // new CBlockTreeDB tries to delete the existing file, which\n@@ -1565,6 +1561,13 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n         return false;\n     }\n \n+    ChainstateManager& chainman = *Assert(node.chainman);\n+\n+    assert(!node.peerman);\n+    node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),\n+                                     chainman, *node.mempool, ignores_incoming_txs);\n+    RegisterValidationInterface(node.peerman.get());\n+\n     // ********************************************************* Step 8: start indexers\n     if (args.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n         if (const auto error{CheckLegacyTxindex(*Assert(chainman.m_blockman.m_block_tree_db))}) {"
      }
    ]
  },
  {
    "sha": "d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
    "node_id": "C_kwDOABII59oAKGQ3YTA1NDNkZDk2OWRlZWZiNGI4YzVjYTVlYzA1NjNmODQwYjgwNTI",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-01-12T18:38:53Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-09T00:12:10Z"
      },
      "message": "validation: Prune UnloadBlockIndex and callees\n\nIn previous commits in this patchset, we've made sure that every\nUnload/UnloadBlockIndex member function resets its own members, and does\nnot reach out to globals.\n\nThis means that their corresponding classes' default destructors can now\nreplace them, and do an even more thorough job without the need to be\nupdated for every new member variable.\n\nTherefore, we can remove them, and also remove UnloadBlockIndex since\nthat's not used anymore.",
      "tree": {
        "sha": "c19052c766c84996519983817a5c713287111c1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c19052c766c84996519983817a5c713287111c1c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9677780f3858bc5ae4511a51fc6a90bee1e2df34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9677780f3858bc5ae4511a51fc6a90bee1e2df34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9677780f3858bc5ae4511a51fc6a90bee1e2df34"
      }
    ],
    "stats": {
      "total": 67,
      "additions": 0,
      "deletions": 67
    },
    "files": [
      {
        "sha": "95a44d62d6a6338d02132aee2dbf00d158429987",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
        "patch": "@@ -162,10 +162,8 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.banman.reset();\n     m_node.addrman.reset();\n     m_node.args = nullptr;\n-    UnloadBlockIndex(m_node.mempool.get(), *m_node.chainman);\n     m_node.mempool.reset();\n     m_node.scheduler.reset();\n-    m_node.chainman->Reset();\n     m_node.chainman.reset();\n }\n "
      },
      {
        "sha": "68d03ab48ed0684cc5edcf5fdfc18c49e5ed7108",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 45,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
        "patch": "@@ -3659,26 +3659,6 @@ bool BlockManager::LoadBlockIndex(\n     return true;\n }\n \n-void BlockManager::Unload() {\n-    m_failed_blocks.clear();\n-    m_blocks_unlinked.clear();\n-\n-    m_block_index.clear();\n-\n-    pindexBestInvalid = nullptr;\n-    pindexBestHeader = nullptr;\n-\n-    setDirtyBlockIndex.clear();\n-    setDirtyFileInfo.clear();\n-\n-    {\n-        LOCK(cs_LastBlockFile);\n-        vinfoBlockFile.clear();\n-        nLastBlockFile = 0;\n-        // TODO: reset fCheckForPruning?\n-    }\n-}\n-\n bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n {\n     if (!LoadBlockIndex(\n@@ -3998,21 +3978,6 @@ bool CChainState::NeedsRedownload() const\n     return false;\n }\n \n-void CChainState::UnloadBlockIndex() {\n-    nBlockSequenceId = 1;\n-    setBlockIndexCandidates.clear();\n-}\n-\n-// May NOT be used after any connections are up as much\n-// of the peer-processing logic assumes a consistent\n-// block index state\n-void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)\n-{\n-    LOCK(cs_main);\n-    chainman.Unload();\n-    if (mempool) mempool->clear();\n-}\n-\n bool ChainstateManager::LoadBlockIndex()\n {\n     AssertLockHeld(cs_main);\n@@ -4959,16 +4924,6 @@ bool ChainstateManager::IsSnapshotActive() const\n     return m_snapshot_chainstate && m_active_chainstate == m_snapshot_chainstate.get();\n }\n \n-void ChainstateManager::Unload()\n-{\n-    for (CChainState* chainstate : this->GetAll()) {\n-        chainstate->m_chain.SetTip(nullptr);\n-        chainstate->UnloadBlockIndex();\n-    }\n-\n-    m_blockman.Unload();\n-}\n-\n void ChainstateManager::Reset()\n {\n     LOCK(::cs_main);"
      },
      {
        "sha": "102b6f8e067649261adb891fdf38096d723d6e54",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7a0543dd969deefb4b8c5ca5ec0563f840b8052/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
        "patch": "@@ -131,8 +131,6 @@ extern arith_uint256 nMinimumChainWork;\n /** Documentation for argument 'checklevel'. */\n extern const std::vector<std::string> CHECKLEVEL_DOC;\n \n-/** Unload database information */\n-void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);\n /** Run instances of script checking worker threads */\n void StartScriptCheckWorkerThreads(int threads_num);\n /** Stop all of the script checking worker threads */\n@@ -473,9 +471,6 @@ class BlockManager\n         std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n         EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    /** Clear all data members. */\n-    void Unload() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Create a new block index entry for a given block hash */\n     CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -530,10 +525,6 @@ class BlockManager\n     VersionBitsCache versionbitscache;\n \n     std::array<ThresholdConditionCache, VERSIONBITS_NUM_BITS> warningcache GUARDED_BY(cs_main);\n-\n-    ~BlockManager() {\n-        Unload();\n-    }\n };\n \n /**\n@@ -798,8 +789,6 @@ class CChainState\n \n     void PruneBlockIndexCandidates();\n \n-    void UnloadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n-\n     /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n     bool IsInitialBlockDownload() const;\n \n@@ -1051,21 +1040,12 @@ class ChainstateManager\n     //! Load the block tree and coins database from disk, initializing state if we're running with -reindex\n     bool LoadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    //! Unload block index and chain data before shutdown.\n-    void Unload() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n-\n     //! Clear (deconstruct) chainstate data.\n     void Reset();\n \n     //! Check to see if caches are out of balance and if so, call\n     //! ResizeCoinsCaches() as needed.\n     void MaybeRebalanceCaches() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n-\n-    ~ChainstateManager() {\n-        LOCK(::cs_main);\n-        UnloadBlockIndex(/* mempool */ nullptr, *this);\n-        Reset();\n-    }\n };\n \n using FopenFn = std::function<FILE*(const fs::path&, const char*)>;"
      }
    ]
  },
  {
    "sha": "444bdccacb12d3630518795497d12b39774e5871",
    "node_id": "C_kwDOABII59oAKDQ0NGJkY2NhY2IxMmQzNjMwNTE4Nzk1NDk3ZDEyYjM5Nzc0ZTU4NzE",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-09-14T18:57:02Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-09T00:12:10Z"
      },
      "message": "scripted-diff: Rename cs_LastBlockFile to cs_blockfiles\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l 'cs_LastBlockFile' | xargs sed -i 's@cs_LastBlockFile@cs_blockfiles@g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "f547ed92ce6756465181e46036040d20b236c748",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f547ed92ce6756465181e46036040d20b236c748"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/444bdccacb12d3630518795497d12b39774e5871",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/444bdccacb12d3630518795497d12b39774e5871",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/444bdccacb12d3630518795497d12b39774e5871",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/444bdccacb12d3630518795497d12b39774e5871/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7a0543dd969deefb4b8c5ca5ec0563f840b8052",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7a0543dd969deefb4b8c5ca5ec0563f840b8052"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 17,
      "deletions": 17
    },
    "files": [
      {
        "sha": "d0717cb9143b6a2421dcce991af33f3dc40d5760",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/444bdccacb12d3630518795497d12b39774e5871/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/444bdccacb12d3630518795497d12b39774e5871/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=444bdccacb12d3630518795497d12b39774e5871",
        "patch": "@@ -82,7 +82,7 @@ std::string CBlockFileInfo::ToString() const\n \n CBlockFileInfo* BlockManager::GetBlockFileInfo(size_t n)\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n \n     return &vinfoBlockFile.at(n);\n }\n@@ -150,7 +150,7 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)\n \n void BlockManager::FlushUndoFile(int block_file, bool finalize)\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n     FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);\n     if (!UndoFileSeq().Flush(undo_pos_old, finalize)) {\n         AbortNode(\"Flushing undo file to disk failed. This is likely the result of an I/O error.\");\n@@ -159,7 +159,7 @@ void BlockManager::FlushUndoFile(int block_file, bool finalize)\n \n void BlockManager::FlushBlockFile(bool fFinalize, bool finalize_undo)\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n     FlatFilePos block_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nSize);\n     if (!BlockFileSeq().Flush(block_pos_old, fFinalize)) {\n         AbortNode(\"Flushing block file to disk failed. This is likely the result of an I/O error.\");\n@@ -171,7 +171,7 @@ void BlockManager::FlushBlockFile(bool fFinalize, bool finalize_undo)\n \n uint64_t BlockManager::CalculateCurrentUsage()\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n \n     uint64_t retval = 0;\n     for (const CBlockFileInfo& file : vinfoBlockFile) {\n@@ -218,7 +218,7 @@ fs::path GetBlockPosFilename(const FlatFilePos& pos)\n \n bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)\n {\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n \n     unsigned int nFile = fKnown ? pos.nFile : nLastBlockFile;\n     if (vinfoBlockFile.size() <= nFile) {\n@@ -275,7 +275,7 @@ bool BlockManager::FindUndoPos(BlockValidationState& state, int nFile, FlatFileP\n {\n     pos.nFile = nFile;\n \n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n \n     pos.nPos = vinfoBlockFile[nFile].nUndoSize;\n     vinfoBlockFile[nFile].nUndoSize += nAddSize;\n@@ -333,7 +333,7 @@ bool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid\n         // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in\n         // the FindBlockPos function\n         {\n-            LOCK(cs_LastBlockFile);\n+            LOCK(cs_blockfiles);\n             if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {\n                 FlushUndoFile(_pos.nFile, true);\n             }"
      },
      {
        "sha": "c0b1d1eb9b17eab2e89a21f83355522edaa9a5a1",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/444bdccacb12d3630518795497d12b39774e5871/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/444bdccacb12d3630518795497d12b39774e5871/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=444bdccacb12d3630518795497d12b39774e5871",
        "patch": "@@ -1928,7 +1928,7 @@ bool CChainState::FlushStateToDisk(\n         bool fDoFullFlush = false;\n \n         CoinsCacheSizeState cache_state = GetCoinsCacheSizeState();\n-        LOCK(m_blockman.cs_LastBlockFile);\n+        LOCK(m_blockman.cs_blockfiles);\n         if (fPruneMode && (m_blockman.fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {\n             // make sure we don't prune above the blockfilterindexes bestblocks\n             // pruning is height-based\n@@ -2056,7 +2056,7 @@ void CChainState::PruneAndFlush()\n {\n     BlockValidationState state;\n     {\n-        LOCK(m_blockman.cs_LastBlockFile);\n+        LOCK(m_blockman.cs_blockfiles);\n         m_blockman.fCheckForPruning = true;\n     }\n     if (!this->FlushStateToDisk(state, FlushStateMode::NONE)) {\n@@ -3458,7 +3458,7 @@ bool TestBlockValidity(BlockValidationState& state,\n void BlockManager::PruneOneBlockFile(const int fileNumber)\n {\n     AssertLockHeld(cs_main);\n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n \n     for (auto& entry : m_block_index) {\n         CBlockIndex* pindex = &entry.second;\n@@ -3493,7 +3493,7 @@ void BlockManager::FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nM\n {\n     assert(fPruneMode && nManualPruneHeight > 0);\n \n-    LOCK2(cs_main, cs_LastBlockFile);\n+    LOCK2(cs_main, cs_blockfiles);\n     if (chain_tip_height < 0) {\n         return;\n     }\n@@ -3524,7 +3524,7 @@ void PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeigh\n \n void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight, int chain_tip_height, int prune_height, bool is_ibd)\n {\n-    LOCK2(cs_main, cs_LastBlockFile);\n+    LOCK2(cs_main, cs_blockfiles);\n     if (chain_tip_height < 0 || nPruneTarget == 0) {\n         return;\n     }\n@@ -3667,7 +3667,7 @@ bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar\n         return false;\n     }\n \n-    LOCK(cs_LastBlockFile);\n+    LOCK(cs_blockfiles);\n     // Load block file info\n     m_block_tree_db->ReadLastBlockFile(nLastBlockFile);\n     vinfoBlockFile.resize(nLastBlockFile + 1);"
      },
      {
        "sha": "8b21c5cf2e0bcf3eb3acc557c3b36f240eb7b221",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/444bdccacb12d3630518795497d12b39774e5871/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/444bdccacb12d3630518795497d12b39774e5871/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=444bdccacb12d3630518795497d12b39774e5871",
        "patch": "@@ -436,14 +436,14 @@ class BlockManager\n     /** Dirty block file entries. */\n     std::set<int> setDirtyFileInfo;\n \n-    RecursiveMutex cs_LastBlockFile;\n-    std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);\n-    int nLastBlockFile GUARDED_BY(cs_LastBlockFile) = 0;\n+    RecursiveMutex cs_blockfiles;\n+    std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_blockfiles);\n+    int nLastBlockFile GUARDED_BY(cs_blockfiles) = 0;\n     /** Global flag to indicate we should check to see if there are\n      *  block/undo files that should be deleted.  Set on startup\n      *  or if we allocate more file space when we're in prune mode\n      */\n-    bool fCheckForPruning GUARDED_BY(cs_LastBlockFile) = false;\n+    bool fCheckForPruning GUARDED_BY(cs_blockfiles) = false;\n \n     /**\n      * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions."
      }
    ]
  },
  {
    "sha": "0898078ed59453cc850ebe08010e68e6dea51dbd",
    "node_id": "C_kwDOABII59oAKDA4OTgwNzhlZDU5NDUzY2M4NTBlYmUwODAxMGU2OGU2ZGVhNTFkYmQ",
    "commit": {
      "author": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-07T01:27:29Z"
      },
      "committer": {
        "name": "Carl Dong",
        "email": "contact@carldong.me",
        "date": "2021-10-09T00:12:10Z"
      },
      "message": "validation/docs: Add pindexBestInvalid description",
      "tree": {
        "sha": "2797881945dcea2483adcae54777b02617eeac25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2797881945dcea2483adcae54777b02617eeac25"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0898078ed59453cc850ebe08010e68e6dea51dbd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0898078ed59453cc850ebe08010e68e6dea51dbd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0898078ed59453cc850ebe08010e68e6dea51dbd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0898078ed59453cc850ebe08010e68e6dea51dbd/comments",
    "author": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dongcarl",
      "id": 3445290,
      "node_id": "MDQ6VXNlcjM0NDUyOTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dongcarl",
      "html_url": "https://github.com/dongcarl",
      "followers_url": "https://api.github.com/users/dongcarl/followers",
      "following_url": "https://api.github.com/users/dongcarl/following{/other_user}",
      "gists_url": "https://api.github.com/users/dongcarl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
      "organizations_url": "https://api.github.com/users/dongcarl/orgs",
      "repos_url": "https://api.github.com/users/dongcarl/repos",
      "events_url": "https://api.github.com/users/dongcarl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dongcarl/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "444bdccacb12d3630518795497d12b39774e5871",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/444bdccacb12d3630518795497d12b39774e5871",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/444bdccacb12d3630518795497d12b39774e5871"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b51cd92d792de06b3cfc30c1fc660d5a0bce9e8f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0898078ed59453cc850ebe08010e68e6dea51dbd/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0898078ed59453cc850ebe08010e68e6dea51dbd/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=0898078ed59453cc850ebe08010e68e6dea51dbd",
        "patch": "@@ -425,6 +425,7 @@ class BlockManager\n       */\n     std::set<CBlockIndex*> m_failed_blocks;\n \n+    /** Most-work invalid block that we've seen so far (used to check for large invalid chains). */\n     CBlockIndex* pindexBestInvalid = nullptr;\n \n     /** Best header we've seen so far (used for getheaders queries' starting points). */"
      }
    ]
  }
]