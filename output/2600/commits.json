[
  {
    "sha": "5d891489ab7828ad8db15e85bb63e2f13f021a6a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDg5MTQ4OWFiNzgyOGFkOGRiMTVlODViYjYzZTJmMTNmMDIxYTZh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-04-30T19:56:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2013-05-30T03:18:42Z"
      },
      "message": "Make CPubKey statically allocated",
      "tree": {
        "sha": "24cd213e276977570de5b299872368bdf70ac929",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/24cd213e276977570de5b299872368bdf70ac929"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d891489ab7828ad8db15e85bb63e2f13f021a6a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d891489ab7828ad8db15e85bb63e2f13f021a6a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d891489ab7828ad8db15e85bb63e2f13f021a6a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d891489ab7828ad8db15e85bb63e2f13f021a6a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec0004aca0a2bf11f99c9587ddb2bf8ea818d3bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec0004aca0a2bf11f99c9587ddb2bf8ea818d3bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec0004aca0a2bf11f99c9587ddb2bf8ea818d3bb"
      }
    ],
    "stats": {
      "total": 126,
      "additions": 98,
      "deletions": 28
    },
    "files": [
      {
        "sha": "536ab71165c17f0fe3761636ca38f9e28315ddaa",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -105,15 +105,22 @@ uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL\n     return ss.GetHash();\n }\n \n-inline uint160 Hash160(const std::vector<unsigned char>& vch)\n+template<typename T1>\n+inline uint160 Hash160(const T1 pbegin, const T1 pend)\n {\n+    static unsigned char pblank[1];\n     uint256 hash1;\n-    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n+    SHA256((pbegin == pend ? pblank : (unsigned char*)&pbegin[0]), (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&hash1);\n     uint160 hash2;\n     RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n     return hash2;\n }\n \n+inline uint160 Hash160(const std::vector<unsigned char>& vch)\n+{\n+    return Hash160(vch.begin(), vch.end());\n+}\n+\n unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\n \n #endif"
      },
      {
        "sha": "a99363c1240614a0cdc9c0285f16550c4a00cc1c",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -258,11 +258,11 @@ CPrivKey CKey::GetPrivKey() const\n \n bool CKey::SetPubKey(const CPubKey& vchPubKey)\n {\n-    const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n-    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n+    const unsigned char* pbegin = vchPubKey.begin();\n+    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))\n     {\n         fSet = true;\n-        if (vchPubKey.vchPubKey.size() == 33)\n+        if (vchPubKey.size() == 33)\n             SetCompressedPubKey();\n         return true;\n     }\n@@ -276,11 +276,13 @@ CPubKey CKey::GetPubKey() const\n     int nSize = i2o_ECPublicKey(pkey, NULL);\n     if (!nSize)\n         throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n-    std::vector<unsigned char> vchPubKey(nSize, 0);\n-    unsigned char* pbegin = &vchPubKey[0];\n+    assert(nSize <= 65);\n+    CPubKey ret;\n+    unsigned char *pbegin = ret.begin();\n     if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n         throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n-    return CPubKey(vchPubKey);\n+    assert((int)ret.size() == nSize);\n+    return ret;\n }\n \n bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)"
      },
      {
        "sha": "1b122112f3bb7c53509a3a3f710ad1f77e56b18c",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 71,
        "deletions": 14,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -63,38 +63,95 @@ class CScriptID : public uint160\n /** An encapsulated public key. */\n class CPubKey {\n private:\n-    std::vector<unsigned char> vchPubKey;\n+    unsigned char vch[65];\n+\n+    unsigned int static GetLen(unsigned char chHeader) {\n+        if (chHeader == 2 || chHeader == 3)\n+            return 33;\n+        if (chHeader == 4 || chHeader == 6 || chHeader == 7)\n+            return 65;\n+        return 0;\n+    }\n+\n+    unsigned char *begin() {\n+        return vch;\n+    }\n+\n     friend class CKey;\n \n public:\n-    CPubKey() { }\n-    CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n-    friend bool operator==(const CPubKey &a, const CPubKey &b) { return a.vchPubKey == b.vchPubKey; }\n-    friend bool operator!=(const CPubKey &a, const CPubKey &b) { return a.vchPubKey != b.vchPubKey; }\n-    friend bool operator<(const CPubKey &a, const CPubKey &b) { return a.vchPubKey < b.vchPubKey; }\n+    CPubKey() { vch[0] = 0xFF; }\n+\n+    CPubKey(const std::vector<unsigned char> &vchPubKeyIn) {\n+        int len = vchPubKeyIn.empty() ? 0 : GetLen(vchPubKeyIn[0]);\n+        if (len) {\n+            memcpy(vch, &vchPubKeyIn[0], len);\n+        } else {\n+            vch[0] = 0xFF;\n+        }\n+    }\n+\n+    unsigned int size() const {\n+        return GetLen(vch[0]);\n+    }\n+\n+    const unsigned char *begin() const {\n+        return vch;\n+    }\n \n-    IMPLEMENT_SERIALIZE(\n-        READWRITE(vchPubKey);\n-    )\n+    const unsigned char *end() const {\n+        return vch+size();\n+    }\n+\n+    friend bool operator==(const CPubKey &a, const CPubKey &b) { return memcmp(a.vch, b.vch, a.size()) == 0; }\n+    friend bool operator!=(const CPubKey &a, const CPubKey &b) { return memcmp(a.vch, b.vch, a.size()) != 0; }\n+    friend bool operator<(const CPubKey &a, const CPubKey &b) {\n+        return a.vch[0] < b.vch[0] ||\n+               (a.vch[0] == b.vch[0] && memcmp(a.vch+1, b.vch+1, a.size() - 1) < 0);\n+    }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+        return size() + 1;\n+    }\n+\n+    template<typename Stream> void Serialize(Stream &s, int nType, int nVersion) const {\n+        unsigned int len = size();\n+        ::Serialize(s, VARINT(len), nType, nVersion);\n+        s.write((char*)vch, len);\n+    }\n+\n+    template<typename Stream> void Unserialize(Stream &s, int nType, int nVersion) {\n+        unsigned int len;\n+        ::Unserialize(s, VARINT(len), nType, nVersion);\n+        if (len <= 65) {\n+            s.read((char*)vch, len);\n+        } else {\n+            // invalid pubkey\n+            vch[0] = 0xFF;\n+            char dummy;\n+            while (len--)\n+                s.read(&dummy, 1);\n+        }\n+    }\n \n     CKeyID GetID() const {\n-        return CKeyID(Hash160(vchPubKey));\n+        return CKeyID(Hash160(vch, vch+size()));\n     }\n \n     uint256 GetHash() const {\n-        return Hash(vchPubKey.begin(), vchPubKey.end());\n+        return Hash(vch, vch+size());\n     }\n \n     bool IsValid() const {\n-        return vchPubKey.size() == 33 || vchPubKey.size() == 65;\n+        return size() > 0;\n     }\n \n     bool IsCompressed() const {\n-        return vchPubKey.size() == 33;\n+        return size() == 33;\n     }\n \n     std::vector<unsigned char> Raw() const {\n-        return vchPubKey;\n+        return std::vector<unsigned char>(vch, vch+size());\n     }\n };\n "
      },
      {
        "sha": "64ee39081bfc282b98d4650f2784883912fb41dd",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -1445,7 +1445,7 @@ class DescribeAddressVisitor : public boost::static_visitor<Object>\n         CPubKey vchPubKey;\n         pwalletMain->GetPubKey(keyID, vchPubKey);\n         obj.push_back(Pair(\"isscript\", false));\n-        obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey.Raw())));\n+        obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n         obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n         return obj;\n     }"
      },
      {
        "sha": "7e1d5785e8cb031ef8d5a286a503cea05a2662b3",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -1895,10 +1895,11 @@ bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigne\n         if (!key.SetPubKey(CPubKey(vch)))\n             return false;\n         key.SetCompressedPubKey(false); // Decompress public key\n-        CPubKey pubkey = key.GetPubKey();\n+        const CPubKey pubkey = key.GetPubKey();\n+        assert(pubkey.size() == 65);\n         script.resize(67);\n         script[0] = 65;\n-        memcpy(&script[1], &pubkey.Raw()[0], 65);\n+        memcpy(&script[1], pubkey.begin(), 65);\n         script[66] = OP_CHECKSIG;\n         return true;\n     }"
      },
      {
        "sha": "e639003549b7f0dc2421ba7cba3aa0c4e65f33f1",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -348,8 +348,10 @@ class CScript : public std::vector<unsigned char>\n \n     CScript& operator<<(const CPubKey& key)\n     {\n-        std::vector<unsigned char> vchKey = key.Raw();\n-        return (*this) << vchKey;\n+        assert(key.size() < OP_PUSHDATA1);\n+        insert(end(), (unsigned char)key.size());\n+        insert(end(), key.begin(), key.end());\n+        return *this;\n     }\n \n     CScript& operator<<(const CBigNum& b)"
      },
      {
        "sha": "b922545b9ba386c4959cd37fd6b2fab2d270c6db",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d891489ab7828ad8db15e85bb63e2f13f021a6a/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "patch": "@@ -300,7 +300,8 @@ std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n     return rv;\n }\n \n-inline std::string HexStr(const std::vector<unsigned char>& vch, bool fSpaces=false)\n+template<typename T>\n+inline std::string HexStr(const T& vch, bool fSpaces=false)\n {\n     return HexStr(vch.begin(), vch.end(), fSpaces);\n }"
      }
    ]
  },
  {
    "sha": "dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZmEyM2I5NGMyNGFhZTY0NjYxNTJmY2NiZTg5NmJhNWRjMGU5N2I0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-05-01T04:52:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2013-05-30T03:20:21Z"
      },
      "message": "CSecret/CKey -> CKey/CPubKey split/refactor",
      "tree": {
        "sha": "a1f7f856577b2223bae9351c960b595b4032ce7a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1f7f856577b2223bae9351c960b595b4032ce7a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d891489ab7828ad8db15e85bb63e2f13f021a6a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5d891489ab7828ad8db15e85bb63e2f13f021a6a"
      }
    ],
    "stats": {
      "total": 1159,
      "additions": 564,
      "deletions": 595
    },
    "files": [
      {
        "sha": "44f4d5eec6d038f4d4ca4243cb0ba281aae657f0",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -144,9 +144,7 @@ bool CAlert::RelayTo(CNode* pnode) const\n \n bool CAlert::CheckSignature() const\n {\n-    CKey key;\n-    if (!key.SetPubKey(ParseHex(fTestNet ? pszTestKey : pszMainKey)))\n-        return error(\"CAlert::CheckSignature() : SetPubKey failed\");\n+    CPubKey key(ParseHex(fTestNet ? pszTestKey : pszMainKey));\n     if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n         return error(\"CAlert::CheckSignature() : verify signature failed\");\n "
      },
      {
        "sha": "b4490ce2776747696d7ac1472c0d570014904db7",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -176,6 +176,15 @@ class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n     {}\n };\n \n+template<typename T> void LockObject(const T &t) {\n+    LockedPageManager::instance.LockRange((void*)(&t), sizeof(T));\n+}\n+\n+template<typename T> void UnlockObject(const T &t) {\n+    OPENSSL_cleanse((void*)(&t), sizeof(T));\n+    LockedPageManager::instance.UnlockRange((void*)(&t), sizeof(T));\n+}\n+\n //\n // Allocator that locks its contents from being paged\n // out of memory and clears its contents before deletion."
      },
      {
        "sha": "efe3a95ebdb66d8d60b01894567b281cd086d861",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -398,21 +398,19 @@ bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const {\n class CBitcoinSecret : public CBase58Data\n {\n public:\n-    void SetSecret(const CSecret& vchSecret, bool fCompressed)\n+    void SetKey(const CKey& vchSecret)\n     {\n-        assert(vchSecret.size() == 32);\n-        SetData(fTestNet ? 239 : 128, &vchSecret[0], vchSecret.size());\n-        if (fCompressed)\n+        assert(vchSecret.IsValid());\n+        SetData(fTestNet ? 239 : 128, vchSecret.begin(), vchSecret.size());\n+        if (vchSecret.IsCompressed())\n             vchData.push_back(1);\n     }\n \n-    CSecret GetSecret(bool &fCompressedOut)\n+    CKey GetKey()\n     {\n-        CSecret vchSecret;\n-        vchSecret.resize(32);\n-        memcpy(&vchSecret[0], &vchData[0], 32);\n-        fCompressedOut = vchData.size() == 33;\n-        return vchSecret;\n+        CKey ret;\n+        ret.Set(&vchData[0], &vchData[32], vchData.size() > 32 && vchData[32] == 1);\n+        return ret;\n     }\n \n     bool IsValid() const\n@@ -443,9 +441,9 @@ class CBitcoinSecret : public CBase58Data\n         return SetString(strSecret.c_str());\n     }\n \n-    CBitcoinSecret(const CSecret& vchSecret, bool fCompressed)\n+    CBitcoinSecret(const CKey& vchSecret)\n     {\n-        SetSecret(vchSecret, fCompressed);\n+        SetKey(vchSecret);\n     }\n \n     CBitcoinSecret()"
      },
      {
        "sha": "32baabd6744c85cb2f0bd08cff3161396c030cb0",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -100,17 +100,17 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM\n }\n \n \n-bool EncryptSecret(CKeyingMaterial& vMasterKey, const CSecret &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n+bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n {\n     CCrypter cKeyCrypter;\n     std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n     memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n     if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n         return false;\n-    return cKeyCrypter.Encrypt((CKeyingMaterial)vchPlaintext, vchCiphertext);\n+    return cKeyCrypter.Encrypt(*((const CKeyingMaterial*)&vchPlaintext), vchCiphertext);\n }\n \n-bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CSecret& vchPlaintext)\n+bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext)\n {\n     CCrypter cKeyCrypter;\n     std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);"
      },
      {
        "sha": "4134c1b49b61360d6d4d1517996ea4134c37848f",
        "filename": "src/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -101,7 +101,7 @@ class CCrypter\n     }\n };\n \n-bool EncryptSecret(CKeyingMaterial& vMasterKey, const CSecret &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext);\n-bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char> &vchCiphertext, const uint256& nIV, CSecret &vchPlaintext);\n+bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext);\n+bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext);\n \n #endif"
      },
      {
        "sha": "f73708199ac49ee6eb378b6ec9cfbe6d36bbafde",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 225,
        "deletions": 242,
        "changes": 467,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -2,13 +2,16 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <map>\n-\n #include <openssl/ecdsa.h>\n+#include <openssl/rand.h>\n #include <openssl/obj_mac.h>\n \n #include \"key.h\"\n \n+\n+// anonymous namespace with local implementation code (OpenSSL interaction)\n+namespace {\n+\n // Generate a private key from just the secret parameter\n int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n {\n@@ -120,293 +123,273 @@ int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned ch\n     return ret;\n }\n \n-void CKey::SetCompressedPubKey(bool fCompressed)\n-{\n-    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-    fCompressedPubKey = true;\n-}\n+// RAII Wrapper around OpenSSL's EC_KEY\n+class CECKey {\n+private:\n+    EC_KEY *pkey;\n \n-void CKey::Reset()\n-{\n-    fCompressedPubKey = false;\n-    if (pkey != NULL)\n+public:\n+    CECKey() {\n+        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+        assert(pkey != NULL);\n+    }\n+\n+    ~CECKey() {\n         EC_KEY_free(pkey);\n-    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    if (pkey == NULL)\n-        throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n-    fSet = false;\n-}\n+    }\n \n-CKey::CKey()\n-{\n-    pkey = NULL;\n-    Reset();\n-}\n+    void GetSecretBytes(unsigned char vch[32]) const {\n+        const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n+        assert(bn);\n+        int nBytes = BN_num_bytes(bn);\n+        int n=BN_bn2bin(bn,&vch[32 - nBytes]);\n+        assert(n == nBytes);\n+        memset(vch, 0, 32 - nBytes);\n+    }\n \n-CKey::CKey(const CKey& b)\n-{\n-    pkey = EC_KEY_dup(b.pkey);\n-    if (pkey == NULL)\n-        throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n-    fSet = b.fSet;\n-}\n+    void SetSecretBytes(const unsigned char vch[32]) {\n+        BIGNUM bn;\n+        BN_init(&bn);\n+        assert(BN_bin2bn(vch, 32, &bn));\n+        assert(EC_KEY_regenerate_key(pkey, &bn));\n+        BN_clear_free(&bn);\n+    }\n \n-CKey& CKey::operator=(const CKey& b)\n-{\n-    if (!EC_KEY_copy(pkey, b.pkey))\n-        throw key_error(\"CKey::operator=(const CKey&) : EC_KEY_copy failed\");\n-    fSet = b.fSet;\n-    return (*this);\n-}\n+    void GetPrivKey(CPrivKey &privkey) {\n+        int nSize = i2d_ECPrivateKey(pkey, NULL);\n+        assert(nSize);\n+        privkey.resize(nSize);\n+        unsigned char* pbegin = &privkey[0];\n+        int nSize2 = i2d_ECPrivateKey(pkey, &pbegin);\n+        assert(nSize == nSize2);\n+    }\n \n-CKey::~CKey()\n-{\n-    EC_KEY_free(pkey);\n-}\n+    bool SetPrivKey(const CPrivKey &privkey) {\n+        const unsigned char* pbegin = &privkey[0];\n+        if (d2i_ECPrivateKey(&pkey, &pbegin, privkey.size())) {\n+            // d2i_ECPrivateKey returns true if parsing succeeds.\n+            // This doesn't necessarily mean the key is valid.\n+            if (EC_KEY_check_key(pkey))\n+                return true;\n+        }\n+        return false;\n+    }\n \n-bool CKey::IsNull() const\n-{\n-    return !fSet;\n-}\n+    void GetPubKey(CPubKey &pubkey, bool fCompressed) {\n+        EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n+        int nSize = i2o_ECPublicKey(pkey, NULL);\n+        assert(nSize);\n+        assert(nSize <= 65);\n+        unsigned char c[65];\n+        unsigned char *pbegin = c;\n+        int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n+        assert(nSize == nSize2);\n+        pubkey.Set(&c[0], &c[nSize]);\n+    }\n \n-bool CKey::IsCompressed() const\n-{\n-    return fCompressedPubKey;\n-}\n+    bool SetPubKey(const CPubKey &pubkey) {\n+        const unsigned char* pbegin = pubkey.begin();\n+        return o2i_ECPublicKey(&pkey, &pbegin, pubkey.size());\n+    }\n \n-void CKey::MakeNewKey(bool fCompressed)\n-{\n-    if (!EC_KEY_generate_key(pkey))\n-        throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n-    if (fCompressed)\n-        SetCompressedPubKey();\n-    fSet = true;\n-}\n+    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) {\n+        unsigned int nSize = ECDSA_size(pkey);\n+        vchSig.resize(nSize); // Make sure it is big enough\n+        assert(ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], &nSize, pkey));\n+        vchSig.resize(nSize); // Shrink to fit actual size\n+        return true;\n+    }\n \n-bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n-{\n-    const unsigned char* pbegin = &vchPrivKey[0];\n-    if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n-    {\n-        // In testing, d2i_ECPrivateKey can return true\n-        // but fill in pkey with a key that fails\n-        // EC_KEY_check_key, so:\n-        if (EC_KEY_check_key(pkey))\n-        {\n-            fSet = true;\n-            return true;\n+    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n+        // -1 = error, 0 = bad sig, 1 = good\n+        if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n+            return false;\n+        return true;\n+    }\n+\n+    bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec) {\n+        bool fOk = false;\n+        ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n+        if (sig==NULL)\n+            return false;\n+        memset(p64, 0, 64);\n+        int nBitsR = BN_num_bits(sig->r);\n+        int nBitsS = BN_num_bits(sig->s);\n+        if (nBitsR <= 256 && nBitsS <= 256) {\n+            CPubKey pubkey;\n+            GetPubKey(pubkey, true);\n+            for (int i=0; i<4; i++) {\n+                CECKey keyRec;\n+                if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1) {\n+                    CPubKey pubkeyRec;\n+                    keyRec.GetPubKey(pubkeyRec, true);\n+                    if (pubkeyRec == pubkey) {\n+                        rec = i;\n+                        fOk = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            assert(fOk);\n+            BN_bn2bin(sig->r,&p64[32-(nBitsR+7)/8]);\n+            BN_bn2bin(sig->s,&p64[64-(nBitsS+7)/8]);\n         }\n+        ECDSA_SIG_free(sig);\n+        return fOk;\n     }\n-    // If vchPrivKey data is bad d2i_ECPrivateKey() can\n-    // leave pkey in a state where calling EC_KEY_free()\n-    // crashes. To avoid that, set pkey to NULL and\n-    // leak the memory (a leak is better than a crash)\n-    pkey = NULL;\n-    Reset();\n-    return false;\n-}\n \n-bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n-{\n-    EC_KEY_free(pkey);\n-    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    if (pkey == NULL)\n-        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n-    if (vchSecret.size() != 32)\n-        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n-    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n-    if (bn == NULL)\n-        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n-    if (!EC_KEY_regenerate_key(pkey,bn))\n+    // reconstruct public key from a compact signature\n+    // This is only slightly more CPU intensive than just verifying it.\n+    // If this function succeeds, the recovered public key is guaranteed to be valid\n+    // (the signature is a valid signature of the given data for that key)\n+    bool Recover(const uint256 &hash, const unsigned char *p64, int rec)\n     {\n-        BN_clear_free(bn);\n-        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n+        if (rec<0 || rec>=3)\n+            return false;\n+        ECDSA_SIG *sig = ECDSA_SIG_new();\n+        BN_bin2bn(&p64[0],  32, sig->r);\n+        BN_bin2bn(&p64[32], 32, sig->s);\n+        bool ret = ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), rec, 0) == 1;\n+        ECDSA_SIG_free(sig);\n+        return ret;\n+    }\n+};\n+\n+}; // end of anonymous namespace\n+\n+bool CKey::Check(const unsigned char *vch) {\n+    // Do not convert to OpenSSL's data structures for range-checking keys,\n+    // it's easy enough to do directly.\n+    static const unsigned char vchMax[32] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n+        0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n+        0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x40\n+    };\n+    bool fIsZero = true;\n+    for (int i=0; i<32 && fIsZero; i++)\n+        if (vch[i] != 0)\n+            fIsZero = false;\n+    if (fIsZero)\n+        return false;\n+    for (int i=0; i<32; i++) {\n+        if (vch[i] < vchMax[i])\n+            return true;\n+        if (vch[i] > vchMax[i])\n+            return false;\n     }\n-    BN_clear_free(bn);\n-    fSet = true;\n-    if (fCompressed || fCompressedPubKey)\n-        SetCompressedPubKey();\n     return true;\n }\n \n-CSecret CKey::GetSecret(bool &fCompressed) const\n-{\n-    CSecret vchRet;\n-    vchRet.resize(32);\n-    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n-    int nBytes = BN_num_bytes(bn);\n-    if (bn == NULL)\n-        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n-    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n-    if (n != nBytes)\n-        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n-    fCompressed = fCompressedPubKey;\n-    return vchRet;\n+void CKey::MakeNewKey(bool fCompressedIn) {\n+    do {\n+        RAND_bytes(vch, sizeof(vch));\n+    } while (!Check(vch));\n+    fValid = true;\n+    fCompressed = fCompressedIn;\n }\n \n-CPrivKey CKey::GetPrivKey() const\n-{\n-    int nSize = i2d_ECPrivateKey(pkey, NULL);\n-    if (!nSize)\n-        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n-    CPrivKey vchPrivKey(nSize, 0);\n-    unsigned char* pbegin = &vchPrivKey[0];\n-    if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n-        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n-    return vchPrivKey;\n+bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n+    CECKey key;\n+    if (!key.SetPrivKey(privkey))\n+        return false;\n+    key.GetSecretBytes(vch);\n+    fCompressed = fCompressedIn;\n+    fValid = true;\n+    return true;\n }\n \n-bool CKey::SetPubKey(const CPubKey& vchPubKey)\n-{\n-    const unsigned char* pbegin = vchPubKey.begin();\n-    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))\n-    {\n-        fSet = true;\n-        if (vchPubKey.size() == 33)\n-            SetCompressedPubKey();\n-        return true;\n-    }\n-    pkey = NULL;\n-    Reset();\n-    return false;\n+CPrivKey CKey::GetPrivKey() const {\n+    assert(fValid);\n+    CECKey key;\n+    key.SetSecretBytes(vch);\n+    CPrivKey privkey;\n+    key.GetPrivKey(privkey);\n+    return privkey;\n }\n \n-CPubKey CKey::GetPubKey() const\n-{\n-    int nSize = i2o_ECPublicKey(pkey, NULL);\n-    if (!nSize)\n-        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n-    assert(nSize <= 65);\n-    CPubKey ret;\n-    unsigned char *pbegin = ret.begin();\n-    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n-        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n-    assert((int)ret.size() == nSize);\n-    return ret;\n+CPubKey CKey::GetPubKey() const {\n+    assert(fValid);\n+    CECKey key;\n+    key.SetSecretBytes(vch);\n+    CPubKey pubkey;\n+    key.GetPubKey(pubkey, fCompressed);\n+    return pubkey;\n }\n \n-bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n-{\n-    unsigned int nSize = ECDSA_size(pkey);\n-    vchSig.resize(nSize); // Make sure it is big enough\n-    if (!ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], &nSize, pkey))\n-    {\n-        vchSig.clear();\n+bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+    if (!fValid)\n         return false;\n-    }\n-    vchSig.resize(nSize); // Shrink to fit actual size\n-    return true;\n+    CECKey key;\n+    key.SetSecretBytes(vch);\n+    return key.Sign(hash, vchSig);\n }\n \n-// create a compact signature (65 bytes), which allows reconstructing the used public key\n-// The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n-// The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n-//                  0x1D = second key with even y, 0x1E = second key with odd y\n-bool CKey::SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)\n-{\n-    bool fOk = false;\n-    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-    if (sig==NULL)\n+bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+    if (!fValid)\n         return false;\n-    vchSig.clear();\n-    vchSig.resize(65,0);\n-    int nBitsR = BN_num_bits(sig->r);\n-    int nBitsS = BN_num_bits(sig->s);\n-    if (nBitsR <= 256 && nBitsS <= 256)\n-    {\n-        int nRecId = -1;\n-        for (int i=0; i<4; i++)\n-        {\n-            CKey keyRec;\n-            keyRec.fSet = true;\n-            if (fCompressedPubKey)\n-                keyRec.SetCompressedPubKey();\n-            if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1)\n-                if (keyRec.GetPubKey() == this->GetPubKey())\n-                {\n-                    nRecId = i;\n-                    break;\n-                }\n-        }\n-\n-        if (nRecId == -1)\n-        {\n-            ECDSA_SIG_free(sig);\n-            throw key_error(\"CKey::SignCompact() : unable to construct recoverable key\");\n-        }\n+    CECKey key;\n+    key.SetSecretBytes(vch);\n+    vchSig.resize(65);\n+    int rec = -1;\n+    if (!key.SignCompact(hash, &vchSig[1], rec))\n+        return false;\n+    assert(rec != -1);\n+    vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n+    return true;\n+}\n \n-        vchSig[0] = nRecId+27+(fCompressedPubKey ? 4 : 0);\n-        BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);\n-        BN_bn2bin(sig->s,&vchSig[65-(nBitsS+7)/8]);\n-        fOk = true;\n-    }\n-    ECDSA_SIG_free(sig);\n-    return fOk;\n+bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n+    if (!IsValid())\n+        return false;\n+    CECKey key;\n+    if (!key.SetPubKey(*this))\n+        return false;\n+    if (!key.Verify(hash, vchSig))\n+        return false;\n+    return true;\n }\n \n-// reconstruct public key from a compact signature\n-// This is only slightly more CPU intensive than just verifying it.\n-// If this function succeeds, the recovered public key is guaranteed to be valid\n-// (the signature is a valid signature of the given data for that key)\n-bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n-{\n+bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n     if (vchSig.size() != 65)\n         return false;\n-    int nV = vchSig[0];\n-    if (nV<27 || nV>=35)\n+    CECKey key;\n+    if (!key.Recover(hash, &vchSig[1], (vchSig[0] - 27) & ~4))\n         return false;\n-    ECDSA_SIG *sig = ECDSA_SIG_new();\n-    BN_bin2bn(&vchSig[1],32,sig->r);\n-    BN_bin2bn(&vchSig[33],32,sig->s);\n-\n-    EC_KEY_free(pkey);\n-    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    if (nV >= 31)\n-    {\n-        SetCompressedPubKey();\n-        nV -= 4;\n-    }\n-    if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n-    {\n-        fSet = true;\n-        ECDSA_SIG_free(sig);\n-        return true;\n-    }\n-    ECDSA_SIG_free(sig);\n-    return false;\n+    key.GetPubKey(*this, (vchSig[0] - 27) & 4);\n+    return true;\n }\n \n-bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n-{\n-    // -1 = error, 0 = bad sig, 1 = good\n-    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n+bool CPubKey::VerifyCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n+    if (!IsValid())\n+        return false;\n+    if (vchSig.size() != 65)\n+        return false;\n+    CECKey key;\n+    if (!key.Recover(hash, &vchSig[1], (vchSig[0] - 27) & ~4))\n+        return false;\n+    CPubKey pubkeyRec;\n+    key.GetPubKey(pubkeyRec, IsCompressed());\n+    if (*this != pubkeyRec)\n         return false;\n-\n     return true;\n }\n \n-bool CKey::VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n-{\n-    CKey key;\n-    if (!key.SetCompactSignature(hash, vchSig))\n+bool CPubKey::IsFullyValid() const {\n+    if (!IsValid())\n         return false;\n-    if (GetPubKey() != key.GetPubKey())\n+    CECKey key;\n+    if (!key.SetPubKey(*this))\n         return false;\n-\n     return true;\n }\n \n-bool CKey::IsValid()\n-{\n-    if (!fSet)\n+bool CPubKey::Decompress() {\n+    if (!IsValid())\n         return false;\n-\n-    if (!EC_KEY_check_key(pkey))\n+    CECKey key;\n+    if (!key.SetPubKey(*this))\n         return false;\n-\n-    bool fCompr;\n-    CSecret secret = GetSecret(fCompr);\n-    CKey key2;\n-    key2.SetSecret(secret, fCompr);\n-    return GetPubKey() == key2.GetPubKey();\n+    key.GetPubKey(*this, false);\n+    return true;\n }"
      },
      {
        "sha": "b9ecd485705293ce99d879c7fc906339b422f724",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 131,
        "deletions": 92,
        "changes": 223,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -1,35 +1,17 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2012 The Bitcoin developers\n+// Copyright (c) 2009-2013 The Bitcoin developers\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #ifndef BITCOIN_KEY_H\n #define BITCOIN_KEY_H\n \n-#include <stdexcept>\n #include <vector>\n \n #include \"allocators.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"hash.h\"\n \n-#include <openssl/ec.h> // for EC_KEY definition\n-\n-// secp160k1\n-// const unsigned int PRIVATE_KEY_SIZE = 192;\n-// const unsigned int PUBLIC_KEY_SIZE  = 41;\n-// const unsigned int SIGNATURE_SIZE   = 48;\n-//\n-// secp192k1\n-// const unsigned int PRIVATE_KEY_SIZE = 222;\n-// const unsigned int PUBLIC_KEY_SIZE  = 49;\n-// const unsigned int SIGNATURE_SIZE   = 57;\n-//\n-// secp224k1\n-// const unsigned int PRIVATE_KEY_SIZE = 250;\n-// const unsigned int PUBLIC_KEY_SIZE  = 57;\n-// const unsigned int SIGNATURE_SIZE   = 66;\n-//\n // secp256k1:\n // const unsigned int PRIVATE_KEY_SIZE = 279;\n // const unsigned int PUBLIC_KEY_SIZE  = 65;\n@@ -38,12 +20,6 @@\n // see www.keylength.com\n // script supports up to 75 for single byte push\n \n-class key_error : public std::runtime_error\n-{\n-public:\n-    explicit key_error(const std::string& str) : std::runtime_error(str) {}\n-};\n-\n /** A reference to a CKey: the Hash160 of its serialized public key */\n class CKeyID : public uint160\n {\n@@ -63,8 +39,11 @@ class CScriptID : public uint160\n /** An encapsulated public key. */\n class CPubKey {\n private:\n+    // Just store the serialized data.\n+    // Its length can very cheaply be computed from the first byte.\n     unsigned char vch[65];\n \n+    // Compute the length of a pubkey with a given first byte.\n     unsigned int static GetLen(unsigned char chHeader) {\n         if (chHeader == 2 || chHeader == 3)\n             return 33;\n@@ -73,146 +52,206 @@ class CPubKey {\n         return 0;\n     }\n \n-    unsigned char *begin() {\n-        return vch;\n+    // Set this key data to be invalid\n+    void Invalidate() {\n+        vch[0] = 0xFF;\n     }\n \n-    friend class CKey;\n-\n public:\n-    CPubKey() { vch[0] = 0xFF; }\n-\n-    CPubKey(const std::vector<unsigned char> &vchPubKeyIn) {\n-        int len = vchPubKeyIn.empty() ? 0 : GetLen(vchPubKeyIn[0]);\n-        if (len) {\n-            memcpy(vch, &vchPubKeyIn[0], len);\n-        } else {\n-            vch[0] = 0xFF;\n-        }\n+    // Construct an invalid public key.\n+    CPubKey() {\n+        Invalidate();\n     }\n \n-    unsigned int size() const {\n-        return GetLen(vch[0]);\n+    // Initialize a public key using begin/end iterators to byte data.\n+    template<typename T>\n+    void Set(const T pbegin, const T pend) {\n+        int len = pend == pbegin ? 0 : GetLen(pbegin[0]);\n+        if (len && len == (pend-pbegin))\n+            memcpy(vch, (unsigned char*)&pbegin[0], len);\n+        else\n+            Invalidate();\n     }\n \n-    const unsigned char *begin() const {\n-        return vch;\n+    // Construct a public key using begin/end iterators to byte data.\n+    template<typename T>\n+    CPubKey(const T pbegin, const T pend) {\n+        Set(pbegin, pend);\n     }\n \n-    const unsigned char *end() const {\n-        return vch+size();\n+    // Construct a public key from a byte vector.\n+    CPubKey(const std::vector<unsigned char> &vch) {\n+        Set(vch.begin(), vch.end());\n     }\n \n-    friend bool operator==(const CPubKey &a, const CPubKey &b) { return memcmp(a.vch, b.vch, a.size()) == 0; }\n-    friend bool operator!=(const CPubKey &a, const CPubKey &b) { return memcmp(a.vch, b.vch, a.size()) != 0; }\n+    // Simply read-only vector-like interface to the pubkey data.\n+    unsigned int size() const { return GetLen(vch[0]); }\n+    const unsigned char *begin() const { return vch; }\n+    const unsigned char *end() const { return vch+size(); }\n+    const unsigned char &operator[](unsigned int pos) const { return vch[pos]; }\n+\n+    // Comparator implementation.\n+    friend bool operator==(const CPubKey &a, const CPubKey &b) {\n+        return a.vch[0] == b.vch[0] &&\n+               memcmp(a.vch, b.vch, a.size()) == 0;\n+    }\n+    friend bool operator!=(const CPubKey &a, const CPubKey &b) {\n+        return !(a == b);\n+    }\n     friend bool operator<(const CPubKey &a, const CPubKey &b) {\n         return a.vch[0] < b.vch[0] ||\n-               (a.vch[0] == b.vch[0] && memcmp(a.vch+1, b.vch+1, a.size() - 1) < 0);\n+               (a.vch[0] == b.vch[0] && memcmp(a.vch, b.vch, a.size()) < 0);\n     }\n \n+    // Implement serialization, as if this was a byte vector.\n     unsigned int GetSerializeSize(int nType, int nVersion) const {\n         return size() + 1;\n     }\n-\n     template<typename Stream> void Serialize(Stream &s, int nType, int nVersion) const {\n         unsigned int len = size();\n         ::Serialize(s, VARINT(len), nType, nVersion);\n         s.write((char*)vch, len);\n     }\n-\n     template<typename Stream> void Unserialize(Stream &s, int nType, int nVersion) {\n         unsigned int len;\n         ::Unserialize(s, VARINT(len), nType, nVersion);\n         if (len <= 65) {\n             s.read((char*)vch, len);\n         } else {\n-            // invalid pubkey\n-            vch[0] = 0xFF;\n+            // invalid pubkey, skip available data\n             char dummy;\n             while (len--)\n                 s.read(&dummy, 1);\n+            Invalidate();\n         }\n     }\n \n+    // Get the KeyID of this public key (hash of its serialization)\n     CKeyID GetID() const {\n         return CKeyID(Hash160(vch, vch+size()));\n     }\n \n+    // Get the 256-bit hash of this public key.\n     uint256 GetHash() const {\n         return Hash(vch, vch+size());\n     }\n \n+    // just check syntactic correctness.\n     bool IsValid() const {\n         return size() > 0;\n     }\n \n+    // fully validate whether this is a valid public key (more expensive than IsValid())\n+    bool IsFullyValid() const;\n+\n+    // Check whether this is a compressed public key.\n     bool IsCompressed() const {\n         return size() == 33;\n     }\n \n-    std::vector<unsigned char> Raw() const {\n-        return std::vector<unsigned char>(vch, vch+size());\n-    }\n+    // Verify a DER signature (~72 bytes).\n+    // If this public key is not fully valid, the return value will be false.\n+    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const;\n+\n+    // Verify a compact signature (~65 bytes).\n+    // See CKey::SignCompact.\n+    bool VerifyCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) const;\n+\n+    // Recover a public key from a compact signature.\n+    bool RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n+\n+    // Turn this public key into an uncompressed public key.\n+    bool Decompress();\n };\n \n \n // secure_allocator is defined in allocators.h\n // CPrivKey is a serialized private key, with all parameters included (279 bytes)\n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CPrivKey;\n-// CSecret is a serialization of just the secret parameter (32 bytes)\n-typedef std::vector<unsigned char, secure_allocator<unsigned char> > CSecret;\n \n-/** An encapsulated OpenSSL Elliptic Curve key (public and/or private) */\n-class CKey\n-{\n-protected:\n-    EC_KEY* pkey;\n-    bool fSet;\n-    bool fCompressedPubKey;\n+/** An encapsulated private key. */\n+class CKey {\n+private:\n+    // Whether this private key is valid. We check for correctness when modifying the key\n+    // data, so fValid should always correspond to the actual state.\n+    bool fValid;\n \n+    // Whether the public key corresponding to this private key is (to be) compressed.\n+    bool fCompressed;\n+\n+    // The actual byte data\n+    unsigned char vch[32];\n+\n+    // Check whether the 32-byte array pointed to be vch is valid keydata.\n+    bool static Check(const unsigned char *vch);\n public:\n-    void SetCompressedPubKey(bool fCompressed = true);\n \n-    void Reset();\n+    // Construct an invalid private key.\n+    CKey() : fValid(false) {\n+        LockObject(vch);\n+    }\n \n-    CKey();\n-    CKey(const CKey& b);\n+    // Copy constructor. This is necessary because of memlocking.\n+    CKey(const CKey &secret) : fValid(secret.fValid), fCompressed(secret.fCompressed) {\n+        LockObject(vch);\n+        memcpy(vch, secret.vch, sizeof(vch));\n+    }\n \n-    CKey& operator=(const CKey& b);\n+    // Destructor (again necessary because of memlocking).\n+    ~CKey() {\n+        UnlockObject(vch);\n+    }\n \n-    ~CKey();\n+    // Initialize using begin and end iterators to byte data.\n+    template<typename T>\n+    void Set(const T pbegin, const T pend, bool fCompressedIn) {\n+        if (pend - pbegin != 32) {\n+            fValid = false;\n+            return;\n+        }\n+        if (Check(&pbegin[0])) {\n+            memcpy(vch, (unsigned char*)&pbegin[0], 32);\n+            fValid = true;\n+            fCompressed = fCompressedIn;\n+        } else {\n+            fValid = false;\n+        }\n+    }\n+\n+    // Simple read-only vector-like interface.\n+    unsigned int size() const { return (fValid ? 32 : 0); }\n+    const unsigned char *begin() const { return vch; }\n+    const unsigned char *end() const { return vch + size(); }\n+\n+    // Check whether this private key is valid.\n+    bool IsValid() const { return fValid; }\n \n-    bool IsNull() const;\n-    bool IsCompressed() const;\n+    // Check whether the public key corresponding to this private key is (to be) compressed.\n+    bool IsCompressed() const { return fCompressed; }\n \n+    // Initialize from a CPrivKey (serialized OpenSSL private key data).\n+    bool SetPrivKey(const CPrivKey &vchPrivKey, bool fCompressed);\n+\n+    // Generate a new private key using a cryptographic PRNG.\n     void MakeNewKey(bool fCompressed);\n-    bool SetPrivKey(const CPrivKey& vchPrivKey);\n-    bool SetSecret(const CSecret& vchSecret, bool fCompressed = false);\n-    CSecret GetSecret(bool &fCompressed) const;\n+\n+    // Convert the private key to a CPrivKey (serialized OpenSSL private key data).\n+    // This is expensive.\n     CPrivKey GetPrivKey() const;\n-    bool SetPubKey(const CPubKey& vchPubKey);\n+\n+    // Compute the public key from a private key.\n+    // This is expensive.\n     CPubKey GetPubKey() const;\n \n-    bool Sign(uint256 hash, std::vector<unsigned char>& vchSig);\n+    // Create a DER-serialized signature.\n+    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const;\n \n-    // create a compact signature (65 bytes), which allows reconstructing the used public key\n+    // Create a compact signature (65 bytes), which allows reconstructing the used public key.\n     // The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n     // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n-    //                  0x1D = second key with even y, 0x1E = second key with odd y\n-    bool SignCompact(uint256 hash, std::vector<unsigned char>& vchSig);\n-\n-    // reconstruct public key from a compact signature\n-    // This is only slightly more CPU intensive than just verifying it.\n-    // If this function succeeds, the recovered public key is guaranteed to be valid\n-    // (the signature is a valid signature of the given data for that key)\n-    bool SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig);\n-\n-    bool Verify(uint256 hash, const std::vector<unsigned char>& vchSig);\n-\n-    // Verify a compact signature\n-    bool VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig);\n-\n-    bool IsValid();\n+    //                  0x1D = second key with even y, 0x1E = second key with odd y,\n+    //                  add 0x04 for compressed keys.\n+    bool SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const;\n };\n \n #endif"
      },
      {
        "sha": "808f8c24ef83bbf13b56d810aa1871233f4f1b72",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 51,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -15,61 +15,50 @@ bool CKeyStore::GetPubKey(const CKeyID &address, CPubKey &vchPubKeyOut) const\n     return true;\n }\n \n-bool CBasicKeyStore::AddKey(const CKey& key)\n+bool CKeyStore::AddKey(const CKey &key) {\n+    return AddKeyPubKey(key, key.GetPubKey());\n+}\n+\n+bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n {\n-    bool fCompressed = false;\n-    CSecret secret = key.GetSecret(fCompressed);\n-    {\n-        LOCK(cs_KeyStore);\n-        mapKeys[key.GetPubKey().GetID()] = make_pair(secret, fCompressed);\n-    }\n+    LOCK(cs_KeyStore);\n+    mapKeys[pubkey.GetID()] = key;\n     return true;\n }\n \n bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n {\n-    {\n-        LOCK(cs_KeyStore);\n-        mapScripts[redeemScript.GetID()] = redeemScript;\n-    }\n+    LOCK(cs_KeyStore);\n+    mapScripts[redeemScript.GetID()] = redeemScript;\n     return true;\n }\n \n bool CBasicKeyStore::HaveCScript(const CScriptID& hash) const\n {\n-    bool result;\n-    {\n-        LOCK(cs_KeyStore);\n-        result = (mapScripts.count(hash) > 0);\n-    }\n-    return result;\n+    LOCK(cs_KeyStore);\n+    return mapScripts.count(hash) > 0;\n }\n \n-\n bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n {\n+    LOCK(cs_KeyStore);\n+    ScriptMap::const_iterator mi = mapScripts.find(hash);\n+    if (mi != mapScripts.end())\n     {\n-        LOCK(cs_KeyStore);\n-        ScriptMap::const_iterator mi = mapScripts.find(hash);\n-        if (mi != mapScripts.end())\n-        {\n-            redeemScriptOut = (*mi).second;\n-            return true;\n-        }\n+        redeemScriptOut = (*mi).second;\n+        return true;\n     }\n     return false;\n }\n \n bool CCryptoKeyStore::SetCrypted()\n {\n-    {\n-        LOCK(cs_KeyStore);\n-        if (fUseCrypto)\n-            return true;\n-        if (!mapKeys.empty())\n-            return false;\n-        fUseCrypto = true;\n-    }\n+    LOCK(cs_KeyStore);\n+    if (fUseCrypto)\n+        return true;\n+    if (!mapKeys.empty())\n+        return false;\n+    fUseCrypto = true;\n     return true;\n }\n \n@@ -99,14 +88,13 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n         {\n             const CPubKey &vchPubKey = (*mi).second.first;\n             const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n-            CSecret vchSecret;\n+            CKeyingMaterial vchSecret;\n             if(!DecryptSecret(vMasterKeyIn, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n                 return false;\n             if (vchSecret.size() != 32)\n                 return false;\n             CKey key;\n-            key.SetPubKey(vchPubKey);\n-            key.SetSecret(vchSecret);\n+            key.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n             if (key.GetPubKey() == vchPubKey)\n                 break;\n             return false;\n@@ -117,23 +105,22 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n     return true;\n }\n \n-bool CCryptoKeyStore::AddKey(const CKey& key)\n+bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n {\n     {\n         LOCK(cs_KeyStore);\n         if (!IsCrypted())\n-            return CBasicKeyStore::AddKey(key);\n+            return CBasicKeyStore::AddKeyPubKey(key, pubkey);\n \n         if (IsLocked())\n             return false;\n \n         std::vector<unsigned char> vchCryptedSecret;\n-        CPubKey vchPubKey = key.GetPubKey();\n-        bool fCompressed;\n-        if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n+        CKeyingMaterial vchSecret(key.begin(), key.end());\n+        if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret))\n             return false;\n \n-        if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n+        if (!AddCryptedKey(pubkey, vchCryptedSecret))\n             return false;\n     }\n     return true;\n@@ -164,13 +151,12 @@ bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n         {\n             const CPubKey &vchPubKey = (*mi).second.first;\n             const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n-            CSecret vchSecret;\n+            CKeyingMaterial vchSecret;\n             if (!DecryptSecret(vMasterKey, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n                 return false;\n             if (vchSecret.size() != 32)\n                 return false;\n-            keyOut.SetPubKey(vchPubKey);\n-            keyOut.SetSecret(vchSecret);\n+            keyOut.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n             return true;\n         }\n     }\n@@ -204,13 +190,11 @@ bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n         fUseCrypto = true;\n         BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n         {\n-            CKey key;\n-            if (!key.SetSecret(mKey.second.first, mKey.second.second))\n-                return false;\n-            const CPubKey vchPubKey = key.GetPubKey();\n+            const CKey &key = mKey.second;\n+            CPubKey vchPubKey = key.GetPubKey();\n+            CKeyingMaterial vchSecret(key.begin(), key.end());\n             std::vector<unsigned char> vchCryptedSecret;\n-            bool fCompressed;\n-            if (!EncryptSecret(vMasterKeyIn, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n+            if (!EncryptSecret(vMasterKeyIn, vchSecret, vchPubKey.GetHash(), vchCryptedSecret))\n                 return false;\n             if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n                 return false;"
      },
      {
        "sha": "49a7bf569d50390f8592921d5be38e04c57bed73",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 6,
        "deletions": 15,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -21,7 +21,8 @@ class CKeyStore\n     virtual ~CKeyStore() {}\n \n     // Add a key to the store.\n-    virtual bool AddKey(const CKey& key) =0;\n+    virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) =0;\n+    virtual bool AddKey(const CKey &key);\n \n     // Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CKeyID &address) const =0;\n@@ -33,18 +34,9 @@ class CKeyStore\n     virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const CScriptID &hash) const =0;\n     virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n-\n-    virtual bool GetSecret(const CKeyID &address, CSecret& vchSecret, bool &fCompressed) const\n-    {\n-        CKey key;\n-        if (!GetKey(address, key))\n-            return false;\n-        vchSecret = key.GetSecret(fCompressed);\n-        return true;\n-    }\n };\n \n-typedef std::map<CKeyID, std::pair<CSecret, bool> > KeyMap;\n+typedef std::map<CKeyID, CKey> KeyMap;\n typedef std::map<CScriptID, CScript > ScriptMap;\n \n /** Basic key store, that keeps keys in an address->secret map */\n@@ -55,7 +47,7 @@ class CBasicKeyStore : public CKeyStore\n     ScriptMap mapScripts;\n \n public:\n-    bool AddKey(const CKey& key);\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     bool HaveKey(const CKeyID &address) const\n     {\n         bool result;\n@@ -85,8 +77,7 @@ class CBasicKeyStore : public CKeyStore\n             KeyMap::const_iterator mi = mapKeys.find(address);\n             if (mi != mapKeys.end())\n             {\n-                keyOut.Reset();\n-                keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n+                keyOut = mi->second;\n                 return true;\n             }\n         }\n@@ -146,7 +137,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool Lock();\n \n     virtual bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    bool AddKey(const CKey& key);\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     bool HaveKey(const CKeyID &address) const\n     {\n         {"
      },
      {
        "sha": "9118770f4c01d22f8ff487fbd21087f6ae854991",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -218,16 +218,16 @@ void SignVerifyMessageDialog::on_verifyMessageButton_VM_clicked()\n     ss << strMessageMagic;\n     ss << ui->messageIn_VM->document()->toPlainText().toStdString();\n \n-    CKey key;\n-    if (!key.SetCompactSignature(Hash(ss.begin(), ss.end()), vchSig))\n+    CPubKey pubkey;\n+    if (!pubkey.RecoverCompact(Hash(ss.begin(), ss.end()), vchSig))\n     {\n         ui->signatureIn_VM->setValid(false);\n         ui->statusLabel_VM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_VM->setText(tr(\"The signature did not match the message digest.\") + QString(\" \") + tr(\"Please check the signature and try again.\"));\n         return;\n     }\n \n-    if (!(CBitcoinAddress(key.GetPubKey().GetID()) == addr))\n+    if (!(CBitcoinAddress(pubkey.GetID()) == addr))\n     {\n         ui->statusLabel_VM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_VM->setText(QString(\"<nobr>\") + tr(\"Message verification failed.\") + QString(\"</nobr>\"));"
      },
      {
        "sha": "d46309eaa4ea314d5b2b49799efee16b374b6771",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -54,20 +54,18 @@ Value importprivkey(const Array& params, bool fHelp)\n \n     if (!fGood) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n \n-    CKey key;\n-    bool fCompressed;\n-    CSecret secret = vchSecret.GetSecret(fCompressed);\n-    key.SetSecret(secret, fCompressed);\n-    CKeyID vchAddress = key.GetPubKey().GetID();\n+    CKey key = vchSecret.GetKey();\n+    CPubKey pubkey = key.GetPubKey();\n+    CKeyID vchAddress = pubkey.GetID();\n     {\n         LOCK2(cs_main, pwalletMain->cs_wallet);\n \n         pwalletMain->MarkDirty();\n         pwalletMain->SetAddressBookName(vchAddress, strLabel);\n \n-        if (!pwalletMain->AddKey(key))\n+        if (!pwalletMain->AddKeyPubKey(key, pubkey))\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-\t\n+\n         if (fRescan) {\n             pwalletMain->ScanForWalletTransactions(pindexGenesisBlock, true);\n             pwalletMain->ReacceptWalletTransactions();\n@@ -91,9 +89,8 @@ Value dumpprivkey(const Array& params, bool fHelp)\n     CKeyID keyID;\n     if (!address.GetKeyID(keyID))\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n-    CSecret vchSecret;\n-    bool fCompressed;\n-    if (!pwalletMain->GetSecret(keyID, vchSecret, fCompressed))\n+    CKey vchSecret;\n+    if (!pwalletMain->GetKey(keyID, vchSecret))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n-    return CBitcoinSecret(vchSecret, fCompressed).ToString();\n+    return CBitcoinSecret(vchSecret).ToString();\n }"
      },
      {
        "sha": "c1e05466e5e55ac17b7dd627d4156deedb991d2e",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -407,10 +407,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             bool fGood = vchSecret.SetString(k.get_str());\n             if (!fGood)\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n-            CKey key;\n-            bool fCompressed;\n-            CSecret secret = vchSecret.GetSecret(fCompressed);\n-            key.SetSecret(secret, fCompressed);\n+            CKey key = vchSecret.GetKey();\n             tempKeystore.AddKey(key);\n         }\n     }"
      },
      {
        "sha": "89f094fa8b9e08563f27da59d1e1ad178a239f90",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -374,11 +374,11 @@ Value verifymessage(const Array& params, bool fHelp)\n     ss << strMessageMagic;\n     ss << strMessage;\n \n-    CKey key;\n-    if (!key.SetCompactSignature(ss.GetHash(), vchSig))\n+    CPubKey pubkey;\n+    if (!pubkey.RecoverCompact(ss.GetHash(), vchSig))\n         return false;\n \n-    return (key.GetPubKey().GetID() == keyID);\n+    return (pubkey.GetID() == keyID);\n }\n \n \n@@ -719,7 +719,7 @@ static CScript _createmultisig(const Array& params)\n         throw runtime_error(\n             strprintf(\"not enough keys supplied \"\n                       \"(got %\"PRIszu\" keys, but need at least %d to redeem)\", keys.size(), nRequired));\n-    std::vector<CKey> pubkeys;\n+    std::vector<CPubKey> pubkeys;\n     pubkeys.resize(keys.size());\n     for (unsigned int i = 0; i < keys.size(); i++)\n     {\n@@ -737,16 +737,18 @@ static CScript _createmultisig(const Array& params)\n             if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n                 throw runtime_error(\n                     strprintf(\"no full public key for address %s\",ks.c_str()));\n-            if (!vchPubKey.IsValid() || !pubkeys[i].SetPubKey(vchPubKey))\n+            if (!vchPubKey.IsFullyValid())\n                 throw runtime_error(\" Invalid public key: \"+ks);\n+            pubkeys[i] = vchPubKey;\n         }\n \n         // Case 2: hex public key\n         else if (IsHex(ks))\n         {\n             CPubKey vchPubKey(ParseHex(ks));\n-            if (!vchPubKey.IsValid() || !pubkeys[i].SetPubKey(vchPubKey))\n+            if (!vchPubKey.IsFullyValid())\n                 throw runtime_error(\" Invalid public key: \"+ks);\n+            pubkeys[i] = vchPubKey;\n         }\n         else\n         {"
      },
      {
        "sha": "2c7fd598747c6773377a25e801962ea2c802b802",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 21,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -1100,11 +1100,7 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n     if (signatureCache.Get(sighash, vchSig, vchPubKey))\n         return true;\n \n-    CKey key;\n-    if (!key.SetPubKey(vchPubKey))\n-        return false;\n-\n-    if (!key.Verify(sighash, vchSig))\n+    if (!CPubKey(vchPubKey).Verify(sighash, vchSig))\n         return false;\n \n     if (!(flags & SCRIPT_VERIFY_NOCACHE))\n@@ -1770,13 +1766,13 @@ void CScript::SetDestination(const CTxDestination& dest)\n     boost::apply_visitor(CScriptVisitor(this), dest);\n }\n \n-void CScript::SetMultisig(int nRequired, const std::vector<CKey>& keys)\n+void CScript::SetMultisig(int nRequired, const std::vector<CPubKey>& keys)\n {\n     this->clear();\n \n     *this << EncodeOP_N(nRequired);\n-    BOOST_FOREACH(const CKey& key, keys)\n-        *this << key.GetPubKey();\n+    BOOST_FOREACH(const CPubKey& key, keys)\n+        *this << key;\n     *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n }\n \n@@ -1801,20 +1797,17 @@ bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n     return false;\n }\n \n-bool CScriptCompressor::IsToPubKey(std::vector<unsigned char> &pubkey) const\n+bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n {\n     if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n                             && (script[1] == 0x02 || script[1] == 0x03)) {\n-        pubkey.resize(33);\n-        memcpy(&pubkey[0], &script[1], 33);\n+        pubkey.Set(&script[1], &script[34]);\n         return true;\n     }\n     if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n                             && script[1] == 0x04) {\n-        pubkey.resize(65);\n-        memcpy(&pubkey[0], &script[1], 65);\n-        CKey key;\n-        return (key.SetPubKey(CPubKey(pubkey))); // SetPubKey fails if this is not a valid public key, a case that would not be compressible\n+        pubkey.Set(&script[1], &script[66]);\n+        return pubkey.IsFullyValid(); // if not fully valid, a case that would not be compressible\n     }\n     return false;\n }\n@@ -1835,7 +1828,7 @@ bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n         memcpy(&out[1], &scriptID, 20);\n         return true;\n     }\n-    std::vector<unsigned char> pubkey;\n+    CPubKey pubkey;\n     if (IsToPubKey(pubkey)) {\n         out.resize(33);\n         memcpy(&out[1], &pubkey[1], 32);\n@@ -1888,14 +1881,12 @@ bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigne\n         return true;\n     case 0x04:\n     case 0x05:\n-        std::vector<unsigned char> vch(33, 0x00);\n+        unsigned char vch[33] = {};\n         vch[0] = nSize - 2;\n         memcpy(&vch[1], &in[0], 32);\n-        CKey key;\n-        if (!key.SetPubKey(CPubKey(vch)))\n+        CPubKey pubkey(&vch[0], &vch[33]);\n+        if (!pubkey.Decompress())\n             return false;\n-        key.SetCompressedPubKey(false); // Decompress public key\n-        const CPubKey pubkey = key.GetPubKey();\n         assert(pubkey.size() == 65);\n         script.resize(67);\n         script[0] = 65;"
      },
      {
        "sha": "3cbb2cf3222b284e5dd2d24da832e1ba6091eaef",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -550,7 +550,7 @@ class CScript : public std::vector<unsigned char>\n \n \n     void SetDestination(const CTxDestination& address);\n-    void SetMultisig(int nRequired, const std::vector<CKey>& keys);\n+    void SetMultisig(int nRequired, const std::vector<CPubKey>& keys);\n \n \n     void PrintHex() const\n@@ -621,7 +621,7 @@ class CScriptCompressor\n     // form).\n     bool IsToKeyID(CKeyID &hash) const;\n     bool IsToScriptID(CScriptID &hash) const;\n-    bool IsToPubKey(std::vector<unsigned char> &pubkey) const;\n+    bool IsToPubKey(CPubKey &pubkey) const;\n \n     bool Compress(std::vector<unsigned char> &out) const;\n     unsigned int GetSpecialSize(unsigned int nSize) const;"
      },
      {
        "sha": "2741672a88c1ca74373157300adb2d00c816a23f",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -133,9 +133,8 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n             // Note: CBitcoinSecret::SetString tests isValid, whereas CBitcoinAddress does not!\n             BOOST_CHECK_MESSAGE(secret.SetString(exp_base58string), \"!SetString:\"+ strTest);\n             BOOST_CHECK_MESSAGE(secret.IsValid(), \"!IsValid:\" + strTest);\n-            bool fCompressedOut = false;\n-            CSecret privkey = secret.GetSecret(fCompressedOut);\n-            BOOST_CHECK_MESSAGE(fCompressedOut == isCompressed, \"compressed mismatch:\" + strTest);\n+            CKey privkey = secret.GetKey();\n+            BOOST_CHECK_MESSAGE(privkey.IsCompressed() == isCompressed, \"compressed mismatch:\" + strTest);\n             BOOST_CHECK_MESSAGE(privkey.size() == exp_payload.size() && std::equal(privkey.begin(), privkey.end(), exp_payload.begin()), \"key mismatch:\" + strTest);\n \n             // Private key must be invalid public key\n@@ -187,8 +186,11 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n         if(isPrivkey)\n         {\n             bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n+            CKey key;\n+            key.Set(exp_payload.begin(), exp_payload.end(), isCompressed);\n+            assert(key.IsValid());\n             CBitcoinSecret secret;\n-            secret.SetSecret(CSecret(exp_payload.begin(), exp_payload.end()), isCompressed);\n+            secret.SetKey(key);\n             BOOST_CHECK_MESSAGE(secret.ToString() == exp_base58string, \"result mismatch: \" + strTest);\n         }\n         else"
      },
      {
        "sha": "0d349a990c1ac29e7f2b76a95aad60f46e0bebd6",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -73,14 +73,13 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n     CBitcoinSecret vchSecret;\n     BOOST_CHECK(vchSecret.SetString(strSecret));\n \n-    CKey key;\n-    bool fCompressed;\n-    CSecret secret = vchSecret.GetSecret(fCompressed);\n-    key.SetSecret(secret, fCompressed);\n+    CKey key = vchSecret.GetKey();\n+    CPubKey pubkey = key.GetPubKey();\n+    vector<unsigned char> vchPubKey(pubkey.begin(), pubkey.end());\n \n     CBloomFilter filter(2, 0.001, 0, BLOOM_UPDATE_ALL);\n-    filter.insert(key.GetPubKey().Raw());\n-    uint160 hash = key.GetPubKey().GetID();\n+    filter.insert(vchPubKey);\n+    uint160 hash = pubkey.GetID();\n     filter.insert(vector<unsigned char>(hash.begin(), hash.end()));\n \n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "c004521d1a24b618f0b7f5acf4cdb0a61604bfec",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 51,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -26,8 +26,8 @@ static const string strAddressBad(\"1HV9Lc3sNHZxwj4Zk6fB38tEmBryq2cBiF\");\n #ifdef KEY_TESTS_DUMPINFO\n void dumpKeyInfo(uint256 privkey)\n {\n-    CSecret secret;\n-    secret.resize(32);\n+    CKey key;\n+    key.resize(32);\n     memcpy(&secret[0], &privkey, 32);\n     vector<unsigned char> sec;\n     sec.resize(32);\n@@ -62,29 +62,24 @@ BOOST_AUTO_TEST_CASE(key_test1)\n     BOOST_CHECK( bsecret2C.SetString(strSecret2C));\n     BOOST_CHECK(!baddress1.SetString(strAddressBad));\n \n-    bool fCompressed;\n-    CSecret secret1  = bsecret1.GetSecret (fCompressed);\n-    BOOST_CHECK(fCompressed == false);\n-    CSecret secret2  = bsecret2.GetSecret (fCompressed);\n-    BOOST_CHECK(fCompressed == false);\n-    CSecret secret1C = bsecret1C.GetSecret(fCompressed);\n-    BOOST_CHECK(fCompressed == true);\n-    CSecret secret2C = bsecret2C.GetSecret(fCompressed);\n-    BOOST_CHECK(fCompressed == true);\n-\n-    BOOST_CHECK(secret1 == secret1C);\n-    BOOST_CHECK(secret2 == secret2C);\n-\n-    CKey key1, key2, key1C, key2C;\n-    key1.SetSecret(secret1, false);\n-    key2.SetSecret(secret2, false);\n-    key1C.SetSecret(secret1, true);\n-    key2C.SetSecret(secret2, true);\n-\n-    BOOST_CHECK(addr1.Get()  == CTxDestination(key1.GetPubKey().GetID()));\n-    BOOST_CHECK(addr2.Get()  == CTxDestination(key2.GetPubKey().GetID()));\n-    BOOST_CHECK(addr1C.Get() == CTxDestination(key1C.GetPubKey().GetID()));\n-    BOOST_CHECK(addr2C.Get() == CTxDestination(key2C.GetPubKey().GetID()));\n+    CKey key1  = bsecret1.GetKey();\n+    BOOST_CHECK(key1.IsCompressed() == false);\n+    CKey key2  = bsecret2.GetKey();\n+    BOOST_CHECK(key2.IsCompressed() == false);\n+    CKey key1C = bsecret1C.GetKey();\n+    BOOST_CHECK(key1C.IsCompressed() == true);\n+    CKey key2C = bsecret2C.GetKey();\n+    BOOST_CHECK(key1C.IsCompressed() == true);\n+\n+    CPubKey pubkey1  = key1. GetPubKey();\n+    CPubKey pubkey2  = key2. GetPubKey();\n+    CPubKey pubkey1C = key1C.GetPubKey();\n+    CPubKey pubkey2C = key2C.GetPubKey();\n+\n+    BOOST_CHECK(addr1.Get()  == CTxDestination(pubkey1.GetID()));\n+    BOOST_CHECK(addr2.Get()  == CTxDestination(pubkey2.GetID()));\n+    BOOST_CHECK(addr1C.Get() == CTxDestination(pubkey1C.GetID()));\n+    BOOST_CHECK(addr2C.Get() == CTxDestination(pubkey2C.GetID()));\n \n     for (int n=0; n<16; n++)\n     {\n@@ -100,25 +95,25 @@ BOOST_AUTO_TEST_CASE(key_test1)\n         BOOST_CHECK(key1C.Sign(hashMsg, sign1C));\n         BOOST_CHECK(key2C.Sign(hashMsg, sign2C));\n \n-        BOOST_CHECK( key1.Verify(hashMsg, sign1));\n-        BOOST_CHECK(!key1.Verify(hashMsg, sign2));\n-        BOOST_CHECK( key1.Verify(hashMsg, sign1C));\n-        BOOST_CHECK(!key1.Verify(hashMsg, sign2C));\n+        BOOST_CHECK( pubkey1.Verify(hashMsg, sign1));\n+        BOOST_CHECK(!pubkey1.Verify(hashMsg, sign2));\n+        BOOST_CHECK( pubkey1.Verify(hashMsg, sign1C));\n+        BOOST_CHECK(!pubkey1.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK(!key2.Verify(hashMsg, sign1));\n-        BOOST_CHECK( key2.Verify(hashMsg, sign2));\n-        BOOST_CHECK(!key2.Verify(hashMsg, sign1C));\n-        BOOST_CHECK( key2.Verify(hashMsg, sign2C));\n+        BOOST_CHECK(!pubkey2.Verify(hashMsg, sign1));\n+        BOOST_CHECK( pubkey2.Verify(hashMsg, sign2));\n+        BOOST_CHECK(!pubkey2.Verify(hashMsg, sign1C));\n+        BOOST_CHECK( pubkey2.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK( key1C.Verify(hashMsg, sign1));\n-        BOOST_CHECK(!key1C.Verify(hashMsg, sign2));\n-        BOOST_CHECK( key1C.Verify(hashMsg, sign1C));\n-        BOOST_CHECK(!key1C.Verify(hashMsg, sign2C));\n+        BOOST_CHECK( pubkey1C.Verify(hashMsg, sign1));\n+        BOOST_CHECK(!pubkey1C.Verify(hashMsg, sign2));\n+        BOOST_CHECK( pubkey1C.Verify(hashMsg, sign1C));\n+        BOOST_CHECK(!pubkey1C.Verify(hashMsg, sign2C));\n \n-        BOOST_CHECK(!key2C.Verify(hashMsg, sign1));\n-        BOOST_CHECK( key2C.Verify(hashMsg, sign2));\n-        BOOST_CHECK(!key2C.Verify(hashMsg, sign1C));\n-        BOOST_CHECK( key2C.Verify(hashMsg, sign2C));\n+        BOOST_CHECK(!pubkey2C.Verify(hashMsg, sign1));\n+        BOOST_CHECK( pubkey2C.Verify(hashMsg, sign2));\n+        BOOST_CHECK(!pubkey2C.Verify(hashMsg, sign1C));\n+        BOOST_CHECK( pubkey2C.Verify(hashMsg, sign2C));\n \n         // compact signatures (with key recovery)\n \n@@ -129,18 +124,17 @@ BOOST_AUTO_TEST_CASE(key_test1)\n         BOOST_CHECK(key1C.SignCompact(hashMsg, csign1C));\n         BOOST_CHECK(key2C.SignCompact(hashMsg, csign2C));\n \n-        CKey rkey1, rkey2, rkey1C, rkey2C;\n+        CPubKey rkey1, rkey2, rkey1C, rkey2C;\n \n-        BOOST_CHECK(rkey1.SetCompactSignature (hashMsg, csign1));\n-        BOOST_CHECK(rkey2.SetCompactSignature (hashMsg, csign2));\n-        BOOST_CHECK(rkey1C.SetCompactSignature(hashMsg, csign1C));\n-        BOOST_CHECK(rkey2C.SetCompactSignature(hashMsg, csign2C));\n+        BOOST_CHECK(rkey1.RecoverCompact (hashMsg, csign1));\n+        BOOST_CHECK(rkey2.RecoverCompact (hashMsg, csign2));\n+        BOOST_CHECK(rkey1C.RecoverCompact(hashMsg, csign1C));\n+        BOOST_CHECK(rkey2C.RecoverCompact(hashMsg, csign2C));\n \n-\n-        BOOST_CHECK(rkey1.GetPubKey()  == key1.GetPubKey());\n-        BOOST_CHECK(rkey2.GetPubKey()  == key2.GetPubKey());\n-        BOOST_CHECK(rkey1C.GetPubKey() == key1C.GetPubKey());\n-        BOOST_CHECK(rkey2C.GetPubKey() == key2C.GetPubKey());\n+        BOOST_CHECK(rkey1  == pubkey1);\n+        BOOST_CHECK(rkey2  == pubkey2);\n+        BOOST_CHECK(rkey1C == pubkey1C);\n+        BOOST_CHECK(rkey2C == pubkey2C);\n     }\n }\n "
      },
      {
        "sha": "9ef932b5b444a5dea4ef2e4d2fa2ec990b06478b",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -30,7 +30,7 @@ sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction,\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround\n-    BOOST_FOREACH(CKey key, keys)\n+    BOOST_FOREACH(const CKey &key, keys)\n     {\n         vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));"
      },
      {
        "sha": "65f0ad0cdcb06517a745e54fb2246815e34d37e1",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -145,19 +145,19 @@ BOOST_AUTO_TEST_CASE(set)\n     // Test the CScript::Set* methods\n     CBasicKeyStore keystore;\n     CKey key[4];\n-    std::vector<CKey> keys;\n+    std::vector<CPubKey> keys;\n     for (int i = 0; i < 4; i++)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n-        keys.push_back(key[i]);\n+        keys.push_back(key[i].GetPubKey());\n     }\n \n     CScript inner[4];\n     inner[0].SetDestination(key[0].GetPubKey().GetID());\n-    inner[1].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+2));\n-    inner[2].SetMultisig(1, std::vector<CKey>(keys.begin(), keys.begin()+2));\n-    inner[3].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+3));\n+    inner[1].SetMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\n+    inner[2].SetMultisig(1, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\n+    inner[3].SetMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+3));\n \n     CScript outer[4];\n     for (int i = 0; i < 4; i++)\n@@ -248,12 +248,12 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     CCoinsViewCache coins(coinsDummy);\n     CBasicKeyStore keystore;\n     CKey key[3];\n-    vector<CKey> keys;\n+    vector<CPubKey> keys;\n     for (int i = 0; i < 3; i++)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n-        keys.push_back(key[i]);\n+        keys.push_back(key[i].GetPubKey());\n     }\n \n     CTransaction txFrom;"
      },
      {
        "sha": "e7ad52627c0883981a489ef1e9e424eaa1c9a0b1",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -211,7 +211,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     // and vice-versa)\n     //\n     result << OP_0;\n-    BOOST_FOREACH(CKey key, keys)\n+    BOOST_FOREACH(const CKey &key, keys)\n     {\n         vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));\n@@ -221,7 +221,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     return result;\n }\n CScript\n-sign_multisig(CScript scriptPubKey, CKey key, CTransaction transaction)\n+sign_multisig(CScript scriptPubKey, const CKey &key, CTransaction transaction)\n {\n     std::vector<CKey> keys;\n     keys.push_back(key);\n@@ -333,11 +333,13 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     // Test the CombineSignatures function\n     CBasicKeyStore keystore;\n     vector<CKey> keys;\n+    vector<CPubKey> pubkeys;\n     for (int i = 0; i < 3; i++)\n     {\n         CKey key;\n         key.MakeNewKey(i%2 == 1);\n         keys.push_back(key);\n+        pubkeys.push_back(key.GetPubKey());\n         keystore.AddKey(key);\n     }\n \n@@ -390,7 +392,7 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     BOOST_CHECK(combined == scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n-    scriptPubKey.SetMultisig(2, keys);\n+    scriptPubKey.SetMultisig(2, pubkeys);\n     keystore.AddCScript(scriptPubKey);\n     SignSignature(keystore, txFrom, txTo, 0);\n     combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);"
      },
      {
        "sha": "5a87f176000316782068e0e34ae78c4b6f47d1c1",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -37,12 +37,12 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n     scriptSig << OP_0 << Serialize(s1);\n     BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig), 3U);\n \n-    std::vector<CKey> keys;\n+    std::vector<CPubKey> keys;\n     for (int i = 0; i < 3; i++)\n     {\n         CKey k;\n         k.MakeNewKey(true);\n-        keys.push_back(k);\n+        keys.push_back(k.GetPubKey());\n     }\n     CScript s2;\n     s2.SetMultisig(1, keys);"
      },
      {
        "sha": "5efc4558398779749b7e2c3a6f69c6c977a3777d",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -32,26 +32,28 @@ CPubKey CWallet::GenerateNewKey()\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     RandAddSeedPerfmon();\n-    CKey key;\n-    key.MakeNewKey(fCompressed);\n+    CKey secret;\n+    secret.MakeNewKey(fCompressed);\n \n     // Compressed public keys were introduced in version 0.6.0\n     if (fCompressed)\n         SetMinVersion(FEATURE_COMPRPUBKEY);\n \n-    if (!AddKey(key))\n+    CPubKey pubkey = secret.GetPubKey();\n+    if (!AddKeyPubKey(secret, pubkey))\n         throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n-    return key.GetPubKey();\n+    return pubkey;\n }\n \n-bool CWallet::AddKey(const CKey& key)\n+bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n {\n-    if (!CCryptoKeyStore::AddKey(key))\n+    if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))\n         return false;\n     if (!fFileBacked)\n         return true;\n-    if (!IsCrypted())\n-        return CWalletDB(strWalletFile).WriteKey(key.GetPubKey(), key.GetPrivKey());\n+    if (!IsCrypted()) {\n+        return CWalletDB(strWalletFile).WriteKey(pubkey, secret.GetPrivKey());\n+    }\n     return true;\n }\n "
      },
      {
        "sha": "7fcb8e13cef04fce2c3efd3604dc7cba9ef79a77",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -136,9 +136,9 @@ class CWallet : public CCryptoKeyStore\n     // Generate a new key\n     CPubKey GenerateNewKey();\n     // Adds a key to the store, and saves it to disk.\n-    bool AddKey(const CKey& key);\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     // Adds a key to the store, without saving it to disk (used by LoadWallet)\n-    bool LoadKey(const CKey& key) { return CCryptoKeyStore::AddKey(key); }\n+    bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n \n     bool LoadMinVersion(int nVersion) { nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n "
      },
      {
        "sha": "4a73413d264d3d439dd77a40794c4ea829adfffb",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 39,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -262,52 +262,33 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         }\n         else if (strType == \"key\" || strType == \"wkey\")\n         {\n-            vector<unsigned char> vchPubKey;\n+            CPubKey vchPubKey;\n             ssKey >> vchPubKey;\n+            if (!vchPubKey.IsValid())\n+            {\n+                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                return false;\n+            }\n             CKey key;\n+            CPrivKey pkey;\n             if (strType == \"key\")\n-            {\n-                CPrivKey pkey;\n                 ssValue >> pkey;\n-                key.SetPubKey(vchPubKey);\n-                if (!key.SetPrivKey(pkey))\n-                {\n-                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                    return false;\n-                }\n-                if (key.GetPubKey() != vchPubKey)\n-                {\n-                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n-                    return false;\n-                }\n-                if (!key.IsValid())\n-                {\n-                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n-                    return false;\n-                }\n-            }\n-            else\n-            {\n+            else {\n                 CWalletKey wkey;\n                 ssValue >> wkey;\n-                key.SetPubKey(vchPubKey);\n-                if (!key.SetPrivKey(wkey.vchPrivKey))\n-                {\n-                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n-                    return false;\n-                }\n-                if (key.GetPubKey() != vchPubKey)\n-                {\n-                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n-                    return false;\n-                }\n-                if (!key.IsValid())\n-                {\n-                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n-                    return false;\n-                }\n+                pkey = wkey.vchPrivKey;\n+            }\n+            if (!key.SetPrivKey(pkey, vchPubKey.IsCompressed()))\n+            {\n+                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+                return false;\n+            }\n+            if (key.GetPubKey() != vchPubKey)\n+            {\n+                strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n+                return false;\n             }\n-            if (!pwallet->LoadKey(key))\n+            if (!pwallet->LoadKey(key, vchPubKey))\n             {\n                 strErr = \"Error reading wallet database: LoadKey failed\";\n                 return false;"
      },
      {
        "sha": "8ae6c3ff4966832f3417e21e9ad49b73351be925",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfa23b94c24aae6466152fccbe896ba5dc0e97b4/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "patch": "@@ -53,18 +53,18 @@ class CWalletDB : public CDB\n     bool WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey)\n     {\n         nWalletDBUpdated++;\n-        return Write(std::make_pair(std::string(\"key\"), vchPubKey.Raw()), vchPrivKey, false);\n+        return Write(std::make_pair(std::string(\"key\"), vchPubKey), vchPrivKey, false);\n     }\n \n     bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, bool fEraseUnencryptedKey = true)\n     {\n         nWalletDBUpdated++;\n-        if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey.Raw()), vchCryptedSecret, false))\n+        if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false))\n             return false;\n         if (fEraseUnencryptedKey)\n         {\n-            Erase(std::make_pair(std::string(\"key\"), vchPubKey.Raw()));\n-            Erase(std::make_pair(std::string(\"wkey\"), vchPubKey.Raw()));\n+            Erase(std::make_pair(std::string(\"key\"), vchPubKey));\n+            Erase(std::make_pair(std::string(\"wkey\"), vchPubKey));\n         }\n         return true;\n     }\n@@ -101,7 +101,7 @@ class CWalletDB : public CDB\n     bool WriteDefaultKey(const CPubKey& vchPubKey)\n     {\n         nWalletDBUpdated++;\n-        return Write(std::string(\"defaultkey\"), vchPubKey.Raw());\n+        return Write(std::string(\"defaultkey\"), vchPubKey);\n     }\n \n     bool ReadPool(int64 nPool, CKeyPool& keypool)"
      }
    ]
  },
  {
    "sha": "896185d7ed3fa23415424c608f0897d6139640f4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTYxODVkN2VkM2ZhMjM0MTU0MjRjNjA4ZjA4OTdkNjEzOTY0MGY0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-05-04T14:10:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2013-05-30T03:20:23Z"
      },
      "message": "Make signature cache store CPubKeys",
      "tree": {
        "sha": "818fdef522d74587e8b85d2f60e3682b47a18b73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/818fdef522d74587e8b85d2f60e3682b47a18b73"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/896185d7ed3fa23415424c608f0897d6139640f4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/896185d7ed3fa23415424c608f0897d6139640f4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/896185d7ed3fa23415424c608f0897d6139640f4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/896185d7ed3fa23415424c608f0897d6139640f4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfa23b94c24aae6466152fccbe896ba5dc0e97b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dfa23b94c24aae6466152fccbe896ba5dc0e97b4"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 19,
      "deletions": 12
    },
    "files": [
      {
        "sha": "85af8fe376c57b075d35fdc227b1ee45293d0e93",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/896185d7ed3fa23415424c608f0897d6139640f4/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/896185d7ed3fa23415424c608f0897d6139640f4/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=896185d7ed3fa23415424c608f0897d6139640f4",
        "patch": "@@ -176,6 +176,10 @@ class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n     {}\n };\n \n+//\n+// Functions for directly locking/unlocking memory objects.\n+// Intended for non-dynamically allocated structures.\n+//\n template<typename T> void LockObject(const T &t) {\n     LockedPageManager::instance.LockRange((void*)(&t), sizeof(T));\n }"
      },
      {
        "sha": "ce469ad298e792f9ee457df90b8f517e6da52cb0",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/896185d7ed3fa23415424c608f0897d6139640f4/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/896185d7ed3fa23415424c608f0897d6139640f4/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=896185d7ed3fa23415424c608f0897d6139640f4",
        "patch": "@@ -84,7 +84,7 @@ class CPubKey {\n         Set(vch.begin(), vch.end());\n     }\n \n-    // Simply read-only vector-like interface to the pubkey data.\n+    // Simple read-only vector-like interface to the pubkey data.\n     unsigned int size() const { return GetLen(vch[0]); }\n     const unsigned char *begin() const { return vch; }\n     const unsigned char *end() const { return vch+size(); }\n@@ -109,12 +109,11 @@ class CPubKey {\n     }\n     template<typename Stream> void Serialize(Stream &s, int nType, int nVersion) const {\n         unsigned int len = size();\n-        ::Serialize(s, VARINT(len), nType, nVersion);\n+        ::WriteCompactSize(s, len);\n         s.write((char*)vch, len);\n     }\n     template<typename Stream> void Unserialize(Stream &s, int nType, int nVersion) {\n-        unsigned int len;\n-        ::Unserialize(s, VARINT(len), nType, nVersion);\n+        unsigned int len = ::ReadCompactSize(s);\n         if (len <= 65) {\n             s.read((char*)vch, len);\n         } else {"
      },
      {
        "sha": "b411666353d176ec7517931f23404142bd454638",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/896185d7ed3fa23415424c608f0897d6139640f4/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/896185d7ed3fa23415424c608f0897d6139640f4/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=896185d7ed3fa23415424c608f0897d6139640f4",
        "patch": "@@ -16,7 +16,7 @@ using namespace boost;\n #include \"sync.h\"\n #include \"util.h\"\n \n-bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags);\n+bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, int flags);\n \n \n \n@@ -1033,13 +1033,13 @@ class CSignatureCache\n {\n private:\n      // sigdata_type is (signature hash, signature, public key):\n-    typedef boost::tuple<uint256, std::vector<unsigned char>, std::vector<unsigned char> > sigdata_type;\n+    typedef boost::tuple<uint256, std::vector<unsigned char>, CPubKey> sigdata_type;\n     std::set< sigdata_type> setValid;\n     boost::shared_mutex cs_sigcache;\n \n public:\n     bool\n-    Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n+    Get(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n     {\n         boost::shared_lock<boost::shared_mutex> lock(cs_sigcache);\n \n@@ -1050,7 +1050,7 @@ class CSignatureCache\n         return false;\n     }\n \n-    void Set(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n+    void Set(const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubKey)\n     {\n         // DoS prevention: limit cache size to less than 10MB\n         // (~200 bytes per cache entry times 50,000 entries)\n@@ -1081,11 +1081,15 @@ class CSignatureCache\n     }\n };\n \n-bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n+bool CheckSig(vector<unsigned char> vchSig, const vector<unsigned char> &vchPubKey, const CScript &scriptCode,\n               const CTransaction& txTo, unsigned int nIn, int nHashType, int flags)\n {\n     static CSignatureCache signatureCache;\n \n+    CPubKey pubkey(vchPubKey);\n+    if (!pubkey.IsValid())\n+        return false;\n+\n     // Hash type is one byte tacked on to the end of the signature\n     if (vchSig.empty())\n         return false;\n@@ -1097,14 +1101,14 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n \n     uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n \n-    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n+    if (signatureCache.Get(sighash, vchSig, pubkey))\n         return true;\n \n-    if (!CPubKey(vchPubKey).Verify(sighash, vchSig))\n+    if (!pubkey.Verify(sighash, vchSig))\n         return false;\n \n     if (!(flags & SCRIPT_VERIFY_NOCACHE))\n-        signatureCache.Set(sighash, vchSig, vchPubKey);\n+        signatureCache.Set(sighash, vchSig, pubkey);\n \n     return true;\n }"
      }
    ]
  }
]