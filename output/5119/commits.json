[
  {
    "sha": "fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTczNjE5MDdhMGE1ZDY2OThiYjdlOGU0NWZhNWFjMDM0YjgxMDY2",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-10-22T19:08:30Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-10-22T19:21:06Z"
      },
      "message": "boost: split stream classes out of serialize.h\n\nserialization now has no dependencies.",
      "tree": {
        "sha": "ab9b6037f55bde2a5f6b9a9bb695fc512d055543",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab9b6037f55bde2a5f6b9a9bb695fc512d055543"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25cc1cf8dc03b9ba0ae886d354855adc207b5b6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25cc1cf8dc03b9ba0ae886d354855adc207b5b6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25cc1cf8dc03b9ba0ae886d354855adc207b5b6e"
      }
    ],
    "stats": {
      "total": 1142,
      "additions": 589,
      "deletions": 553
    },
    "files": [
      {
        "sha": "77443686db180a980065d7401e1f438245f8fb27",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -107,6 +107,7 @@ BITCOIN_CORE_H = \\\n   script/sign.h \\\n   script/standard.h \\\n   serialize.h \\\n+  streams.h \\\n   sync.h \\\n   threadsafety.h \\\n   timedata.h \\"
      },
      {
        "sha": "3c6f8d9e7216d75f06469458d97dd36b37c6413e",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -6,6 +6,7 @@\n \n #include \"hash.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n \n using namespace std;\n "
      },
      {
        "sha": "78a3b76d0cd9adf291a0d9c0fcd334b6826e0ea2",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -9,6 +9,7 @@\n #include <map>\n #include <string>\n #include <string.h>\n+#include <vector>\n \n #include <boost/thread/mutex.hpp>\n #include <boost/thread/once.hpp>\n@@ -261,4 +262,7 @@ struct zero_after_free_allocator : public std::allocator<T> {\n // This is exactly like std::string, but with a custom allocator.\n typedef std::basic_string<char, std::char_traits<char>, secure_allocator<char> > SecureString;\n \n+// Byte-vector that clears its contents before deletion.\n+typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;\n+\n #endif // BITCOIN_ALLOCATORS_H"
      },
      {
        "sha": "cac71fdbbf799de5795ecbd57d0df8e3f5307c05",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -7,6 +7,7 @@\n #include \"core.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n+#include \"streams.h\"\n \n #include <math.h>\n #include <stdlib.h>"
      },
      {
        "sha": "dcbcf4b4f74b58ff480b835e08eeb9bbc3466aa3",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -7,6 +7,7 @@\n #include \"core.h\"\n #include \"script/script.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"univalue/univalue.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\""
      },
      {
        "sha": "b2b29fb367aff92f48c14e4853fa8416101eccad",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -9,6 +9,7 @@\n #include \"script/script.h\"\n #include \"script/standard.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"univalue/univalue.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\""
      },
      {
        "sha": "0cbdd8b91b5e24484d9b528192c2b15f8fccd482",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_DB_H\n \n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"sync.h\"\n #include \"version.h\"\n "
      },
      {
        "sha": "d997d56e00b7ef534cbff4d2c7621b026c131b96",
        "filename": "src/leveldbwrapper.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/leveldbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/leveldbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_LEVELDBWRAPPER_H\n \n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"util.h\"\n #include \"version.h\"\n "
      },
      {
        "sha": "340158512df342d302dfbe0b39a0954d8562eb2c",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -14,6 +14,7 @@\n #include \"netbase.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n+#include \"streams.h\"\n #include \"sync.h\"\n #include \"uint256.h\"\n #include \"utilstrencodings.h\""
      },
      {
        "sha": "5deac8007c65dcabac8e9b1118200993d4c9c0dd",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -7,6 +7,7 @@\n #include \"bitcoinunits.h\"\n #include \"guiutil.h\"\n #include \"optionsmodel.h\"\n+#include \"streams.h\"\n \n #include <boost/foreach.hpp>\n "
      },
      {
        "sha": "877ef8640a437c02858bcd5eb168fd7e17db29f7",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 0,
        "deletions": 553,
        "changes": 553,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -6,8 +6,6 @@\n #ifndef BITCOIN_SERIALIZE_H\n #define BITCOIN_SERIALIZE_H\n \n-#include \"allocators.h\"\n-\n #include <algorithm>\n #include <assert.h>\n #include <ios>\n@@ -20,8 +18,6 @@\n #include <utility>\n #include <vector>\n \n-class CAutoFile;\n-class CDataStream;\n class CScript;\n \n static const unsigned int MAX_SIZE = 0x02000000;\n@@ -761,8 +757,6 @@ inline void SerReadWrite(Stream& s, T& obj, int nType, int nVersion, CSerActionU\n \n \n \n-typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;\n-\n class CSizeComputer\n {\n protected:\n@@ -792,551 +786,4 @@ class CSizeComputer\n     }\n };\n \n-/** Double ended buffer combining vector and stream-like interfaces.\n- *\n- * >> and << read and write unformatted data using the above serialization templates.\n- * Fills with data in linear time; some stringstream implementations take N^2 time.\n- */\n-class CDataStream\n-{\n-protected:\n-    typedef CSerializeData vector_type;\n-    vector_type vch;\n-    unsigned int nReadPos;\n-public:\n-    int nType;\n-    int nVersion;\n-\n-    typedef vector_type::allocator_type   allocator_type;\n-    typedef vector_type::size_type        size_type;\n-    typedef vector_type::difference_type  difference_type;\n-    typedef vector_type::reference        reference;\n-    typedef vector_type::const_reference  const_reference;\n-    typedef vector_type::value_type       value_type;\n-    typedef vector_type::iterator         iterator;\n-    typedef vector_type::const_iterator   const_iterator;\n-    typedef vector_type::reverse_iterator reverse_iterator;\n-\n-    explicit CDataStream(int nTypeIn, int nVersionIn)\n-    {\n-        Init(nTypeIn, nVersionIn);\n-    }\n-\n-    CDataStream(const_iterator pbegin, const_iterator pend, int nTypeIn, int nVersionIn) : vch(pbegin, pend)\n-    {\n-        Init(nTypeIn, nVersionIn);\n-    }\n-\n-#if !defined(_MSC_VER) || _MSC_VER >= 1300\n-    CDataStream(const char* pbegin, const char* pend, int nTypeIn, int nVersionIn) : vch(pbegin, pend)\n-    {\n-        Init(nTypeIn, nVersionIn);\n-    }\n-#endif\n-\n-    CDataStream(const vector_type& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())\n-    {\n-        Init(nTypeIn, nVersionIn);\n-    }\n-\n-    CDataStream(const std::vector<char>& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())\n-    {\n-        Init(nTypeIn, nVersionIn);\n-    }\n-\n-    CDataStream(const std::vector<unsigned char>& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())\n-    {\n-        Init(nTypeIn, nVersionIn);\n-    }\n-\n-    void Init(int nTypeIn, int nVersionIn)\n-    {\n-        nReadPos = 0;\n-        nType = nTypeIn;\n-        nVersion = nVersionIn;\n-    }\n-\n-    CDataStream& operator+=(const CDataStream& b)\n-    {\n-        vch.insert(vch.end(), b.begin(), b.end());\n-        return *this;\n-    }\n-\n-    friend CDataStream operator+(const CDataStream& a, const CDataStream& b)\n-    {\n-        CDataStream ret = a;\n-        ret += b;\n-        return (ret);\n-    }\n-\n-    std::string str() const\n-    {\n-        return (std::string(begin(), end()));\n-    }\n-\n-\n-    //\n-    // Vector subset\n-    //\n-    const_iterator begin() const                     { return vch.begin() + nReadPos; }\n-    iterator begin()                                 { return vch.begin() + nReadPos; }\n-    const_iterator end() const                       { return vch.end(); }\n-    iterator end()                                   { return vch.end(); }\n-    size_type size() const                           { return vch.size() - nReadPos; }\n-    bool empty() const                               { return vch.size() == nReadPos; }\n-    void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n-    void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n-    const_reference operator[](size_type pos) const  { return vch[pos + nReadPos]; }\n-    reference operator[](size_type pos)              { return vch[pos + nReadPos]; }\n-    void clear()                                     { vch.clear(); nReadPos = 0; }\n-    iterator insert(iterator it, const char& x=char()) { return vch.insert(it, x); }\n-    void insert(iterator it, size_type n, const char& x) { vch.insert(it, n, x); }\n-\n-    void insert(iterator it, std::vector<char>::const_iterator first, std::vector<char>::const_iterator last)\n-    {\n-        assert(last - first >= 0);\n-        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n-        {\n-            // special case for inserting at the front when there's room\n-            nReadPos -= (last - first);\n-            memcpy(&vch[nReadPos], &first[0], last - first);\n-        }\n-        else\n-            vch.insert(it, first, last);\n-    }\n-\n-#if !defined(_MSC_VER) || _MSC_VER >= 1300\n-    void insert(iterator it, const char* first, const char* last)\n-    {\n-        assert(last - first >= 0);\n-        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n-        {\n-            // special case for inserting at the front when there's room\n-            nReadPos -= (last - first);\n-            memcpy(&vch[nReadPos], &first[0], last - first);\n-        }\n-        else\n-            vch.insert(it, first, last);\n-    }\n-#endif\n-\n-    iterator erase(iterator it)\n-    {\n-        if (it == vch.begin() + nReadPos)\n-        {\n-            // special case for erasing from the front\n-            if (++nReadPos >= vch.size())\n-            {\n-                // whenever we reach the end, we take the opportunity to clear the buffer\n-                nReadPos = 0;\n-                return vch.erase(vch.begin(), vch.end());\n-            }\n-            return vch.begin() + nReadPos;\n-        }\n-        else\n-            return vch.erase(it);\n-    }\n-\n-    iterator erase(iterator first, iterator last)\n-    {\n-        if (first == vch.begin() + nReadPos)\n-        {\n-            // special case for erasing from the front\n-            if (last == vch.end())\n-            {\n-                nReadPos = 0;\n-                return vch.erase(vch.begin(), vch.end());\n-            }\n-            else\n-            {\n-                nReadPos = (last - vch.begin());\n-                return last;\n-            }\n-        }\n-        else\n-            return vch.erase(first, last);\n-    }\n-\n-    inline void Compact()\n-    {\n-        vch.erase(vch.begin(), vch.begin() + nReadPos);\n-        nReadPos = 0;\n-    }\n-\n-    bool Rewind(size_type n)\n-    {\n-        // Rewind by n characters if the buffer hasn't been compacted yet\n-        if (n > nReadPos)\n-            return false;\n-        nReadPos -= n;\n-        return true;\n-    }\n-\n-\n-    //\n-    // Stream subset\n-    //\n-    bool eof() const             { return size() == 0; }\n-    CDataStream* rdbuf()         { return this; }\n-    int in_avail()               { return size(); }\n-\n-    void SetType(int n)          { nType = n; }\n-    int GetType()                { return nType; }\n-    void SetVersion(int n)       { nVersion = n; }\n-    int GetVersion()             { return nVersion; }\n-    void ReadVersion()           { *this >> nVersion; }\n-    void WriteVersion()          { *this << nVersion; }\n-\n-    CDataStream& read(char* pch, size_t nSize)\n-    {\n-        // Read from the beginning of the buffer\n-        unsigned int nReadPosNext = nReadPos + nSize;\n-        if (nReadPosNext >= vch.size())\n-        {\n-            if (nReadPosNext > vch.size())\n-            {\n-                throw std::ios_base::failure(\"CDataStream::read() : end of data\");\n-            }\n-            memcpy(pch, &vch[nReadPos], nSize);\n-            nReadPos = 0;\n-            vch.clear();\n-            return (*this);\n-        }\n-        memcpy(pch, &vch[nReadPos], nSize);\n-        nReadPos = nReadPosNext;\n-        return (*this);\n-    }\n-\n-    CDataStream& ignore(int nSize)\n-    {\n-        // Ignore from the beginning of the buffer\n-        assert(nSize >= 0);\n-        unsigned int nReadPosNext = nReadPos + nSize;\n-        if (nReadPosNext >= vch.size())\n-        {\n-            if (nReadPosNext > vch.size())\n-                throw std::ios_base::failure(\"CDataStream::ignore() : end of data\");\n-            nReadPos = 0;\n-            vch.clear();\n-            return (*this);\n-        }\n-        nReadPos = nReadPosNext;\n-        return (*this);\n-    }\n-\n-    CDataStream& write(const char* pch, size_t nSize)\n-    {\n-        // Write to the end of the buffer\n-        vch.insert(vch.end(), pch, pch + nSize);\n-        return (*this);\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const\n-    {\n-        // Special case: stream << stream concatenates like stream += stream\n-        if (!vch.empty())\n-            s.write((char*)&vch[0], vch.size() * sizeof(vch[0]));\n-    }\n-\n-    template<typename T>\n-    unsigned int GetSerializeSize(const T& obj)\n-    {\n-        // Tells the size of the object if serialized to this stream\n-        return ::GetSerializeSize(obj, nType, nVersion);\n-    }\n-\n-    template<typename T>\n-    CDataStream& operator<<(const T& obj)\n-    {\n-        // Serialize to this stream\n-        ::Serialize(*this, obj, nType, nVersion);\n-        return (*this);\n-    }\n-\n-    template<typename T>\n-    CDataStream& operator>>(T& obj)\n-    {\n-        // Unserialize from this stream\n-        ::Unserialize(*this, obj, nType, nVersion);\n-        return (*this);\n-    }\n-\n-    void GetAndClear(CSerializeData &data) {\n-        data.insert(data.end(), begin(), end());\n-        clear();\n-    }\n-};\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-/** Non-refcounted RAII wrapper for FILE*\n- *\n- * Will automatically close the file when it goes out of scope if not null.\n- * If you're returning the file pointer, return file.release().\n- * If you need to close the file early, use file.fclose() instead of fclose(file).\n- */\n-class CAutoFile\n-{\n-private:\n-    // Disallow copies\n-    CAutoFile(const CAutoFile&);\n-    CAutoFile& operator=(const CAutoFile&);\n-\n-    int nType;\n-    int nVersion;\n-\t\n-    FILE* file;\t\n-\n-public:\n-    CAutoFile(FILE* filenew, int nTypeIn, int nVersionIn)\n-    {\n-        file = filenew;\n-        nType = nTypeIn;\n-        nVersion = nVersionIn;\n-    }\n-\n-    ~CAutoFile()\n-    {\n-        fclose();\n-    }\n-\n-    void fclose()\n-    {\n-        if (file) {\n-            ::fclose(file);\n-            file = NULL;\n-        }\n-    }\n-\n-    /** Get wrapped FILE* with transfer of ownership.\n-     * @note This will invalidate the CAutoFile object, and makes it the responsibility of the caller\n-     * of this function to clean up the returned FILE*.\n-     */\n-    FILE* release()             { FILE* ret = file; file = NULL; return ret; }\n-\n-    /** Get wrapped FILE* without transfer of ownership.\n-     * @note Ownership of the FILE* will remain with this class. Use this only if the scope of the\n-     * CAutoFile outlives use of the passed pointer.\n-     */\n-    FILE* Get() const           { return file; }\n-\n-    /** Return true if the wrapped FILE* is NULL, false otherwise.\n-     */\n-    bool IsNull() const         { return (file == NULL); }\n-\n-    //\n-    // Stream subset\n-    //\n-    void SetType(int n)          { nType = n; }\n-    int GetType()                { return nType; }\n-    void SetVersion(int n)       { nVersion = n; }\n-    int GetVersion()             { return nVersion; }\n-    void ReadVersion()           { *this >> nVersion; }\n-    void WriteVersion()          { *this << nVersion; }\n-\n-    CAutoFile& read(char* pch, size_t nSize)\n-    {\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::read : file handle is NULL\");\n-        if (fread(pch, 1, nSize, file) != nSize)\n-            throw std::ios_base::failure(feof(file) ? \"CAutoFile::read : end of file\" : \"CAutoFile::read : fread failed\");\n-        return (*this);\n-    }\n-\n-    CAutoFile& write(const char* pch, size_t nSize)\n-    {\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::write : file handle is NULL\");\n-        if (fwrite(pch, 1, nSize, file) != nSize)\n-            throw std::ios_base::failure(\"CAutoFile::write : write failed\");\n-        return (*this);\n-    }\n-\n-    template<typename T>\n-    unsigned int GetSerializeSize(const T& obj)\n-    {\n-        // Tells the size of the object if serialized to this stream\n-        return ::GetSerializeSize(obj, nType, nVersion);\n-    }\n-\n-    template<typename T>\n-    CAutoFile& operator<<(const T& obj)\n-    {\n-        // Serialize to this stream\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator<< : file handle is NULL\");\n-        ::Serialize(*this, obj, nType, nVersion);\n-        return (*this);\n-    }\n-\n-    template<typename T>\n-    CAutoFile& operator>>(T& obj)\n-    {\n-        // Unserialize from this stream\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator>> : file handle is NULL\");\n-        ::Unserialize(*this, obj, nType, nVersion);\n-        return (*this);\n-    }\n-};\n-\n-/** Non-refcounted RAII wrapper around a FILE* that implements a ring buffer to\n- *  deserialize from. It guarantees the ability to rewind a given number of bytes.\n- *\n- *  Will automatically close the file when it goes out of scope if not null.\n- *  If you need to close the file early, use file.fclose() instead of fclose(file).\n- */\n-class CBufferedFile\n-{\n-private:\n-    // Disallow copies\n-    CBufferedFile(const CBufferedFile&);\n-    CBufferedFile& operator=(const CBufferedFile&);\n-\n-    int nType;\n-    int nVersion;\n-\n-    FILE *src;            // source file\n-    uint64_t nSrcPos;     // how many bytes have been read from source\n-    uint64_t nReadPos;    // how many bytes have been read from this\n-    uint64_t nReadLimit;  // up to which position we're allowed to read\n-    uint64_t nRewind;     // how many bytes we guarantee to rewind\n-    std::vector<char> vchBuf; // the buffer\n-\n-protected:\n-    // read data from the source to fill the buffer\n-    bool Fill() {\n-        unsigned int pos = nSrcPos % vchBuf.size();\n-        unsigned int readNow = vchBuf.size() - pos;\n-        unsigned int nAvail = vchBuf.size() - (nSrcPos - nReadPos) - nRewind;\n-        if (nAvail < readNow)\n-            readNow = nAvail;\n-        if (readNow == 0)\n-            return false;\n-        size_t read = fread((void*)&vchBuf[pos], 1, readNow, src);\n-        if (read == 0) {\n-            throw std::ios_base::failure(feof(src) ? \"CBufferedFile::Fill : end of file\" : \"CBufferedFile::Fill : fread failed\");\n-        } else {\n-            nSrcPos += read;\n-            return true;\n-        }\n-    }\n-\n-public:\n-    CBufferedFile(FILE *fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn) :\n-        nSrcPos(0), nReadPos(0), nReadLimit((uint64_t)(-1)), nRewind(nRewindIn), vchBuf(nBufSize, 0)\n-    {\n-        src = fileIn;\n-        nType = nTypeIn;\n-        nVersion = nVersionIn;\n-    }\n-\n-    ~CBufferedFile()\n-    {\n-        fclose();\n-    }\n-\n-    void fclose()\n-    {\n-        if (src) {\n-            ::fclose(src);\n-            src = NULL;\n-        }\n-    }\n-\n-    // check whether we're at the end of the source file\n-    bool eof() const {\n-        return nReadPos == nSrcPos && feof(src);\n-    }\n-\n-    // read a number of bytes\n-    CBufferedFile& read(char *pch, size_t nSize) {\n-        if (nSize + nReadPos > nReadLimit)\n-            throw std::ios_base::failure(\"Read attempted past buffer limit\");\n-        if (nSize + nRewind > vchBuf.size())\n-            throw std::ios_base::failure(\"Read larger than buffer size\");\n-        while (nSize > 0) {\n-            if (nReadPos == nSrcPos)\n-                Fill();\n-            unsigned int pos = nReadPos % vchBuf.size();\n-            size_t nNow = nSize;\n-            if (nNow + pos > vchBuf.size())\n-                nNow = vchBuf.size() - pos;\n-            if (nNow + nReadPos > nSrcPos)\n-                nNow = nSrcPos - nReadPos;\n-            memcpy(pch, &vchBuf[pos], nNow);\n-            nReadPos += nNow;\n-            pch += nNow;\n-            nSize -= nNow;\n-        }\n-        return (*this);\n-    }\n-\n-    // return the current reading position\n-    uint64_t GetPos() {\n-        return nReadPos;\n-    }\n-\n-    // rewind to a given reading position\n-    bool SetPos(uint64_t nPos) {\n-        nReadPos = nPos;\n-        if (nReadPos + nRewind < nSrcPos) {\n-            nReadPos = nSrcPos - nRewind;\n-            return false;\n-        } else if (nReadPos > nSrcPos) {\n-            nReadPos = nSrcPos;\n-            return false;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    bool Seek(uint64_t nPos) {\n-        long nLongPos = nPos;\n-        if (nPos != (uint64_t)nLongPos)\n-            return false;\n-        if (fseek(src, nLongPos, SEEK_SET))\n-            return false;\n-        nLongPos = ftell(src);\n-        nSrcPos = nLongPos;\n-        nReadPos = nLongPos;\n-        return true;\n-    }\n-\n-    // prevent reading beyond a certain position\n-    // no argument removes the limit\n-    bool SetLimit(uint64_t nPos = (uint64_t)(-1)) {\n-        if (nPos < nReadPos)\n-            return false;\n-        nReadLimit = nPos;\n-        return true;\n-    }\n-\n-    template<typename T>\n-    CBufferedFile& operator>>(T& obj) {\n-        // Unserialize from this stream\n-        ::Unserialize(*this, obj, nType, nVersion);\n-        return (*this);\n-    }\n-\n-    // search for a given byte in the stream, and remain positioned on it\n-    void FindByte(char ch) {\n-        while (true) {\n-            if (nReadPos == nSrcPos)\n-                Fill();\n-            if (vchBuf[nReadPos % vchBuf.size()] == ch)\n-                break;\n-            nReadPos++;\n-        }\n-    }\n-};\n-\n #endif // BITCOIN_SERIALIZE_H"
      },
      {
        "sha": "b07b11eb3da106b4a1018860a3f6338666d3bc24",
        "filename": "src/streams.h",
        "status": "added",
        "additions": 571,
        "deletions": 0,
        "changes": 571,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -0,0 +1,571 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_STREAMS_H\n+#define BITCOIN_STREAMS_H\n+\n+#include \"allocators.h\"\n+#include \"serialize.h\"\n+\n+#include <algorithm>\n+#include <assert.h>\n+#include <ios>\n+#include <limits>\n+#include <map>\n+#include <set>\n+#include <stdint.h>\n+#include <string>\n+#include <string.h>\n+#include <utility>\n+#include <vector>\n+\n+/** Double ended buffer combining vector and stream-like interfaces.\n+ *\n+ * >> and << read and write unformatted data using the above serialization templates.\n+ * Fills with data in linear time; some stringstream implementations take N^2 time.\n+ */\n+class CDataStream\n+{\n+protected:\n+    typedef CSerializeData vector_type;\n+    vector_type vch;\n+    unsigned int nReadPos;\n+public:\n+    int nType;\n+    int nVersion;\n+\n+    typedef vector_type::allocator_type   allocator_type;\n+    typedef vector_type::size_type        size_type;\n+    typedef vector_type::difference_type  difference_type;\n+    typedef vector_type::reference        reference;\n+    typedef vector_type::const_reference  const_reference;\n+    typedef vector_type::value_type       value_type;\n+    typedef vector_type::iterator         iterator;\n+    typedef vector_type::const_iterator   const_iterator;\n+    typedef vector_type::reverse_iterator reverse_iterator;\n+\n+    explicit CDataStream(int nTypeIn, int nVersionIn)\n+    {\n+        Init(nTypeIn, nVersionIn);\n+    }\n+\n+    CDataStream(const_iterator pbegin, const_iterator pend, int nTypeIn, int nVersionIn) : vch(pbegin, pend)\n+    {\n+        Init(nTypeIn, nVersionIn);\n+    }\n+\n+#if !defined(_MSC_VER) || _MSC_VER >= 1300\n+    CDataStream(const char* pbegin, const char* pend, int nTypeIn, int nVersionIn) : vch(pbegin, pend)\n+    {\n+        Init(nTypeIn, nVersionIn);\n+    }\n+#endif\n+\n+    CDataStream(const vector_type& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())\n+    {\n+        Init(nTypeIn, nVersionIn);\n+    }\n+\n+    CDataStream(const std::vector<char>& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())\n+    {\n+        Init(nTypeIn, nVersionIn);\n+    }\n+\n+    CDataStream(const std::vector<unsigned char>& vchIn, int nTypeIn, int nVersionIn) : vch(vchIn.begin(), vchIn.end())\n+    {\n+        Init(nTypeIn, nVersionIn);\n+    }\n+\n+    void Init(int nTypeIn, int nVersionIn)\n+    {\n+        nReadPos = 0;\n+        nType = nTypeIn;\n+        nVersion = nVersionIn;\n+    }\n+\n+    CDataStream& operator+=(const CDataStream& b)\n+    {\n+        vch.insert(vch.end(), b.begin(), b.end());\n+        return *this;\n+    }\n+\n+    friend CDataStream operator+(const CDataStream& a, const CDataStream& b)\n+    {\n+        CDataStream ret = a;\n+        ret += b;\n+        return (ret);\n+    }\n+\n+    std::string str() const\n+    {\n+        return (std::string(begin(), end()));\n+    }\n+\n+\n+    //\n+    // Vector subset\n+    //\n+    const_iterator begin() const                     { return vch.begin() + nReadPos; }\n+    iterator begin()                                 { return vch.begin() + nReadPos; }\n+    const_iterator end() const                       { return vch.end(); }\n+    iterator end()                                   { return vch.end(); }\n+    size_type size() const                           { return vch.size() - nReadPos; }\n+    bool empty() const                               { return vch.size() == nReadPos; }\n+    void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n+    void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n+    const_reference operator[](size_type pos) const  { return vch[pos + nReadPos]; }\n+    reference operator[](size_type pos)              { return vch[pos + nReadPos]; }\n+    void clear()                                     { vch.clear(); nReadPos = 0; }\n+    iterator insert(iterator it, const char& x=char()) { return vch.insert(it, x); }\n+    void insert(iterator it, size_type n, const char& x) { vch.insert(it, n, x); }\n+\n+    void insert(iterator it, std::vector<char>::const_iterator first, std::vector<char>::const_iterator last)\n+    {\n+        assert(last - first >= 0);\n+        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n+        {\n+            // special case for inserting at the front when there's room\n+            nReadPos -= (last - first);\n+            memcpy(&vch[nReadPos], &first[0], last - first);\n+        }\n+        else\n+            vch.insert(it, first, last);\n+    }\n+\n+#if !defined(_MSC_VER) || _MSC_VER >= 1300\n+    void insert(iterator it, const char* first, const char* last)\n+    {\n+        assert(last - first >= 0);\n+        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n+        {\n+            // special case for inserting at the front when there's room\n+            nReadPos -= (last - first);\n+            memcpy(&vch[nReadPos], &first[0], last - first);\n+        }\n+        else\n+            vch.insert(it, first, last);\n+    }\n+#endif\n+\n+    iterator erase(iterator it)\n+    {\n+        if (it == vch.begin() + nReadPos)\n+        {\n+            // special case for erasing from the front\n+            if (++nReadPos >= vch.size())\n+            {\n+                // whenever we reach the end, we take the opportunity to clear the buffer\n+                nReadPos = 0;\n+                return vch.erase(vch.begin(), vch.end());\n+            }\n+            return vch.begin() + nReadPos;\n+        }\n+        else\n+            return vch.erase(it);\n+    }\n+\n+    iterator erase(iterator first, iterator last)\n+    {\n+        if (first == vch.begin() + nReadPos)\n+        {\n+            // special case for erasing from the front\n+            if (last == vch.end())\n+            {\n+                nReadPos = 0;\n+                return vch.erase(vch.begin(), vch.end());\n+            }\n+            else\n+            {\n+                nReadPos = (last - vch.begin());\n+                return last;\n+            }\n+        }\n+        else\n+            return vch.erase(first, last);\n+    }\n+\n+    inline void Compact()\n+    {\n+        vch.erase(vch.begin(), vch.begin() + nReadPos);\n+        nReadPos = 0;\n+    }\n+\n+    bool Rewind(size_type n)\n+    {\n+        // Rewind by n characters if the buffer hasn't been compacted yet\n+        if (n > nReadPos)\n+            return false;\n+        nReadPos -= n;\n+        return true;\n+    }\n+\n+\n+    //\n+    // Stream subset\n+    //\n+    bool eof() const             { return size() == 0; }\n+    CDataStream* rdbuf()         { return this; }\n+    int in_avail()               { return size(); }\n+\n+    void SetType(int n)          { nType = n; }\n+    int GetType()                { return nType; }\n+    void SetVersion(int n)       { nVersion = n; }\n+    int GetVersion()             { return nVersion; }\n+    void ReadVersion()           { *this >> nVersion; }\n+    void WriteVersion()          { *this << nVersion; }\n+\n+    CDataStream& read(char* pch, size_t nSize)\n+    {\n+        // Read from the beginning of the buffer\n+        unsigned int nReadPosNext = nReadPos + nSize;\n+        if (nReadPosNext >= vch.size())\n+        {\n+            if (nReadPosNext > vch.size())\n+            {\n+                throw std::ios_base::failure(\"CDataStream::read() : end of data\");\n+            }\n+            memcpy(pch, &vch[nReadPos], nSize);\n+            nReadPos = 0;\n+            vch.clear();\n+            return (*this);\n+        }\n+        memcpy(pch, &vch[nReadPos], nSize);\n+        nReadPos = nReadPosNext;\n+        return (*this);\n+    }\n+\n+    CDataStream& ignore(int nSize)\n+    {\n+        // Ignore from the beginning of the buffer\n+        assert(nSize >= 0);\n+        unsigned int nReadPosNext = nReadPos + nSize;\n+        if (nReadPosNext >= vch.size())\n+        {\n+            if (nReadPosNext > vch.size())\n+                throw std::ios_base::failure(\"CDataStream::ignore() : end of data\");\n+            nReadPos = 0;\n+            vch.clear();\n+            return (*this);\n+        }\n+        nReadPos = nReadPosNext;\n+        return (*this);\n+    }\n+\n+    CDataStream& write(const char* pch, size_t nSize)\n+    {\n+        // Write to the end of the buffer\n+        vch.insert(vch.end(), pch, pch + nSize);\n+        return (*this);\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const\n+    {\n+        // Special case: stream << stream concatenates like stream += stream\n+        if (!vch.empty())\n+            s.write((char*)&vch[0], vch.size() * sizeof(vch[0]));\n+    }\n+\n+    template<typename T>\n+    unsigned int GetSerializeSize(const T& obj)\n+    {\n+        // Tells the size of the object if serialized to this stream\n+        return ::GetSerializeSize(obj, nType, nVersion);\n+    }\n+\n+    template<typename T>\n+    CDataStream& operator<<(const T& obj)\n+    {\n+        // Serialize to this stream\n+        ::Serialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    template<typename T>\n+    CDataStream& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    void GetAndClear(CSerializeData &data) {\n+        data.insert(data.end(), begin(), end());\n+        clear();\n+    }\n+};\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+/** Non-refcounted RAII wrapper for FILE*\n+ *\n+ * Will automatically close the file when it goes out of scope if not null.\n+ * If you're returning the file pointer, return file.release().\n+ * If you need to close the file early, use file.fclose() instead of fclose(file).\n+ */\n+class CAutoFile\n+{\n+private:\n+    // Disallow copies\n+    CAutoFile(const CAutoFile&);\n+    CAutoFile& operator=(const CAutoFile&);\n+\n+    int nType;\n+    int nVersion;\n+\t\n+    FILE* file;\t\n+\n+public:\n+    CAutoFile(FILE* filenew, int nTypeIn, int nVersionIn)\n+    {\n+        file = filenew;\n+        nType = nTypeIn;\n+        nVersion = nVersionIn;\n+    }\n+\n+    ~CAutoFile()\n+    {\n+        fclose();\n+    }\n+\n+    void fclose()\n+    {\n+        if (file) {\n+            ::fclose(file);\n+            file = NULL;\n+        }\n+    }\n+\n+    /** Get wrapped FILE* with transfer of ownership.\n+     * @note This will invalidate the CAutoFile object, and makes it the responsibility of the caller\n+     * of this function to clean up the returned FILE*.\n+     */\n+    FILE* release()             { FILE* ret = file; file = NULL; return ret; }\n+\n+    /** Get wrapped FILE* without transfer of ownership.\n+     * @note Ownership of the FILE* will remain with this class. Use this only if the scope of the\n+     * CAutoFile outlives use of the passed pointer.\n+     */\n+    FILE* Get() const           { return file; }\n+\n+    /** Return true if the wrapped FILE* is NULL, false otherwise.\n+     */\n+    bool IsNull() const         { return (file == NULL); }\n+\n+    //\n+    // Stream subset\n+    //\n+    void SetType(int n)          { nType = n; }\n+    int GetType()                { return nType; }\n+    void SetVersion(int n)       { nVersion = n; }\n+    int GetVersion()             { return nVersion; }\n+    void ReadVersion()           { *this >> nVersion; }\n+    void WriteVersion()          { *this << nVersion; }\n+\n+    CAutoFile& read(char* pch, size_t nSize)\n+    {\n+        if (!file)\n+            throw std::ios_base::failure(\"CAutoFile::read : file handle is NULL\");\n+        if (fread(pch, 1, nSize, file) != nSize)\n+            throw std::ios_base::failure(feof(file) ? \"CAutoFile::read : end of file\" : \"CAutoFile::read : fread failed\");\n+        return (*this);\n+    }\n+\n+    CAutoFile& write(const char* pch, size_t nSize)\n+    {\n+        if (!file)\n+            throw std::ios_base::failure(\"CAutoFile::write : file handle is NULL\");\n+        if (fwrite(pch, 1, nSize, file) != nSize)\n+            throw std::ios_base::failure(\"CAutoFile::write : write failed\");\n+        return (*this);\n+    }\n+\n+    template<typename T>\n+    unsigned int GetSerializeSize(const T& obj)\n+    {\n+        // Tells the size of the object if serialized to this stream\n+        return ::GetSerializeSize(obj, nType, nVersion);\n+    }\n+\n+    template<typename T>\n+    CAutoFile& operator<<(const T& obj)\n+    {\n+        // Serialize to this stream\n+        if (!file)\n+            throw std::ios_base::failure(\"CAutoFile::operator<< : file handle is NULL\");\n+        ::Serialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    template<typename T>\n+    CAutoFile& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        if (!file)\n+            throw std::ios_base::failure(\"CAutoFile::operator>> : file handle is NULL\");\n+        ::Unserialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+};\n+\n+/** Non-refcounted RAII wrapper around a FILE* that implements a ring buffer to\n+ *  deserialize from. It guarantees the ability to rewind a given number of bytes.\n+ *\n+ *  Will automatically close the file when it goes out of scope if not null.\n+ *  If you need to close the file early, use file.fclose() instead of fclose(file).\n+ */\n+class CBufferedFile\n+{\n+private:\n+    // Disallow copies\n+    CBufferedFile(const CBufferedFile&);\n+    CBufferedFile& operator=(const CBufferedFile&);\n+\n+    int nType;\n+    int nVersion;\n+\n+    FILE *src;            // source file\n+    uint64_t nSrcPos;     // how many bytes have been read from source\n+    uint64_t nReadPos;    // how many bytes have been read from this\n+    uint64_t nReadLimit;  // up to which position we're allowed to read\n+    uint64_t nRewind;     // how many bytes we guarantee to rewind\n+    std::vector<char> vchBuf; // the buffer\n+\n+protected:\n+    // read data from the source to fill the buffer\n+    bool Fill() {\n+        unsigned int pos = nSrcPos % vchBuf.size();\n+        unsigned int readNow = vchBuf.size() - pos;\n+        unsigned int nAvail = vchBuf.size() - (nSrcPos - nReadPos) - nRewind;\n+        if (nAvail < readNow)\n+            readNow = nAvail;\n+        if (readNow == 0)\n+            return false;\n+        size_t read = fread((void*)&vchBuf[pos], 1, readNow, src);\n+        if (read == 0) {\n+            throw std::ios_base::failure(feof(src) ? \"CBufferedFile::Fill : end of file\" : \"CBufferedFile::Fill : fread failed\");\n+        } else {\n+            nSrcPos += read;\n+            return true;\n+        }\n+    }\n+\n+public:\n+    CBufferedFile(FILE *fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn) :\n+        nSrcPos(0), nReadPos(0), nReadLimit((uint64_t)(-1)), nRewind(nRewindIn), vchBuf(nBufSize, 0)\n+    {\n+        src = fileIn;\n+        nType = nTypeIn;\n+        nVersion = nVersionIn;\n+    }\n+\n+    ~CBufferedFile()\n+    {\n+        fclose();\n+    }\n+\n+    void fclose()\n+    {\n+        if (src) {\n+            ::fclose(src);\n+            src = NULL;\n+        }\n+    }\n+\n+    // check whether we're at the end of the source file\n+    bool eof() const {\n+        return nReadPos == nSrcPos && feof(src);\n+    }\n+\n+    // read a number of bytes\n+    CBufferedFile& read(char *pch, size_t nSize) {\n+        if (nSize + nReadPos > nReadLimit)\n+            throw std::ios_base::failure(\"Read attempted past buffer limit\");\n+        if (nSize + nRewind > vchBuf.size())\n+            throw std::ios_base::failure(\"Read larger than buffer size\");\n+        while (nSize > 0) {\n+            if (nReadPos == nSrcPos)\n+                Fill();\n+            unsigned int pos = nReadPos % vchBuf.size();\n+            size_t nNow = nSize;\n+            if (nNow + pos > vchBuf.size())\n+                nNow = vchBuf.size() - pos;\n+            if (nNow + nReadPos > nSrcPos)\n+                nNow = nSrcPos - nReadPos;\n+            memcpy(pch, &vchBuf[pos], nNow);\n+            nReadPos += nNow;\n+            pch += nNow;\n+            nSize -= nNow;\n+        }\n+        return (*this);\n+    }\n+\n+    // return the current reading position\n+    uint64_t GetPos() {\n+        return nReadPos;\n+    }\n+\n+    // rewind to a given reading position\n+    bool SetPos(uint64_t nPos) {\n+        nReadPos = nPos;\n+        if (nReadPos + nRewind < nSrcPos) {\n+            nReadPos = nSrcPos - nRewind;\n+            return false;\n+        } else if (nReadPos > nSrcPos) {\n+            nReadPos = nSrcPos;\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    bool Seek(uint64_t nPos) {\n+        long nLongPos = nPos;\n+        if (nPos != (uint64_t)nLongPos)\n+            return false;\n+        if (fseek(src, nLongPos, SEEK_SET))\n+            return false;\n+        nLongPos = ftell(src);\n+        nSrcPos = nLongPos;\n+        nReadPos = nLongPos;\n+        return true;\n+    }\n+\n+    // prevent reading beyond a certain position\n+    // no argument removes the limit\n+    bool SetLimit(uint64_t nPos = (uint64_t)(-1)) {\n+        if (nPos < nReadPos)\n+            return false;\n+        nReadLimit = nPos;\n+        return true;\n+    }\n+\n+    template<typename T>\n+    CBufferedFile& operator>>(T& obj) {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    // search for a given byte in the stream, and remain positioned on it\n+    void FindByte(char ch) {\n+        while (true) {\n+            if (nReadPos == nSrcPos)\n+                Fill();\n+            if (vchBuf[nReadPos % vchBuf.size()] == ch)\n+                break;\n+            nReadPos++;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_STREAMS_H"
      },
      {
        "sha": "28610f0d2e49cb168be5cc208019edfb29cd95d8",
        "filename": "src/test/alert_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/test/alert_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/test/alert_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/alert_tests.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -10,6 +10,7 @@\n #include \"data/alertTests.raw.h\"\n \n #include \"serialize.h\"\n+#include \"streams.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\""
      },
      {
        "sha": "59e95f2fd123516dd769d8d8b7eed611e1e7e261",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"serialize.h\"\n+#include \"streams.h\"\n \n #include <stdint.h>\n "
      },
      {
        "sha": "b0d6b4aefa8af2a73c0ea09f3fd52102354309b4",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -6,6 +6,7 @@\n #include \"txmempool.h\"\n \n #include \"core.h\"\n+#include \"streams.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #include \"version.h\""
      },
      {
        "sha": "85cf5310ff4d1c8294938e99c60311d8a3e60342",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7361907a0a5d6698bb7e8e45fa5ac034b81066/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=fa7361907a0a5d6698bb7e8e45fa5ac034b81066",
        "patch": "@@ -12,6 +12,8 @@\n #include \"core.h\"\n #include \"sync.h\"\n \n+class CAutoFile;\n+\n inline bool AllowFree(double dPriority)\n {\n     // Large (in bytes) low-priority (new, small-coin) transactions"
      }
    ]
  }
]