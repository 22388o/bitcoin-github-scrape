[
  {
    "sha": "03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowM2Y4NzdmYWQzOTNiYzUzYTcxZDBkZjRkN2ViMmY2OGZkZGQ1ZWUx",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-13T17:59:41Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T15:36:25Z"
      },
      "message": "Refactor: protect mapNodeState with its own lock\n\nEncapsulate mapNodeState in a smart-pointer class with its own lock.\n\nWhy? So Misbehaving() can be called from the sanity-check-a-message code without holding cs_main.\n\nAnd to get better exception safety (the smart-pointer approach gives RAII semantics).\n\nAnd because protecting fewer things with cs_main is a good idea.\n\nTested by compiling with -DDEBUG_LOCKORDER, running all of the qa/rpc-tests, and running a node on the main network overnight.",
      "tree": {
        "sha": "ddd803c50bb66cd91f74491c514156bad6761855",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ddd803c50bb66cd91f74491c514156bad6761855"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlLHkACgkQdYgkL74406iGWQCg2nFDPhUe9Tm3iva1G5sUx4Pk\noqsAn1SEB3HqUryaKyTpXGaVdelz6ITv\n=eYE4\n-----END PGP SIGNATURE-----",
        "payload": "tree ddd803c50bb66cd91f74491c514156bad6761855\nparent 6bcb0a21c5435738e2fccd589636de8db4989992\nauthor Gavin Andresen <gavinandresen@gmail.com> 1436810381 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436888185 -0400\n\nRefactor: protect mapNodeState with its own lock\n\nEncapsulate mapNodeState in a smart-pointer class with its own lock.\n\nWhy? So Misbehaving() can be called from the sanity-check-a-message code without holding cs_main.\n\nAnd to get better exception safety (the smart-pointer approach gives RAII semantics).\n\nAnd because protecting fewer things with cs_main is a good idea.\n\nTested by compiling with -DDEBUG_LOCKORDER, running all of the qa/rpc-tests, and running a node on the main network overnight.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6bcb0a21c5435738e2fccd589636de8db4989992",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bcb0a21c5435738e2fccd589636de8db4989992",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6bcb0a21c5435738e2fccd589636de8db4989992"
      }
    ],
    "stats": {
      "total": 165,
      "additions": 107,
      "deletions": 58
    },
    "files": [
      {
        "sha": "c75ac19da3caae4a0bc37e0e98f80471fd649808",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 107,
        "deletions": 58,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
        "patch": "@@ -237,24 +237,71 @@ struct CNodeState {\n     }\n };\n \n-/** Map maintaining per-node state. Requires cs_main. */\n-map<NodeId, CNodeState> mapNodeState;\n+// Class that maintains per-node state, and\n+// acts as a RAII smart-pointer that make sure\n+// the state stays consistent.\n+class NodeStatePtr {\n+private:\n+    static CCriticalSection cs_mapNodeState;\n+    static map<NodeId, CNodeState> mapNodeState;\n+    CNodeState* s;\n+    NodeId id;\n+public:\n+    static void insert(NodeId nodeid, const CNode *pnode) {\n+        LOCK(cs_mapNodeState);\n+        CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;\n+        state.name = pnode->addrName;\n+        state.address = pnode->addr;\n+    }\n \n-// Requires cs_main.\n-CNodeState *State(NodeId pnode) {\n-    map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n-    if (it == mapNodeState.end())\n-        return NULL;\n-    return &it->second;\n-}\n+    NodeStatePtr(NodeId nodeid) {\n+        LOCK(cs_mapNodeState);\n+        map<NodeId, CNodeState>::iterator it = mapNodeState.find(nodeid);\n+        if (it == mapNodeState.end())\n+            s = NULL;\n+        else {\n+            s = &it->second;\n+            id = nodeid;\n+            cs_mapNodeState.lock();\n+        }\n+    }\n+    ~NodeStatePtr() {\n+        if (s)\n+            cs_mapNodeState.unlock();\n+    }\n+    bool IsNull() const { return s == NULL; }\n+\n+    CNodeState* operator ->() { return s; }\n+    const CNodeState* operator ->() const { return s; }\n+\n+    void erase() {\n+        if (s) {\n+            mapNodeState.erase(id);\n+            s = NULL;\n+            cs_mapNodeState.unlock();\n+        }\n+    }\n+\n+    static void clear() {\n+        LOCK(cs_mapNodeState);\n+        mapNodeState.clear();\n+    }\n+\n+private:\n+    // disallow copy/assignment\n+    NodeStatePtr(const NodeStatePtr&) {}\n+    NodeStatePtr& operator=(const NodeStatePtr& p) { return *this; }\n+};\n+CCriticalSection NodeStatePtr::cs_mapNodeState;\n+map<NodeId, CNodeState> NodeStatePtr::mapNodeState;\n \n int GetHeight()\n {\n     LOCK(cs_main);\n     return chainActive.Height();\n }\n \n-void UpdatePreferredDownload(CNode* node, CNodeState* state)\n+void UpdatePreferredDownload(CNode* node, NodeStatePtr& state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n \n@@ -271,15 +318,12 @@ int64_t GetBlockTimeout(int64_t nTime, int nValidatedQueuedBefore, const Consens\n }\n \n void InitializeNode(NodeId nodeid, const CNode *pnode) {\n-    LOCK(cs_main);\n-    CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;\n-    state.name = pnode->addrName;\n-    state.address = pnode->addr;\n+    NodeStatePtr::insert(nodeid, pnode);\n }\n \n void FinalizeNode(NodeId nodeid) {\n     LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n+    NodeStatePtr state(nodeid);\n \n     if (state->fSyncStarted)\n         nSyncStarted--;\n@@ -293,15 +337,16 @@ void FinalizeNode(NodeId nodeid) {\n     EraseOrphansFor(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n \n-    mapNodeState.erase(nodeid);\n+    state.erase();\n }\n \n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n bool MarkBlockAsReceived(const uint256& hash) {\n+    AssertLockHeld(cs_main);\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n+        NodeStatePtr state(itInFlight->second.first);\n         nQueuedValidatedHeaders -= itInFlight->second.second->fValidatedHeaders;\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n@@ -315,12 +360,14 @@ bool MarkBlockAsReceived(const uint256& hash) {\n \n // Requires cs_main.\n void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    AssertLockHeld(cs_main);\n \n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n+    NodeStatePtr state(nodeid);\n+    assert(!state.IsNull());\n+\n     int64_t nNow = GetTimeMicros();\n     QueuedBlock newentry = {hash, pindex, nNow, pindex != NULL, GetBlockTimeout(nNow, nQueuedValidatedHeaders, consensusParams)};\n     nQueuedValidatedHeaders += newentry.fValidatedHeaders;\n@@ -331,9 +378,8 @@ void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n }\n \n /** Check whether the last unknown block a peer advertized is not yet known. */\n-void ProcessBlockAvailability(NodeId nodeid) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+static void ProcessBlockAvailability(NodeStatePtr& state) {\n+    AssertLockHeld(cs_main);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n         BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n@@ -347,10 +393,11 @@ void ProcessBlockAvailability(NodeId nodeid) {\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    AssertLockHeld(cs_main);\n+    NodeStatePtr state(nodeid);\n+    assert(!state.IsNull());\n \n-    ProcessBlockAvailability(nodeid);\n+    ProcessBlockAvailability(state);\n \n     BlockMap::iterator it = mapBlockIndex.find(hash);\n     if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {\n@@ -388,12 +435,13 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n     if (count == 0)\n         return;\n \n+    AssertLockHeld(cs_main);\n     vBlocks.reserve(vBlocks.size() + count);\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    NodeStatePtr state(nodeid);\n+    assert(!state.IsNull());\n \n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n-    ProcessBlockAvailability(nodeid);\n+    ProcessBlockAvailability(state);\n \n     if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n         // This peer has nothing interesting.\n@@ -469,9 +517,8 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n } // anon namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n-    LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n-    if (state == NULL)\n+    NodeStatePtr state(nodeid);\n+    if (state.IsNull())\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n@@ -1302,14 +1349,13 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n-// Requires cs_main.\n void Misbehaving(NodeId pnode, int howmuch)\n {\n     if (howmuch == 0)\n         return;\n \n-    CNodeState *state = State(pnode);\n-    if (state == NULL)\n+    NodeStatePtr state(pnode);\n+    if (state.IsNull())\n         return;\n \n     state->nMisbehavior += howmuch;\n@@ -1341,9 +1387,10 @@ void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state\n     int nDoS = 0;\n     if (state.IsInvalid(nDoS)) {\n         std::map<uint256, NodeId>::iterator it = mapBlockSource.find(pindex->GetBlockHash());\n-        if (it != mapBlockSource.end() && State(it->second)) {\n+        NodeStatePtr nodeState(it->second);\n+        if (it != mapBlockSource.end() && !nodeState.IsNull()) {\n             CBlockReject reject = {state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), pindex->GetBlockHash()};\n-            State(it->second)->rejects.push_back(reject);\n+            nodeState->rejects.push_back(reject);\n             if (nDoS > 0)\n                 Misbehaving(it->second, nDoS);\n         }\n@@ -3368,7 +3415,7 @@ void UnloadBlockIndex()\n     nPreferredDownload = 0;\n     setDirtyBlockIndex.clear();\n     setDirtyFileInfo.clear();\n-    mapNodeState.clear();\n+    NodeStatePtr::clear();\n \n     BOOST_FOREACH(BlockMap::value_type& entry, mapBlockIndex) {\n         delete entry.second;\n@@ -4011,7 +4058,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n         // Potentially mark this peer as a preferred download peer.\n-        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n+        {\n+            NodeStatePtr nodeState(pfrom->GetId());\n+            UpdatePreferredDownload(pfrom, nodeState);\n+        }\n \n         // Change version\n         pfrom->PushMessage(\"verack\");\n@@ -4085,8 +4135,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // Mark this node as currently connected, so we update its timestamp later.\n         if (pfrom->fNetworkNode) {\n-            LOCK(cs_main);\n-            State(pfrom->GetId())->fCurrentlyConnected = true;\n+            NodeStatePtr(pfrom->GetId())->fCurrentlyConnected = true;\n         }\n     }\n \n@@ -4197,7 +4246,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // doing this will result in the received block being rejected as an orphan in case it is\n                     // not a direct successor.\n                     pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexBestHeader), inv.hash);\n-                    CNodeState *nodestate = State(pfrom->GetId());\n+                    NodeStatePtr nodestate(pfrom->GetId());\n                     if (chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - chainparams.GetConsensus().nPowTargetSpacing * 20 &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         vToFetch.push_back(inv);\n@@ -4949,8 +4998,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 pto->PushMessage(\"addr\", vAddr);\n         }\n \n-        CNodeState &state = *State(pto->GetId());\n-        if (state.fShouldBan) {\n+        NodeStatePtr statePtr(pto->GetId());\n+        if (statePtr->fShouldBan) {\n             if (pto->fWhitelisted)\n                 LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n             else {\n@@ -4962,21 +5011,21 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     CNode::Ban(pto->addr);\n                 }\n             }\n-            state.fShouldBan = false;\n+            statePtr->fShouldBan = false;\n         }\n \n-        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n+        BOOST_FOREACH(const CBlockReject& reject, statePtr->rejects)\n             pto->PushMessage(\"reject\", (string)\"block\", reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n-        state.rejects.clear();\n+        statePtr->rejects.clear();\n \n         // Start block sync\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n-        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        bool fFetch = statePtr->fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n+        if (!statePtr->fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n-                state.fSyncStarted = true;\n+                statePtr->fSyncStarted = true;\n                 nSyncStarted++;\n                 CBlockIndex *pindexStart = pindexBestHeader->pprev ? pindexBestHeader->pprev : pindexBestHeader;\n                 LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n@@ -5042,7 +5091,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n         // Detect whether we're stalling\n         int64_t nNow = GetTimeMicros();\n-        if (!pto->fDisconnect && state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+        if (!pto->fDisconnect && statePtr->nStallingSince && statePtr->nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n@@ -5059,9 +5108,9 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // only looking at this peer's oldest request).  This way a large queue in the past doesn't result in a\n         // permanently large window for this block to be delivered (ie if the number of blocks in flight is decreasing\n         // more quickly than once every 5 minutes, then we'll shorten the download window for this block).\n-        if (!pto->fDisconnect && state.vBlocksInFlight.size() > 0) {\n-            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int64_t nTimeoutIfRequestedNow = GetBlockTimeout(nNow, nQueuedValidatedHeaders - state.nBlocksInFlightValidHeaders, consensusParams);\n+        if (!pto->fDisconnect && statePtr->vBlocksInFlight.size() > 0) {\n+            QueuedBlock &queuedBlock = statePtr->vBlocksInFlight.front();\n+            int64_t nTimeoutIfRequestedNow = GetBlockTimeout(nNow, nQueuedValidatedHeaders - statePtr->nBlocksInFlightValidHeaders, consensusParams);\n             if (queuedBlock.nTimeDisconnect > nTimeoutIfRequestedNow) {\n                 LogPrint(\"net\", \"Reducing block download timeout for peer=%d block=%s, orig=%d new=%d\\n\", pto->id, queuedBlock.hash.ToString(), queuedBlock.nTimeDisconnect, nTimeoutIfRequestedNow);\n                 queuedBlock.nTimeDisconnect = nTimeoutIfRequestedNow;\n@@ -5076,19 +5125,19 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && statePtr->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             vector<CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - statePtr->nBlocksInFlight, vToDownload, staller);\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n                 vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n                 LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->id);\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n-                if (State(staller)->nStallingSince == 0) {\n-                    State(staller)->nStallingSince = nNow;\n+            if (statePtr->nBlocksInFlight == 0 && staller != -1) {\n+                if (NodeStatePtr(staller)->nStallingSince == 0) {\n+                    NodeStatePtr(staller)->nStallingSince = nNow;\n                     LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "0e096a0d2a991979fd03ed291f7562423125f0bb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTA5NmEwZDJhOTkxOTc5ZmQwM2VkMjkxZjc1NjI0MjMxMjVmMGJi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-05T18:21:24Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T15:37:12Z"
      },
      "message": "Refactor, new CNode::FinalizeHeader method\n\nI need this to write some unit tests for the\nCNode::ReceiveMsgBytes() function.",
      "tree": {
        "sha": "20d1b6fe233812c14bc425ec3b52df1789698eb4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20d1b6fe233812c14bc425ec3b52df1789698eb4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e096a0d2a991979fd03ed291f7562423125f0bb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlLKgACgkQdYgkL74406gQGgCfUolZBNo3FQbH0KI1EotxuzPK\nLIYAoMWQcOaYbJfM2KbSnVE/d/dsDVB1\n=xF0A\n-----END PGP SIGNATURE-----",
        "payload": "tree 20d1b6fe233812c14bc425ec3b52df1789698eb4\nparent 03f877fad393bc53a71d0df4d7eb2f68fddd5ee1\nauthor Gavin Andresen <gavinandresen@gmail.com> 1433528484 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436888232 -0400\n\nRefactor, new CNode::FinalizeHeader method\n\nI need this to write some unit tests for the\nCNode::ReceiveMsgBytes() function.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e096a0d2a991979fd03ed291f7562423125f0bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e096a0d2a991979fd03ed291f7562423125f0bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e096a0d2a991979fd03ed291f7562423125f0bb/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/03f877fad393bc53a71d0df4d7eb2f68fddd5ee1"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 20,
      "deletions": 10
    },
    "files": [
      {
        "sha": "25c6bf5f5022e7b2feeb40b777e1e49b5685bb97",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 10,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e096a0d2a991979fd03ed291f7562423125f0bb/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e096a0d2a991979fd03ed291f7562423125f0bb/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=0e096a0d2a991979fd03ed291f7562423125f0bb",
        "patch": "@@ -614,6 +614,22 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n     return true;\n }\n \n+unsigned int CNetMessage::FinalizeHeader(CDataStream& s)\n+{\n+    // Set the size\n+    unsigned int nSize = s.size() - CMessageHeader::HEADER_SIZE;\n+    WriteLE32((uint8_t*)&s[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n+\n+    // Set the checksum\n+    uint256 hash = Hash(s.begin() + CMessageHeader::HEADER_SIZE, s.end());\n+    unsigned int nChecksum = 0;\n+    memcpy(&nChecksum, &hash, sizeof(nChecksum));\n+    assert(s.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n+    memcpy((char*)&s[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n+\n+    return nSize;\n+}\n+\n int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n {\n     // copy data to temporary parsing buffer\n@@ -2084,16 +2100,7 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n     if (ssSend.size() == 0)\n         return;\n \n-    // Set the size\n-    unsigned int nSize = ssSend.size() - CMessageHeader::HEADER_SIZE;\n-    WriteLE32((uint8_t*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n-\n-    // Set the checksum\n-    uint256 hash = Hash(ssSend.begin() + CMessageHeader::HEADER_SIZE, ssSend.end());\n-    unsigned int nChecksum = 0;\n-    memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-    assert(ssSend.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n-    memcpy((char*)&ssSend[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n+    unsigned int nSize = CNetMessage::FinalizeHeader(ssSend);\n \n     LogPrint(\"net\", \"(%d bytes) peer=%d\\n\", nSize, id);\n "
      },
      {
        "sha": "bdd8b0965eac087138c50c1b502e101ac1cc834d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e096a0d2a991979fd03ed291f7562423125f0bb/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e096a0d2a991979fd03ed291f7562423125f0bb/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=0e096a0d2a991979fd03ed291f7562423125f0bb",
        "patch": "@@ -210,6 +210,9 @@ class CNetMessage {\n         nTime = 0;\n     }\n \n+    // Called by CNode::EndMessage() and unit tests: modify stream to set size/checksum of header\n+    static unsigned int FinalizeHeader(CDataStream& s);\n+\n     bool complete() const\n     {\n         if (!in_data)"
      }
    ]
  },
  {
    "sha": "021122cf48b900365a594bee20780c8887a5731b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjExMjJjZjQ4YjkwMDM2NWE1OTRiZWUyMDc4MGM4ODg3YTU3MzFi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-05T19:09:21Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T15:37:13Z"
      },
      "message": "Unit test for CNode::ReceiveMsgBytes",
      "tree": {
        "sha": "4b782a369502806c9eadde073cdac3550d95d418",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b782a369502806c9eadde073cdac3550d95d418"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/021122cf48b900365a594bee20780c8887a5731b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlLKkACgkQdYgkL74406ga+QCeKlX8fFW/QYzaOaS473Wi9IBR\nrSkAn3S2iyuHhP6p41FXtgFaaFRTY00l\n=fin5\n-----END PGP SIGNATURE-----",
        "payload": "tree 4b782a369502806c9eadde073cdac3550d95d418\nparent 0e096a0d2a991979fd03ed291f7562423125f0bb\nauthor Gavin Andresen <gavinandresen@gmail.com> 1433531361 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436888233 -0400\n\nUnit test for CNode::ReceiveMsgBytes\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021122cf48b900365a594bee20780c8887a5731b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/021122cf48b900365a594bee20780c8887a5731b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021122cf48b900365a594bee20780c8887a5731b/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0e096a0d2a991979fd03ed291f7562423125f0bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e096a0d2a991979fd03ed291f7562423125f0bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0e096a0d2a991979fd03ed291f7562423125f0bb"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 90,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3643eca49ab3054e54707775cbc89c2f00d0b2eb",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021122cf48b900365a594bee20780c8887a5731b/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021122cf48b900365a594bee20780c8887a5731b/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=021122cf48b900365a594bee20780c8887a5731b",
        "patch": "@@ -59,6 +59,7 @@ BITCOIN_TESTS =\\\n   test/pmt_tests.cpp \\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n+  test/ReceiveMsgBytes_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\"
      },
      {
        "sha": "961e29864fe68044d62e30eb936021d278b5aad0",
        "filename": "src/test/ReceiveMsgBytes_tests.cpp",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021122cf48b900365a594bee20780c8887a5731b/src/test/ReceiveMsgBytes_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021122cf48b900365a594bee20780c8887a5731b/src/test/ReceiveMsgBytes_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ReceiveMsgBytes_tests.cpp?ref=021122cf48b900365a594bee20780c8887a5731b",
        "patch": "@@ -0,0 +1,89 @@\n+// Copyright (c) 2011-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+//\n+// Unit tests for CNode::ReceiveMsgBytes\n+//\n+\n+\n+#include \"main.h\"\n+#include \"net.h\"\n+#include \"pow.h\"\n+#include \"serialize.h\"\n+#include \"util.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(ReceiveMsgBytes_tests, TestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(FullMessages)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params().MessageStart(), \"ping\", 0);\n+    s << (uint64_t)11; // ping nonce\n+    CNetMessage::FinalizeHeader(s);\n+\n+    LOCK(testNode.cs_vRecvMsg);\n+\n+    // Receive a full 'ping' message\n+    {\n+        BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        CNetMessage& msg = testNode.vRecvMsg[0];\n+        BOOST_CHECK(msg.complete());\n+        BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n+        uint64_t nonce;\n+        msg.vRecv >> nonce;\n+        BOOST_CHECK_EQUAL(nonce, (uint64_t)11);\n+    }\n+\n+\n+    testNode.vRecvMsg.clear();\n+\n+    // ...receive it one byte at a time:\n+    {\n+        for (size_t i = 0; i < s.size(); i++) {\n+            BOOST_CHECK(testNode.ReceiveMsgBytes(&s[i], 1));\n+        }\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        CNetMessage& msg = testNode.vRecvMsg[0];\n+        BOOST_CHECK(msg.complete());\n+        BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n+        uint64_t nonce;\n+        msg.vRecv >> nonce;\n+        BOOST_CHECK_EQUAL(nonce, (uint64_t)11);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(TooLarge)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params().MessageStart(), \"ping\", 0);\n+    size_t headerLen = s.size();\n+    s << (uint64_t)11; // ping nonce\n+\n+    // Test: too large\n+    s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen+1);\n+    CNetMessage::FinalizeHeader(s);\n+\n+    BOOST_CHECK(!testNode.ReceiveMsgBytes(&s[0], s.size()));\n+\n+    testNode.vRecvMsg.clear();\n+\n+    // Test: exactly at max:\n+    s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen);\n+    CNetMessage::FinalizeHeader(s);\n+\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MThkOWY0ZmRmZTg2ZWY0OTdiYjlhMDM0NWY1OWE1MmFmMjIyMWNl",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-05T20:44:18Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T15:37:13Z"
      },
      "message": "Allow per-message sanity checking when reading from wire",
      "tree": {
        "sha": "dd55f12f5bdc5ebd1ff55400f5c486cb9653d2f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dd55f12f5bdc5ebd1ff55400f5c486cb9653d2f0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlLKkACgkQdYgkL74406i4mwCeKTA2Wb3WeAsX18M7wyqq6H8n\nHLkAn3kdHXoWIyjhWZ1P6eLRcwLQwuHY\n=vbRp\n-----END PGP SIGNATURE-----",
        "payload": "tree dd55f12f5bdc5ebd1ff55400f5c486cb9653d2f0\nparent 021122cf48b900365a594bee20780c8887a5731b\nauthor Gavin Andresen <gavinandresen@gmail.com> 1433537058 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436888233 -0400\n\nAllow per-message sanity checking when reading from wire\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "021122cf48b900365a594bee20780c8887a5731b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021122cf48b900365a594bee20780c8887a5731b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/021122cf48b900365a594bee20780c8887a5731b"
      }
    ],
    "stats": {
      "total": 106,
      "additions": 93,
      "deletions": 13
    },
    "files": [
      {
        "sha": "65905eb4eb2b1695d17b614afdc10e926a3f259d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "patch": "@@ -27,6 +27,7 @@\n #include <sstream>\n \n #include <boost/algorithm/string/replace.hpp>\n+#include <boost/assign/list_of.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n #include <boost/math/distributions/poisson.hpp>\n@@ -76,6 +77,8 @@ map<uint256, COrphanTx> mapOrphanTransactions;\n map<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n void EraseOrphansFor(NodeId peer);\n \n+static bool SanityCheckMessage(CNode* peer, const CNetMessage& msg);\n+\n /**\n  * Returns true if there are nRequired or more blocks of minVersion or above\n  * in the last Consensus::Params::nMajorityWindow blocks, starting at pstart and going backwards.\n@@ -533,6 +536,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n void RegisterNodeSignals(CNodeSignals& nodeSignals)\n {\n     nodeSignals.GetHeight.connect(&GetHeight);\n+    nodeSignals.SanityCheckMessages.connect(&SanityCheckMessage);\n     nodeSignals.ProcessMessages.connect(&ProcessMessages);\n     nodeSignals.SendMessages.connect(&SendMessages);\n     nodeSignals.InitializeNode.connect(&InitializeNode);\n@@ -542,6 +546,7 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals)\n void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n {\n     nodeSignals.GetHeight.disconnect(&GetHeight);\n+    nodeSignals.SanityCheckMessages.disconnect(&SanityCheckMessage);\n     nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n     nodeSignals.SendMessages.disconnect(&SendMessages);\n     nodeSignals.InitializeNode.disconnect(&InitializeNode);\n@@ -3831,6 +3836,30 @@ std::string GetWarnings(const std::string& strFor)\n // Messages\n //\n \n+static std::map<std::string, size_t> maxMessageSizes = boost::assign::map_list_of\n+    (\"getaddr\",0)\n+    (\"mempool\",0)\n+    (\"ping\",8)\n+    (\"pong\",8)\n+    (\"verack\", 0)\n+    ;\n+\n+bool static SanityCheckMessage(CNode* peer, const CNetMessage& msg)\n+{\n+    const std::string& strCommand = msg.hdr.GetCommand();\n+    if (msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH ||\n+        (maxMessageSizes.count(strCommand) && msg.hdr.nMessageSize > maxMessageSizes[strCommand])) {\n+        LogPrint(\"net\", \"Oversized %s message from peer=%i (%d bytes)\\n\",\n+                 SanitizeString(strCommand), peer->GetId(), msg.hdr.nMessageSize);\n+        Misbehaving(peer->GetId(), 20);\n+        return msg.hdr.nMessageSize <= MAX_PROTOCOL_MESSAGE_LENGTH;\n+    }\n+    // This would be a good place for more sophisticated DoS detection/prevention.\n+    // (e.g. disconnect a peer that is flooding us with excessive messages)\n+\n+    return true;\n+}\n+\n \n bool static AlreadyHave(const CInv& inv)\n {"
      },
      {
        "sha": "86b3f40ef8af62cdcfcff99f6385a32da125aa78",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "patch": "@@ -90,6 +90,8 @@ static const unsigned int DATABASE_WRITE_INTERVAL = 60 * 60;\n static const unsigned int DATABASE_FLUSH_INTERVAL = 24 * 60 * 60;\n /** Maximum length of reject messages. */\n static const unsigned int MAX_REJECT_MESSAGE_LENGTH = 111;\n+/** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n \n struct BlockHasher\n {"
      },
      {
        "sha": "90e0d37759d2d0671ff1f8a5704c82df2f090279",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "patch": "@@ -595,12 +595,10 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n             handled = msg.readData(pch, nBytes);\n \n         if (handled < 0)\n-                return false;\n+            return false;\n \n-        if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n-            LogPrint(\"net\", \"Oversized message from peer=%i, disconnecting\", GetId());\n+        if (msg.in_data && !g_signals.SanityCheckMessages(this, boost::ref(msg)))\n             return false;\n-        }\n \n         pch += handled;\n         nBytes -= handled;"
      },
      {
        "sha": "49215c60c8fe498434838c23733004ef99794722",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "patch": "@@ -33,6 +33,7 @@\n class CAddrMan;\n class CBlockIndex;\n class CScheduler;\n+class CNetMessage;\n class CNode;\n \n namespace boost {\n@@ -47,8 +48,6 @@ static const int TIMEOUT_INTERVAL = 20 * 60;\n static const unsigned int MAX_INV_SZ = 50000;\n /** The maximum number of new addresses to accumulate before announcing. */\n static const unsigned int MAX_ADDR_TO_SEND = 1000;\n-/** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n-static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n /** -listen default */\n static const bool DEFAULT_LISTEN = true;\n /** -upnp default */\n@@ -95,10 +94,14 @@ struct CombinerAll\n     }\n };\n \n-// Signals for message handling\n+// Signals are used to communicate with higher-level code.\n struct CNodeSignals\n {\n     boost::signals2::signal<int ()> GetHeight;\n+    // register a handler for this signal to do sanity checks as the bytes of a message are being\n+    // received. Note that the message may not be completely read (so this can be\n+    // used to prevent DoS attacks using over-size messages).\n+    boost::signals2::signal<bool (CNode*, const CNetMessage&), CombinerAll> SanityCheckMessages;\n     boost::signals2::signal<bool (CNode*), CombinerAll> ProcessMessages;\n     boost::signals2::signal<bool (CNode*, bool), CombinerAll> SendMessages;\n     boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;"
      },
      {
        "sha": "0d75c67f0730a29ea6f16531f2d3898cbeb977e3",
        "filename": "src/test/ReceiveMsgBytes_tests.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 6,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/test/ReceiveMsgBytes_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/src/test/ReceiveMsgBytes_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ReceiveMsgBytes_tests.cpp?ref=618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "patch": "@@ -34,7 +34,7 @@ BOOST_AUTO_TEST_CASE(FullMessages)\n     // Receive a full 'ping' message\n     {\n         BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n-        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(),1UL);\n         CNetMessage& msg = testNode.vRecvMsg[0];\n         BOOST_CHECK(msg.complete());\n         BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n@@ -51,25 +51,31 @@ BOOST_AUTO_TEST_CASE(FullMessages)\n         for (size_t i = 0; i < s.size(); i++) {\n             BOOST_CHECK(testNode.ReceiveMsgBytes(&s[i], 1));\n         }\n-        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(), 1);\n+        BOOST_CHECK_EQUAL(testNode.vRecvMsg.size(),1UL);\n         CNetMessage& msg = testNode.vRecvMsg[0];\n         BOOST_CHECK(msg.complete());\n         BOOST_CHECK_EQUAL(msg.hdr.GetCommand(), \"ping\");\n         uint64_t nonce;\n         msg.vRecv >> nonce;\n         BOOST_CHECK_EQUAL(nonce, (uint64_t)11);\n-    }\n+   }\n }\n \n-BOOST_AUTO_TEST_CASE(TooLarge)\n+BOOST_AUTO_TEST_CASE(TooLargeBlock)\n {\n+    // Random real block (000000000000dab0130bbcc991d3d7ae6b81aa6f50a798888dfe62337458dc45)\n+    // With one tx\n+    CBlock block;\n+    CDataStream stream(ParseHex(\"0100000079cda856b143d9db2c1caff01d1aecc8630d30625d10e8b4b8b0000000000000b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f196367291b4d4c86041b8fa45d630101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff08044c86041b020a02ffffffff0100f2052a01000000434104ecd3229b0571c3be876feaac0442a9f13c5a572742927af1dc623353ecf8c202225f64868137a18cdd85cbbb4c74fbccfd4f49639cf1bdc94a5672bb15ad5d4cac00000000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    stream >> block;\n+\n     CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n     testNode.nVersion = 1;\n \n     CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n-    s << CMessageHeader(Params().MessageStart(), \"ping\", 0);\n+    s << CMessageHeader(Params().MessageStart(), \"block\", 0);\n     size_t headerLen = s.size();\n-    s << (uint64_t)11; // ping nonce\n+    s << block;\n \n     // Test: too large\n     s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen+1);\n@@ -86,4 +92,46 @@ BOOST_AUTO_TEST_CASE(TooLarge)\n     BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n }\n \n+BOOST_AUTO_TEST_CASE(TooLargeVerack)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params().MessageStart(), \"verack\", 0);\n+    size_t headerLen = s.size();\n+\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+\n+    // verack is zero-length, so even one byte bigger is too big:\n+    s.resize(headerLen+1);\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+    CNodeStateStats stats;\n+    GetNodeStateStats(testNode.GetId(), stats);\n+    BOOST_CHECK(stats.nMisbehavior > 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(TooLargePing)\n+{\n+    CNode testNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), NODE_NETWORK));\n+    testNode.nVersion = 1;\n+\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    s << CMessageHeader(Params().MessageStart(), \"ping\", 0);\n+    s << (uint64_t)11; // 8-byte nonce\n+\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+\n+    // Add another nonce, sanity check should fail\n+    s << (uint64_t)11; // 8-byte nonce\n+    CNetMessage::FinalizeHeader(s);\n+    BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));\n+    CNodeStateStats stats;\n+    GetNodeStateStats(testNode.GetId(), stats);\n+    BOOST_CHECK(stats.nMisbehavior > 0);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "714852722960d6851890b4eb2939bb66d1cd7f2e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MTQ4NTI3MjI5NjBkNjg1MTg5MGI0ZWIyOTM5YmI2NmQxY2Q3ZjJl",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-16T16:12:03Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T18:22:41Z"
      },
      "message": "Implement hard fork to allow bigger blocks\n\nUnit test and code for a bigger-block hard fork.\nParameters are:\n  8MB cap\n  ... doubling every two years (so 16MB in 2018)\n  ... for twenty years\n  ... earliest possible chain fork: 11 Jan 2016\n  ... after miner supermajority (code in the next patch)\n  ... and grace period once miner supermajority achieved (code in next patch)",
      "tree": {
        "sha": "274f96a179683a8a81a78ef20accdd5e88fd1ecf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/274f96a179683a8a81a78ef20accdd5e88fd1ecf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/714852722960d6851890b4eb2939bb66d1cd7f2e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlU4AACgkQdYgkL74406hoEwCdE2dhjzyGUWusUxfhHhY/qvJH\nL4oAoIkXah9OntVmj2wsHfvTorzJPPm2\n=HgWv\n-----END PGP SIGNATURE-----",
        "payload": "tree 274f96a179683a8a81a78ef20accdd5e88fd1ecf\nparent 618d9f4fdfe86ef497bb9a0345f59a52af2221ce\nauthor Gavin Andresen <gavinandresen@gmail.com> 1434471123 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436898161 -0400\n\nImplement hard fork to allow bigger blocks\n\nUnit test and code for a bigger-block hard fork.\nParameters are:\n  8MB cap\n  ... doubling every two years (so 16MB in 2018)\n  ... for twenty years\n  ... earliest possible chain fork: 11 Jan 2016\n  ... after miner supermajority (code in the next patch)\n  ... and grace period once miner supermajority achieved (code in next patch)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/714852722960d6851890b4eb2939bb66d1cd7f2e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/714852722960d6851890b4eb2939bb66d1cd7f2e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/714852722960d6851890b4eb2939bb66d1cd7f2e/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/618d9f4fdfe86ef497bb9a0345f59a52af2221ce"
      }
    ],
    "stats": {
      "total": 546,
      "additions": 386,
      "deletions": 160
    },
    "files": [
      {
        "sha": "467d7cfce73279d0fd90b76632b6e5d2d9e47c9d",
        "filename": "qa/rpc-tests/bipdersig-p2p.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/qa/rpc-tests/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/qa/rpc-tests/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig-p2p.py?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -35,10 +35,10 @@ def unDERify(tx):\n Connect to a single node.\n Mine 2 (version 2) blocks (save the coinbases for later).\n Generate 98 more version 2 blocks, verify the node accepts.\n-Mine 749 version 3 blocks, verify the node accepts.\n-Check that the new DERSIG rules are not enforced on the 750th version 3 block.\n-Check that the new DERSIG rules are enforced on the 751st version 3 block.\n-Mine 199 new version blocks.\n+Mine 74 version 3 blocks, verify the node accepts.\n+Check that the new DERSIG rules are not enforced on the 75th version 3 block.\n+Check that the new DERSIG rules are enforced on the 76th version 3 block.\n+Mine 19 new version blocks.\n Mine 1 old-version block.\n Mine 1 new version block.\n Mine 1 old version block, see that the node rejects.\n@@ -91,9 +91,9 @@ def get_tests(self):\n             self.tip = block.sha256\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n-        ''' Mine 749 version 3 blocks '''\n+        ''' Mine 74 version 3 blocks '''\n         test_blocks = []\n-        for i in xrange(749):\n+        for i in xrange(74):\n             block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n             block.nVersion = 3\n             block.rehash()\n@@ -104,7 +104,7 @@ def get_tests(self):\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n         ''' \n-        Check that the new DERSIG rules are not enforced in the 750th\n+        Check that the new DERSIG rules are not enforced in the 75th\n         version 3 block.\n         '''\n         spendtx = self.create_transaction(self.nodes[0],\n@@ -124,7 +124,7 @@ def get_tests(self):\n         yield TestInstance([[block, True]])\n \n         ''' \n-        Check that the new DERSIG rules are enforced in the 751st version 3\n+        Check that the new DERSIG rules are enforced in the 76th version 3\n         block.\n         '''\n         spendtx = self.create_transaction(self.nodes[0],\n@@ -141,9 +141,9 @@ def get_tests(self):\n         self.last_block_time += 1\n         yield TestInstance([[block, False]])\n \n-        ''' Mine 199 new version blocks on last valid tip '''\n+        ''' Mine 19 new version blocks on last valid tip '''\n         test_blocks = []\n-        for i in xrange(199):\n+        for i in xrange(19):\n             block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n             block.nVersion = 3\n             block.rehash()"
      },
      {
        "sha": "243f816f652647739a8f3833fbede7f3f96f4478",
        "filename": "qa/rpc-tests/bipdersig.py",
        "status": "removed",
        "additions": 0,
        "deletions": 89,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/qa/rpc-tests/bipdersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/618d9f4fdfe86ef497bb9a0345f59a52af2221ce/qa/rpc-tests/bipdersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig.py?ref=618d9f4fdfe86ef497bb9a0345f59a52af2221ce",
        "patch": "@@ -1,89 +0,0 @@\n-#!/usr/bin/env python2\n-# Copyright (c) 2014 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#\n-# Test the BIP66 changeover logic\n-#\n-\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-import os\n-import shutil\n-\n-class BIP66Test(BitcoinTestFramework):\n-\n-    def setup_network(self):\n-        self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, []))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockversion=2\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockversion=3\"]))\n-        connect_nodes(self.nodes[1], 0)\n-        connect_nodes(self.nodes[2], 0)\n-        self.is_network_split = False\n-        self.sync_all()\n-\n-    def run_test(self):\n-        cnt = self.nodes[0].getblockcount()\n-\n-        # Mine some old-version blocks\n-        self.nodes[1].generate(100)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 100):\n-            raise AssertionError(\"Failed to mine 100 version=2 blocks\")\n-\n-        # Mine 750 new-version blocks\n-        for i in xrange(15):\n-            self.nodes[2].generate(50)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 850):\n-            raise AssertionError(\"Failed to mine 750 version=3 blocks\")\n-\n-        # TODO: check that new DERSIG rules are not enforced\n-\n-        # Mine 1 new-version block\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 851):\n-            raise AssertionFailure(\"Failed to mine a version=3 blocks\")\n-\n-        # TODO: check that new DERSIG rules are enforced\n-\n-        # Mine 198 new-version blocks\n-        for i in xrange(2):\n-            self.nodes[2].generate(99)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1049):\n-            raise AssertionError(\"Failed to mine 198 version=3 blocks\")\n-\n-        # Mine 1 old-version block\n-        self.nodes[1].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1050):\n-            raise AssertionError(\"Failed to mine a version=2 block after 949 version=3 blocks\")\n-\n-        # Mine 1 new-version blocks\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1051):\n-            raise AssertionError(\"Failed to mine a version=3 block\")\n-\n-        # Mine 1 old-version blocks\n-        try:\n-            self.nodes[1].generate(1)\n-            raise AssertionError(\"Succeeded to mine a version=2 block after 950 version=3 blocks\")\n-        except JSONRPCException:\n-            pass\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1051):\n-            raise AssertionError(\"Accepted a version=2 block after 950 version=3 blocks\")\n-\n-        # Mine 1 new-version blocks\n-        self.nodes[2].generate(1)\n-        self.sync_all()\n-        if (self.nodes[0].getblockcount() != cnt + 1052):\n-            raise AssertionError(\"Failed to mine a version=3 block\")\n-\n-if __name__ == '__main__':\n-    BIP66Test().main()"
      },
      {
        "sha": "abe0049019d07f465b63ef92b10accb309a90ebc",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -40,6 +40,7 @@ BITCOIN_TESTS =\\\n   test/base58_tests.cpp \\\n   test/base64_tests.cpp \\\n   test/bip32_tests.cpp \\\n+  test/block_size_tests.cpp \\\n   test/bloom_tests.cpp \\\n   test/checkblock_tests.cpp \\\n   test/Checkpoints_tests.cpp \\"
      },
      {
        "sha": "67e451653b284864e5e4f138d3907c065c960e74",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -187,7 +187,9 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n     uint256 txid(uint256S(strTxid));\n \n     static const unsigned int minTxOutSz = 9;\n-    static const unsigned int maxVout = MAX_BLOCK_SIZE / minTxOutSz;\n+    // Don't know if the reduce max transaction size fork has activated yet or not;\n+    // assume it has if after the earliest fork time.\n+    unsigned int maxVout = Params().MaxTransactionSize(GetTime(), GetTime()) / minTxOutSz;\n \n     // extract and validate vout\n     string strVout = strInput.substr(pos + 1, string::npos);"
      },
      {
        "sha": "52fc0c4a2a57ad9721b2a097dfdff185d7daa575",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -53,6 +53,17 @@ class CMainParams : public CChainParams {\n         nMinerThreads = 0;\n         nPruneAfterHeight = 100000;\n \n+        // Timestamps for forking consensus rule changes:\n+        //  Allow bigger blocks\n+        //  Limit transactions to 100,000 bytes\n+        nEarliestSizeForkTime = 1452470400; // 11 Jan 2016 00:00:00 UTC\n+        // 1MB max blocks before 11 Jan 2016\n+        // Then, if miner consensus: 8MB max, doubling every two years\n+        nMaxSizePreFork = 1000*1000; // 1MB max pre-fork\n+        nSizeDoubleEpoch = 60*60*24*365*2; // two years\n+        nMaxSizeBase = 8*1000*1000; // 8MB\n+        nMaxSizeDoublings = 10;\n+\n         /**\n          * Build the genesis block. Note that the output of its generation\n          * transaction cannot be spent since it did not originally exist in the\n@@ -150,6 +161,14 @@ class CTestNetParams : public CMainParams {\n         nMinerThreads = 0;\n         nPruneAfterHeight = 1000;\n \n+        // 1MB max blocks before 1 Aug 2015\n+        // Then, if miner consensus: 8MB max, doubling every two years\n+        nMaxSizePreFork = 1000*1000; // 1MB max pre-fork\n+        nEarliestSizeForkTime = 1438387200; // 1 Aug 2015 00:00:00 UTC\n+        nSizeDoubleEpoch = 60*60*24*365*2; // two years\n+        nMaxSizeBase = 8*1000*1000; // 8MB\n+        nMaxSizeDoublings = 10;\n+\n         //! Modify the testnet genesis block so the timestamp is valid for a later start.\n         genesis.nTime = 1296688602;\n         genesis.nNonce = 414098458;\n@@ -198,9 +217,10 @@ class CRegTestParams : public CTestNetParams {\n     CRegTestParams() {\n         strNetworkID = \"regtest\";\n         consensus.nSubsidyHalvingInterval = 150;\n-        consensus.nMajorityEnforceBlockUpgrade = 750;\n-        consensus.nMajorityRejectBlockOutdated = 950;\n-        consensus.nMajorityWindow = 1000;\n+        // Make forks on regtest the same as mainnet but 10x easier, to speed up the regression tests.\n+        consensus.nMajorityEnforceBlockUpgrade = 75;\n+        consensus.nMajorityRejectBlockOutdated = 95;\n+        consensus.nMajorityWindow = 100;\n         consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         pchMessageStart[0] = 0xfa;\n         pchMessageStart[1] = 0xbf;"
      },
      {
        "sha": "893c210c6ba64981934baba0c7444e9566f9dca8",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -12,6 +12,7 @@\n #include \"primitives/block.h\"\n #include \"protocol.h\"\n \n+#include <limits>\n #include <vector>\n \n struct CDNSSeedData {\n@@ -71,6 +72,38 @@ class CChainParams\n     const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n     const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n     const Checkpoints::CCheckpointData& Checkpoints() const { return checkpointData; }\n+\n+    /** Maximum block size of a block with timestamp nBlockTimestamp */\n+    uint64_t MaxBlockSize(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n+        if (nBlockTimestamp < nEarliestSizeForkTime || nBlockTimestamp < nSizeForkActivationTime)\n+            return nMaxSizePreFork;\n+        if (nBlockTimestamp >= nEarliestSizeForkTime + nSizeDoubleEpoch * nMaxSizeDoublings)\n+            return nMaxSizeBase << nMaxSizeDoublings;\n+\n+        // Piecewise-linear-between-doublings growth. Calculated based on a fixed\n+        // timestamp and not the activation time so the maximum size is\n+        // predictable, and so the activation time can be completely removed in\n+        // a future version of this code after the fork is complete.\n+        uint64_t timeDelta = nBlockTimestamp - nEarliestSizeForkTime;\n+        uint64_t doublings = timeDelta / nSizeDoubleEpoch;\n+        uint64_t remain = timeDelta % nSizeDoubleEpoch;\n+        uint64_t interpolate = (nMaxSizeBase << doublings) * remain / nSizeDoubleEpoch;\n+        uint64_t nMaxSize = (nMaxSizeBase << doublings) + interpolate;\n+        return nMaxSize;\n+    }\n+    /** Maximum number of signature ops in a block with timestamp nBlockTimestamp */\n+    uint64_t MaxBlockSigops(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n+        return MaxBlockSize(nBlockTimestamp, nSizeForkActivationTime)/50;\n+    }\n+    /** Maximum size of a transaction in a block with timestamp nBlockTimestamp */\n+    uint64_t MaxTransactionSize(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n+        if (nBlockTimestamp < nEarliestSizeForkTime || nBlockTimestamp < nSizeForkActivationTime)\n+            return nMaxSizePreFork;\n+        return 100*1000;\n+    }\n+    int ActivateSizeForkMajority() const { return nActivateSizeForkMajority; }\n+    uint64_t SizeForkGracePeriod() const { return nSizeForkGracePeriod; }\n+\n protected:\n     CChainParams() {}\n \n@@ -79,6 +112,16 @@ class CChainParams\n     //! Raw pub key bytes for the broadcast alert signing key.\n     std::vector<unsigned char> vAlertPubKey;\n     int nDefaultPort;\n+\n+    /** Maximum block size parameters */\n+    uint32_t nMaxSizePreFork;\n+    uint64_t nEarliestSizeForkTime;\n+    uint32_t nSizeDoubleEpoch;\n+    uint64_t nMaxSizeBase;\n+    uint8_t nMaxSizeDoublings;\n+    int nActivateSizeForkMajority;\n+    uint64_t nSizeForkGracePeriod;\n+\n     int nMinerThreads;\n     uint64_t nPruneAfterHeight;\n     std::vector<CDNSSeedData> vSeeds;"
      },
      {
        "sha": "85902581d934c6c71bedca6cab8e4f7e0762007a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 11,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -64,6 +64,8 @@ size_t nCoinCacheUsage = 5000 * 300;\n uint64_t nPruneTarget = 0;\n bool fAlerts = DEFAULT_ALERTS;\n \n+SizeForkTime sizeForkTime(std::numeric_limits<uint64_t>::max());\n+\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n CFeeRate minRelayTxFee = CFeeRate(1000);\n \n@@ -848,7 +850,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n \n \n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, uint64_t nMaxTxSize)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -858,7 +860,8 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n         return state.DoS(10, error(\"CheckTransaction(): vout empty\"),\n                          REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits\n-    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+    size_t txSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+    if (txSize > nMaxTxSize)\n         return state.DoS(100, error(\"CheckTransaction(): size limits failed\"),\n                          REJECT_INVALID, \"bad-txns-oversize\");\n \n@@ -942,7 +945,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n-    if (!CheckTransaction(tx, state))\n+    if (!CheckTransaction(tx, state, Params().MaxTransactionSize(GetAdjustedTime(), sizeForkTime.load())))\n         return error(\"AcceptToMemoryPool: CheckTransaction failed\");\n \n     // Coinbase is only valid in a block, not as a loose transaction\n@@ -1922,7 +1925,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n         nInputs += tx.vin.size();\n         nSigOps += GetLegacySigOpCount(tx);\n-        if (nSigOps > MAX_BLOCK_SIGOPS)\n+        if (nSigOps > Params().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n             return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n@@ -1938,7 +1941,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 // this is to prevent a \"rogue miner\" from creating\n                 // an incredibly-expensive-to-validate block.\n                 nSigOps += GetP2SHSigOpCount(tx, view);\n-                if (nSigOps > MAX_BLOCK_SIGOPS)\n+                if (nSigOps > Params().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n                     return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                                      REJECT_INVALID, \"bad-blk-sigops\");\n             }\n@@ -2641,7 +2644,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n     }\n \n     if (!fKnown) {\n-        while (vinfoBlockFile[nFile].nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n+        while (vinfoBlockFile[nFile].nSize + nAddSize >= Params().MaxBlockSize(nTime, sizeForkTime.load())*MIN_BLOCKFILE_BLOCKS) {\n             LogPrintf(\"Leaving block file %i: %s\\n\", nFile, vinfoBlockFile[nFile].ToString());\n             FlushBlockFile(true);\n             nFile++;\n@@ -2759,7 +2762,9 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     // because we receive the wrong transactions for it.\n \n     // Size limits\n-    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+    uint64_t nMaxBlockSize = Params().MaxBlockSize(block.GetBlockTime(), sizeForkTime.load());\n+    uint64_t nMaxTxSize = Params().MaxTransactionSize(block.GetBlockTime(), sizeForkTime.load());\n+    if (block.vtx.empty() || block.vtx.size() > nMaxBlockSize || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > nMaxBlockSize)\n         return state.DoS(100, error(\"CheckBlock(): size limits failed\"),\n                          REJECT_INVALID, \"bad-blk-length\");\n \n@@ -2774,15 +2779,15 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n \n     // Check transactions\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-        if (!CheckTransaction(tx, state))\n+        if (!CheckTransaction(tx, state, nMaxTxSize))\n             return error(\"CheckBlock(): CheckTransaction failed\");\n \n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n-    if (nSigOps > MAX_BLOCK_SIGOPS)\n+    if (nSigOps > Params().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n         return state.DoS(100, error(\"CheckBlock(): out-of-bounds SigOpCount\"),\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n@@ -3489,7 +3494,8 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n     int nLoaded = 0;\n     try {\n         // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor\n-        CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n+        uint64_t nMaxBlocksize = Params().MaxBlockSize(GetAdjustedTime(), sizeForkTime.load());\n+        CBufferedFile blkdat(fileIn, 2*nMaxBlocksize, nMaxBlocksize+8, SER_DISK, CLIENT_VERSION);\n         uint64_t nRewind = blkdat.GetPos();\n         while (!blkdat.eof()) {\n             boost::this_thread::interruption_point();\n@@ -3508,7 +3514,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                     continue;\n                 // read size\n                 blkdat >> nSize;\n-                if (nSize < 80 || nSize > MAX_BLOCK_SIZE)\n+                if (nSize < 80 || nSize > nMaxBlocksize)\n                     continue;\n             } catch (const std::exception&) {\n                 // no valid block header found; don't complain\n@@ -5202,6 +5208,20 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n      return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast));\n  }\n \n+SizeForkTime::SizeForkTime(uint64_t _t)\n+{\n+    t = _t;\n+}\n+uint64_t SizeForkTime::load() const\n+{\n+    LOCK(cs);\n+    return t;\n+}\n+void SizeForkTime::store(uint64_t _t)\n+{\n+    LOCK(cs);\n+    t = _t;\n+}\n \n \n class CMainCleanup"
      },
      {
        "sha": "1c3f1f2ac6166f370c8193548da2d21c301f14fe",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 20,
        "deletions": 4,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -59,11 +59,11 @@ static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n /** Maximum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n-static const unsigned int MAX_STANDARD_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;\n+static const unsigned int MAX_STANDARD_TX_SIGOPS = MAX_STANDARD_TX_SIZE/25; // one sigop per 25 bytes\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n-/** The maximum size of a blk?????.dat file (since 0.8) */\n-static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n+/** Minimum number of max-sized blocks in blk?????.dat files */\n+static const unsigned int MIN_BLOCKFILE_BLOCKS = 128;\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */\n static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n /** The pre-allocation chunk size for rev?????.dat files (since 0.8) */\n@@ -323,7 +323,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, int nHeight);\n \n /** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, uint64_t nMaxTransactionSize);\n \n /** Check for standard transaction types\n  * @return True if all outputs (scriptPubKeys) use only standard transaction forms\n@@ -499,4 +499,20 @@ extern CBlockTreeDB *pblocktree;\n  */\n int GetSpendHeight(const CCoinsViewCache& inputs);\n \n+// Time when bigger-than-1MB-blocks are allowed\n+class SizeForkTime {\n+public:\n+    SizeForkTime(uint64_t _t);\n+\n+    // Same interface as std::atomic -- when c++11 is supported,\n+    // this class can go away and sizeForkTime can just be type\n+    // std::atomic<uint64_t>\n+    uint64_t load() const;\n+    void store(uint64_t _t);\n+private:\n+    mutable CCriticalSection cs;\n+    uint64_t t;\n+};\n+extern SizeForkTime sizeForkTime;\n+\n #endif // BITCOIN_MAIN_H"
      },
      {
        "sha": "c6f711448bf53ac511dc4f3ec2999a3e31841ead",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -147,13 +147,13 @@ CPartialMerkleTree::CPartialMerkleTree(const std::vector<uint256> &vTxid, const\n \n CPartialMerkleTree::CPartialMerkleTree() : nTransactions(0), fBad(true) {}\n \n-uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n+uint256 CPartialMerkleTree::ExtractMatches(uint64_t nMaxTransactions, std::vector<uint256> &vMatch) {\n     vMatch.clear();\n     // An empty set will not work\n     if (nTransactions == 0)\n         return uint256();\n     // check for excessively high numbers of transactions\n-    if (nTransactions > MAX_BLOCK_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n+    if (nTransactions > nMaxTransactions)\n         return uint256();\n     // there can never be more hashes provided than one for every txid\n     if (vHash.size() > nTransactions)"
      },
      {
        "sha": "5dff7b60ac823e8f37b0434df376dd5c298d09fa",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -113,7 +113,7 @@ class CPartialMerkleTree\n      * extract the matching txid's represented by this partial merkle tree.\n      * returns the merkle root, or 0 in case of failure\n      */\n-    uint256 ExtractMatches(std::vector<uint256> &vMatch);\n+    uint256 ExtractMatches(uint64_t nMaxTransactions, std::vector<uint256> &vMatch);\n };\n \n \n@@ -144,6 +144,8 @@ class CMerkleBlock\n \n     CMerkleBlock() {}\n \n+    int64_t GetBlockTime() { return header.GetBlockTime(); }\n+\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>"
      },
      {
        "sha": "26ac8be8a54cf0f2bdd75372f72d2ef271a37344",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 17,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -114,21 +114,6 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n-    // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n-\n-    // How much of the block should be dedicated to high-priority transactions,\n-    // included regardless of the fees they pay\n-    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n-    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n-\n-    // Minimum block size you want to create; block will be filled with free transactions\n-    // until there are no more or the block reaches this size:\n-    unsigned int nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n-    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n-\n     // Collect memory pool transactions into the block\n     CAmount nFees = 0;\n \n@@ -139,6 +124,26 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         pblock->nTime = GetAdjustedTime();\n         CCoinsViewCache view(pcoinsTip);\n \n+        UpdateTime(pblock, Params().GetConsensus(), pindexPrev);\n+        uint64_t nBlockTime = pblock->GetBlockTime();\n+\n+        // Largest block you're willing to create:\n+        uint64_t nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+        uint64_t nConsensusMaxSize = Params().MaxBlockSize(nBlockTime, sizeForkTime.load());\n+        // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n+        nBlockMaxSize = std::max((uint64_t)1000,\n+                                 std::min(nConsensusMaxSize-1000, nBlockMaxSize));\n+\n+        // How much of the block should be dedicated to high-priority transactions,\n+        // included regardless of the fees they pay\n+        uint64_t nBlockPrioritySize = GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE);\n+        nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n+\n+        // Minimum block size you want to create; block will be filled with free transactions\n+        // until there are no more or the block reaches this size:\n+        uint64_t nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n+        nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+\n         // Priority order to process transactions\n         list<COrphan> vOrphan; // list memory doesn't move\n         map<uint256, vector<COrphan*> > mapDependers;\n@@ -244,7 +249,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n             // Legacy limits on sigOps:\n             unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            if (nBlockSigOps + nTxSigOps >= Params().MaxBlockSigops(nBlockTime, sizeForkTime.load()))\n                 continue;\n \n             // Skip free transactions if we're past the minimum block size:\n@@ -271,7 +276,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             CAmount nTxFees = view.GetValueIn(tx)-tx.GetValueOut();\n \n             nTxSigOps += GetP2SHSigOpCount(tx, view);\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n+            if (nBlockSigOps + nTxSigOps >= Params().MaxBlockSigops(nBlockTime, sizeForkTime.load()))\n                 continue;\n \n             // Note that flags: we don't want to set mempool/IsStandard()"
      },
      {
        "sha": "074a6f5ad9ea27e983982cebd430c467ea5159f4",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -364,6 +364,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"  \\\"noncerange\\\" : \\\"00000000ffffffff\\\",   (string) A range of valid nonces\\n\"\n             \"  \\\"sigoplimit\\\" : n,                 (numeric) limit of sigops in blocks\\n\"\n             \"  \\\"sizelimit\\\" : n,                  (numeric) limit of block size\\n\"\n+            \"  \\\"txsizelimit\\\" : n,                (numeric) limit of transaction size\\n\"\n             \"  \\\"curtime\\\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n             \"  \\\"bits\\\" : \\\"xxx\\\",                 (string) compressed target of next block\\n\"\n             \"  \\\"height\\\" : n                      (numeric) The height of the next block\\n\"\n@@ -562,6 +563,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     }\n \n     UniValue result(UniValue::VOBJ);\n+    int64_t nBlockTime = pblock->GetBlockTime();\n     result.push_back(Pair(\"capabilities\", aCaps));\n     result.push_back(Pair(\"version\", pblock->nVersion));\n     result.push_back(Pair(\"previousblockhash\", pblock->hashPrevBlock.GetHex()));\n@@ -573,9 +575,10 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n-    result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS));\n-    result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE));\n-    result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n+    result.push_back(Pair(\"sigoplimit\", Params().MaxBlockSigops(nBlockTime, sizeForkTime.load())));\n+    result.push_back(Pair(\"sizelimit\", Params().MaxBlockSize(nBlockTime, sizeForkTime.load())));\n+    result.push_back(Pair(\"txsizelimit\", Params().MaxTransactionSize(nBlockTime, sizeForkTime.load())));\n+    result.push_back(Pair(\"curtime\", nBlockTime));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n "
      },
      {
        "sha": "a77f4ee0298abb41d8f70066cd1df71702c056d4",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -296,7 +296,8 @@ UniValue verifytxoutproof(const UniValue& params, bool fHelp)\n     UniValue res(UniValue::VARR);\n \n     vector<uint256> vMatch;\n-    if (merkleBlock.txn.ExtractMatches(vMatch) != merkleBlock.header.hashMerkleRoot)\n+    uint64_t nMaxTransactions = Params().MaxBlockSize(merkleBlock.GetBlockTime(), sizeForkTime.load())/60; // 60 bytes == min tx size\n+    if (merkleBlock.txn.ExtractMatches(nMaxTransactions, vMatch) != merkleBlock.header.hashMerkleRoot)\n         return res;\n \n     LOCK(cs_main);"
      },
      {
        "sha": "c94f7b047515aae5f837cc69d1383db45f81949c",
        "filename": "src/test/block_size_tests.cpp",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/block_size_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/block_size_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/block_size_tests.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -0,0 +1,197 @@\n+// Copyright (c) 2011-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chainparams.h\"\n+#include \"consensus/validation.h\"\n+#include \"main.h\"\n+#include \"miner.h\"\n+#include \"pubkey.h\"\n+#include \"random.h\"\n+#include \"uint256.h\"\n+#include \"util.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// These must match parameters in chainparams.cpp\n+static const uint64_t EARLIEST_FORK_TIME = 1452470400; // 11 Jan 2016\n+static const uint32_t MAXSIZE_PREFORK = 1000*1000;\n+static const uint32_t MAXSIZE_POSTFORK = 8*1000*1000;\n+static const uint64_t SIZE_DOUBLE_EPOCH = 60*60*24*365*2; // two years\n+\n+BOOST_FIXTURE_TEST_SUITE(block_size_tests, TestingSetup)\n+\n+// Fill block with dummy transactions until it's serialized size is exactly nSize\n+static void\n+FillBlock(CBlock& block, unsigned int nSize)\n+{\n+    assert(block.vtx.size() > 0); // Start with at least a coinbase\n+\n+    unsigned int nBlockSize = ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+    if (nBlockSize > nSize) {\n+        block.vtx.resize(1); // passed in block is too big, start with just coinbase\n+        nBlockSize = ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+    }\n+    \n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_11;\n+    tx.vin[0].prevout.hash = block.vtx[0].GetHash(); // passes CheckBlock, would fail if we checked inputs.\n+    tx.vin[0].prevout.n = 0;\n+    tx.vout.resize(1);\n+    tx.vout[0].nValue = 1LL;\n+    tx.vout[0].scriptPubKey = block.vtx[0].vout[0].scriptPubKey;\n+\n+    unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+    block.vtx.reserve(1+nSize/nTxSize);\n+\n+    // ... add copies of tx to the block to get close to nSize:\n+    while (nBlockSize+nTxSize < nSize) {\n+        block.vtx.push_back(tx);\n+        nBlockSize += nTxSize;\n+        tx.vin[0].prevout.hash = GetRandHash(); // Just to make each tx unique\n+    }\n+    // Make the last transaction exactly the right size by making the scriptSig bigger.\n+    block.vtx.pop_back();\n+    nBlockSize = ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+    unsigned int nFill = nSize - nBlockSize - nTxSize;\n+    for (unsigned int i = 0; i < nFill; i++)\n+        tx.vin[0].scriptSig << OP_11;\n+    block.vtx.push_back(tx);\n+    nBlockSize = ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+    assert(nBlockSize == nSize);\n+}\n+\n+static bool TestCheckBlock(CBlock& block, uint64_t nTime, unsigned int nSize)\n+{\n+    SetMockTime(nTime);\n+    block.nTime = nTime;\n+    FillBlock(block, nSize);\n+    CValidationState validationState;\n+    bool fResult = CheckBlock(block, validationState, false, false) && validationState.IsValid();\n+    SetMockTime(0);\n+    return fResult;\n+}\n+\n+//\n+// Unit test CheckBlock() for conditions around the block size hard fork\n+//\n+BOOST_AUTO_TEST_CASE(BigBlockFork_Time1)\n+{\n+    CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n+    CBlockTemplate *pblocktemplate;\n+\n+    uint64_t t = EARLIEST_FORK_TIME;\n+    uint64_t preforkSize = MAXSIZE_PREFORK;\n+    uint64_t postforkSize = MAXSIZE_POSTFORK;\n+    uint64_t tActivate = EARLIEST_FORK_TIME;\n+\n+    sizeForkTime.store(tActivate);\n+\n+    LOCK(cs_main);\n+\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    CBlock *pblock = &pblocktemplate->block;\n+\n+    // Before fork time...\n+    BOOST_CHECK(TestCheckBlock(*pblock, t-1LL, preforkSize)); // 1MB : valid\n+    BOOST_CHECK(!TestCheckBlock(*pblock, t-1LL, preforkSize+1)); // >1MB : invalid\n+    BOOST_CHECK(!TestCheckBlock(*pblock, t-1LL, postforkSize)); // big : invalid\n+\n+    // Exactly at fork time...\n+    BOOST_CHECK(TestCheckBlock(*pblock, t, preforkSize)); // 1MB : valid\n+    BOOST_CHECK(TestCheckBlock(*pblock, t, postforkSize)); // big : valid\n+    BOOST_CHECK(!TestCheckBlock(*pblock, t,  postforkSize+1)); // big+1 : invalid\n+\n+    // Halfway to first doubling...\n+    uint64_t tHalf = t+SIZE_DOUBLE_EPOCH/2;\n+    BOOST_CHECK(!TestCheckBlock(*pblock, tHalf-1, (3*postforkSize)/2));\n+    BOOST_CHECK(TestCheckBlock(*pblock, tHalf, (3*postforkSize)/2));\n+    BOOST_CHECK(!TestCheckBlock(*pblock, tHalf, (3*postforkSize)/2)+1);\n+\n+    // Sanity check: April 1 2017 is more than halfway to first\n+    // doubling:\n+    uint64_t tApril_2017 = 1491004800;\n+    BOOST_CHECK(TestCheckBlock(*pblock, tApril_2017, (3*postforkSize)/2)+1);\n+\n+    // After one doubling...\n+    uint64_t yearsAfter = t+SIZE_DOUBLE_EPOCH;\n+    BOOST_CHECK(TestCheckBlock(*pblock, yearsAfter, 2*postforkSize)); // 2 * big : valid\n+    BOOST_CHECK(!TestCheckBlock(*pblock, yearsAfter, 2*postforkSize+1)); // > 2 * big : invalid\n+\n+#if 0\n+    // These tests use gigabytes of memory and take a long time to run--\n+    // don't enable by default until computers have petabytes of memory\n+    // and are 100 times faster than in 2015.\n+    // Network protocol will have to be updated before we get there...\n+    uint64_t maxDoublings = 8;\n+    uint64_t postDoubleTime = t + SIZE_DOUBLE_EPOCH * maxDoublings + 1;\n+    uint64_t farFuture = t + SIZE_DOUBLE_EPOCH * 100;\n+    BOOST_CHECK(TestCheckBlock(*pblock, postDoubleTime, postforkSize<<maxDoublings));\n+    BOOST_CHECK(TestCheckBlock(*pblock, farFuture, postforkSize<<maxDoublings));\n+    BOOST_CHECK(!TestCheckBlock(*pblock, postDoubleTime, (postforkSize<<maxDoublings)+1));\n+    BOOST_CHECK(!TestCheckBlock(*pblock, farFuture, (postforkSize<<maxDoublings)+1));\n+#endif\n+\n+    sizeForkTime.store(std::numeric_limits<uint64_t>::max());\n+}\n+\n+// Test activation time 30 days after earliest possible:\n+BOOST_AUTO_TEST_CASE(BigBlockFork_Time2)\n+{\n+    CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n+    CBlockTemplate *pblocktemplate;\n+\n+    uint64_t t = EARLIEST_FORK_TIME;\n+    uint64_t preforkSize = MAXSIZE_PREFORK;\n+    uint64_t postforkSize = MAXSIZE_POSTFORK;\n+\n+    uint64_t tActivate = EARLIEST_FORK_TIME+60*60*24*30;\n+    sizeForkTime.store(tActivate);\n+\n+    LOCK(cs_main);\n+\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    CBlock *pblock = &pblocktemplate->block;\n+\n+    // Exactly at fork time...\n+    BOOST_CHECK(TestCheckBlock(*pblock, t, preforkSize)); // 1MB : valid\n+    BOOST_CHECK(!TestCheckBlock(*pblock, t, postforkSize)); // big : invalid\n+\n+    // Exactly at activation time....\n+    BOOST_CHECK(TestCheckBlock(*pblock, tActivate, preforkSize)); // 1MB : valid\n+    BOOST_CHECK(TestCheckBlock(*pblock, tActivate, postforkSize)); // big : valid\n+ \n+    // Halfway to first doubling IS after the activation time:\n+    uint64_t tHalf = t+SIZE_DOUBLE_EPOCH/2;\n+    BOOST_CHECK(TestCheckBlock(*pblock, tHalf, (3*postforkSize)/2));\n+\n+    sizeForkTime.store(std::numeric_limits<uint64_t>::max());\n+}\n+\n+// Test: no miner consensus, no big blocks:\n+BOOST_AUTO_TEST_CASE(BigBlockFork_NoActivation)\n+{\n+    CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n+    CBlockTemplate *pblocktemplate;\n+\n+    uint64_t t = EARLIEST_FORK_TIME;\n+    uint64_t preforkSize = MAXSIZE_PREFORK;\n+    uint64_t postforkSize = MAXSIZE_POSTFORK;\n+\n+    LOCK(cs_main);\n+\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n+    CBlock *pblock = &pblocktemplate->block;\n+\n+    // Exactly at fork time...\n+    BOOST_CHECK(TestCheckBlock(*pblock, t, preforkSize)); // 1MB : valid\n+    BOOST_CHECK(!TestCheckBlock(*pblock, t, postforkSize)); // big : invalid\n+\n+    uint64_t tHalf = t+SIZE_DOUBLE_EPOCH/2;\n+    BOOST_CHECK(!TestCheckBlock(*pblock, tHalf, (3*postforkSize)/2));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "39fffce2b921359feef536679aa16001a924bdb6",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -23,6 +23,8 @@\n \n using namespace std;\n \n+static const int maxTxn = 1000*1000/60; // upper limit, number txns in 1MB block\n+\n BOOST_FIXTURE_TEST_SUITE(bloom_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n@@ -204,7 +206,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_1)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 8);\n \n     vector<uint256> vMatched;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -221,7 +223,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_1)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0xdd1fd2a6fc16404faf339881a90adbde7f4f728691ac62e8f168809cdfae1053\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 7);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -249,7 +251,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_2)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n     vector<uint256> vMatched;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -275,7 +277,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_2)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[3].second == uint256S(\"0x3c1d7e82342158e4109df2e0b6348b6e84e403d8b4046d7007663ace63cddb23\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[3].first == 3);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -303,7 +305,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_2_with_update_none)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n     vector<uint256> vMatched;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -326,7 +328,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_2_with_update_none)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[2].second == uint256S(\"0x3c1d7e82342158e4109df2e0b6348b6e84e403d8b4046d7007663ace63cddb23\"));\n     BOOST_CHECK(merkleBlock.vMatchedTxn[2].first == 3);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -353,7 +355,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 0);\n \n     vector<uint256> vMatched;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -392,7 +394,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_4)\n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].first == 6);\n \n     vector<uint256> vMatched;\n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);\n@@ -409,7 +411,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_4)\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn[1] == pair);\n \n-    BOOST_CHECK(merkleBlock.txn.ExtractMatches(vMatched) == block.hashMerkleRoot);\n+    BOOST_CHECK(merkleBlock.txn.ExtractMatches(maxTxn, vMatched) == block.hashMerkleRoot);\n     BOOST_CHECK(vMatched.size() == merkleBlock.vMatchedTxn.size());\n     for (unsigned int i = 0; i < vMatched.size(); i++)\n         BOOST_CHECK(vMatched[i] == merkleBlock.vMatchedTxn[i].second);"
      },
      {
        "sha": "999d937375a3eac22b295799b04e57a42506bd14",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -18,6 +18,8 @@\n \n using namespace std;\n \n+static const int maxTxn = 1000*1000/60; // upper limit, number txns in 1MB block\n+\n class CPartialMerkleTreeTester : public CPartialMerkleTree\n {\n public:\n@@ -87,7 +89,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n \n             // extract merkle root and matched txids from copy\n             std::vector<uint256> vMatchTxid2;\n-            uint256 merkleRoot2 = pmt2.ExtractMatches(vMatchTxid2);\n+            uint256 merkleRoot2 = pmt2.ExtractMatches(maxTxn, vMatchTxid2);\n \n             // check that it has the same merkle root as the original, and a valid one\n             BOOST_CHECK(merkleRoot1 == merkleRoot2);\n@@ -101,7 +103,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n                 CPartialMerkleTreeTester pmt3(pmt2);\n                 pmt3.Damage();\n                 std::vector<uint256> vMatchTxid3;\n-                uint256 merkleRoot3 = pmt3.ExtractMatches(vMatchTxid3);\n+                uint256 merkleRoot3 = pmt3.ExtractMatches(maxTxn, vMatchTxid3);\n                 BOOST_CHECK(merkleRoot3 != merkleRoot1);\n             }\n         }\n@@ -121,7 +123,7 @@ BOOST_AUTO_TEST_CASE(pmt_malleability)\n \n     CPartialMerkleTree tree(vTxid, vMatch);\n     std::vector<uint256> vTxid2;\n-    BOOST_CHECK(tree.ExtractMatches(vTxid).IsNull());\n+    BOOST_CHECK(tree.ExtractMatches(100, vTxid).IsNull());\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1ed14e3952237e41ef1af6bb19853845f312d538",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -197,7 +197,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           stream >> tx;\n \n           CValidationState state;\n-          BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n+          BOOST_CHECK_MESSAGE(CheckTransaction(tx, state, MAX_STANDARD_TX_SIZE), strTest);\n           BOOST_CHECK(state.IsValid());\n \n           std::vector<unsigned char> raw = ParseHex(raw_script);"
      },
      {
        "sha": "a04762f28ebf721caa359736fbd240e43ae6b51d",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -135,7 +135,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             stream >> tx;\n \n             CValidationState state;\n-            BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n+            BOOST_CHECK_MESSAGE(CheckTransaction(tx, state, MAX_STANDARD_TX_SIZE), strTest);\n             BOOST_CHECK(state.IsValid());\n \n             for (unsigned int i = 0; i < tx.vin.size(); i++)\n@@ -210,7 +210,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             stream >> tx;\n \n             CValidationState state;\n-            fValid = CheckTransaction(tx, state) && state.IsValid();\n+            fValid = CheckTransaction(tx, state, MAX_STANDARD_TX_SIZE) && state.IsValid();\n \n             for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\n             {\n@@ -239,11 +239,11 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     CMutableTransaction tx;\n     stream >> tx;\n     CValidationState state;\n-    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n+    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state, MAX_STANDARD_TX_SIZE) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n \n     // Check that duplicate txins fail\n     tx.vin.push_back(tx.vin[0]);\n-    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n+    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state, MAX_STANDARD_TX_SIZE) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n }\n \n //"
      },
      {
        "sha": "2c51114382f70915bb49fc3a3085ff21e566d436",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/714852722960d6851890b4eb2939bb66d1cd7f2e/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/714852722960d6851890b4eb2939bb66d1cd7f2e/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=714852722960d6851890b4eb2939bb66d1cd7f2e",
        "patch": "@@ -371,7 +371,8 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletTx wtx;\n             ssValue >> wtx;\n             CValidationState state;\n-            if (!(CheckTransaction(wtx, state) && (wtx.GetHash() == hash) && state.IsValid()))\n+            // Allow reading transactions up to 1MB large (largest ever allowed in a block):\n+            if (!(CheckTransaction(wtx, state, 1000*1000) && (wtx.GetHash() == hash) && state.IsValid()))\n                 return false;\n \n             // Undo serialize changes in 31600"
      }
    ]
  },
  {
    "sha": "b7492b1a60e333d5a0151f11a428a1023274ab21",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzQ5MmIxYTYwZTMzM2Q1YTAxNTFmMTFhNDI4YTEwMjMyNzRhYjIx",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-19T14:56:04Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T18:28:58Z"
      },
      "message": "Implement miner vote and grace period for block size fork\n\nThese changes implement and test miner rollout of a bigger\nblock size hard fork.\n\nqa/rpc-tests/bigblocks.py mines a 50% upgraded -regtest chain,\ngenerates 4MB of transactions, and then tests the upgrade and\nmining code to make sure larger blocks are only created when\nthe fork conditions are met.\n\nThe activation state of the fork is stored in the block tree database;\nit is written when the threshold is met (and unwritten if the\nthreshold block is re-orged out of the best chain), and read at startup.",
      "tree": {
        "sha": "891488c07d6fdcabcba934b2fc6e940726b408d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/891488c07d6fdcabcba934b2fc6e940726b408d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7492b1a60e333d5a0151f11a428a1023274ab21",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlVPMACgkQdYgkL74406iEewCeMjiXRw6Y6RmU5oQOH+sYMHNb\ny+QAoMfyZ9MgWPZNft4vZwUIIul/Id2N\n=ev0x\n-----END PGP SIGNATURE-----",
        "payload": "tree 891488c07d6fdcabcba934b2fc6e940726b408d5\nparent 714852722960d6851890b4eb2939bb66d1cd7f2e\nauthor Gavin Andresen <gavinandresen@gmail.com> 1434725764 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436898538 -0400\n\nImplement miner vote and grace period for block size fork\n\nThese changes implement and test miner rollout of a bigger\nblock size hard fork.\n\nqa/rpc-tests/bigblocks.py mines a 50% upgraded -regtest chain,\ngenerates 4MB of transactions, and then tests the upgrade and\nmining code to make sure larger blocks are only created when\nthe fork conditions are met.\n\nThe activation state of the fork is stored in the block tree database;\nit is written when the threshold is met (and unwritten if the\nthreshold block is re-orged out of the best chain), and read at startup.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7492b1a60e333d5a0151f11a428a1023274ab21",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7492b1a60e333d5a0151f11a428a1023274ab21",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7492b1a60e333d5a0151f11a428a1023274ab21/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "714852722960d6851890b4eb2939bb66d1cd7f2e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/714852722960d6851890b4eb2939bb66d1cd7f2e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/714852722960d6851890b4eb2939bb66d1cd7f2e"
      }
    ],
    "stats": {
      "total": 415,
      "additions": 406,
      "deletions": 9
    },
    "files": [
      {
        "sha": "a24abec5ad7a6277a656771c6c59fbe8f2616ba0",
        "filename": "qa/rpc-tests/bigblocks.py",
        "status": "added",
        "additions": 279,
        "deletions": 0,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/qa/rpc-tests/bigblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/qa/rpc-tests/bigblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bigblocks.py?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -0,0 +1,279 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test mining and broadcast of larger-than-1MB-blocks\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+from decimal import Decimal\n+\n+CACHE_DIR = \"cache_bigblock\"\n+\n+# regression test / testnet fork params:\n+FORK_TIME = 1438387200\n+FORK_BLOCK_VERSION = 0x20000004\n+FORK_GRACE_PERIOD = 60*60*24\n+\n+class BigBlockTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        print(\"Be patient, this test can take 5 or more minutes to run.\")\n+\n+        if not os.path.isdir(os.path.join(CACHE_DIR, \"node0\")):\n+            print(\"Creating initial chain\")\n+\n+            for i in range(4):\n+                initialize_datadir(CACHE_DIR, i) # Overwrite port/rpcport in bitcoin.conf\n+\n+            first_block_time = FORK_TIME - 200 * 10*60\n+\n+            # Node 0 tries to create as-big-as-possible blocks.\n+            # Node 1 creates really small, old-version blocks\n+            # Node 2 creates empty up-version blocks\n+            # Node 3 creates empty, old-version blocks\n+            self.nodes = []\n+            # Use node0 to mine blocks for input splitting\n+            self.nodes.append(start_node(0, CACHE_DIR, [\"-blockmaxsize=8000000\", \"-debug=net\",\n+                                                        \"-mocktime=%d\"%(first_block_time,),\n+                                                        \"-blockversion=%d\"%(FORK_BLOCK_VERSION,)]))\n+            self.nodes.append(start_node(1, CACHE_DIR, [\"-blockmaxsize=50000\", \"-debug=net\",\n+                                                        \"-mocktime=%d\"%(first_block_time,),\n+                                                        \"-blockversion=3\"]))\n+            self.nodes.append(start_node(2, CACHE_DIR, [\"-blockmaxsize=1000\",\n+                                                        \"-mocktime=%d\"%(first_block_time,),\n+                                                        \"-blockversion=%d\"%(FORK_BLOCK_VERSION,)]))\n+            self.nodes.append(start_node(3, CACHE_DIR, [\"-blockmaxsize=1000\",\n+                                                        \"-mocktime=%d\"%(first_block_time,),\n+                                                        \"-blockversion=3\"]))\n+\n+            set_node_times(self.nodes, first_block_time)\n+\n+            connect_nodes_bi(self.nodes, 0, 1)\n+            connect_nodes_bi(self.nodes, 1, 2)\n+            connect_nodes_bi(self.nodes, 2, 3)\n+            connect_nodes_bi(self.nodes, 3, 0)\n+\n+            self.is_network_split = False\n+            self.sync_all()\n+\n+            # Have node0 and node1 alternate finding blocks\n+            # before the fork time, so it's 50% / 50% vote\n+            block_time = first_block_time\n+            for i in range(0,200):\n+                miner = i%2\n+                set_node_times(self.nodes, block_time)\n+                self.nodes[miner].generate(1)\n+                assert(self.sync_blocks(self.nodes[0:2]))\n+                block_time = block_time + 10*60\n+\n+            # Generate 1200 addresses\n+            addresses = [ self.nodes[3].getnewaddress() for i in range(0,1200) ]\n+\n+            amount = Decimal(\"0.00125\")\n+\n+            send_to = { }\n+            for address in addresses:\n+                send_to[address] = amount\n+\n+            tx_file = open(os.path.join(CACHE_DIR, \"txdata\"), \"w\")\n+\n+            # Create four megabytes worth of transactions ready to be\n+            # mined:\n+            print(\"Creating 100 40K transactions (4MB)\")\n+            for node in range(0,2):\n+                for i in range(0,50):\n+                    txid = self.nodes[node].sendmany(\"\", send_to, 1)\n+                    txdata = self.nodes[node].getrawtransaction(txid)\n+                    tx_file.write(txdata+\"\\n\")\n+            tx_file.close()\n+\n+            stop_nodes(self.nodes)\n+            wait_bitcoinds()\n+            self.nodes = []\n+            for i in range(4):\n+                os.remove(log_filename(CACHE_DIR, i, \"debug.log\"))\n+                os.remove(log_filename(CACHE_DIR, i, \"db.log\"))\n+                os.remove(log_filename(CACHE_DIR, i, \"peers.dat\"))\n+                os.remove(log_filename(CACHE_DIR, i, \"fee_estimates.dat\"))\n+\n+\n+        for i in range(4):\n+            from_dir = os.path.join(CACHE_DIR, \"node\"+str(i))\n+            to_dir = os.path.join(self.options.tmpdir,  \"node\"+str(i))\n+            shutil.copytree(from_dir, to_dir)\n+            initialize_datadir(self.options.tmpdir, i) # Overwrite port/rpcport in bitcoin.conf\n+\n+    def sync_blocks(self, rpc_connections, wait=1, max_wait=30):\n+        \"\"\"\n+        Wait until everybody has the same block count\n+        \"\"\"\n+        for i in range(0,max_wait):\n+            if i > 0: time.sleep(wait)\n+            counts = [ x.getblockcount() for x in rpc_connections ]\n+            if counts == [ counts[0] ]*len(counts):\n+                return True\n+        return False\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        last_block_time = FORK_TIME - 10*60\n+\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-blockmaxsize=8000000\", \"-debug=net\",\n+                                                              \"-mocktime=%d\"%(last_block_time,),\n+                                                              \"-blockversion=%d\"%(FORK_BLOCK_VERSION,)]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockmaxsize=50000\", \"-debug=net\",\n+                                                              \"-mocktime=%d\"%(last_block_time,),\n+                                                              \"-blockversion=3\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockmaxsize=1000\",\n+                                                              \"-mocktime=%d\"%(last_block_time,),\n+                                                              \"-blockversion=%d\"%(FORK_BLOCK_VERSION,)]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-blockmaxsize=1000\",\n+                                                              \"-mocktime=%d\"%(last_block_time,),\n+                                                              \"-blockversion=3\"]))\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 2, 3)\n+        connect_nodes_bi(self.nodes, 3, 0)\n+\n+        # Populate node0's mempool with cached pre-created transactions:\n+        with open(os.path.join(CACHE_DIR, \"txdata\"), \"r\") as f:\n+            for line in f:\n+                self.nodes[0].sendrawtransaction(line.rstrip())\n+\n+    def copy_mempool(self, from_node, to_node):\n+        txids = from_node.getrawmempool()\n+        for txid in txids:\n+            txdata = from_node.getrawtransaction(txid)\n+            to_node.sendrawtransaction(txdata)\n+\n+    def TestMineBig(self, expect_big):\n+        # Test if node0 will mine big blocks.\n+        b1hash = self.nodes[0].generate(1)[0]\n+        b1 = self.nodes[0].getblock(b1hash, True)\n+        assert(self.sync_blocks(self.nodes))\n+\n+        if expect_big:\n+            assert(b1['size'] > 1000*1000)\n+\n+            # Have node1 mine on top of the block,\n+            # to make sure it goes along with the fork\n+            b2hash = self.nodes[1].generate(1)[0]\n+            b2 = self.nodes[1].getblock(b2hash, True)\n+            assert(b2['previousblockhash'] == b1hash)\n+            assert(self.sync_blocks(self.nodes))\n+\n+        else:\n+            assert(b1['size'] < 1000*1000)\n+\n+        # Reset chain to before b1hash:\n+        for node in self.nodes:\n+            node.invalidateblock(b1hash)\n+        assert(self.sync_blocks(self.nodes))\n+\n+\n+    def run_test(self):\n+        # nodes 0 and 1 have 50 mature 50-BTC coinbase transactions.\n+        # Spend them with 50 transactions, each that has\n+        # 1,200 outputs (so they're about 41K big).\n+\n+        print(\"Testing fork conditions\")\n+\n+        # Fork is controlled by block timestamp and miner super-majority;\n+        # large blocks may only be created after a supermajority of miners\n+        # produce up-version blocks plus a grace period AND after a\n+        # hard-coded earliest-possible date.\n+\n+        # At this point the chain is 200 blocks long\n+        # alternating between version=3 and version=FORK_BLOCK_VERSION\n+        # blocks.\n+\n+        # NOTE: the order of these test is important!\n+        # set_node_times must advance time. Local time moving\n+        # backwards causes problems.\n+\n+        # Time starts a little before earliest fork time\n+        set_node_times(self.nodes, FORK_TIME - 100)\n+\n+        # No supermajority, and before earliest fork time:\n+        self.TestMineBig(False)\n+\n+        # node2 creates empty up-version blocks; creating\n+        # 50 in a row makes 75 of previous 100 up-version\n+        # (which is the -regtest activation condition)\n+        t_delta = FORK_GRACE_PERIOD/50\n+        blocks = []\n+        for i in range(50):\n+            set_node_times(self.nodes, FORK_TIME + t_delta*i - 1)\n+            blocks.append(self.nodes[2].generate(1)[0])\n+        assert(self.sync_blocks(self.nodes))\n+\n+        # Earliest time for a big block is the timestamp of the\n+        # supermajority block plus grace period:\n+        lastblock = self.nodes[0].getblock(blocks[-1], True)\n+        t_fork = lastblock[\"time\"] + FORK_GRACE_PERIOD\n+\n+        self.TestMineBig(False)  # Supermajority... but before grace period end\n+\n+        # Test right around the switchover time.\n+        set_node_times(self.nodes, t_fork-1)\n+        self.TestMineBig(False)\n+\n+        # Note that node's local times are irrelevant, block timestamps\n+        # are all that count-- so node0 will mine a big block with timestamp in the\n+        # future from the perspective of the other nodes, but as long as\n+        # it's timestamp is not too far in the future (2 hours) it will be\n+        # accepted.\n+        self.nodes[0].setmocktime(t_fork)\n+        self.TestMineBig(True)\n+\n+        # Shutdown then restart node[0], it should\n+        # remember supermajority state and produce a big block.\n+        stop_node(self.nodes[0], 0)\n+        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-blockmaxsize=8000000\", \"-debug=net\",\n+                                                            \"-mocktime=%d\"%(t_fork,),\n+                                                            \"-blockversion=%d\"%(FORK_BLOCK_VERSION,)])\n+        self.copy_mempool(self.nodes[1], self.nodes[0])\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 0, 3)\n+        self.TestMineBig(True)\n+\n+        # Test re-orgs past the activation block (blocks[-1])\n+        #\n+        # Shutdown node[0] again:\n+        stop_node(self.nodes[0], 0)\n+\n+        # Mine a longer chain with two version=3 blocks:\n+        self.nodes[3].invalidateblock(blocks[-1])\n+        v3blocks = self.nodes[3].generate(2)\n+        assert(self.sync_blocks(self.nodes[1:]))\n+\n+        # Restart node0, it should re-org onto longer chain, reset\n+        # activation time, and refuse to mine a big block:\n+        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-blockmaxsize=8000000\", \"-debug=net\",\n+                                                            \"-mocktime=%d\"%(t_fork,),\n+                                                            \"-blockversion=%d\"%(FORK_BLOCK_VERSION,)])\n+        self.copy_mempool(self.nodes[1], self.nodes[0])\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 0, 3)\n+        assert(self.sync_blocks(self.nodes))\n+        self.TestMineBig(False)\n+\n+        # Mine 4 FORK_BLOCK_VERSION blocks and set the time past the\n+        # grace period:  bigger block OK:\n+        self.nodes[2].generate(4)\n+        assert(self.sync_blocks(self.nodes))\n+        set_node_times(self.nodes, t_fork + FORK_GRACE_PERIOD)\n+        self.TestMineBig(True)\n+\n+\n+        print(\"Cached test chain and transactions left in %s\"%(CACHE_DIR))\n+        print(\" (remove that directory if you will not run this test again)\")\n+\n+\n+if __name__ == '__main__':\n+    BigBlockTest().main()"
      },
      {
        "sha": "1f5d1f8aa3911daa26b93275688a31c6f8079e6f",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -63,6 +63,8 @@ class CMainParams : public CChainParams {\n         nSizeDoubleEpoch = 60*60*24*365*2; // two years\n         nMaxSizeBase = 8*1000*1000; // 8MB\n         nMaxSizeDoublings = 10;\n+        nActivateSizeForkMajority = 750; // 75% of hashpower to activate fork\n+        nSizeForkGracePeriod = 60*60*24*14; // two week grace period after activation\n \n         /**\n          * Build the genesis block. Note that the output of its generation\n@@ -168,6 +170,8 @@ class CTestNetParams : public CMainParams {\n         nSizeDoubleEpoch = 60*60*24*365*2; // two years\n         nMaxSizeBase = 8*1000*1000; // 8MB\n         nMaxSizeDoublings = 10;\n+        nActivateSizeForkMajority = 75; // 75 of 100 to activate fork\n+        nSizeForkGracePeriod = 60*60*24; // 1-day grace period\n \n         //! Modify the testnet genesis block so the timestamp is valid for a later start.\n         genesis.nTime = 1296688602;"
      },
      {
        "sha": "e079953845a99345ab11a250cb1f0774f278c2cd",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 6,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -82,10 +82,16 @@ void EraseOrphansFor(NodeId peer);\n static bool SanityCheckMessage(CNode* peer, const CNetMessage& msg);\n \n /**\n- * Returns true if there are nRequired or more blocks of minVersion or above\n- * in the last Consensus::Params::nMajorityWindow blocks, starting at pstart and going backwards.\n+ * Returns true if there are nRequired or more blocks with a version that matches\n+ * versionOrBitmask in the last Consensus::Params::nMajorityWindow blocks,\n+ * starting at pstart and going backwards.\n+ *\n+ * A bitmask is used to be compatible with Pieter Wuille's \"Version bits\"\n+ * proposal, so it is possible for multiple forks to be in-progress\n+ * at the same time. A simple >= version field is used for forks that\n+ * predate this proposal.\n  */\n-static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams);\n+static bool IsSuperMajority(int versionOrBitmask, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams, bool useBitMask = true);\n static void CheckBlockIndex();\n \n /** Constant stuff for coinbase transactions we create: */\n@@ -1843,6 +1849,12 @@ static int64_t nTimeIndex = 0;\n static int64_t nTimeCallbacks = 0;\n static int64_t nTimeTotal = 0;\n \n+static bool DidBlockTriggerSizeFork(const CBlock &block, const CBlockIndex *pindex, const CChainParams &chainparams) {\n+    return (block.nVersion & SIZE_FORK_VERSION) &&\n+           (pblocktree->ForkActivated(SIZE_FORK_VERSION) == uint256()) &&\n+           IsSuperMajority(SIZE_FORK_VERSION, pindex, chainparams.ActivateSizeForkMajority(), chainparams.GetConsensus(), true /* use bitmask */);\n+}\n+\n bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, bool fJustCheck)\n {\n     const CChainParams& chainparams = Params();\n@@ -2018,6 +2030,14 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     int64_t nTime4 = GetTimeMicros(); nTimeCallbacks += nTime4 - nTime3;\n     LogPrint(\"bench\", \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime4 - nTime3), nTimeCallbacks * 0.000001);\n \n+    if (DidBlockTriggerSizeFork(block, pindex, chainparams)) {\n+        uint64_t tAllowBigger = block.nTime + chainparams.SizeForkGracePeriod();\n+        LogPrintf(\"%s: Max block size fork activating at time %d, bigger blocks allowed at time %d\\n\",\n+                  __func__, block.nTime, tAllowBigger);\n+        pblocktree->ActivateFork(SIZE_FORK_VERSION, pindex->GetBlockHash());\n+        sizeForkTime.store(tAllowBigger);\n+    }\n+\n     return true;\n }\n \n@@ -2212,6 +2232,14 @@ bool static DisconnectTip(CValidationState &state) {\n     }\n     mempool.removeCoinbaseSpends(pcoinsTip, pindexDelete->nHeight);\n     mempool.check(pcoinsTip);\n+\n+    // Re-org past the size fork, reset activation condition:\n+    if (pblocktree->ForkActivated(SIZE_FORK_VERSION) == pindexDelete->GetBlockHash()) {\n+        LogPrintf(\"%s: re-org past size fork\\n\", __func__);\n+        pblocktree->ActivateFork(SIZE_FORK_VERSION, uint256());\n+        sizeForkTime.store(std::numeric_limits<uint64_t>::max());\n+    }\n+\n     // Update chainActive and related variables.\n     UpdateTip(pindexDelete->pprev);\n     // Let wallets know transactions went from 1-confirmed to\n@@ -2964,12 +2992,13 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     return true;\n }\n \n-static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams)\n+static bool IsSuperMajority(int versionOrBitmask, const CBlockIndex* pstart, unsigned nRequired, const Consensus::Params& consensusParams, bool useBitMask)\n {\n     unsigned int nFound = 0;\n     for (int i = 0; i < consensusParams.nMajorityWindow && nFound < nRequired && pstart != NULL; i++)\n     {\n-        if (pstart->nVersion >= minVersion)\n+        if ((useBitMask && ((pstart->nVersion & versionOrBitmask) == versionOrBitmask)) ||\n+            (!useBitMask && (pstart->nVersion >= versionOrBitmask)))\n             ++nFound;\n         pstart = pstart->pprev;\n     }\n@@ -3212,6 +3241,15 @@ bool static LoadBlockIndexDB()\n     if (!pblocktree->LoadBlockIndexGuts())\n         return false;\n \n+    // If the max-block-size fork threshold was reached, update\n+    // chainparams so big blocks are allowed:\n+    uint256 sizeForkHash = pblocktree->ForkActivated(SIZE_FORK_VERSION);\n+    if (sizeForkHash != uint256()) {\n+        BlockMap::iterator it = mapBlockIndex.find(sizeForkHash);\n+        assert(it != mapBlockIndex.end());\n+        sizeForkTime.store(it->second->GetBlockTime() + chainparams.SizeForkGracePeriod());\n+    }\n+\n     boost::this_thread::interruption_point();\n \n     // Calculate nChainWork\n@@ -3853,7 +3891,14 @@ static std::map<std::string, size_t> maxMessageSizes = boost::assign::map_list_o\n bool static SanityCheckMessage(CNode* peer, const CNetMessage& msg)\n {\n     const std::string& strCommand = msg.hdr.GetCommand();\n-    if (msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH ||\n+    if (strCommand == \"block\") {\n+        uint64_t maxSize = Params().MaxBlockSize(GetAdjustedTime() + 2 * 60 * 60, sizeForkTime.load());\n+        if (msg.hdr.nMessageSize > maxSize) {\n+            LogPrint(\"net\", \"Oversized %s message from peer=%i\\n\", SanitizeString(strCommand), peer->GetId());\n+            return false;\n+        }\n+    }\n+    else if (msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH ||\n         (maxMessageSizes.count(strCommand) && msg.hdr.nMessageSize > maxMessageSizes[strCommand])) {\n         LogPrint(\"net\", \"Oversized %s message from peer=%i (%d bytes)\\n\",\n                  SanitizeString(strCommand), peer->GetId(), msg.hdr.nMessageSize);"
      },
      {
        "sha": "760109a993ceada624a847507c105c28e5de8abf",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -10,6 +10,9 @@\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n+/** Blocks with version fields that have these bits set activate the bigger-block fork */\n+const unsigned int SIZE_FORK_VERSION = 0x20000004;\n+\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block\n@@ -21,7 +24,7 @@ class CBlockHeader\n {\n public:\n     // header\n-    static const int32_t CURRENT_VERSION=3;\n+    static const int32_t CURRENT_VERSION=SIZE_FORK_VERSION;\n     int32_t nVersion;\n     uint256 hashPrevBlock;\n     uint256 hashMerkleRoot;"
      },
      {
        "sha": "ac378c681fe78622dbb05f0ae00d486bdc98336c",
        "filename": "src/test/ReceiveMsgBytes_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/src/test/ReceiveMsgBytes_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/src/test/ReceiveMsgBytes_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ReceiveMsgBytes_tests.cpp?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -11,6 +11,7 @@\n #include \"net.h\"\n #include \"pow.h\"\n #include \"serialize.h\"\n+#include \"timedata.h\"\n #include \"util.h\"\n \n #include \"test/test_bitcoin.h\"\n@@ -78,15 +79,16 @@ BOOST_AUTO_TEST_CASE(TooLargeBlock)\n     s << block;\n \n     // Test: too large\n-    s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen+1);\n+    size_t maxBlockSize = Params().MaxBlockSize(GetAdjustedTime(), sizeForkTime.load());\n+    s.resize(maxBlockSize+headerLen+1);\n     CNetMessage::FinalizeHeader(s);\n \n     BOOST_CHECK(!testNode.ReceiveMsgBytes(&s[0], s.size()));\n \n     testNode.vRecvMsg.clear();\n \n     // Test: exactly at max:\n-    s.resize(MAX_PROTOCOL_MESSAGE_LENGTH+headerLen);\n+    s.resize(maxBlockSize+headerLen);\n     CNetMessage::FinalizeHeader(s);\n \n     BOOST_CHECK(testNode.ReceiveMsgBytes(&s[0], s.size()));"
      },
      {
        "sha": "f98e7023faf57207482b5aabdcd057147df32fdd",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -27,6 +27,7 @@ static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n+static const char DB_FORK_ACTIVATION = 'a';\n \n void static BatchWriteCoins(CLevelDBBatch &batch, const uint256 &hash, const CCoins &coins) {\n     if (coins.IsPruned())\n@@ -240,5 +241,64 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n         }\n     }\n \n+    // Load fork activation info\n+    ssKeySet.clear();\n+    ssKeySet << make_pair(DB_FORK_ACTIVATION, 0);\n+    pcursor->Seek(ssKeySet.str());\n+    while (pcursor->Valid()) {\n+        try {\n+            leveldb::Slice slKey = pcursor->key();\n+            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            char chType;\n+            ssKey >> chType;\n+            if (chType == DB_FORK_ACTIVATION) {\n+                uint32_t nVersion;\n+                ssKey >> nVersion;\n+                leveldb::Slice slValue = pcursor->value();\n+                CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+                uint256 blockHash;\n+                ssValue >> blockHash;\n+                forkActivationMap[nVersion] = blockHash;\n+\n+                pcursor->Next();\n+            } else {\n+                break; // finished loading block index\n+            }\n+        }\n+        catch (std::exception &e) {\n+            return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        }\n+    }\n+\n     return true;\n }\n+\n+uint256 CBlockTreeDB::ForkActivated(int32_t nForkVersion) const\n+{\n+    // Returns block at which a supermajority was reached for given\n+    // fork version.\n+    // NOTE! The  max blocksize fork adds a grace period\n+    // during which no bigger blocks are allowed; this routine\n+    // just keeps track of the hash of the block that\n+    // triggers the fork condition\n+\n+    std::map<int32_t, uint256>::const_iterator it = forkActivationMap.find(nForkVersion);\n+    if (it != forkActivationMap.end())\n+        return it->second;\n+\n+    return uint256();\n+}\n+\n+bool CBlockTreeDB::ActivateFork(int32_t nForkVersion, const uint256& blockHash)\n+{\n+    // Called when a supermajority of blocks (ending with blockHash)\n+    // support a rule change\n+    // OR if a chain re-org happens around the activation block,\n+    // called with uint256(0) to reset the flag in the database.\n+\n+    forkActivationMap[nForkVersion] = blockHash;\n+    if (blockHash == uint256())\n+        return Erase(make_pair(DB_FORK_ACTIVATION, nForkVersion));\n+    else\n+        return Write(make_pair(DB_FORK_ACTIVATION, nForkVersion), blockHash);\n+}"
      },
      {
        "sha": "8459225536b37b5b561a11d20315dc1850e75936",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7492b1a60e333d5a0151f11a428a1023274ab21/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7492b1a60e333d5a0151f11a428a1023274ab21/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=b7492b1a60e333d5a0151f11a428a1023274ab21",
        "patch": "@@ -49,6 +49,8 @@ class CBlockTreeDB : public CLevelDBWrapper\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);\n+    std::map<int32_t, uint256> forkActivationMap;\n+\n public:\n     bool WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo);\n     bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n@@ -60,6 +62,8 @@ class CBlockTreeDB : public CLevelDBWrapper\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts();\n+    uint256 ForkActivated(int32_t nForkVersion) const;\n+    bool ActivateFork(int32_t nForkVersion, const uint256& blockHash);\n };\n \n #endif // BITCOIN_TXDB_H"
      }
    ]
  },
  {
    "sha": "c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjNlYjcwZGMwY2JjZjZhMzZiMWU3YWU5ODk4ZDlmNDA1Mjg4ZWMy",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-23T19:06:00Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T18:29:07Z"
      },
      "message": "Define MIN_TRANSACTION_SIZE=60 constant (avoid repeating myself)",
      "tree": {
        "sha": "c395e3c0ca79556dfbd097463e1518d54ca2e1fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c395e3c0ca79556dfbd097463e1518d54ca2e1fb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlVPMACgkQdYgkL74406gD3gCggttsRJbDUBUqs/oGxkCT5arm\nj+cAnRM8sqQAG71fHMl7zftQNhK8YI1a\n=PhKx\n-----END PGP SIGNATURE-----",
        "payload": "tree c395e3c0ca79556dfbd097463e1518d54ca2e1fb\nparent b7492b1a60e333d5a0151f11a428a1023274ab21\nauthor Gavin Andresen <gavinandresen@gmail.com> 1435086360 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436898547 -0400\n\nDefine MIN_TRANSACTION_SIZE=60 constant (avoid repeating myself)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7492b1a60e333d5a0151f11a428a1023274ab21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7492b1a60e333d5a0151f11a428a1023274ab21",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7492b1a60e333d5a0151f11a428a1023274ab21"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 9,
      "deletions": 3
    },
    "files": [
      {
        "sha": "df4ff00ef8ddfd814f30ae59493874f9eb8ac3fb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
        "patch": "@@ -2792,7 +2792,9 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     // Size limits\n     uint64_t nMaxBlockSize = Params().MaxBlockSize(block.GetBlockTime(), sizeForkTime.load());\n     uint64_t nMaxTxSize = Params().MaxTransactionSize(block.GetBlockTime(), sizeForkTime.load());\n-    if (block.vtx.empty() || block.vtx.size() > nMaxBlockSize || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > nMaxBlockSize)\n+    if (block.vtx.empty() ||\n+        block.vtx.size()*MIN_TRANSACTION_SIZE > nMaxBlockSize ||\n+        ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > nMaxBlockSize)\n         return state.DoS(100, error(\"CheckBlock(): size limits failed\"),\n                          REJECT_INVALID, \"bad-blk-length\");\n "
      },
      {
        "sha": "cb3d6583694bba672285e31d7805fe76d0de7ba0",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
        "patch": "@@ -54,6 +54,8 @@ static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 50000;\n /** Default for accepting alerts from the P2P network. */\n static const bool DEFAULT_ALERTS = true;\n+/** Smallest possible serialized transaction, in bytes */\n+static const unsigned int MIN_TRANSACTION_SIZE = 60;\n /** The maximum size for transactions we're willing to relay/mine */\n static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n /** Maximum number of signature check operations in an IsStandard() P2SH script */"
      },
      {
        "sha": "a83d6fe110ddd9c6069ec9209ae3b4e8e3c89580",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
        "patch": "@@ -7,6 +7,7 @@\n #include \"base58.h\"\n #include \"clientversion.h\"\n #include \"key.h\"\n+#include \"main.h\"\n #include \"merkleblock.h\"\n #include \"random.h\"\n #include \"serialize.h\"\n@@ -23,7 +24,7 @@\n \n using namespace std;\n \n-static const int maxTxn = 1000*1000/60; // upper limit, number txns in 1MB block\n+static const int maxTxn = 1000*1000/MIN_TRANSACTION_SIZE; // upper limit, number txns in 1MB block\n \n BOOST_FIXTURE_TEST_SUITE(bloom_tests, BasicTestingSetup)\n "
      },
      {
        "sha": "46e7a3825496371d3ed52ea7d61cc6bac6a58a41",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"main.h\"\n #include \"merkleblock.h\"\n #include \"serialize.h\"\n #include \"streams.h\"\n@@ -18,7 +19,7 @@\n \n using namespace std;\n \n-static const int maxTxn = 1000*1000/60; // upper limit, number txns in 1MB block\n+static const int maxTxn = 1000*1000/MIN_TRANSACTION_SIZE; // upper limit, number txns in 1MB block\n \n class CPartialMerkleTreeTester : public CPartialMerkleTree\n {"
      }
    ]
  },
  {
    "sha": "b58d92578566a52d696891b5611694b785fd2734",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNThkOTI1Nzg1NjZhNTJkNjk2ODkxYjU2MTE2OTRiNzg1ZmQyNzM0",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-06-29T20:36:27Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2015-07-14T18:31:25Z"
      },
      "message": "Move size fork params from chainparams.h to consensus/params.h",
      "tree": {
        "sha": "fe4289a96ceefd15844772851c49e832ea07ef8e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe4289a96ceefd15844772851c49e832ea07ef8e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b58d92578566a52d696891b5611694b785fd2734",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niEYEABECAAYFAlWlVX8ACgkQdYgkL74406hBlQCgnbSM/qqKxjv23SmtvLgl61kj\njpwAoJlaNsSpHg6nz9vC3CPfxO265K+C\n=7wtZ\n-----END PGP SIGNATURE-----",
        "payload": "tree fe4289a96ceefd15844772851c49e832ea07ef8e\nparent c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2\nauthor Gavin Andresen <gavinandresen@gmail.com> 1435610187 -0400\ncommitter Gavin Andresen <gavinandresen@gmail.com> 1436898685 -0400\n\nMove size fork params from chainparams.h to consensus/params.h\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b58d92578566a52d696891b5611694b785fd2734",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b58d92578566a52d696891b5611694b785fd2734",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b58d92578566a52d696891b5611694b785fd2734/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c63eb70dc0cbcf6a36b1e7ae9898d9f405288ec2"
      }
    ],
    "stats": {
      "total": 152,
      "additions": 76,
      "deletions": 76
    },
    "files": [
      {
        "sha": "872a1b1888effe578fa082b0aa9df96ea52b4fa3",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -189,7 +189,7 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n     static const unsigned int minTxOutSz = 9;\n     // Don't know if the reduce max transaction size fork has activated yet or not;\n     // assume it has if after the earliest fork time.\n-    unsigned int maxVout = Params().MaxTransactionSize(GetTime(), GetTime()) / minTxOutSz;\n+    unsigned int maxVout = Params().GetConsensus().MaxTransactionSize(GetTime(), GetTime()) / minTxOutSz;\n \n     // extract and validate vout\n     string strVout = strInput.substr(pos + 1, string::npos);"
      },
      {
        "sha": "d34193378ac3aa974f6a905537c619642e615bdd",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -56,15 +56,15 @@ class CMainParams : public CChainParams {\n         // Timestamps for forking consensus rule changes:\n         //  Allow bigger blocks\n         //  Limit transactions to 100,000 bytes\n-        nEarliestSizeForkTime = 1452470400; // 11 Jan 2016 00:00:00 UTC\n+        consensus.nEarliestSizeForkTime = 1452470400; // 11 Jan 2016 00:00:00 UTC\n         // 1MB max blocks before 11 Jan 2016\n         // Then, if miner consensus: 8MB max, doubling every two years\n-        nMaxSizePreFork = 1000*1000; // 1MB max pre-fork\n-        nSizeDoubleEpoch = 60*60*24*365*2; // two years\n-        nMaxSizeBase = 8*1000*1000; // 8MB\n-        nMaxSizeDoublings = 10;\n-        nActivateSizeForkMajority = 750; // 75% of hashpower to activate fork\n-        nSizeForkGracePeriod = 60*60*24*14; // two week grace period after activation\n+        consensus.nMaxSizePreFork = 1000*1000; // 1MB max pre-fork\n+        consensus.nSizeDoubleEpoch = 60*60*24*365*2; // two years\n+        consensus.nMaxSizeBase = 8*1000*1000; // 8MB\n+        consensus.nMaxSizeDoublings = 10;\n+        consensus.nActivateSizeForkMajority = 750; // 75% of hashpower to activate fork\n+        consensus.nSizeForkGracePeriod = 60*60*24*14; // two week grace period after activation\n \n         /**\n          * Build the genesis block. Note that the output of its generation\n@@ -165,13 +165,13 @@ class CTestNetParams : public CMainParams {\n \n         // 1MB max blocks before 1 Aug 2015\n         // Then, if miner consensus: 8MB max, doubling every two years\n-        nMaxSizePreFork = 1000*1000; // 1MB max pre-fork\n-        nEarliestSizeForkTime = 1438387200; // 1 Aug 2015 00:00:00 UTC\n-        nSizeDoubleEpoch = 60*60*24*365*2; // two years\n-        nMaxSizeBase = 8*1000*1000; // 8MB\n-        nMaxSizeDoublings = 10;\n-        nActivateSizeForkMajority = 75; // 75 of 100 to activate fork\n-        nSizeForkGracePeriod = 60*60*24; // 1-day grace period\n+        consensus.nMaxSizePreFork = 1000*1000; // 1MB max pre-fork\n+        consensus.nEarliestSizeForkTime = 1438387200; // 1 Aug 2015 00:00:00 UTC\n+        consensus.nSizeDoubleEpoch = 60*60*24*365*2; // two years\n+        consensus.nMaxSizeBase = 8*1000*1000; // 8MB\n+        consensus.nMaxSizeDoublings = 10;\n+        consensus.nActivateSizeForkMajority = 75; // 75 of 100 to activate fork\n+        consensus.nSizeForkGracePeriod = 60*60*24; // 1-day grace period\n \n         //! Modify the testnet genesis block so the timestamp is valid for a later start.\n         genesis.nTime = 1296688602;"
      },
      {
        "sha": "91892428b550941e7267e5997109843fd720de00",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 0,
        "deletions": 40,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -73,37 +73,6 @@ class CChainParams\n     const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n     const Checkpoints::CCheckpointData& Checkpoints() const { return checkpointData; }\n \n-    /** Maximum block size of a block with timestamp nBlockTimestamp */\n-    uint64_t MaxBlockSize(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n-        if (nBlockTimestamp < nEarliestSizeForkTime || nBlockTimestamp < nSizeForkActivationTime)\n-            return nMaxSizePreFork;\n-        if (nBlockTimestamp >= nEarliestSizeForkTime + nSizeDoubleEpoch * nMaxSizeDoublings)\n-            return nMaxSizeBase << nMaxSizeDoublings;\n-\n-        // Piecewise-linear-between-doublings growth. Calculated based on a fixed\n-        // timestamp and not the activation time so the maximum size is\n-        // predictable, and so the activation time can be completely removed in\n-        // a future version of this code after the fork is complete.\n-        uint64_t timeDelta = nBlockTimestamp - nEarliestSizeForkTime;\n-        uint64_t doublings = timeDelta / nSizeDoubleEpoch;\n-        uint64_t remain = timeDelta % nSizeDoubleEpoch;\n-        uint64_t interpolate = (nMaxSizeBase << doublings) * remain / nSizeDoubleEpoch;\n-        uint64_t nMaxSize = (nMaxSizeBase << doublings) + interpolate;\n-        return nMaxSize;\n-    }\n-    /** Maximum number of signature ops in a block with timestamp nBlockTimestamp */\n-    uint64_t MaxBlockSigops(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n-        return MaxBlockSize(nBlockTimestamp, nSizeForkActivationTime)/50;\n-    }\n-    /** Maximum size of a transaction in a block with timestamp nBlockTimestamp */\n-    uint64_t MaxTransactionSize(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n-        if (nBlockTimestamp < nEarliestSizeForkTime || nBlockTimestamp < nSizeForkActivationTime)\n-            return nMaxSizePreFork;\n-        return 100*1000;\n-    }\n-    int ActivateSizeForkMajority() const { return nActivateSizeForkMajority; }\n-    uint64_t SizeForkGracePeriod() const { return nSizeForkGracePeriod; }\n-\n protected:\n     CChainParams() {}\n \n@@ -113,15 +82,6 @@ class CChainParams\n     std::vector<unsigned char> vAlertPubKey;\n     int nDefaultPort;\n \n-    /** Maximum block size parameters */\n-    uint32_t nMaxSizePreFork;\n-    uint64_t nEarliestSizeForkTime;\n-    uint32_t nSizeDoubleEpoch;\n-    uint64_t nMaxSizeBase;\n-    uint8_t nMaxSizeDoublings;\n-    int nActivateSizeForkMajority;\n-    uint64_t nSizeForkGracePeriod;\n-\n     int nMinerThreads;\n     uint64_t nPruneAfterHeight;\n     std::vector<CDNSSeedData> vSeeds;"
      },
      {
        "sha": "28eac18b51b992d7827c5a5dead0d4fdc1ba4d02",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -25,6 +25,46 @@ struct Params {\n     int64_t nPowTargetSpacing;\n     int64_t nPowTargetTimespan;\n     int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }\n+\n+    /** Maximum block size parameters */\n+    uint32_t nMaxSizePreFork;\n+    uint64_t nEarliestSizeForkTime;\n+    uint32_t nSizeDoubleEpoch;\n+    uint64_t nMaxSizeBase;\n+    uint8_t nMaxSizeDoublings;\n+    int nActivateSizeForkMajority;\n+    uint64_t nSizeForkGracePeriod;\n+\n+    /** Maximum block size of a block with timestamp nBlockTimestamp */\n+    uint64_t MaxBlockSize(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n+        if (nBlockTimestamp < nEarliestSizeForkTime || nBlockTimestamp < nSizeForkActivationTime)\n+            return nMaxSizePreFork;\n+        if (nBlockTimestamp >= nEarliestSizeForkTime + nSizeDoubleEpoch * nMaxSizeDoublings)\n+            return nMaxSizeBase << nMaxSizeDoublings;\n+\n+        // Piecewise-linear-between-doublings growth. Calculated based on a fixed\n+        // timestamp and not the activation time so the maximum size is\n+        // predictable, and so the activation time can be completely removed in\n+        // a future version of this code after the fork is complete.\n+        uint64_t timeDelta = nBlockTimestamp - nEarliestSizeForkTime;\n+        uint64_t doublings = timeDelta / nSizeDoubleEpoch;\n+        uint64_t remain = timeDelta % nSizeDoubleEpoch;\n+        uint64_t interpolate = (nMaxSizeBase << doublings) * remain / nSizeDoubleEpoch;\n+        uint64_t nMaxSize = (nMaxSizeBase << doublings) + interpolate;\n+        return nMaxSize;\n+    }\n+    /** Maximum number of signature ops in a block with timestamp nBlockTimestamp */\n+    uint64_t MaxBlockSigops(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n+        return MaxBlockSize(nBlockTimestamp, nSizeForkActivationTime)/50;\n+    }\n+    /** Maximum size of a transaction in a block with timestamp nBlockTimestamp */\n+    uint64_t MaxTransactionSize(uint64_t nBlockTimestamp, uint64_t nSizeForkActivationTime) const {\n+        if (nBlockTimestamp < nEarliestSizeForkTime || nBlockTimestamp < nSizeForkActivationTime)\n+            return nMaxSizePreFork;\n+        return 100*1000;\n+    }\n+    int ActivateSizeForkMajority() const { return nActivateSizeForkMajority; }\n+    uint64_t SizeForkGracePeriod() const { return nSizeForkGracePeriod; }\n };\n } // namespace Consensus\n "
      },
      {
        "sha": "cbb56d6ca5c529dd4152c93e1f0af358b8e5994d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -951,7 +951,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n-    if (!CheckTransaction(tx, state, Params().MaxTransactionSize(GetAdjustedTime(), sizeForkTime.load())))\n+    if (!CheckTransaction(tx, state, Params().GetConsensus().MaxTransactionSize(GetAdjustedTime(), sizeForkTime.load())))\n         return error(\"AcceptToMemoryPool: CheckTransaction failed\");\n \n     // Coinbase is only valid in a block, not as a loose transaction\n@@ -1851,8 +1851,8 @@ static int64_t nTimeTotal = 0;\n \n static bool DidBlockTriggerSizeFork(const CBlock &block, const CBlockIndex *pindex, const CChainParams &chainparams) {\n     return (block.nVersion & SIZE_FORK_VERSION) &&\n-           (pblocktree->ForkActivated(SIZE_FORK_VERSION) == uint256()) &&\n-           IsSuperMajority(SIZE_FORK_VERSION, pindex, chainparams.ActivateSizeForkMajority(), chainparams.GetConsensus(), true /* use bitmask */);\n+        (pblocktree->ForkActivated(SIZE_FORK_VERSION) == uint256()) &&\n+        IsSuperMajority(SIZE_FORK_VERSION, pindex, chainparams.GetConsensus().ActivateSizeForkMajority(), chainparams.GetConsensus(), true /* use bitmask */);\n }\n \n bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, bool fJustCheck)\n@@ -1937,7 +1937,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n         nInputs += tx.vin.size();\n         nSigOps += GetLegacySigOpCount(tx);\n-        if (nSigOps > Params().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n+        if (nSigOps > chainparams.GetConsensus().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n             return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n@@ -1953,7 +1953,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 // this is to prevent a \"rogue miner\" from creating\n                 // an incredibly-expensive-to-validate block.\n                 nSigOps += GetP2SHSigOpCount(tx, view);\n-                if (nSigOps > Params().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n+                if (nSigOps > chainparams.GetConsensus().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n                     return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                                      REJECT_INVALID, \"bad-blk-sigops\");\n             }\n@@ -2031,7 +2031,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     LogPrint(\"bench\", \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime4 - nTime3), nTimeCallbacks * 0.000001);\n \n     if (DidBlockTriggerSizeFork(block, pindex, chainparams)) {\n-        uint64_t tAllowBigger = block.nTime + chainparams.SizeForkGracePeriod();\n+        uint64_t tAllowBigger = block.nTime + chainparams.GetConsensus().SizeForkGracePeriod();\n         LogPrintf(\"%s: Max block size fork activating at time %d, bigger blocks allowed at time %d\\n\",\n                   __func__, block.nTime, tAllowBigger);\n         pblocktree->ActivateFork(SIZE_FORK_VERSION, pindex->GetBlockHash());\n@@ -2672,7 +2672,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n     }\n \n     if (!fKnown) {\n-        while (vinfoBlockFile[nFile].nSize + nAddSize >= Params().MaxBlockSize(nTime, sizeForkTime.load())*MIN_BLOCKFILE_BLOCKS) {\n+        while (vinfoBlockFile[nFile].nSize + nAddSize >= Params().GetConsensus().MaxBlockSize(nTime, sizeForkTime.load())*MIN_BLOCKFILE_BLOCKS) {\n             LogPrintf(\"Leaving block file %i: %s\\n\", nFile, vinfoBlockFile[nFile].ToString());\n             FlushBlockFile(true);\n             nFile++;\n@@ -2790,8 +2790,8 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     // because we receive the wrong transactions for it.\n \n     // Size limits\n-    uint64_t nMaxBlockSize = Params().MaxBlockSize(block.GetBlockTime(), sizeForkTime.load());\n-    uint64_t nMaxTxSize = Params().MaxTransactionSize(block.GetBlockTime(), sizeForkTime.load());\n+    uint64_t nMaxBlockSize = Params().GetConsensus().MaxBlockSize(block.GetBlockTime(), sizeForkTime.load());\n+    uint64_t nMaxTxSize = Params().GetConsensus().MaxTransactionSize(block.GetBlockTime(), sizeForkTime.load());\n     if (block.vtx.empty() ||\n         block.vtx.size()*MIN_TRANSACTION_SIZE > nMaxBlockSize ||\n         ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > nMaxBlockSize)\n@@ -2817,7 +2817,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n-    if (nSigOps > Params().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n+    if (nSigOps > Params().GetConsensus().MaxBlockSigops(block.GetBlockTime(), sizeForkTime.load()))\n         return state.DoS(100, error(\"CheckBlock(): out-of-bounds SigOpCount\"),\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n@@ -3249,7 +3249,7 @@ bool static LoadBlockIndexDB()\n     if (sizeForkHash != uint256()) {\n         BlockMap::iterator it = mapBlockIndex.find(sizeForkHash);\n         assert(it != mapBlockIndex.end());\n-        sizeForkTime.store(it->second->GetBlockTime() + chainparams.SizeForkGracePeriod());\n+        sizeForkTime.store(it->second->GetBlockTime() + chainparams.GetConsensus().SizeForkGracePeriod());\n     }\n \n     boost::this_thread::interruption_point();\n@@ -3534,7 +3534,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n     int nLoaded = 0;\n     try {\n         // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor\n-        uint64_t nMaxBlocksize = Params().MaxBlockSize(GetAdjustedTime(), sizeForkTime.load());\n+        uint64_t nMaxBlocksize = chainparams.GetConsensus().MaxBlockSize(GetAdjustedTime(), sizeForkTime.load());\n         CBufferedFile blkdat(fileIn, 2*nMaxBlocksize, nMaxBlocksize+8, SER_DISK, CLIENT_VERSION);\n         uint64_t nRewind = blkdat.GetPos();\n         while (!blkdat.eof()) {\n@@ -3894,7 +3894,7 @@ bool static SanityCheckMessage(CNode* peer, const CNetMessage& msg)\n {\n     const std::string& strCommand = msg.hdr.GetCommand();\n     if (strCommand == \"block\") {\n-        uint64_t maxSize = Params().MaxBlockSize(GetAdjustedTime() + 2 * 60 * 60, sizeForkTime.load());\n+        uint64_t maxSize = Params().GetConsensus().MaxBlockSize(GetAdjustedTime() + 2 * 60 * 60, sizeForkTime.load());\n         if (msg.hdr.nMessageSize > maxSize) {\n             LogPrint(\"net\", \"Oversized %s message from peer=%i\\n\", SanitizeString(strCommand), peer->GetId());\n             return false;"
      },
      {
        "sha": "899d24ee31283aecab9375b56e488b449c0a9221",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -129,7 +129,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n         // Largest block you're willing to create:\n         uint64_t nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-        uint64_t nConsensusMaxSize = Params().MaxBlockSize(nBlockTime, sizeForkTime.load());\n+        uint64_t nConsensusMaxSize = chainparams.GetConsensus().MaxBlockSize(nBlockTime, sizeForkTime.load());\n         // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n         nBlockMaxSize = std::max((uint64_t)1000,\n                                  std::min(nConsensusMaxSize-1000, nBlockMaxSize));\n@@ -249,7 +249,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n             // Legacy limits on sigOps:\n             unsigned int nTxSigOps = GetLegacySigOpCount(tx);\n-            if (nBlockSigOps + nTxSigOps >= Params().MaxBlockSigops(nBlockTime, sizeForkTime.load()))\n+            if (nBlockSigOps + nTxSigOps >= chainparams.GetConsensus().MaxBlockSigops(nBlockTime, sizeForkTime.load()))\n                 continue;\n \n             // Skip free transactions if we're past the minimum block size:\n@@ -276,7 +276,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             CAmount nTxFees = view.GetValueIn(tx)-tx.GetValueOut();\n \n             nTxSigOps += GetP2SHSigOpCount(tx, view);\n-            if (nBlockSigOps + nTxSigOps >= Params().MaxBlockSigops(nBlockTime, sizeForkTime.load()))\n+            if (nBlockSigOps + nTxSigOps >= chainparams.GetConsensus().MaxBlockSigops(nBlockTime, sizeForkTime.load()))\n                 continue;\n \n             // Note that flags: we don't want to set mempool/IsStandard()"
      },
      {
        "sha": "2985eb3c4788c1a8d7a6cd144f91c5deb2eb1213",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -575,9 +575,9 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n-    result.push_back(Pair(\"sigoplimit\", Params().MaxBlockSigops(nBlockTime, sizeForkTime.load())));\n-    result.push_back(Pair(\"sizelimit\", Params().MaxBlockSize(nBlockTime, sizeForkTime.load())));\n-    result.push_back(Pair(\"txsizelimit\", Params().MaxTransactionSize(nBlockTime, sizeForkTime.load())));\n+    result.push_back(Pair(\"sigoplimit\", Params().GetConsensus().MaxBlockSigops(nBlockTime, sizeForkTime.load())));\n+    result.push_back(Pair(\"sizelimit\", Params().GetConsensus().MaxBlockSize(nBlockTime, sizeForkTime.load())));\n+    result.push_back(Pair(\"txsizelimit\", Params().GetConsensus().MaxTransactionSize(nBlockTime, sizeForkTime.load())));\n     result.push_back(Pair(\"curtime\", nBlockTime));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));"
      },
      {
        "sha": "2372fede2f2bd099cfeef92a03db1478e78bd25c",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -296,7 +296,7 @@ UniValue verifytxoutproof(const UniValue& params, bool fHelp)\n     UniValue res(UniValue::VARR);\n \n     vector<uint256> vMatch;\n-    uint64_t nMaxTransactions = Params().MaxBlockSize(merkleBlock.GetBlockTime(), sizeForkTime.load())/60; // 60 bytes == min tx size\n+    uint64_t nMaxTransactions = Params().GetConsensus().MaxBlockSize(merkleBlock.GetBlockTime(), sizeForkTime.load())/60; // 60 bytes == min tx size\n     if (merkleBlock.txn.ExtractMatches(nMaxTransactions, vMatch) != merkleBlock.header.hashMerkleRoot)\n         return res;\n "
      },
      {
        "sha": "119d6808462be01f6a3d25a84a27ba9e2173cb41",
        "filename": "src/test/ReceiveMsgBytes_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b58d92578566a52d696891b5611694b785fd2734/src/test/ReceiveMsgBytes_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b58d92578566a52d696891b5611694b785fd2734/src/test/ReceiveMsgBytes_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/ReceiveMsgBytes_tests.cpp?ref=b58d92578566a52d696891b5611694b785fd2734",
        "patch": "@@ -79,7 +79,7 @@ BOOST_AUTO_TEST_CASE(TooLargeBlock)\n     s << block;\n \n     // Test: too large\n-    size_t maxBlockSize = Params().MaxBlockSize(GetAdjustedTime(), sizeForkTime.load());\n+    size_t maxBlockSize = Params().GetConsensus().MaxBlockSize(GetAdjustedTime(), sizeForkTime.load());\n     s.resize(maxBlockSize+headerLen+1);\n     CNetMessage::FinalizeHeader(s);\n "
      }
    ]
  }
]