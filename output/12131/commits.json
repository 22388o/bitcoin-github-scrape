[
  {
    "sha": "51342eb8a11748fce8a16f45ee95df9a27395592",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MTM0MmViOGExMTc0OGZjZThhMTZmNDVlZTk1ZGY5YTI3Mzk1NTky",
    "commit": {
      "author": {
        "name": "Mark Friedenbach",
        "email": "mark@friedenbach.org",
        "date": "2016-01-22T16:19:17Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:06:56Z"
      },
      "message": "Add midstate output to CSHA256. This allows the intermediate state of a SHA-256 run to be saved for future resumption, or in the case of fast Merkle trees to perform a non-padded hash.",
      "tree": {
        "sha": "c29869ca68ee31a46a57f3fa0b18057ede0dc2a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c29869ca68ee31a46a57f3fa0b18057ede0dc2a1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51342eb8a11748fce8a16f45ee95df9a27395592",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyYAACgkQV692LbM1\nMyKOig//asx11qAZaviqzDbNUs1wx8+eBZUCMuaWRQyZNeeLmWhjmsKssfnippG3\nQ7lfoMABAFlma3Thi5dL8hqS6xmBcgNdiKUVT1KJaRRnoZ9CxRw+yj55KdWbyFrn\n+WXFZjsKwoGF95TckOPX/30DjXN8LiXBtqvPHwSPqpuHW7A3Xr+EiFLnezXvRR3J\n2GOTUWT1cDs2HLOr7Dg2iOp0b4Z7+fkVZwoF3mkm+S9YDKcz2qfLRmO1uTelSID2\nNRBH2OFWfKQrmtNQ9WQnuz2uEIfHb4NNk4+XPWdytwkX/OPIRTLh3Z9ds2JwKNm4\nLaAXY9KmAD4xTCepRsKM/SP7xGgYIOVww/msjm0NnhFn1qU6hLxdD/o2aKaY5stf\nLA/soVI9RgqncArfIflSR3NdmasnrmrqcRhtJLtcsdocY6N15lawQbN9ZoplokyS\nJxo3654YJZR69BeWvxrldrnJtSfJpthvXFgRVMB5UAKRUOOODFdA3I7bsKdyWiuM\n88UihomwYQpI7kaU+NZuMziB1Iu7GdCwTwoOeB8bZRbW8DhEc5CjfZXKEVU/yDQJ\nEiaDxPLUW55AdkcSIMqRwBdo3+pSaY4+KVa+p6ciJjz+B+FqSs0INqIxDFyy1QTe\n49DCaVdKGdRnFfLrJeXlNs9KwtvMRwknQaiPli7k9xct3estm+o=\n=TKZt\n-----END PGP SIGNATURE-----",
        "payload": "tree c29869ca68ee31a46a57f3fa0b18057ede0dc2a1\nparent bdda14d1c01c253a5c553b3b02a82a856b6a1f92\nauthor Mark Friedenbach <mark@friedenbach.org> 1453479557 -0800\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550016 +0900\n\nAdd midstate output to CSHA256. This allows the intermediate state of a SHA-256 run to be saved for future resumption, or in the case of fast Merkle trees to perform a non-padded hash.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51342eb8a11748fce8a16f45ee95df9a27395592",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51342eb8a11748fce8a16f45ee95df9a27395592",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51342eb8a11748fce8a16f45ee95df9a27395592/comments",
    "author": {
      "login": "maaku",
      "id": 69154,
      "node_id": "MDQ6VXNlcjY5MTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maaku",
      "html_url": "https://github.com/maaku",
      "followers_url": "https://api.github.com/users/maaku/followers",
      "following_url": "https://api.github.com/users/maaku/following{/other_user}",
      "gists_url": "https://api.github.com/users/maaku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maaku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maaku/subscriptions",
      "organizations_url": "https://api.github.com/users/maaku/orgs",
      "repos_url": "https://api.github.com/users/maaku/repos",
      "events_url": "https://api.github.com/users/maaku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maaku/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bdda14d1c01c253a5c553b3b02a82a856b6a1f92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdda14d1c01c253a5c553b3b02a82a856b6a1f92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdda14d1c01c253a5c553b3b02a82a856b6a1f92"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 12,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2dcf8b635c7227c4b8ce88f580ab115aa82ac27b",
        "filename": "src/crypto/sha256.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51342eb8a11748fce8a16f45ee95df9a27395592/src/crypto/sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51342eb8a11748fce8a16f45ee95df9a27395592/src/crypto/sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.cpp?ref=51342eb8a11748fce8a16f45ee95df9a27395592",
        "patch": "@@ -231,6 +231,11 @@ void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n     Write(sizedesc, 8);\n+    Midstate(hash, NULL, NULL);\n+}\n+\n+void CSHA256::Midstate(unsigned char hash[OUTPUT_SIZE], uint64_t* len, unsigned char* buffer)\n+{\n     WriteBE32(hash, s[0]);\n     WriteBE32(hash + 4, s[1]);\n     WriteBE32(hash + 8, s[2]);\n@@ -239,6 +244,12 @@ void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE32(hash + 20, s[5]);\n     WriteBE32(hash + 24, s[6]);\n     WriteBE32(hash + 28, s[7]);\n+    if (len) {\n+        *len = bytes << 3;\n+    }\n+    if (buffer) {\n+        memcpy(buffer, buf, bytes % 64);\n+    }\n }\n \n CSHA256& CSHA256::Reset()"
      },
      {
        "sha": "998548f682b320b140a5b9df0135ecad54a20f42",
        "filename": "src/crypto/sha256.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51342eb8a11748fce8a16f45ee95df9a27395592/src/crypto/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51342eb8a11748fce8a16f45ee95df9a27395592/src/crypto/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.h?ref=51342eb8a11748fce8a16f45ee95df9a27395592",
        "patch": "@@ -23,6 +23,7 @@ class CSHA256\n     CSHA256();\n     CSHA256& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    void Midstate(unsigned char hash[OUTPUT_SIZE], uint64_t* bytes, unsigned char* buffer);\n     CSHA256& Reset();\n };\n "
      }
    ]
  },
  {
    "sha": "9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzA1YTRlY2U0YzM1M2EzOTUyZWY4ZTUwZmY1MmJhNWM3OGU0NWJi",
    "commit": {
      "author": {
        "name": "Mark Friedenbach",
        "email": "mark@friedenbach.org",
        "date": "2017-09-21T19:20:09Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:06:57Z"
      },
      "message": "Add custom initialization vector support to CSHA256. Using alternative initialization vectors allows SHA-256 to be reused as a different cryptographic hash function while sharing the same implementation, which is necessary to secure some hash tree protocols.",
      "tree": {
        "sha": "5f251cccd9e64453fee3654652bad14a4741db32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5f251cccd9e64453fee3654652bad14a4741db32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyYEACgkQV692LbM1\nMyIltg/8Ccw14CNqlJ+tSUnbY8+BMPCR+aA3FdWq3XSwNNyQ3wiQsDy0Ja9j7rQ3\naPTyiG6gh/u4Uhln/8Yh57FsL/4P/5JOdVE3E0BN5cGgtURHkI01gGbWJ+mwYM9Y\njZg2KDze1/XDX/dk6E5rohqrx7oL1PHrYbH5ou6Hi1XPC9204Lct/6Ev36ksE3nO\n2nA6EgJIiz3Q2i/gv32ePKEsHRtxWle/f4c4lrHyaaKOvQxwR6xcx+KopadCkWly\nx5/ynHH4ov4uW9fqqkO3f5CLYNqOghHTc6RX578wk0uNFSnD61/mtsvZbKWELvtJ\nW7uzSStAuyurEjhm107RP2NWxojvD+4tUFH3HCJNz4CVWYRL7DM+j4+6P8SfR3/g\nR3Pp0XdSYsi9UmZUvAe+Vyq2JDB4J/y1v6szrNL15Dc3rbuPvowKu0+KnITFRzji\nXtPjNZw2AbuPoXKCyzqUphsObkoD9EksuhAJUA5FfdmcFuD4ttPdpakgYhrWcrN+\nFTxoiPS2qh71PrTKKRYCo7VVAOKmjc7aE+HQdNe0YYtQo2wTh6l3egIP4MR99GuR\n8X6cRZytvmPIEQrn+qT8HsPXvZG0NnQMn6x8VPrcNE4m4IPfeIWxzeVVMNtCQwB7\nqcbxK6NRC+DaZpZOPbmXkoDk/bpPYetAgW08m8yqpsWbvGZkJlo=\n=t2ah\n-----END PGP SIGNATURE-----",
        "payload": "tree 5f251cccd9e64453fee3654652bad14a4741db32\nparent 51342eb8a11748fce8a16f45ee95df9a27395592\nauthor Mark Friedenbach <mark@friedenbach.org> 1506021609 -0700\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550017 +0900\n\nAdd custom initialization vector support to CSHA256. Using alternative initialization vectors allows SHA-256 to be reused as a different cryptographic hash function while sharing the same implementation, which is necessary to secure some hash tree protocols.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb/comments",
    "author": {
      "login": "maaku",
      "id": 69154,
      "node_id": "MDQ6VXNlcjY5MTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maaku",
      "html_url": "https://github.com/maaku",
      "followers_url": "https://api.github.com/users/maaku/followers",
      "following_url": "https://api.github.com/users/maaku/following{/other_user}",
      "gists_url": "https://api.github.com/users/maaku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maaku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maaku/subscriptions",
      "organizations_url": "https://api.github.com/users/maaku/orgs",
      "repos_url": "https://api.github.com/users/maaku/repos",
      "events_url": "https://api.github.com/users/maaku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maaku/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "51342eb8a11748fce8a16f45ee95df9a27395592",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51342eb8a11748fce8a16f45ee95df9a27395592",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/51342eb8a11748fce8a16f45ee95df9a27395592"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 13,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b78136388f8edc809a71a43e0898c2e1408cf168",
        "filename": "src/crypto/sha256.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb/src/crypto/sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb/src/crypto/sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.cpp?ref=9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
        "patch": "@@ -198,6 +198,18 @@ CSHA256::CSHA256() : bytes(0)\n     sha256::Initialize(s);\n }\n \n+CSHA256::CSHA256(const unsigned char iv[OUTPUT_SIZE]) : bytes(0)\n+{\n+    s[0] = ReadBE32(iv);\n+    s[1] = ReadBE32(iv + 4);\n+    s[2] = ReadBE32(iv + 8);\n+    s[3] = ReadBE32(iv + 12);\n+    s[4] = ReadBE32(iv + 16);\n+    s[5] = ReadBE32(iv + 20);\n+    s[6] = ReadBE32(iv + 24);\n+    s[7] = ReadBE32(iv + 28);\n+}\n+\n CSHA256& CSHA256::Write(const unsigned char* data, size_t len)\n {\n     const unsigned char* end = data + len;"
      },
      {
        "sha": "3bdd6e15fae275b8e3fc89901575fab6daaee010",
        "filename": "src/crypto/sha256.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb/src/crypto/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb/src/crypto/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.h?ref=9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
        "patch": "@@ -21,6 +21,7 @@ class CSHA256\n     static const size_t OUTPUT_SIZE = 32;\n \n     CSHA256();\n+    CSHA256(const unsigned char iv[OUTPUT_SIZE]);\n     CSHA256& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     void Midstate(unsigned char hash[OUTPUT_SIZE], uint64_t* bytes, unsigned char* buffer);"
      }
    ]
  },
  {
    "sha": "74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NGQ0NWJlNDFmODI0M2JkYmU0YWQ2MGFkYmI2OTlmNTJiNGUyZTI4",
    "commit": {
      "author": {
        "name": "Mark Friedenbach",
        "email": "mark@friedenbach.org",
        "date": "2016-01-22T16:50:33Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:06:57Z"
      },
      "message": "Add fast Merkle branch functions. A fast Merkle branch uses midstate to perform a single SHA-256 compression with a custom initialization vector per internal node of a binary Merkle tree, and is not vulnerable to CVE-2012-2459. It produces different hash values though, so can only be used for new hash trees going forward.",
      "tree": {
        "sha": "fefad0b4cc330cdb0cf3d9bb05178fe1dd5fa906",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fefad0b4cc330cdb0cf3d9bb05178fe1dd5fa906"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyYEACgkQV692LbM1\nMyLC4Q//fsjPUGybqMIYli1AIg02xBSdPWVHre/gTP0A/WDDMkbdmJP7RJZbVBY4\nmjHqJrF4c7ljD+sBiX6vHR0ctXLB/OCY/L+VBU5sRKdk5WTrq2kBOJTkLdRd/Log\nMLW4mQxmbnV1OqJ+rhv3I4zlq7dPsi+vafBwQUU2WtOn0OkedZWYhjs5gKpFWHNT\npjXUwpbG12Fv65JE6/lJONVzN5ELTP5R8TbiEVgAHvxpq7XJy15fRbKEfrtS4de2\nTs4H20H5PjxkbK7w6iBFwz/5SOzJaGZDxS/u60KkR0dAa7yXbOS5HyRBcMMMKEgZ\n2UmbPybpLxjZv1qHiywCkBOYRlLd2f5MFZFAK5MM1momimHm2plzedSr4GyxF8uf\nIWmoHKuxc2BcXe+JYPMPMxqaAmVQ0ldRIqd+/DHPzcFI0pfHgltu0TSmj6dbwGjB\nlSi7eVLDZelZtU8CP5AjbnBIWqKscHUVRjy04qrWxfghXxfbyPeTlATsvTFsGpqS\n346m7w/YJg5RmUV2Pgvdn7ULVayMOQMD13kHwmdZ2BdIwp9qFjgRhIrGxSTIrIaF\nhK2xh7LPOBWUTrhFkw5xy+Xra29R2NaNXmxzcgqyfsm4ty/mBlqd7zimrAqrn+Uu\nZ7tvUQ/UtyUmsQ+2+1fmMy83fdmb3PVcU17h8Z1/j2AKV6bjx+I=\n=CpAg\n-----END PGP SIGNATURE-----",
        "payload": "tree fefad0b4cc330cdb0cf3d9bb05178fe1dd5fa906\nparent 9705a4ece4c353a3952ef8e50ff52ba5c78e45bb\nauthor Mark Friedenbach <mark@friedenbach.org> 1453481433 -0800\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550017 +0900\n\nAdd fast Merkle branch functions. A fast Merkle branch uses midstate to perform a single SHA-256 compression with a custom initialization vector per internal node of a binary Merkle tree, and is not vulnerable to CVE-2012-2459. It produces different hash values though, so can only be used for new hash trees going forward.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/comments",
    "author": {
      "login": "maaku",
      "id": 69154,
      "node_id": "MDQ6VXNlcjY5MTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maaku",
      "html_url": "https://github.com/maaku",
      "followers_url": "https://api.github.com/users/maaku/followers",
      "following_url": "https://api.github.com/users/maaku/following{/other_user}",
      "gists_url": "https://api.github.com/users/maaku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maaku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maaku/subscriptions",
      "organizations_url": "https://api.github.com/users/maaku/orgs",
      "repos_url": "https://api.github.com/users/maaku/repos",
      "events_url": "https://api.github.com/users/maaku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maaku/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9705a4ece4c353a3952ef8e50ff52ba5c78e45bb"
      }
    ],
    "stats": {
      "total": 187,
      "additions": 180,
      "deletions": 7
    },
    "files": [
      {
        "sha": "a7a065f92d3396862dc37e730fc91a88301bcd5b",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 7,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
        "patch": "@@ -42,14 +42,45 @@\n        root.\n */\n \n+typedef enum {\n+    MERKLE_COMPUTATION_MUTABLE = 0x1,\n+    MERKLE_COMPUTATION_FAST    = 0x2\n+} merklecomputationopts;\n+\n+static void MerkleHash_Hash256(uint256& parent, const uint256& left, const uint256& right) {\n+    CHash256().Write(left.begin(), 32).Write(right.begin(), 32).Finalize(parent.begin());\n+}\n+\n+/* Calculated by using standard FIPS-180 SHA-256 to hash the first 512\n+ * bits of the fractional part of the square root of 2 then extracting\n+ * the midstate. This initial data, expressed in hexadecimal notation\n+ * is:\n+ *\n+ *   6a09e667f3bcc908 b2fb1366ea957d3e 3adec17512775099 da2f590b0667322a\n+ *   95f9060875714587 5163fcdfb907b672 1ee950bc8738f694 f0090e6c7bf44ed1\n+ */\n+static unsigned char _MidstateIV[32] =\n+    { 0x91, 0x06, 0x6c, 0x2b, 0x97, 0x5c, 0xc8, 0x32,\n+      0xe7, 0x6c, 0xd4, 0x01, 0x68, 0x21, 0x8d, 0x36,\n+      0x18, 0xd0, 0x9b, 0xe1, 0x9a, 0x7b, 0xff, 0xc0,\n+      0xec, 0x1d, 0xcc, 0xf0, 0x8f, 0x77, 0x5b, 0xbd };\n+static void MerkleHash_Sha256Midstate(uint256& parent, const uint256& left, const uint256& right) {\n+    CSHA256(_MidstateIV).Write(left.begin(), 32).Write(right.begin(), 32).Midstate(parent.begin(), NULL, NULL);\n+}\n+\n /* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */\n-static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector<uint256>* pbranch) {\n+static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector<uint256>* pbranch, merklecomputationopts flags) {\n     if (pbranch) pbranch->clear();\n     if (leaves.size() == 0) {\n         if (pmutated) *pmutated = false;\n         if (proot) *proot = uint256();\n         return;\n     }\n+    bool is_mutable = flags & MERKLE_COMPUTATION_MUTABLE;\n+    auto MerkleHash = MerkleHash_Hash256;\n+    if (flags & MERKLE_COMPUTATION_FAST) {\n+        MerkleHash = MerkleHash_Sha256Midstate;\n+    }\n     bool mutated = false;\n     // count is the number of leaves processed so far.\n     uint32_t count = 0;\n@@ -80,7 +111,7 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n                 }\n             }\n             mutated |= (inner[level] == h);\n-            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+            MerkleHash(h, inner[level], h);\n         }\n         // Store the resulting hash at inner position level.\n         inner[level] = h;\n@@ -103,10 +134,12 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n         // If we reach this point, h is an inner value that is not the top.\n         // We combine it with itself (Bitcoin's special rule for odd levels in\n         // the tree) to produce a higher level one.\n-        if (pbranch && matchh) {\n+        if (is_mutable && pbranch && matchh) {\n             pbranch->push_back(h);\n         }\n-        CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+        if (is_mutable) {\n+            MerkleHash(h, h, h);\n+        }\n         // Increment count to the value it would have if two entries at this\n         // level had existed.\n         count += (((uint32_t)1) << level);\n@@ -121,7 +154,7 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n                     matchh = true;\n                 }\n             }\n-            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+            MerkleHash(h, inner[level], h);\n             level++;\n         }\n     }\n@@ -132,13 +165,13 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n \n uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated) {\n     uint256 hash;\n-    MerkleComputation(leaves, &hash, mutated, -1, nullptr);\n+    MerkleComputation(leaves, &hash, mutated, -1, nullptr, MERKLE_COMPUTATION_MUTABLE);\n     return hash;\n }\n \n std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position) {\n     std::vector<uint256> ret;\n-    MerkleComputation(leaves, nullptr, nullptr, position, &ret);\n+    MerkleComputation(leaves, nullptr, nullptr, position, &ret, MERKLE_COMPUTATION_MUTABLE);\n     return ret;\n }\n \n@@ -155,6 +188,51 @@ uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint2\n     return hash;\n }\n \n+uint256 ComputeFastMerkleRoot(const std::vector<uint256>& leaves) {\n+    uint256 hash;\n+    if (leaves.empty()) {\n+        hash = CHashWriter(SER_GETHASH, PROTOCOL_VERSION).GetHash();\n+    } else {\n+        MerkleComputation(leaves, &hash, nullptr, -1, nullptr, MERKLE_COMPUTATION_FAST);\n+    }\n+    return hash;\n+}\n+\n+std::pair<std::vector<uint256>, uint32_t> ComputeFastMerkleBranch(const std::vector<uint256>& leaves, uint32_t position) {\n+    std::vector<uint256> branch;\n+    MerkleComputation(leaves, nullptr, nullptr, position, &branch, MERKLE_COMPUTATION_FAST);\n+    std::size_t max = 0;\n+    for (int i = 0; i < 32; ++i)\n+        if (position & ((uint32_t)1)<<i)\n+            max = i + 1;\n+    uint32_t path = position;\n+    while (max > branch.size()) {\n+        int i;\n+        for (i = max-1; i >= 0; --i)\n+            if (!(path & ((uint32_t)1)<<i))\n+                break;\n+        if (i < 0) // Should never happen\n+            return {};\n+        path = ((path & ~((((uint32_t)1)<<(i+1))-1))>>1)\n+             |  (path &  ((((uint32_t)1)<< i   )-1));\n+        --max;\n+    }\n+    return {branch, path};\n+}\n+\n+uint256 ComputeFastMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t path) {\n+    uint256 hash = leaf;\n+    for (std::vector<uint256>::const_iterator it = branch.begin(); it != branch.end(); ++it) {\n+        if (path & 1) {\n+            MerkleHash_Sha256Midstate(hash, *it, hash);\n+        } else {\n+            MerkleHash_Sha256Midstate(hash, hash, *it);\n+        }\n+        path >>= 1;\n+    }\n+    return hash;\n+}\n+\n uint256 BlockMerkleRoot(const CBlock& block, bool* mutated)\n {\n     std::vector<uint256> leaves;"
      },
      {
        "sha": "eeb6d89634c356c21503e5831fc60af4b0a0f1a7",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
        "patch": "@@ -16,6 +16,61 @@ uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = nu\n std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position);\n uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t position);\n \n+/*\n+ * Has similar API semantics, but produces Merkle roots and validates\n+ * branches 3x as fast, and without the mutation vulnerability. Cannot\n+ * be substituted for the non-fast variants because the hash values are\n+ * different. ComputeFastMerkleBranch returns a pair with the second\n+ * element being the path used to validate the branch.\n+ *\n+ * Because the fast Merkle branch does not do unnecessary hash operations,\n+ * the path used to validate a branch is derived from but not necessarily\n+ * the same as the original position in the list. ComputeFastMerkleBranch\n+ * calculates the path by dropping high-order zeros from the binary\n+ * representation of the position until the path is the same length or\n+ * less as the number of Merkle branches.\n+ *\n+ * To understand why this works, consider a list of 303 elements from\n+ * which a fast Merkle tree is constructed, and we request the branch to\n+ * the 292nd element. The binary encoded positions of the last and\n+ * desired elements are as follows:\n+ *\n+ *   0b 1 0 0 1 0 1 1 1 0 # decimal 302 (zero-indexed)\n+ *\n+ *   0b 1 0 0 1 0 0 0 1 1 # decimal 291\n+ *\n+ * The root of the Merkle tree has a left branch that contains 2^8 = 256\n+ * elements, and a right branch that contains the remaining 47. The first\n+ * level of the right branch contains 2^5 = 32 nodes on the left side, and\n+ * the remaining 15 nodes on the right side. The next level contains 2^3 =\n+ * 8 nodes on the left, and the remaining 7 on the right. This pattern\n+ * repeats on the right hand side of the tree: each layer has the largest\n+ * remaining power of two on the left, and the residual on the right.\n+ *\n+ * Notice specifically that the sizes of the sub-trees correspnd to the\n+ * set bits in the zero-based index of the final element. For each 1 at,\n+ * index n, there is a branch with 2^n elements on the left and the\n+ * remaining amount on the right.\n+ *\n+ * So, for an element whose path traverse the right-side of the tree, the\n+ * intervening levels (e.g. 2^7 and 2^6) are missing. These correspond to\n+ * zeros in the binary expansion, and they are removed from the path\n+ * description. However once the path takes a left-turn into the tree (a\n+ * zero where a one is present in the expansion of the last element), the\n+ * sub-tree is full and no more 0's can be pruned out.\n+ *\n+ * So the path for element 292 becomes:\n+ *\n+ *     0b 1 - - 1 - 0 0 1 1 # decimal 291\n+ *\n+ *   = 0b 1 1 0 0 1 1\n+ *\n+ *   = 51\n+ */\n+uint256 ComputeFastMerkleRoot(const std::vector<uint256>& leaves);\n+std::pair<std::vector<uint256>, uint32_t> ComputeFastMerkleBranch(const std::vector<uint256>& leaves, uint32_t position);\n+uint256 ComputeFastMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t path);\n+\n /*\n  * Compute the Merkle root of the transactions in a block.\n  * *mutated is set to true if a duplicated subtree was found."
      },
      {
        "sha": "3d6cf8e337a13badc455f4a9bde54b8e77e544ca",
        "filename": "src/test/merkle_tests.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/src/test/merkle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74d45be41f8243bdbe4ad60adbb699f52b4e2e28/src/test/merkle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkle_tests.cpp?ref=74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
        "patch": "@@ -132,4 +132,44 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(fast_merkle_branch)\n+{\n+    const std::vector<uint256> leaves = {\n+      (CHashWriter(SER_GETHASH, PROTOCOL_VERSION) << 'a').GetHash(),\n+      (CHashWriter(SER_GETHASH, PROTOCOL_VERSION) << 'b').GetHash(),\n+      (CHashWriter(SER_GETHASH, PROTOCOL_VERSION) << 'c').GetHash(),\n+    };\n+    const uint256 root = ComputeFastMerkleRoot(leaves);\n+    BOOST_CHECK(root == uint256S(\"0x9cde1ad752292baac9c86e91d0c0e506a3bc0e7f11fd449c8c54bbd3e46d91a1\"));\n+    {\n+        std::vector<uint256> branch;\n+        uint32_t path;\n+        std::tie(branch, path) = ComputeFastMerkleBranch(leaves, 0);\n+        BOOST_CHECK(path == 0);\n+        BOOST_CHECK(branch.size() == 2);\n+        BOOST_CHECK(branch[0] == leaves[1]);\n+        BOOST_CHECK(branch[1] == leaves[2]);\n+        BOOST_CHECK(root == ComputeFastMerkleRootFromBranch(leaves[0], branch, path));\n+    }\n+    {\n+        std::vector<uint256> branch;\n+        uint32_t path;\n+        std::tie(branch, path) = ComputeFastMerkleBranch(leaves, 1);\n+        BOOST_CHECK(path == 1);\n+        BOOST_CHECK(branch.size() == 2);\n+        BOOST_CHECK(branch[0] == leaves[0]);\n+        BOOST_CHECK(branch[1] == leaves[2]);\n+        BOOST_CHECK(root == ComputeFastMerkleRootFromBranch(leaves[1], branch, path));\n+    }\n+    {\n+        std::vector<uint256> branch;\n+        uint32_t path;\n+        std::tie(branch, path) = ComputeFastMerkleBranch(leaves, 2);\n+        BOOST_CHECK(path == 1);\n+        BOOST_CHECK(branch.size() == 1);\n+        BOOST_CHECK(branch[0] == uint256S(\"0xc771140365578d348d7ffc6e04a102ecf3e2eea51177d38fac92f954aebdd1cd\"));\n+        BOOST_CHECK(root == ComputeFastMerkleRootFromBranch(leaves[2], branch, path));\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "240c6af170f980303404a2e5b0bd8a9a76c98231",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDBjNmFmMTcwZjk4MDMwMzQwNGEyZTViMGJkOGE5YTc2Yzk4MjMx",
    "commit": {
      "author": {
        "name": "Mark Friedenbach",
        "email": "mark@friedenbach.org",
        "date": "2017-12-13T23:17:49Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:07:59Z"
      },
      "message": "Add MerkleProof and MerkleTree data structures, for efficiently transmitting and validating proofs of multiple elements from a fast Merkle tree. The MerkleProof contains the tree structure and skip hashes, while the MerkleTree contains a proof and associated verify hashes.",
      "tree": {
        "sha": "bb418ef23b5cc15c45ffe90d65453645030eb1e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bb418ef23b5cc15c45ffe90d65453645030eb1e6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/240c6af170f980303404a2e5b0bd8a9a76c98231",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyb8ACgkQV692LbM1\nMyLBIg//Vx9DZDGEcgTEcxrsL0bevT1goGcByTmClzchDOTtOjRonglRPIpfMCNm\nhOcTcRoJLz0Z1txPhky+PRA5M8DI3IrsySCtvsKTxN2fc6FS4/IeMKtmT/THNf1i\ngMol2OoUKyBs/rAEUnzi/vSJXJKckvNr7H9jQjjGdSmJwvROIIVXjSzL8eNEbfAr\nzwFGLxYFIflnKk5WvKxb/NYa2jhnR7aVB5Mn8LYJGVtxfaR/9QM7M9z3URk7We8d\nho0xfK0TtKfNM/qbAt4u3CWK2bzUHY7YTXZv8khvjWvLxICJTNHPX0GxFBiXxEYb\nAWneC6Ogkp77I7UfeqQnR1la0N8PMJe20gDjn3YWNGYrW8jDoRk2fi9onvGlhnrm\nuKQ+BdYfuYwYdIbTaLGe1dLGCfCpT/Hgl+AbeLRCV9sGbwIcoOo5OPnpy7AbK3vw\njB3J9qDxnVKe3V94HQleDg876KuLjDcnc0r+JwSvVhNbM3xB8HaevGDiYGK17X9i\nWDEzXbMoznxnmCfZKBMUozCgnlG0MHQ3svxl6WfTERNtRUQGcrZ3hbiboKygoFnj\nuY/YMc/ETlWHj+sBZ56aqO/nW0AOaA64k3rlNO3y/VMsgA3yTuLN9LlCl2yjvj8/\n9EaJvNxVXYiGI1+EYoYVM5YQfJZHae+1j/B6YhO1sktoSByc4+Y=\n=+c+e\n-----END PGP SIGNATURE-----",
        "payload": "tree bb418ef23b5cc15c45ffe90d65453645030eb1e6\nparent 74d45be41f8243bdbe4ad60adbb699f52b4e2e28\nauthor Mark Friedenbach <mark@friedenbach.org> 1513207069 -0800\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550079 +0900\n\nAdd MerkleProof and MerkleTree data structures, for efficiently transmitting and validating proofs of multiple elements from a fast Merkle tree. The MerkleProof contains the tree structure and skip hashes, while the MerkleTree contains a proof and associated verify hashes.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/240c6af170f980303404a2e5b0bd8a9a76c98231",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/240c6af170f980303404a2e5b0bd8a9a76c98231",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/240c6af170f980303404a2e5b0bd8a9a76c98231/comments",
    "author": {
      "login": "maaku",
      "id": 69154,
      "node_id": "MDQ6VXNlcjY5MTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maaku",
      "html_url": "https://github.com/maaku",
      "followers_url": "https://api.github.com/users/maaku/followers",
      "following_url": "https://api.github.com/users/maaku/following{/other_user}",
      "gists_url": "https://api.github.com/users/maaku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maaku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maaku/subscriptions",
      "organizations_url": "https://api.github.com/users/maaku/orgs",
      "repos_url": "https://api.github.com/users/maaku/repos",
      "events_url": "https://api.github.com/users/maaku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maaku/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74d45be41f8243bdbe4ad60adbb699f52b4e2e28",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/74d45be41f8243bdbe4ad60adbb699f52b4e2e28"
      }
    ],
    "stats": {
      "total": 2708,
      "additions": 2708,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1aaba1599aa77c1ae4bba63922b93d85a6a90e1f",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 293,
        "deletions": 0,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/240c6af170f980303404a2e5b0bd8a9a76c98231/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/240c6af170f980303404a2e5b0bd8a9a76c98231/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=240c6af170f980303404a2e5b0bd8a9a76c98231",
        "patch": "@@ -263,3 +263,296 @@ std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n     }\n     return ComputeMerkleBranch(leaves, position);\n }\n+\n+/*\n+ * The {SKIP, SKIP} entry is missing on purpose. Not only does this\n+ * make the number of possible states a nicely packable power of 2,\n+ * but excluding that fully prunable state means that any given fully\n+ * expanded tree and set of verify hashes has one and only one proof\n+ * encoding -- the serialized tree with all {SKIP, SKIP} nodes\n+ * recursively pruned.\n+ */\n+const std::array<MerkleLink, 8> MerkleNode::m_left_from_code {{\n+    MerkleLink::VERIFY,  MerkleLink::VERIFY,  MerkleLink::VERIFY,\n+    MerkleLink::DESCEND, MerkleLink::DESCEND, MerkleLink::DESCEND,\n+      /* No SKIP */      MerkleLink::SKIP,    MerkleLink::SKIP }};\n+\n+const std::array<MerkleLink, 8> MerkleNode::m_right_from_code {{\n+    MerkleLink::SKIP, MerkleLink::VERIFY, MerkleLink::DESCEND,\n+    MerkleLink::SKIP, MerkleLink::VERIFY, MerkleLink::DESCEND,\n+      /* No SKIP */   MerkleLink::VERIFY, MerkleLink::DESCEND }};\n+\n+MerkleNode::code_type MerkleNode::_get_code(MerkleLink left, MerkleLink right)\n+{\n+    /*\n+     * Returns the 3-bit code for a given combination of left and\n+     * right link values in an internal node.\n+     */\n+    code_type code = std::numeric_limits<code_type>::max();\n+    /* Write out a table of Code values to see why this works :) */\n+    switch (left)\n+    {\n+        case MerkleLink::DESCEND: code = 5; break;\n+        case MerkleLink::VERIFY:  code = 2; break;\n+        case MerkleLink::SKIP:    code = 7; break;\n+    }\n+    switch (right)\n+    {\n+        case MerkleLink::SKIP:    --code; // No break!\n+        case MerkleLink::VERIFY:  --code; break;\n+        case MerkleLink::DESCEND:         break;\n+    }\n+    return code;\n+}\n+\n+MerkleNode::code_type MerkleNodeReference::GetCode() const\n+{\n+    /*\n+     * Belts and suspenders: m_offset should never be anything outside\n+     * the range [0, 7], so the assignment to max should be undone by\n+     * the switch that follows. But just in case we'll favor failing\n+     * in a way that is maximally likely to be detectable when the\n+     * code is later used.\n+     */\n+    MerkleNode::code_type code = std::numeric_limits<MerkleNode::code_type>::max();\n+    assert((m_offset >= 0) && (m_offset <= 7));\n+    switch (m_offset)\n+    {\n+        /*\n+         * Use the diagram in the class definition to work out that\n+         * these magic constant values are correct.\n+         */\n+        case 0: code =   m_base[0] >> 5;  break;\n+        case 1: code =   m_base[0] >> 2;  break;\n+        case 2: code =  (m_base[0] << 1)\n+                     | ((m_base[1] >> 7) & 1); break;\n+        case 3: code =   m_base[1] >> 4;  break;\n+        case 4: code =   m_base[1] >> 1;  break;\n+        case 5: code =  (m_base[1] << 2)\n+                     | ((m_base[2] >> 6) & 3); break;\n+        case 6: code =   m_base[2] >> 3;       break;\n+        case 7: code =   m_base[2];            break;\n+    }\n+    return code & 7;\n+}\n+\n+MerkleNodeReference& MerkleNodeReference::SetCode(MerkleNode::code_type code)\n+{\n+    switch (m_offset)\n+    {\n+        /*\n+         * Again, check the diagram in the class definition to see\n+         * where these magic constant shift and mask values arise\n+         * from.\n+         */\n+        case 0: m_base[0] = (m_base[0] & 0x1f) |  (code      << 5); break;\n+        case 1: m_base[0] = (m_base[0] & 0xe3) |  (code      << 2); break;\n+        case 2: m_base[0] = (m_base[0] & 0xfc) |  (code      >> 1);\n+                m_base[1] = (m_base[1] & 0x7f) | ((code & 1) << 7); break;\n+        case 3: m_base[1] = (m_base[1] & 0x8f) |  (code      << 4); break;\n+        case 4: m_base[1] = (m_base[1] & 0xf1) |  (code      << 1); break;\n+        case 5: m_base[1] = (m_base[1] & 0xfe) |  (code      >> 2);\n+                m_base[2] = (m_base[2] & 0x3f) | ((code & 3) << 6); break;\n+        case 6: m_base[2] = (m_base[2] & 0xc7) |  (code      << 3); break;\n+        case 7: m_base[2] = (m_base[2] & 0xf8) |   code;            break;\n+    }\n+    return *this;\n+}\n+\n+void MerkleNodeIteratorBase::_incr()\n+{\n+    if (m_ref.m_offset++ == 7) {\n+        m_ref.m_offset = 0;\n+        m_ref.m_base += 3;\n+    }\n+}\n+\n+void MerkleNodeIteratorBase::_decr()\n+{\n+    if (m_ref.m_offset-- == 0) {\n+        m_ref.m_offset = 7;\n+        m_ref.m_base -= 3;\n+    }\n+}\n+\n+void MerkleNodeIteratorBase::_seek(MerkleNodeIteratorBase::difference_type distance)\n+{\n+    difference_type bits = distance + m_ref.m_offset;\n+    m_ref.m_base += 3 * (bits / 8);\n+    bits = bits % 8;\n+    if (bits < 0) {\n+        bits += 8;\n+        m_ref.m_base -= 3;\n+    }\n+    m_ref.m_offset = static_cast<MerkleNodeReference::offset_type>(bits);\n+}\n+\n+MerkleNodeIteratorBase::difference_type MerkleNodeIteratorBase::operator-(const MerkleNodeIteratorBase& other) const\n+{\n+    /*\n+     * Compare with the version of _seek implemented above. The\n+     * following property should hold true:\n+     *\n+     *   A._seek(B-A) == B\n+     *\n+     * That is to say, the difference between two iterators is the\n+     * value which needs to be passed to _seek() to move from one to\n+     * the other.\n+     */\n+    return 8 * (m_ref.m_base - other.m_ref.m_base) / 3 + m_ref.m_offset - other.m_ref.m_offset;\n+}\n+\n+void MerkleProof::clear() noexcept\n+{\n+    m_path.clear();\n+    m_skip.clear();\n+}\n+\n+void swap(MerkleProof& lhs, MerkleProof& rhs)\n+{\n+    using std::swap;\n+    swap(lhs.m_path, rhs.m_path);\n+    swap(lhs.m_skip, rhs.m_skip);\n+}\n+\n+MerkleTree::MerkleTree(const MerkleTree& left, const MerkleTree& right)\n+{\n+    /* Handle the special case of both left and right being fully\n+     * pruned, which also results in a fully pruned super-tree.. */\n+    if (left.m_proof.m_path.empty() && left.m_proof.m_skip.size()==1 && left.m_verify.empty() &&\n+        right.m_proof.m_path.empty() && right.m_proof.m_skip.size()==1 && right.m_verify.empty())\n+    {\n+        m_proof.m_skip.resize(1);\n+        MerkleHash_Sha256Midstate(m_proof.m_skip[0], left.m_proof.m_skip[0], right.m_proof.m_skip[0]);\n+        return;\n+    }\n+\n+    /* We assume a well-formed, non-empty MerkleTree for both passed\n+     * in subtrees, in which if there are no internal nodes than\n+     * either m_skip XOR m_verify must have a single hash. Otherwise\n+     * the result of what follows will be an invalid MerkleTree. */\n+    m_proof.m_path.emplace_back(MerkleLink::DESCEND, MerkleLink::DESCEND);\n+\n+    if (left.m_proof.m_path.empty())\n+        m_proof.m_path.front().SetLeft(left.m_proof.m_skip.empty()? MerkleLink::VERIFY: MerkleLink::SKIP);\n+    m_proof.m_path.insert(m_proof.m_path.end(), left.m_proof.m_path.begin(), left.m_proof.m_path.end());\n+    m_proof.m_skip.insert(m_proof.m_skip.end(), left.m_proof.m_skip.begin(), left.m_proof.m_skip.end());\n+    m_verify.insert(m_verify.end(), left.m_verify.begin(), left.m_verify.end());\n+\n+    if (right.m_proof.m_path.empty())\n+        m_proof.m_path.front().SetRight(right.m_proof.m_skip.empty()? MerkleLink::VERIFY: MerkleLink::SKIP);\n+    m_proof.m_path.insert(m_proof.m_path.end(), right.m_proof.m_path.begin(), right.m_proof.m_path.end());\n+    m_proof.m_skip.insert(m_proof.m_skip.end(), right.m_proof.m_skip.begin(), right.m_proof.m_skip.end());\n+    m_verify.insert(m_verify.end(), right.m_verify.begin(), right.m_verify.end());\n+}\n+\n+void MerkleTree::clear() noexcept\n+{\n+    m_proof.clear();\n+    m_verify.clear();\n+}\n+\n+void swap(MerkleTree& lhs, MerkleTree& rhs)\n+{\n+    using std::swap;\n+    swap(lhs.m_proof, rhs.m_proof);\n+    swap(lhs.m_verify, rhs.m_verify);\n+}\n+\n+uint256 MerkleTree::GetHash(bool* invalid) const\n+{\n+    std::vector<std::pair<bool, uint256> > stack(2);\n+    auto verify_pos = m_verify.begin();\n+    auto verify_last = m_verify.end();\n+    auto skip_pos = m_proof.m_skip.begin();\n+    auto skip_last = m_proof.m_skip.end();\n+\n+    auto visitor = [&stack, &verify_pos, &verify_last, &skip_pos, &skip_last](std::size_t depth, MerkleLink value, bool right) -> bool\n+    {\n+        const uint256* new_hash = nullptr;\n+        switch(value) {\n+            case MerkleLink::DESCEND:\n+                stack.emplace_back();\n+                return false;\n+\n+            case MerkleLink::VERIFY:\n+                if (verify_pos == verify_last) // read past end of verify hashes list\n+                    return true;\n+                new_hash = &(verify_pos++)[0];\n+                break;\n+\n+            case MerkleLink::SKIP:\n+                if (skip_pos == skip_last) // read past end of skip hashes list\n+                    return true;\n+                new_hash = &(skip_pos++)[0];\n+                break;\n+        }\n+\n+        uint256 tmp;\n+        while (stack.back().first) {\n+            MerkleHash_Sha256Midstate(tmp, stack.back().second, *new_hash);\n+            new_hash = &tmp;\n+            stack.pop_back();\n+        }\n+\n+        stack.back().first = true;\n+        stack.back().second = *new_hash;\n+        return false;\n+    };\n+\n+    // As a special case, an empty proof with no verify hashes results\n+    // in the unsalted hash of empty string. Although this requires\n+    // extra work in this implementation to support, it provides\n+    // continuous semantics to the meaning of the MERKLEBLOCKVERIFY\n+    // opcode, which might potentially reduce the number of code paths\n+    // in some scripts.\n+    if (m_proof.m_path.empty() && m_verify.empty() && m_proof.m_skip.empty()) {\n+        if (invalid) {\n+            *invalid = false;\n+        }\n+        return CHashWriter(SER_GETHASH, PROTOCOL_VERSION).GetHash();\n+    }\n+\n+    // Except for the special case of a 0-node, 0-verify, 0-skip tree,\n+    // it is always the case (for any binary tree), that the number of\n+    // leaf nodes (verify + skip) is one more than the number of\n+    // internal nodes in the tree.\n+    if ((m_verify.size() + m_proof.m_skip.size()) != (m_proof.m_path.size() + 1)) {\n+        if (invalid) {\n+            *invalid = true;\n+        }\n+        return uint256();\n+    }\n+\n+    // If there are NO nodes in the tree, then this is the degenerate\n+    // case of a single hash, in either the verify or skip set.\n+    if (m_proof.m_path.empty()) {\n+        if (invalid) {\n+            *invalid = false;\n+        }\n+        if (!m_verify.empty()) {\n+            return m_verify[0];\n+        } else {\n+            return m_proof.m_skip[0];\n+        }\n+    }\n+\n+    auto res = depth_first_traverse(m_proof.m_path.begin(), m_proof.m_path.end(), visitor);\n+\n+    if (res.first != m_proof.m_path.end() // m_proof.m_path has \"extra\" Nodes (after end of tree)\n+        || res.second                     // m_proof.m_path has insufficient Nodes (tree not finished)\n+        || stack.size() != 1              // expected one root hash...\n+        || !stack.back().first)           // ...and an actual hash, not a placeholder\n+    {\n+        if (invalid)\n+            *invalid = true;\n+        return uint256();\n+    }\n+\n+    if (invalid) {\n+        *invalid = (verify_pos != verify_last  // did not use all verify hashes\n+                    || skip_pos != skip_last); // did not use all skip hashes\n+    }\n+\n+    return stack.back().second;\n+}"
      },
      {
        "sha": "7f70a93a73bbed226ae460378ca08f9731009d72",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 1360,
        "deletions": 0,
        "changes": 1360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/240c6af170f980303404a2e5b0bd8a9a76c98231/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/240c6af170f980303404a2e5b0bd8a9a76c98231/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=240c6af170f980303404a2e5b0bd8a9a76c98231",
        "patch": "@@ -6,10 +6,13 @@\n #define BITCOIN_CONSENSUS_MERKLE_H\n \n #include <stdint.h>\n+#include <array>\n+#include <iterator>\n #include <vector>\n \n #include <primitives/transaction.h>\n #include <primitives/block.h>\n+#include <serialize.h>\n #include <uint256.h>\n \n uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = nullptr);\n@@ -90,4 +93,1361 @@ uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n  */\n std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position);\n \n+/*\n+ * Each link of a Merkle tree can have one of three values in a proof\n+ * object:\n+ *\n+ *   DESCEND: This link connects to another sub-tree, which must be\n+ *     processed. The root of this sub-tree is the hash value of the\n+ *     link.\n+ *\n+ *   VERIFY: This hash value of this link must be provided at\n+ *     validation time. Computation of the Merkle root and comparison\n+ *     with a reference value provides a batch confirmation as to\n+ *     whether ALL the provided VERIFY hashes are correct.\n+ *\n+ *   SKIP: The hash value of this link is provided as part of the\n+ *     proof.\n+ */\n+enum class MerkleLink : unsigned char { DESCEND, VERIFY, SKIP };\n+\n+/*\n+ * An internal node can have up to eight different structures, the\n+ * product of the 3 possible MerkleLink states the left and right\n+ * branches can have, with the exception of the {SKIP, SKIP} state\n+ * which would be pruned as a SKIP hash in the parent node.\n+ *\n+ * This means nodes can be represented as a 3-bit integer, and packed\n+ * 8 nodes to each 3 byte sequence. The MerkleNode class uses an\n+ * unsigned char to represent the unpacked code, whereas the\n+ * MerkleNodeReference class is used to access a 3-bit code value\n+ * within a packed representation.\n+ */\n+struct MerkleNode\n+{\n+    typedef unsigned char code_type;\n+\n+protected:\n+    code_type m_code;\n+\n+    static const std::array<MerkleLink, 8> m_left_from_code;\n+    static const std::array<MerkleLink, 8> m_right_from_code;\n+\n+    static code_type _get_code(MerkleLink left, MerkleLink right);\n+\n+public:\n+    explicit MerkleNode(MerkleLink left, MerkleLink right) : m_code(_get_code(left, right)) { }\n+\n+    explicit MerkleNode(code_type code) : m_code(code) { }\n+\n+    /* Note that a code value of 0 is a {VERIFY, SKIP} node. */\n+    MerkleNode() : m_code(0) { }\n+\n+    /* The default behavior is adequate. */\n+    MerkleNode(const MerkleNode&) = default;\n+    MerkleNode(MerkleNode&&) = default;\n+    MerkleNode& operator=(const MerkleNode&) = default;\n+    MerkleNode& operator=(MerkleNode&&) = default;\n+\n+    /*\n+     * Ideally this would perhaps be operator int() and operator=(),\n+     * however C++ does not let us mark an assingment operator as\n+     * explicit. This unfortunately defeats many of the protections\n+     * against bugs that strong typing would give us as any integer or\n+     * Boolean value could be mistakenly assigned and interpreted as a\n+     * code, and therefore assignable to a MerkleNode, probably\n+     * generating a memory access exception if the value is not\n+     * between 0 and 7.\n+     */\n+    inline code_type GetCode() const\n+      { return m_code; }\n+\n+    inline MerkleNode& SetCode(code_type code)\n+    {\n+        m_code = code;\n+        return *this;\n+    }\n+\n+    /*\n+     * The getters and setters for the left and right MerkleLinks\n+     * simply recalculate the code value using tables. The code values\n+     * line up such that this could be done with arithmetic and\n+     * shifts, but it is probably of similar efficiency.\n+     */\n+    inline MerkleLink GetLeft() const\n+      { return m_left_from_code[m_code]; }\n+\n+    inline MerkleNode& SetLeft(MerkleLink left)\n+    {\n+        m_code = _get_code(left, m_right_from_code[m_code]);\n+        return *this;\n+    }\n+\n+    inline MerkleLink GetRight() const\n+      { return m_right_from_code[m_code]; }\n+\n+    inline MerkleNode& SetRight(MerkleLink right)\n+    {\n+        m_code = _get_code(m_left_from_code[m_code], right);\n+        return *this;\n+    }\n+\n+    /* Equality */\n+    inline bool operator==(MerkleNode other) const\n+      { return (m_code == other.m_code); }\n+    inline bool operator!=(MerkleNode other) const\n+      { return !(*this == other); }\n+\n+    /* Relational */\n+    inline bool operator<(MerkleNode other) const\n+      { return (m_code < other.m_code); }\n+    inline bool operator<=(MerkleNode other) const\n+      { return !(other < *this); }\n+    inline bool operator>=(MerkleNode other) const\n+      { return !(*this < other); }\n+    inline bool operator>(MerkleNode other) const\n+      { return (other < *this); }\n+\n+    /* Needs access to m_{left,right}_from_code and _get_code() */\n+    friend struct MerkleNodeReference;\n+};\n+\n+/*\n+ * Now we begin constructing the necessary infrastructure for\n+ * supporting an STL-like container for packed 3-bit code\n+ * representations of MerkleNode values. This is parallels the way\n+ * that std::vector<bool> is specialized, with the added complication\n+ * of a non-power-of-2 packed size.\n+ */\n+\n+/*\n+ * First we build a \"reference\" class which is able to address the\n+ * location of a packed 3-bit value, and to read and write that value\n+ * without affecting its neighbors.\n+ *\n+ * Then we will make use of this MerkleNode reference type to\n+ * construct an STL-compatible iterator class (technically two, since\n+ * the class const_iterator is not a const instance of the class\n+ * iterator, for reasons).\n+ */\n+struct MerkleNodeReference\n+{\n+    /*\n+     * Nodes are stored with a tightly packed 3-bit encoding, the\n+     * code. This allows up to 8 node specifications to fit within 3\n+     * bytes:\n+     *\n+     *    -- Node index\n+     *   /\n+     *   00011122 23334445 55666777\n+     *    byte 0   byte 1   byte 2\n+     *   76543210 76543210 76543210\n+     *                            /\n+     *                Bit Index --\n+     *\n+     * A reference to a particular node consists of a pointer to the\n+     * beginning of this 3 byte sequence, and the index (between 0 and\n+     * 7) of the node.\n+     */\n+    typedef unsigned char base_type;\n+    typedef unsigned char offset_type;\n+\n+protected:\n+    base_type* m_base;\n+    offset_type m_offset;\n+\n+    /*\n+     * The parameterized constructor is protected because MerkleNode\n+     * references should only ever be created by the friended iterator\n+     * and container code.\n+     */\n+    MerkleNodeReference(base_type* base, offset_type offset) : m_base(base), m_offset(offset) { }\n+\n+    /*\n+     * We're emulating a reference, not a pointer, and it doesn't make\n+     * sense to have a default-constructable reference.\n+     */\n+    MerkleNodeReference() = delete;\n+\n+public:\n+    /*\n+     * The default copy constructors are sufficient. Note that these\n+     * create a new reference object that points to the same packed\n+     * MerkleNode value.\n+     */\n+    MerkleNodeReference(const MerkleNodeReference& other) = default;\n+    MerkleNodeReference(MerkleNodeReference&& other) = default;\n+\n+    /*\n+     * Copy assignment operators are NOT the default behavior:\n+     * assigning one reference to another copies the underlying\n+     * values, to make the MerkleNodeReference objects behave like\n+     * references. It is NOT the same as the copy constructor, which\n+     * copies the reference itself.\n+     */\n+    inline MerkleNodeReference& operator=(const MerkleNodeReference& other)\n+      { return SetCode(other.GetCode()); }\n+    inline MerkleNodeReference& operator=(MerkleNodeReference&& other)\n+      { return SetCode(other.GetCode()); }\n+\n+public:\n+    /* Read a 3-bit code value */\n+    MerkleNode::code_type GetCode() const;\n+\n+    /* Write a 3-bit code value */\n+    MerkleNodeReference& SetCode(MerkleNode::code_type code);\n+\n+    /* Read and write the MerkleLink values individually. */\n+    inline MerkleLink GetLeft() const\n+      { return MerkleNode::m_left_from_code[GetCode()]; }\n+    inline MerkleNodeReference& SetLeft(MerkleLink left)\n+      { return SetCode(MerkleNode::_get_code(left, GetRight())); }\n+\n+    MerkleLink GetRight() const\n+      { return MerkleNode::m_right_from_code[GetCode()]; }\n+    MerkleNodeReference& SetRight(MerkleLink right)\n+      { return SetCode(MerkleNode::_get_code(GetLeft(), right)); }\n+\n+    /* Equality */\n+    inline bool operator==(const MerkleNodeReference& other) const\n+      { return (GetCode() == other.GetCode()); }\n+    inline bool operator==(MerkleNode other) const\n+      { return (GetCode() == other.GetCode()); }\n+    inline bool operator!=(const MerkleNodeReference& other) const\n+      { return (GetCode() != other.GetCode()); }\n+    inline bool operator!=(MerkleNode other) const\n+      { return (GetCode() != other.GetCode()); }\n+\n+    /* Relational */\n+    inline bool operator<(const MerkleNodeReference& other) const\n+      { return (GetCode() < other.GetCode()); }\n+    inline bool operator<(MerkleNode other) const\n+      { return (GetCode() < other.GetCode()); }\n+    inline bool operator<=(const MerkleNodeReference& other) const\n+      { return (GetCode() <= other.GetCode()); }\n+    inline bool operator<=(MerkleNode other) const\n+      { return (GetCode() <= other.GetCode()); }\n+    inline bool operator>=(const MerkleNodeReference& other) const\n+      { return (GetCode() >= other.GetCode()); }\n+    inline bool operator>=(MerkleNode other) const\n+      { return (GetCode() >= other.GetCode()); }\n+    inline bool operator>(const MerkleNodeReference& other) const\n+      { return (GetCode() > other.GetCode()); }\n+    inline bool operator>(MerkleNode other) const\n+      { return (GetCode() > other.GetCode()); }\n+\n+    /* Conversion to/from class MerkleNode */\n+    inline MerkleNodeReference& operator=(const MerkleNode& other)\n+      { return SetCode(other.GetCode()); }\n+    inline operator MerkleNode() const\n+      { return MerkleNode(GetCode()); }\n+\n+protected:\n+    /* Needs C(base,offset) and access to m_base and m_offset */\n+    friend struct MerkleNodeIteratorBase;\n+\n+    /* Needs C(base,offset) */\n+    template<class T, class Alloc> friend class std::vector;\n+};\n+\n+inline bool operator==(MerkleNode lhs, const MerkleNodeReference& rhs)\n+  { return (lhs.GetCode() == rhs.GetCode()); }\n+inline bool operator!=(MerkleNode lhs, const MerkleNodeReference& rhs)\n+  { return (lhs.GetCode() != rhs.GetCode()); }\n+inline bool operator<(MerkleNode lhs, const MerkleNodeReference& rhs)\n+  { return (lhs.GetCode() < rhs.GetCode()); }\n+inline bool operator<=(MerkleNode lhs, const MerkleNodeReference& rhs)\n+  { return (lhs.GetCode() <= rhs.GetCode()); }\n+inline bool operator>=(MerkleNode lhs, const MerkleNodeReference& rhs)\n+  { return (lhs.GetCode() >= rhs.GetCode()); }\n+inline bool operator>(MerkleNode lhs, const MerkleNodeReference& rhs)\n+  { return (lhs.GetCode() > rhs.GetCode()); }\n+\n+/*\n+ * Now we construct an STL-compatible iterator object. If you are not\n+ * familiar with writing STL iterators, this might be difficult to\n+ * review. I will not explain how this works in detail, but I\n+ * encourage reviewers to compare this with how std::vector<bool>'s\n+ * iterators are implemented, as well as available documentation for\n+ * std::iterator, as necessary.\n+ *\n+ * We derive from std::iterator basically just to provide the ability\n+ * to specialized algorithms based on iterator category tags. All\n+ * iterator functionality is implemented by this class due to the\n+ * peculiarities of iterating over packed representations.\n+ *\n+ * Note, if you're not aware, that for STL containers const_iterator\n+ * is not the iterator class with a const qualifier applied. The class\n+ * MerkleNodeIteratorBase implements the common functionality and the\n+ * two iterators derive from it.\n+ */\n+struct MerkleNodeIteratorBase : public std::iterator<std::random_access_iterator_tag, MerkleNodeReference::base_type>\n+{\n+    /*\n+     * The value extracted from an iterator is a MerkleNode, or more\n+     * properly a MerkleNodeReference (iterator) or const MerkleNode\n+     * (const_iterator). The packed array of 3-bit code values only\n+     * has its values extracted and then converted to MerkleNode as\n+     * necessary on the fly.\n+     */\n+    typedef MerkleNode value_type;\n+    typedef std::ptrdiff_t difference_type;\n+\n+protected:\n+    MerkleNodeReference m_ref;\n+\n+    /*\n+     * A pass through initializer used by the derived iterator types,\n+     * since otherwise m_ref would not be accessible to their\n+     * constructor member initialization lists.\n+     */\n+    MerkleNodeIteratorBase(MerkleNodeReference::base_type* base, MerkleNodeReference::offset_type offset) : m_ref(base, offset) { }\n+\n+    /*\n+     * Constructing an iterator from another iterator clones the\n+     * underlying reference.\n+     */\n+    MerkleNodeIteratorBase(const MerkleNodeIteratorBase&) = default;\n+    MerkleNodeIteratorBase(MerkleNodeIteratorBase&&) = default;\n+\n+    /*\n+     * Copy assignment also clones the underlying reference, but a\n+     * non-default copy assignment is required because the underlying\n+     * MerkleNodeReference structure uses its own copy assignment\n+     * operator to emulate reference behavior, but in this context we\n+     * want what would otherwise be the default behavior of copying\n+     * the reference itself.\n+     */\n+    inline MerkleNodeIteratorBase& operator=(const MerkleNodeIteratorBase& other)\n+    {\n+       m_ref.m_base = other.m_ref.m_base;\n+        m_ref.m_offset = other.m_ref.m_offset;\n+        return *this;\n+    }\n+\n+    inline MerkleNodeIteratorBase& operator=(MerkleNodeIteratorBase&& other)\n+    {\n+        m_ref.m_base = other.m_ref.m_base;\n+        m_ref.m_offset = other.m_ref.m_offset;\n+        return *this;\n+    }\n+\n+public:\n+    /* Distance */\n+    difference_type operator-(const MerkleNodeIteratorBase& other) const;\n+\n+    /*\n+     * The standard increment, decrement, advancement, etc. operators\n+     * for both iterator and const_iterator do the same thing and\n+     * could be defined here, but then they would be returning\n+     * instances of the base class not the iterator. So look to those\n+     * definitions in the derived classes below.\n+     */\n+\n+    /*\n+     * Equality\n+     *\n+     * Note: Comparing the underlying reference directly with\n+     *       MerkleNodeReference::operator== and friends would result\n+     *       in the underlying values being compared, not the memory\n+     *       addresses.\n+     */\n+    inline bool operator==(const MerkleNodeIteratorBase& other) const\n+    {\n+        return m_ref.m_base == other.m_ref.m_base\n+            && m_ref.m_offset == other.m_ref.m_offset;\n+    }\n+\n+    inline bool operator!=(const MerkleNodeIteratorBase& other) const\n+      { return !(*this == other); }\n+\n+    /* Relational */\n+    inline bool operator<(const MerkleNodeIteratorBase& other) const\n+    {\n+        return m_ref.m_base < other.m_ref.m_base\n+           || (m_ref.m_base == other.m_ref.m_base && m_ref.m_offset < other.m_ref.m_offset);\n+    }\n+\n+    inline bool operator<=(const MerkleNodeIteratorBase& other) const\n+      { return !(other < *this); }\n+    inline bool operator>=(const MerkleNodeIteratorBase& other) const\n+      { return !(*this < other); }\n+    inline bool operator>(const MerkleNodeIteratorBase& other) const\n+      { return other < *this; }\n+\n+protected:\n+    /*\n+     * Move to the next 3-bit code value, incrementing m_base (by 3!)\n+     * only if we've gone past the end of a 3-byte block of 8 code\n+     * values.\n+     */\n+    void _incr();\n+\n+    /*\n+     * Move to the prior 3-bit code value, moving m_back back (by 3)\n+     * if we've gone past the beginning of the 3-byte block of 8 code\n+     * values it points to.\n+     */\n+    void _decr();\n+\n+    /*\n+     * Move an arbitrary number of elements forward or backwards. for\n+     * random access (see related operator-() definition below).\n+     */\n+    void _seek(difference_type distance);\n+};\n+\n+/*\n+ * Forward random access iterator, using the _incr(), _decr(), _seek()\n+ * and operator-() methods of MerkleNodeIteratorBase, which is the\n+ * important business logic. This class is mostly just API wrappers to\n+ * provide an API interface close enough to API compatible with STL\n+ * iterators to be usable with other standard library generics.\n+ */\n+struct MerkleNodeIterator : public MerkleNodeIteratorBase\n+{\n+    typedef MerkleNodeIterator iterator;\n+    typedef MerkleNodeReference reference;\n+    typedef MerkleNodeReference* pointer;\n+\n+    /*\n+     * Default constructor makes an unusable iterator, but required so\n+     * that an iterator variable can declared and initialized\n+     * separately.\n+     */\n+    MerkleNodeIterator() : MerkleNodeIteratorBase(nullptr, 0) { }\n+\n+    /* Default copy/move constructors and assignment operators are fine. */\n+    MerkleNodeIterator(const MerkleNodeIterator& other) = default;\n+    MerkleNodeIterator(MerkleNodeIterator&& other) = default;\n+    MerkleNodeIterator& operator=(const MerkleNodeIterator& other) = default;\n+    MerkleNodeIterator& operator=(MerkleNodeIterator&& other) = default;\n+\n+protected:\n+    MerkleNodeIterator(MerkleNodeReference::base_type* base, MerkleNodeReference::offset_type offset) : MerkleNodeIteratorBase(base, offset) { }\n+\n+public:\n+    /* Dereference */\n+    inline reference operator*() const\n+      { return m_ref; }\n+    inline pointer operator->() const\n+      { return const_cast<pointer>(&m_ref); }\n+\n+    /* Advancement */\n+    inline iterator& operator++()\n+    {\n+        _incr();\n+        return *this;\n+    }\n+\n+    inline iterator operator++(int)\n+    {\n+        iterator ret(*this);\n+        _incr();\n+        return ret;\n+    }\n+\n+    inline iterator& operator--()\n+    {\n+        _decr();\n+        return *this;\n+    }\n+\n+    inline iterator operator--(int)\n+    {\n+        iterator ret(*this);\n+        _decr();\n+        return ret;\n+    }\n+\n+    /* Random access */\n+    inline difference_type operator-(const MerkleNodeIterator& other) const\n+    {\n+        /*\n+         * The base class implements this correctly, but since we\n+         * define another overload of operator-() below, we need to\n+         * explicitly implement this variant too.\n+         */\n+        return MerkleNodeIteratorBase::operator-(other);\n+    }\n+\n+    inline iterator& operator+=(difference_type n)\n+    {\n+        _seek(n);\n+        return *this;\n+    }\n+\n+    inline iterator& operator-=(difference_type n)\n+    {\n+        _seek(-n);\n+        return *this;\n+    }\n+\n+    inline iterator operator+(difference_type n) const\n+    {\n+        iterator ret(*this);\n+        ret._seek(n);\n+        return ret;\n+    }\n+\n+    inline iterator operator-(difference_type n) const\n+    {\n+        iterator ret(*this);\n+        ret._seek(-n);\n+        return ret;\n+    }\n+\n+    inline reference operator[](difference_type n) const\n+      { return *(*this + n); }\n+\n+    /* std::vector<Node> specialization uses C(base,offset) */\n+    template<class T, class Alloc> friend class std::vector;\n+};\n+\n+inline MerkleNodeIterator operator+(MerkleNodeIterator::difference_type n, const MerkleNodeIterator& x)\n+  { return (x + n); }\n+\n+struct MerkleNodeConstIterator : public MerkleNodeIteratorBase\n+{\n+    typedef MerkleNodeConstIterator iterator;\n+    typedef const MerkleNodeReference reference;\n+    typedef const MerkleNodeReference* pointer;\n+\n+    /* Creates an unusable iterator with a sentinal value. */\n+    MerkleNodeConstIterator() : MerkleNodeIteratorBase(nullptr, 0) { }\n+\n+    /* Pass-through constructor of the m_ref field. */\n+    MerkleNodeConstIterator(const MerkleNodeIterator& other) : MerkleNodeIteratorBase(static_cast<const MerkleNodeIteratorBase&>(other)) { }\n+\n+    /* Default copy/move constructors and assignment operators are fine. */\n+    MerkleNodeConstIterator(const MerkleNodeConstIterator& other) = default;\n+    MerkleNodeConstIterator(MerkleNodeConstIterator&& other) = default;\n+    MerkleNodeConstIterator& operator=(const MerkleNodeConstIterator& other) = default;\n+    MerkleNodeConstIterator& operator=(MerkleNodeConstIterator&& other) = default;\n+\n+protected:\n+    /*\n+     * const_cast is required (and allowed) because the const\n+     * qualifier is only dropped to copy its value into m_ref. No API\n+     * is provided to actually manipulate the underlying value of the\n+     * reference by this class.\n+     */\n+    MerkleNodeConstIterator(const MerkleNodeReference::base_type* base, MerkleNodeReference::offset_type offset) : MerkleNodeIteratorBase(const_cast<MerkleNodeReference::base_type*>(base), offset) { }\n+\n+public:\n+  /* Dereference */\n+    inline reference operator*() const\n+      { return m_ref; }\n+    inline pointer operator->() const\n+      { return &m_ref; }\n+\n+    /* Advancement */\n+    inline iterator& operator++()\n+    {\n+        _incr();\n+        return *this;\n+    }\n+\n+    inline iterator operator++(int)\n+    {\n+        iterator tmp = *this;\n+        _incr();\n+        return tmp;\n+    }\n+\n+    inline iterator& operator--()\n+    {\n+        _decr();\n+        return *this;\n+    }\n+\n+    inline iterator operator--(int)\n+    {\n+        iterator tmp = *this;\n+        _decr();\n+        return tmp;\n+    }\n+\n+    /* Random access */\n+    inline difference_type operator-(const MerkleNodeConstIterator& other) const\n+    {\n+      /*\n+       * The base class implements this correctly, but since we define\n+       * another version of operator-() below, we need to explicitly\n+       * implement this variant too.\n+       */\n+      return MerkleNodeIteratorBase::operator-(other);\n+    }\n+\n+    inline iterator& operator+=(difference_type n)\n+    {\n+        _seek(n);\n+        return *this;\n+    }\n+\n+    inline iterator& operator-=(difference_type n)\n+    {\n+        *this += -n;\n+        return *this;\n+    }\n+\n+    inline iterator operator+(difference_type n) const\n+    {\n+        iterator tmp = *this;\n+        return tmp += n;\n+    }\n+\n+    inline iterator operator-(difference_type n) const\n+    {\n+        iterator tmp = *this;\n+        return tmp -= n;\n+    }\n+\n+    inline reference operator[](difference_type n) const\n+      { return *(*this + n); }\n+\n+    /* std::vector<MerkleNode> uses C(base,offset) */\n+    template<class T, class Alloc> friend class std::vector;\n+};\n+\n+inline MerkleNodeConstIterator operator+(MerkleNodeConstIterator::difference_type n, const MerkleNodeConstIterator& x)\n+  { return x + n; }\n+\n+/*\n+ * Now we are ready to define the specialization of std::vector for\n+ * packed 3-bit MerkleNode values. We use a std::vector<unsigned char>\n+ * as the underlying container to hold the encoded bytes, with 3\n+ * packed MerkleNodes per byte. We then provide a std::vector\n+ * compatible API to return iterators over MerkleNodeReference objects\n+ * inside this packed array.\n+ */\n+namespace std {\n+template<class Allocator>\n+class vector<MerkleNode, Allocator>\n+{\n+public:\n+    typedef MerkleNode value_type;\n+    typedef MerkleNodeReference::base_type base_type;\n+    typedef typename Allocator::template rebind<value_type>::other allocator_type;\n+    typedef std::size_t size_type;\n+    typedef std::ptrdiff_t difference_type;\n+    typedef MerkleNodeReference reference;\n+    typedef const MerkleNodeReference const_reference;\n+    typedef MerkleNodeReference* pointer;\n+    typedef const MerkleNodeReference* const_pointer;\n+    typedef MerkleNodeIterator iterator;\n+    typedef MerkleNodeConstIterator const_iterator;\n+    typedef std::reverse_iterator<iterator> reverse_iterator;\n+    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+protected:\n+    /*\n+     * A std::vector<unsignd char> is what is actually used to store\n+     * the packed Node representation.\n+     */\n+    typedef typename Allocator::template rebind<base_type>::other base_allocator_type;\n+    typedef std::vector<base_type, base_allocator_type> vch_type;\n+\n+    /*\n+     * m_vch.size() is (3 * m_count) / 8, but because of the truncation\n+     * we can't know from m_vch.size() alone how many nodes are in the\n+     * tree structure, so the count needs to be stored explicitly.\n+     */\n+    vch_type m_vch;\n+    size_type m_count;\n+\n+    /* Returns the required size of m_vch to contain count packed Nodes. */\n+    static inline const typename vch_type::size_type _vch_size(size_type count)\n+      { return (3 * count + 7) / 8; }\n+\n+public:\n+    explicit vector(const Allocator& alloc = Allocator()) : m_vch(static_cast<base_allocator_type>(alloc)), m_count(0) { }\n+\n+    /*\n+     * Yes, this doesn't allow specifying the allocator. That is a bug\n+     * in C++11, fixed in C++14. However we aim for exact\n+     * compatibility with the version of C++ used by Bitcoin Core,\n+     * which is still pegged to C++11.\n+     *\n+     * Note: Because m_vch is a vector of a primitive type, its values\n+     *       are value initialized to zero according to the C++11\n+     *       standard. We don't need to do anything. Note, however,\n+     *       that in prior versions of the standard the behavior was\n+     *       different and this implementation will not work with\n+     *       pre-C++11 compilers.\n+     */\n+    explicit vector(size_type count) : m_vch(_vch_size(count)), m_count(count) { }\n+\n+    vector(size_type count, value_type value, const Allocator& alloc = Allocator()) : m_vch(_vch_size(count), 0, static_cast<base_allocator_type>(alloc)), m_count(count)\n+    {\n+        MerkleNode::code_type code = value.GetCode();\n+        if (code) // Already filled with zeros\n+            _fill(0, count, code);\n+    }\n+\n+    /* Assign constructors */\n+    template<class InputIt>\n+    vector(InputIt first, InputIt last, const Allocator& alloc = Allocator()) : m_vch(static_cast<base_allocator_type>(alloc)), m_count(0)\n+      { insert(begin(), first, last); }\n+\n+    vector(std::initializer_list<value_type> ilist, const Allocator& alloc = Allocator()) : m_vch(static_cast<base_allocator_type>(alloc)), m_count(0)\n+      { assign(ilist); }\n+\n+    /* Copy constructors */\n+    vector(const vector& other) = default;\n+    vector(const vector& other, const Allocator& alloc) : m_vch(other.m_vch, static_cast<base_allocator_type>(alloc)), m_count(other.m_count) { }\n+    vector(vector&& other) = default;\n+    vector(vector&& other, const Allocator& alloc) : m_vch(other.m_vch, static_cast<base_allocator_type>(alloc)), m_count(other.m_count) { }\n+\n+    /* Assignment operators */\n+    vector& operator=(const vector& other) = default;\n+    vector& operator=(vector&& other) = default;\n+\n+    inline vector& operator=(std::initializer_list<value_type> ilist)\n+    {\n+        assign(ilist);\n+        return *this;\n+    }\n+\n+    /* Equality comparators */\n+    inline bool operator==(const vector &other) const\n+      { return ((m_count == other.m_count) && (m_vch == other.m_vch)); }\n+    inline bool operator!=(const vector &other) const\n+      { return !(*this == other); }\n+\n+    /* Relational compariators */\n+    inline bool operator<(const vector &other) const\n+      { return ((m_vch < other.m_vch) || ((m_vch == other.m_vch) && (m_count < other.m_count))); }\n+    inline bool operator<=(const vector &other) const\n+      { return !(other < *this); }\n+    inline bool operator>=(const vector &other) const\n+      { return !(*this < other); }\n+    inline bool operator>(const vector &other) const\n+      { return (other < *this); }\n+\n+    /* Clear & assign methods */\n+    void assign(size_type count, value_type value)\n+    {\n+        clear();\n+        insert(begin(), count, value);\n+    }\n+\n+    template<class InputIt>\n+    void assign(InputIt first, InputIt last)\n+    {\n+        clear();\n+        insert(begin(), first, last);\n+    }\n+\n+    void assign(std::initializer_list<value_type> ilist)\n+    {\n+        clear();\n+        reserve(ilist.size());\n+        for (auto node : ilist)\n+            push_back(node);\n+    }\n+\n+    allocator_type get_allocator() const\n+      { return allocator_type(m_vch.get_allocator()); }\n+\n+    /* Item access */\n+    reference at(size_type pos)\n+    {\n+        if (!(pos < size()))\n+            throw std::out_of_range(\"vector<Node>::at out of range\");\n+        return (*this)[pos];\n+    }\n+\n+    const_reference at(size_type pos) const\n+    {\n+        if (!(pos < size()))\n+            throw std::out_of_range(\"vector<Node>::at out of range\");\n+        return (*this)[pos];\n+    }\n+\n+    inline reference operator[](size_type pos)\n+      { return reference(data() + (3 * (pos / 8)), pos % 8); }\n+    inline const_reference operator[](size_type pos) const\n+      { return const_reference(const_cast<const_reference::base_type*>(data() + (3 * (pos / 8))), pos % 8); }\n+\n+    inline reference front()\n+      { return (*this)[0]; }\n+    inline const_reference front() const\n+      { return (*this)[0]; }\n+\n+    inline reference back()\n+      { return (*this)[m_count-1]; }\n+    inline const_reference back() const\n+      { return (*this)[m_count-1]; }\n+\n+    inline base_type* data()\n+      { return m_vch.data(); }\n+    inline const base_type* data() const\n+      { return m_vch.data(); }\n+\n+    /* Iterators */\n+    inline iterator begin() noexcept\n+      { return iterator(data(), 0); }\n+    inline const_iterator begin() const noexcept\n+      { return const_iterator(data(), 0); }\n+    inline const_iterator cbegin() const noexcept\n+      { return begin(); }\n+\n+    inline iterator end() noexcept\n+      { return iterator(data() + (3 * (m_count / 8)), m_count % 8); }\n+    inline const_iterator end() const noexcept\n+      { return const_iterator(data() + (3 * (m_count / 8)), m_count % 8); }\n+    inline const_iterator cend() const noexcept\n+      { return end(); }\n+\n+    inline reverse_iterator rbegin() noexcept\n+      { return reverse_iterator(end()); }\n+    inline const_reverse_iterator rbegin() const noexcept\n+      { return const_reverse_iterator(end()); }\n+    inline const_reverse_iterator crbegin() const noexcept\n+      { return rbegin(); }\n+\n+    inline reverse_iterator rend() noexcept\n+      { return reverse_iterator(begin()); }\n+    inline const_reverse_iterator rend() const noexcept\n+      { return const_reverse_iterator(begin()); }\n+    inline const_reverse_iterator crend() const noexcept\n+      { return rend(); }\n+\n+    /* Size and capacity */\n+    inline bool empty() const noexcept\n+      { return !m_count; }\n+\n+    inline size_type size() const noexcept\n+      { return m_count; }\n+\n+    inline size_type max_size() const noexcept\n+    {\n+        /* We must be careful in what we return due to overflow. */\n+        return std::max(m_vch.max_size(), 8 * m_vch.max_size() / 3);\n+    }\n+\n+    inline void reserve(size_type new_cap)\n+      { m_vch.reserve(_vch_size(new_cap)); }\n+\n+    inline size_type capacity() const noexcept\n+    {\n+        /* Again, careful of overflow, although it is more of a\n+         * theoretical concern here since such limitations would only\n+         * be encountered if the vector consumed more than 1/8th of\n+         * the addressable memory range. */\n+        return std::max(m_count, 8 * m_vch.capacity() / 3);\n+    }\n+\n+    inline void resize(size_type count)\n+      { resize(count, value_type()); }\n+\n+    void resize(size_type count, value_type value)\n+    {\n+        auto old_count = m_count;\n+        _resize(count);\n+        if (old_count < count)\n+            _fill(old_count, count, value.GetCode());\n+    }\n+\n+    inline void shrink_to_fit()\n+      { m_vch.shrink_to_fit(); }\n+\n+protected:\n+    /*\n+     * Resizes the underlying vector to support the number of packed\n+     * Nodes specified. Does NOT initialize any newly allocated bytes,\n+     * except for the unused bits in the last byte when shrinking or\n+     * the last new byte added, to prevent acquisition of dirty\n+     * status. It is the responsibility of the caller to initialize\n+     * any added new MerkleNodes.\n+     */\n+    void _resize(size_type count)\n+    {\n+        if (count < m_count) {\n+            /* Clear bits of elements being removed in the new last\n+             * byte, for the purpose of not introducing dirty\n+             * status. */\n+            _fill(count, std::min((count + 7) & ~7, m_count), 0);\n+        }\n+        size_type new_vch_size = _vch_size(count);\n+        m_vch.resize(new_vch_size);\n+        if (m_count < count) {\n+            /* Clear the last byte, if a byte is being added, so that\n+             * none of the extra bits introduce dirty status. */\n+            if (new_vch_size > _vch_size(m_count)) {\n+                m_vch.back() = 0;\n+            }\n+        }\n+        m_count = count;\n+    }\n+\n+    /*\n+     * A memmove()-like behavior over the packed elements of this\n+     * container. The source and the destination are allowed to\n+     * overlap. Any non-overlap in the source is left with its prior\n+     * value intact.\n+     */\n+    void _move(size_type first, size_type last, size_type dest)\n+    {\n+        /* TODO: This could be made much faster by copying chunks at a\n+         *       time. This far less efficient approach is taken\n+         *       because it is more obviously correct and _move is not\n+         *       in the pipeline critical to validation performance. */\n+        if (dest < first) {\n+            std::copy(begin()+first, begin()+last, begin()+dest);\n+        }\n+        if (first < dest) {\n+            dest += last - first;\n+            std::copy_backward(begin()+first, begin()+last, begin()+dest);\n+        }\n+    }\n+\n+    /*\n+     * A std::fill()-like behavior over a range of the packed elements\n+     * of this container.\n+     */\n+    void _fill(size_type first, size_type last, MerkleNode::code_type value)\n+    {\n+        /* TODO: This could be made much faster for long ranges by\n+         *       precomputing the 3-byte repeating sequence and using\n+         *       that for long runs. However this method mostly exists\n+         *       for API compatability with std::vector, and is not\n+         *       used by Merkle tree manipulation code, which at best\n+         *       very infrequently needs to fill a range of serialized\n+         *       MerkleNode code values. */\n+        std::fill(begin()+first, begin()+last, MerkleNode(value));\n+    }\n+\n+public:\n+    void clear() noexcept\n+    {\n+        m_vch.clear();\n+        m_count = 0;\n+    }\n+\n+    iterator insert(const_iterator pos, value_type value)\n+    {\n+        difference_type n = pos - cbegin();\n+        _resize(m_count + 1);\n+        _move(n, m_count-1, n+1);\n+        operator[](n) = value;\n+        return (begin() + n);\n+    }\n+\n+    iterator insert(const_iterator pos, size_type count, value_type value)\n+    {\n+        difference_type n = pos - cbegin();\n+        _resize(m_count + count);\n+        _move(n, m_count-count, n+count);\n+        _fill(n, n+count, value.GetCode());\n+        return (begin() + n);\n+    }\n+\n+    /*\n+     * TODO: This implementation should be correct. It's a rather\n+     *       trivial method to implement. However (1) the lack of easy\n+     *       non-interactive input iterators in the standard library\n+     *       makes this difficult to write tests for; and (2) it's not\n+     *       currently used anyway. Still, for exact compatibility\n+     *       with the standard container interface this should get\n+     *       tested and implemented.\n+     */\n+    template<class InputIt>\n+    iterator insert(const_iterator pos, InputIt first, InputIt last, std::input_iterator_tag)\n+    {\n+        difference_type n = pos - cbegin();\n+        for (; first != last; ++first, ++pos)\n+            pos = insert(pos, *first);\n+        return (begin() + n);\n+    }\n+\n+    template<class InputIt>\n+    iterator insert(const_iterator pos, InputIt first, InputIt last, std::forward_iterator_tag)\n+    {\n+      auto n = std::distance(cbegin(), pos);\n+      auto len = std::distance(first, last);\n+      _resize(m_count + len);\n+      _move(n, m_count-len, n+len);\n+      auto pos2 = begin() + n;\n+      for (; first != last; ++first, ++pos2)\n+          *pos2 = *first;\n+      return (begin() + n);\n+    }\n+\n+    template<class InputIt>\n+    inline iterator insert(const_iterator pos, InputIt first, InputIt last)\n+    {\n+        /* Use iterator tag dispatching to be able to pre-allocate the\n+         * space when InputIt is a random access iterator, to prevent\n+         * multiple resizings on a large insert. */\n+        return insert(pos, first, last, typename iterator_traits<InputIt>::iterator_category());\n+    }\n+\n+    inline iterator insert(const_iterator pos, std::initializer_list<value_type> ilist)\n+      { return insert(pos, ilist.begin(), ilist.end()); }\n+\n+    template<class... Args>\n+    iterator emplace(const_iterator pos, Args&&... args)\n+    {\n+        difference_type n = pos - cbegin();\n+        _resize(m_count + 1);\n+        _move(n, m_count-1, n+1);\n+        auto ret = begin() + n;\n+        *ret = MerkleNode(args...);\n+        return ret;\n+    }\n+\n+    iterator erase(const_iterator pos)\n+    {\n+        difference_type n = pos - cbegin();\n+        _move(n+1, m_count, n);\n+        _resize(m_count - 1);\n+        return (begin() + n);\n+    }\n+\n+    iterator erase(const_iterator first, const_iterator last)\n+    {\n+        auto n = std::distance(cbegin(), first);\n+        auto len = std::distance(first, last);\n+        _move(n+len, m_count, n);\n+        _resize(m_count - len);\n+        return (begin() + n);\n+    }\n+\n+    void push_back(value_type value)\n+    {\n+        if (m_vch.size() < _vch_size(m_count+1))\n+            m_vch.push_back(0);\n+        (*this)[m_count++] = value;\n+    }\n+\n+    template<class... Args>\n+    void emplace_back(Args&&... args)\n+    {\n+        if (m_vch.size() < _vch_size(m_count+1))\n+            m_vch.push_back(0);\n+        (*this)[m_count++] = MerkleNode(args...);\n+    }\n+\n+    void pop_back()\n+    {\n+        (*this)[m_count-1].SetCode(0);\n+        if (_vch_size(m_count-1) < m_vch.size())\n+            m_vch.pop_back();\n+        --m_count;\n+    }\n+\n+    void swap(vector& other)\n+    {\n+        m_vch.swap(other.m_vch);\n+        std::swap(m_count, other.m_count);\n+    }\n+\n+public:\n+    base_type dirty() const\n+    {\n+        switch (m_count%8) {\n+            case 0:  return 0;\n+            case 1:  return m_vch.back() & 0x1f;\n+            case 2:  return m_vch.back() & 0x03;\n+            case 3:  return m_vch.back() & 0x7f;\n+            case 4:  return m_vch.back() & 0x0f;\n+            case 5:  return m_vch.back() & 0x01;\n+            case 6:  return m_vch.back() & 0x3f;\n+            default: return m_vch.back() & 0x07;\n+        }\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        /* The size of the node array is prefixed by the number of\n+         * nodes, not the number of bytes which much then be\n+         * read. _resize() handles conversion between the two. */\n+        uint64_t count = m_count;\n+        READWRITE(VARINT(count));\n+        if (ser_action.ForRead())\n+            _resize(static_cast<size_type>(count));\n+        /* The size of the underlying storage vector is always kept\n+         * exactly equal to the minimum number of bytes necessary to\n+         * store the number 3-bit packed code values, so we can just\n+         * read and write it as a plain old data. */\n+        if (!m_vch.empty()) {\n+            READWRITE(REF(CFlatData(m_vch)));\n+        }\n+    }\n+};\n+\n+template<class A> inline bool operator==(const vector<MerkleNode, A> &lhs, const vector<MerkleNode, A> &rhs)\n+  { return lhs.operator==(rhs); }\n+template<class A> inline bool operator!=(const vector<MerkleNode, A> &lhs, const vector<MerkleNode, A> &rhs)\n+  { return lhs.operator!=(rhs); }\n+\n+template<class A> inline bool operator<(const vector<MerkleNode, A> &lhs, const vector<MerkleNode, A> &rhs)\n+  { return lhs.operator<(rhs); }\n+template<class A> inline bool operator<=(const vector<MerkleNode, A> &lhs, const vector<MerkleNode, A> &rhs)\n+  { return lhs.operator<=(rhs); }\n+template<class A> inline bool operator>=(const vector<MerkleNode, A> &lhs, const vector<MerkleNode, A> &rhs)\n+  { return lhs.operator>=(rhs); }\n+template<class A> inline bool operator>(const vector<MerkleNode, A> &lhs, const vector<MerkleNode, A> &rhs)\n+  { return lhs.operator>(rhs); }\n+} // namespace std\n+\n+template<typename Stream, typename T, typename A>\n+void Serialize_impl(Stream& os, const std::vector<T, A>& v, const MerkleNode&)\n+{\n+    v.Serialize(os);\n+}\n+\n+template<typename Stream, typename T, typename A>\n+void Unserialize_impl(Stream& is, std::vector<T, A>& v, const MerkleNode&)\n+{\n+    v.Unserialize(is);\n+}\n+\n+/*\n+ * TraversalPredicate (used below) is a template parameter\n+ *   representing a callable object or function pointer which supports\n+ *   the following API:\n+ *\n+ * bool operator()(std::vector<Node>::size_t depth, MerkleLink value, bool right)\n+ *\n+ * It is called by the traversal routines both to process the contents\n+ * of the tree (for example, calculate the Merkle root), or report\n+ * reaching the end of traversal.\n+ *\n+ * size_t depth\n+ *\n+ *   The depth of the MerkleLink being processed. MerkleLinks of the\n+ *   root node have a depth of 1. Depth 0 would be the depth of a\n+ *   single-hash tree, which has no internal nodes.\n+ *\n+ * MerkleLink value\n+ *\n+ *   The value of the link, one of MerkleLink::DESCEND,\n+ *   MerkleLink::VERIFY, or MerkleLink::SKIP.\n+ *\n+ * bool right\n+ *\n+ *   false if this is a left-link, true if this is a right-link.\n+ *\n+ * returns bool\n+ *\n+ *   false if traversal should continue. true causes traversal to\n+ *   terminate and an iterator to the node containing the link in\n+ *   question to be returned to the caller.\n+ */\n+\n+/*\n+ * Does a depth-first traversal of a tree. Starting with the root node\n+ * first, the left link is passed to pred then advanced, and if it is\n+ * MerkleLink::DESCEND then its sub-tree is recursively processed,\n+ * then the right link followed by its sub-tree. Traversal ends the\n+ * first time any of following conditions hold true:\n+ *\n+ *   1. first == last;\n+ *   2. the entire sub-tree with first as the root node has been\n+ *      processed; or\n+ *   3. pred() returns true.\n+ *\n+ * Iter first\n+ *\n+ *   The root of the subtree to be processed.\n+ *\n+ * Iter last\n+ *\n+ *   One past the last node to possibly be processed. Traversal will\n+ *   end earlier if it reaches the end of the subtree, or if\n+ *   TraversalPredicate returns true.\n+ *\n+ * TraversalPredicate pred\n+ *\n+ *   A callable object or function pointer that executed for each link\n+ *   in the tree. It is passed the current depth, the MerkleLink\n+ *   value, and a Boolean value indicating whether it is the left or\n+ *   the right link.\n+ *\n+ * returns std::pair<Iter, bool>\n+ *\n+ *   Returns the iterator pointing to the node where traversal\n+ *   terminated, and a Boolean value indicating whether it was the\n+ *   left (false) or right (true) branch that triggered termination,\n+ *   or {last, incomplete} if termination is due to hitting the end of\n+ *   the range, where incomplete is a Boolean value indicating whether\n+ *   termination was due to finishing the subtree (false) or merely\n+ *   hitting the end of the range (true).\n+ */\n+template<class Iter, class TraversalPredicate>\n+std::pair<Iter, bool> depth_first_traverse(Iter first, Iter last, TraversalPredicate pred)\n+{\n+    /* Depth-first traversal uses space linear with respect to the\n+     * depth of the tree, which is logarithmetic in the case of a\n+     * balanced tree. What is stored is a path from the root to the\n+     * node under consideration, and a record of whether it was the\n+     * left (false) or right (true) branch that was taken. */\n+    std::vector<std::pair<Iter, bool> > stack;\n+\n+    for (auto pos = first; pos != last; ++pos) {\n+        /* Each branch is processed the same. First we check if the\n+         * branch meets the user-provided termination criteria. Then\n+         * if it is a MerkleLink::DESCEND we save our position on the\n+         * stack and \"recurse\" down the link into the next layer. */\n+        if (pred(stack.size()+1, pos->GetLeft(), false)) {\n+            return {pos, false};\n+        }\n+        if (pos->GetLeft() == MerkleLink::DESCEND) {\n+            stack.emplace_back(pos, false);\n+            continue;\n+        }\n+\n+        /* If the left link was MerkleLink::VERIFY or\n+         * MerkleLink::SKIP, we continue on to the right branch in the\n+         * same way. */\n+        if (pred(stack.size()+1, pos->GetRight(), true)) {\n+            return {pos, true};\n+        }\n+        if (pos->GetRight() == MerkleLink::DESCEND) {\n+            stack.emplace_back(pos, true);\n+            continue;\n+        }\n+\n+        /* After processing a leaf node (neither left nor right\n+         * branches are MerkleLink:DESCEND) we move up the path,\n+         * processing the right branches of nodes for which we had\n+         * descended the left-branch. */\n+        bool done = false;\n+        while (!stack.empty() && !done) {\n+            if (stack.back().second) {\n+                stack.pop_back();\n+            } else {\n+                if (pred(stack.size(), stack.back().first->GetRight(), true)) {\n+                    return {stack.back().first, true};\n+                }\n+                stack.back().second = true;\n+                if (stack.back().first->GetRight() == MerkleLink::DESCEND) {\n+                    done = true;\n+                }\n+            }\n+        }\n+\n+        /* We get to this point only after retreating up the path and\n+         * hitting an inner node for which the right branch has not\n+         * been explored (in which case the stack is not empty and we\n+         * continue), or if we have completed processing the entire\n+         * subtree, in which case traversal terminates. */\n+        if (stack.empty())\n+            return {++pos, false};\n+    }\n+\n+    /* The user-provided traversal predicate did not at any point\n+     * terminate traversal, but we nevertheless hit the end of the\n+     * traversal range with portions of the subtree still left\n+     * unexplored. */\n+    return {last, true};\n+}\n+\n+/*\n+ * A MerkleProof is a transportable structure that contains the\n+ * information necessary to verify the root of a Merkle tree given N\n+ * accompanying \"verify\" hashes. The proof consists of those portions\n+ * of the tree which can't be pruned, and M \"skip\" hashes, each of\n+ * which is either the root hash of a fully pruned subtree, or a leaf\n+ * value not included in the set of \"verify\" hashes.\n+ */\n+struct MerkleProof\n+{\n+    typedef std::vector<MerkleNode> path_type;\n+    path_type m_path;\n+\n+    typedef std::vector<uint256> skip_type;\n+    skip_type m_skip;\n+\n+    MerkleProof(path_type&& path, skip_type&& skip) : m_path(path), m_skip(skip) { }\n+\n+    /* Default constructors and assignment operators are fine */\n+    MerkleProof() = default;\n+    MerkleProof(const MerkleProof&) = default;\n+    MerkleProof(MerkleProof&&) = default;\n+    MerkleProof& operator=(const MerkleProof&) = default;\n+    MerkleProof& operator=(MerkleProof&&) = default;\n+\n+    void clear() noexcept;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(REF(m_path));\n+        /* The standard serialization primitives for a vector involves\n+         * using the Satoshi-defined CompactSize format, which isn't\n+         * actually a very nice format to for most purposes when\n+         * compared with the VarInt encoding developed by Pieter\n+         * Wuille. Since we have the freedom of defining a new\n+         * serialization format for MerkleProofs, we choose to\n+         * explicitly use the latter here. */\n+        uint64_t skip_size = m_skip.size();\n+        READWRITE(VARINT(skip_size));\n+        if (ser_action.ForRead())\n+            m_skip.resize(static_cast<skip_type::size_type>(skip_size));\n+        /* Read/write hashes as plain old data. */\n+        if (!m_skip.empty()) {\n+            READWRITE(REF(CFlatData(m_skip)));\n+        }\n+    }\n+};\n+\n+void swap(MerkleProof& lhs, MerkleProof& rhs);\n+\n+/*\n+ * A MerkleTree combines a MerkleProof with a vector of \"verify\" hash\n+ * values. It also contains methods for re-computing the root hash.\n+ */\n+struct MerkleTree\n+{\n+    typedef MerkleProof proof_type;\n+    proof_type m_proof;\n+\n+    typedef proof_type::skip_type verify_type;\n+    verify_type m_verify;\n+\n+    /* Builds a new Merkle tree with the specified left-branch and\n+     * right-branch, including properly handling the case of left or\n+     * right being a single hash. */\n+    MerkleTree(const MerkleTree& left, const MerkleTree& right);\n+\n+    /* Default constructors and assignment operators are fine */\n+    MerkleTree() = default;\n+    MerkleTree(const MerkleTree&) = default;\n+    MerkleTree(MerkleTree&&) = default;\n+    MerkleTree& operator=(const MerkleTree&) = default;\n+    MerkleTree& operator=(MerkleTree&&) = default;\n+\n+    void clear() noexcept;\n+\n+    /* Calculates the root hash of the MerkleTree, a process that\n+     * requires a depth first traverse of the full tree using linear\n+     * time and logarithmic (depth) space.. */\n+    uint256 GetHash(bool* invalid = nullptr) const;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(REF(m_proof));\n+        /* See the note in MerkleProof about CompactSize vs VarInt. */\n+        uint64_t verify_size = m_verify.size();\n+        READWRITE(VARINT(verify_size));\n+        if (ser_action.ForRead())\n+            m_verify.resize(static_cast<verify_type::size_type>(verify_size));\n+        /* Read/write hashes as plain old data. */\n+        if (!m_verify.empty()) {\n+            READWRITE(REF(CFlatData(m_verify)));\n+        }\n+    }\n+};\n+\n+void swap(MerkleTree& lhs, MerkleTree& rhs);\n+\n #endif // BITCOIN_CONSENSUS_MERKLE_H"
      },
      {
        "sha": "3083203cc429a8762704925a44c2cd61d669f0cd",
        "filename": "src/test/merkle_tests.cpp",
        "status": "modified",
        "additions": 1055,
        "deletions": 0,
        "changes": 1055,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/240c6af170f980303404a2e5b0bd8a9a76c98231/src/test/merkle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/240c6af170f980303404a2e5b0bd8a9a76c98231/src/test/merkle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkle_tests.cpp?ref=240c6af170f980303404a2e5b0bd8a9a76c98231",
        "patch": "@@ -132,8 +132,1025 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(merkle_link)\n+{\n+    BOOST_CHECK(sizeof(MerkleLink) == 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node)\n+{\n+    BOOST_CHECK(sizeof(MerkleNode) == 1);\n+\n+    BOOST_CHECK(MerkleNode().GetCode() == 0);\n+\n+    const MerkleNode by_code[8] = {MerkleNode(0), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(4), MerkleNode(5), MerkleNode(6), MerkleNode(7)};\n+    const MerkleNode by_link[8] = {\n+        MerkleNode(MerkleLink::VERIFY, MerkleLink::SKIP),\n+        MerkleNode(MerkleLink::VERIFY, MerkleLink::VERIFY),\n+        MerkleNode(MerkleLink::VERIFY, MerkleLink::DESCEND),\n+        MerkleNode(MerkleLink::DESCEND, MerkleLink::SKIP),\n+        MerkleNode(MerkleLink::DESCEND, MerkleLink::VERIFY),\n+        MerkleNode(MerkleLink::DESCEND, MerkleLink::DESCEND),\n+        MerkleNode(MerkleLink::SKIP, MerkleLink::VERIFY),\n+        MerkleNode(MerkleLink::SKIP, MerkleLink::DESCEND),\n+    };\n+\n+    for (int i = 0; i <= 7; ++i) {\n+        BOOST_CHECK(i == by_code[i].GetCode());\n+        BOOST_CHECK(i == by_link[i].GetCode());\n+    }\n+\n+    for (int i = 0; i <= 7; ++i) {\n+        for (int j = 0; j <= 7; ++j) {\n+            BOOST_CHECK((i==j) == (by_code[i] == by_link[j]));\n+            BOOST_CHECK((i!=j) == (by_code[i] != by_link[j]));\n+            BOOST_CHECK((i<j) == (by_code[i] < by_link[j]));\n+            BOOST_CHECK((i<=j) == (by_code[i] <= by_link[j]));\n+            BOOST_CHECK((i>=j) == (by_code[i] >= by_link[j]));\n+            BOOST_CHECK((i>j) == (by_code[i] > by_link[j]));\n+        }\n+    }\n+\n+    MerkleNode a(0);\n+    a.SetCode(1);\n+    BOOST_CHECK(a.GetCode() == 1);\n+    BOOST_CHECK(a == MerkleNode(1));\n+\n+    a = MerkleNode(3);\n+    BOOST_CHECK(a != MerkleNode(1));\n+    BOOST_CHECK(a.GetCode() == 3);\n+\n+    for (int i = 0; i <= 7; ++i) {\n+        MerkleNode n = by_code[i];\n+        MerkleLink l = n.GetLeft();\n+        MerkleLink r = n.GetRight();\n+        BOOST_CHECK(MerkleNode(l,r) == by_link[i]);\n+        for (int j = 0; j <= 2; ++j) {\n+          MerkleNode n2(n);\n+          BOOST_CHECK(n2 == n);\n+          n2.SetLeft(MerkleLink(j));\n+          BOOST_CHECK(n2 == MerkleNode(MerkleLink(j),r));\n+        }\n+        for (int j = 0; j <= 2; ++j) {\n+          MerkleNode n3(n);\n+          BOOST_CHECK(n3 == n);\n+          n3.SetRight(MerkleLink(j));\n+          BOOST_CHECK(n3 == MerkleNode(l,MerkleLink(j)));\n+        }\n+    }\n+}\n+\n+/*\n+ * To properly test some features requires access to protected members\n+ * of these classes. In the case of MerkleNode, just some static class\n+ * members so we write a method to return those.\n+ */\n+struct PublicMerkleNode: public MerkleNode\n+{\n+    typedef const std::array<MerkleLink, 8> m_link_from_code_type;\n+    static m_link_from_code_type& m_left_from_code()\n+      { return MerkleNode::m_left_from_code; }\n+    static m_link_from_code_type& m_right_from_code()\n+      { return MerkleNode::m_right_from_code; }\n+};\n+\n+/*\n+ * In the case of MerkleNodeReference we need access to class instance\n+ * members, so we have a somewhat more involve wrapper that is used\n+ * for actual MerkleNodeReference instances (and forwards whatever\n+ * functionality needs to be defined to the base class).\n+ */\n+struct PublicMerkleNodeReference: public MerkleNodeReference\n+{\n+    PublicMerkleNodeReference(base_type* base, offset_type offset) : MerkleNodeReference(base, offset) { }\n+\n+    PublicMerkleNodeReference() = delete;\n+\n+    PublicMerkleNodeReference(const PublicMerkleNodeReference& other) : MerkleNodeReference(other) { }\n+    PublicMerkleNodeReference(const MerkleNodeReference& other) : MerkleNodeReference(other) { }\n+    PublicMerkleNodeReference(PublicMerkleNodeReference&& other) : MerkleNodeReference(other) { }\n+    PublicMerkleNodeReference(MerkleNodeReference&& other) : MerkleNodeReference(other) { }\n+    inline PublicMerkleNodeReference& operator=(const PublicMerkleNodeReference& other)\n+      { return static_cast<PublicMerkleNodeReference&>(MerkleNodeReference::operator=(other)); }\n+    inline PublicMerkleNodeReference& operator=(const MerkleNodeReference& other)\n+      { return static_cast<PublicMerkleNodeReference&>(MerkleNodeReference::operator=(other)); }\n+    inline PublicMerkleNodeReference& operator=(PublicMerkleNodeReference&& other)\n+      { return static_cast<PublicMerkleNodeReference&>(MerkleNodeReference::operator=(other)); }\n+    inline PublicMerkleNodeReference& operator=(MerkleNodeReference&& other)\n+      { return static_cast<PublicMerkleNodeReference&>(MerkleNodeReference::operator=(other)); }\n+\n+    inline PublicMerkleNodeReference& operator=(MerkleNode other)\n+      { return static_cast<PublicMerkleNodeReference&>(MerkleNodeReference::operator=(other)); }\n+    inline operator MerkleNode() const\n+      { return MerkleNodeReference::operator MerkleNode(); }\n+\n+    typedef MerkleNodeReference::base_type* m_base_type;\n+    m_base_type& m_base()\n+      { return MerkleNodeReference::m_base; }\n+    const m_base_type& m_base() const\n+      { return MerkleNodeReference::m_base; }\n+\n+    typedef MerkleNodeReference::offset_type m_offset_type;\n+    m_offset_type& m_offset()\n+      { return MerkleNodeReference::m_offset; }\n+    const m_offset_type& m_offset() const\n+      { return MerkleNodeReference::m_offset; }\n+};\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_reference)\n+{\n+    MerkleNodeReference::base_type v[3] = {0};\n+    PublicMerkleNodeReference _r[8] = {\n+        {v, 0}, {v, 1}, {v, 2}, {v, 3},\n+        {v, 4}, {v, 5}, {v, 6}, {v, 7},\n+    };\n+    MerkleNodeReference* r = &_r[0];\n+    const MerkleNode n[8] = {\n+        MerkleNode(0), MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+        MerkleNode(4), MerkleNode(5), MerkleNode(6), MerkleNode(7),\n+    };\n+\n+    PublicMerkleNodeReference a(v, 0);\n+    BOOST_CHECK(a.m_base() == &v[0]);\n+    BOOST_CHECK(a.m_offset() == 0);\n+\n+    for (int i = 0; i <= 7; ++i) {\n+        BOOST_CHECK(r[i].GetCode() == 0);\n+        PublicMerkleNodeReference(v, i).SetCode(i);\n+        BOOST_CHECK_MESSAGE(r[i].GetCode() == i, strprintf(\"%d\", i).c_str());\n+    }\n+\n+    BOOST_CHECK(v[0] == static_cast<MerkleNodeReference::base_type>(0x05));\n+    BOOST_CHECK(v[1] == static_cast<MerkleNodeReference::base_type>(0x39));\n+    BOOST_CHECK(v[2] == static_cast<MerkleNodeReference::base_type>(0x77));\n+\n+    for (int i = 0; i <= 7; ++i) {\n+        BOOST_CHECK(n[i].GetCode() == i);\n+        BOOST_CHECK(r[i].GetCode() == i);\n+        BOOST_CHECK(r[i].GetLeft() == PublicMerkleNode::m_left_from_code()[i]);\n+        BOOST_CHECK(r[i].GetRight() == PublicMerkleNode::m_right_from_code()[i]);\n+    }\n+\n+    PublicMerkleNodeReference ref(v, 0);\n+    PublicMerkleNodeReference ref2(v, 7);\n+\n+    for (MerkleNode::code_type i = 0; i <= 7; ++i) {\n+        for (MerkleNode::code_type j = 0; j <= 7; ++j) {\n+          ref.SetCode(i);\n+          ref2.SetCode(j);\n+          MerkleNode node(j);\n+          BOOST_CHECK((i==j) == (ref == node));\n+          BOOST_CHECK((j==i) == (node == ref));\n+          BOOST_CHECK((i==j) == (ref == ref2));\n+          BOOST_CHECK((i!=j) == (ref != node));\n+          BOOST_CHECK((j!=i) == (node != ref));\n+          BOOST_CHECK((i!=j) == (ref != ref2));\n+          BOOST_CHECK((i<j) == (ref < node));\n+          BOOST_CHECK((j<i) == (node < ref));\n+          BOOST_CHECK((i<j) == (ref < ref2));\n+          BOOST_CHECK((i<=j) == (ref <= node));\n+          BOOST_CHECK((j<=i) == (node <= ref));\n+          BOOST_CHECK((i<=j) == (ref <= ref2));\n+          BOOST_CHECK((i>=j) == (ref >= node));\n+          BOOST_CHECK((j>=i) == (node >= ref));\n+          BOOST_CHECK((i>=j) == (ref >= ref2));\n+          BOOST_CHECK((i>j) == (ref > node));\n+          BOOST_CHECK((j>i) == (node > ref));\n+          BOOST_CHECK((i>j) == (ref > ref2));\n+          MerkleLink new_left = node.GetLeft();\n+          MerkleLink new_right = node.GetRight();\n+          if ((new_left == MerkleLink::SKIP) && (ref.GetRight() == MerkleLink::SKIP)) {\n+              /* Prevent errors due to temporary {SKIP,SKIP} */\n+              ref.SetRight(MerkleLink::VERIFY);\n+          }\n+          ref.SetLeft(new_left);\n+          BOOST_CHECK(ref.GetLeft() == node.GetLeft());\n+          if ((ref.GetLeft() == MerkleLink::SKIP) && (new_right == MerkleLink::SKIP)) {\n+              /* Prevent errors due to temporary {SKIP,SKIP} */\n+              ref.SetLeft(MerkleLink::VERIFY);\n+          }\n+          ref.SetRight(new_right);\n+          BOOST_CHECK(ref.GetRight() == node.GetRight());\n+          BOOST_CHECK(ref == node);\n+          BOOST_CHECK(node == ref);\n+          ref.SetCode(i);\n+          BOOST_CHECK((i==j) == (ref == ref2));\n+          ref2 = ref;\n+          BOOST_CHECK(ref == ref2);\n+          ref2 = node;\n+          BOOST_CHECK(ref2 == node);\n+          BOOST_CHECK((i==j) == (ref == ref2));\n+          static_cast<MerkleNode>(ref).SetCode(j);\n+          BOOST_CHECK((i==j) == (ref == ref2));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_constructor)\n+{\n+    /* explicit vector(const Allocator& alloc = Allocator()) */\n+    std::vector<MerkleNode> def;\n+    BOOST_CHECK(def.empty());\n+    BOOST_CHECK(!def.dirty());\n+\n+    std::allocator<MerkleNode> alloc;\n+    std::vector<MerkleNode> with_alloc(alloc);\n+    BOOST_CHECK(with_alloc.get_allocator() == std::allocator<MerkleNode>());\n+    BOOST_CHECK(with_alloc.get_allocator() == def.get_allocator());\n+\n+    /* explicit vector(size_type count) */\n+    std::vector<MerkleNode> three(3);\n+    BOOST_CHECK(three.size() == 3);\n+    BOOST_CHECK(three[0] == MerkleNode());\n+    BOOST_CHECK(three[1] == MerkleNode());\n+    BOOST_CHECK(three[2] == MerkleNode());\n+\n+    std::vector<MerkleNode> nine(9);\n+    BOOST_CHECK(nine.size() == 9);\n+    BOOST_CHECK(nine.front() == MerkleNode());\n+    BOOST_CHECK(nine.back() == MerkleNode());\n+\n+    /* vector(size_type count, value_type value, const Allocator& alloc = Allocator()) */\n+    std::vector<MerkleNode> three_ones(3, MerkleNode(1));\n+    BOOST_CHECK(three_ones.size() == 3);\n+    BOOST_CHECK(three_ones[0] == MerkleNode(1));\n+    BOOST_CHECK(three_ones[1] == MerkleNode(1));\n+    BOOST_CHECK(three_ones[2] == MerkleNode(1));\n+    BOOST_CHECK(three.size() == three_ones.size());\n+    BOOST_CHECK(three != three_ones);\n+\n+    std::vector<MerkleNode> nine_sevens(9, MerkleNode(7), alloc);\n+    BOOST_CHECK(nine_sevens.size() == 9);\n+    BOOST_CHECK(nine_sevens.front() == MerkleNode(7));\n+    BOOST_CHECK(nine_sevens.back() == MerkleNode(7));\n+    BOOST_CHECK(nine.size() == nine_sevens.size());\n+    BOOST_CHECK(nine != nine_sevens);\n+\n+    /* void assign(size_type count, value_type value) */\n+    {\n+        std::vector<MerkleNode> t(nine_sevens);\n+        t.assign(3, MerkleNode(1));\n+        BOOST_CHECK(t == three_ones);\n+        std::vector<MerkleNode> t2(three_ones);\n+        t2.assign(9, MerkleNode(7));\n+        BOOST_CHECK(t2 == nine_sevens);\n+    }\n+\n+    /* template<class InputIt> vector(InputIt first, InputIt last, const Allocator& alloc = Allocator()) */\n+    std::vector<MerkleNode> one_two_three;\n+    one_two_three.push_back(MerkleNode(1)); BOOST_CHECK(one_two_three[0].GetCode() == 1);\n+    one_two_three.push_back(MerkleNode(2)); BOOST_CHECK(one_two_three[1].GetCode() == 2);\n+    one_two_three.push_back(MerkleNode(3)); BOOST_CHECK(one_two_three[2].GetCode() == 3);\n+\n+    std::list<MerkleNode> l{MerkleNode(1), MerkleNode(2), MerkleNode(3)};\n+    std::vector<MerkleNode> from_list(l.begin(), l.end());\n+    BOOST_CHECK(from_list == one_two_three);\n+\n+    std::deque<MerkleNode> q{MerkleNode(3), MerkleNode(2), MerkleNode(1)};\n+    std::vector<MerkleNode> from_reversed_deque(q.rbegin(), q.rend(), alloc);\n+    BOOST_CHECK(from_reversed_deque == one_two_three);\n+    BOOST_CHECK(from_reversed_deque == from_list);\n+\n+    /* template<class InputIt> void assign(InputIt first, InputIt last) */\n+    {\n+        std::vector<MerkleNode> t(nine_sevens);\n+        t.assign(from_list.begin(), from_list.end());\n+        BOOST_CHECK(t == one_two_three);\n+        std::vector<MerkleNode> t2;\n+        t2.assign(q.rbegin(), q.rend());\n+        BOOST_CHECK(t2 == one_two_three);\n+    }\n+\n+    /* vector(std::initializer_list<value_type> ilist, const Allocator& alloc = Allocator()) */\n+    std::vector<MerkleNode> from_ilist{MerkleNode(1), MerkleNode(2), MerkleNode(3)};\n+    BOOST_CHECK(from_ilist == one_two_three);\n+\n+    /* vector& operator=(std::initializer_list<value_type> ilist) */\n+    {\n+        std::vector<MerkleNode> t(nine_sevens);\n+        t = {MerkleNode(1), MerkleNode(2), MerkleNode(3)};\n+        BOOST_CHECK(t == one_two_three);\n+    }\n+\n+    /* void assign(std::initializer_list<value_type> ilist) */\n+    {\n+        std::vector<MerkleNode> t(nine_sevens);\n+        t.assign({MerkleNode(1), MerkleNode(2), MerkleNode(3)});\n+        BOOST_CHECK(t == one_two_three);\n+    }\n+\n+    /* vector(const vector& other) */\n+    {\n+        std::vector<MerkleNode> v123(one_two_three);\n+        BOOST_CHECK(v123.size() == 3);\n+        BOOST_CHECK(v123[0] == MerkleNode(1));\n+        BOOST_CHECK(v123[1] == MerkleNode(2));\n+        BOOST_CHECK(v123[2] == MerkleNode(3));\n+        BOOST_CHECK(v123 == one_two_three);\n+    }\n+\n+    /* vector(const vector& other, const Allocator& alloc) */\n+    {\n+        std::vector<MerkleNode> v123(one_two_three, alloc);\n+        BOOST_CHECK(v123.size() == 3);\n+        BOOST_CHECK(v123[0] == MerkleNode(1));\n+        BOOST_CHECK(v123[1] == MerkleNode(2));\n+        BOOST_CHECK(v123[2] == MerkleNode(3));\n+        BOOST_CHECK(v123 == one_two_three);\n+    }\n+\n+    /* vector(vector&& other) */\n+    {\n+        std::vector<MerkleNode> v123a(one_two_three);\n+        BOOST_CHECK(v123a == one_two_three);\n+        std::vector<MerkleNode> v123b(std::move(v123a));\n+        BOOST_CHECK(v123b == one_two_three);\n+    }\n+\n+    /* vector(vector&& other, const Allocator& alloc) */\n+    {\n+        std::vector<MerkleNode> v123a(one_two_three);\n+        BOOST_CHECK(v123a == one_two_three);\n+        std::vector<MerkleNode> v123b(std::move(v123a), alloc);\n+        BOOST_CHECK(v123b == one_two_three);\n+    }\n+\n+    /* vector& operator=(const vector& other) */\n+    {\n+        std::vector<MerkleNode> v123;\n+        v123 = one_two_three;\n+        BOOST_CHECK(v123.size() == 3);\n+        BOOST_CHECK(v123[0] == MerkleNode(1));\n+        BOOST_CHECK(v123[1] == MerkleNode(2));\n+        BOOST_CHECK(v123[2] == MerkleNode(3));\n+        BOOST_CHECK(v123 == one_two_three);\n+    }\n+\n+    /* vector& operator=(vector&& other) */\n+    {\n+        std::vector<MerkleNode> v123;\n+        v123 = std::move(one_two_three);\n+        BOOST_CHECK(v123.size() == 3);\n+        BOOST_CHECK(v123[0] == MerkleNode(1));\n+        BOOST_CHECK(v123[1] == MerkleNode(2));\n+        BOOST_CHECK(v123[2] == MerkleNode(3));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_relational)\n+{\n+    std::vector<MerkleNode> a{MerkleNode(0)};\n+    std::vector<MerkleNode> b{MerkleNode(0), MerkleNode(1)};\n+\n+    BOOST_CHECK(!(a==b));\n+    BOOST_CHECK(a!=b);\n+    BOOST_CHECK(a<b);\n+    BOOST_CHECK(a<=b);\n+    BOOST_CHECK(!(a>=b));\n+    BOOST_CHECK(!(a>b));\n+\n+    a.push_back(MerkleNode(1));\n+\n+    BOOST_CHECK(a==b);\n+    BOOST_CHECK(!(a!=b));\n+    BOOST_CHECK(!(a<b));\n+    BOOST_CHECK(a<=b);\n+    BOOST_CHECK(a>=b);\n+    BOOST_CHECK(!(a>b));\n+\n+    a.push_back(MerkleNode(2));\n+\n+    BOOST_CHECK(!(a==b));\n+    BOOST_CHECK(a!=b);\n+    BOOST_CHECK(!(a<b));\n+    BOOST_CHECK(!(a<=b));\n+    BOOST_CHECK(a>=b);\n+    BOOST_CHECK(a>b);\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_access)\n+{\n+    std::vector<MerkleNode> v{MerkleNode(1), MerkleNode(2), MerkleNode(3)};\n+    const std::vector<MerkleNode>& c = v;\n+\n+    BOOST_CHECK(v == c);\n+\n+    BOOST_CHECK(v.at(0) == MerkleNode(1));\n+    BOOST_CHECK(c.at(0) == MerkleNode(1));\n+    BOOST_CHECK(v.at(1) == MerkleNode(2));\n+    BOOST_CHECK(v.at(1) == MerkleNode(2));\n+    BOOST_CHECK(v.at(2) == MerkleNode(3));\n+    BOOST_CHECK(v.at(2) == MerkleNode(3));\n+\n+    BOOST_CHECK_THROW(v.at(3), std::out_of_range);\n+    BOOST_CHECK_THROW(c.at(3), std::out_of_range);\n+\n+    BOOST_CHECK(v[0] == MerkleNode(1));\n+    BOOST_CHECK(c[0] == MerkleNode(1));\n+    BOOST_CHECK(v[1] == MerkleNode(2));\n+    BOOST_CHECK(c[1] == MerkleNode(2));\n+    BOOST_CHECK(v[2] == MerkleNode(3));\n+    BOOST_CHECK(c[2] == MerkleNode(3));\n+\n+    /* Known to work due to a weirdness of the packed format, used as\n+     * a check that the access is not bounds checked. */\n+    BOOST_CHECK(!v.dirty());\n+    BOOST_CHECK(v[3] == MerkleNode(0));\n+    BOOST_CHECK(!c.dirty());\n+    BOOST_CHECK(c[3] == MerkleNode(0));\n+\n+    BOOST_CHECK(v.front() == MerkleNode(1));\n+    BOOST_CHECK(c.front() == MerkleNode(1));\n+    BOOST_CHECK(v.back() == MerkleNode(3));\n+    BOOST_CHECK(c.back() == MerkleNode(3));\n+\n+    BOOST_CHECK(v.data()[0] == 0x29);\n+    BOOST_CHECK(c.data()[0] == 0x29);\n+    BOOST_CHECK(v.data()[1] == 0x80);\n+    BOOST_CHECK(c.data()[1] == 0x80);\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_iterator)\n+{\n+    std::vector<MerkleNode> v{MerkleNode(1), MerkleNode(2), MerkleNode(3)};\n+    const std::vector<MerkleNode>& cv = v;\n+\n+    BOOST_CHECK(v.begin()[0] == MerkleNode(1));\n+    BOOST_CHECK(v.begin()[1] == MerkleNode(2));\n+    BOOST_CHECK(v.begin()[2] == MerkleNode(3));\n+    BOOST_CHECK(*(2 + v.begin()) == MerkleNode(3));\n+    auto i = v.begin();\n+    BOOST_CHECK(*i++ == MerkleNode(1));\n+    BOOST_CHECK(*i++ == MerkleNode(2));\n+    BOOST_CHECK(*i++ == MerkleNode(3));\n+    BOOST_CHECK(i-- == v.end());\n+    BOOST_CHECK(*i-- == MerkleNode(3));\n+    BOOST_CHECK(*i-- == MerkleNode(2));\n+    BOOST_CHECK(*i == MerkleNode(1));\n+    i += 2;\n+    BOOST_CHECK(*i == MerkleNode(3));\n+    BOOST_CHECK((i - v.begin()) == 2);\n+    i -= 2;\n+    BOOST_CHECK(i == v.begin());\n+    BOOST_CHECK(std::distance(v.begin(), v.end()) == 3);\n+    BOOST_CHECK((v.end() - v.begin()) == 3);\n+\n+    BOOST_CHECK(cv.begin()[0] == MerkleNode(1));\n+    BOOST_CHECK(cv.begin()[1] == MerkleNode(2));\n+    BOOST_CHECK(cv.begin()[2] == MerkleNode(3));\n+    BOOST_CHECK(*(2 + cv.begin()) == MerkleNode(3));\n+    auto c = cv.begin();\n+    BOOST_CHECK(*c++ == MerkleNode(1));\n+    BOOST_CHECK(*c++ == MerkleNode(2));\n+    BOOST_CHECK(*c++ == MerkleNode(3));\n+    BOOST_CHECK(c-- == cv.cend());\n+    BOOST_CHECK(*c-- == MerkleNode(3));\n+    BOOST_CHECK(*c-- == MerkleNode(2));\n+    BOOST_CHECK(*c == MerkleNode(1));\n+    c += 2;\n+    BOOST_CHECK(*c == MerkleNode(3));\n+    BOOST_CHECK((c - v.begin()) == 2);\n+    c -= 2;\n+    BOOST_CHECK(c == cv.begin());\n+    BOOST_CHECK(std::distance(cv.begin(), cv.end()) == 3);\n+    BOOST_CHECK((cv.end() - cv.begin()) == 3);\n+\n+    BOOST_CHECK(v.cbegin()[0] == MerkleNode(1));\n+    BOOST_CHECK(v.cbegin()[1] == MerkleNode(2));\n+    BOOST_CHECK(v.cbegin()[2] == MerkleNode(3));\n+    BOOST_CHECK(*(2 + v.cbegin()) == MerkleNode(3));\n+    auto c2 = v.cbegin();\n+    BOOST_CHECK(*c2++ == MerkleNode(1));\n+    BOOST_CHECK(*c2++ == MerkleNode(2));\n+    BOOST_CHECK(*c2++ == MerkleNode(3));\n+    BOOST_CHECK(c2-- == v.cend());\n+    BOOST_CHECK(*c2-- == MerkleNode(3));\n+    BOOST_CHECK(*c2-- == MerkleNode(2));\n+    BOOST_CHECK(*c2 == MerkleNode(1));\n+    c2 += 2;\n+    BOOST_CHECK(*c2 == MerkleNode(3));\n+    BOOST_CHECK((c2 - v.cbegin()) == 2);\n+    c2 -= 2;\n+    BOOST_CHECK(c2 == v.cbegin());\n+    BOOST_CHECK(std::distance(v.cbegin(), v.cend()) == 3);\n+    BOOST_CHECK((v.cend() - v.cbegin()) == 3);\n+\n+    BOOST_CHECK(v.rbegin()[0] == MerkleNode(3));\n+    BOOST_CHECK(v.rbegin()[1] == MerkleNode(2));\n+    BOOST_CHECK(v.rbegin()[2] == MerkleNode(1));\n+    BOOST_CHECK(*(2 + v.rbegin()) == MerkleNode(1));\n+    auto r = v.rbegin();\n+    BOOST_CHECK(*r++ == MerkleNode(3));\n+    BOOST_CHECK(*r++ == MerkleNode(2));\n+    BOOST_CHECK(*r++ == MerkleNode(1));\n+    BOOST_CHECK(r-- == v.rend());\n+    BOOST_CHECK(*r-- == MerkleNode(1));\n+    BOOST_CHECK(*r-- == MerkleNode(2));\n+    BOOST_CHECK(*r == MerkleNode(3));\n+    r += 2;\n+    BOOST_CHECK(*r == MerkleNode(1));\n+    BOOST_CHECK((r - v.rbegin()) == 2);\n+    r -= 2;\n+    BOOST_CHECK(r == v.rbegin());\n+    BOOST_CHECK(std::distance(v.rbegin(), v.rend()) == 3);\n+    BOOST_CHECK((v.rend() - v.rbegin()) == 3);\n+\n+    BOOST_CHECK(cv.rbegin()[0] == MerkleNode(3));\n+    BOOST_CHECK(cv.rbegin()[1] == MerkleNode(2));\n+    BOOST_CHECK(cv.rbegin()[2] == MerkleNode(1));\n+    BOOST_CHECK(*(2 + cv.rbegin()) == MerkleNode(1));\n+    auto rc = cv.rbegin();\n+    BOOST_CHECK(*rc++ == MerkleNode(3));\n+    BOOST_CHECK(*rc++ == MerkleNode(2));\n+    BOOST_CHECK(*rc++ == MerkleNode(1));\n+    BOOST_CHECK(rc-- == cv.rend());\n+    BOOST_CHECK(*rc-- == MerkleNode(1));\n+    BOOST_CHECK(*rc-- == MerkleNode(2));\n+    BOOST_CHECK(*rc == MerkleNode(3));\n+    rc += 2;\n+    BOOST_CHECK(*rc == MerkleNode(1));\n+    BOOST_CHECK((rc - cv.rbegin()) == 2);\n+    rc -= 2;\n+    BOOST_CHECK(rc == cv.rbegin());\n+    BOOST_CHECK(std::distance(cv.rbegin(), cv.rend()) == 3);\n+    BOOST_CHECK((cv.rend() - cv.rbegin()) == 3);\n+\n+    BOOST_CHECK(v.crbegin()[0] == MerkleNode(3));\n+    BOOST_CHECK(v.crbegin()[1] == MerkleNode(2));\n+    BOOST_CHECK(v.crbegin()[2] == MerkleNode(1));\n+    BOOST_CHECK(*(2 + v.crbegin()) == MerkleNode(1));\n+    auto rc2 = v.crbegin();\n+    BOOST_CHECK(*rc2++ == MerkleNode(3));\n+    BOOST_CHECK(*rc2++ == MerkleNode(2));\n+    BOOST_CHECK(*rc2++ == MerkleNode(1));\n+    BOOST_CHECK(rc2-- == v.crend());\n+    BOOST_CHECK(*rc2-- == MerkleNode(1));\n+    BOOST_CHECK(*rc2-- == MerkleNode(2));\n+    BOOST_CHECK(*rc2 == MerkleNode(3));\n+    rc2 += 2;\n+    BOOST_CHECK(*rc2 == MerkleNode(1));\n+    BOOST_CHECK((rc2 - v.crbegin()) == 2);\n+    rc2 -= 2;\n+    BOOST_CHECK(rc2 == v.crbegin());\n+    BOOST_CHECK(std::distance(v.crbegin(), v.crend()) == 3);\n+    BOOST_CHECK((v.crend() - v.crbegin()) == 3);\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_capacity)\n+{\n+    std::vector<MerkleNode> v;\n+    BOOST_CHECK(v.empty());\n+    BOOST_CHECK(v.size() == 0);\n+    BOOST_CHECK(v.max_size() >= std::vector<unsigned char>().max_size());\n+    BOOST_CHECK(v.capacity() >= v.size());\n+\n+    v.push_back(MerkleNode(1));\n+    BOOST_CHECK(!v.empty());\n+    BOOST_CHECK(v.size() == 1);\n+    BOOST_CHECK(v.capacity() >= v.size());\n+\n+    v.push_back(MerkleNode(2));\n+    BOOST_CHECK(!v.empty());\n+    BOOST_CHECK(v.size() == 2);\n+    BOOST_CHECK(v.capacity() >= v.size());\n+\n+    v.push_back(MerkleNode(3));\n+    BOOST_CHECK(!v.empty());\n+    BOOST_CHECK(v.size() == 3);\n+    BOOST_CHECK(v.capacity() >= v.size());\n+\n+    BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+\n+    v.resize(6);\n+    BOOST_CHECK(!v.empty());\n+    BOOST_CHECK(v.size() == 6);\n+    BOOST_CHECK(v.capacity() >= v.size());\n+\n+    BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                              MerkleNode(0), MerkleNode(0), MerkleNode(0)}));\n+\n+    v.shrink_to_fit();\n+    BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                              MerkleNode(0), MerkleNode(0), MerkleNode(0)}));\n+\n+    v.resize(9, MerkleNode(7));\n+    BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                              MerkleNode(0), MerkleNode(0), MerkleNode(0),\n+                                              MerkleNode(7), MerkleNode(7), MerkleNode(7)}));\n+\n+    v.shrink_to_fit();\n+    BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                              MerkleNode(0), MerkleNode(0), MerkleNode(0),\n+                                              MerkleNode(7), MerkleNode(7), MerkleNode(7)}));\n+\n+    v.resize(3);\n+    BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+}\n+\n+/*\n+ * Takes an iterator of any category derived from InputIterator, and\n+ * exposes an interface restricted to only support the InputIterator\n+ * API, including the input_iterator_tag. Useful for mocking an\n+ * InputIterator for testing non-random-access or non-bidirectional\n+ * code paths.\n+ */\n+template<class Iter>\n+struct mock_input_iterator: public std::iterator<std::input_iterator_tag, typename Iter::reference>\n+{\n+    typedef Iter inner_type;\n+    inner_type m_iter;\n+\n+    typedef mock_input_iterator iterator;\n+    typedef typename inner_type::value_type value_type;\n+    typedef typename inner_type::difference_type difference_type;\n+    typedef typename inner_type::pointer pointer;\n+    typedef typename inner_type::reference reference;\n+\n+    mock_input_iterator() = delete;\n+\n+    explicit mock_input_iterator(inner_type& iter) : m_iter(iter) { }\n+\n+    iterator& operator=(inner_type& iter)\n+    {\n+        m_iter = iter;\n+        return *this;\n+    }\n+\n+    mock_input_iterator(const iterator&) = default;\n+    mock_input_iterator(iterator&&) = default;\n+    iterator& operator=(const iterator&) = default;\n+    iterator& operator=(iterator&&) = default;\n+\n+    /* Distance */\n+    difference_type operator-(const iterator& other) const\n+      { return (m_iter - other.m_iter); }\n+\n+    /* Equality */\n+    inline bool operator==(const iterator& other) const\n+      { return (m_iter == other.m_iter); }\n+    inline bool operator!=(const iterator& other) const\n+      { return (m_iter != other.m_iter); }\n+\n+    /* Input iterators are not relational comparable */\n+\n+    /* Dereference */\n+    inline reference operator*() const\n+      { return (*m_iter); }\n+    inline pointer operator->() const\n+      { return m_iter.operator->(); }\n+\n+    /* Advancement */\n+    inline iterator& operator++()\n+    {\n+        m_iter.operator++();\n+        return *this;\n+    }\n+\n+    inline iterator& operator++(int _)\n+      { return iterator(m_iter.operator++(_)); }\n+};\n+\n+template<class Iter>\n+inline mock_input_iterator<Iter> wrap_mock_input_iterator(Iter iter)\n+  { return mock_input_iterator<Iter>(iter); }\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_insert)\n+{\n+    /* void push_back(value_type value) */\n+    /* template<class... Args> void emplace_back(Args&&... args) */\n+    std::vector<MerkleNode> one_two_three;\n+    one_two_three.push_back(MerkleNode(1));\n+    one_two_three.emplace_back(static_cast<MerkleNode::code_type>(2));\n+    one_two_three.emplace_back(MerkleLink::DESCEND, MerkleLink::SKIP);\n+    BOOST_CHECK(one_two_three.size() == 3);\n+    BOOST_CHECK(one_two_three[0] == MerkleNode(1));\n+    BOOST_CHECK(one_two_three[1] == MerkleNode(2));\n+    BOOST_CHECK(one_two_three[2] == MerkleNode(3));\n+\n+    /* void clear() */\n+    {\n+        std::vector<MerkleNode> v(one_two_three);\n+        BOOST_CHECK(v.size() == 3);\n+        BOOST_CHECK(v == one_two_three);\n+        v.clear();\n+        BOOST_CHECK(v.empty());\n+        BOOST_CHECK(one_two_three.size() == 3);\n+    }\n+\n+    /* iterator insert(const_iterator pos, value_type value) */\n+    {\n+        std::vector<MerkleNode> v(one_two_three);\n+        auto res = v.insert(v.begin(), MerkleNode(0));\n+        BOOST_CHECK(res == v.begin());\n+        BOOST_CHECK(v != one_two_three);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+        res = v.insert(v.begin()+2, MerkleNode(4));\n+        BOOST_CHECK(res == (v.begin()+2));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(3)}));\n+        res = v.insert(v.begin()+4, MerkleNode(5));\n+        BOOST_CHECK(res == (v.begin()+4));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(5), MerkleNode(3)}));\n+        res = v.insert(v.begin()+6, MerkleNode(6));\n+        BOOST_CHECK(res == (v.begin()+6));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(5), MerkleNode(3), MerkleNode(6)}));\n+        res = v.insert(v.end(), MerkleNode(7));\n+        BOOST_CHECK(res != v.end());\n+        BOOST_CHECK(res == (v.begin()+7));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(5), MerkleNode(3), MerkleNode(6), MerkleNode(7)}));\n+    }\n+\n+    /* iterator insert(const_iterator pos, size_type count, value_type value) */\n+    {\n+        std::vector<MerkleNode> v(one_two_three);\n+        auto res = v.insert(v.begin(), 0, MerkleNode(0));\n+        BOOST_CHECK(res == v.begin());\n+        BOOST_CHECK(v == one_two_three);\n+        res = v.insert(v.begin()+1, 1, MerkleNode(4));\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(3)}));\n+        res = v.insert(v.begin()+3, 2, MerkleNode(5));\n+        BOOST_CHECK(res == (v.begin()+3));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(5), MerkleNode(5), MerkleNode(3)}));\n+        res = v.insert(v.begin()+6, 3, MerkleNode(6));\n+        BOOST_CHECK(res == (v.begin()+6));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(5), MerkleNode(5), MerkleNode(3), MerkleNode(6), MerkleNode(6), MerkleNode(6)}));\n+        res = v.insert(v.end(), 2, MerkleNode(7));\n+        BOOST_CHECK(res != v.end());\n+        BOOST_CHECK(res == (v.begin()+9));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(4), MerkleNode(2), MerkleNode(5), MerkleNode(5), MerkleNode(3), MerkleNode(6), MerkleNode(6), MerkleNode(6), MerkleNode(7), MerkleNode(7)}));\n+    }\n+\n+    /* template<class InputIt> iterator insert(const_iterator pos, InputIt first, InputIt last) */\n+    {\n+        std::vector<MerkleNode> ones({MerkleNode(1), MerkleNode(1)});\n+        std::vector<MerkleNode> twos({MerkleNode(2), MerkleNode(2)});\n+        std::vector<MerkleNode> v;\n+        BOOST_CHECK(v.empty());\n+        auto res = v.insert(v.begin(), wrap_mock_input_iterator(ones.begin()), wrap_mock_input_iterator(ones.end()));\n+        BOOST_CHECK(res == v.begin());\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(1)}));\n+        res = v.insert(v.begin()+1, one_two_three.begin(), one_two_three.end());\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1)}));\n+        res = v.insert(v.end(), twos.begin(), twos.begin() + 1);\n+        BOOST_CHECK(res != v.end());\n+        BOOST_CHECK(res == (v.begin()+5));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2)}));\n+        std::vector<MerkleNode> v2(v);\n+        res = v2.insert(v2.end(), v.begin(), v.end());\n+        BOOST_CHECK(res != v2.end());\n+        BOOST_CHECK(res == (v2.begin()+6));\n+        BOOST_CHECK(v2 == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2)}));\n+        std::vector<MerkleNode> v3(v2);\n+        res = v3.insert(v3.begin()+1, v2.begin(), v2.end());\n+        BOOST_CHECK(res == (v3.begin()+1));\n+        BOOST_CHECK(v3 == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2)}));\n+        res = v3.insert(v3.begin(), one_two_three.begin(), one_two_three.end());\n+        BOOST_CHECK(res == v3.begin());\n+        BOOST_CHECK(v3 == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2), MerkleNode(1), MerkleNode(1), MerkleNode(2), MerkleNode(3), MerkleNode(1), MerkleNode(2)}));\n+    }\n+\n+    /* iterator insert(const_iterator pos, std::initializer_list<value_type> ilist) */\n+    {\n+        std::vector<MerkleNode> v;\n+        auto res = v.insert(v.begin(), {MerkleNode(1), MerkleNode(1)});\n+        BOOST_CHECK(res == v.begin());\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(1)}));\n+        res = v.insert(v.begin()+1, {MerkleNode(2), MerkleNode(2)});\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(2), MerkleNode(1)}));\n+        res = v.insert(v.end(), {MerkleNode(3)});\n+        BOOST_CHECK(res == (v.begin()+4));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(2), MerkleNode(1), MerkleNode(3)}));\n+    }\n+\n+    /* template<class... Args> iterator emplace(const_iterator pos, Args&&... args) */\n+    {\n+        std::vector<MerkleNode> v;\n+        auto res = v.emplace(v.begin());\n+        BOOST_CHECK(res == v.begin());\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0)}));\n+        res = v.emplace(v.end(), MerkleNode(2));\n+        BOOST_CHECK(res != v.end());\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(2)}));\n+        res = v.emplace(res, static_cast<MerkleNode::code_type>(1));\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(2)}));\n+        res = v.emplace(v.end(), MerkleLink::DESCEND, MerkleLink::SKIP);\n+        BOOST_CHECK(res != v.end());\n+        BOOST_CHECK(res == (v.begin()+3));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(0), MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+    }\n+\n+    /* iterator erase(const_iterator pos) */\n+    {\n+        std::vector<MerkleNode> v(one_two_three);\n+        auto res = v.erase(v.begin()+1);\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(3)}));\n+        res = v.erase(v.begin());\n+        BOOST_CHECK(res == v.begin());\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(3)}));\n+    }\n+\n+    /* iterator erase(const_iterator first, const_iterator last) */\n+    {\n+        std::vector<MerkleNode> v(one_two_three);\n+        auto res = v.erase(v.begin()+1, v.end());\n+        BOOST_CHECK(res == v.end());\n+        BOOST_CHECK(res == (v.begin()+1));\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1)}));\n+    }\n+\n+    /* void pop_back() */\n+    {\n+        std::vector<MerkleNode> v;\n+        v.insert(v.end(), one_two_three.begin(), one_two_three.end());\n+        v.insert(v.end(), one_two_three.begin(), one_two_three.end());\n+        v.insert(v.end(), one_two_three.begin(), one_two_three.end());\n+        BOOST_CHECK(v.size() == 9);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 8);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 7);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 6);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 5);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1), MerkleNode(2)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 4);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3),\n+                                                  MerkleNode(1)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 3);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2), MerkleNode(3)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 2);\n+        BOOST_CHECK(v == std::vector<MerkleNode>({MerkleNode(1), MerkleNode(2)}));\n+        v.pop_back();\n+        BOOST_CHECK(v.size() == 1);\n+        BOOST_CHECK(v == std::vector<MerkleNode>(1, MerkleNode(1)));\n+        v.pop_back();\n+        BOOST_CHECK(v.empty());\n+        BOOST_CHECK(v == std::vector<MerkleNode>());\n+    }\n+\n+    /* void swap(vector& other) */\n+    {\n+        std::vector<MerkleNode> tmp;\n+        BOOST_CHECK(tmp.empty());\n+        tmp.swap(one_two_three);\n+        BOOST_CHECK(tmp.size() == 3);\n+    }\n+    BOOST_CHECK(one_two_three.empty());\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_dirty)\n+{\n+    static std::size_t k_vch_size[9] =\n+      {0, 1, 1, 2, 2, 2, 3, 3, 3};\n+\n+    for (std::size_t i = 1; i <= 8; ++i) {\n+        std::vector<MerkleNode> v;\n+        for (std::size_t j = 0; j < i; ++j)\n+            v.emplace_back(static_cast<MerkleNode::code_type>(j));\n+        for (std::size_t j = 0; j < (8*k_vch_size[i]); ++j) {\n+            BOOST_CHECK(!v.dirty());\n+            v.data()[j/8] ^= (1 << (7-(j%8)));\n+            BOOST_CHECK((j < (3*i)) == !(v.dirty()));\n+            v.data()[j/8] ^= (1 << (7-(j%8)));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_node_vector_serialize)\n+{\n+    typedef std::vector<unsigned char> vch;\n+\n+    std::vector<MerkleNode> v;\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x00\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(0);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x01\\x00\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(1);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x02\\x04\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(2);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x03\\x05\\x00\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(3);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x04\\x05\\x30\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(4);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x05\\x05\\x38\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(5);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x06\\x05\\x39\\x40\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(6);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x07\\x05\\x39\\x70\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(7);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x08\\x05\\x39\\x77\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    v.emplace_back(5);\n+    {\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, v);\n+        BOOST_CHECK(std::equal(ds.begin(), ds.end(), \"\\x09\\x05\\x39\\x77\\xa0\"));\n+        std::vector<MerkleNode> v2;\n+        ds >> v2;\n+        BOOST_CHECK(v == v2);\n+    }\n+\n+    {\n+        auto data = ParseHex(\"02600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\");\n+        CDataStream ds(SER_NETWORK, PROTOCOL_VERSION, CFlatData(data.data(), data.data()+data.size()));\n+        MerkleProof proof;\n+        BOOST_CHECK_MESSAGE(ds[0] == '\\x02', HexStr(ds.begin(), ds.end()).c_str());\n+        BOOST_CHECK_MESSAGE(ds.size() == 67, HexStr(ds.begin(), ds.end()).c_str());\n+        ds >> proof;\n+        BOOST_CHECK(ds.empty());\n+        BOOST_CHECK(proof.m_path.size() == 2);\n+        BOOST_CHECK(proof.m_path[0] == MerkleNode(MerkleLink::DESCEND, MerkleLink::SKIP));\n+        BOOST_CHECK(proof.m_path[1] == MerkleNode(MerkleLink::VERIFY, MerkleLink::SKIP));\n+        BOOST_CHECK(proof.m_skip.size() == 2);\n+        BOOST_CHECK(proof.m_skip[0] == uint256S(\"b98db090398ebc4342951f9ba89b3e0110bdc757714b80c695663c9060113639\"));\n+        BOOST_CHECK(proof.m_skip[1] == uint256S(\"d377b92dd7af8f1b25b2ac96f5ac68d0d8ae0e15fc370f89ea0fa36c3d753266\"));\n+    }\n+}\n+\n BOOST_AUTO_TEST_CASE(fast_merkle_branch)\n {\n+    using std::swap;\n     const std::vector<uint256> leaves = {\n       (CHashWriter(SER_GETHASH, PROTOCOL_VERSION) << 'a').GetHash(),\n       (CHashWriter(SER_GETHASH, PROTOCOL_VERSION) << 'b').GetHash(),\n@@ -170,6 +1187,44 @@ BOOST_AUTO_TEST_CASE(fast_merkle_branch)\n         BOOST_CHECK(branch[0] == uint256S(\"0xc771140365578d348d7ffc6e04a102ecf3e2eea51177d38fac92f954aebdd1cd\"));\n         BOOST_CHECK(root == ComputeFastMerkleRootFromBranch(leaves[2], branch, path));\n     }\n+    BOOST_CHECK(ComputeFastMerkleRoot({}) == MerkleTree().GetHash());\n+    for (int i = 1; i < 35; ++i) {\n+        std::vector<uint256> leaves;\n+        leaves.resize(i);\n+        for (int j = 0; j < i; ++j) {\n+            leaves.back().begin()[j/8] ^= ((char)1 << (j%8));\n+        }\n+        const uint256 root = ComputeFastMerkleRoot(leaves);\n+        for (int j = 0; j < i; ++j) {\n+            const auto branch = ComputeFastMerkleBranch(leaves, j);\n+            BOOST_CHECK(ComputeFastMerkleRootFromBranch(leaves[j], branch.first, branch.second) == root);\n+            std::vector<MerkleTree> subtrees(i);\n+            for (int k = 0; k < i; ++k) {\n+                if (k == j) {\n+                    subtrees[k].m_verify.push_back(leaves[k]);\n+                } else {\n+                    subtrees[k].m_proof.m_skip.push_back(leaves[k]);\n+                }\n+            }\n+            while (subtrees.size() > 1) {\n+                std::vector<MerkleTree> other;\n+                for (auto itr = subtrees.begin(); itr != subtrees.end(); ++itr) {\n+                    auto itr2 = std::next(itr);\n+                    if (itr2 != subtrees.end()) {\n+                        other.emplace_back(*(itr++), *itr2);\n+                    } else {\n+                        other.emplace_back();\n+                        swap(other.back(), *itr);\n+                    }\n+                }\n+                swap(subtrees, other);\n+            }\n+            BOOST_CHECK(subtrees[0].m_verify.size() == 1);\n+            bool invalid = false;\n+            BOOST_CHECK(subtrees[0].GetHash(&invalid) == root);\n+            BOOST_CHECK(!invalid);\n+        }\n+    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "19b7f05059dc5da5ba911d81fbea42bbe83bf940",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOWI3ZjA1MDU5ZGM1ZGE1YmE5MTFkODFmYmVhNDJiYmU4M2JmOTQw",
    "commit": {
      "author": {
        "name": "Mark Friedenbach",
        "email": "mark@friedenbach.org",
        "date": "2017-08-30T20:49:50Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:08:56Z"
      },
      "message": "Replace NOP4 with MERKLEBRANCHVERIFY, presently disabled.\n\n  [... leaf/H(leaf) ...] proof root {count,prehashed} MERKLEBRANCHVERIFY\n\nThis opcode takes a Merkle root, any number of leaf hashes of the tree, and a 'proof' object composed of an encoding of the path through the tree from root to leaves and the minimal set of hash values necessary to recompute the the root from the leaf. Script validation fails if the recomputed root does not match the hash provided (which, presumably, would be committed to in the scriptPubKey).\n\nOnly the logic and unit tests are implemented; this commit does not have any soft-fork activation logic in it.\n\nSee BIP116 for details.",
      "tree": {
        "sha": "bea2cb635c9c189ba38fe62c59de5959429d96b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bea2cb635c9c189ba38fe62c59de5959429d96b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/19b7f05059dc5da5ba911d81fbea42bbe83bf940",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyfgACgkQV692LbM1\nMyIb+w//WD18QZh0JAs8r2FgF2239Wvy0nhSb5YMcFb+bmxeAJlnlPU4RoGxzWxb\n4oG/4nPDLWSMPFpJqJ8sbfBv7vYW5Zt9mDo1ZNRhOy6KVQoBZ4VkFfJB0dUH2j1/\ngi0ESH5u+Q/HtIg0g+FhClciQNpn2TcRNueI7rSDMvi7kCMxZIkEMbO/igmYTydb\nyeSJ3fvDohfUIJfk954Tr+gQm78mV0mqqXBpSg4GL6GfJbTCyIcL9rc8vc9vsX/d\nHJiev7+MHBT2wyTjeqOyvHKkDUoXfoFjTr5a2I3DpTRGQ9e28XJC7JT6EkPS/h8m\nQ39ENcnOWY4ki83T3wHNqYNjbelV1yS8cLFAccR5DuhIsXJC1MiTTWVqzjydNZE5\nhajP12C9Dkj/NkyX+M+kScJWPeqZNa3kVkyQCBL9C/SBrivPASS/c1yZg/nV8dLR\nLleFBnEeqtdaARdPbn3SG7B8r/7h6Oyg1VjSp8gTEap1cxvqzcoCDqq+AxkLf1I5\ndKnccxxEAWJd4B0DT9BY0s9OAlC+pwVr0DClIhMBqbiJgneWLbrVWFlffpJwoGke\n/lCqUGCWbvXgnX2P/pNJzgLXxz4AyUc31JDXOW4WPU/8a+zXQef95kyQ4v3FYkZw\nDpUKFMeCoTO7SbkDu4Zom32GVyqzdNkvYLCXXmcdA9Ct+2zAHBM=\n=WP+i\n-----END PGP SIGNATURE-----",
        "payload": "tree bea2cb635c9c189ba38fe62c59de5959429d96b0\nparent 240c6af170f980303404a2e5b0bd8a9a76c98231\nauthor Mark Friedenbach <mark@friedenbach.org> 1504126190 -0700\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550136 +0900\n\nReplace NOP4 with MERKLEBRANCHVERIFY, presently disabled.\n\n  [... leaf/H(leaf) ...] proof root {count,prehashed} MERKLEBRANCHVERIFY\n\nThis opcode takes a Merkle root, any number of leaf hashes of the tree, and a 'proof' object composed of an encoding of the path through the tree from root to leaves and the minimal set of hash values necessary to recompute the the root from the leaf. Script validation fails if the recomputed root does not match the hash provided (which, presumably, would be committed to in the scriptPubKey).\n\nOnly the logic and unit tests are implemented; this commit does not have any soft-fork activation logic in it.\n\nSee BIP116 for details.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19b7f05059dc5da5ba911d81fbea42bbe83bf940",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/19b7f05059dc5da5ba911d81fbea42bbe83bf940",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19b7f05059dc5da5ba911d81fbea42bbe83bf940/comments",
    "author": {
      "login": "maaku",
      "id": 69154,
      "node_id": "MDQ6VXNlcjY5MTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maaku",
      "html_url": "https://github.com/maaku",
      "followers_url": "https://api.github.com/users/maaku/followers",
      "following_url": "https://api.github.com/users/maaku/following{/other_user}",
      "gists_url": "https://api.github.com/users/maaku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maaku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maaku/subscriptions",
      "organizations_url": "https://api.github.com/users/maaku/orgs",
      "repos_url": "https://api.github.com/users/maaku/repos",
      "events_url": "https://api.github.com/users/maaku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maaku/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "240c6af170f980303404a2e5b0bd8a9a76c98231",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/240c6af170f980303404a2e5b0bd8a9a76c98231",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/240c6af170f980303404a2e5b0bd8a9a76c98231"
      }
    ],
    "stats": {
      "total": 238,
      "additions": 229,
      "deletions": 9
    },
    "files": [
      {
        "sha": "0ac38607ad1dbafb0b7aef2f5998b8a9363ec5a9",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -318,6 +318,7 @@ libbitcoin_consensus_a_SOURCES = \\\n   script/script_error.h \\\n   serialize.h \\\n   span.h \\\n+  support/cleanse.cpp \\\n   tinyformat.h \\\n   uint256.cpp \\\n   uint256.h \\"
      },
      {
        "sha": "44a121a77169ad0d18f22a2ed0c178b782297887",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 140,
        "deletions": 1,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -5,12 +5,15 @@\n \n #include <script/interpreter.h>\n \n+#include <primitives/transaction.h>\n+#include <consensus/merkle.h>\n #include <crypto/ripemd160.h>\n #include <crypto/sha1.h>\n #include <crypto/sha256.h>\n #include <pubkey.h>\n #include <script/script.h>\n #include <uint256.h>\n+#include <streams.h>\n \n typedef std::vector<unsigned char> valtype;\n \n@@ -453,7 +456,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     break;\n                 }\n \n-                case OP_NOP1: case OP_NOP4: case OP_NOP5:\n+                case OP_NOP1: case OP_NOP5:\n                 case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                 {\n                     if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n@@ -1052,6 +1055,142 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_MERKLEBRANCHVERIFY:\n+                {\n+                    if (!(flags & SCRIPT_VERIFY_MERKLEBRANCHVERIFY)) {\n+                        // not enabled; treat as a NOP4\n+                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n+                        }\n+                        break;\n+                    }\n+\n+                    // ([...verify hashes...] proof root {2*count+prehash})\n+                    if (stack.size() < 3) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    valtype& vchCount = stacktop(-1);\n+                    valtype& vchRoot  = stacktop(-2);\n+                    valtype& vchProof = stacktop(-3);\n+\n+                    // vchCount is a minimally encoded CScriptNum\n+                    // encoding 2*N plus a Boolean value in the low\n+                    // order bit encoding whether the leaf elements\n+                    // are pre-hashed.\n+                    bool prehashed = false;\n+                    std::size_t count = 0;\n+                    try {\n+                        // MAX_STACK_SIZE prevents count from ever\n+                        // being more than 997, which also means the\n+                        // first parameter can never be more than two\n+                        // bytes, when minimally serialized.\n+                        auto param = CScriptNum(vchCount, true, 2).getint();\n+                        if (param < 0) {\n+                            return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                        }\n+                        prehashed = param & 1;\n+                        count = param >> 1;\n+                    } catch (scriptnum_error e) {\n+                        // param is more than 2 bytes or not minimally encoded\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                    } catch (...) {\n+                        // Belt and suspenders. It should not be\n+                        // possible for other exceptions to be thrown,\n+                        // but in case that assessment is wrong or\n+                        // ever changes, let's not mask other\n+                        // exceptions.\n+                        throw;\n+                    }\n+\n+                    // There are count=N many leaf objects passed on\n+                    // the stack after the first three parameters\n+                    // which are always present.\n+                    if (stack.size() < (3 + count)) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    // vchRoot is a standard 32-byte hash. Note that\n+                    // this hash is pushed as data and not minimally\n+                    // encoded.\n+                    if (vchRoot.size() != 32) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG2);\n+                    }\n+                    const uint256 root = uint256(vchRoot);\n+\n+                    // The third argument is a MerkleProof, which we\n+                    // deserialize as part of the MerkleTree structure\n+                    // we are building to validate the entire root.\n+                    MerkleTree branch;\n+                    CDataStream proofStream(vchProof, SER_NETWORK, PROTOCOL_VERSION);\n+                    try {\n+                        Unserialize(proofStream, branch.m_proof);\n+                    } catch (const std::bad_alloc e) {\n+                        throw; // Don't mask a transient out-of-memory exception\n+                    } catch (...) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (!proofStream.empty()) {\n+                        // Extra bytes remaining after the MerkleProof\n+                        // was deserialized, which could be a source\n+                        // of witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (branch.m_proof.m_path.dirty()) {\n+                        // Extra bits in the final byte of the packed\n+                        // serialization of the Merkle branch's path,\n+                        // which would otherwise be another source of\n+                        // witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if ((!branch.m_proof.m_path.empty() || count || !branch.m_proof.m_skip.empty()) &&\n+                        ((count + branch.m_proof.m_skip.size()) != (branch.m_proof.m_path.size() + 1)))\n+                    {\n+                        // It is a property of any binary tree that\n+                        // the number of leaf nodes is precisely one\n+                        // more than the number of internal nodes.\n+                        // This acts as an early-out check of whether\n+                        // this is a well-formed proof. Note that the\n+                        // special case of a 0-node, 0-verify, 0-skip\n+                        // tree is exempted from this requirement.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+\n+                    // The remaining _count_ items on the stack are\n+                    // the verify hashes, or the actual leaf values\n+                    // which are hashed with double-SHA256 to get the\n+                    // verify hashes if _prehashed_ is clear.\n+                    branch.m_verify.reserve(count);\n+                    for (int i = 0; i < (int)count; ++i) {\n+                        // -1 through -3 are the count+prehashed, root\n+                        // hash, and MerkleProof we already extracted.\n+                        valtype& vchLeaf = stacktop(-4 - i);\n+                        if (prehashed) {\n+                            // Require 32-byte hash values, no\n+                            // truncation of ending bytes.\n+                            if (vchLeaf.size() != 32) {\n+                                return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG);\n+                            }\n+                            branch.m_verify.emplace_back(uint256(vchLeaf));\n+                        } else {\n+                            branch.m_verify.emplace_back();\n+                            CHash256().Write(vchLeaf.data(), vchLeaf.size()).Finalize(branch.m_verify.back().begin());\n+                        }\n+                    }\n+\n+                    // Compute Merkle root hash\n+                    uint256 result = branch.GetHash();\n+\n+                    // Do not pop arguments from the stack as we\n+                    // retain soft- fork compatibility. Scripts must\n+                    // use [2DROP 2DROP ... DROP] themselves to remove\n+                    // the arguments from the stack, if necessary.\n+                    if (result != root) {\n+                        return set_error(serror, SCRIPT_ERR_MERKLEBRANCHVERIFY);\n+                    }\n+                }\n+                break;\n+\n                 default:\n                     return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n             }"
      },
      {
        "sha": "cd59dadcc0595388ce98c53fbe79e1d9b5ba549b",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -111,6 +111,11 @@ enum\n     // Public keys in segregated witness scripts must be compressed\n     //\n     SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1U << 15),\n+\n+    // Support MERKLEBRANCHVERIFY\n+    //\n+    // See BIP116 for details\n+    SCRIPT_VERIFY_MERKLEBRANCHVERIFY = (1U << 16),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "a933fd96f046989b6b19ddf634eeb037ad537150",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -131,7 +131,7 @@ const char* GetOpName(opcodetype opcode)\n     case OP_NOP1                   : return \"OP_NOP1\";\n     case OP_CHECKLOCKTIMEVERIFY    : return \"OP_CHECKLOCKTIMEVERIFY\";\n     case OP_CHECKSEQUENCEVERIFY    : return \"OP_CHECKSEQUENCEVERIFY\";\n-    case OP_NOP4                   : return \"OP_NOP4\";\n+    case OP_MERKLEBRANCHVERIFY     : return \"OP_MERKLEBRANCHVERIFY\";\n     case OP_NOP5                   : return \"OP_NOP5\";\n     case OP_NOP6                   : return \"OP_NOP6\";\n     case OP_NOP7                   : return \"OP_NOP7\";"
      },
      {
        "sha": "81033846d3c67902d5e286507e772eae2d0db2d9",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -173,7 +173,8 @@ enum opcodetype\n     OP_NOP2 = OP_CHECKLOCKTIMEVERIFY,\n     OP_CHECKSEQUENCEVERIFY = 0xb2,\n     OP_NOP3 = OP_CHECKSEQUENCEVERIFY,\n-    OP_NOP4 = 0xb3,\n+    OP_MERKLEBRANCHVERIFY = 0xb3,\n+    OP_NOP4 = OP_MERKLEBRANCHVERIFY,\n     OP_NOP5 = 0xb4,\n     OP_NOP6 = 0xb5,\n     OP_NOP7 = 0xb6,"
      },
      {
        "sha": "3b4c736922549c0507d17af4f5798f9591afa654",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -23,6 +23,8 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Script failed an OP_CHECKSIGVERIFY operation\";\n         case SCRIPT_ERR_NUMEQUALVERIFY:\n             return \"Script failed an OP_NUMEQUALVERIFY operation\";\n+        case SCRIPT_ERR_MERKLEBRANCHVERIFY:\n+            return \"Script failed an OP_MERKLEBRANCHVERIFY operation\";\n         case SCRIPT_ERR_SCRIPT_SIZE:\n             return \"Script is too big\";\n         case SCRIPT_ERR_PUSH_SIZE:\n@@ -43,6 +45,14 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Operation not valid with the current stack size\";\n         case SCRIPT_ERR_INVALID_ALTSTACK_OPERATION:\n             return \"Operation not valid with the current altstack size\";\n+        case SCRIPT_ERR_BAD_DECODE_ARG:\n+            return \"Failed to decode stack item for current opcode\";\n+        case SCRIPT_ERR_BAD_DECODE_ARG1:\n+            return \"Failed to decode top stack item for current opcode\";\n+        case SCRIPT_ERR_BAD_DECODE_ARG2:\n+            return \"Failed to decode 2nd stack item for current opcode\";\n+        case SCRIPT_ERR_BAD_DECODE_ARG3:\n+            return \"Failed to decode 3rd stack item for current opcode\";\n         case SCRIPT_ERR_OP_RETURN:\n             return \"OP_RETURN was encountered\";\n         case SCRIPT_ERR_UNBALANCED_CONDITIONAL:"
      },
      {
        "sha": "92931671cdff66b88b9fbdc8de669b579307ad80",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -27,13 +27,18 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_CHECKMULTISIGVERIFY,\n     SCRIPT_ERR_CHECKSIGVERIFY,\n     SCRIPT_ERR_NUMEQUALVERIFY,\n+    SCRIPT_ERR_MERKLEBRANCHVERIFY,\n \n     /* Logical/Format/Canonical errors */\n     SCRIPT_ERR_BAD_OPCODE,\n     SCRIPT_ERR_DISABLED_OPCODE,\n     SCRIPT_ERR_INVALID_STACK_OPERATION,\n     SCRIPT_ERR_INVALID_ALTSTACK_OPERATION,\n     SCRIPT_ERR_UNBALANCED_CONDITIONAL,\n+    SCRIPT_ERR_BAD_DECODE_ARG,\n+    SCRIPT_ERR_BAD_DECODE_ARG1,\n+    SCRIPT_ERR_BAD_DECODE_ARG2,\n+    SCRIPT_ERR_BAD_DECODE_ARG3,\n \n     /* CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY */\n     SCRIPT_ERR_NEGATIVE_LOCKTIME,"
      },
      {
        "sha": "e28f5c3e063e2f2a9328ca2caa9f541455791ec3",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 59,
        "deletions": 6,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -244,8 +244,8 @@\n [\"'abcdefghijklmnopqrstuvwxyz'\", \"HASH256 0x4c 0x20 0xca139bc10c2f660da42666f72e89a225936fc60f193c161124a672050c434671 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n \n \n-[\"1\",\"NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY NOP4 NOP5 NOP6 NOP7 NOP8 NOP9 NOP10 1 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n-[\"'NOP_1_to_10' NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY NOP4 NOP5 NOP6 NOP7 NOP8 NOP9 NOP10\",\"'NOP_1_to_10' EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n+[\"1\",\"NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY MERKLEBRANCHVERIFY NOP5 NOP6 NOP7 NOP8 NOP9 NOP10 1 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n+[\"'NOP_1_to_10' NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY MERKLEBRANCHVERIFY NOP5 NOP6 NOP7 NOP8 NOP9 NOP10\",\"'NOP_1_to_10' EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n \n [\"1\", \"NOP\", \"P2SH,STRICTENC,DISCOURAGE_UPGRADABLE_NOPS\", \"OK\", \"Discourage NOPx flag allows OP_NOP\"],\n \n@@ -456,7 +456,7 @@\n [\"NOP\", \"NOP1 1\", \"P2SH,STRICTENC\", \"OK\"],\n [\"NOP\", \"CHECKLOCKTIMEVERIFY 1\", \"P2SH,STRICTENC\", \"OK\"],\n [\"NOP\", \"CHECKSEQUENCEVERIFY 1\", \"P2SH,STRICTENC\", \"OK\"],\n-[\"NOP\", \"NOP4 1\", \"P2SH,STRICTENC\", \"OK\"],\n+[\"NOP\", \"MERKLEBRANCHVERIFY 1\", \"P2SH,STRICTENC\", \"OK\"],\n [\"NOP\", \"NOP5 1\", \"P2SH,STRICTENC\", \"OK\"],\n [\"NOP\", \"NOP6 1\", \"P2SH,STRICTENC\", \"OK\"],\n [\"NOP\", \"NOP7 1\", \"P2SH,STRICTENC\", \"OK\"],\n@@ -869,12 +869,11 @@\n [\"2 2 LSHIFT\", \"8 EQUAL\", \"P2SH,STRICTENC\", \"DISABLED_OPCODE\", \"disabled\"],\n [\"2 1 RSHIFT\", \"1 EQUAL\", \"P2SH,STRICTENC\", \"DISABLED_OPCODE\", \"disabled\"],\n \n-[\"1\", \"NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY NOP4 NOP5 NOP6 NOP7 NOP8 NOP9 NOP10 2 EQUAL\", \"P2SH,STRICTENC\", \"EVAL_FALSE\"],\n-[\"'NOP_1_to_10' NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY NOP4 NOP5 NOP6 NOP7 NOP8 NOP9 NOP10\",\"'NOP_1_to_11' EQUAL\", \"P2SH,STRICTENC\", \"EVAL_FALSE\"],\n+[\"1\", \"NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY MERKLEBRANCHVERIFY NOP5 NOP6 NOP7 NOP8 NOP9 NOP10 2 EQUAL\", \"P2SH,STRICTENC\", \"EVAL_FALSE\"],\n+[\"'NOP_1_to_10' NOP1 CHECKLOCKTIMEVERIFY CHECKSEQUENCEVERIFY MERKLEBRANCHVERIFY NOP5 NOP6 NOP7 NOP8 NOP9 NOP10\",\"'NOP_1_to_11' EQUAL\", \"P2SH,STRICTENC\", \"EVAL_FALSE\"],\n \n [\"Ensure 100% coverage of discouraged NOPS\"],\n [\"1\", \"NOP1\",  \"P2SH,DISCOURAGE_UPGRADABLE_NOPS\", \"DISCOURAGE_UPGRADABLE_NOPS\"],\n-[\"1\", \"NOP4\",  \"P2SH,DISCOURAGE_UPGRADABLE_NOPS\", \"DISCOURAGE_UPGRADABLE_NOPS\"],\n [\"1\", \"NOP5\",  \"P2SH,DISCOURAGE_UPGRADABLE_NOPS\", \"DISCOURAGE_UPGRADABLE_NOPS\"],\n [\"1\", \"NOP6\",  \"P2SH,DISCOURAGE_UPGRADABLE_NOPS\", \"DISCOURAGE_UPGRADABLE_NOPS\"],\n [\"1\", \"NOP7\",  \"P2SH,DISCOURAGE_UPGRADABLE_NOPS\", \"DISCOURAGE_UPGRADABLE_NOPS\"],\n@@ -2615,5 +2614,59 @@\n [\"0 0x09 0x300602010102010101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG\", \"OK\", \"BIP66-compliant but not NULLFAIL-compliant\"],\n [\"0 0x09 0x300602010102010101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG,NULLFAIL\", \"NULLFAIL\", \"BIP66-compliant but not NULLFAIL-compliant\"],\n \n+[\"\", \"MERKLEBRANCHVERIFY 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Missing args 1,2,3\"],\n+[\"\", \"0 MERKLEBRANCHVERIFY DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Missing args 2,3\"],\n+[\"\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 0 MERKLEBRANCHVERIFY 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Missing arg 3\"],\n+\n+[\"0x020000\", \"0x205df6e0e2761359d30a8275058e299fcc0381534545f55cf43e41983f5d4c9456 0 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Empty tree is hash of empty string\"],\n+[\"0x020000\", \"0x200000000000000000000000000000000000000000000000000000000000000000 0 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"MERKLEBRANCHVERIFY\", \"Empty tree is hash of empty string\"],\n+\n+[\"0x220001a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 0 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check none of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x220001a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 1 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check none of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x020000\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Check root of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 0x020000\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check root of sha256('a') || sha256('b') || sha256('c')\"],\n+\n+[\"0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Missing verify hash(s)\"],\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check left branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x20bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d8 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check left branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0162 0x43027802bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d86632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check middle branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x2039361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9 0x43027802bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d86632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check middle branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0163 0x2301c001cdd1bdae54f992ac8fd37711a5eee2f3ec02a1046efc7f8d348d5765031471c7\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check right branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x206632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3 0x2301c001cdd1bdae54f992ac8fd37711a5eee2f3ec02a1046efc7f8d348d5765031471c7\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check right branch of sha256('a') || sha256('b') || sha256('c')\"],\n+\n+[\"0x230264016632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 4 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Check left and middle branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0161 0x230264016632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 4 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Check left and middle branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0162 0x0161 0x230264016632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 4 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check left and middle branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x2039361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9 0x20bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d8 0x230264016632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 5 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check left and middle branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0163 0x0161 0x2302800139361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 4 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check left and right branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x206632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3 0x20bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d8 0x2302800139361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 5 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check left and right branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0163 0x0162 0x23029801bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d8\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 4 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check middle and right branch of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x206632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3 0x2039361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9 0x23029801bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d8\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 5 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check middle and right branch of sha256('a') || sha256('b') || sha256('c')\"],\n+\n+[\"0x03028400\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 6 MERKLEBRANCHVERIFY 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Check all branches of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0161 0x03028400\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 6 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Check all branches of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0162 0x0161 0x03028400\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 6 MERKLEBRANCHVERIFY 2DROP 2DROP DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Check all branches of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x0163 0x0162 0x0161 0x03028400\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 6 MERKLEBRANCHVERIFY 2DROP 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check all branches of sha256('a') || sha256('b') || sha256('c')\"],\n+[\"0x206632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3 0x2039361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9 0x20bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d8 0x03028400\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 7 MERKLEBRANCHVERIFY 2DROP 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"OK\", \"Check all branches of sha256('a') || sha256('b') || sha256('c')\"],\n+\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 32768 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG1\", \"Count more than 15 bits\"],\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 0x020200 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG1\", \"Non-minimally encoded count\"],\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c -2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG1\", \"Count negative\"],\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 32767 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"INVALID_STACK_OPERATION\", \"Count larger than stack\"],\n+\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x1fa1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG2\", \"Root too short for a hash\"],\n+[\"0x0161 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x21a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c00 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG2\", \"Root too long for a hash\"],\n+\n+[\"0x0161 0x4202600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG3\", \"Early termination of Merkle proof\"],\n+[\"0x0161 0x4402600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d300\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG3\", \"Excess bytes after Merkle proof\"],\n+[\"0x0161 0x4302620239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG3\", \"Residual dirty bits set in Merkle proof\"],\n+[\"0x0161 0x2302600139361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db9\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG3\", \"Not enough skip hashes\"],\n+[\"0x0161 0x4c6302600339361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d300112233445566778899aabbccddeeff00112233445566778899aabbccddeeff\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 2 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG3\", \"Too many skip hashes\"],\n+[\"0x1fbf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG\", \"Verify hash too short\"],\n+[\"0x21bf5d3affb73efd2ec6c36ad3112dd933efed63c4e1cbffcfa88e2759c144f2d800 0x4302600239361160903c6695c6804b7157c7bd10013e9ba89b1f954243bc8e3990b08db96632753d6ca30fea890f37fc150eaed8d068acf596acb2251b8fafd72db977d3\", \"0x20a1916de4d3bb548c9c44fd117f0ebca306e5c0d0916ec8c9aa2b2952d71ade9c 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"BAD_DECODE_ARG\", \"Verify hash too long\"],\n+\n+[\"0x20ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 0x020000\", \"0x20fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"MERKLEBRANCHVERIFY\", \"calculated and expected root don't match\"],\n+[\"0x20fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe 0x020000\", \"0x20ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 3 MERKLEBRANCHVERIFY 2DROP 2DROP 1\", \"MERKLEBRANCHVERIFY\", \"MERKLEBRANCHVERIFY\", \"calculated and expected root don't match\"],\n+\n [\"The End\"]\n ]"
      },
      {
        "sha": "cc3eb63589d11a7dd398d5248ec14a7a1a76729c",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -71,11 +71,16 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_CHECKMULTISIGVERIFY, \"CHECKMULTISIGVERIFY\"},\n     {SCRIPT_ERR_CHECKSIGVERIFY, \"CHECKSIGVERIFY\"},\n     {SCRIPT_ERR_NUMEQUALVERIFY, \"NUMEQUALVERIFY\"},\n+    {SCRIPT_ERR_MERKLEBRANCHVERIFY, \"MERKLEBRANCHVERIFY\"},\n     {SCRIPT_ERR_BAD_OPCODE, \"BAD_OPCODE\"},\n     {SCRIPT_ERR_DISABLED_OPCODE, \"DISABLED_OPCODE\"},\n     {SCRIPT_ERR_INVALID_STACK_OPERATION, \"INVALID_STACK_OPERATION\"},\n     {SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, \"INVALID_ALTSTACK_OPERATION\"},\n     {SCRIPT_ERR_UNBALANCED_CONDITIONAL, \"UNBALANCED_CONDITIONAL\"},\n+    {SCRIPT_ERR_BAD_DECODE_ARG, \"BAD_DECODE_ARG\"},\n+    {SCRIPT_ERR_BAD_DECODE_ARG1, \"BAD_DECODE_ARG1\"},\n+    {SCRIPT_ERR_BAD_DECODE_ARG2, \"BAD_DECODE_ARG2\"},\n+    {SCRIPT_ERR_BAD_DECODE_ARG3, \"BAD_DECODE_ARG3\"},\n     {SCRIPT_ERR_NEGATIVE_LOCKTIME, \"NEGATIVE_LOCKTIME\"},\n     {SCRIPT_ERR_UNSATISFIED_LOCKTIME, \"UNSATISFIED_LOCKTIME\"},\n     {SCRIPT_ERR_SIG_HASHTYPE, \"SIG_HASHTYPE\"},"
      },
      {
        "sha": "9bf47a80c0896ee9afc05f926eb934129517537c",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19b7f05059dc5da5ba911d81fbea42bbe83bf940/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "patch": "@@ -53,6 +53,7 @@ static std::map<std::string, unsigned int> mapFlagNames = {\n     {std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS},\n     {std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},\n     {std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},\n+    {std::string(\"MERKLEBRANCHVERIFY\"), (unsigned int)SCRIPT_VERIFY_MERKLEBRANCHVERIFY},\n };\n \n unsigned int ParseScriptFlags(std::string strFlags)"
      }
    ]
  },
  {
    "sha": "7e3fdbeff66744431e713138e8b9f73211589b70",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZTNmZGJlZmY2Njc0NDQzMWU3MTMxMzhlOGI5ZjczMjExNTg5Yjcw",
    "commit": {
      "author": {
        "name": "Mark Friedenbach",
        "email": "mark@friedenbach.org",
        "date": "2017-08-30T21:00:13Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:08:57Z"
      },
      "message": "Enable MERKLEBRANCHVERIFY as a standard script verification flag. Transactions that fail MBV verification will be rejected from the mempool, making it easier to test and to later soft-fork activate this feature. Blocks which contain \"invalid\" MBV-using transactions will still be accepted; this is *not* the soft-fork required to use MBV in production.",
      "tree": {
        "sha": "9ed6b99b240c2a0d923a392a5656ea21d6386572",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9ed6b99b240c2a0d923a392a5656ea21d6386572"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e3fdbeff66744431e713138e8b9f73211589b70",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyfkACgkQV692LbM1\nMyKlEg/+Kk4O7Qqj+Su2D/jIxZS1Hxc+xvQawVsjuia4cFNWsXgInaGR3RPeqMm5\nzDZCL3AHO7MP3hmtTyArJGfbdBmbKM93qh+B6u7XNnJZSUQc82wYtIYw7EpBOmIf\nw0LKUarqnFLhwgv0Q5hmUarkSzn9Bi/8OL6iPOnDJz6iK/3CwMJ2+lPeqB4f/tSu\n5UK0es899MMRqSZuka4GH1v0q/eq0+wail+zSm5HUAXjYfDSSME3ipXHAt+o7oUC\nRoNtwRDpNvB9JY3PA6RuxoJFfnQ9VwThtGNDq/TIrNIySjZ358m6WkB46ssCmGeU\n1yYGMtWlB1p9RgSCx6VaFXqZr6a+1IeM1VnMSGXYGUiMHmzGNkj5p7qzTnggEIrN\nSSEu6OrZYjY9b/3+Les5+Xgybum9XJlUEChlTKU/nIBGk3zWC2ywnPaPDUb83sBl\nUb0c8UAMbpvkthsEYu+07uteXS5eoVujuuKBGnm95X1jYXy1PiualpnyckwGdAEO\nvDfQrAWvuZ+f2TP2lF7pQVmR+YW9Pe9IFnXy6vdpCqrC8goywVs365OMJlJ27rN6\nSwusuZi+tt1fUoo1WvGBKZTWNce648FF4w2VG9EUDEIgpl7TQdPmamMCYrgwanFn\nTAJtK7BHv8NupEsFWTyOQg0MPQbDkSgrwJt22s0tbJfvK/qYVIY=\n=B0nj\n-----END PGP SIGNATURE-----",
        "payload": "tree 9ed6b99b240c2a0d923a392a5656ea21d6386572\nparent 19b7f05059dc5da5ba911d81fbea42bbe83bf940\nauthor Mark Friedenbach <mark@friedenbach.org> 1504126813 -0700\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550137 +0900\n\nEnable MERKLEBRANCHVERIFY as a standard script verification flag. Transactions that fail MBV verification will be rejected from the mempool, making it easier to test and to later soft-fork activate this feature. Blocks which contain \"invalid\" MBV-using transactions will still be accepted; this is *not* the soft-fork required to use MBV in production.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e3fdbeff66744431e713138e8b9f73211589b70",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e3fdbeff66744431e713138e8b9f73211589b70",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e3fdbeff66744431e713138e8b9f73211589b70/comments",
    "author": {
      "login": "maaku",
      "id": 69154,
      "node_id": "MDQ6VXNlcjY5MTU0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maaku",
      "html_url": "https://github.com/maaku",
      "followers_url": "https://api.github.com/users/maaku/followers",
      "following_url": "https://api.github.com/users/maaku/following{/other_user}",
      "gists_url": "https://api.github.com/users/maaku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maaku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maaku/subscriptions",
      "organizations_url": "https://api.github.com/users/maaku/orgs",
      "repos_url": "https://api.github.com/users/maaku/repos",
      "events_url": "https://api.github.com/users/maaku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maaku/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19b7f05059dc5da5ba911d81fbea42bbe83bf940",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/19b7f05059dc5da5ba911d81fbea42bbe83bf940"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "dbea94cd49c21f8de42a4b543dff4d0dd8d50810",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e3fdbeff66744431e713138e8b9f73211589b70/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e3fdbeff66744431e713138e8b9f73211589b70/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=7e3fdbeff66744431e713138e8b9f73211589b70",
        "patch": "@@ -63,7 +63,8 @@ static constexpr unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VE\n                                                              SCRIPT_VERIFY_LOW_S |\n                                                              SCRIPT_VERIFY_WITNESS |\n                                                              SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\n-                                                             SCRIPT_VERIFY_WITNESS_PUBKEYTYPE;\n+                                                             SCRIPT_VERIFY_WITNESS_PUBKEYTYPE |\n+                                                             SCRIPT_VERIFY_MERKLEBRANCHVERIFY;\n \n /** For convenience, standard but not mandatory verify flags. */\n static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;"
      }
    ]
  },
  {
    "sha": "108f4d1d677e743428e1340b2f4245662d5a8e01",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDhmNGQxZDY3N2U3NDM0MjhlMTM0MGIyZjQyNDU2NjJkNWE4ZTAx",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-03-23T05:02:14Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:08:57Z"
      },
      "message": "f'src/consensus/merkle.h: inline Get/SetRight",
      "tree": {
        "sha": "492de8d70bfd75c8cbc8448bd65873035cbff324",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/492de8d70bfd75c8cbc8448bd65873035cbff324"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/108f4d1d677e743428e1340b2f4245662d5a8e01",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyfkACgkQV692LbM1\nMyJk1A/9Ej3hIWYTjzt2fXyAaeq4TGIO4pd8bY+VozOcwxqFAvwY7WNmX4uX/l0z\nJQ5MaBNM5E6xnFMXM3HTzH3H9nTQyxP19qlqj3yY/2avviiaysOtnY7GUBj9ishQ\nCc7jF/IBWvRLlSurRnIhfxJmB9BRUfHiknN3EYfSSqx5qR2fFUz49To+dKrfp94K\nxLQrzG4vZkxmpP4WUhdGz7BVCnEzaJOfY68YYBR5HbTeaHz3EK1HXVQsyE6s/3Vi\nrJpMLAKk7H+ACCMf+FBr7BqHwR0yj/2zarNyl2d3zq3jEcPqlneStvrZ3rTfyLFF\nkdQ8P4DYnUgyg8uzt7XTWn859GNdv79waLaS2jQ8c8KjXcJjtmSTP04NpmaFKFio\niLOp1d+By+fHt+qwQGdej1MCk1m/1Lrz/uvZuUW06IvPyk98lBwyVyWy9+0J4Too\nKa9nh+L8+HadzPsTeGZVXMq1ByhrPYWZv15PixuaGPpkWYpwwvtwY9BppeteULZz\nh55wYItJAyjCJvx/NB6vl/BnYEulv8rI9IcgLoxR7Pa8ZlxjQ26f/ogfxZPDefo6\nkJlk8lMHHLGwTmXcxnEju8iPiKekgra7X8Ww97Bi1o1MsKPNeMHKTJKca30p7Otb\nI4u470EzlBwI46bhCfSn0zsEA2Ee7b7cKTsks+frJ5O7ArYK39Y=\n=6e4D\n-----END PGP SIGNATURE-----",
        "payload": "tree 492de8d70bfd75c8cbc8448bd65873035cbff324\nparent 7e3fdbeff66744431e713138e8b9f73211589b70\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1521781334 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550137 +0900\n\nf'src/consensus/merkle.h: inline Get/SetRight\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/108f4d1d677e743428e1340b2f4245662d5a8e01",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/108f4d1d677e743428e1340b2f4245662d5a8e01",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/108f4d1d677e743428e1340b2f4245662d5a8e01/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7e3fdbeff66744431e713138e8b9f73211589b70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e3fdbeff66744431e713138e8b9f73211589b70",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7e3fdbeff66744431e713138e8b9f73211589b70"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "fb1e500a2351bc53e84b199d4d567e2ffbcede03",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/108f4d1d677e743428e1340b2f4245662d5a8e01/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/108f4d1d677e743428e1340b2f4245662d5a8e01/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=108f4d1d677e743428e1340b2f4245662d5a8e01",
        "patch": "@@ -303,9 +303,9 @@ struct MerkleNodeReference\n     inline MerkleNodeReference& SetLeft(MerkleLink left)\n       { return SetCode(MerkleNode::_get_code(left, GetRight())); }\n \n-    MerkleLink GetRight() const\n+    inline MerkleLink GetRight() const\n       { return MerkleNode::m_right_from_code[GetCode()]; }\n-    MerkleNodeReference& SetRight(MerkleLink right)\n+    inline MerkleNodeReference& SetRight(MerkleLink right)\n       { return SetCode(MerkleNode::_get_code(GetLeft(), right)); }\n \n     /* Equality */"
      }
    ]
  },
  {
    "sha": "e5e56bc8b41b1ef7812bb44de51b2a3276a428e3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNWU1NmJjOGI0MWIxZWY3ODEyYmI0NGRlNTFiMmEzMjc2YTQyOGUz",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-03-23T05:19:22Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2018-04-24T06:08:57Z"
      },
      "message": "f'src/script/interpreter.cpp: check invalid flag in branch.GetHash() and throw SCRIPT_ERR_BAD_DECODE_ARG if true",
      "tree": {
        "sha": "cfa54a7601cb72becd93eac91d6520d70421147c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cfa54a7601cb72becd93eac91d6520d70421147c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5e56bc8b41b1ef7812bb44de51b2a3276a428e3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAlreyfkACgkQV692LbM1\nMyLm1A/+KGyK7uy+/frc+ELKqIqSwWndHrcB2fk5020gzGTp+uALu4N51dye1xlV\nyoCvdZHMznIHJr0G81X8XX/pLJ+PXPo2KdKemhqBjLf54Oi1/bn9cRach/Ff5J2f\n5ldFGPWI6nVYnGQS9GZULxNjH+DTlsVI7+S048xHWwBp1vCXKvl6PQyt0Ff6zTJA\nL8oMsO6hlG+eMcYe/BUPUamoMtskQ2GxLLQmVIzvwu5yBnj9huHkK7kwjYBycIYk\npyy3wCU6BI9ZMqUSi4AiyBUZwvUBPD0Uq7CjShvndm07pSaiM6stJJyj0BWKflRl\nF8NhgkHWSb/6fA4EWq+aWME+NllN1KLm5icp7zzAf1BtEeQk/ESSxm6iK0bwuFRe\nB/eCwEkkuy+c0RaqgpsCkjq1aFttanGLXxoZStmccfWb1FL1cpLbgXpTib6fHwxj\nAAJaRCnQgm4QjZbwrYzDjJDs3jcM+sL63ey3Z9E7oBh6JlRaW15vwQihti9EYosu\nZqSLQFaxigZOGw9Y1Cbt52nwetCKF3IWoOa1KrW6k0K9jmPKzq3H5hgtkuxfXc78\nLa7MbwKGDzw3F9SDgn0on5vEohB4xh5bNh/uFWDx9BUibpiAwEjnNYiT8Q0dyUJD\nHB0XWOBOUnoM4nHSQEewi8LOQAfOQrxYxW4pW9Yv3mO/nMoha4Q=\n=R+Qw\n-----END PGP SIGNATURE-----",
        "payload": "tree cfa54a7601cb72becd93eac91d6520d70421147c\nparent 108f4d1d677e743428e1340b2f4245662d5a8e01\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1521782362 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1524550137 +0900\n\nf'src/script/interpreter.cpp: check invalid flag in branch.GetHash() and throw SCRIPT_ERR_BAD_DECODE_ARG if true\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5e56bc8b41b1ef7812bb44de51b2a3276a428e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e5e56bc8b41b1ef7812bb44de51b2a3276a428e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5e56bc8b41b1ef7812bb44de51b2a3276a428e3/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "108f4d1d677e743428e1340b2f4245662d5a8e01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/108f4d1d677e743428e1340b2f4245662d5a8e01",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/108f4d1d677e743428e1340b2f4245662d5a8e01"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 5,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a94d3fe02f07feb6480420c14796a7e534a8da56",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5e56bc8b41b1ef7812bb44de51b2a3276a428e3/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5e56bc8b41b1ef7812bb44de51b2a3276a428e3/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=e5e56bc8b41b1ef7812bb44de51b2a3276a428e3",
        "patch": "@@ -1179,7 +1179,11 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     }\n \n                     // Compute Merkle root hash\n-                    uint256 result = branch.GetHash();\n+                    bool invalid;\n+                    uint256 result = branch.GetHash(&invalid);\n+                    if (invalid) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG);\n+                    }\n \n                     // Do not pop arguments from the stack as we\n                     // retain soft- fork compatibility. Scripts must"
      }
    ]
  }
]