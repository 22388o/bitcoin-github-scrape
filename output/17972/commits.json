[
  {
    "sha": "f4691b6c217ab843e6e66fa0ad34d83137499a89",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDY5MWI2YzIxN2FiODQzZTZlNjZmYTBhZDM0ZDgzMTM3NDk5YTg5",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-01-21T12:22:55Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-03-05T21:11:10Z"
      },
      "message": "tests: Add fuzzing harness for CKey related functions",
      "tree": {
        "sha": "229173c4f626bdcf8285413709bf575f2652ab13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/229173c4f626bdcf8285413709bf575f2652ab13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4691b6c217ab843e6e66fa0ad34d83137499a89",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4691b6c217ab843e6e66fa0ad34d83137499a89",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f4691b6c217ab843e6e66fa0ad34d83137499a89",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4691b6c217ab843e6e66fa0ad34d83137499a89/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "631df3ee87ec93e1fc748715671cdb5cff7308e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/631df3ee87ec93e1fc748715671cdb5cff7308e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/631df3ee87ec93e1fc748715671cdb5cff7308e6"
      }
    ],
    "stats": {
      "total": 317,
      "additions": 317,
      "deletions": 0
    },
    "files": [
      {
        "sha": "67cb490989b2046312964377c30aec4ae4e06583",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4691b6c217ab843e6e66fa0ad34d83137499a89/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4691b6c217ab843e6e66fa0ad34d83137499a89/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=f4691b6c217ab843e6e66fa0ad34d83137499a89",
        "patch": "@@ -32,6 +32,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/hex \\\n   test/fuzz/integer \\\n   test/fuzz/inv_deserialize \\\n+  test/fuzz/key \\\n   test/fuzz/key_origin_info_deserialize \\\n   test/fuzz/merkle_block_deserialize \\\n   test/fuzz/messageheader_deserialize \\\n@@ -403,6 +404,12 @@ test_fuzz_inv_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_inv_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_inv_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n \n+test_fuzz_key_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_key_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_key_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_key_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_key_SOURCES = $(FUZZ_SUITE) test/fuzz/key.cpp\n+\n test_fuzz_key_origin_info_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DKEY_ORIGIN_INFO_DESERIALIZE=1\n test_fuzz_key_origin_info_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_key_origin_info_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)"
      },
      {
        "sha": "1919a5f881f6148e67844edd6bede9c3e5cf050c",
        "filename": "src/test/fuzz/key.cpp",
        "status": "added",
        "additions": 309,
        "deletions": 0,
        "changes": 309,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4691b6c217ab843e6e66fa0ad34d83137499a89/src/test/fuzz/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4691b6c217ab843e6e66fa0ad34d83137499a89/src/test/fuzz/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/key.cpp?ref=f4691b6c217ab843e6e66fa0ad34d83137499a89",
        "patch": "@@ -0,0 +1,309 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <key_io.h>\n+#include <outputtype.h>\n+#include <policy/policy.h>\n+#include <pubkey.h>\n+#include <rpc/util.h>\n+#include <script/keyorigin.h>\n+#include <script/script.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <numeric>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    const CKey key = [&] {\n+        CKey k;\n+        k.Set(buffer.begin(), buffer.end(), true);\n+        return k;\n+    }();\n+    if (!key.IsValid()) {\n+        return;\n+    }\n+\n+    {\n+        assert(key.begin() + key.size() == key.end());\n+        assert(key.IsCompressed());\n+        assert(key.size() == 32);\n+        assert(DecodeSecret(EncodeSecret(key)) == key);\n+    }\n+\n+    {\n+        CKey invalid_key;\n+        assert(!(invalid_key == key));\n+        assert(!invalid_key.IsCompressed());\n+        assert(!invalid_key.IsValid());\n+        assert(invalid_key.size() == 0);\n+    }\n+\n+    {\n+        CKey uncompressed_key;\n+        uncompressed_key.Set(buffer.begin(), buffer.end(), false);\n+        assert(!(uncompressed_key == key));\n+        assert(!uncompressed_key.IsCompressed());\n+        assert(key.size() == 32);\n+        assert(uncompressed_key.begin() + uncompressed_key.size() == uncompressed_key.end());\n+        assert(uncompressed_key.IsValid());\n+    }\n+\n+    {\n+        CKey copied_key;\n+        copied_key.Set(key.begin(), key.end(), key.IsCompressed());\n+        assert(copied_key == key);\n+    }\n+\n+    {\n+        CKey negated_key = key;\n+        negated_key.Negate();\n+        assert(negated_key.IsValid());\n+        assert(!(negated_key == key));\n+\n+        negated_key.Negate();\n+        assert(negated_key == key);\n+    }\n+\n+    const uint256 random_uint256 = Hash(buffer.begin(), buffer.end());\n+\n+    {\n+        CKey child_key;\n+        ChainCode child_chaincode;\n+        const bool ok = key.Derive(child_key, child_chaincode, 0, random_uint256);\n+        assert(ok);\n+        assert(child_key.IsValid());\n+        assert(!(child_key == key));\n+        assert(child_chaincode != random_uint256);\n+    }\n+\n+    const CPubKey pubkey = key.GetPubKey();\n+\n+    {\n+        assert(pubkey.size() == 33);\n+        assert(key.VerifyPubKey(pubkey));\n+        assert(pubkey.GetHash() != random_uint256);\n+        assert(pubkey.begin() + pubkey.size() == pubkey.end());\n+        assert(pubkey.data() == pubkey.begin());\n+        assert(pubkey.IsCompressed());\n+        assert(pubkey.IsValid());\n+        assert(pubkey.IsFullyValid());\n+        assert(HexToPubKey(HexStr(pubkey.begin(), pubkey.end())) == pubkey);\n+        assert(GetAllDestinationsForKey(pubkey).size() == 3);\n+    }\n+\n+    {\n+        CDataStream data_stream{SER_NETWORK, INIT_PROTO_VERSION};\n+        pubkey.Serialize(data_stream);\n+\n+        CPubKey pubkey_deserialized;\n+        pubkey_deserialized.Unserialize(data_stream);\n+        assert(pubkey_deserialized == pubkey);\n+    }\n+\n+    {\n+        const CScript tx_pubkey_script = GetScriptForRawPubKey(pubkey);\n+        assert(!tx_pubkey_script.IsPayToScriptHash());\n+        assert(!tx_pubkey_script.IsPayToWitnessScriptHash());\n+        assert(!tx_pubkey_script.IsPushOnly());\n+        assert(!tx_pubkey_script.IsUnspendable());\n+        assert(tx_pubkey_script.HasValidOps());\n+        assert(tx_pubkey_script.size() == 35);\n+\n+        const CScript tx_multisig_script = GetScriptForMultisig(1, {pubkey});\n+        assert(!tx_multisig_script.IsPayToScriptHash());\n+        assert(!tx_multisig_script.IsPayToWitnessScriptHash());\n+        assert(!tx_multisig_script.IsPushOnly());\n+        assert(!tx_multisig_script.IsUnspendable());\n+        assert(tx_multisig_script.HasValidOps());\n+        assert(tx_multisig_script.size() == 37);\n+\n+        FillableSigningProvider fillable_signing_provider;\n+        assert(IsSolvable(fillable_signing_provider, tx_pubkey_script));\n+        assert(IsSolvable(fillable_signing_provider, tx_multisig_script));\n+        assert(!IsSegWitOutput(fillable_signing_provider, tx_pubkey_script));\n+        assert(!IsSegWitOutput(fillable_signing_provider, tx_multisig_script));\n+        assert(fillable_signing_provider.GetKeys().size() == 0);\n+        assert(!fillable_signing_provider.HaveKey(pubkey.GetID()));\n+\n+        const bool ok_add_key = fillable_signing_provider.AddKey(key);\n+        assert(ok_add_key);\n+        assert(fillable_signing_provider.HaveKey(pubkey.GetID()));\n+\n+        FillableSigningProvider fillable_signing_provider_pub;\n+        assert(!fillable_signing_provider_pub.HaveKey(pubkey.GetID()));\n+\n+        const bool ok_add_key_pubkey = fillable_signing_provider_pub.AddKeyPubKey(key, pubkey);\n+        assert(ok_add_key_pubkey);\n+        assert(fillable_signing_provider_pub.HaveKey(pubkey.GetID()));\n+\n+        txnouttype which_type_tx_pubkey;\n+        const bool is_standard_tx_pubkey = IsStandard(tx_pubkey_script, which_type_tx_pubkey);\n+        assert(is_standard_tx_pubkey);\n+        assert(which_type_tx_pubkey == txnouttype::TX_PUBKEY);\n+\n+        txnouttype which_type_tx_multisig;\n+        const bool is_standard_tx_multisig = IsStandard(tx_multisig_script, which_type_tx_multisig);\n+        assert(is_standard_tx_multisig);\n+        assert(which_type_tx_multisig == txnouttype::TX_MULTISIG);\n+\n+        std::vector<std::vector<unsigned char>> v_solutions_ret_tx_pubkey;\n+        const txnouttype outtype_tx_pubkey = Solver(tx_pubkey_script, v_solutions_ret_tx_pubkey);\n+        assert(outtype_tx_pubkey == txnouttype::TX_PUBKEY);\n+        assert(v_solutions_ret_tx_pubkey.size() == 1);\n+        assert(v_solutions_ret_tx_pubkey[0].size() == 33);\n+\n+        std::vector<std::vector<unsigned char>> v_solutions_ret_tx_multisig;\n+        const txnouttype outtype_tx_multisig = Solver(tx_multisig_script, v_solutions_ret_tx_multisig);\n+        assert(outtype_tx_multisig == txnouttype::TX_MULTISIG);\n+        assert(v_solutions_ret_tx_multisig.size() == 3);\n+        assert(v_solutions_ret_tx_multisig[0].size() == 1);\n+        assert(v_solutions_ret_tx_multisig[1].size() == 33);\n+        assert(v_solutions_ret_tx_multisig[2].size() == 1);\n+\n+        OutputType output_type{};\n+        const CTxDestination tx_destination = GetDestinationForKey(pubkey, output_type);\n+        assert(output_type == OutputType::LEGACY);\n+        assert(IsValidDestination(tx_destination));\n+        assert(CTxDestination{PKHash{pubkey}} == tx_destination);\n+\n+        const CScript script_for_destination = GetScriptForDestination(tx_destination);\n+        assert(script_for_destination.size() == 25);\n+\n+        const std::string destination_address = EncodeDestination(tx_destination);\n+        assert(DecodeDestination(destination_address) == tx_destination);\n+\n+        const CPubKey pubkey_from_address_string = AddrToPubKey(fillable_signing_provider, destination_address);\n+        assert(pubkey_from_address_string == pubkey);\n+\n+        CKeyID key_id = pubkey.GetID();\n+        assert(!key_id.IsNull());\n+        assert(key_id == CKeyID{key_id});\n+        assert(key_id == GetKeyForDestination(fillable_signing_provider, tx_destination));\n+\n+        CPubKey pubkey_out;\n+        const bool ok_get_pubkey = fillable_signing_provider.GetPubKey(key_id, pubkey_out);\n+        assert(ok_get_pubkey);\n+\n+        CKey key_out;\n+        const bool ok_get_key = fillable_signing_provider.GetKey(key_id, key_out);\n+        assert(ok_get_key);\n+        assert(fillable_signing_provider.GetKeys().size() == 1);\n+        assert(fillable_signing_provider.HaveKey(key_id));\n+\n+        KeyOriginInfo key_origin_info;\n+        const bool ok_get_key_origin = fillable_signing_provider.GetKeyOrigin(key_id, key_origin_info);\n+        assert(!ok_get_key_origin);\n+    }\n+\n+    {\n+        const std::vector<unsigned char> vch_pubkey{pubkey.begin(), pubkey.end()};\n+        assert(CPubKey::ValidSize(vch_pubkey));\n+        assert(!CPubKey::ValidSize({pubkey.begin(), pubkey.begin() + pubkey.size() - 1}));\n+\n+        const CPubKey pubkey_ctor_1{vch_pubkey};\n+        assert(pubkey == pubkey_ctor_1);\n+\n+        const CPubKey pubkey_ctor_2{vch_pubkey.begin(), vch_pubkey.end()};\n+        assert(pubkey == pubkey_ctor_2);\n+\n+        CPubKey pubkey_set;\n+        pubkey_set.Set(vch_pubkey.begin(), vch_pubkey.end());\n+        assert(pubkey == pubkey_set);\n+    }\n+\n+    {\n+        const CPubKey invalid_pubkey{};\n+        assert(!invalid_pubkey.IsValid());\n+        assert(!invalid_pubkey.IsFullyValid());\n+        assert(!(pubkey == invalid_pubkey));\n+        assert(pubkey != invalid_pubkey);\n+        assert(pubkey < invalid_pubkey);\n+    }\n+\n+    {\n+        // Cover CPubKey's operator[](unsigned int pos)\n+        unsigned int sum = 0;\n+        for (size_t i = 0; i < pubkey.size(); ++i) {\n+            sum += pubkey[i];\n+        }\n+        assert(std::accumulate(pubkey.begin(), pubkey.end(), 0U) == sum);\n+    }\n+\n+    {\n+        CPubKey decompressed_pubkey = pubkey;\n+        assert(decompressed_pubkey.IsCompressed());\n+\n+        const bool ok = decompressed_pubkey.Decompress();\n+        assert(ok);\n+        assert(!decompressed_pubkey.IsCompressed());\n+        assert(decompressed_pubkey.size() == 65);\n+    }\n+\n+    {\n+        std::vector<unsigned char> vch_sig;\n+        const bool ok = key.Sign(random_uint256, vch_sig, false);\n+        assert(ok);\n+        assert(pubkey.Verify(random_uint256, vch_sig));\n+        assert(CPubKey::CheckLowS(vch_sig));\n+\n+        const std::vector<unsigned char> vch_invalid_sig{vch_sig.begin(), vch_sig.begin() + vch_sig.size() - 1};\n+        assert(!pubkey.Verify(random_uint256, vch_invalid_sig));\n+        assert(!CPubKey::CheckLowS(vch_invalid_sig));\n+    }\n+\n+    {\n+        std::vector<unsigned char> vch_compact_sig;\n+        const bool ok_sign_compact = key.SignCompact(random_uint256, vch_compact_sig);\n+        assert(ok_sign_compact);\n+\n+        CPubKey recover_pubkey;\n+        const bool ok_recover_compact = recover_pubkey.RecoverCompact(random_uint256, vch_compact_sig);\n+        assert(ok_recover_compact);\n+        assert(recover_pubkey == pubkey);\n+    }\n+\n+    {\n+        CPubKey child_pubkey;\n+        ChainCode child_chaincode;\n+        const bool ok = pubkey.Derive(child_pubkey, child_chaincode, 0, random_uint256);\n+        assert(ok);\n+        assert(child_pubkey != pubkey);\n+        assert(child_pubkey.IsCompressed());\n+        assert(child_pubkey.IsFullyValid());\n+        assert(child_pubkey.IsValid());\n+        assert(child_pubkey.size() == 33);\n+        assert(child_chaincode != random_uint256);\n+    }\n+\n+    const CPrivKey priv_key = key.GetPrivKey();\n+\n+    {\n+        for (const bool skip_check : {true, false}) {\n+            CKey loaded_key;\n+            const bool ok = loaded_key.Load(priv_key, pubkey, skip_check);\n+            assert(ok);\n+            assert(key == loaded_key);\n+        }\n+    }\n+}"
      },
      {
        "sha": "c60a48beff717d21d8ce4e78df498780fc1370d0",
        "filename": "test/fuzz/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4691b6c217ab843e6e66fa0ad34d83137499a89/test/fuzz/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4691b6c217ab843e6e66fa0ad34d83137499a89/test/fuzz/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/fuzz/test_runner.py?ref=f4691b6c217ab843e6e66fa0ad34d83137499a89",
        "patch": "@@ -25,6 +25,7 @@\n     \"flat_file_pos_deserialize\",\n     \"hex\",\n     \"integer\",\n+    \"key\",\n     \"key_origin_info_deserialize\",\n     \"merkle_block_deserialize\",\n     \"out_point_deserialize\","
      }
    ]
  }
]