[
  {
    "sha": "c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMDk5Y2Y1MDJiZDU1YmY1YzZhZWJjYWE0ZWQwZTlkNmUzMTQzMjg4",
    "commit": {
      "author": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2019-09-26T20:55:27Z"
      },
      "committer": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-08-11T13:53:24Z"
      },
      "message": "Add test for send{toaddress, many} conf_target under subtractfromamount scenario",
      "tree": {
        "sha": "47eb50bf4f256a6525a333f909ace275f9dab01e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47eb50bf4f256a6525a333f909ace275f9dab01e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4644b13b4499d1d661efdccc9854d3dccdf5b0e9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4644b13b4499d1d661efdccc9854d3dccdf5b0e9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4644b13b4499d1d661efdccc9854d3dccdf5b0e9"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 38,
      "deletions": 1
    },
    "files": [
      {
        "sha": "38adffb4831a9b694d64dcf18a58e929b22f39cd",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=c099cf502bd55bf5c6aebcaa4ed0e9d6e3143288",
        "patch": "@@ -10,12 +10,14 @@\n from test_framework.script import CScript, OP_1, OP_DROP, OP_2, OP_HASH160, OP_EQUAL, hash160, OP_TRUE\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n+    assert_approx,\n     assert_equal,\n     assert_greater_than,\n     assert_greater_than_or_equal,\n     connect_nodes,\n     satoshi_round,\n )\n+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n \n # Construct 2 trivial P2SH's and the ScriptSigs that spend them\n # So we can create many transactions without needing to spend\n@@ -255,9 +257,44 @@ def run_test(self):\n             self.transact_and_mine(10, self.nodes[1])\n             check_estimates(self.nodes[1], self.fees_per_kb)\n \n+        # Test the conf_target argument for sendtoaddress when whole coins are spent\n+        # and subtractfeefromamount is used\n+        low_count = 288\n+        high_count = 2\n+        low_feerate = self.nodes[1].estimatesmartfee(low_count, \"ECONOMICAL\")\n+        high_feerate = self.nodes[1].estimatesmartfee(high_count, \"ECONOMICAL\")\n+        assert high_feerate[\"feerate\"]/2 > low_feerate[\"feerate\"] # comfortably larger\n+        assert high_feerate[\"blocks\"] < low_feerate[\"blocks\"]\n+\n+        # Spend all coins at once\n+        self.nodes[1].sendtoaddress(address=self.nodes[1].getnewaddress(), amount=self.nodes[1].getbalance(), subtractfeefromamount=True, conf_target=low_count, estimate_mode=\"ECONOMICAL\")\n+        self.nodes[1].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        # Then re-spend the change a couple times to test close as possible scenarios\n+        low_txid = self.nodes[1].sendtoaddress(address=self.nodes[1].getnewaddress(), amount=self.nodes[1].getbalance(), subtractfeefromamount=True, conf_target=low_count, estimate_mode=\"ECONOMICAL\")\n+        high_txid = self.nodes[1].sendtoaddress(address=self.nodes[1].getnewaddress(), amount=self.nodes[1].getbalance(), subtractfeefromamount=True, conf_target=high_count, estimate_mode=\"ECONOMICAL\")\n+        # Send exactly the UTXO amount to multiple destinations, with one output paying the fee\n+        sum_total = self.nodes[1].getbalances()[\"mine\"][\"trusted\"]\n+        subtract_address = self.nodes[1].getnewaddress()\n+        low_many_txid = self.nodes[1].sendmany(amounts={self.nodes[1].getnewaddress(): sum_total-10, subtract_address: 10}, subtractfeefrom=[subtract_address], conf_target=low_count, estimate_mode=\"ECONOMICAL\")\n+        sum_total = self.nodes[1].getbalances()[\"mine\"][\"trusted\"]\n+        high_many_txid = self.nodes[1].sendmany(amounts={self.nodes[1].getnewaddress(): sum_total-10, subtract_address: 10}, subtractfeefrom=[subtract_address], conf_target=high_count, estimate_mode=\"ECONOMICAL\")\n+\n+\n+        # Total fee should be really close to one-off estimates\n+        low_info = self.nodes[1].getmempoolentry(low_txid)\n+        high_info = self.nodes[1].getmempoolentry(high_txid)\n+        low_many_info = self.nodes[1].getmempoolentry(low_many_txid)\n+        high_many_info = self.nodes[1].getmempoolentry(high_many_txid)\n+\n+        assert_approx(low_info[\"vsize\"]*low_feerate[\"feerate\"]/1000, float(low_info[\"fee\"]))\n+        assert_approx(high_info[\"vsize\"]*high_feerate[\"feerate\"]/1000, float(high_info[\"fee\"]))\n+        assert_approx(low_many_info[\"vsize\"]*low_feerate[\"feerate\"]/1000, float(low_many_info[\"fee\"]))\n+        assert_approx(high_many_info[\"vsize\"]*high_feerate[\"feerate\"]/1000, float(high_many_info[\"fee\"]))\n+\n+\n         # Finish by mining a normal-sized block:\n         while len(self.nodes[1].getrawmempool()) > 0:\n-            self.nodes[1].generate(1)\n+            self.nodes[1].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n \n         self.sync_blocks(self.nodes[0:3], wait=.1)\n         self.log.info(\"Final estimates after emptying mempools\")"
      }
    ]
  }
]