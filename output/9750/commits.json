[
  {
    "sha": "64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NGFhMzZlMjAzNjhmYTE2ZDRmZjc1N2Q1NmRjMjY5MGVkMGY0OGJh",
    "commit": {
      "author": {
        "name": "\u30ed\u30cf\u30f3 \u30c0\u30eb",
        "email": "rohun-dhar@MN14042102.local",
        "date": "2017-02-13T05:39:48Z"
      },
      "committer": {
        "name": "\u30ed\u30cf\u30f3 \u30c0\u30eb",
        "email": "rohun-dhar@MN14042102.local",
        "date": "2017-02-13T05:39:48Z"
      },
      "message": "param variables made const",
      "tree": {
        "sha": "6d6e54064be812d02932a9e1fdee55d70b618967",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d6e54064be812d02932a9e1fdee55d70b618967"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "d978c41e1ec4fcf2c4d096f09af035f9e8a7ad81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d978c41e1ec4fcf2c4d096f09af035f9e8a7ad81",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d978c41e1ec4fcf2c4d096f09af035f9e8a7ad81"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 8,
      "deletions": 8
    },
    "files": [
      {
        "sha": "860bc0211ef2bf2c2e52aa6a11600a59f5d1f1e5",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
        "patch": "@@ -19,7 +19,7 @@\n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n \n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn, unsigned char nFlagsIn) :\n     /**\n      * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n      * - nElements * log(fp rate) / ln(2)^2\n@@ -40,7 +40,7 @@ CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int\n }\n \n // Private constructor used by CRollingBloomFilter\n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn) :\n     vData((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)) / 8),\n     isFull(false),\n     isEmpty(true),\n@@ -120,7 +120,7 @@ void CBloomFilter::clear()\n     isEmpty = true;\n }\n \n-void CBloomFilter::reset(unsigned int nNewTweak)\n+void CBloomFilter::reset(const unsigned int nNewTweak)\n {\n     clear();\n     nTweak = nNewTweak;\n@@ -214,7 +214,7 @@ void CBloomFilter::UpdateEmptyFull()\n     isEmpty = empty;\n }\n \n-CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate)\n+CRollingBloomFilter::CRollingBloomFilter(const unsigned int nElements, const double fpRate)\n {\n     double logFpRate = log(fpRate);\n     /* The optimal number of hash functions is log(fpRate) / log(0.5), but"
      },
      {
        "sha": "7ca96822396b909ec076e7f2f562b7d0f1766133",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
        "patch": "@@ -54,7 +54,7 @@ class CBloomFilter\n     unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n     // Private constructor for CRollingBloomFilter, no restrictions on size\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak);\n     friend class CRollingBloomFilter;\n \n public:\n@@ -67,7 +67,7 @@ class CBloomFilter\n      * It should generally always be a random value (and is largely only exposed for unit testing)\n      * nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)\n      */\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak, unsigned char nFlagsIn);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak, unsigned char nFlagsIn);\n     CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) {}\n \n     ADD_SERIALIZE_METHODS;\n@@ -89,7 +89,7 @@ class CBloomFilter\n     bool contains(const uint256& hash) const;\n \n     void clear();\n-    void reset(unsigned int nNewTweak);\n+    void reset(const unsigned int nNewTweak);\n \n     //! True if the size is <= MAX_BLOOM_FILTER_SIZE and the number of hash functions is <= MAX_HASH_FUNCS\n     //! (catch a filter which was just deserialized which was too big)\n@@ -122,7 +122,7 @@ class CRollingBloomFilter\n     // A random bloom filter calls GetRand() at creation time.\n     // Don't create global CRollingBloomFilter objects, as they may be\n     // constructed before the randomizer is properly initialized.\n-    CRollingBloomFilter(unsigned int nElements, double nFPRate);\n+    CRollingBloomFilter(const unsigned int nElements, const double nFPRate);\n \n     void insert(const std::vector<unsigned char>& vKey);\n     void insert(const uint256& hash);"
      }
    ]
  },
  {
    "sha": "d60d54ddb394bce457c87fee5474421db65811ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjBkNTRkZGIzOTRiY2U0NTdjODdmZWU1NDc0NDIxZGI2NTgxMWFi",
    "commit": {
      "author": {
        "name": "\u30ed\u30cf\u30f3 \u30c0\u30eb",
        "email": "rohun-dhar@MN14042102.local",
        "date": "2017-02-21T19:31:13Z"
      },
      "committer": {
        "name": "\u30ed\u30cf\u30f3 \u30c0\u30eb",
        "email": "rohun-dhar@MN14042102.local",
        "date": "2017-02-21T19:31:13Z"
      },
      "message": "merge with bitcoin core",
      "tree": {
        "sha": "955d66deef5fc5483032a5edbb6d5eb2ebec35fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/955d66deef5fc5483032a5edbb6d5eb2ebec35fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d60d54ddb394bce457c87fee5474421db65811ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60d54ddb394bce457c87fee5474421db65811ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d60d54ddb394bce457c87fee5474421db65811ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60d54ddb394bce457c87fee5474421db65811ab/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/64aa36e20368fa16d4ff757d56dc2690ed0f48ba"
      },
      {
        "sha": "61a640ea9741e5e76b945699a8332b0a9923339b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a640ea9741e5e76b945699a8332b0a9923339b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61a640ea9741e5e76b945699a8332b0a9923339b"
      }
    ],
    "stats": {
      "total": 3931,
      "additions": 2923,
      "deletions": 1008
    },
    "files": [
      {
        "sha": "fc8d58d97df49dfb039c8caee2293a82c93862c0",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -38,7 +38,7 @@ fixes or code moves with actual code changes.\n Commit messages should be verbose by default consisting of a short subject line\n (50 chars max), a blank line and detailed explanatory text as separate\n paragraph(s); unless the title alone is self-explanatory (like \"Corrected typo\n-in main.cpp\") then a single title line is sufficient. Commit messages should be\n+in init.cpp\") then a single title line is sufficient. Commit messages should be\n helpful to people reading your code in the future, so explain the reasoning for\n your decisions. Further explanation [here](http://chris.beams.io/posts/git-commit/).\n \n@@ -79,7 +79,7 @@ Examples:\n     Consensus: Add new opcode for BIP-XXXX OP_CHECKAWESOMESIG\n     Net: Automatically create hidden service, listen on Tor\n     Qt: Add feed bump button\n-    Trivial: Fix typo in main.cpp\n+    Trivial: Fix typo in init.cpp\n \n If a pull request is specifically not to be considered for merging (yet) please\n prefix the title with [WIP] or use [Tasks Lists](https://help.github.com/articles/basic-writing-and-formatting-syntax/#task-lists)\n@@ -194,7 +194,7 @@ request. Typically reviewers will review the code for obvious errors, as well as\n test out the patch set and opine on the technical merits of the patch. Project\n maintainers take into account the peer review when determining if there is\n consensus to merge a pull request (remember that discussions may have been\n-spread out over github, mailing list and IRC discussions). The following\n+spread out over GitHub, mailing list and IRC discussions). The following\n language is used within pull-request comments:\n \n   - ACK means \"I have tested the code and I agree it should be merged\";"
      },
      {
        "sha": "1ee2dfb734ede01f76a6f192be0441a372bea756",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -227,9 +227,6 @@ EXTRA_DIST = $(top_srcdir)/share/genbuild.sh qa/pull-tester/rpc-tests.py qa/rpc-\n \n CLEANFILES = $(OSX_DMG) $(BITCOIN_WIN_INSTALLER)\n \n-# This file is problematic for out-of-tree builds if it exists.\n-DISTCLEANFILES = qa/pull-tester/tests_config.pyc\n-\n .INTERMEDIATE: $(COVERAGE_INFO)\n \n DISTCHECK_CONFIGURE_FLAGS = --enable-man"
      },
      {
        "sha": "78129fb202923a9d9ddc10ea8cc211587f807449",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,7 +1,7 @@\n dnl require autoconf 2.60 (AS_ECHO/AS_ECHO_N)\n AC_PREREQ([2.60])\n define(_CLIENT_VERSION_MAJOR, 0)\n-define(_CLIENT_VERSION_MINOR, 13)\n+define(_CLIENT_VERSION_MINOR, 14)\n define(_CLIENT_VERSION_REVISION, 99)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_IS_RELEASE, false)\n@@ -1087,7 +1087,7 @@ AC_SUBST(ZMQ_LIBS)\n AC_SUBST(PROTOBUF_LIBS)\n AC_SUBST(QR_LIBS)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist src/test/buildenv.py])\n-AC_CONFIG_FILES([qa/pull-tester/tests_config.py],[chmod +x qa/pull-tester/tests_config.py])\n+AC_CONFIG_FILES([qa/pull-tester/tests_config.ini],[chmod +x qa/pull-tester/tests_config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AC_CONFIG_LINKS([qa/pull-tester/rpc-tests.py:qa/pull-tester/rpc-tests.py])\n "
      },
      {
        "sha": "6f750106e4710dbe29eb95ab0f0a54454d488657",
        "filename": "contrib/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/README.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -3,7 +3,7 @@ Repository Tools\n \n ### [Developer tools](/contrib/devtools) ###\n Specific tools for developers working on this repository.\n-Contains the script `github-merge.py` for merging github pull requests securely and signing them using GPG.\n+Contains the script `github-merge.py` for merging GitHub pull requests securely and signing them using GPG.\n \n ### [Verify-Commits](/contrib/verify-commits) ###\n Tool to verify that every merge commit was signed by a developer using the above `github-merge.py` script."
      },
      {
        "sha": "67c5e15a15041f77122a8d0745a3164abde9e8d0",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -125,7 +125,7 @@ check or whatever).\n \n This means that there are no potential race conditions (where a\n pullreq gets updated while you're reviewing it, but before you click\n-merge), and when using GPG signatures, that even a compromised github\n+merge), and when using GPG signatures, that even a compromised GitHub\n couldn't mess with the sources.\n \n Setup"
      },
      {
        "sha": "2011841005930eb975a54bcd59693c27b4a70f2c",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -65,6 +65,14 @@ def split_format_specifiers(specifiers):\n         else:\n             other.append(s)\n \n+    # If both numeric format specifiers and \"others\" are used, assume we're dealing\n+    # with a Qt-formatted message. In the case of Qt formatting (see https://doc.qt.io/qt-5/qstring.html#arg)\n+    # only numeric formats are replaced at all. This means \"(percentage: %1%)\" is valid, without needing\n+    # any kind of escaping that would be necessary for strprintf. Without this, this function\n+    # would wrongly detect '%)' as a printf format specifier.\n+    if numeric:\n+        other = []\n+\n     # numeric (Qt) can be present in any order, others (strprintf) must be in specified order\n     return set(numeric),other\n "
      },
      {
        "sha": "00af4bdc6fa81e2cbfc1550feb5f2a99cb0f8f44",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,5 +1,5 @@\n ---\n-name: \"bitcoin-linux-0.13\"\n+name: \"bitcoin-linux-0.15\"\n enable_cache: true\n suites:\n - \"trusty\""
      },
      {
        "sha": "05cc65414fc537678b9b9c511781c326746427b9",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,5 +1,5 @@\n ---\n-name: \"bitcoin-osx-0.13\"\n+name: \"bitcoin-osx-0.15\"\n enable_cache: true\n suites:\n - \"trusty\""
      },
      {
        "sha": "6fead7c208de0d0abbd8835a2c0bfbe8c501213f",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,5 +1,5 @@\n ---\n-name: \"bitcoin-win-0.13\"\n+name: \"bitcoin-win-0.15\"\n enable_cache: true\n suites:\n - \"trusty\""
      },
      {
        "sha": "ea398a27eacd78001244023534e77a325a6e1d13",
        "filename": "contrib/zmq/zmq_sub.py",
        "status": "modified",
        "additions": 69,
        "deletions": 28,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/zmq/zmq_sub.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/zmq/zmq_sub.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,43 +1,84 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+\"\"\"\n+    ZMQ example using python3's asyncio\n+\n+    Bitcoin should be started with the command line arguments:\n+        bitcoind -testnet -daemon \\\n+                -zmqpubhashblock=tcp://127.0.0.1:28332 \\\n+                -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n+                -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n+                -zmqpubhashblock=tcp://127.0.0.1:28332\n+\n+    We use the asyncio library here.  `self.handle()` installs itself as a\n+    future at the end of the function.  Since it never returns with the event\n+    loop having an empty stack of futures, this creates an infinite loop.  An\n+    alternative is to wrap the contents of `handle` inside `while True`.\n+\n+    A blocking example using python 2.7 can be obtained from the git history:\n+    https://github.com/bitcoin/bitcoin/blob/37a7fe9e440b83e2364d5498931253937abe9294/contrib/zmq/zmq_sub.py\n+\"\"\"\n+\n import binascii\n+import asyncio\n import zmq\n+import zmq.asyncio\n+import signal\n import struct\n+import sys\n+\n+if not (sys.version_info.major >= 3 and sys.version_info.minor >= 5):\n+    print(\"This example only works with Python 3.5 and greater\")\n+    exit(1)\n \n port = 28332\n \n-zmqContext = zmq.Context()\n-zmqSubSocket = zmqContext.socket(zmq.SUB)\n-zmqSubSocket.setsockopt(zmq.SUBSCRIBE, \"hashblock\")\n-zmqSubSocket.setsockopt(zmq.SUBSCRIBE, \"hashtx\")\n-zmqSubSocket.setsockopt(zmq.SUBSCRIBE, \"rawblock\")\n-zmqSubSocket.setsockopt(zmq.SUBSCRIBE, \"rawtx\")\n-zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n-\n-try:\n-    while True:\n-        msg = zmqSubSocket.recv_multipart()\n-        topic = str(msg[0])\n+class ZMQHandler():\n+    def __init__(self):\n+        self.loop = zmq.asyncio.install()\n+        self.zmqContext = zmq.asyncio.Context()\n+\n+        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtx\")\n+        self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n+\n+    async def handle(self) :\n+        msg = await self.zmqSubSocket.recv_multipart()\n+        topic = msg[0]\n         body = msg[1]\n         sequence = \"Unknown\"\n         if len(msg[-1]) == 4:\n           msgSequence = struct.unpack('<I', msg[-1])[-1]\n           sequence = str(msgSequence)\n-        if topic == \"hashblock\":\n-            print '- HASH BLOCK ('+sequence+') -'\n-            print binascii.hexlify(body)\n-        elif topic == \"hashtx\":\n-            print '- HASH TX  ('+sequence+') -'\n-            print binascii.hexlify(body)\n-        elif topic == \"rawblock\":\n-            print '- RAW BLOCK HEADER ('+sequence+') -'\n-            print binascii.hexlify(body[:80])\n-        elif topic == \"rawtx\":\n-            print '- RAW TX ('+sequence+') -'\n-            print binascii.hexlify(body)\n-\n-except KeyboardInterrupt:\n-    zmqContext.destroy()\n+        if topic == b\"hashblock\":\n+            print('- HASH BLOCK ('+sequence+') -')\n+            print(binascii.hexlify(body))\n+        elif topic == b\"hashtx\":\n+            print('- HASH TX  ('+sequence+') -')\n+            print(binascii.hexlify(body))\n+        elif topic == b\"rawblock\":\n+            print('- RAW BLOCK HEADER ('+sequence+') -')\n+            print(binascii.hexlify(body[:80]))\n+        elif topic == b\"rawtx\":\n+            print('- RAW TX ('+sequence+') -')\n+            print(binascii.hexlify(body))\n+        # schedule ourselves to receive the next message\n+        asyncio.ensure_future(self.handle())\n+\n+    def start(self):\n+        self.loop.add_signal_handler(signal.SIGINT, self.stop)\n+        self.loop.create_task(self.handle())\n+        self.loop.run_forever()\n+\n+    def stop(self):\n+        self.loop.stop()\n+        self.zmqContext.destroy()\n+\n+daemon = ZMQHandler()\n+daemon.start()"
      },
      {
        "sha": "a2ff64b29b77ef9d1e9cfbfc26faa2cedd005bf3",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -0,0 +1,89 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"\n+    ZMQ example using python3's asyncio\n+\n+    Bitcoin should be started with the command line arguments:\n+        bitcoind -testnet -daemon \\\n+                -zmqpubhashblock=tcp://127.0.0.1:28332 \\\n+                -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n+                -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n+                -zmqpubhashblock=tcp://127.0.0.1:28332\n+\n+    We use the asyncio library here.  `self.handle()` installs itself as a\n+    future at the end of the function.  Since it never returns with the event\n+    loop having an empty stack of futures, this creates an infinite loop.  An\n+    alternative is to wrap the contents of `handle` inside `while True`.\n+\n+    The `@asyncio.coroutine` decorator and the `yield from` syntax found here\n+    was introduced in python 3.4 and has been deprecated in favor of the `async`\n+    and `await` keywords respectively.\n+\n+    A blocking example using python 2.7 can be obtained from the git history:\n+    https://github.com/bitcoin/bitcoin/blob/37a7fe9e440b83e2364d5498931253937abe9294/contrib/zmq/zmq_sub.py\n+\"\"\"\n+\n+import binascii\n+import asyncio\n+import zmq\n+import zmq.asyncio\n+import signal\n+import struct\n+import sys\n+\n+if not (sys.version_info.major >= 3 and sys.version_info.minor >= 4):\n+    print(\"This example only works with Python 3.4 and greater\")\n+    exit(1)\n+\n+port = 28332\n+\n+class ZMQHandler():\n+    def __init__(self):\n+        self.loop = zmq.asyncio.install()\n+        self.zmqContext = zmq.asyncio.Context()\n+\n+        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtx\")\n+        self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n+\n+    @asyncio.coroutine\n+    def handle(self) :\n+        msg = yield from self.zmqSubSocket.recv_multipart()\n+        topic = msg[0]\n+        body = msg[1]\n+        sequence = \"Unknown\";\n+        if len(msg[-1]) == 4:\n+          msgSequence = struct.unpack('<I', msg[-1])[-1]\n+          sequence = str(msgSequence)\n+        if topic == b\"hashblock\":\n+            print('- HASH BLOCK ('+sequence+') -')\n+            print(binascii.hexlify(body))\n+        elif topic == b\"hashtx\":\n+            print('- HASH TX  ('+sequence+') -')\n+            print(binascii.hexlify(body))\n+        elif topic == b\"rawblock\":\n+            print('- RAW BLOCK HEADER ('+sequence+') -')\n+            print(binascii.hexlify(body[:80]))\n+        elif topic == b\"rawtx\":\n+            print('- RAW TX ('+sequence+') -')\n+            print(binascii.hexlify(body))\n+        # schedule ourselves to receive the next message\n+        asyncio.ensure_future(self.handle())\n+\n+    def start(self):\n+        self.loop.add_signal_handler(signal.SIGINT, self.stop)\n+        self.loop.create_task(self.handle())\n+        self.loop.run_forever()\n+\n+    def stop(self):\n+        self.loop.stop()\n+        self.zmqContext.destroy()\n+\n+daemon = ZMQHandler()\n+daemon.start()"
      },
      {
        "sha": "44fdf1c2952b6188b25ddfe56d2b4f1c71d1c07f",
        "filename": "depends/packages/qrencode.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/depends/packages/qrencode.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/depends/packages/qrencode.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qrencode.mk?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,7 +1,7 @@\n package=qrencode\n $(package)_version=3.4.4\n $(package)_download_path=https://fukuchi.org/works/qrencode/\n-$(package)_file_name=qrencode-$(qrencode_version).tar.bz2\n+$(package)_file_name=$(package)-$($(package)_version).tar.bz2\n $(package)_sha256_hash=efe5188b1ddbcbf98763b819b146be6a90481aac30cfc8d858ab78a19cde1fa5\n \n define $(package)_set_vars"
      },
      {
        "sha": "45436a6b151a103d4adec0d8484a5f1d580bb61f",
        "filename": "doc/Doxyfile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/Doxyfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/Doxyfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/Doxyfile?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -38,7 +38,7 @@ PROJECT_NAME           = \"Bitcoin Core\"\n # could be handy for archiving the generated documentation or if some version\n # control system is used.\n \n-PROJECT_NUMBER         = 0.13.99\n+PROJECT_NUMBER         = 0.14.99\n \n # Using the PROJECT_BRIEF tag one can provide an optional one line description\n # for a project that appears at the top of each page and should give viewer a"
      },
      {
        "sha": "09f32bc09effcd4d07ea12af3801f1cf26e1659b",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core 0.13.99\n+Bitcoin Core 0.14.99\n =====================\n \n Setup"
      },
      {
        "sha": "0e4c9ce04febb43e3da0739bf9f56ea08b6f5d1d",
        "filename": "doc/README_windows.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/README_windows.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/README_windows.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_windows.txt?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin Core 0.13.99\r\n+Bitcoin Core 0.14.99\r\n =====================\r\n \r\n Intro\r"
      },
      {
        "sha": "3a7e4f73b3d60d5a88e20615205d77aa056a7c9f",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -448,7 +448,7 @@ Current subtrees include:\n   - Upstream at https://github.com/jgarzik/univalue ; report important PRs to Core to avoid delay.\n \n \n-Git and github tips\n+Git and GitHub tips\n ---------------------\n \n - For resolving merge/rebase conflicts, it can be useful to enable diff3 style using"
      },
      {
        "sha": "0493241b1e07e90db2ac06eacaaa12ff3a6cd1e9",
        "filename": "doc/man/bitcoin-cli.1",
        "status": "modified",
        "additions": 16,
        "deletions": 14,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoin-cli.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoin-cli.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoin-cli.1?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,19 +1,17 @@\n-.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.5.\n-.TH BITCOIN-CLI \"1\" \"September 2016\" \"bitcoin-cli v0.13.0.0\" \"User Commands\"\n+.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n+.TH BITCOIN-CLI \"1\" \"February 2017\" \"bitcoin-cli v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoin-cli \\- manual page for bitcoin-cli v0.13.0.0\n+bitcoin-cli \\- manual page for bitcoin-cli v0.14.99.0\n .SH DESCRIPTION\n-Bitcoin Core RPC client version v0.13.0.0\n+Bitcoin Core RPC client version v0.14.99.0\n .SS \"Usage:\"\n .TP\n bitcoin\\-cli [options] <command> [params]\n Send command to Bitcoin Core\n-.TP\n-bitcoin\\-cli [options] help\n-List commands\n-.TP\n-bitcoin\\-cli [options] help <command>\n-Get help for a command\n+.IP\n+bitcoin\\-cli [options] \\fB\\-named\\fR <command> [name=value] ... Send command to Bitcoin Core (with named arguments)\n+bitcoin\\-cli [options] help                List commands\n+bitcoin\\-cli [options] help <command>      Get help for a command\n .SH OPTIONS\n .HP\n \\-?\n@@ -40,6 +38,10 @@ Enter regression test mode, which uses a special chain in which blocks\n can be solved instantly. This is intended for regression testing\n tools and app development.\n .HP\n+\\fB\\-named\\fR\n+.IP\n+Pass named instead of positional arguments (default: false)\n+.HP\n \\fB\\-rpcconnect=\\fR<ip>\n .IP\n Send commands to node running on <ip> (default: 127.0.0.1)\n@@ -69,16 +71,16 @@ Timeout during HTTP requests (default: 900)\n Read extra arguments from standard input, one per line until EOF/Ctrl\\-D\n (recommended for sensitive information such as passphrases)\n .SH COPYRIGHT\n-Copyright (C) 2009-2016 The Bitcoin Core developers\n+Copyright (C) 2009-2017 The Bitcoin Core developers\n \n Please contribute if you find Bitcoin Core useful. Visit\n <https://bitcoincore.org> for further information about the software.\n The source code is available from <https://github.com/bitcoin/bitcoin>.\n \n This is experimental software.\n Distributed under the MIT software license, see the accompanying file COPYING\n-or <http://www.opensource.org/licenses/mit-license.php>.\n+or <https://opensource.org/licenses/MIT>\n \n This product includes software developed by the OpenSSL Project for use in the\n-OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written\n-by Eric Young and UPnP software written by Thomas Bernard.\n+OpenSSL Toolkit <https://www.openssl.org> and cryptographic software written by\n+Eric Young and UPnP software written by Thomas Bernard."
      },
      {
        "sha": "ce252612e57a2ae402921f7ed50cf7199679aa1e",
        "filename": "doc/man/bitcoin-qt.1",
        "status": "modified",
        "additions": 69,
        "deletions": 38,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoin-qt.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoin-qt.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoin-qt.1?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,9 +1,9 @@\n-.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.5.\n-.TH BITCOIN-QT \"1\" \"September 2016\" \"bitcoin-qt v0.13.0.0\" \"User Commands\"\n+.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n+.TH BITCOIN-QT \"1\" \"February 2017\" \"bitcoin-qt v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoin-qt \\- manual page for bitcoin-qt v0.13.0.0\n+bitcoin-qt \\- manual page for bitcoin-qt v0.14.99.0\n .SH DESCRIPTION\n-Bitcoin Core version v0.13.0.0 (64\\-bit)\n+Bitcoin Core version v0.14.99.0 (64\\-bit)\n Usage:\n .IP\n bitcoin\\-qt [command\\-line options]\n@@ -27,13 +27,14 @@ long fork (%s in cmd is replaced by message)\n Execute command when the best block changes (%s in cmd is replaced by\n block hash)\n .HP\n-\\fB\\-checkblocks=\\fR<n>\n+\\fB\\-assumevalid=\\fR<hex>\n .IP\n-How many blocks to check at startup (default: 288, 0 = all)\n-.HP\n-\\fB\\-checklevel=\\fR<n>\n-.IP\n-How thorough the block verification of \\fB\\-checkblocks\\fR is (0\\-4, default: 3)\n+If this block is in the chain assume that it and its ancestors are valid\n+and potentially skip their script verification (0 to verify all,\n+default:\n+00000000000000000013176bf8d7dfeab4e1db31dc93bc311b436e82ab226b90,\n+testnet:\n+00000000000128796ee387cf110ccb9d2f36cffaf7f73079c995377c65ac0dcc)\n .HP\n \\fB\\-conf=\\fR<file>\n .IP\n@@ -62,11 +63,16 @@ Keep the transaction memory pool below <n> megabytes (default: 300)\n \\fB\\-mempoolexpiry=\\fR<n>\n .IP\n Do not keep transactions in the mempool longer than <n> hours (default:\n-72)\n+336)\n+.HP\n+\\fB\\-blockreconstructionextratxn=\\fR<n>\n+.IP\n+Extra transactions to keep in memory for compact block reconstructions\n+(default: 100)\n .HP\n \\fB\\-par=\\fR<n>\n .IP\n-Set the number of script verification threads (\\fB\\-4\\fR to 16, 0 = auto, <0 =\n+Set the number of script verification threads (\\fB\\-2\\fR to 16, 0 = auto, <0 =\n leave that many cores free, default: 0)\n .HP\n \\fB\\-pid=\\fR<file>\n@@ -75,13 +81,15 @@ Specify pid file (default: bitcoind.pid)\n .HP\n \\fB\\-prune=\\fR<n>\n .IP\n-Reduce storage requirements by enabling pruning (deleting) of old blocks.\n-This allows the pruneblockchain RPC to be called to delete specific blocks,\n-and enables automatic pruning of old blocks if a target size in MiB is\n-provided. This mode is incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR.\n-Warning: Reverting this setting requires re\\-downloading the entire blockchain.\n-(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >550 =\n-automatically prune block files to stay under the specified target size in MiB)\n+Reduce storage requirements by enabling pruning (deleting) of old\n+blocks. This allows the pruneblockchain RPC to be called to\n+delete specific blocks, and enables automatic pruning of old\n+blocks if a target size in MiB is provided. This mode is\n+incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR. Warning: Reverting this\n+setting requires re\\-downloading the entire blockchain. (default:\n+0 = disable pruning blocks, 1 = allow manual pruning via RPC,\n+>550 = automatically prune block files to stay under the\n+specified target size in MiB)\n .HP\n \\fB\\-reindex\\-chainstate\\fR\n .IP\n@@ -123,7 +131,8 @@ for IPv6\n .HP\n \\fB\\-connect=\\fR<ip>\n .IP\n-Connect only to the specified node(s)\n+Connect only to the specified node(s); \\fB\\-noconnect\\fR or \\fB\\-connect\\fR=\\fI\\,0\\/\\fR alone to\n+disable automatic connections\n .HP\n \\fB\\-discover\\fR\n .IP\n@@ -137,7 +146,7 @@ Allow DNS lookups for \\fB\\-addnode\\fR, \\fB\\-seednode\\fR and \\fB\\-connect\\fR (def\n \\fB\\-dnsseed\\fR\n .IP\n Query for peer addresses via DNS lookup, if low on addresses (default: 1\n-unless \\fB\\-connect\\fR)\n+unless \\fB\\-connect\\fR/\\-noconnect)\n .HP\n \\fB\\-externalip=\\fR<ip>\n .IP\n@@ -149,7 +158,8 @@ Always query for peer addresses via DNS lookup (default: 0)\n .HP\n \\fB\\-listen\\fR\n .IP\n-Accept connections from outside (default: 1 if no \\fB\\-proxy\\fR or \\fB\\-connect\\fR)\n+Accept connections from outside (default: 1 if no \\fB\\-proxy\\fR or\n+\\fB\\-connect\\fR/\\-noconnect)\n .HP\n \\fB\\-listenonion\\fR\n .IP\n@@ -204,6 +214,11 @@ Connect through SOCKS5 proxy\n Randomize credentials for every proxy connection. This enables Tor\n stream isolation (default: 1)\n .HP\n+\\fB\\-rpcserialversion\\fR\n+.IP\n+Sets the serialization of raw transaction or block hex returned in\n+non\\-verbose mode, non\\-segwit(0) or segwit(1) (default: 1)\n+.HP\n \\fB\\-seednode=\\fR<ip>\n .IP\n Connect to a node to retrieve peer addresses, and disconnect\n@@ -221,17 +236,22 @@ Tor control port to use if onion listening enabled (default:\n .IP\n Tor control port password (default: empty)\n .HP\n+\\fB\\-upnp\\fR\n+.IP\n+Use UPnP to map the listening port (default: 0)\n+.HP\n \\fB\\-whitebind=\\fR<addr>\n .IP\n Bind to given address and whitelist peers connecting to it. Use\n [host]:port notation for IPv6\n .HP\n-\\fB\\-whitelist=\\fR<netmask>\n+\\fB\\-whitelist=\\fR<IP address or network>\n .IP\n-Whitelist peers connecting from the given netmask or IP address. Can be\n-specified multiple times. Whitelisted peers cannot be DoS banned\n-and their transactions are always relayed, even if they are\n-already in the mempool, useful e.g. for a gateway\n+Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or\n+CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple\n+times. Whitelisted peers cannot be DoS banned and their\n+transactions are always relayed, even if they are already in the\n+mempool, useful e.g. for a gateway\n .HP\n \\fB\\-whitelistrelay\\fR\n .IP\n@@ -240,7 +260,7 @@ not relaying transactions (default: 1)\n .HP\n \\fB\\-whitelistforcerelay\\fR\n .IP\n-Force relay of transactions from whitelisted peers even they violate\n+Force relay of transactions from whitelisted peers even if they violate\n local relay policy (default: 1)\n .HP\n \\fB\\-maxuploadtarget=\\fR<n>\n@@ -287,13 +307,17 @@ Spend unconfirmed change when sending transactions (default: 1)\n \\fB\\-txconfirmtarget=\\fR<n>\n .IP\n If paytxfee is not set, include enough fee so transactions begin\n-confirmation on average within n blocks (default: 2)\n+confirmation on average within n blocks (default: 6)\n .HP\n \\fB\\-usehd\\fR\n .IP\n Use hierarchical deterministic key generation (HD) after BIP32. Only has\n effect during wallet creation/first start (default: 1)\n .HP\n+\\fB\\-walletrbf\\fR\n+.IP\n+Send transactions with full\\-RBF opt\\-in enabled (default: 0)\n+.HP\n \\fB\\-upgradewallet\\fR\n .IP\n Upgrade wallet to latest format on startup\n@@ -347,9 +371,9 @@ Append comment to the user agent string\n Output debugging information (default: 0, supplying <category> is\n optional). If <category> is not supplied or if <category> = 1,\n output all debugging information.<category> can be: addrman,\n-alert, bench, coindb, db, http, libevent, lock, mempool,\n-mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins,\n-tor, zmq, qt.\n+alert, bench, cmpctblock, coindb, db, http, libevent, lock,\n+mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc,\n+selectcoins, tor, zmq, qt.\n .HP\n \\fB\\-help\\-debug\\fR\n .IP\n@@ -422,6 +446,11 @@ Set maximum block size in bytes (default: 750000)\n .IP\n Set maximum size of high\\-priority/low\\-fee transactions in bytes\n (default: 0)\n+.HP\n+\\fB\\-blockmintxfee=\\fR<amt>\n+.IP\n+Set lowest fee rate (in BTC/kB) for transactions to be included in block\n+creation. (default: 0.00001)\n .PP\n RPC server options:\n .HP\n@@ -455,8 +484,10 @@ Password for JSON\\-RPC connections\n .IP\n Username and hashed password for JSON\\-RPC connections. The field\n <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A\n-canonical python script is included in share/rpcuser. This option\n-can be specified multiple times\n+canonical python script is included in share/rpcuser. The client\n+then connects normally using the\n+rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This\n+option can be specified multiple times\n .HP\n \\fB\\-rpcport=\\fR<port>\n .IP\n@@ -500,16 +531,16 @@ Show splash screen on startup (default: 1)\n .IP\n Reset all settings changed in the GUI\n .SH COPYRIGHT\n-Copyright (C) 2009-2016 The Bitcoin Core developers\n+Copyright (C) 2009-2017 The Bitcoin Core developers\n \n Please contribute if you find Bitcoin Core useful. Visit\n <https://bitcoincore.org> for further information about the software.\n The source code is available from <https://github.com/bitcoin/bitcoin>.\n \n This is experimental software.\n Distributed under the MIT software license, see the accompanying file COPYING\n-or <http://www.opensource.org/licenses/mit-license.php>.\n+or <https://opensource.org/licenses/MIT>\n \n This product includes software developed by the OpenSSL Project for use in the\n-OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written\n-by Eric Young and UPnP software written by Thomas Bernard.\n+OpenSSL Toolkit <https://www.openssl.org> and cryptographic software written by\n+Eric Young and UPnP software written by Thomas Bernard."
      },
      {
        "sha": "98adf2f5b1e5d7445326a0782ddd081a3e079b99",
        "filename": "doc/man/bitcoin-tx.1",
        "status": "modified",
        "additions": 25,
        "deletions": 10,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoin-tx.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoin-tx.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoin-tx.1?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,9 +1,9 @@\n-.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.5.\n-.TH BITCOIN-TX \"1\" \"September 2016\" \"bitcoin-tx v0.13.0.0\" \"User Commands\"\n+.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n+.TH BITCOIN-TX \"1\" \"February 2017\" \"bitcoin-tx v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoin-tx \\- manual page for bitcoin-tx v0.13.0.0\n+bitcoin-tx \\- manual page for bitcoin-tx v0.14.99.0\n .SH DESCRIPTION\n-Bitcoin Core bitcoin\\-tx utility version v0.13.0.0\n+Bitcoin Core bitcoin\\-tx utility version v0.14.99.0\n .SS \"Usage:\"\n .TP\n bitcoin\\-tx [options] <hex\\-tx> [commands]\n@@ -67,13 +67,28 @@ outaddr=VALUE:ADDRESS\n .IP\n Add address\\-based output to TX\n .IP\n+outpubkey=VALUE:PUBKEY[:FLAGS]\n+.IP\n+Add pay\\-to\\-pubkey output to TX. Optionally add the \"W\" flag to produce a\n+pay\\-to\\-witness\\-pubkey\\-hash output. Optionally add the \"S\" flag to\n+wrap the output in a pay\\-to\\-script\\-hash.\n+.IP\n outdata=[VALUE:]DATA\n .IP\n Add data\\-based output to TX\n .IP\n-outscript=VALUE:SCRIPT\n+outscript=VALUE:SCRIPT[:FLAGS]\n+.IP\n+Add raw script output to TX. Optionally add the \"W\" flag to produce a\n+pay\\-to\\-witness\\-script\\-hash output. Optionally add the \"S\" flag to\n+wrap the output in a pay\\-to\\-script\\-hash.\n+.IP\n+outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\n .IP\n-Add raw script output to TX\n+Add Pay To n\\-of\\-m Multi\\-sig output to TX. n = REQUIRED, m = PUBKEYS.\n+Optionally add the \"W\" flag to produce a\n+pay\\-to\\-witness\\-script\\-hash output. Optionally add the \"S\" flag to\n+wrap the output in a pay\\-to\\-script\\-hash.\n .IP\n sign=SIGHASH\\-FLAGS\n .IP\n@@ -92,16 +107,16 @@ set=NAME:JSON\\-STRING\n .IP\n Set register NAME to given JSON\\-STRING\n .SH COPYRIGHT\n-Copyright (C) 2009-2016 The Bitcoin Core developers\n+Copyright (C) 2009-2017 The Bitcoin Core developers\n \n Please contribute if you find Bitcoin Core useful. Visit\n <https://bitcoincore.org> for further information about the software.\n The source code is available from <https://github.com/bitcoin/bitcoin>.\n \n This is experimental software.\n Distributed under the MIT software license, see the accompanying file COPYING\n-or <http://www.opensource.org/licenses/mit-license.php>.\n+or <https://opensource.org/licenses/MIT>\n \n This product includes software developed by the OpenSSL Project for use in the\n-OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written\n-by Eric Young and UPnP software written by Thomas Bernard.\n+OpenSSL Toolkit <https://www.openssl.org> and cryptographic software written by\n+Eric Young and UPnP software written by Thomas Bernard."
      },
      {
        "sha": "fb066e0c6f310fbbe34423cff059052bcdf73af6",
        "filename": "doc/man/bitcoind.1",
        "status": "modified",
        "additions": 69,
        "deletions": 38,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/man/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoind.1?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,9 +1,9 @@\n-.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.5.\n-.TH BITCOIND \"1\" \"September 2016\" \"bitcoind v0.13.0.0\" \"User Commands\"\n+.\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n+.TH BITCOIND \"1\" \"February 2017\" \"bitcoind v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoind \\- manual page for bitcoind v0.13.0.0\n+bitcoind \\- manual page for bitcoind v0.14.99.0\n .SH DESCRIPTION\n-Bitcoin Core Daemon version v0.13.0.0\n+Bitcoin Core Daemon version v0.14.99.0\n .SS \"Usage:\"\n .TP\n bitcoind [options]\n@@ -28,13 +28,14 @@ long fork (%s in cmd is replaced by message)\n Execute command when the best block changes (%s in cmd is replaced by\n block hash)\n .HP\n-\\fB\\-checkblocks=\\fR<n>\n+\\fB\\-assumevalid=\\fR<hex>\n .IP\n-How many blocks to check at startup (default: 288, 0 = all)\n-.HP\n-\\fB\\-checklevel=\\fR<n>\n-.IP\n-How thorough the block verification of \\fB\\-checkblocks\\fR is (0\\-4, default: 3)\n+If this block is in the chain assume that it and its ancestors are valid\n+and potentially skip their script verification (0 to verify all,\n+default:\n+00000000000000000013176bf8d7dfeab4e1db31dc93bc311b436e82ab226b90,\n+testnet:\n+00000000000128796ee387cf110ccb9d2f36cffaf7f73079c995377c65ac0dcc)\n .HP\n \\fB\\-conf=\\fR<file>\n .IP\n@@ -67,11 +68,16 @@ Keep the transaction memory pool below <n> megabytes (default: 300)\n \\fB\\-mempoolexpiry=\\fR<n>\n .IP\n Do not keep transactions in the mempool longer than <n> hours (default:\n-72)\n+336)\n+.HP\n+\\fB\\-blockreconstructionextratxn=\\fR<n>\n+.IP\n+Extra transactions to keep in memory for compact block reconstructions\n+(default: 100)\n .HP\n \\fB\\-par=\\fR<n>\n .IP\n-Set the number of script verification threads (\\fB\\-4\\fR to 16, 0 = auto, <0 =\n+Set the number of script verification threads (\\fB\\-2\\fR to 16, 0 = auto, <0 =\n leave that many cores free, default: 0)\n .HP\n \\fB\\-pid=\\fR<file>\n@@ -80,13 +86,15 @@ Specify pid file (default: bitcoind.pid)\n .HP\n \\fB\\-prune=\\fR<n>\n .IP\n-Reduce storage requirements by enabling pruning (deleting) of old blocks.\n-This allows the pruneblockchain RPC to be called to delete specific blocks,\n-and enables automatic pruning of old blocks if a target size in MiB is\n-provided. This mode is incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR.\n-Warning: Reverting this setting requires re\\-downloading the entire blockchain.\n-(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >550 =\n-automatically prune block files to stay under the specified target size in MiB)\n+Reduce storage requirements by enabling pruning (deleting) of old\n+blocks. This allows the pruneblockchain RPC to be called to\n+delete specific blocks, and enables automatic pruning of old\n+blocks if a target size in MiB is provided. This mode is\n+incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR. Warning: Reverting this\n+setting requires re\\-downloading the entire blockchain. (default:\n+0 = disable pruning blocks, 1 = allow manual pruning via RPC,\n+>550 = automatically prune block files to stay under the\n+specified target size in MiB)\n .HP\n \\fB\\-reindex\\-chainstate\\fR\n .IP\n@@ -128,7 +136,8 @@ for IPv6\n .HP\n \\fB\\-connect=\\fR<ip>\n .IP\n-Connect only to the specified node(s)\n+Connect only to the specified node(s); \\fB\\-noconnect\\fR or \\fB\\-connect\\fR=\\fI\\,0\\/\\fR alone to\n+disable automatic connections\n .HP\n \\fB\\-discover\\fR\n .IP\n@@ -142,7 +151,7 @@ Allow DNS lookups for \\fB\\-addnode\\fR, \\fB\\-seednode\\fR and \\fB\\-connect\\fR (def\n \\fB\\-dnsseed\\fR\n .IP\n Query for peer addresses via DNS lookup, if low on addresses (default: 1\n-unless \\fB\\-connect\\fR)\n+unless \\fB\\-connect\\fR/\\-noconnect)\n .HP\n \\fB\\-externalip=\\fR<ip>\n .IP\n@@ -154,7 +163,8 @@ Always query for peer addresses via DNS lookup (default: 0)\n .HP\n \\fB\\-listen\\fR\n .IP\n-Accept connections from outside (default: 1 if no \\fB\\-proxy\\fR or \\fB\\-connect\\fR)\n+Accept connections from outside (default: 1 if no \\fB\\-proxy\\fR or\n+\\fB\\-connect\\fR/\\-noconnect)\n .HP\n \\fB\\-listenonion\\fR\n .IP\n@@ -209,6 +219,11 @@ Connect through SOCKS5 proxy\n Randomize credentials for every proxy connection. This enables Tor\n stream isolation (default: 1)\n .HP\n+\\fB\\-rpcserialversion\\fR\n+.IP\n+Sets the serialization of raw transaction or block hex returned in\n+non\\-verbose mode, non\\-segwit(0) or segwit(1) (default: 1)\n+.HP\n \\fB\\-seednode=\\fR<ip>\n .IP\n Connect to a node to retrieve peer addresses, and disconnect\n@@ -226,17 +241,22 @@ Tor control port to use if onion listening enabled (default:\n .IP\n Tor control port password (default: empty)\n .HP\n+\\fB\\-upnp\\fR\n+.IP\n+Use UPnP to map the listening port (default: 0)\n+.HP\n \\fB\\-whitebind=\\fR<addr>\n .IP\n Bind to given address and whitelist peers connecting to it. Use\n [host]:port notation for IPv6\n .HP\n-\\fB\\-whitelist=\\fR<netmask>\n+\\fB\\-whitelist=\\fR<IP address or network>\n .IP\n-Whitelist peers connecting from the given netmask or IP address. Can be\n-specified multiple times. Whitelisted peers cannot be DoS banned\n-and their transactions are always relayed, even if they are\n-already in the mempool, useful e.g. for a gateway\n+Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or\n+CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple\n+times. Whitelisted peers cannot be DoS banned and their\n+transactions are always relayed, even if they are already in the\n+mempool, useful e.g. for a gateway\n .HP\n \\fB\\-whitelistrelay\\fR\n .IP\n@@ -245,7 +265,7 @@ not relaying transactions (default: 1)\n .HP\n \\fB\\-whitelistforcerelay\\fR\n .IP\n-Force relay of transactions from whitelisted peers even they violate\n+Force relay of transactions from whitelisted peers even if they violate\n local relay policy (default: 1)\n .HP\n \\fB\\-maxuploadtarget=\\fR<n>\n@@ -292,13 +312,17 @@ Spend unconfirmed change when sending transactions (default: 1)\n \\fB\\-txconfirmtarget=\\fR<n>\n .IP\n If paytxfee is not set, include enough fee so transactions begin\n-confirmation on average within n blocks (default: 2)\n+confirmation on average within n blocks (default: 6)\n .HP\n \\fB\\-usehd\\fR\n .IP\n Use hierarchical deterministic key generation (HD) after BIP32. Only has\n effect during wallet creation/first start (default: 1)\n .HP\n+\\fB\\-walletrbf\\fR\n+.IP\n+Send transactions with full\\-RBF opt\\-in enabled (default: 0)\n+.HP\n \\fB\\-upgradewallet\\fR\n .IP\n Upgrade wallet to latest format on startup\n@@ -352,9 +376,9 @@ Append comment to the user agent string\n Output debugging information (default: 0, supplying <category> is\n optional). If <category> is not supplied or if <category> = 1,\n output all debugging information.<category> can be: addrman,\n-alert, bench, coindb, db, http, libevent, lock, mempool,\n-mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins,\n-tor, zmq.\n+alert, bench, cmpctblock, coindb, db, http, libevent, lock,\n+mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc,\n+selectcoins, tor, zmq.\n .HP\n \\fB\\-help\\-debug\\fR\n .IP\n@@ -427,6 +451,11 @@ Set maximum block size in bytes (default: 750000)\n .IP\n Set maximum size of high\\-priority/low\\-fee transactions in bytes\n (default: 0)\n+.HP\n+\\fB\\-blockmintxfee=\\fR<amt>\n+.IP\n+Set lowest fee rate (in BTC/kB) for transactions to be included in block\n+creation. (default: 0.00001)\n .PP\n RPC server options:\n .HP\n@@ -460,8 +489,10 @@ Password for JSON\\-RPC connections\n .IP\n Username and hashed password for JSON\\-RPC connections. The field\n <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A\n-canonical python script is included in share/rpcuser. This option\n-can be specified multiple times\n+canonical python script is included in share/rpcuser. The client\n+then connects normally using the\n+rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This\n+option can be specified multiple times\n .HP\n \\fB\\-rpcport=\\fR<port>\n .IP\n@@ -479,16 +510,16 @@ option can be specified multiple times\n .IP\n Set the number of threads to service RPC calls (default: 4)\n .SH COPYRIGHT\n-Copyright (C) 2009-2016 The Bitcoin Core developers\n+Copyright (C) 2009-2017 The Bitcoin Core developers\n \n Please contribute if you find Bitcoin Core useful. Visit\n <https://bitcoincore.org> for further information about the software.\n The source code is available from <https://github.com/bitcoin/bitcoin>.\n \n This is experimental software.\n Distributed under the MIT software license, see the accompanying file COPYING\n-or <http://www.opensource.org/licenses/mit-license.php>.\n+or <https://opensource.org/licenses/MIT>\n \n This product includes software developed by the OpenSSL Project for use in the\n-OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software written\n-by Eric Young and UPnP software written by Thomas Bernard.\n+OpenSSL Toolkit <https://www.openssl.org> and cryptographic software written by\n+Eric Young and UPnP software written by Thomas Bernard."
      },
      {
        "sha": "eaa0b330ebb9ae09e672be83cb10c3bfffafa73f",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 0,
        "deletions": 111,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -33,117 +33,6 @@ frequently tested on them.\n Notable changes\n ===============\n \n-Low-level RPC changes\n-----------------------\n-\n-- `importprunedfunds` only accepts two required arguments. Some versions accept\n-  an optional third arg, which was always ignored. Make sure to never pass more\n-  than two arguments.\n-\n-Fee Estimation Changes\n-----------------------\n-\n-- Since 0.13.2 fee estimation for a confirmation target of 1 block has been\n-  disabled. This is only a minor behavior change as there was often insufficient\n-  data for this target anyway. `estimatefee 1` will now always return -1 and\n-  `estimatesmartfee 1` will start searching at a target of 2.\n-\n-- The default target for fee estimation is changed to 6 blocks in both the GUI\n-  (previously 25) and for RPC calls (previously 2).\n-\n-Removal of Priority Estimation\n--------------------------------\n-\n-- Estimation of \"priority\" needed for a transaction to be included within a target\n-  number of blocks has been removed.  The rpc calls are deprecated and will either\n-  return -1 or 1e24 appropriately. The format for `fee_estimates.dat` has also\n-  changed to no longer save these priority estimates. It will automatically be\n-  converted to the new format which is not readable by prior versions of the\n-  software.\n-\n-- The concept of \"priority\" (coin age) transactions is planned to be removed in\n-  the next major version. To prepare for this, the default for the rate limit of\n-  priority transactions (`-limitfreerelay`) has been set to `0` kB/minute. This\n-  is not to be confused with the `prioritisetransaction` RPC which will remain\n-  supported for adding fee deltas to transactions.\n-\n-P2P connection management\n---------------------------\n-\n-- Peers manually added through the addnode option or addnode RPC now have their own\n-  limit of eight connections which does not compete with other inbound or outbound\n-  connection usage and is not subject to the maxconnections limitation.\n-\n-- New connections to manually added peers are much faster.\n-\n-Introduction of assumed-valid blocks\n--------------------------------------\n-\n-- A significant portion of the initial block download time is spent verifying\n-  scripts/signatures.  Although the verification must pass to ensure the security\n-  of the system, no other result from this verification is needed: If the node\n-  knew the history of a given block were valid it could skip checking scripts\n-  for its ancestors.\n-\n-- A new configuration option 'assumevalid' is provided to express this knowledge\n-  to the software.  Unlike the 'checkpoints' in the past this setting does not\n-  force the use of a particular chain: chains that are consistent with it are\n-  processed quicker, but other chains are still accepted if they'd otherwise\n-  be chosen as best. Also unlike 'checkpoints' the user can configure which\n-  block history is assumed true, this means that even outdated software can\n-  sync more quickly if the setting is updated by the user.\n-\n-- Because the validity of a chain history is a simple objective fact it is much\n-  easier to review this setting.  As a result the software ships with a default\n-  value adjusted to match the current chain shortly before release.  The use\n-  of this default value can be disabled by setting -assumevalid=0\n-\n-0.14.0 Change log\n-=================\n-\n-Detailed release notes follow. This overview includes changes that affect\n-behavior, not code moves, refactors and string updates. For convenience in locating\n-the code changes and accompanying discussion, both the pull request and\n-git merge commit are mentioned.\n-\n-### RPC and REST\n-\n-UTXO set query (`GET /rest/getutxos/<checkmempool>/<txid>-<n>/<txid>-<n>/.../<txid>-<n>.<bin|hex|json>`) responses\n-were changed to return status code HTTP_BAD_REQUEST (400) instead of HTTP_INTERNAL_SERVER_ERROR (500) when requests\n-contain invalid parameters.\n-\n-The first boolean argument to `getaddednodeinfo` has been removed. This is an incompatible change.\n-\n-Call \"getmininginfo\" loses the \"testnet\" field in favor of the more generic \"chain\" (which has been present for years).\n-\n-### Configuration and command-line options\n-\n-### Block and transaction handling\n-\n-### P2P protocol and network code\n-\n-### Validation\n-\n-### Build system\n-\n-### Wallet\n-\n-0.14.0 Fundrawtransaction change address reuse\n-==============================================\n-\n-Before 0.14, `fundrawtransaction` was by default wallet stateless. In almost all cases `fundrawtransaction` does add a change-output to the outputs of the funded transaction. Before 0.14, the used keypool key was never marked as change-address key and directly returned to the keypool (leading to address reuse).\n-Before 0.14, calling `getnewaddress` directly after `fundrawtransaction` did generate the same address as the change-output address.\n-\n-Since 0.14, fundrawtransaction does reserve the change-output-key from the keypool by default (optional by setting  `reserveChangeKey`, default = `true`)\n-\n-Users should also consider using `getrawchangeaddress()` in conjunction with `fundrawtransaction`'s `changeAddress` option.\n-\n-### GUI\n-\n-### Tests\n-\n-### Miscellaneous\n-\n Credits\n =======\n "
      },
      {
        "sha": "1702637d53ebd7a0c2f827ed114260d0f515ee51",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -4,7 +4,7 @@ Translations\n The Bitcoin-Core project has been designed to support multiple localisations. This makes adding new phrases, and completely new languages easily achievable. For managing all application translations, Bitcoin-Core makes use of the Transifex online translation management tool.\n \n ### Helping to translate (using Transifex)\n-Transifex is setup to monitor the Github repo for updates, and when code containing new translations is found, Transifex will process any changes. It may take several hours after a pull-request has been merged, to appear in the Transifex web interface.\n+Transifex is setup to monitor the GitHub repo for updates, and when code containing new translations is found, Transifex will process any changes. It may take several hours after a pull-request has been merged, to appear in the Transifex web interface.\n \n Multiple language support is critical in assisting Bitcoin\u2019s global adoption, and growth. One of Bitcoin\u2019s greatest strengths is cross-border money transfers, any help making that easier is greatly appreciated.\n \n@@ -32,7 +32,7 @@ QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n ### Creating a pull-request\n For general PRs, you shouldn\u2019t include any updates to the translation source files. They will be updated periodically, primarily around pre-releases, allowing time for any new phrases to be translated before public releases. This is also important in avoiding translation related merge conflicts.\n \n-When an updated source file is merged into the Github repo, Transifex will automatically detect it (although it can take several hours). Once processed, the new strings will show up as \"Remaining\" in the Transifex web interface and are ready for translators.\n+When an updated source file is merged into the GitHub repo, Transifex will automatically detect it (although it can take several hours). Once processed, the new strings will show up as \"Remaining\" in the Transifex web interface and are ready for translators.\n \n To create the pull-request, use the following commands:\n ```"
      },
      {
        "sha": "1019ff6653b7842f0e18371bc577eeb1faebd313",
        "filename": "doc/zmq.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/doc/zmq.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/doc/zmq.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/zmq.md?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1,4 +1,4 @@\n-# Block and Transaction Broadcasting With ZeroMQ\n+# Block and Transaction Broadcasting with ZeroMQ\n \n [ZeroMQ](http://zeromq.org/) is a lightweight wrapper around TCP\n connections, inter-process communication, and shared-memory,\n@@ -50,7 +50,7 @@ during the *configure* step of building bitcoind:\n     $ ./configure --disable-zmq (other options)\n \n To actually enable operation, one must set the appropriate options on\n-the commandline or in the configuration file.\n+the command line or in the configuration file.\n \n ## Usage\n "
      },
      {
        "sha": "973165c4c8b6aea745da5271a7d352d574d839fb",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 135,
        "deletions": 116,
        "changes": 251,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -2,25 +2,21 @@\n # Copyright (c) 2014-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n \"\"\"\n-Run Regression Test Suite\n+rpc-tests.py - run regression test suite\n \n This module calls down into individual test cases via subprocess. It will\n-forward all unrecognized arguments onto the individual test scripts, other\n-than:\n+forward all unrecognized arguments onto the individual test scripts.\n \n-    - `-extended`: run the \"extended\" test suite in addition to the basic one.\n-    - `-win`: signal that this is running in a Windows environment, and we\n-      should run the tests.\n-    - `--coverage`: this generates a basic coverage report for the RPC\n-      interface.\n+RPC tests are disabled on Windows by default. Use --force to run them anyway.\n \n For a description of arguments recognized by test scripts, see\n `qa/pull-tester/test_framework/test_framework.py:BitcoinTestFramework.main`.\n \n \"\"\"\n \n+import argparse\n+import configparser\n import os\n import time\n import shutil\n@@ -29,77 +25,9 @@\n import tempfile\n import re\n \n-sys.path.append(\"qa/pull-tester/\")\n-from tests_config import *\n-\n-BOLD = (\"\",\"\")\n-if os.name == 'posix':\n-    # primitive formatting on supported\n-    # terminal via ANSI escape sequences:\n-    BOLD = ('\\033[0m', '\\033[1m')\n-\n-RPC_TESTS_DIR = SRCDIR + '/qa/rpc-tests/'\n-\n-#If imported values are not defined then set to zero (or disabled)\n-if 'ENABLE_WALLET' not in vars():\n-    ENABLE_WALLET=0\n-if 'ENABLE_BITCOIND' not in vars():\n-    ENABLE_BITCOIND=0\n-if 'ENABLE_UTILS' not in vars():\n-    ENABLE_UTILS=0\n-if 'ENABLE_ZMQ' not in vars():\n-    ENABLE_ZMQ=0\n-\n-ENABLE_COVERAGE=0\n-\n-#Create a set to store arguments and create the passon string\n-opts = set()\n-passon_args = []\n-PASSON_REGEX = re.compile(\"^--\")\n-PARALLEL_REGEX = re.compile('^-parallel=')\n-\n-print_help = False\n-run_parallel = 4\n-\n-for arg in sys.argv[1:]:\n-    if arg == \"--help\" or arg == \"-h\" or arg == \"-?\":\n-        print_help = True\n-        break\n-    if arg == '--coverage':\n-        ENABLE_COVERAGE = 1\n-    elif PASSON_REGEX.match(arg):\n-        passon_args.append(arg)\n-    elif PARALLEL_REGEX.match(arg):\n-        run_parallel = int(arg.split(sep='=', maxsplit=1)[1])\n-    else:\n-        opts.add(arg)\n-\n-#Set env vars\n-if \"BITCOIND\" not in os.environ:\n-    os.environ[\"BITCOIND\"] = BUILDDIR + '/src/bitcoind' + EXEEXT\n-\n-if EXEEXT == \".exe\" and \"-win\" not in opts:\n-    # https://github.com/bitcoin/bitcoin/commit/d52802551752140cf41f0d9a225a43e84404d3e9\n-    # https://github.com/bitcoin/bitcoin/pull/5677#issuecomment-136646964\n-    print(\"Win tests currently disabled by default.  Use -win option to enable\")\n-    sys.exit(0)\n-\n-if not (ENABLE_WALLET == 1 and ENABLE_UTILS == 1 and ENABLE_BITCOIND == 1):\n-    print(\"No rpc tests to run. Wallet, utils, and bitcoind must all be enabled\")\n-    sys.exit(0)\n-\n-# python3-zmq may not be installed. Handle this gracefully and with some helpful info\n-if ENABLE_ZMQ:\n-    try:\n-        import zmq\n-    except ImportError:\n-        print(\"ERROR: \\\"import zmq\\\" failed. Set ENABLE_ZMQ=0 or \"\n-              \"to run zmq tests, see dependency info in /qa/README.md.\")\n-        # ENABLE_ZMQ=0\n-        raise\n-\n-testScripts = [\n-    # longest test should go first, to favor running tests in parallel\n+BASE_SCRIPTS= [\n+    # Scripts that are run by the travis build process.\n+    # Longest test should go first, to favor running tests in parallel\n     'wallet-hd.py',\n     'walletbackup.py',\n     # vv Tests less than 5m vv\n@@ -154,11 +82,17 @@\n     'bumpfee.py',\n     'rpcnamedargs.py',\n     'listsinceblock.py',\n+    'p2p-leaktests.py',\n ]\n-if ENABLE_ZMQ:\n-    testScripts.append('zmq_test.py')\n \n-testScriptsExt = [\n+ZMQ_SCRIPTS = [\n+    # ZMQ test can only be run if bitcoin was built with zmq-enabled.\n+    # call rpc_tests.py with -nozmq to explicitly exclude these tests.\n+    \"zmq_test.py\"]\n+\n+EXTENDED_SCRIPTS = [\n+    # These tests are not run by the travis build process.\n+    # Longest test should go first, to favor running tests in parallel\n     'pruning.py',\n     # vv Tests less than 20m vv\n     'smartfees.py',\n@@ -168,6 +102,7 @@\n     # vv Tests less than 2m vv\n     'bip68-sequence.py',\n     'getblocktemplate_longpoll.py',\n+    'p2p-timeouts.py',\n     # vv Tests less than 60s vv\n     'bip9-softforks.py',\n     'p2p-feefilter.py',\n@@ -187,44 +122,126 @@\n     'replace-by-fee.py',\n ]\n \n+ALL_SCRIPTS = BASE_SCRIPTS + ZMQ_SCRIPTS + EXTENDED_SCRIPTS\n+\n+def main():\n+    # Parse arguments and pass through unrecognised args\n+    parser = argparse.ArgumentParser(add_help=False,\n+                                     usage='%(prog)s [rpc-test.py options] [script options] [scripts]',\n+                                     description=__doc__,\n+                                     epilog='''\n+    Help text and arguments for individual test script:''',\n+                                     formatter_class=argparse.RawTextHelpFormatter)\n+    parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n+    parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n+    parser.add_argument('--force', '-f', action='store_true', help='run tests even on platforms where they are disabled by default (e.g. windows).')\n+    parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n+    parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n+    parser.add_argument('--nozmq', action='store_true', help='do not run the zmq tests')\n+    args, unknown_args = parser.parse_known_args()\n+\n+    # Create a set to store arguments and create the passon string\n+    tests = set(arg for arg in unknown_args if arg[:2] != \"--\")\n+    passon_args = [arg for arg in unknown_args if arg[:2] == \"--\"]\n+\n+    # Read config generated by configure.\n+    config = configparser.ConfigParser()\n+    config.read_file(open(os.path.dirname(__file__) + \"/tests_config.ini\"))\n+\n+    enable_wallet = config[\"components\"].getboolean(\"ENABLE_WALLET\")\n+    enable_utils = config[\"components\"].getboolean(\"ENABLE_UTILS\")\n+    enable_bitcoind = config[\"components\"].getboolean(\"ENABLE_BITCOIND\")\n+    enable_zmq = config[\"components\"].getboolean(\"ENABLE_ZMQ\") and not args.nozmq\n+\n+    if config[\"environment\"][\"EXEEXT\"] == \".exe\" and not args.force:\n+        # https://github.com/bitcoin/bitcoin/commit/d52802551752140cf41f0d9a225a43e84404d3e9\n+        # https://github.com/bitcoin/bitcoin/pull/5677#issuecomment-136646964\n+        print(\"Tests currently disabled on Windows by default. Use --force option to enable\")\n+        sys.exit(0)\n \n-def runtests():\n-    test_list = []\n-    if '-extended' in opts:\n-        test_list = testScripts + testScriptsExt\n-    elif len(opts) == 0 or (len(opts) == 1 and \"-win\" in opts):\n-        test_list = testScripts\n-    else:\n-        for t in testScripts + testScriptsExt:\n-            if t in opts or re.sub(\".py$\", \"\", t) in opts:\n-                test_list.append(t)\n+    if not (enable_wallet and enable_utils and enable_bitcoind):\n+        print(\"No rpc tests to run. Wallet, utils, and bitcoind must all be enabled\")\n+        print(\"Rerun `configure` with -enable-wallet, -with-utils and -with-daemon and rerun make\")\n+        sys.exit(0)\n+\n+    # python3-zmq may not be installed. Handle this gracefully and with some helpful info\n+    if enable_zmq:\n+        try:\n+            import zmq\n+        except ImportError:\n+            print(\"ERROR: \\\"import zmq\\\" failed. Use -nozmq to run without the ZMQ tests.\"\n+                  \"To run zmq tests, see dependency info in /qa/README.md.\")\n+            raise\n+\n+    # Build list of tests\n+    if tests:\n+        # Individual tests have been specified. Run specified tests that exist\n+        # in the ALL_SCRIPTS list. Accept the name with or without .py extension.\n+        test_list = [t for t in ALL_SCRIPTS if\n+                (t in tests or re.sub(\".py$\", \"\", t) in tests)]\n+        if not test_list:\n+            print(\"No valid test scripts specified. Check that your test is in one \"\n+                  \"of the test lists in rpc-tests.py or run rpc-tests.py with no arguments to run all tests\")\n+            print(\"Scripts not found:\")\n+            print(tests)\n+            sys.exit(0)\n \n-    if print_help:\n-        # Only print help of the first script and exit\n-        subprocess.check_call((RPC_TESTS_DIR + test_list[0]).split() + ['-h'])\n+    else:\n+        # No individual tests have been specified. Run base tests, and\n+        # optionally ZMQ tests and extended tests.\n+        test_list = BASE_SCRIPTS\n+        if enable_zmq:\n+            test_list += ZMQ_SCRIPTS\n+        if args.extended:\n+            test_list += EXTENDED_SCRIPTS\n+            # TODO: BASE_SCRIPTS and EXTENDED_SCRIPTS are sorted by runtime\n+            # (for parallel running efficiency). This combined list will is no\n+            # longer sorted.\n+\n+    if args.help:\n+        # Print help for rpc-tests.py, then print help of the first script and exit.\n+        parser.print_help()\n+        subprocess.check_call((config[\"environment\"][\"SRCDIR\"] + '/qa/rpc-tests/' + test_list[0]).split() + ['-h'])\n         sys.exit(0)\n \n-    coverage = None\n+    run_tests(test_list, config[\"environment\"][\"SRCDIR\"], config[\"environment\"][\"BUILDDIR\"], config[\"environment\"][\"EXEEXT\"], args.jobs, args.coverage, passon_args)\n+\n+def run_tests(test_list, src_dir, build_dir, exeext, jobs=1, enable_coverage=False, args=[]):\n+    BOLD = (\"\",\"\")\n+    if os.name == 'posix':\n+        # primitive formatting on supported\n+        # terminal via ANSI escape sequences:\n+        BOLD = ('\\033[0m', '\\033[1m')\n+\n+    #Set env vars\n+    if \"BITCOIND\" not in os.environ:\n+        os.environ[\"BITCOIND\"] = build_dir + '/src/bitcoind' + exeext\n+\n+    tests_dir = src_dir + '/qa/rpc-tests/'\n \n-    if ENABLE_COVERAGE:\n+    flags = [\"--srcdir=\" + src_dir] + args\n+    flags.append(\"--cachedir=%s/qa/cache\" % build_dir)\n+\n+    if enable_coverage:\n         coverage = RPCCoverage()\n-        print(\"Initializing coverage directory at %s\\n\" % coverage.dir)\n-    flags = [\"--srcdir=%s/src\" % BUILDDIR] + passon_args\n-    flags.append(\"--cachedir=%s/qa/cache\" % BUILDDIR)\n-    if coverage:\n         flags.append(coverage.flag)\n+        print(\"Initializing coverage directory at %s\\n\" % coverage.dir)\n+    else:\n+        coverage = None\n \n-    if len(test_list) > 1 and run_parallel > 1:\n+    if len(test_list) > 1 and jobs > 1:\n         # Populate cache\n-        subprocess.check_output([RPC_TESTS_DIR + 'create_cache.py'] + flags)\n+        subprocess.check_output([tests_dir + 'create_cache.py'] + flags)\n \n     #Run Tests\n-    max_len_name = len(max(test_list, key=len))\n+    all_passed = True\n     time_sum = 0\n     time0 = time.time()\n-    job_queue = RPCTestHandler(run_parallel, test_list, flags)\n+\n+    job_queue = RPCTestHandler(jobs, tests_dir, test_list, flags)\n+\n+    max_len_name = len(max(test_list, key=len))\n     results = BOLD[1] + \"%s | %s | %s\\n\\n\" % (\"TEST\".ljust(max_len_name), \"PASSED\", \"DURATION\") + BOLD[0]\n-    all_passed = True\n     for _ in range(len(test_list)):\n         (name, stdout, stderr, passed, duration) = job_queue.get_next()\n         all_passed = all_passed and passed\n@@ -233,8 +250,10 @@ def runtests():\n         print('\\n' + BOLD[1] + name + BOLD[0] + \":\")\n         print('' if passed else stdout + '\\n', end='')\n         print('' if stderr == '' else 'stderr:\\n' + stderr + '\\n', end='')\n-        results += \"%s | %s | %s s\\n\" % (name.ljust(max_len_name), str(passed).ljust(6), duration)\n         print(\"Pass: %s%s%s, Duration: %s s\\n\" % (BOLD[1], passed, BOLD[0], duration))\n+\n+        results += \"%s | %s | %s s\\n\" % (name.ljust(max_len_name), str(passed).ljust(6), duration)\n+\n     results += BOLD[1] + \"\\n%s | %s | %s s (accumulated)\" % (\"ALL\".ljust(max_len_name), str(all_passed).ljust(6), time_sum) + BOLD[0]\n     print(results)\n     print(\"\\nRuntime: %s s\" % (int(time.time() - time0)))\n@@ -247,15 +266,15 @@ def runtests():\n \n     sys.exit(not all_passed)\n \n-\n class RPCTestHandler:\n     \"\"\"\n     Trigger the testscrips passed in via the list.\n     \"\"\"\n \n-    def __init__(self, num_tests_parallel, test_list=None, flags=None):\n+    def __init__(self, num_tests_parallel, tests_dir, test_list=None, flags=None):\n         assert(num_tests_parallel >= 1)\n         self.num_jobs = num_tests_parallel\n+        self.tests_dir = tests_dir\n         self.test_list = test_list\n         self.flags = flags\n         self.num_running = 0\n@@ -275,7 +294,7 @@ def get_next(self):\n             log_stderr = tempfile.SpooledTemporaryFile(max_size=2**16)\n             self.jobs.append((t,\n                               time.time(),\n-                              subprocess.Popen((RPC_TESTS_DIR + t).split() + self.flags + port_seed,\n+                              subprocess.Popen((self.tests_dir + t).split() + self.flags + port_seed,\n                                                universal_newlines=True,\n                                                stdout=log_stdout,\n                                                stderr=log_stderr),\n@@ -340,10 +359,10 @@ def _get_uncovered_rpc_commands(self):\n \n         \"\"\"\n         # This is shared from `qa/rpc-tests/test-framework/coverage.py`\n-        REFERENCE_FILENAME = 'rpc_interface.txt'\n-        COVERAGE_FILE_PREFIX = 'coverage.'\n+        reference_filename = 'rpc_interface.txt'\n+        coverage_file_prefix = 'coverage.'\n \n-        coverage_ref_filename = os.path.join(self.dir, REFERENCE_FILENAME)\n+        coverage_ref_filename = os.path.join(self.dir, reference_filename)\n         coverage_filenames = set()\n         all_cmds = set()\n         covered_cmds = set()\n@@ -356,7 +375,7 @@ def _get_uncovered_rpc_commands(self):\n \n         for root, dirs, files in os.walk(self.dir):\n             for filename in files:\n-                if filename.startswith(COVERAGE_FILE_PREFIX):\n+                if filename.startswith(coverage_file_prefix):\n                     coverage_filenames.add(os.path.join(root, filename))\n \n         for filename in coverage_filenames:\n@@ -367,4 +386,4 @@ def _get_uncovered_rpc_commands(self):\n \n \n if __name__ == '__main__':\n-    runtests()\n+    main()"
      },
      {
        "sha": "e3e457d0b1d120c13036c5cbfb84004b7168a361",
        "filename": "qa/pull-tester/tests_config.ini.in",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/pull-tester/tests_config.ini.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/pull-tester/tests_config.ini.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/tests_config.ini.in?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -0,0 +1,18 @@\n+# Copyright (c) 2013-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# These environment variables are set by the build process and read by\n+# rpc-tests.py\n+\n+[environment]\n+SRCDIR=@abs_top_srcdir@\n+BUILDDIR=@abs_top_builddir@\n+EXEEXT=@EXEEXT@\n+\n+[components]\n+# Which components are enabled. These are commented out by `configure` if they were disabled when running config.\n+@ENABLE_WALLET_TRUE@ENABLE_WALLET=true\n+@BUILD_BITCOIN_UTILS_TRUE@ENABLE_UTILS=true\n+@BUILD_BITCOIND_TRUE@ENABLE_BITCOIND=true\n+@ENABLE_ZMQ_TRUE@ENABLE_ZMQ=true"
      },
      {
        "sha": "a0d0a3d98a86becd64c699fa8bb67bb2ae79629c",
        "filename": "qa/pull-tester/tests_config.py.in",
        "status": "removed",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/qa/pull-tester/tests_config.py.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64aa36e20368fa16d4ff757d56dc2690ed0f48ba/qa/pull-tester/tests_config.py.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/tests_config.py.in?ref=64aa36e20368fa16d4ff757d56dc2690ed0f48ba",
        "patch": "@@ -1,14 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2013-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-SRCDIR=\"@abs_top_srcdir@\"\n-BUILDDIR=\"@abs_top_builddir@\"\n-EXEEXT=\"@EXEEXT@\"\n-\n-# These will turn into comments if they were disabled when configuring.\n-@ENABLE_WALLET_TRUE@ENABLE_WALLET=1\n-@BUILD_BITCOIN_UTILS_TRUE@ENABLE_UTILS=1\n-@BUILD_BITCOIND_TRUE@ENABLE_BITCOIND=1\n-@ENABLE_ZMQ_TRUE@ENABLE_ZMQ=1"
      },
      {
        "sha": "e03bc1c37b6dcab4c9fee75032b4ef3385c5370d",
        "filename": "qa/rpc-tests/bip68-112-113-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/bip68-112-113-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/bip68-112-113-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-112-113-p2p.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -5,7 +5,7 @@\n \n from test_framework.test_framework import ComparisonTestFramework\n from test_framework.util import *\n-from test_framework.mininode import ToHex, CTransaction, NetworkThread\n+from test_framework.mininode import ToHex, NetworkThread\n from test_framework.blocktools import create_coinbase, create_block\n from test_framework.comptool import TestInstance, TestManager\n from test_framework.script import *"
      },
      {
        "sha": "1b099f933967524d9826229e270e78fa13b9188c",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -9,8 +9,6 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.script import *\n-from test_framework.mininode import *\n from test_framework.blocktools import *\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)"
      },
      {
        "sha": "e02cb4c300b039ac25a25365edf66ceb750229b3",
        "filename": "qa/rpc-tests/bumpfee.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bumpfee.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -8,10 +8,8 @@\n from test_framework import blocktools\n from test_framework.mininode import CTransaction\n from test_framework.util import *\n-from test_framework.util import *\n \n import io\n-import time\n \n # Sequence number that is BIP 125 opt-in and BIP 68-compliant\n BIP125_SEQUENCE_NUMBER = 0xfffffffd"
      },
      {
        "sha": "54cc6d2642adff69688326786b403048b102fb38",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 142,
        "deletions": 112,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -2,54 +2,105 @@\n # Copyright (c) 2014-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n+\"\"\"Test rescan behavior of importaddress, importpubkey, importprivkey, and\n+importmulti RPCs with different types of keys and rescan options.\n+\n+In the first part of the test, node 0 creates an address for each type of\n+import RPC call and sends BTC to it. Then other nodes import the addresses,\n+and the test makes listtransactions and getbalance calls to confirm that the\n+importing node either did or did not execute rescans picking up the send\n+transactions.\n+\n+In the second part of the test, node 0 sends more BTC to each address, and the\n+test makes more listtransactions and getbalance calls to confirm that the\n+importing nodes pick up the new transactions regardless of whether rescans\n+happened previously.\n+\"\"\"\n+\n+from test_framework.authproxy import JSONRPCException\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal)\n+from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal, set_node_times)\n from decimal import Decimal\n \n import collections\n import enum\n import itertools\n-import functools\n \n Call = enum.Enum(\"Call\", \"single multi\")\n Data = enum.Enum(\"Data\", \"address pub priv\")\n-ImportNode = collections.namedtuple(\"ImportNode\", \"rescan\")\n-\n-\n-def call_import_rpc(call, data, address, scriptPubKey, pubkey, key, label, node, rescan):\n-    \"\"\"Helper that calls a wallet import RPC on a bitcoin node.\"\"\"\n-    watchonly = data != Data.priv\n-    if call == Call.single:\n-        if data == Data.address:\n-            response = node.importaddress(address, label, rescan)\n-        elif data == Data.pub:\n-            response = node.importpubkey(pubkey, label, rescan)\n-        elif data == Data.priv:\n-            response = node.importprivkey(key, label, rescan)\n-        assert_equal(response, None)\n-    elif call == Call.multi:\n-        response = node.importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"pubkeys\": [pubkey] if data == Data.pub else [],\n-            \"keys\": [key] if data == Data.priv else [],\n-            \"label\": label,\n-            \"watchonly\": watchonly\n-        }], {\"rescan\": rescan})\n-        assert_equal(response, [{\"success\": True}])\n-    return watchonly\n-\n-\n-# List of RPCs that import a wallet key or address in various ways.\n-IMPORT_RPCS = [functools.partial(call_import_rpc, call, data) for call, data in itertools.product(Call, Data)]\n-\n-# List of bitcoind nodes that will import keys.\n-IMPORT_NODES = [\n-    ImportNode(rescan=True),\n-    ImportNode(rescan=False),\n-]\n+Rescan = enum.Enum(\"Rescan\", \"no yes late_timestamp\")\n+\n+\n+class Variant(collections.namedtuple(\"Variant\", \"call data rescan prune\")):\n+    \"\"\"Helper for importing one key and verifying scanned transactions.\"\"\"\n+\n+    def do_import(self, timestamp):\n+        \"\"\"Call one key import RPC.\"\"\"\n+\n+        if self.call == Call.single:\n+            if self.data == Data.address:\n+                response, error = try_rpc(self.node.importaddress, self.address[\"address\"], self.label,\n+                                          self.rescan == Rescan.yes)\n+            elif self.data == Data.pub:\n+                response, error = try_rpc(self.node.importpubkey, self.address[\"pubkey\"], self.label,\n+                                          self.rescan == Rescan.yes)\n+            elif self.data == Data.priv:\n+                response, error = try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n+            assert_equal(response, None)\n+            assert_equal(error, {'message': 'Rescan is disabled in pruned mode',\n+                                 'code': -4} if self.expect_disabled else None)\n+        elif self.call == Call.multi:\n+            response = self.node.importmulti([{\n+                \"scriptPubKey\": {\n+                    \"address\": self.address[\"address\"]\n+                },\n+                \"timestamp\": timestamp + RESCAN_WINDOW + (1 if self.rescan == Rescan.late_timestamp else 0),\n+                \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n+                \"keys\": [self.key] if self.data == Data.priv else [],\n+                \"label\": self.label,\n+                \"watchonly\": self.data != Data.priv\n+            }], {\"rescan\": self.rescan in (Rescan.yes, Rescan.late_timestamp)})\n+            assert_equal(response, [{\"success\": True}])\n+\n+    def check(self, txid=None, amount=None, confirmations=None):\n+        \"\"\"Verify that getbalance/listtransactions return expected values.\"\"\"\n+\n+        balance = self.node.getbalance(self.label, 0, True)\n+        assert_equal(balance, self.expected_balance)\n+\n+        txs = self.node.listtransactions(self.label, 10000, 0, True)\n+        assert_equal(len(txs), self.expected_txs)\n+\n+        if txid is not None:\n+            tx, = [tx for tx in txs if tx[\"txid\"] == txid]\n+            assert_equal(tx[\"account\"], self.label)\n+            assert_equal(tx[\"address\"], self.address[\"address\"])\n+            assert_equal(tx[\"amount\"], amount)\n+            assert_equal(tx[\"category\"], \"receive\")\n+            assert_equal(tx[\"label\"], self.label)\n+            assert_equal(tx[\"txid\"], txid)\n+            assert_equal(tx[\"confirmations\"], confirmations)\n+            assert_equal(\"trusted\" not in tx, True)\n+            if self.data != Data.priv:\n+                assert_equal(tx[\"involvesWatchonly\"], True)\n+            else:\n+                assert_equal(\"involvesWatchonly\" not in tx, True)\n+\n+\n+# List of Variants for each way a key or address could be imported.\n+IMPORT_VARIANTS = [Variant(*variants) for variants in itertools.product(Call, Data, Rescan, (False, True))]\n+\n+# List of nodes to import keys to. Half the nodes will have pruning disabled,\n+# half will have it enabled. Different nodes will be used for imports that are\n+# expected to cause rescans, and imports that are not expected to cause\n+# rescans, in order to prevent rescans during later imports picking up\n+# transactions associated with earlier imports. This makes it easier to keep\n+# track of expected balances and transactions.\n+ImportNode = collections.namedtuple(\"ImportNode\", \"prune rescan\")\n+IMPORT_NODES = [ImportNode(*fields) for fields in itertools.product((False, True), repeat=2)]\n+\n+# Rescans start at the earliest block up to 2 hours before the key timestamp.\n+RESCAN_WINDOW = 2 * 60 * 60\n \n \n class ImportRescanTest(BitcoinTestFramework):\n@@ -59,96 +110,75 @@ def __init__(self):\n \n     def setup_network(self):\n         extra_args = [[\"-debug=1\"] for _ in range(self.num_nodes)]\n+        for i, import_node in enumerate(IMPORT_NODES, 1):\n+            if import_node.prune:\n+                extra_args[i] += [\"-prune=1\"]\n+\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n         for i in range(1, self.num_nodes):\n             connect_nodes(self.nodes[i], 0)\n \n     def run_test(self):\n         # Create one transaction on node 0 with a unique amount and label for\n         # each possible type of wallet import RPC.\n-        import_rpc_variants = []\n-        for i, import_rpc in enumerate(IMPORT_RPCS):\n-            label = \"label{}\".format(i)\n-            addr = self.nodes[0].validateaddress(self.nodes[0].getnewaddress(label))\n-            key = self.nodes[0].dumpprivkey(addr[\"address\"])\n-            amount = 24.9375 - i * .0625\n-            txid = self.nodes[0].sendtoaddress(addr[\"address\"], amount)\n-            import_rpc = functools.partial(import_rpc, addr[\"address\"], addr[\"scriptPubKey\"], addr[\"pubkey\"], key,\n-                                           label)\n-            import_rpc_variants.append((import_rpc, label, amount, txid, addr))\n-\n+        for i, variant in enumerate(IMPORT_VARIANTS):\n+            variant.label = \"label {} {}\".format(i, variant)\n+            variant.address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress(variant.label))\n+            variant.key = self.nodes[0].dumpprivkey(variant.address[\"address\"])\n+            variant.initial_amount = 25 - (i + 1) / 4.0\n+            variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n+\n+        # Generate a block containing the initial transactions, then another\n+        # block further in the future (past the rescan window).\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n+        timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n+        set_node_times(self.nodes, timestamp + RESCAN_WINDOW + 1)\n+        self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n-        # For each importing node and variation of wallet import RPC, invoke\n-        # the RPC and check the results from getbalance and listtransactions.\n-        for node, import_node in zip(self.nodes[1:], IMPORT_NODES):\n-            for import_rpc, label, amount, txid, addr in import_rpc_variants:\n-                watchonly = import_rpc(node, import_node.rescan)\n-\n-                balance = node.getbalance(label, 0, True)\n-                if import_node.rescan:\n-                    assert_equal(balance, amount)\n-                else:\n-                    assert_equal(balance, 0)\n-\n-                txs = node.listtransactions(label, 10000, 0, True)\n-                if import_node.rescan:\n-                    assert_equal(len(txs), 1)\n-                    assert_equal(txs[0][\"account\"], label)\n-                    assert_equal(txs[0][\"address\"], addr[\"address\"])\n-                    assert_equal(txs[0][\"amount\"], amount)\n-                    assert_equal(txs[0][\"category\"], \"receive\")\n-                    assert_equal(txs[0][\"label\"], label)\n-                    assert_equal(txs[0][\"txid\"], txid)\n-                    assert_equal(txs[0][\"confirmations\"], 1)\n-                    assert_equal(\"trusted\" not in txs[0], True)\n-                    if watchonly:\n-                        assert_equal(txs[0][\"involvesWatchonly\"], True)\n-                    else:\n-                        assert_equal(\"involvesWatchonly\" not in txs[0], True)\n-                else:\n-                    assert_equal(len(txs), 0)\n-\n-        # Create spends for all the imported addresses.\n-        spend_txids = []\n+        # For each variation of wallet key import, invoke the import RPC and\n+        # check the results from getbalance and listtransactions.\n+        for variant in IMPORT_VARIANTS:\n+            variant.expect_disabled = variant.rescan == Rescan.yes and variant.prune and variant.call == Call.single\n+            expect_rescan = variant.rescan == Rescan.yes and not variant.expect_disabled\n+            variant.node = self.nodes[1 + IMPORT_NODES.index(ImportNode(variant.prune, expect_rescan))]\n+            variant.do_import(timestamp)\n+            if expect_rescan:\n+                variant.expected_balance = variant.initial_amount\n+                variant.expected_txs = 1\n+                variant.check(variant.initial_txid, variant.initial_amount, 2)\n+            else:\n+                variant.expected_balance = 0\n+                variant.expected_txs = 0\n+                variant.check()\n+\n+        # Create new transactions sending to each address.\n         fee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n-        for import_rpc, label, amount, txid, addr in import_rpc_variants:\n-            raw_tx = self.nodes[0].getrawtransaction(txid)\n-            decoded_tx = self.nodes[0].decoderawtransaction(raw_tx)\n-            input_vout = next(out[\"n\"] for out in decoded_tx[\"vout\"]\n-                              if out[\"scriptPubKey\"][\"addresses\"] == [addr[\"address\"]])\n-            inputs = [{\"txid\": txid, \"vout\": input_vout}]\n-            outputs = {self.nodes[0].getnewaddress(): Decimal(amount) - fee}\n-            raw_spend_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_spend_tx = self.nodes[0].signrawtransaction(raw_spend_tx)\n-            spend_txid = self.nodes[0].sendrawtransaction(signed_spend_tx[\"hex\"])\n-            spend_txids.append(spend_txid)\n+        for i, variant in enumerate(IMPORT_VARIANTS):\n+            variant.sent_amount = 25 - (2 * i + 1) / 8.0\n+            variant.sent_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.sent_amount)\n \n+        # Generate a block containing the new transactions.\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n         sync_blocks(self.nodes)\n \n-        # Check the results from getbalance and listtransactions after the spends.\n-        for node, import_node in zip(self.nodes[1:], IMPORT_NODES):\n-            txs = node.listtransactions(\"*\", 10000, 0, True)\n-            for (import_rpc, label, amount, txid, addr), spend_txid in zip(import_rpc_variants, spend_txids):\n-                balance = node.getbalance(label, 0, True)\n-                spend_tx = [tx for tx in txs if tx[\"txid\"] == spend_txid]\n-                if import_node.rescan:\n-                    assert_equal(balance, amount)\n-                    assert_equal(len(spend_tx), 1)\n-                    assert_equal(spend_tx[0][\"account\"], \"\")\n-                    assert_equal(spend_tx[0][\"amount\"] + spend_tx[0][\"fee\"], -amount)\n-                    assert_equal(spend_tx[0][\"category\"], \"send\")\n-                    assert_equal(\"label\" not in spend_tx[0], True)\n-                    assert_equal(spend_tx[0][\"confirmations\"], 1)\n-                    assert_equal(\"trusted\" not in spend_tx[0], True)\n-                    assert_equal(\"involvesWatchonly\" not in txs[0], True)\n-                else:\n-                    assert_equal(balance, 0)\n-                    assert_equal(spend_tx, [])\n+        # Check the latest results from getbalance and listtransactions.\n+        for variant in IMPORT_VARIANTS:\n+            if not variant.expect_disabled:\n+                variant.expected_balance += variant.sent_amount\n+                variant.expected_txs += 1\n+                variant.check(variant.sent_txid, variant.sent_amount, 1)\n+            else:\n+                variant.check()\n+\n+\n+def try_rpc(func, *args, **kwargs):\n+    try:\n+        return func(*args, **kwargs), None\n+    except JSONRPCException as e:\n+        return None, e.error\n \n \n if __name__ == \"__main__\":"
      },
      {
        "sha": "1aa4ba2e18f2a286a9a2ef3c80420d70a010c9b2",
        "filename": "qa/rpc-tests/importmulti.py",
        "status": "modified",
        "additions": 77,
        "deletions": 3,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/importmulti.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -20,6 +20,7 @@ def run_test (self):\n         print (\"Mining blocks...\")\n         self.nodes[0].generate(1)\n         self.nodes[1].generate(1)\n+        timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         # keyword definition\n         PRIV_KEY = 'privkey'\n@@ -52,38 +53,56 @@ def run_test (self):\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n-            }\n+            },\n+            \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['timestamp'], timestamp)\n+        watchonly_address = address['address']\n+        watchonly_timestamp = timestamp\n \n+        print(\"Should not import an invalid address\")\n+        result = self.nodes[1].importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": \"not valid address\",\n+            },\n+            \"timestamp\": \"now\",\n+        }])\n+        assert_equal(result[0]['success'], False)\n+        assert_equal(result[0]['error']['code'], -5)\n+        assert_equal(result[0]['error']['message'], 'Invalid address')\n \n         # ScriptPubKey + internal\n         print(\"Should import a scriptPubKey with internal flag\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + !internal\n         print(\"Should not import a scriptPubKey without internal flag\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey']\n+            \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set for hex scriptPubKey')\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n \n         # Address + Public key + !Internal\n@@ -93,19 +112,22 @@ def run_test (self):\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n+            \"timestamp\": \"now\",\n             \"pubkeys\": [ address['pubkey'] ]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n \n         # ScriptPubKey + Public key + internal\n         print(\"Should import a scriptPubKey with internal and with public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"pubkeys\": [ address['pubkey'] ],\n             \"internal\": True\n         }]\n@@ -114,12 +136,14 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Public key + !internal\n         print(\"Should not import a scriptPubKey without internal and with public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"pubkeys\": [ address['pubkey'] ]\n         }]\n         result = self.nodes[1].importmulti(request)\n@@ -129,6 +153,7 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n         # Address + Private key + !watchonly\n         print(\"Should import an address with private key\")\n@@ -137,12 +162,14 @@ def run_test (self):\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n+            \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n         # Address + Private key + watchonly\n         print(\"Should not import an address with private key and with watchonly\")\n@@ -151,6 +178,7 @@ def run_test (self):\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n+            \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n             \"watchonly\": True\n         }])\n@@ -160,25 +188,29 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n         # ScriptPubKey + Private key + internal\n         print(\"Should import a scriptPubKey with internal and with private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Private key + !internal\n         print(\"Should not import a scriptPubKey without internal and with private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n         }])\n         assert_equal(result[0]['success'], False)\n@@ -187,6 +219,7 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n \n         # P2SH address\n@@ -197,18 +230,21 @@ def run_test (self):\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)\n+        timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n         print(\"Should import a p2sh\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n-            }\n+            },\n+            \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n         assert_equal(address_assert['isscript'], True)\n         assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['timestamp'], timestamp)\n         p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n@@ -222,16 +258,20 @@ def run_test (self):\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)\n+        timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n         print(\"Should import a p2sh with respective redeem script\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n             },\n+            \"timestamp\": \"now\",\n             \"redeemscript\": multi_sig_script['redeemScript']\n         }])\n         assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n         p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n@@ -246,17 +286,21 @@ def run_test (self):\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)\n+        timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n         print(\"Should import a p2sh with respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n             },\n+            \"timestamp\": \"now\",\n             \"redeemscript\": multi_sig_script['redeemScript'],\n             \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n         }])\n         assert_equal(result[0]['success'], True)\n+        address_assert = self.nodes[1].validateaddress(multi_sig_script['address'])\n+        assert_equal(address_assert['timestamp'], timestamp)\n \n         p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n@@ -277,6 +321,7 @@ def run_test (self):\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n             },\n+            \"timestamp\": \"now\",\n             \"redeemscript\": multi_sig_script['redeemScript'],\n             \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])],\n             \"watchonly\": True\n@@ -294,6 +339,7 @@ def run_test (self):\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n+            \"timestamp\": \"now\",\n             \"pubkeys\": [ address2['pubkey'] ]\n         }])\n         assert_equal(result[0]['success'], False)\n@@ -302,6 +348,7 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n@@ -310,6 +357,7 @@ def run_test (self):\n         address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"pubkeys\": [ address2['pubkey'] ],\n             \"internal\": True\n         }]\n@@ -320,6 +368,7 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n \n         # Address + Private key + !watchonly + Wrong private key\n@@ -330,6 +379,7 @@ def run_test (self):\n             \"scriptPubKey\": {\n                 \"address\": address['address']\n             },\n+            \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ]\n         }])\n         assert_equal(result[0]['success'], False)\n@@ -338,6 +388,7 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n \n \n         # ScriptPubKey + Private key + internal + Wrong private key\n@@ -346,6 +397,7 @@ def run_test (self):\n         address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n+            \"timestamp\": \"now\",\n             \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ],\n             \"internal\": True\n         }])\n@@ -355,6 +407,28 @@ def run_test (self):\n         address_assert = self.nodes[1].validateaddress(address['address'])\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n+        assert_equal('timestamp' in address_assert, False)\n+\n+        # restart nodes to check for proper serialization/deserialization of watch only address\n+        stop_nodes(self.nodes)\n+        self.nodes = start_nodes(2, self.options.tmpdir)\n+        address_assert = self.nodes[1].validateaddress(watchonly_address)\n+        assert_equal(address_assert['iswatchonly'], True)\n+        assert_equal(address_assert['ismine'], False)\n+        assert_equal(address_assert['timestamp'], watchonly_timestamp);\n+\n+        # Bad or missing timestamps\n+        print(\"Should throw on invalid or missing timestamp values\")\n+        assert_raises_message(JSONRPCException, 'Missing required timestamp field for key',\n+            self.nodes[1].importmulti, [{\n+                \"scriptPubKey\": address['scriptPubKey'],\n+            }])\n+        assert_raises_message(JSONRPCException, 'Expected number or \"now\" timestamp value for key. got type string',\n+            self.nodes[1].importmulti, [{\n+                \"scriptPubKey\": address['scriptPubKey'],\n+                \"timestamp\": \"\",\n+            }])\n+\n \n if __name__ == '__main__':\n     ImportMultiTest ().main ()"
      },
      {
        "sha": "47dfe4f5fd18ee12a248c26615f53d97fc68993d",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -7,7 +7,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n-from test_framework.siphash import siphash256\n from test_framework.script import CScript, OP_TRUE\n \n '''"
      },
      {
        "sha": "44e5f103224651b9b01155484315de78eb8c00a8",
        "filename": "qa/rpc-tests/p2p-fullblocktest.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-fullblocktest.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -398,7 +398,7 @@ def update_block(block_number, new_transactions):\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n         b27 = block(27, spend=out[7])\n-        yield rejected(RejectResult(16, b'bad-prevblk'))\n+        yield rejected(RejectResult(0, b'bad-prevblk'))\n \n         # Now try a too-large-coinbase script\n         tip(15)\n@@ -410,7 +410,7 @@ def update_block(block_number, new_transactions):\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n         b29 = block(29, spend=out[7])\n-        yield rejected(RejectResult(16, b'bad-prevblk'))\n+        yield rejected(RejectResult(0, b'bad-prevblk'))\n \n         # b30 has a max-sized coinbase scriptSig.\n         tip(23)"
      },
      {
        "sha": "41ca84d779890cded199129d7739fbbd348a894c",
        "filename": "qa/rpc-tests/p2p-leaktests.py",
        "status": "added",
        "additions": 145,
        "deletions": 0,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-leaktests.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -0,0 +1,145 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+'''\n+Test for message sending before handshake completion\n+\n+A node should never send anything other than VERSION/VERACK/REJECT until it's\n+received a VERACK.\n+\n+This test connects to a node and sends it a few messages, trying to intice it\n+into sending us something it shouldn't.\n+'''\n+\n+banscore = 10\n+\n+class CLazyNode(NodeConnCB):\n+    def __init__(self):\n+        self.connection = None\n+        self.unexpected_msg = False\n+        self.connected = False\n+        super().__init__()\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def bad_message(self, message):\n+        self.unexpected_msg = True\n+        print(\"should not have received message: %s\" % message.command)\n+\n+    def on_open(self, conn):\n+        self.connected = True\n+\n+    def on_version(self, conn, message): self.bad_message(message)\n+    def on_verack(self, conn, message): self.bad_message(message)\n+    def on_reject(self, conn, message): self.bad_message(message)\n+    def on_inv(self, conn, message): self.bad_message(message)\n+    def on_addr(self, conn, message): self.bad_message(message)\n+    def on_alert(self, conn, message): self.bad_message(message)\n+    def on_getdata(self, conn, message): self.bad_message(message)\n+    def on_getblocks(self, conn, message): self.bad_message(message)\n+    def on_tx(self, conn, message): self.bad_message(message)\n+    def on_block(self, conn, message): self.bad_message(message)\n+    def on_getaddr(self, conn, message): self.bad_message(message)\n+    def on_headers(self, conn, message): self.bad_message(message)\n+    def on_getheaders(self, conn, message): self.bad_message(message)\n+    def on_ping(self, conn, message): self.bad_message(message)\n+    def on_mempool(self, conn): self.bad_message(message)\n+    def on_pong(self, conn, message): self.bad_message(message)\n+    def on_feefilter(self, conn, message): self.bad_message(message)\n+    def on_sendheaders(self, conn, message): self.bad_message(message)\n+    def on_sendcmpct(self, conn, message): self.bad_message(message)\n+    def on_cmpctblock(self, conn, message): self.bad_message(message)\n+    def on_getblocktxn(self, conn, message): self.bad_message(message)\n+    def on_blocktxn(self, conn, message): self.bad_message(message)\n+\n+# Node that never sends a version. We'll use this to send a bunch of messages\n+# anyway, and eventually get disconnected.\n+class CNodeNoVersionBan(CLazyNode):\n+    def __init__(self):\n+        super().__init__()\n+\n+    # send a bunch of veracks without sending a message. This should get us disconnected.\n+    # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n+    def on_open(self, conn):\n+        super().on_open(conn)\n+        for i in range(banscore):\n+            self.send_message(msg_verack())\n+\n+    def on_reject(self, conn, message): pass\n+\n+# Node that never sends a version. This one just sits idle and hopes to receive\n+# any message (it shouldn't!)\n+class CNodeNoVersionIdle(CLazyNode):\n+    def __init__(self):\n+        super().__init__()\n+\n+# Node that sends a version but not a verack.\n+class CNodeNoVerackIdle(CLazyNode):\n+    def __init__(self):\n+        self.version_received = False\n+        super().__init__()\n+\n+    def on_reject(self, conn, message): pass\n+    def on_verack(self, conn, message): pass\n+    # When version is received, don't reply with a verack. Instead, see if the\n+    # node will give us a message that it shouldn't. This is not an exhaustive\n+    # list!\n+    def on_version(self, conn, message):\n+        self.version_received = True\n+        conn.send_message(msg_ping())\n+        conn.send_message(msg_getaddr())\n+\n+class P2PLeakTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1\n+    def setup_network(self):\n+        extra_args = [['-debug', '-banscore='+str(banscore)]\n+                      for i in range(self.num_nodes)]\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+    def run_test(self):\n+        no_version_bannode = CNodeNoVersionBan()\n+        no_version_idlenode = CNodeNoVersionIdle()\n+        no_verack_idlenode = CNodeNoVerackIdle()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_version_bannode, send_version=False))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_version_idlenode, send_version=False))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_verack_idlenode))\n+        no_version_bannode.add_connection(connections[0])\n+        no_version_idlenode.add_connection(connections[1])\n+        no_verack_idlenode.add_connection(connections[2])\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+\n+        assert(wait_until(lambda: no_version_bannode.connected and no_version_idlenode.connected and no_verack_idlenode.version_received, timeout=10))\n+\n+        # Mine a block and make sure that it's not sent to the connected nodes\n+        self.nodes[0].generate(1)\n+\n+        #Give the node enough time to possibly leak out a message\n+        time.sleep(5)\n+\n+        #This node should have been banned\n+        assert(no_version_bannode.connection.state == \"closed\")\n+\n+        [conn.disconnect_node() for conn in connections]\n+\n+        # Make sure no unexpected messages came in\n+        assert(no_version_bannode.unexpected_msg == False)\n+        assert(no_version_idlenode.unexpected_msg == False)\n+        assert(no_verack_idlenode.unexpected_msg == False)\n+\n+if __name__ == '__main__':\n+    P2PLeakTest().main()"
      },
      {
        "sha": "f1b190587d8efa7d43584507b13e390ca3bbe711",
        "filename": "qa/rpc-tests/p2p-timeouts.py",
        "status": "added",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-timeouts.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -0,0 +1,103 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\" TimeoutsTest -- test various net timeouts (only in extended tests)\n+\n+- Create three bitcoind nodes:\n+\n+    no_verack_node - we never send a verack in response to their version\n+    no_version_node - we never send a version (only a ping)\n+    no_send_node - we never send any P2P message.\n+\n+- Start all three nodes\n+- Wait 1 second\n+- Assert that we're connected\n+- Send a ping to no_verack_node and no_version_node\n+- Wait 30 seconds\n+- Assert that we're still connected\n+- Send a ping to no_verack_node and no_version_node\n+- Wait 31 seconds\n+- Assert that we're no longer connected (timeout to receive version/verack is 60 seconds)\n+\"\"\"\n+\n+from time import sleep\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class TestNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.connected = False\n+        self.received_version = False\n+\n+    def on_open(self, conn):\n+        self.connected = True\n+\n+    def on_close(self, conn):\n+        self.connected = False\n+\n+    def on_version(self, conn, message):\n+        # Don't send a verack in response\n+        self.received_version = True\n+\n+class TimeoutsTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        self.nodes = []\n+\n+        # Start up node0 to be a version 1, pre-segwit node.\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, \n+                [[\"-debug\", \"-logtimemicros=1\"]])\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        self.no_verack_node = TestNode() # never send verack\n+        self.no_version_node = TestNode() # never send version (just ping)\n+        self.no_send_node = TestNode() # never send anything\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_verack_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_version_node, send_version=False))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_send_node, send_version=False))\n+        self.no_verack_node.add_connection(connections[0])\n+        self.no_version_node.add_connection(connections[1])\n+        self.no_send_node.add_connection(connections[2])\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+\n+        sleep(1)\n+\n+        assert(self.no_verack_node.connected)\n+        assert(self.no_version_node.connected)\n+        assert(self.no_send_node.connected)\n+\n+        ping_msg = msg_ping()\n+        connections[0].send_message(ping_msg)\n+        connections[1].send_message(ping_msg)\n+\n+        sleep(30)\n+\n+        assert(self.no_verack_node.received_version)\n+\n+        assert(self.no_verack_node.connected)\n+        assert(self.no_version_node.connected)\n+        assert(self.no_send_node.connected)\n+\n+        connections[0].send_message(ping_msg)\n+        connections[1].send_message(ping_msg)\n+\n+        sleep(31)\n+\n+        assert(not self.no_verack_node.connected)\n+        assert(not self.no_version_node.connected)\n+        assert(not self.no_send_node.connected)\n+\n+if __name__ == '__main__':\n+    TimeoutsTest().main()"
      },
      {
        "sha": "f9a40955c06c2b4411d34d23d001f58f703e5b76",
        "filename": "qa/rpc-tests/rpcnamedargs.py",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/rpcnamedargs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/rpcnamedargs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcnamedargs.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -3,17 +3,11 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-from decimal import Decimal\n-\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.authproxy import JSONRPCException\n from test_framework.util import (\n     assert_equal,\n     assert_raises_jsonrpc,\n-    assert_is_hex_string,\n-    assert_is_hash_string,\n     start_nodes,\n-    connect_nodes_bi,\n )\n \n "
      },
      {
        "sha": "d6831e00e36ad2ba7c353c7ccd78acb676244674",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -130,10 +130,14 @@ def run_test(self):\n         print(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({})\n+        assert(tmpl['sizelimit'] == 1000000)\n+        assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n         tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        assert(tmpl['sizelimit'] == 1000000)\n+        assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n@@ -241,6 +245,8 @@ def run_test(self):\n         print(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n+        assert(tmpl['weightlimit'] == 4000000)\n         assert(tmpl['sigoplimit'] == 80000)\n         assert(tmpl['transactions'][0]['txid'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 8)\n@@ -250,6 +256,8 @@ def run_test(self):\n         try:\n             tmpl = self.nodes[0].getblocktemplate({})\n             assert(len(tmpl['transactions']) == 1)  # Doesn't include witness tx\n+            assert(tmpl['sizelimit'] == 1000000)\n+            assert('weightlimit' not in tmpl)\n             assert(tmpl['sigoplimit'] == 20000)\n             assert(tmpl['transactions'][0]['hash'] == txid)\n             assert(tmpl['transactions'][0]['sigops'] == 2)"
      },
      {
        "sha": "5b563c58ae1e1a17e50caa42f165a28fd3d739d7",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 26,
        "deletions": 12,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1540,6 +1540,7 @@ def on_ping(self, conn, message):\n         if conn.ver_send > BIP0031_VERSION:\n             conn.send_message(msg_pong(message.nonce))\n     def on_reject(self, conn, message): pass\n+    def on_open(self, conn): pass\n     def on_close(self, conn): pass\n     def on_mempool(self, conn): pass\n     def on_pong(self, conn, message): pass\n@@ -1614,7 +1615,7 @@ class NodeConn(asyncore.dispatcher):\n         \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n     }\n \n-    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK):\n+    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n         self.dstaddr = dstaddr\n@@ -1631,14 +1632,16 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE\n         self.disconnect = False\n         self.nServices = 0\n \n-        # stuff version msg into sendbuf\n-        vt = msg_version()\n-        vt.nServices = services\n-        vt.addrTo.ip = self.dstaddr\n-        vt.addrTo.port = self.dstport\n-        vt.addrFrom.ip = \"0.0.0.0\"\n-        vt.addrFrom.port = 0\n-        self.send_message(vt, True)\n+        if send_version:\n+            # stuff version msg into sendbuf\n+            vt = msg_version()\n+            vt.nServices = services\n+            vt.addrTo.ip = self.dstaddr\n+            vt.addrTo.port = self.dstport\n+            vt.addrFrom.ip = \"0.0.0.0\"\n+            vt.addrFrom.port = 0\n+            self.send_message(vt, True)\n+\n         print('MiniNode: Connecting to Bitcoin Node IP # ' + dstaddr + ':' \\\n             + str(dstport))\n \n@@ -1652,8 +1655,10 @@ def show_debug_msg(self, msg):\n         self.log.debug(msg)\n \n     def handle_connect(self):\n-        self.show_debug_msg(\"MiniNode: Connected & Listening: \\n\")\n-        self.state = \"connected\"\n+        if self.state != \"connected\":\n+            self.show_debug_msg(\"MiniNode: Connected & Listening: \\n\")\n+            self.state = \"connected\"\n+            self.cb.on_open(self)\n \n     def handle_close(self):\n         self.show_debug_msg(\"MiniNode: Closing Connection to %s:%d... \"\n@@ -1681,11 +1686,20 @@ def readable(self):\n \n     def writable(self):\n         with mininode_lock:\n+            pre_connection = self.state == \"connecting\"\n             length = len(self.sendbuf)\n-        return (length > 0)\n+        return (length > 0 or pre_connection)\n \n     def handle_write(self):\n         with mininode_lock:\n+            # asyncore does not expose socket connection, only the first read/write\n+            # event, thus we must check connection manually here to know when we\n+            # actually connect\n+            if self.state == \"connecting\":\n+                self.handle_connect()\n+            if not self.writable():\n+                return\n+\n             try:\n                 sent = self.send(self.sendbuf)\n             except:"
      },
      {
        "sha": "45a9db05717372008c2c07fa62be66d9a39f0491",
        "filename": "qa/rpc-tests/wallet-accounts.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/wallet-accounts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/qa/rpc-tests/wallet-accounts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet-accounts.py?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -6,9 +6,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     start_nodes,\n-    start_node,\n     assert_equal,\n-    connect_nodes_bi,\n )\n \n "
      },
      {
        "sha": "b6ab4c6305184ca31ebe27282bb58a38a3ec7f3a",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -53,11 +53,7 @@ bool CAddrInfo::IsTerrible(int64_t nNow) const\n double CAddrInfo::GetChance(int64_t nNow) const\n {\n     double fChance = 1.0;\n-\n-    int64_t nSinceLastTry = nNow - nLastTry;\n-\n-    if (nSinceLastTry < 0)\n-        nSinceLastTry = 0;\n+    int64_t nSinceLastTry = std::max<int64_t>(nNow - nLastTry, 0);\n \n     // deprioritize very recent attempts away\n     if (nSinceLastTry < 60 * 10)"
      },
      {
        "sha": "383d9849af9752490c44b8259bd99692e21a2def",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -97,10 +97,10 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\n \n         // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000002cb971dd56d1c583c20f90\");\n+        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000003f94d1ad391682fe038bf5\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x0000000000000000030abc968e1bd635736e880b946085c93152969b9a81a6e2\"); //447235\n+        consensus.defaultAssumeValid = uint256S(\"0x00000000000000000013176bf8d7dfeab4e1db31dc93bc311b436e82ab226b90\"); //453354\n \n         /**\n          * The message start string is designed to be unlikely to occur in normal data.\n@@ -201,10 +201,10 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n \n         // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000000000198b4def2baa9338d6\");\n+        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000001f057509eba81aed91\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x000000000871ee6842d3648317ccc8a435eb8cc3c2429aee94faff9ba26b05a0\"); //1043841\n+        consensus.defaultAssumeValid = uint256S(\"0x00000000000128796ee387cf110ccb9d2f36cffaf7f73079c995377c65ac0dcc\"); //1079274\n \n         pchMessageStart[0] = 0x0b;\n         pchMessageStart[1] = 0x11;"
      },
      {
        "sha": "69154d546dd795ab38abe96fa285fa2f33a3e62e",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -15,7 +15,7 @@\n \n //! These need to be macros, as clientversion.cpp's and bitcoin*-res.rc's voodoo requires it\n #define CLIENT_VERSION_MAJOR 0\n-#define CLIENT_VERSION_MINOR 13\n+#define CLIENT_VERSION_MINOR 14\n #define CLIENT_VERSION_REVISION 99\n #define CLIENT_VERSION_BUILD 0\n "
      },
      {
        "sha": "eacb8f04fef378ab80a1b1df15689525e5d45895",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -25,9 +25,9 @@ class CHash256 {\n     static const size_t OUTPUT_SIZE = CSHA256::OUTPUT_SIZE;\n \n     void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-        unsigned char buf[sha.OUTPUT_SIZE];\n+        unsigned char buf[CSHA256::OUTPUT_SIZE];\n         sha.Finalize(buf);\n-        sha.Reset().Write(buf, sha.OUTPUT_SIZE).Finalize(hash);\n+        sha.Reset().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\n     }\n \n     CHash256& Write(const unsigned char *data, size_t len) {\n@@ -49,9 +49,9 @@ class CHash160 {\n     static const size_t OUTPUT_SIZE = CRIPEMD160::OUTPUT_SIZE;\n \n     void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-        unsigned char buf[sha.OUTPUT_SIZE];\n+        unsigned char buf[CSHA256::OUTPUT_SIZE];\n         sha.Finalize(buf);\n-        CRIPEMD160().Write(buf, sha.OUTPUT_SIZE).Finalize(hash);\n+        CRIPEMD160().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\n     }\n \n     CHash160& Write(const unsigned char *data, size_t len) {"
      },
      {
        "sha": "8ac6925acdac6ee044e5e7d2f8797980760b647e",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -112,7 +112,7 @@ static bool multiUserAuthorized(std::string strUserPass)\n             std::string strSalt = vFields[1];\n             std::string strHash = vFields[2];\n \n-            unsigned int KEY_SIZE = 32;\n+            static const unsigned int KEY_SIZE = 32;\n             unsigned char out[KEY_SIZE];\n \n             CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);"
      },
      {
        "sha": "cf265180ffae56b7de88410316ec736ed62a65f1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -934,7 +934,7 @@ bool AppInitParameterInteraction()\n     int64_t nMempoolSizeMin = GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40;\n     if (nMempoolSizeMax < 0 || nMempoolSizeMax < nMempoolSizeMin)\n         return InitError(strprintf(_(\"-maxmempool must be at least %d MB\"), std::ceil(nMempoolSizeMin / 1000000.0)));\n-    // incremental relay fee sets the minimimum feerate increase necessary for BIP 125 replacement in the mempool\n+    // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool\n     // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting.\n     if (IsArgSet(\"-incrementalrelayfee\"))\n     {"
      },
      {
        "sha": "de5fc29693e8247ccc107ac0f211172942585158",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1388,6 +1388,11 @@ void CConnman::ThreadSocketHandler()\n                     LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n                     pnode->fDisconnect = true;\n                 }\n+                else if (!pnode->fSuccessfullyConnected)\n+                {\n+                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->id);\n+                    pnode->fDisconnect = true;\n+                }\n             }\n         }\n         {"
      },
      {
        "sha": "3ec1a1c27d28e6fcb8cbbd1ba0fff01e92a23599",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 49,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1190,8 +1190,31 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n     }\n \n+    if (strCommand == NetMsgType::REJECT)\n+    {\n+        if (fDebug) {\n+            try {\n+                std::string strMsg; unsigned char ccode; std::string strReason;\n+                vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);\n \n-    if (strCommand == NetMsgType::VERSION)\n+                std::ostringstream ss;\n+                ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;\n+\n+                if (strMsg == NetMsgType::BLOCK || strMsg == NetMsgType::TX)\n+                {\n+                    uint256 hash;\n+                    vRecv >> hash;\n+                    ss << \": hash \" << hash.ToString();\n+                }\n+                LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(ss.str()));\n+            } catch (const std::ios_base::failure&) {\n+                // Avoid feedback loops by preventing reject messages from triggering a new reject message.\n+                LogPrint(\"net\", \"Unparseable reject message received\\n\");\n+            }\n+        }\n+    }\n+\n+    else if (strCommand == NetMsgType::VERSION)\n     {\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n@@ -1402,6 +1425,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->fSuccessfullyConnected = true;\n     }\n \n+    else if (!pfrom->fSuccessfullyConnected)\n+    {\n+        // Must have a verack message before anything else\n+        LOCK(cs_main);\n+        Misbehaving(pfrom->GetId(), 1);\n+        return false;\n+    }\n \n     else if (strCommand == NetMsgType::ADDR)\n     {\n@@ -2549,31 +2579,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->fRelayTxes = true;\n     }\n \n-\n-    else if (strCommand == NetMsgType::REJECT)\n-    {\n-        if (fDebug) {\n-            try {\n-                std::string strMsg; unsigned char ccode; std::string strReason;\n-                vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);\n-\n-                std::ostringstream ss;\n-                ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;\n-\n-                if (strMsg == NetMsgType::BLOCK || strMsg == NetMsgType::TX)\n-                {\n-                    uint256 hash;\n-                    vRecv >> hash;\n-                    ss << \": hash \" << hash.ToString();\n-                }\n-                LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(ss.str()));\n-            } catch (const std::ios_base::failure&) {\n-                // Avoid feedback loops by preventing reject messages from triggering a new reject message.\n-                LogPrint(\"net\", \"Unparseable reject message received\\n\");\n-            }\n-        }\n-    }\n-\n     else if (strCommand == NetMsgType::FEEFILTER) {\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n@@ -2601,6 +2606,36 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     return true;\n }\n \n+static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n+{\n+    AssertLockHeld(cs_main);\n+    CNodeState &state = *State(pnode->GetId());\n+\n+    BOOST_FOREACH(const CBlockReject& reject, state.rejects) {\n+        connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+    }\n+    state.rejects.clear();\n+\n+    if (state.fShouldBan) {\n+        state.fShouldBan = false;\n+        if (pnode->fWhitelisted)\n+            LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n+        else if (pnode->fAddnode)\n+            LogPrintf(\"Warning: not punishing addnoded peer %s!\\n\", pnode->addr.ToString());\n+        else {\n+            pnode->fDisconnect = true;\n+            if (pnode->addr.IsLocal())\n+                LogPrintf(\"Warning: not banning local peer %s!\\n\", pnode->addr.ToString());\n+            else\n+            {\n+                connman.Ban(pnode->addr, BanReasonNodeMisbehaving);\n+            }\n+        }\n+        return true;\n+    }\n+    return false;\n+}\n+\n bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n@@ -2711,8 +2746,12 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n             PrintExceptionContinue(NULL, \"ProcessMessages()\");\n         }\n \n-        if (!fRet)\n+        if (!fRet) {\n             LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->id);\n+        }\n+\n+        LOCK(cs_main);\n+        SendRejectsAndCheckIfBanned(pfrom, connman);\n \n     return fMoreWork;\n }\n@@ -2778,30 +2817,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n         if (!lockMain)\n             return true;\n \n+        if (SendRejectsAndCheckIfBanned(pto, connman))\n+            return true;\n         CNodeState &state = *State(pto->GetId());\n \n-        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n-        state.rejects.clear();\n-\n-        if (state.fShouldBan) {\n-            state.fShouldBan = false;\n-            if (pto->fWhitelisted)\n-                LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n-            else if (pto->fAddnode)\n-                LogPrintf(\"Warning: not punishing addnoded peer %s!\\n\", pto->addr.ToString());\n-            else {\n-                pto->fDisconnect = true;\n-                if (pto->addr.IsLocal())\n-                    LogPrintf(\"Warning: not banning local peer %s!\\n\", pto->addr.ToString());\n-                else\n-                {\n-                    connman.Ban(pto->addr, BanReasonNodeMisbehaving);\n-                }\n-                return true;\n-            }\n-        }\n-\n         // Address refresh broadcast\n         int64_t nNow = GetTimeMicros();\n         if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {"
      },
      {
        "sha": "fc9a6ed0be8e3f8bcece8c50d369a00c49785562",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 18,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -198,6 +198,14 @@ struct timeval MillisToTimeval(int64_t nTimeout)\n     return timeout;\n }\n \n+enum class IntrRecvError {\n+    OK,\n+    Timeout,\n+    Disconnected,\n+    NetworkError,\n+    Interrupted\n+};\n+\n /**\n  * Read bytes from socket. This will either read the full number of bytes requested\n  * or return False on error or timeout.\n@@ -209,7 +217,7 @@ struct timeval MillisToTimeval(int64_t nTimeout)\n  *\n  * @note This function requires that hSocket is in non-blocking mode.\n  */\n-bool static InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSocket)\n+static IntrRecvError InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSocket)\n {\n     int64_t curTime = GetTimeMillis();\n     int64_t endTime = curTime + timeout;\n@@ -222,30 +230,30 @@ bool static InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSock\n             len -= ret;\n             data += ret;\n         } else if (ret == 0) { // Unexpected disconnection\n-            return false;\n+            return IntrRecvError::Disconnected;\n         } else { // Other error or blocking\n             int nErr = WSAGetLastError();\n             if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL) {\n                 if (!IsSelectableSocket(hSocket)) {\n-                    return false;\n+                    return IntrRecvError::NetworkError;\n                 }\n                 struct timeval tval = MillisToTimeval(std::min(endTime - curTime, maxWait));\n                 fd_set fdset;\n                 FD_ZERO(&fdset);\n                 FD_SET(hSocket, &fdset);\n                 int nRet = select(hSocket + 1, &fdset, NULL, NULL, &tval);\n                 if (nRet == SOCKET_ERROR) {\n-                    return false;\n+                    return IntrRecvError::NetworkError;\n                 }\n             } else {\n-                return false;\n+                return IntrRecvError::NetworkError;\n             }\n         }\n         if (interruptSocks5Recv)\n-            return false;\n+            return IntrRecvError::Interrupted;\n         curTime = GetTimeMillis();\n     }\n-    return len == 0;\n+    return len == 0 ? IntrRecvError::OK : IntrRecvError::Timeout;\n }\n \n struct ProxyCredentials\n@@ -272,6 +280,7 @@ std::string Socks5ErrorString(int err)\n /** Connect using SOCKS5 (as described in RFC1928) */\n static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, SOCKET& hSocket)\n {\n+    IntrRecvError recvr;\n     LogPrint(\"net\", \"SOCKS5 connecting %s\\n\", strDest);\n     if (strDest.size() > 255) {\n         CloseSocket(hSocket);\n@@ -294,7 +303,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet1[2];\n-    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n+    if ((recvr = InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n         CloseSocket(hSocket);\n         LogPrintf(\"Socks5() connect to %s:%d failed: InterruptibleRecv() timeout or other failure\\n\", strDest, port);\n         return false;\n@@ -320,7 +329,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         }\n         LogPrint(\"proxy\", \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n         char pchRetA[2];\n-        if (!InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n+        if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n             CloseSocket(hSocket);\n             return error(\"Error reading proxy authentication response\");\n         }\n@@ -349,9 +358,16 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet2[4];\n-    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) {\n+    if ((recvr = InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n         CloseSocket(hSocket);\n-        return error(\"Error reading proxy response\");\n+        if (recvr == IntrRecvError::Timeout) {\n+            /* If a timeout happens here, this effectively means we timed out while connecting\n+             * to the remote node. This is very common for Tor, so do not print an\n+             * error message. */\n+            return false;\n+        } else {\n+            return error(\"Error while reading proxy response\");\n+        }\n     }\n     if (pchRet2[0] != 0x05) {\n         CloseSocket(hSocket);\n@@ -370,26 +386,26 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n     char pchRet3[256];\n     switch (pchRet2[3])\n     {\n-        case 0x01: ret = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket); break;\n-        case 0x04: ret = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket); break;\n+        case 0x01: recvr = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket); break;\n+        case 0x04: recvr = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket); break;\n         case 0x03:\n         {\n-            ret = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n-            if (!ret) {\n+            recvr = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n+            if (recvr != IntrRecvError::OK) {\n                 CloseSocket(hSocket);\n                 return error(\"Error reading from proxy\");\n             }\n             int nRecv = pchRet3[0];\n-            ret = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n+            recvr = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n             break;\n         }\n         default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n     }\n-    if (!ret) {\n+    if (recvr != IntrRecvError::OK) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n+    if ((recvr = InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }"
      },
      {
        "sha": "be79a67990e5bb2ce248d0581f112c8a125b314c",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -518,7 +518,10 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         // Propagate cleared model to child objects\n         rpcConsole->setClientModel(nullptr);\n #ifdef ENABLE_WALLET\n-        walletFrame->setClientModel(nullptr);\n+        if (walletFrame)\n+        {\n+            walletFrame->setClientModel(nullptr);\n+        }\n #endif // ENABLE_WALLET\n         unitDisplayControl->setOptionsModel(nullptr);\n     }"
      },
      {
        "sha": "d4fd8bd37262cf9025737de0e27b5c29a7c42fb4",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -563,9 +563,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         }\n \n         // after fee\n-        nAfterFee = nAmount - nPayFee;\n-        if (nAfterFee < 0)\n-            nAfterFee = 0;\n+        nAfterFee = std::max<CAmount>(nAmount - nPayFee, 0);\n     }\n \n     // actually update labels"
      },
      {
        "sha": "cfdd8482e39586db428cea0086733d121e9f521a",
        "filename": "src/qt/forms/intro.ui",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/forms/intro.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/forms/intro.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/intro.ui?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -7,7 +7,7 @@\n     <x>0</x>\n     <y>0</y>\n     <width>674</width>\n-    <height>363</height>\n+    <height>415</height>\n    </rect>\n   </property>\n   <property name=\"windowTitle\">\n@@ -55,9 +55,6 @@\n    </item>\n    <item>\n     <widget class=\"QLabel\" name=\"sizeWarningLabel\">\n-     <property name=\"text\">\n-      <string>%1 will download and store a copy of the Bitcoin block chain. At least %2GB of data will be stored in this directory, and it will grow over time. The wallet will also be stored in this directory.</string>\n-     </property>\n      <property name=\"wordWrap\">\n       <bool>true</bool>\n      </property>\n@@ -203,6 +200,36 @@\n      </item>\n     </layout>\n    </item>\n+   <item>\n+    <widget class=\"QLabel\" name=\"lblExplanation1\">\n+     <property name=\"text\">\n+      <string>When you click OK, %1 will begin to download and process the full %4 block chain (%2GB) starting with the earliest transactions in %3 when %4 initially launched.</string>\n+     </property>\n+     <property name=\"wordWrap\">\n+      <bool>true</bool>\n+     </property>\n+    </widget>\n+   </item>\n+   <item>\n+    <widget class=\"QLabel\" name=\"lblExplanation2\">\n+     <property name=\"text\">\n+      <string>This initial synchronisation is very demanding, and may expose hardware problems with your computer that had previously gone unnoticed. Each time you run %1, it will continue downloading where it left off.</string>\n+     </property>\n+     <property name=\"wordWrap\">\n+      <bool>true</bool>\n+     </property>\n+    </widget>\n+   </item>\n+   <item>\n+    <widget class=\"QLabel\" name=\"lblExplanation3\">\n+     <property name=\"text\">\n+      <string>If you have chosen to limit block chain storage (pruning), the historical data must still be downloaded and processed, but will be deleted afterward to keep your disk usage low.</string>\n+     </property>\n+     <property name=\"wordWrap\">\n+      <bool>true</bool>\n+     </property>\n+    </widget>\n+   </item>\n    <item>\n     <spacer name=\"verticalSpacer\">\n      <property name=\"orientation\">"
      },
      {
        "sha": "fd3dcac4248ff323199021bfb2e74371a7abdc4f",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 17,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -37,9 +37,7 @@\n \n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n-#if BOOST_FILESYSTEM_VERSION >= 3\n #include <boost/filesystem/detail/utf8_codecvt_facet.hpp>\n-#endif\n #include <boost/scoped_array.hpp>\n \n #include <QAbstractItemView>\n@@ -67,9 +65,7 @@\n #include <QFontDatabase>\n #endif\n \n-#if BOOST_FILESYSTEM_VERSION >= 3\n static boost::filesystem::detail::utf8_codecvt_facet utf8;\n-#endif\n \n #if defined(Q_OS_MAC)\n extern double NSAppKitVersionNumber;\n@@ -762,6 +758,8 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n \n \n #elif defined(Q_OS_MAC)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n // based on: https://github.com/Mozketo/LaunchAtLoginController/blob/master/LaunchAtLoginController.m\n \n #include <CoreFoundation/CoreFoundation.h>\n@@ -824,6 +822,7 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n     }\n     return true;\n }\n+#pragma GCC diagnostic pop\n #else\n \n bool GetStartOnSystemStartup() { return false; }\n@@ -860,7 +859,6 @@ void setClipboard(const QString& str)\n     QApplication::clipboard()->setText(str, QClipboard::Selection);\n }\n \n-#if BOOST_FILESYSTEM_VERSION >= 3\n boost::filesystem::path qstringToBoostPath(const QString &path)\n {\n     return boost::filesystem::path(path.toStdString(), utf8);\n@@ -870,18 +868,6 @@ QString boostPathToQString(const boost::filesystem::path &path)\n {\n     return QString::fromStdString(path.string(utf8));\n }\n-#else\n-#warning Conversion between boost path and QString can use invalid character encoding with boost_filesystem v2 and older\n-boost::filesystem::path qstringToBoostPath(const QString &path)\n-{\n-    return boost::filesystem::path(path.toStdString());\n-}\n-\n-QString boostPathToQString(const boost::filesystem::path &path)\n-{\n-    return QString::fromStdString(path.string());\n-}\n-#endif\n \n QString formatDurationStr(int secs)\n {"
      },
      {
        "sha": "4939648ff0b343932aa80bb166905e98200d5d10",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -124,16 +124,34 @@ Intro::Intro(QWidget *parent) :\n     ui->setupUi(this);\n     ui->welcomeLabel->setText(ui->welcomeLabel->text().arg(tr(PACKAGE_NAME)));\n     ui->storageLabel->setText(ui->storageLabel->text().arg(tr(PACKAGE_NAME)));\n+\n+    ui->lblExplanation1->setText(ui->lblExplanation1->text()\n+        .arg(tr(PACKAGE_NAME))\n+        .arg(BLOCK_CHAIN_SIZE)\n+        .arg(2009)\n+        .arg(tr(\"Bitcoin\"))\n+    );\n+    ui->lblExplanation2->setText(ui->lblExplanation2->text().arg(tr(PACKAGE_NAME)));\n+\n     uint64_t pruneTarget = std::max<int64_t>(0, GetArg(\"-prune\", 0));\n     requiredSpace = BLOCK_CHAIN_SIZE;\n+    QString storageRequiresMsg = tr(\"At least %1 GB of data will be stored in this directory, and it will grow over time.\");\n     if (pruneTarget) {\n         uint64_t prunedGBs = std::ceil(pruneTarget * 1024 * 1024.0 / GB_BYTES);\n         if (prunedGBs <= requiredSpace) {\n             requiredSpace = prunedGBs;\n+            storageRequiresMsg = tr(\"Approximately %1 GB of data will be stored in this directory.\");\n         }\n+        ui->lblExplanation3->setVisible(true);\n+    } else {\n+        ui->lblExplanation3->setVisible(false);\n     }\n     requiredSpace += CHAIN_STATE_SIZE;\n-    ui->sizeWarningLabel->setText(ui->sizeWarningLabel->text().arg(tr(PACKAGE_NAME)).arg(requiredSpace));\n+    ui->sizeWarningLabel->setText(\n+        tr(\"%1 will download and store a copy of the Bitcoin block chain.\").arg(tr(PACKAGE_NAME)) + \" \" +\n+        storageRequiresMsg.arg(requiredSpace) + \" \" +\n+        tr(\"The wallet will also be stored in this directory.\")\n+    );\n     startThread();\n }\n "
      },
      {
        "sha": "f38c425137020ded31353635e466c526a0127f0f",
        "filename": "src/qt/locale/bitcoin_cs.ts",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_cs.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_cs.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cs.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -329,6 +329,10 @@\n         <source>Click to enable network activity again.</source>\n         <translation>Kliknut\u00edm op\u011bt umo\u017en\u00ed\u0161 spojen\u00ed do s\u00edt\u011b.</translation>\n     </message>\n+    <message>\n+        <source>Syncing Headers (%1%)...</source>\n+        <translation>Synchronizuji z\u00e1hlav\u00ed blok\u016f (%1 %)\u2026</translation>\n+    </message>\n     <message>\n         <source>Reindexing blocks on disk...</source>\n         <translation>Vytv\u00e1\u0159\u00edm nov\u00fd index blok\u016f na disku...</translation>\n@@ -481,6 +485,10 @@\n         <source>%1 client</source>\n         <translation>%1 klient</translation>\n     </message>\n+    <message>\n+        <source>Connecting to peers...</source>\n+        <translation>P\u0159ipojuji se\u2026</translation>\n+    </message>\n     <message>\n         <source>Catching up...</source>\n         <translation>Stahuji...</translation>\n@@ -3089,6 +3097,14 @@\n         <source>Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)</source>\n         <translation>Spustit p\u0159\u00edkaz, kdy\u017e se objev\u00ed transakce t\u00fdkaj\u00edc\u00ed se pen\u011b\u017eenky (%s se v p\u0159\u00edkazu nahrad\u00ed za TxID)</translation>\n     </message>\n+    <message>\n+        <source>Extra transactions to keep in memory for compact block reconstructions (default: %u)</source>\n+        <translation>Po\u010det extra transakc\u00ed, kter\u00e9 se maj\u00ed dr\u017eet v pam\u011bti pro \u00fa\u010dely rekonstrukce kompaktn\u00edch blok\u016f (v\u00fdchoz\u00ed: %u)</translation>\n+    </message>\n+    <message>\n+        <source>If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)</source>\n+        <translation>Pokud je tenhle blok v \u0159et\u011bzci, tak p\u0159edpokl\u00e1dat, \u017ee on i jeho n\u00e1sledn\u00edci jsou platn\u00ed, a potenci\u00e1ln\u011b p\u0159esko\u010dit ov\u011b\u0159ov\u00e1n\u00ed jejich skript\u016f (0 = ov\u011b\u0159ovat v\u0161e, v\u00fdchoz\u00ed: %s, testnet: %s)</translation>\n+    </message>\n     <message>\n         <source>Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)</source>\n         <translation>Maxim\u00e1ln\u00ed povolen\u00e9 se\u0159izov\u00e1n\u00ed \u010dasu medi\u00e1nem \u010das\u016f prot\u011bj\u0161k\u016f. M\u00edstn\u00ed vn\u00edm\u00e1n\u00ed \u010dasu m\u016f\u017ee b\u00fdt ovlivn\u011bno prot\u011bj\u0161ky, a to dop\u0159edu nebo dozadu a\u017e o toto mno\u017estv\u00ed. (v\u00fdchoz\u00ed: %u vte\u0159in)</translation>\n@@ -3105,6 +3121,14 @@\n         <source>Please contribute if you find %s useful. Visit %s for further information about the software.</source>\n         <translation>Pros\u00edme, zapoj se nebo p\u0159isp\u011bj, pokud ti %s p\u0159ijde u\u017eite\u010dn\u00fd. V\u00edce informac\u00ed o programu je na %s.</translation>\n     </message>\n+    <message>\n+        <source>Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain. (default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, &gt;%u = automatically prune block files to stay under the specified target size in MiB)</source>\n+        <translation>Omezit n\u00e1roky na \u00falo\u017en\u00fd prostor pro\u0159ez\u00e1v\u00e1n\u00edm (maz\u00e1n\u00edm) star\u00fdch blok\u016f. Tato volba tak\u00e9 umo\u017en\u00ed pou\u017e\u00edt RPC vol\u00e1n\u00ed pruneblockchain ke smaz\u00e1n\u00ed konkr\u00e9tn\u00edch blok\u016f a d\u00e1le automatick\u00e9 pro\u0159ez\u00e1v\u00e1n\u00ed star\u00fdch blok\u016f, pokud je zad\u00e1na c\u00edlov\u00e1 velikost soubor\u016f s bloky v MiB. Tento re\u017eim nen\u00ed slu\u010diteln\u00fd s -txindex ani -rescan. Upozorn\u011bn\u00ed: op\u011btovn\u00e1 zm\u011bna tohoto nastaven\u00ed bude vy\u017eadovat nov\u00e9 sta\u017een\u00ed cel\u00e9ho \u0159et\u011bzce blok\u016f. (v\u00fdchoz\u00ed: 0 = bloky nepro\u0159ez\u00e1vat, 1 = povolit ru\u010dn\u00ed pro\u0159ez\u00e1v\u00e1n\u00ed skrze RPC, &gt;%u = automatick\u00e9 pro\u0159ez\u00e1v\u00e1n\u00ed blok\u016f tak, aby byla udr\u017eena c\u00edlov\u00e1 velikost soubor\u016f s bloky, v MiB)</translation>\n+    </message>\n+    <message>\n+        <source>Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)</source>\n+        <translation>Nastavit nejni\u017e\u0161\u00ed akceptovateln\u00fd poplatek (v %s/kB) pro transakce, kter\u00e9 maj\u00ed b\u00fdt zahrnuty do nov\u00fdch blok\u016f. (v\u00fdchoz\u00ed: %s)</translation>\n+    </message>\n     <message>\n         <source>Set the number of script verification threads (%u to %d, 0 = auto, &lt;0 = leave that many cores free, default: %d)</source>\n         <translation>Nastaven\u00ed po\u010dtu vl\u00e1ken pro verifikaci skript\u016f (%u a\u017e %d, 0 = automaticky, &lt;0 = nechat dan\u00fd po\u010det jader voln\u00fd, v\u00fdchoz\u00ed: %d)</translation>"
      },
      {
        "sha": "f62f1e4a734d39538a281a90f29a0d698cfd70b6",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1083,7 +1083,7 @@\n         <translation>Use a custom data directory:</translation>\n     </message>\n     <message>\n-        <location filename=\"../intro.cpp\" line=\"+89\"/>\n+        <location filename=\"../intro.cpp\" line=\"+94\"/>\n         <source>Error: Specified data directory &quot;%1&quot; cannot be created.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>"
      },
      {
        "sha": "313d5e3be14b67ef1ec205503df3287884e24b26",
        "filename": "src/qt/locale/bitcoin_et.ts",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_et.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_et.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_et.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -214,6 +214,10 @@\n </context>\n <context>\n     <name>BanTableModel</name>\n+    <message>\n+        <source>IP/Netmask</source>\n+        <translation>IP/V\u00f5rgumask</translation>\n+    </message>\n     </context>\n <context>\n     <name>BitcoinGUI</name>\n@@ -787,6 +791,10 @@\n         <source>&amp;Window</source>\n         <translation>&amp;Aken</translation>\n     </message>\n+    <message>\n+        <source>Hide tray icon</source>\n+        <translation>Peida tegumiriba ikoon</translation>\n+    </message>\n     <message>\n         <source>Show only a tray icon after minimizing the window.</source>\n         <translation>Minimeeri systray alale.</translation>\n@@ -903,10 +911,30 @@\n         <source>N/A</source>\n         <translation>N/A</translation>\n     </message>\n+    <message>\n+        <source>%1 ms</source>\n+        <translation>%1 ms</translation>\n+    </message>\n+    <message numerus=\"yes\">\n+        <source>%n hour(s)</source>\n+        <translation><numerusform>%n tund</numerusform><numerusform>%n tundi</numerusform></translation>\n+    </message>\n+    <message numerus=\"yes\">\n+        <source>%n day(s)</source>\n+        <translation><numerusform>%n p\u00e4ev</numerusform><numerusform>%n p\u00e4eva</numerusform></translation>\n+    </message>\n+    <message numerus=\"yes\">\n+        <source>%n week(s)</source>\n+        <translation><numerusform>%n n\u00e4dal</numerusform><numerusform>%n n\u00e4dalat</numerusform></translation>\n+    </message>\n     <message>\n         <source>%1 and %2</source>\n         <translation>%1 ja %2</translation>\n     </message>\n+    <message numerus=\"yes\">\n+        <source>%n year(s)</source>\n+        <translation><numerusform>%n aasta</numerusform><numerusform>%n aastat</numerusform></translation>\n+    </message>\n     </context>\n <context>\n     <name>QObject::QObject</name>"
      },
      {
        "sha": "21800231596a0bd70db1ab0f290fd1ec9bcf5534",
        "filename": "src/qt/locale/bitcoin_fr.ts",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_fr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_fr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -329,6 +329,10 @@\n         <source>Click to enable network activity again.</source>\n         <translation>Cliquer pour r\u00e9activer l'activit\u00e9 r\u00e9seau.</translation>\n     </message>\n+    <message>\n+        <source>Syncing Headers (%1%)...</source>\n+        <translation>Synchronisation des en-t\u00eates (%1)...</translation>\n+    </message>\n     <message>\n         <source>Reindexing blocks on disk...</source>\n         <translation>R\u00e9indexation des blocs sur le disque...</translation>"
      },
      {
        "sha": "9f2c7626de09550ee73eb86eaed9c3acbc01bfc7",
        "filename": "src/qt/locale/bitcoin_it.ts",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_it.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_it.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_it.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -702,10 +702,6 @@\n         <source>Error</source>\n         <translation>Errore</translation>\n     </message>\n-    <message numerus=\"yes\">\n-        <source>%n GB of free space available</source>\n-        <translation><numerusform>GB di spazio libero disponibile</numerusform><numerusform>%n GB di spazio disponibile</numerusform></translation>\n-    </message>\n     <message numerus=\"yes\">\n         <source>(of %n GB needed)</source>\n         <translation><numerusform>(di %nGB richiesti)</numerusform><numerusform>(%n GB richiesti)</numerusform></translation>"
      },
      {
        "sha": "3202587cbd54bc3773667a348375112c358ded02",
        "filename": "src/qt/locale/bitcoin_pt_BR.ts",
        "status": "modified",
        "additions": 24,
        "deletions": 16,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_pt_BR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_pt_BR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_BR.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -23,7 +23,7 @@\n     </message>\n     <message>\n         <source>C&amp;lose</source>\n-        <translation>Fechar</translation>\n+        <translation>&amp;Fechar</translation>\n     </message>\n     <message>\n         <source>Delete the currently selected address from the list</source>\n@@ -39,7 +39,7 @@\n     </message>\n     <message>\n         <source>&amp;Delete</source>\n-        <translation>&amp;Excluir</translation>\n+        <translation>E&amp;xcluir</translation>\n     </message>\n     <message>\n         <source>Choose the address to send coins to</source>\n@@ -102,15 +102,15 @@\n     <name>AddressTableModel</name>\n     <message>\n         <source>Label</source>\n-        <translation>R\u00f3tuo</translation>\n+        <translation>R\u00f3tulo</translation>\n     </message>\n     <message>\n         <source>Address</source>\n         <translation>Endere\u00e7o</translation>\n     </message>\n     <message>\n         <source>(no label)</source>\n-        <translation>(sem r\u00f3tuo)</translation>\n+        <translation>(sem r\u00f3tulo)</translation>\n     </message>\n </context>\n <context>\n@@ -231,7 +231,7 @@\n     <name>BitcoinGUI</name>\n     <message>\n         <source>Sign &amp;message...</source>\n-        <translation>&amp;Assinar mensagem...</translation>\n+        <translation>Assinar &amp;mensagem...</translation>\n     </message>\n     <message>\n         <source>Synchronizing with network...</source>\n@@ -375,7 +375,7 @@\n     </message>\n     <message>\n         <source>&amp;Show / Hide</source>\n-        <translation>&amp;Exibir/Ocultar</translation>\n+        <translation>&amp;Exibir / Ocultar</translation>\n     </message>\n     <message>\n         <source>Show or hide the main Window</source>\n@@ -479,7 +479,7 @@\n     </message>\n     <message>\n         <source>%1 client</source>\n-        <translation>%1</translation>\n+        <translation>%1 cliente</translation>\n     </message>\n     <message>\n         <source>Connecting to peers...</source>\n@@ -688,7 +688,7 @@\n     </message>\n     <message>\n         <source>(no label)</source>\n-        <translation>(sem r\u00f3tuo)</translation>\n+        <translation>(sem r\u00f3tulo)</translation>\n     </message>\n     <message>\n         <source>change from %1 (%2)</source>\n@@ -1360,6 +1360,10 @@\n         <source>Node/Service</source>\n         <translation>N\u00f3/Servi\u00e7o</translation>\n     </message>\n+    <message>\n+        <source>NodeId</source>\n+        <translation>ID do n\u00f3</translation>\n+    </message>\n     <message>\n         <source>Ping</source>\n         <translation>Ping</translation>\n@@ -1900,7 +1904,7 @@\n     </message>\n     <message>\n         <source>Label</source>\n-        <translation>R\u00f3tuo</translation>\n+        <translation>R\u00f3tulo</translation>\n     </message>\n     <message>\n         <source>Message</source>\n@@ -1923,15 +1927,15 @@\n     </message>\n     <message>\n         <source>Label</source>\n-        <translation>R\u00f3tuo</translation>\n+        <translation>R\u00f3tulo</translation>\n     </message>\n     <message>\n         <source>Message</source>\n         <translation>Mensagem</translation>\n     </message>\n     <message>\n         <source>(no label)</source>\n-        <translation>(sem r\u00f3tuo)</translation>\n+        <translation>(sem r\u00f3tulo)</translation>\n     </message>\n     <message>\n         <source>(no message)</source>\n@@ -2210,7 +2214,7 @@\n     </message>\n     <message>\n         <source>(no label)</source>\n-        <translation>(sem r\u00f3tuo)</translation>\n+        <translation>(sem r\u00f3tulo)</translation>\n     </message>\n </context>\n <context>\n@@ -2665,7 +2669,7 @@\n     </message>\n     <message>\n         <source>Label</source>\n-        <translation>R\u00f3tuo</translation>\n+        <translation>R\u00f3tulo</translation>\n     </message>\n     <message numerus=\"yes\">\n         <source>Open for %n more block(s)</source>\n@@ -2741,7 +2745,7 @@\n     </message>\n     <message>\n         <source>(no label)</source>\n-        <translation>(sem r\u00f3tuo)</translation>\n+        <translation>(sem r\u00f3tulo)</translation>\n     </message>\n     <message>\n         <source>Transaction status. Hover over this field to show number of confirmations.</source>\n@@ -2888,7 +2892,7 @@\n     </message>\n     <message>\n         <source>Label</source>\n-        <translation>R\u00f3tuo</translation>\n+        <translation>R\u00f3tulo</translation>\n     </message>\n     <message>\n         <source>Address</source>\n@@ -3797,6 +3801,10 @@\n         <source>Relay non-P2SH multisig (default: %u)</source>\n         <translation>Retransmitir P2SH n\u00e3o multisig (padr\u00e3o: %u)</translation>\n     </message>\n+    <message>\n+        <source>Send transactions with full-RBF opt-in enabled (default: %u)</source>\n+        <translation>Ativar op\u00e7\u00e3o full-RBF nas transa\u00e7\u00f5es enviadas (padr\u00e3o: %u)</translation>\n+    </message>\n     <message>\n         <source>Set key pool size to &lt;n&gt; (default: %u)</source>\n         <translation>Defina o tamanho da chave para piscina&lt;n&gt; (padr\u00e3o: %u)</translation>\n@@ -3819,7 +3827,7 @@\n     </message>\n     <message>\n         <source>Specify pid file (default: %s)</source>\n-        <translation>Especificar aqrquivo pid (padr\u00e3o: %s)</translation>\n+        <translation>Especificar arquivo pid (padr\u00e3o: %s)</translation>\n     </message>\n     <message>\n         <source>Spend unconfirmed change when sending transactions (default: %u)</source>"
      },
      {
        "sha": "2de0d14ddd24bdc6adddf6d72c0d47729159291f",
        "filename": "src/qt/locale/bitcoin_tr.ts",
        "status": "modified",
        "additions": 1406,
        "deletions": 202,
        "changes": 1608,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_tr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_tr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_tr.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab"
      },
      {
        "sha": "20875c232722ac12e09037eafbc3d74e3942b401",
        "filename": "src/qt/locale/bitcoin_zh_CN.ts",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_zh_CN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/locale/bitcoin_zh_CN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_CN.ts?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -481,6 +481,10 @@\n         <source>%1 client</source>\n         <translation>%1 \u5ba2\u6236</translation>\n     </message>\n+    <message>\n+        <source>Connecting to peers...</source>\n+        <translation>\u6b63\u5728\u8fde\u63a5\u5230\u8282\u70b9\u2026\u2026</translation>\n+    </message>\n     <message>\n         <source>Catching up...</source>\n         <translation>\u66f4\u65b0\u4e2d...</translation>\n@@ -1927,7 +1931,11 @@\n         <source>(no amount requested)</source>\n         <translation>\uff08\u65e0\u8bf7\u6c42\u91d1\u989d\uff09</translation>\n     </message>\n-    </context>\n+    <message>\n+        <source>Requested</source>\n+        <translation>\u603b\u989d</translation>\n+    </message>\n+</context>\n <context>\n     <name>SendCoinsDialog</name>\n     <message>\n@@ -2178,6 +2186,10 @@\n         <source>Warning: Unknown change address</source>\n         <translation>\u8b66\u544a\uff1a\u672a\u77e5\u7684\u66f4\u6539\u5730\u5740</translation>\n     </message>\n+    <message>\n+        <source>The address you selected for change is not part of this wallet. Any or all funds in your wallet may be sent to this address. Are you sure?</source>\n+        <translation>\u4f60\u9009\u62e9\u7684\u627e\u96f6\u5730\u5740\u672a\u88ab\u5305\u542b\u5728\u672c\u94b1\u5305\u4e2d\uff0c\u4f60\u94b1\u5305\u4e2d\u7684\u90e8\u5206\u6216\u5168\u90e8\u91d1\u989d\u5c06\u88ab\u53d1\u9001\u81f3\u8be5\u5730\u5740\u3002\u4f60\u786e\u5b9a\u8981\u8fd9\u6837\u505a\u5417\uff1f</translation>\n+    </message>\n     <message>\n         <source>(no label)</source>\n         <translation>(\u65e0\u6807\u7b7e)</translation>\n@@ -2459,6 +2471,14 @@\n         <source>0/unconfirmed, %1</source>\n         <translation>0/\u672a\u786e\u8ba4\uff0c%1</translation>\n     </message>\n+    <message>\n+        <source>in memory pool</source>\n+        <translation>\u5728\u5185\u5b58\u6c60\u4e2d</translation>\n+    </message>\n+    <message>\n+        <source>not in memory pool</source>\n+        <translation>\u4e0d\u5728\u5185\u5b58\u6c60\u4e2d</translation>\n+    </message>\n     <message>\n         <source>abandoned</source>\n         <translation>\u5df2\u629b\u5f03</translation>\n@@ -3200,6 +3220,10 @@\n         <source>Use UPnP to map the listening port (default: %u)</source>\n         <translation>\u4f7f\u7528UPnp\u6620\u5c04\u76d1\u542c\u7aef\u53e3 (\u9ed8\u8ba4: %u) </translation>\n     </message>\n+    <message>\n+        <source>Use the test chain</source>\n+        <translation>\u4f7f\u7528\u6d4b\u8bd5\u94fe</translation>\n+    </message>\n     <message>\n         <source>User Agent comment (%s) contains unsafe characters.</source>\n         <translation>\u7528\u6237\u4ee3\u7406\u8bc4\u8bba(%s)\u5305\u542b\u4e0d\u5b89\u5168\u7684\u5b57\u7b26\u3002</translation>"
      },
      {
        "sha": "7ff00b1e9eeb1f2ecae3b4516513e0c259efdbd2",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -277,6 +277,9 @@ void OptionsDialog::showRestartWarning(bool fPersistent)\n void OptionsDialog::clearStatusLabel()\n {\n     ui->statusLabel->clear();\n+    if (model && model->isRestartRequired()) {\n+        showRestartWarning(true);\n+    }\n }\n \n void OptionsDialog::updateProxyValidationState()\n@@ -286,7 +289,7 @@ void OptionsDialog::updateProxyValidationState()\n     if (pUiProxyIp->isValid() && (!ui->proxyPort->isEnabled() || ui->proxyPort->text().toInt() > 0) && (!ui->proxyPortTor->isEnabled() || ui->proxyPortTor->text().toInt() > 0))\n     {\n         setOkButtonState(otherProxyWidget->isValid()); //only enable ok button if both proxys are valid\n-        ui->statusLabel->clear();\n+        clearStatusLabel();\n     }\n     else\n     {"
      },
      {
        "sha": "a2fea3fdc64fb8d488a0e0498002f52bf461f208",
        "filename": "src/qt/paymentrequestplus.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/paymentrequestplus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/paymentrequestplus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -5,7 +5,10 @@\n #ifndef BITCOIN_QT_PAYMENTREQUESTPLUS_H\n #define BITCOIN_QT_PAYMENTREQUESTPLUS_H\n \n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n #include \"paymentrequest.pb.h\"\n+#pragma GCC diagnostic pop\n \n #include \"base58.h\"\n "
      },
      {
        "sha": "dd75f12076d9e78a7df3aa7c09196d9128d07e51",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -55,8 +55,6 @@ const char* BIP70_MESSAGE_PAYMENTREQUEST = \"PaymentRequest\";\n const char* BIP71_MIMETYPE_PAYMENT = \"application/bitcoin-payment\";\n const char* BIP71_MIMETYPE_PAYMENTACK = \"application/bitcoin-paymentack\";\n const char* BIP71_MIMETYPE_PAYMENTREQUEST = \"application/bitcoin-paymentrequest\";\n-// BIP70 max payment request size in bytes (DoS protection)\n-const qint64 BIP70_MAX_PAYMENTREQUEST_SIZE = 50000;\n \n struct X509StoreDeleter {\n       void operator()(X509_STORE* b) {"
      },
      {
        "sha": "7c6d4507fe6ce0c7055c1c6e02869638fe703c59",
        "filename": "src/qt/paymentserver.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/paymentserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/qt/paymentserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -53,7 +53,7 @@ class QUrl;\n QT_END_NAMESPACE\n \n // BIP70 max payment request size in bytes (DoS protection)\n-extern const qint64 BIP70_MAX_PAYMENTREQUEST_SIZE;\n+static const qint64 BIP70_MAX_PAYMENTREQUEST_SIZE = 50000;\n \n class PaymentServer : public QObject\n {"
      },
      {
        "sha": "7b69c81ff9c42ac95bd8fc0f289607b77c65695d",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -820,7 +820,8 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n         throw runtime_error(\n             \"pruneblockchain\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"height\\\"       (numeric, required) The block height to prune up to. May be set to a discrete height, or to a unix timestamp to prune based on block time.\\n\"\n+            \"1. \\\"height\\\"       (numeric, required) The block height to prune up to. May be set to a discrete height, or a unix timestamp\\n\"\n+            \"                  to prune blocks whose block time is at least 2 hours older than the provided timestamp.\\n\"\n             \"\\nResult:\\n\"\n             \"n    (numeric) Height of the last block pruned.\\n\"\n             \"\\nExamples:\\n\"\n@@ -839,7 +840,8 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n     // Height value more than a billion is too high to be a block height, and\n     // too low to be a block time (corresponds to timestamp from Sep 2001).\n     if (heightParam > 1000000000) {\n-        CBlockIndex* pindex = chainActive.FindEarliestAtLeast(heightParam);\n+        // Add a 2 hour buffer to include blocks which might have had old timestamps\n+        CBlockIndex* pindex = chainActive.FindEarliestAtLeast(heightParam - 7200);\n         if (!pindex) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Could not find block with at least the specified timestamp.\");\n         }"
      },
      {
        "sha": "29bdb376821751612aae0da7b08d56844daf9917",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -24,7 +24,7 @@ class CRPCConvertParam\n };\n \n /**\n- * Specifiy a (method, idx, name) here if the argument is a non-string RPC\n+ * Specify a (method, idx, name) here if the argument is a non-string RPC\n  * argument and needs to be converted from JSON.\n  *\n  * @note Parameter indexes start from 0."
      },
      {
        "sha": "77cd282a3da4ce78b61413c4cfb3b942b8097eb2",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -676,8 +676,12 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         nSigOpLimit /= WITNESS_SCALE_FACTOR;\n     }\n     result.push_back(Pair(\"sigoplimit\", nSigOpLimit));\n-    result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SERIALIZED_SIZE));\n-    result.push_back(Pair(\"weightlimit\", (int64_t)MAX_BLOCK_WEIGHT));\n+    if (fPreSegWit) {\n+        result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_BASE_SIZE));\n+    } else {\n+        result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SERIALIZED_SIZE));\n+        result.push_back(Pair(\"weightlimit\", (int64_t)MAX_BLOCK_WEIGHT));\n+    }\n     result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));"
      },
      {
        "sha": "140cb4840b147e8e86696bf303151c4be8c60655",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 5,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -167,6 +167,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n             \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string) The hex value of the raw public key\\n\"\n             \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n             \"  \\\"account\\\" : \\\"account\\\"         (string) DEPRECATED. The account associated with the address, \\\"\\\" is the default account\\n\"\n+            \"  \\\"timestamp\\\" : timestamp,        (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)\\n\"\n             \"  \\\"hdkeypath\\\" : \\\"keypath\\\"       (string, optional) The HD keypath if the key is HD and available\\n\"\n             \"  \\\"hdmasterkeyid\\\" : \\\"<hash160>\\\" (string, optional) The Hash160 of the HD master pubkey\\n\"\n             \"}\\n\"\n@@ -204,10 +205,19 @@ UniValue validateaddress(const JSONRPCRequest& request)\n         if (pwalletMain && pwalletMain->mapAddressBook.count(dest))\n             ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[dest].name));\n         CKeyID keyID;\n-        if (pwalletMain && address.GetKeyID(keyID) && pwalletMain->mapKeyMetadata.count(keyID) && !pwalletMain->mapKeyMetadata[keyID].hdKeypath.empty())\n-        {\n-            ret.push_back(Pair(\"hdkeypath\", pwalletMain->mapKeyMetadata[keyID].hdKeypath));\n-            ret.push_back(Pair(\"hdmasterkeyid\", pwalletMain->mapKeyMetadata[keyID].hdMasterKeyID.GetHex()));\n+        if (pwalletMain) {\n+            const auto& meta = pwalletMain->mapKeyMetadata;\n+            auto it = address.GetKeyID(keyID) ? meta.find(keyID) : meta.end();\n+            if (it == meta.end()) {\n+                it = meta.find(CScriptID(scriptPubKey));\n+            }\n+            if (it != meta.end()) {\n+                ret.push_back(Pair(\"timestamp\", it->second.nCreateTime));\n+                if (!it->second.hdKeypath.empty()) {\n+                    ret.push_back(Pair(\"hdkeypath\", it->second.hdKeypath));\n+                    ret.push_back(Pair(\"hdmasterkeyid\", it->second.hdMasterKeyID.GetHex()));\n+                }\n+            }\n         }\n #endif\n     }\n@@ -435,7 +445,7 @@ UniValue setmocktime(const JSONRPCRequest& request)\n     // this could have an effect on mempool time-based eviction, as well as\n     // IsCurrentForFeeEstimation() and IsInitialBlockDownload().\n     // TODO: figure out the right way to synchronize around mocktime, and\n-    // ensure all callsites of GetTime() are accessing this safely.\n+    // ensure all call sites of GetTime() are accessing this safely.\n     LOCK(cs_main);\n \n     RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));"
      },
      {
        "sha": "0b763acd451d613f15cb1924799ee2219ed06988",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -18,8 +18,6 @@\n #include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n-#include <boost/iostreams/concepts.hpp>\n-#include <boost/iostreams/stream.hpp>\n #include <boost/shared_ptr.hpp>\n #include <boost/signals2/signal.hpp>\n #include <boost/thread.hpp>"
      },
      {
        "sha": "6f364e42d13d8c220e8f4cd9c5e4c33374782054",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -93,8 +93,9 @@ static CSignatureCache signatureCache;\n // To be called once in AppInit2/TestingSetup to initialize the signatureCache\n void InitSignatureCache()\n {\n-    size_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n-    if (nMaxCacheSize <= 0) return;\n+    // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n+    // setup_bytes creates the minimum possible cache (2 elements).\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE)), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n     size_t nElems = signatureCache.setup_bytes(nMaxCacheSize);\n     LogPrintf(\"Using %zu MiB out of %zu requested for signature cache, able to store %zu elements\\n\",\n             (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);"
      },
      {
        "sha": "238952bb954df1daaa9af91a36f32d2d23d26b66",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -14,6 +14,8 @@\n // systems). Due to how we count cache size, actual memory usage is slightly\n // more (~32.25 MB)\n static const unsigned int DEFAULT_MAX_SIG_CACHE_SIZE = 32;\n+// Maximum sig cache size allowed\n+static const int64_t MAX_MAX_SIG_CACHE_SIZE = 16384;\n \n class CPubKey;\n "
      },
      {
        "sha": "c62e6ae838a94b03f3055e9c1921c2b656449958",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -23,7 +23,7 @@\n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n-// Tests this internal-to-main.cpp method:\n+// Tests these internal-to-net_processing.cpp methods:\n extern bool AddOrphanTx(const CTransactionRef& tx, NodeId peer);\n extern void EraseOrphansFor(NodeId peer);\n extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);"
      },
      {
        "sha": "e6d86229796b2e9f72c217364fd6d7872a056b74",
        "filename": "src/test/testutil.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 18,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/test/testutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/test/testutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/testutil.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -11,23 +11,5 @@\n #include <boost/filesystem.hpp>\n \n boost::filesystem::path GetTempPath() {\n-#if BOOST_FILESYSTEM_VERSION == 3\n     return boost::filesystem::temp_directory_path();\n-#else\n-    // TODO: remove when we don't support filesystem v2 anymore\n-    boost::filesystem::path path;\n-#ifdef WIN32\n-    char pszPath[MAX_PATH] = \"\";\n-\n-    if (GetTempPathA(MAX_PATH, pszPath))\n-        path = boost::filesystem::path(pszPath);\n-#else\n-    path = boost::filesystem::path(\"/tmp\");\n-#endif\n-    if (path.empty() || !boost::filesystem::is_directory(path)) {\n-        LogPrintf(\"GetTempPath(): failed to find temp path\\n\");\n-        return boost::filesystem::path(\"\");\n-    }\n-    return path;\n-#endif\n }"
      },
      {
        "sha": "5842dd88d838c8159b79d97d349ecdfe5d9ffa43",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -395,7 +395,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n {\n     NotifyEntryAdded(entry.GetSharedTx());\n     // Add to memory pool without checking anything.\n-    // Used by main.cpp AcceptToMemoryPool(), which DOES do\n+    // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n     indexed_transaction_set::iterator newit = mapTx.insert(entry).first;"
      },
      {
        "sha": "78c353dfe521dabcf0050466810ee256026ae9fb",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -214,12 +214,13 @@ void OpenDebugLog()\n     assert(vMsgsBeforeOpenLog);\n     boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n     fileout = fopen(pathDebug.string().c_str(), \"a\");\n-    if (fileout) setbuf(fileout, NULL); // unbuffered\n-\n-    // dump buffered messages from before we opened the log\n-    while (!vMsgsBeforeOpenLog->empty()) {\n-        FileWriteStr(vMsgsBeforeOpenLog->front(), fileout);\n-        vMsgsBeforeOpenLog->pop_front();\n+    if (fileout) {\n+        setbuf(fileout, NULL); // unbuffered\n+        // dump buffered messages from before we opened the log\n+        while (!vMsgsBeforeOpenLog->empty()) {\n+            FileWriteStr(vMsgsBeforeOpenLog->front(), fileout);\n+            vMsgsBeforeOpenLog->pop_front();\n+        }\n     }\n \n     delete vMsgsBeforeOpenLog;\n@@ -838,4 +839,4 @@ std::string CopyrightHolders(const std::string& strPrefix)\n         strCopyrightHolders += \"\\n\" + strPrefix + \"The Bitcoin Core developers\";\n     }\n     return strCopyrightHolders;\n-}\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "cc3290c63157097887b5c3978e7644afd08555f4",
        "filename": "src/utiltime.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/utiltime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/utiltime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -11,7 +11,7 @@\n \n /**\n  * GetTimeMicros() and GetTimeMillis() both return the system time, but in\n- * different units. GetTime() returns the sytem time in seconds, but also\n+ * different units. GetTime() returns the system time in seconds, but also\n  * supports mocktime, where the time can be specified by the user, eg for\n  * testing (eg with the setmocktime rpc, or -mocktime argument).\n  *"
      },
      {
        "sha": "cad1c9c16005aeda2eaaa5bdbe3687af767cbdba",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -1429,7 +1429,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         // Helps prevent CPU exhaustion attacks.\n \n         // Skip script verification when connecting blocks under the\n-        // assumedvalid block. Assuming the assumedvalid block is valid this\n+        // assumevalid block. Assuming the assumevalid block is valid this\n         // is safe because block merkle hashes are still computed and checked,\n         // Of course, if an assumed valid block is invalid due to false scriptSigs\n         // this optimization would allow an invalid chain to be accepted.\n@@ -1771,7 +1771,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n-                // The equivalent time check discourages hashpower from extorting the network via DOS attack\n+                // The equivalent time check discourages hash power from extorting the network via DOS attack\n                 //  into accepting an invalid block through telling users they must manually set assumevalid.\n                 //  Requiring a software change or burying the invalid block, regardless of the setting, makes\n                 //  it hard to hide the implication of the demand.  This also avoids having release candidates\n@@ -2486,12 +2486,12 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         bool fInitialDownload;\n         {\n             LOCK(cs_main);\n-            { // TODO: Tempoarily ensure that mempool removals are notified before\n+            { // TODO: Temporarily ensure that mempool removals are notified before\n               // connected transactions.  This shouldn't matter, but the abandoned\n               // state of transactions in our wallet is currently cleared when we\n               // receive another notification and there is a race condition where\n               // notification of a connected conflict might cause an outside process\n-              // to abandon a transaction and then have it inadvertantly cleared by\n+              // to abandon a transaction and then have it inadvertently cleared by\n               // the notification that the conflicted transaction was evicted.\n             MemPoolConflictRemovalTracker mrt(mempool);\n             CBlockIndex *pindexOldTip = chainActive.Tip();\n@@ -2520,7 +2520,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n \n             } // MemPoolConflictRemovalTracker destroyed and conflict evictions are notified\n \n-            // Transactions in the connnected block are notified\n+            // Transactions in the connected block are notified\n             for (const auto& pair : connectTrace.blocksConnected) {\n                 assert(pair.second);\n                 const CBlock& block = *(pair.second);\n@@ -3187,7 +3187,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     }\n     if (fNewBlock) *fNewBlock = true;\n \n-    if (!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime()) ||\n+    if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n         if (state.IsInvalid() && !state.CorruptionPossible()) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n@@ -3229,13 +3229,19 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool *fNewBlock)\n {\n     {\n-        LOCK(cs_main);\n-\n-        // Store to disk\n         CBlockIndex *pindex = NULL;\n         if (fNewBlock) *fNewBlock = false;\n         CValidationState state;\n-        bool ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock);\n+        // Ensure that CheckBlock() passes before calling AcceptBlock, as\n+        // belt-and-suspenders.\n+        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n+\n+        LOCK(cs_main);\n+\n+        if (ret) {\n+            // Store to disk\n+            ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock);\n+        }\n         CheckBlockIndex(chainparams.GetConsensus());\n         if (!ret) {\n             GetMainSignals().BlockChecked(*pblock, state);\n@@ -4174,7 +4180,7 @@ static const uint64_t MEMPOOL_DUMP_VERSION = 1;\n bool LoadMempool(void)\n {\n     int64_t nExpiryTimeout = GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60;\n-    FILE* filestr = fopen((GetDataDir() / \"mempool.dat\").string().c_str(), \"r\");\n+    FILE* filestr = fopen((GetDataDir() / \"mempool.dat\").string().c_str(), \"rb\");\n     CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);\n     if (file.IsNull()) {\n         LogPrintf(\"Failed to open mempool file from disk. Continuing anyway.\\n\");\n@@ -4255,7 +4261,7 @@ void DumpMempool(void)\n     int64_t mid = GetTimeMicros();\n \n     try {\n-        FILE* filestr = fopen((GetDataDir() / \"mempool.dat.new\").string().c_str(), \"w\");\n+        FILE* filestr = fopen((GetDataDir() / \"mempool.dat.new\").string().c_str(), \"wb\");\n         if (!filestr) {\n             return;\n         }"
      },
      {
        "sha": "a494eb6990fee9db508b77cc26b26a7504613982",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -50,7 +50,7 @@ class CValidationInterface {\n struct CMainSignals {\n     /** Notifies listeners of updated block chain tip */\n     boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    /** A posInBlock value for SyncTransaction calls for tranactions not\n+    /** A posInBlock value for SyncTransaction calls for transactions not\n      * included in connected blocks such as transactions removed from mempool,\n      * accepted to mempool or appearing in disconnected blocks.*/\n     static const int SYNC_TRANSACTION_NOT_IN_BLOCK = -1;"
      },
      {
        "sha": "e95c71ac8a145e55e7490ea752edfc7b9b3f912c",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 26,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -143,7 +143,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n \n         // whenever a key is imported, we need to scan the whole chain\n-        pwalletMain->nTimeFirstKey = 1; // 0 would be considered 'no value'\n+        pwalletMain->UpdateTimeFirstKey(1);\n \n         if (fRescan) {\n             pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n@@ -161,7 +161,7 @@ void ImportScript(const CScript& script, const string& strLabel, bool isRedeemSc\n \n     pwalletMain->MarkDirty();\n \n-    if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+    if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script, 0 /* nCreateTime */))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n \n     if (isRedeemScript) {\n@@ -500,8 +500,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n     while (pindex && pindex->pprev && pindex->GetBlockTime() > nTimeBegin - 7200)\n         pindex = pindex->pprev;\n \n-    if (!pwalletMain->nTimeFirstKey || nTimeBegin < pwalletMain->nTimeFirstKey)\n-        pwalletMain->nTimeFirstKey = nTimeBegin;\n+    pwalletMain->UpdateTimeFirstKey(nTimeBegin);\n \n     LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n     pwalletMain->ScanForWalletTransactions(pindex);\n@@ -576,15 +575,17 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n \n-    std::map<CKeyID, int64_t> mapKeyBirth;\n+    std::map<CTxDestination, int64_t> mapKeyBirth;\n     std::set<CKeyID> setKeyPool;\n     pwalletMain->GetKeyBirthTimes(mapKeyBirth);\n     pwalletMain->GetAllReserveKeys(setKeyPool);\n \n     // sort time/key pairs\n     std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;\n-    for (std::map<CKeyID, int64_t>::const_iterator it = mapKeyBirth.begin(); it != mapKeyBirth.end(); it++) {\n-        vKeyBirth.push_back(std::make_pair(it->second, it->first));\n+    for (const auto& entry : mapKeyBirth) {\n+        if (const CKeyID* keyID = boost::get<CKeyID>(&entry.first)) { // set and test\n+            vKeyBirth.push_back(std::make_pair(entry.second, *keyID));\n+        }\n     }\n     mapKeyBirth.clear();\n     std::sort(vKeyBirth.begin(), vKeyBirth.end());\n@@ -640,7 +641,8 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-UniValue processImport(const UniValue& data) {\n+UniValue ProcessImport(const UniValue& data, const int64_t timestamp)\n+{\n     try {\n         bool success = false;\n \n@@ -659,7 +661,6 @@ UniValue processImport(const UniValue& data) {\n         const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n         const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > 1 ? data[\"timestamp\"].get_int64() : 1;\n \n         bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n         bool isP2SH = strRedeemScript.length() > 0;\n@@ -671,6 +672,9 @@ UniValue processImport(const UniValue& data) {\n \n         if (!isScript) {\n             address = CBitcoinAddress(output);\n+            if (!address.IsValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+            }\n             script = GetScriptForDestination(address.Get());\n         } else {\n             if (!IsHex(output)) {\n@@ -721,7 +725,7 @@ UniValue processImport(const UniValue& data) {\n \n             pwalletMain->MarkDirty();\n \n-            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n@@ -738,7 +742,7 @@ UniValue processImport(const UniValue& data) {\n \n             pwalletMain->MarkDirty();\n \n-            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n@@ -782,9 +786,7 @@ UniValue processImport(const UniValue& data) {\n                         throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n                     }\n \n-                    if (timestamp < pwalletMain->nTimeFirstKey) {\n-                        pwalletMain->nTimeFirstKey = timestamp;\n-                    }\n+                    pwalletMain->UpdateTimeFirstKey(timestamp);\n                 }\n             }\n \n@@ -833,7 +835,7 @@ UniValue processImport(const UniValue& data) {\n \n                 pwalletMain->MarkDirty();\n \n-                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript, timestamp)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n@@ -851,7 +853,7 @@ UniValue processImport(const UniValue& data) {\n \n                 pwalletMain->MarkDirty();\n \n-                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey, timestamp)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n@@ -912,9 +914,7 @@ UniValue processImport(const UniValue& data) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n                 }\n \n-                if (timestamp < pwalletMain->nTimeFirstKey) {\n-                    pwalletMain->nTimeFirstKey = timestamp;\n-                }\n+                pwalletMain->UpdateTimeFirstKey(timestamp);\n \n                 success = true;\n             }\n@@ -927,7 +927,7 @@ UniValue processImport(const UniValue& data) {\n \n                 pwalletMain->MarkDirty();\n \n-                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script, timestamp)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n@@ -958,6 +958,20 @@ UniValue processImport(const UniValue& data) {\n     }\n }\n \n+int64_t GetImportTimestamp(const UniValue& data, int64_t now)\n+{\n+    if (data.exists(\"timestamp\")) {\n+        const UniValue& timestamp = data[\"timestamp\"];\n+        if (timestamp.isNum()) {\n+            return timestamp.get_int64();\n+        } else if (timestamp.isStr() && timestamp.get_str() == \"now\") {\n+            return now;\n+        }\n+        throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Expected number or \\\"now\\\" timestamp value for key. got type %s\", uvTypeName(timestamp.type())));\n+    }\n+    throw JSONRPCError(RPC_TYPE_ERROR, \"Missing required timestamp field for key\");\n+}\n+\n UniValue importmulti(const JSONRPCRequest& mainRequest)\n {\n     // clang-format off\n@@ -970,13 +984,18 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             \"  [     (array of json objects)\\n\"\n             \"    {\\n\"\n             \"      \\\"scriptPubKey\\\": \\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }, (string / json, required) Type of scriptPubKey (string for script, json for address)\\n\"\n+            \"      \\\"timestamp\\\": timestamp | \\\"now\\\"                        , (integer / string, required) Creation time of the key in seconds since epoch (Jan 1 1970 GMT),\\n\"\n+            \"                                                              or the string \\\"now\\\" to substitute the current synced blockchain time. The timestamp of the oldest\\n\"\n+            \"                                                              key will determine how far back blockchain rescans need to begin for missing wallet transactions.\\n\"\n+            \"                                                              \\\"now\\\" can be specified to bypass scanning, for keys which are known to never have been used, and\\n\"\n+            \"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\\n\"\n+            \"                                                              creation time of all keys being imported by the importmulti call will be scanned.\\n\"\n             \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n             \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n             \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n             \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n             \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n             \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n-            \"      \\\"timestamp\\\": 1454686740,                                (integer, optional, default now) Timestamp\\n\"\n             \"    }\\n\"\n             \"  ,...\\n\"\n             \"  ]\\n\"\n@@ -1015,6 +1034,12 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n     EnsureWalletIsUnlocked();\n \n+    // Verify all timestamps are present before importing any keys.\n+    const int64_t now = chainActive.Tip() ? chainActive.Tip()->GetMedianTimePast() : 0;\n+    for (const UniValue& data : requests.getValues()) {\n+        GetImportTimestamp(data, now);\n+    }\n+\n     bool fRunScan = false;\n     const int64_t minimumTimestamp = 1;\n     int64_t nLowestTimestamp = 0;\n@@ -1028,7 +1053,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     UniValue response(UniValue::VARR);\n \n     BOOST_FOREACH (const UniValue& data, requests.getValues()) {\n-        const UniValue result = processImport(data);\n+        const int64_t timestamp = std::max(GetImportTimestamp(data, now), minimumTimestamp);\n+        const UniValue result = ProcessImport(data, timestamp);\n         response.push_back(result);\n \n         if (!fRescan) {\n@@ -1041,15 +1067,13 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n         }\n \n         // Get the lowest timestamp.\n-        const int64_t& timestamp = data.exists(\"timestamp\") && data[\"timestamp\"].get_int64() > minimumTimestamp ? data[\"timestamp\"].get_int64() : minimumTimestamp;\n-\n         if (timestamp < nLowestTimestamp) {\n             nLowestTimestamp = timestamp;\n         }\n     }\n \n-    if (fRescan && fRunScan && requests.size() && nLowestTimestamp <= chainActive.Tip()->GetBlockTimeMax()) {\n-        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(nLowestTimestamp) : chainActive.Genesis();\n+    if (fRescan && fRunScan && requests.size()) {\n+        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(std::max<int64_t>(nLowestTimestamp - 7200, 0)) : chainActive.Genesis();\n \n         if (pindex) {\n             pwalletMain->ScanForWalletTransactions(pindex, true);"
      },
      {
        "sha": "01005bf3380c2c9bcb27474e975e5696ce70d8c9",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -2725,7 +2725,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n             \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n             \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n-            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         still be replaceable in practice, for example if it has unconfirmed ancestors which\\n\"\n             \"                         are replaceable).\\n\"\n             \"   }\\n\"\n             \"\\nResult:\\n\""
      },
      {
        "sha": "8df15a060edbf2c0e8293d16914b8ca494e6d06b",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 19,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -113,8 +113,7 @@ CPubKey CWallet::GenerateNewKey()\n     assert(secret.VerifyPubKey(pubkey));\n \n     mapKeyMetadata[pubkey.GetID()] = metadata;\n-    if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n-        nTimeFirstKey = nCreationTime;\n+    UpdateTimeFirstKey(nCreationTime);\n \n     if (!AddKeyPubKey(secret, pubkey))\n         throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n@@ -207,13 +206,11 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n     return false;\n }\n \n-bool CWallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n+bool CWallet::LoadKeyMetadata(const CTxDestination& keyID, const CKeyMetadata &meta)\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n-    if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n-        nTimeFirstKey = meta.nCreateTime;\n-\n-    mapKeyMetadata[pubkey.GetID()] = meta;\n+    UpdateTimeFirstKey(meta.nCreateTime);\n+    mapKeyMetadata[keyID] = meta;\n     return true;\n }\n \n@@ -222,6 +219,18 @@ bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigne\n     return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n }\n \n+void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n+{\n+    AssertLockHeld(cs_wallet);\n+    if (nCreateTime <= 1) {\n+        // Cannot determine birthday information, so set the wallet birthday to\n+        // the beginning of time.\n+        nTimeFirstKey = 1;\n+    } else if (!nTimeFirstKey || nCreateTime < nTimeFirstKey) {\n+        nTimeFirstKey = nCreateTime;\n+    }\n+}\n+\n bool CWallet::AddCScript(const CScript& redeemScript)\n {\n     if (!CCryptoKeyStore::AddCScript(redeemScript))\n@@ -247,15 +256,22 @@ bool CWallet::LoadCScript(const CScript& redeemScript)\n     return CCryptoKeyStore::AddCScript(redeemScript);\n }\n \n-bool CWallet::AddWatchOnly(const CScript &dest)\n+bool CWallet::AddWatchOnly(const CScript& dest)\n {\n     if (!CCryptoKeyStore::AddWatchOnly(dest))\n         return false;\n-    nTimeFirstKey = 1; // No birthday information for watch-only keys.\n+    const CKeyMetadata& meta = mapKeyMetadata[CScriptID(dest)];\n+    UpdateTimeFirstKey(meta.nCreateTime);\n     NotifyWatchonlyChanged(true);\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).WriteWatchOnly(dest);\n+    return CWalletDB(strWalletFile).WriteWatchOnly(dest, meta);\n+}\n+\n+bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n+{\n+    mapKeyMetadata[CScriptID(dest)].nCreateTime = nCreateTime;\n+    return AddWatchOnly(dest);\n }\n \n bool CWallet::RemoveWatchOnly(const CScript &dest)\n@@ -1012,7 +1028,7 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n  * TODO: One exception to this is that the abandoned state is cleared under the\n  * assumption that any further notification of a transaction that was considered\n  * abandoned is an indication that it is not safe to be considered abandoned.\n- * Abandoned state should probably be more carefuly tracked via different\n+ * Abandoned state should probably be more carefully tracked via different\n  * posInBlock signals or by checking mempool presence when necessary.\n  */\n bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n@@ -3416,14 +3432,16 @@ class CAffectedKeysVisitor : public boost::static_visitor<void> {\n     void operator()(const CNoDestination &none) {}\n };\n \n-void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n+void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) const {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n     mapKeyBirth.clear();\n \n     // get birth times for keys with metadata\n-    for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n-        if (it->second.nCreateTime)\n-            mapKeyBirth[it->first] = it->second.nCreateTime;\n+    for (const auto& entry : mapKeyMetadata) {\n+        if (entry.second.nCreateTime) {\n+            mapKeyBirth[entry.first] = entry.second.nCreateTime;\n+        }\n+    }\n \n     // map in which we'll infer heights of other keys\n     CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n@@ -3874,11 +3892,7 @@ bool CWallet::BackupWallet(const std::string& strDest)\n                     pathDest /= strWalletFile;\n \n                 try {\n-#if BOOST_VERSION >= 104000\n                     boost::filesystem::copy_file(pathSrc, pathDest, boost::filesystem::copy_option::overwrite_if_exists);\n-#else\n-                    boost::filesystem::copy_file(pathSrc, pathDest);\n-#endif\n                     LogPrintf(\"copied %s to %s\\n\", strWalletFile, pathDest.string());\n                     return true;\n                 } catch (const boost::filesystem::filesystem_error& e) {"
      },
      {
        "sha": "a7b15a8441c8410925bd0a1a4ae9b032517483ea",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 32,
        "deletions": 17,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -611,6 +611,20 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool fFileBacked;\n \n     std::set<int64_t> setKeyPool;\n+\n+    int64_t nTimeFirstKey;\n+\n+    /**\n+     * Private version of AddWatchOnly method which does not accept a\n+     * timestamp, and which will reset the wallet's nTimeFirstKey value to 1 if\n+     * the watch key did not previously have a timestamp associated with it.\n+     * Because this is an inherited virtual method, it is accessible despite\n+     * being marked private, but it is marked private anyway to encourage use\n+     * of the other AddWatchOnly which accepts a timestamp and sets\n+     * nTimeFirstKey more intelligently for more efficient rescans.\n+     */\n+    bool AddWatchOnly(const CScript& dest) override;\n+\n public:\n     /*\n      * Main wallet lock.\n@@ -635,7 +649,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n             mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n     }\n \n-    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n+    // Map from Key ID (for regular keys) or Script ID (for watch-only keys) to\n+    // key metadata.\n+    std::map<CTxDestination, CKeyMetadata> mapKeyMetadata;\n \n     typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n     MasterKeyMap mapMasterKeys;\n@@ -688,8 +704,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     std::set<COutPoint> setLockedCoins;\n \n-    int64_t nTimeFirstKey;\n-\n     const CWalletTx* GetWalletTx(const uint256& hash) const;\n \n     //! check whether we are allowed to upgrade (or already support) to the named feature\n@@ -723,19 +737,20 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CPubKey GenerateNewKey();\n     void DeriveNewChildKey(CKeyMetadata& metadata, CKey& secret);\n     //! Adds a key to the store, and saves it to disk.\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n     //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n     //! Load metadata (used by LoadWallet)\n-    bool LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &metadata);\n+    bool LoadKeyMetadata(const CTxDestination& pubKey, const CKeyMetadata &metadata);\n \n     bool LoadMinVersion(int nVersion) { AssertLockHeld(cs_wallet); nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n+    void UpdateTimeFirstKey(int64_t nCreateTime);\n \n     //! Adds an encrypted key to the store, and saves it to disk.\n-    bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret) override;\n     //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    bool AddCScript(const CScript& redeemScript);\n+    bool AddCScript(const CScript& redeemScript) override;\n     bool LoadCScript(const CScript& redeemScript);\n \n     //! Adds a destination data tuple to the store, and saves it to disk\n@@ -748,16 +763,16 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool GetDestData(const CTxDestination &dest, const std::string &key, std::string *value) const;\n \n     //! Adds a watch-only address to the store, and saves it to disk.\n-    bool AddWatchOnly(const CScript &dest);\n-    bool RemoveWatchOnly(const CScript &dest);\n+    bool AddWatchOnly(const CScript& dest, int64_t nCreateTime);\n+    bool RemoveWatchOnly(const CScript &dest) override;\n     //! Adds a watch-only address to the store, without saving it to disk (used by LoadWallet)\n     bool LoadWatchOnly(const CScript &dest);\n \n     bool Unlock(const SecureString& strWalletPassphrase);\n     bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);\n     bool EncryptWallet(const SecureString& strWalletPassphrase);\n \n-    void GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const;\n+    void GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) const;\n \n     /** \n      * Increment the next transaction order id\n@@ -771,11 +786,11 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose=true);\n     bool LoadToWallet(const CWalletTx& wtxIn);\n-    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock);\n+    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock) override;\n     bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     void ReacceptWalletTransactions();\n-    void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman);\n+    void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override;\n     std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman);\n     CAmount GetBalance() const;\n     CAmount GetUnconfirmedBalance() const;\n@@ -857,7 +872,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const;\n     CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n     CAmount GetChange(const CTransaction& tx) const;\n-    void SetBestChain(const CBlockLocator& loc);\n+    void SetBestChain(const CBlockLocator& loc) override;\n \n     DBErrors LoadWallet(bool& fFirstRunRet);\n     DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n@@ -867,9 +882,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     bool DelAddressBook(const CTxDestination& address);\n \n-    void UpdatedTransaction(const uint256 &hashTx);\n+    void UpdatedTransaction(const uint256 &hashTx) override;\n \n-    void Inventory(const uint256 &hash)\n+    void Inventory(const uint256 &hash) override\n     {\n         {\n             LOCK(cs_wallet);\n@@ -879,8 +894,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         }\n     }\n \n-    void GetScriptForMining(boost::shared_ptr<CReserveScript> &script);\n-    void ResetRequestCount(const uint256 &hash)\n+    void GetScriptForMining(boost::shared_ptr<CReserveScript> &script) override;\n+    void ResetRequestCount(const uint256 &hash) override\n     {\n         LOCK(cs_wallet);\n         mapRequestCount[hash] = 0;"
      },
      {
        "sha": "81fdde401ecb68aa660065cae937e662dc5f8c9a",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 18,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -120,15 +120,19 @@ bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n     return Write(std::make_pair(std::string(\"cscript\"), hash), *(const CScriptBase*)(&redeemScript), false);\n }\n \n-bool CWalletDB::WriteWatchOnly(const CScript &dest)\n+bool CWalletDB::WriteWatchOnly(const CScript &dest, const CKeyMetadata& keyMeta)\n {\n     nWalletDBUpdateCounter++;\n+    if (!Write(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest)), keyMeta))\n+        return false;\n     return Write(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)), '1');\n }\n \n bool CWalletDB::EraseWatchOnly(const CScript &dest)\n {\n     nWalletDBUpdateCounter++;\n+    if (!Erase(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest))))\n+        return false;\n     return Erase(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)));\n }\n \n@@ -259,14 +263,15 @@ class CWalletScanState {\n public:\n     unsigned int nKeys;\n     unsigned int nCKeys;\n+    unsigned int nWatchKeys;\n     unsigned int nKeyMeta;\n     bool fIsEncrypted;\n     bool fAnyUnordered;\n     int nFileVersion;\n     vector<uint256> vWalletUpgrade;\n \n     CWalletScanState() {\n-        nKeys = nCKeys = nKeyMeta = 0;\n+        nKeys = nCKeys = nWatchKeys = nKeyMeta = 0;\n         fIsEncrypted = false;\n         fAnyUnordered = false;\n         nFileVersion = 0;\n@@ -348,16 +353,13 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         }\n         else if (strType == \"watchs\")\n         {\n+            wss.nWatchKeys++;\n             CScript script;\n             ssKey >> *(CScriptBase*)(&script);\n             char fYes;\n             ssValue >> fYes;\n             if (fYes == '1')\n                 pwallet->LoadWatchOnly(script);\n-\n-            // Watch-only addresses have no birthday information for now,\n-            // so set the wallet birthday to the beginning of time.\n-            pwallet->nTimeFirstKey = 1;\n         }\n         else if (strType == \"key\" || strType == \"wkey\")\n         {\n@@ -458,20 +460,27 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             }\n             wss.fIsEncrypted = true;\n         }\n-        else if (strType == \"keymeta\")\n+        else if (strType == \"keymeta\" || strType == \"watchmeta\")\n         {\n-            CPubKey vchPubKey;\n-            ssKey >> vchPubKey;\n+            CTxDestination keyID;\n+            if (strType == \"keymeta\")\n+            {\n+              CPubKey vchPubKey;\n+              ssKey >> vchPubKey;\n+              keyID = vchPubKey.GetID();\n+            }\n+            else if (strType == \"watchmeta\")\n+            {\n+              CScript script;\n+              ssKey >> *(CScriptBase*)(&script);\n+              keyID = CScriptID(script);\n+            }\n+\n             CKeyMetadata keyMeta;\n             ssValue >> keyMeta;\n             wss.nKeyMeta++;\n \n-            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n-\n-            // find earliest key creation time, as wallet birthday\n-            if (!pwallet->nTimeFirstKey ||\n-                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n-                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n+            pwallet->LoadKeyMetadata(keyID, keyMeta);\n         }\n         else if (strType == \"defaultkey\")\n         {\n@@ -550,8 +559,8 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     bool fNoncriticalErrors = false;\n     DBErrors result = DB_LOAD_OK;\n \n+    LOCK(pwallet->cs_wallet);\n     try {\n-        LOCK(pwallet->cs_wallet);\n         int nMinVersion = 0;\n         if (Read((string)\"minversion\", nMinVersion))\n         {\n@@ -625,8 +634,8 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n            wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n \n     // nTimeFirstKey is only reliable if all keys have metadata\n-    if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n-        pwallet->nTimeFirstKey = 1; // 0 would be considered 'no value'\n+    if ((wss.nKeys + wss.nCKeys + wss.nWatchKeys) != wss.nKeyMeta)\n+        pwallet->UpdateTimeFirstKey(1);\n \n     BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n         WriteTx(pwallet->mapWallet[hash]);"
      },
      {
        "sha": "c7c65465df9a8fafb104c7a1e3875af71e60d1c8",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60d54ddb394bce457c87fee5474421db65811ab/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=d60d54ddb394bce457c87fee5474421db65811ab",
        "patch": "@@ -135,7 +135,7 @@ class CWalletDB : public CDB\n \n     bool WriteCScript(const uint160& hash, const CScript& redeemScript);\n \n-    bool WriteWatchOnly(const CScript &script);\n+    bool WriteWatchOnly(const CScript &script, const CKeyMetadata &keymeta);\n     bool EraseWatchOnly(const CScript &script);\n \n     bool WriteBestBlock(const CBlockLocator& locator);"
      }
    ]
  }
]