[
  {
    "sha": "688592f825333b626561d41d62689e4f184101d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODg1OTJmODI1MzMzYjYyNjU2MWQ0MWQ2MjY4OWU0ZjE4NDEwMWQ5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-12T00:10:25Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-19T23:39:06Z"
      },
      "message": "Remove unnecessary cs_mains in denialofservice_tests\n\n9fdf05d70cac4a62d1aeeb4299e2c3a9a866f8af resolved some lock\ninversion warnings in denialofservice_tests, but left in a number\nof cs_main locks that are unnecessary (introducing lock inversion\nwarnings in future changes).",
      "tree": {
        "sha": "7a22cc9d23ce306b5e5643ceb6b069a3fe9a0f01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a22cc9d23ce306b5e5643ceb6b069a3fe9a0f01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/688592f825333b626561d41d62689e4f184101d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/688592f825333b626561d41d62689e4f184101d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/688592f825333b626561d41d62689e4f184101d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/688592f825333b626561d41d62689e4f184101d9/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e00ecb3d7aaee463643e486ca03c318e192b8058",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e00ecb3d7aaee463643e486ca03c318e192b8058",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e00ecb3d7aaee463643e486ca03c318e192b8058"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 12,
      "deletions": 12
    },
    "files": [
      {
        "sha": "9b1c798ca1c3de66d98c11b40bbcd69bc4261e61",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/688592f825333b626561d41d62689e4f184101d9/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/688592f825333b626561d41d62689e4f184101d9/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=688592f825333b626561d41d62689e4f184101d9",
        "patch": "@@ -98,11 +98,11 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     // Test starts here\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_vSend);\n+        LOCK(dummyNode1.cs_vSend);\n         BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n         dummyNode1.vSendMsg.clear();\n     }\n@@ -111,17 +111,17 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     // Wait 21 minutes\n     SetMockTime(nStartTime+21*60);\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_vSend);\n+        LOCK(dummyNode1.cs_vSend);\n         BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n     }\n     // Wait 3 more minutes\n     SetMockTime(nStartTime+24*60);\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in disconnect\n     }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n@@ -235,7 +235,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(banman->IsBanned(addr1));\n@@ -252,7 +252,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n-        LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n+        LOCK(dummyNode2.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr2)); // 2 not banned yet...\n@@ -262,7 +262,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n-        LOCK2(cs_main, dummyNode2.cs_sendProcessing);\n+        LOCK(dummyNode2.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n     }\n     BOOST_CHECK(banman->IsBanned(addr2));\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         Misbehaving(dummyNode1.GetId(), 100);\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n@@ -300,7 +300,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         Misbehaving(dummyNode1.GetId(), 10);\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n@@ -309,7 +309,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n         Misbehaving(dummyNode1.GetId(), 1);\n     }\n     {\n-        LOCK2(cs_main, dummyNode1.cs_sendProcessing);\n+        LOCK(dummyNode1.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n     }\n     BOOST_CHECK(banman->IsBanned(addr1));\n@@ -341,7 +341,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n         Misbehaving(dummyNode.GetId(), 100);\n     }\n     {\n-        LOCK2(cs_main, dummyNode.cs_sendProcessing);\n+        LOCK(dummyNode.cs_sendProcessing);\n         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n     }\n     BOOST_CHECK(banman->IsBanned(addr));"
      }
    ]
  },
  {
    "sha": "e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDE2YjY2YTYwZDg3ZGMzZDM2NGYzOWUwZmIxNDg5MzkxZDNkNGI2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-16T16:14:45Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-19T23:39:06Z"
      },
      "message": "Return the AcceptBlock CValidationState directly in ProcessNewBlock\n\nIn practice this means that CheckBlock+ContextualCheckBlock are\ncalled with a passed-in CValidationState before we move onto\nconnecting the best chain. This makes conceptual sense as these\ncalls represent the DoS checks on a block (ie PoW and malleability)\nwhich the caller almost certainly wants to know about right away\nand shouldn't have to wait on a callback for (and other\nvalidationinterface clients shouldn't care about someone submitting\nbogus malleated blocks to PNB).\n\nThis also makes it much, much easier to move the best chain\nactivation logic to a background thread as it implies that if PNB\nreturns with a IsValid() CValidationState we don't need to care\nabout trying to process (non-malleated) copies of the block from\nother peers.",
      "tree": {
        "sha": "7009d59e315e3815c1497b0b95b7d5269b67b3c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7009d59e315e3815c1497b0b95b7d5269b67b3c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "688592f825333b626561d41d62689e4f184101d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/688592f825333b626561d41d62689e4f184101d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/688592f825333b626561d41d62689e4f184101d9"
      }
    ],
    "stats": {
      "total": 125,
      "additions": 86,
      "deletions": 39
    },
    "files": [
      {
        "sha": "bbe7b358deea0571ecf370434352d1f4dda836f0",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 9,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -1232,7 +1232,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n  * Handle invalid block rejection and consequent peer banning, maintain which\n  * peers announce compact blocks.\n  */\n-void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n+static void BlockChecked(const CBlock& block, const CValidationState& state, CConnman* connman) {\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n@@ -1263,6 +1263,10 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n         mapBlockSource.erase(it);\n }\n \n+void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n+    ::BlockChecked(block, state, connman);\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Messages\n@@ -2819,15 +2823,19 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n+            CValidationState dos_state;\n+            ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true, &fNewBlock);\n+            if (fNewBlock && dos_state.IsValid()) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n+                if (!dos_state.IsValid()) {\n+                    BlockChecked(*pblock, dos_state, connman);\n+                }\n                 LOCK(cs_main);\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n+            if (dos_state.IsValid()) {\n+                LOCK(cs_main);\n                 // Clear download state for this block, which is in\n                 // process from some other peer.  We do this after calling\n                 // ProcessNewBlock so that a malleated cmpctblock announcement\n@@ -2908,10 +2916,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n+            CValidationState dos_state;\n+            ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true, &fNewBlock);\n+            if (fNewBlock && dos_state.IsValid()) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n+                if (!dos_state.IsValid()) {\n+                    BlockChecked(*pblock, dos_state, connman);\n+                }\n                 LOCK(cs_main);\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n@@ -2970,10 +2982,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n         bool fNewBlock = false;\n-        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n-        if (fNewBlock) {\n+        CValidationState dos_state;\n+        ProcessNewBlock(chainparams, pblock, dos_state, forceProcessing, &fNewBlock);\n+        if (fNewBlock && dos_state.IsValid()) {\n             pfrom->nLastBlockTime = GetTime();\n         } else {\n+            if (!dos_state.IsValid()) {\n+                BlockChecked(*pblock, dos_state, connman);\n+            }\n             LOCK(cs_main);\n             mapBlockSource.erase(pblock->GetHash());\n         }"
      },
      {
        "sha": "53141150678f0c2c1b9a3e984e6c359fa9b1ae34",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -132,7 +132,8 @@ static UniValue generateBlocks(const CScript& coinbase_script, int nGenerate, ui\n             continue;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n+        CValidationState state;\n+        if (!ProcessNewBlock(Params(), shared_pblock, state, true, nullptr) || !state.IsValid())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -733,15 +734,20 @@ static UniValue submitblock(const JSONRPCRequest& request)\n     bool new_block;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool accepted = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n+    CValidationState dos_state;\n+    bool accepted = ProcessNewBlock(Params(), blockptr, dos_state, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n     UnregisterValidationInterface(&sc);\n     if (!new_block && accepted) {\n         return \"duplicate\";\n     }\n-    if (!sc.found) {\n+    if (!sc.found && dos_state.IsValid()) {\n         return \"inconclusive\";\n     }\n-    return BIP22ValidationResult(sc.state);\n+    if (dos_state.IsValid()) {\n+        return BIP22ValidationResult(sc.state);\n+    } else {\n+        return BIP22ValidationResult(dos_state);\n+    }\n }\n \n static UniValue submitheader(const JSONRPCRequest& request)"
      },
      {
        "sha": "c2f27d9dd0dd164f4a52dbeed0f382543681057b",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -176,7 +176,9 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     uint256 chainA_last_header = last_header;\n     for (size_t i = 0; i < 2; i++) {\n         const auto& block = chainA[i];\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, true, nullptr));\n+        CValidationState dos_state;\n+        BOOST_REQUIRE(ProcessNewBlock(Params(), block, dos_state, true, nullptr));\n+        BOOST_REQUIRE(dos_state.IsValid());\n \n         const CBlockIndex* block_index;\n         {\n@@ -192,7 +194,9 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     uint256 chainB_last_header = last_header;\n     for (size_t i = 0; i < 3; i++) {\n         const auto& block = chainB[i];\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, true, nullptr));\n+        CValidationState dos_state;\n+        BOOST_REQUIRE(ProcessNewBlock(Params(), block, dos_state, true, nullptr));\n+        BOOST_REQUIRE(dos_state.IsValid());\n \n         const CBlockIndex* block_index;\n         {\n@@ -219,10 +223,12 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     }\n \n     // Reorg back to chain A.\n-     for (size_t i = 2; i < 4; i++) {\n-         const auto& block = chainA[i];\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, true, nullptr));\n-     }\n+    for (size_t i = 2; i < 4; i++) {\n+        const auto& block = chainA[i];\n+        CValidationState dos_state;\n+        BOOST_REQUIRE(ProcessNewBlock(Params(), block, dos_state, true, nullptr));\n+        BOOST_REQUIRE(dos_state.IsValid());\n+    }\n \n      // Check that chain A and B blocks can be retrieved.\n      chainA_last_header = last_header;"
      },
      {
        "sha": "04ba69b30207529197d1c94a9268d0953cb474d5",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -7,6 +7,7 @@\n #include <consensus/consensus.h>\n #include <consensus/merkle.h>\n #include <consensus/tx_verify.h>\n+#include <consensus/validation.h>\n #include <miner.h>\n #include <policy/policy.h>\n #include <script/standard.h>\n@@ -247,7 +248,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n             pblock->nNonce = blockinfo[i].nonce;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n+        CValidationState dos_state;\n+        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, dos_state, true, nullptr));\n+        BOOST_CHECK(dos_state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n "
      },
      {
        "sha": "3c8de13a1d9f4fb5aa669cad59814d958a230153",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -164,7 +164,8 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n+    CValidationState dos_state;\n+    ProcessNewBlock(chainparams, shared_pblock, dos_state, true, nullptr);\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "ee473cf412968316592af10fc22ba0b415b4b7c2",
        "filename": "src/test/util.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <chainparams.h>\n #include <consensus/merkle.h>\n+#include <consensus/validation.h>\n #include <key_io.h>\n #include <miner.h>\n #include <outputtype.h>\n@@ -61,8 +62,10 @@ CTxIn MineBlock(const CScript& coinbase_scriptPubKey)\n         assert(block->nNonce);\n     }\n \n-    bool processed{ProcessNewBlock(Params(), block, true, nullptr)};\n+    CValidationState dos_state;\n+    bool processed{ProcessNewBlock(Params(), block, dos_state, true, nullptr)};\n     assert(processed);\n+    assert(dos_state.IsValid());\n \n     return CTxIn{block->vtx[0]->GetHash(), 0};\n }"
      },
      {
        "sha": "bb21ffb321ec8520a25995129325e8b7ec13f3e3",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -159,7 +159,8 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     BOOST_CHECK(ProcessNewBlockHeaders(headers, state, Params()));\n \n     // Connect the genesis block and drain any outstanding events\n-    BOOST_CHECK(ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored));\n+    CValidationState dos_state;\n+    BOOST_CHECK(ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), dos_state, true, &ignored));\n     SyncWithValidationInterfaceQueue();\n \n     // subscribe to events (this subscriber will validate event ordering)\n@@ -181,14 +182,17 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n             FastRandomContext insecure;\n             for (int i = 0; i < 1000; i++) {\n                 auto block = blocks[insecure.randrange(blocks.size() - 1)];\n-                ProcessNewBlock(Params(), block, true, &ignored);\n+                CValidationState dos_state;\n+                ProcessNewBlock(Params(), block, dos_state, true, &ignored);\n             }\n \n             // to make sure that eventually we process the full chain - do it here\n             for (auto block : blocks) {\n                 if (block->vtx.size() == 1) {\n-                    bool processed = ProcessNewBlock(Params(), block, true, &ignored);\n+                    CValidationState dos_state;\n+                    bool processed = ProcessNewBlock(Params(), block, dos_state, true, &ignored);\n                     assert(processed);\n+                    assert(dos_state.IsValid());\n                 }\n             }\n         });\n@@ -228,7 +232,8 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n {\n     bool ignored;\n     auto ProcessBlock = [&ignored](std::shared_ptr<const CBlock> block) -> bool {\n-        return ProcessNewBlock(Params(), block, /* fForceProcessing */ true, /* fNewBlock */ &ignored);\n+        CValidationState dos_state;\n+        return ProcessNewBlock(Params(), block, dos_state, /* fForceProcessing */ true, /* fNewBlock */ &ignored);\n     };\n \n     // Process all mined blocks"
      },
      {
        "sha": "bc3a8e79c7e861b5bbdaec814520fec77a09b3fa",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -3507,14 +3507,13 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     return true;\n }\n \n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool *fNewBlock)\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing, bool *fNewBlock)\n {\n     AssertLockNotHeld(cs_main);\n \n     {\n         CBlockIndex *pindex = nullptr;\n         if (fNewBlock) *fNewBlock = false;\n-        CValidationState state;\n \n         // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n         // Therefore, the following critical section must include the CheckBlock() call as well.\n@@ -3528,15 +3527,14 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n             ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n         }\n         if (!ret) {\n-            GetMainSignals().BlockChecked(*pblock, state);\n             return error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n         }\n     }\n \n     NotifyHeaderTip();\n \n-    CValidationState state; // Only used to report errors, not invalidity - ignore it\n-    if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n+    CValidationState dummy_state; // Only used to report errors, not invalidity - ignore it\n+    if (!::ChainstateActive().ActivateBestChain(dummy_state, chainparams, pblock))\n         return error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n     return true;"
      },
      {
        "sha": "28fac7d37edab1f1da2583c92ff0421725885b96",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 17,
        "deletions": 8,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e416b66a60d87dc3d364f39e0fb1489391d3d4b6/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "patch": "@@ -198,22 +198,31 @@ static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n  * block is made active. Note that it does not, however, guarantee that the\n  * specific block passed to it has been checked for validity!\n  *\n- * If you want to *possibly* get feedback on whether pblock is valid, you must\n- * install a CValidationInterface (see validationinterface.h) - this will have\n- * its BlockChecked method called whenever *any* block completes validation.\n+ * Performs initial sanity checks using the provided CValidationState before\n+ * connecting any block(s). If you want to *possibly* get feedback on whether\n+ * pblock is valid beyond just cursory mutation/DoS checks, you must install\n+ * a CValidationInterface (see validationinterface.h) - this will have its\n+ * BlockChecked method called whenever *any* block completes validation (note\n+ * that any invalidity returned via state will *not* also be provided via\n+ * BlockChecked). There is, of course, no guarantee that any given block which\n+ * is not a part of the eventual best chain will ever be checked.\n  *\n- * Note that we guarantee that either the proof-of-work is valid on pblock, or\n- * (and possibly also) BlockChecked will have been called.\n+ * If pblock connects, and has been mutation, state is guaranteed to be some\n+ * non-IsValid() state.\n  *\n- * May not be called in a\n- * validationinterface callback.\n+ * If fForceProcessing is set (or fNewBlock returns true), barring pruning and\n+ * a desire to re-download a pruned block, if state.IsValid(), there should\n+ * never be any reason to re-ProcessNewBlock any block with the same hash.\n+ *\n+ * May not be called in a validationinterface callback.\n  *\n  * @param[in]   pblock  The block we want to process.\n+ * @param[out] state This may be set to an Error state if any error occurred processing them\n  * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n  * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n  * @return True if state.IsValid()\n  */\n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock) LOCKS_EXCLUDED(cs_main);\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing, bool* fNewBlock) LOCKS_EXCLUDED(cs_main);\n \n /**\n  * Process incoming block headers."
      }
    ]
  },
  {
    "sha": "269a06007e044d85f9fabdb1518493c62296eec4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNjlhMDYwMDdlMDQ0ZDg1ZjlmYWJkYjE1MTg0OTNjNjIyOTZlZWM0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-17T16:57:01Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-19T23:39:06Z"
      },
      "message": "Make ProcessNewBlock return a future instead of an immediate bool\n\nThis prepares for making best-chain-activation and disk writes\nhappen in a separate thread from the caller, even though all\ncallsites currently block on the return value immediately.",
      "tree": {
        "sha": "829326c826e353db5cb5dafc299ed035b0282a64",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/829326c826e353db5cb5dafc299ed035b0282a64"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/269a06007e044d85f9fabdb1518493c62296eec4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/269a06007e044d85f9fabdb1518493c62296eec4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/269a06007e044d85f9fabdb1518493c62296eec4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/269a06007e044d85f9fabdb1518493c62296eec4/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e416b66a60d87dc3d364f39e0fb1489391d3d4b6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e416b66a60d87dc3d364f39e0fb1489391d3d4b6"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 45,
      "deletions": 35
    },
    "files": [
      {
        "sha": "d21da497b0119f3de6e1136abf69f7a5db7174f9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -2813,7 +2813,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_main);\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n-            bool fNewBlock = false;\n             // Setting fForceProcessing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n             // unrequested blocks that might be trying to waste our resources\n@@ -2824,7 +2823,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n             CValidationState dos_state;\n-            ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true, &fNewBlock);\n+            bool fNewBlock = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true).get();\n             if (fNewBlock && dos_state.IsValid()) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2909,15 +2908,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n-            bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n             CValidationState dos_state;\n-            ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true, &fNewBlock);\n+            bool fNewBlock = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true).get();\n             if (fNewBlock && dos_state.IsValid()) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2981,9 +2979,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n-        bool fNewBlock = false;\n         CValidationState dos_state;\n-        ProcessNewBlock(chainparams, pblock, dos_state, forceProcessing, &fNewBlock);\n+        bool fNewBlock = ProcessNewBlock(chainparams, pblock, dos_state, forceProcessing).get();\n         if (fNewBlock && dos_state.IsValid()) {\n             pfrom->nLastBlockTime = GetTime();\n         } else {"
      },
      {
        "sha": "d76940f6c93580a9e32492f3d595ff26a05eb6c2",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -133,7 +133,8 @@ static UniValue generateBlocks(const CScript& coinbase_script, int nGenerate, ui\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n         CValidationState state;\n-        if (!ProcessNewBlock(Params(), shared_pblock, state, true, nullptr) || !state.IsValid())\n+        ProcessNewBlock(Params(), shared_pblock, state, true).wait();\n+        if (ChainActive().Tip()->GetBlockHash() != pblock->GetHash())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -731,13 +732,12 @@ static UniValue submitblock(const JSONRPCRequest& request)\n         }\n     }\n \n-    bool new_block;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n     CValidationState dos_state;\n-    bool accepted = ProcessNewBlock(Params(), blockptr, dos_state, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n+    bool new_block = ProcessNewBlock(Params(), blockptr, dos_state, /* fForceProcessing */ true).get();\n     UnregisterValidationInterface(&sc);\n-    if (!new_block && accepted) {\n+    if (!new_block && dos_state.IsValid()) {\n         return \"duplicate\";\n     }\n     if (!sc.found && dos_state.IsValid()) {"
      },
      {
        "sha": "5586b62bc950649d7e7692e99f836807476587de",
        "filename": "src/test/blockfilter_index_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/test/blockfilter_index_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/test/blockfilter_index_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockfilter_index_tests.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -177,7 +177,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     for (size_t i = 0; i < 2; i++) {\n         const auto& block = chainA[i];\n         CValidationState dos_state;\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, dos_state, true, nullptr));\n+        ProcessNewBlock(Params(), block, dos_state, true).wait();\n         BOOST_REQUIRE(dos_state.IsValid());\n \n         const CBlockIndex* block_index;\n@@ -195,7 +195,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     for (size_t i = 0; i < 3; i++) {\n         const auto& block = chainB[i];\n         CValidationState dos_state;\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, dos_state, true, nullptr));\n+        ProcessNewBlock(Params(), block, dos_state, true).wait();\n         BOOST_REQUIRE(dos_state.IsValid());\n \n         const CBlockIndex* block_index;\n@@ -226,7 +226,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n     for (size_t i = 2; i < 4; i++) {\n         const auto& block = chainA[i];\n         CValidationState dos_state;\n-        BOOST_REQUIRE(ProcessNewBlock(Params(), block, dos_state, true, nullptr));\n+        ProcessNewBlock(Params(), block, dos_state, true).wait();\n         BOOST_REQUIRE(dos_state.IsValid());\n     }\n "
      },
      {
        "sha": "8ec5f99ab69319ed6f38d0d9399fa618cfa82dbe",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -249,7 +249,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n         CValidationState dos_state;\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, dos_state, true, nullptr));\n+        ProcessNewBlock(chainparams, shared_pblock, dos_state, true).wait();\n         BOOST_CHECK(dos_state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }"
      },
      {
        "sha": "5827f9ca4947d21d72ae3933ff160a301a1b8453",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -165,7 +165,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n     CValidationState dos_state;\n-    ProcessNewBlock(chainparams, shared_pblock, dos_state, true, nullptr);\n+    ProcessNewBlock(chainparams, shared_pblock, dos_state, true).wait();\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "eb6bb8e0098e4480efc3e0b42b2e31eef5cc0a49",
        "filename": "src/test/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -63,8 +63,7 @@ CTxIn MineBlock(const CScript& coinbase_scriptPubKey)\n     }\n \n     CValidationState dos_state;\n-    bool processed{ProcessNewBlock(Params(), block, dos_state, true, nullptr)};\n-    assert(processed);\n+    ProcessNewBlock(Params(), block, dos_state, true).wait();\n     assert(dos_state.IsValid());\n \n     return CTxIn{block->vtx[0]->GetHash(), 0};"
      },
      {
        "sha": "7e6909944fcf1f11f9c9d0e10ad478d9427f989d",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -150,7 +150,6 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n         BuildChain(Params().GenesisBlock().GetHash(), 100, 15, 10, 500, blocks);\n     }\n \n-    bool ignored;\n     CValidationState state;\n     std::vector<CBlockHeader> headers;\n     std::transform(blocks.begin(), blocks.end(), std::back_inserter(headers), [](std::shared_ptr<const CBlock> b) { return b->GetBlockHeader(); });\n@@ -160,7 +159,8 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n \n     // Connect the genesis block and drain any outstanding events\n     CValidationState dos_state;\n-    BOOST_CHECK(ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), dos_state, true, &ignored));\n+    ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), dos_state, true).wait();\n+    BOOST_CHECK(dos_state.IsValid());\n     SyncWithValidationInterfaceQueue();\n \n     // subscribe to events (this subscriber will validate event ordering)\n@@ -178,23 +178,25 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     std::vector<std::thread> threads;\n     for (int i = 0; i < 10; i++) {\n         threads.emplace_back([&blocks]() {\n-            bool ignored;\n+            std::vector<std::future<bool>> thread_futures;\n             FastRandomContext insecure;\n             for (int i = 0; i < 1000; i++) {\n                 auto block = blocks[insecure.randrange(blocks.size() - 1)];\n                 CValidationState dos_state;\n-                ProcessNewBlock(Params(), block, dos_state, true, &ignored);\n+                thread_futures.push_back(ProcessNewBlock(Params(), block, dos_state, true));\n             }\n \n             // to make sure that eventually we process the full chain - do it here\n             for (auto block : blocks) {\n                 if (block->vtx.size() == 1) {\n                     CValidationState dos_state;\n-                    bool processed = ProcessNewBlock(Params(), block, dos_state, true, &ignored);\n-                    assert(processed);\n+                    thread_futures.push_back(ProcessNewBlock(Params(), block, dos_state, true));\n                     assert(dos_state.IsValid());\n                 }\n             }\n+            for (std::future<bool>& future: thread_futures) {\n+                future.wait();\n+            }\n         });\n     }\n \n@@ -231,9 +233,10 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n {\n     bool ignored;\n-    auto ProcessBlock = [&ignored](std::shared_ptr<const CBlock> block) -> bool {\n+    auto ProcessBlock = [](std::shared_ptr<const CBlock> block) -> bool {\n         CValidationState dos_state;\n-        return ProcessNewBlock(Params(), block, dos_state, /* fForceProcessing */ true, /* fNewBlock */ &ignored);\n+        ProcessNewBlock(Params(), block, dos_state, /* fForceProcessing */ true).wait();\n+        return dos_state.IsValid();\n     };\n \n     // Process all mined blocks"
      },
      {
        "sha": "9595e7f510df2da3dd87534342aa88d18945b1fb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -3507,13 +3507,16 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     return true;\n }\n \n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing, bool *fNewBlock)\n+std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing)\n {\n     AssertLockNotHeld(cs_main);\n \n+    std::promise<bool> result_promise;\n+    std::future<bool> result = result_promise.get_future();\n+    bool fNewBlock = false;\n+\n     {\n         CBlockIndex *pindex = nullptr;\n-        if (fNewBlock) *fNewBlock = false;\n \n         // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n         // Therefore, the following critical section must include the CheckBlock() call as well.\n@@ -3524,20 +3527,24 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n         bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n         if (ret) {\n             // Store to disk\n-            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n+            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n         }\n         if (!ret) {\n-            return error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+            error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+            result_promise.set_value(fNewBlock);\n+            return result;\n         }\n     }\n \n+    result_promise.set_value(fNewBlock);\n+\n     NotifyHeaderTip();\n \n     CValidationState dummy_state; // Only used to report errors, not invalidity - ignore it\n     if (!::ChainstateActive().ActivateBestChain(dummy_state, chainparams, pblock))\n-        return error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n+        error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n-    return true;\n+    return result;\n }\n \n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)"
      },
      {
        "sha": "176ae3a4adaa2ae7318e1cae1a0e0ded0c7fbd2f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/269a06007e044d85f9fabdb1518493c62296eec4/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/269a06007e044d85f9fabdb1518493c62296eec4/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=269a06007e044d85f9fabdb1518493c62296eec4",
        "patch": "@@ -25,6 +25,7 @@\n #include <algorithm>\n #include <atomic>\n #include <exception>\n+#include <future>\n #include <map>\n #include <memory>\n #include <set>\n@@ -210,19 +211,22 @@ static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n  * If pblock connects, and has been mutation, state is guaranteed to be some\n  * non-IsValid() state.\n  *\n- * If fForceProcessing is set (or fNewBlock returns true), barring pruning and\n+ * If fForceProcessing is set (or the future returns true), barring pruning and\n  * a desire to re-download a pruned block, if state.IsValid(), there should\n  * never be any reason to re-ProcessNewBlock any block with the same hash.\n  *\n  * May not be called in a validationinterface callback.\n  *\n+ * Do NOT block on the returned future waiting for it to resolve as this may\n+ * introduce deadlocks (in the case you are holding any mutexes which are\n+ * also taken in validationinterface callbacks).\n+ *\n  * @param[in]   pblock  The block we want to process.\n  * @param[out] state This may be set to an Error state if any error occurred processing them\n  * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n- * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n- * @return True if state.IsValid()\n+ * @return      A future which complets with a boolean which is set to indicate if the block was first received via this call\n  */\n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing, bool* fNewBlock) LOCKS_EXCLUDED(cs_main);\n+std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing) LOCKS_EXCLUDED(cs_main);\n \n /**\n  * Process incoming block headers."
      }
    ]
  },
  {
    "sha": "49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OWIxN2U1Y2M2OGI0ZjVmNWJhMTM1OGIyMmFiZDY1ZjlmOGZiMjMx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-08T12:47:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-19T23:39:06Z"
      },
      "message": "Add a new peer state tracking class to reduce cs_main contention.\n\nCNodeState was added for validation-state-tracking, and thus,\nlogically, was protected by cs_main. However, as it has grown to\ninclude non-validation state (taking state from CNode), and as\nwe've reduced cs_main usage for other unrelated things, CNodeState\nis left with lots of cs_main locking in net_processing.\n\nIn order to ease transition to something new, this adds only a\ndummy CPeerState which is held as a reference for the duration of\nmessage processing.\n\nNote that moving things is somewhat tricky pre validation-thread as\na consistent lockorder must be kept - we can't take a lock on the\nnew cs_peerstate in anything that's called directly from\nvalidation.",
      "tree": {
        "sha": "d99330b5367856b5933142b2e53ccb136b24c1df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d99330b5367856b5933142b2e53ccb136b24c1df"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "269a06007e044d85f9fabdb1518493c62296eec4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/269a06007e044d85f9fabdb1518493c62296eec4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/269a06007e044d85f9fabdb1518493c62296eec4"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 44,
      "deletions": 3
    },
    "files": [
      {
        "sha": "4f4980b66c4f30df5fe238711eedcf8ad7762cbd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 3,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
        "patch": "@@ -199,6 +199,17 @@ struct CBlockReject {\n     uint256 hashBlock;\n };\n \n+/**\n+ * Maintain state about nodes, protected by our own lock. Historically we put all\n+ * peer tracking state in CNodeState, however this results in significant cs_main\n+ * contention. Thus, new state tracking should go here, and we should eventually\n+ * move most (non-validation-specific) state here.\n+ */\n+struct CPeerState {\n+    CPeerState() {}\n+};\n+\n+\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -393,7 +404,20 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, std::chrono::microseconds> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n+/** Note that this must be locked BEFORE cs_main! */\n+CCriticalSection cs_peerstate;\n+\n /** Map maintaining per-node state. */\n+static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n+\n+static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) LOCKS_EXCLUDED(cs_main) {\n+    std::map<NodeId, CPeerState>::iterator it = mapPeerState.find(pnode);\n+    if (it == mapPeerState.end())\n+        return nullptr;\n+    return &it->second;\n+}\n+\n+/** Map maintaining new per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n@@ -771,12 +795,22 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n         LOCK(cs_main);\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n+    {\n+        LOCK(cs_peerstate);\n+        mapPeerState.emplace_hint(mapPeerState.end(), nodeid, CPeerState{});\n+    }\n+\n     if(!pnode->fInbound)\n         PushNodeVersion(pnode, connman, GetTime());\n }\n \n void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n+\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(nodeid);\n+    assert(peerstate != nullptr);\n+\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -799,13 +833,15 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n     mapNodeState.erase(nodeid);\n+    mapPeerState.erase(nodeid);\n \n     if (mapNodeState.empty()) {\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n         assert(g_outbound_peers_with_protect_from_disconnect == 0);\n+        assert(mapPeerState.empty());\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -1853,7 +1889,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n     }\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n+bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2795,7 +2831,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n+            return ProcessMessage(pfrom, peerstate, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n@@ -3259,6 +3295,8 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(pfrom->GetId());\n     //\n     // Message format\n     //  (4) message start\n@@ -3342,7 +3380,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n+        fRet = ProcessMessage(pfrom, peerstate, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3551,6 +3589,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // If we get here, the outgoing message serialization version is set and can't change.\n         const CNetMsgMaker msgMaker(pto->GetSendVersion());\n \n+        LOCK(cs_peerstate);\n+        CPeerState* peerstate = PeerState(pto->GetId());\n+\n         //\n         // Message: ping\n         //"
      }
    ]
  },
  {
    "sha": "56b98066d40bfc5a91a1e08bca401336c57561ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NmI5ODA2NmQ0MGJmYzVhOTFhMWUwOGJjYTQwMTMzNmM1NzU2MWVm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-17T17:13:36Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-19T23:39:06Z"
      },
      "message": "Move net_processing's ProcessNewBlock calls to resolve async.\n\nEssentially, our goal is to not process anything for the given peer\nuntil the block finishes processing (emulating the previous behavior)\nwithout actually blocking the ProcessMessages loops. Obviously, in\nmost cases, we'll just go on to the next peer and immediately hit a\ncs_main lock, blocking us anyway, but this we can slowly improve\nthat state over time by moving things from CNodeState to CPeerState.",
      "tree": {
        "sha": "52cb8e628ace89098c55d688c4e2fba7fb9167a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/52cb8e628ace89098c55d688c4e2fba7fb9167a4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56b98066d40bfc5a91a1e08bca401336c57561ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56b98066d40bfc5a91a1e08bca401336c57561ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/56b98066d40bfc5a91a1e08bca401336c57561ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56b98066d40bfc5a91a1e08bca401336c57561ef/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/49b17e5cc68b4f5f5ba1358b22abd65f9f8fb231"
      }
    ],
    "stats": {
      "total": 101,
      "additions": 76,
      "deletions": 25
    },
    "files": [
      {
        "sha": "29365dab38430dd1851860571ead4f62a92f50bd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 25,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56b98066d40bfc5a91a1e08bca401336c57561ef/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56b98066d40bfc5a91a1e08bca401336c57561ef/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=56b98066d40bfc5a91a1e08bca401336c57561ef",
        "patch": "@@ -121,6 +121,20 @@ namespace {\n      * messages or ban them when processing happens afterwards.\n      * Set mapBlockSource[hash].second to false if the node should not be\n      * punished if the block is invalid.\n+     *\n+     * If a block is in this map by the time you read it, this means there\n+     * is no reason to re-download the block (as it passed the\n+     * ProcessNewBlock state.IsValid()). See the ProcessNewBlock docs for\n+     * more info.\n+     *\n+     * TODO: There is currently a race on the above - we add to this map\n+     * before calling PNB and then remove it if the block was malleated. We\n+     * should be able to just not add it to the map if the block is malleated.\n+     * (This is fixed later in this patch set, so should never hit master!)\n+     *\n+     * However, things which are not on our best chain but were written to\n+     * disk anyway may sit around in here forever, so be careful relying on\n+     * its size for any decisions.\n      */\n     std::map<uint256, std::pair<NodeId, bool>> mapBlockSource GUARDED_BY(cs_main);\n \n@@ -206,6 +220,13 @@ struct CBlockReject {\n  * move most (non-validation-specific) state here.\n  */\n struct CPeerState {\n+    //! If this peer generated some headers for us to add, we store the resulting\n+    //! future here and wait for it to complete before we process more data from this\n+    //! peer.\n+    std::future<bool> pending_block_processing;\n+    //! The hash of the block which is pending download.\n+    uint256 pending_block_hash;\n+\n     CPeerState() {}\n };\n \n@@ -682,7 +703,7 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n                 // We wouldn't download this block or its descendants from this peer.\n                 return;\n             }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n+            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex) || mapBlockSource.count(pindex->GetBlockHash()) != 0) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n@@ -1751,6 +1772,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             while (pindexWalk && !::ChainActive().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                         !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !mapBlockSource.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -2727,8 +2749,9 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n-        if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n+        if ((pindex->nStatus & BLOCK_HAVE_DATA) || mapBlockSource.count(pindex->GetBlockHash())) {// Nothing to do here\n             return true;\n+        }\n \n         if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n@@ -2859,17 +2882,14 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n             CValidationState dos_state;\n-            bool fNewBlock = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true).get();\n-            if (fNewBlock && dos_state.IsValid()) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                if (!dos_state.IsValid()) {\n-                    BlockChecked(*pblock, dos_state, connman);\n-                }\n+            std::future<bool> block_future = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true);\n+            if (!dos_state.IsValid()) {\n                 LOCK(cs_main);\n+                BlockChecked(*pblock, dos_state, connman);\n                 mapBlockSource.erase(pblock->GetHash());\n-            }\n-            if (dos_state.IsValid()) {\n+            } else {\n+                peerstate->pending_block_hash = pblock->GetHash();\n+                peerstate->pending_block_processing = std::move(block_future);\n                 LOCK(cs_main);\n                 // Clear download state for this block, which is in\n                 // process from some other peer.  We do this after calling\n@@ -2951,15 +2971,14 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n             CValidationState dos_state;\n-            bool fNewBlock = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true).get();\n-            if (fNewBlock && dos_state.IsValid()) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                if (!dos_state.IsValid()) {\n-                    BlockChecked(*pblock, dos_state, connman);\n-                }\n+            std::future<bool> block_future = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true);\n+            if (!dos_state.IsValid()) {\n                 LOCK(cs_main);\n+                BlockChecked(*pblock, dos_state, connman);\n                 mapBlockSource.erase(pblock->GetHash());\n+            } else {\n+                peerstate->pending_block_hash = pblock->GetHash();\n+                peerstate->pending_block_processing = std::move(block_future);\n             }\n         }\n         return true;\n@@ -3016,15 +3035,14 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n         CValidationState dos_state;\n-        bool fNewBlock = ProcessNewBlock(chainparams, pblock, dos_state, forceProcessing).get();\n-        if (fNewBlock && dos_state.IsValid()) {\n-            pfrom->nLastBlockTime = GetTime();\n-        } else {\n-            if (!dos_state.IsValid()) {\n-                BlockChecked(*pblock, dos_state, connman);\n-            }\n+        std::future<bool> block_future = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/forceProcessing);\n+        if (!dos_state.IsValid()) {\n             LOCK(cs_main);\n+            BlockChecked(*pblock, dos_state, connman);\n             mapBlockSource.erase(pblock->GetHash());\n+        } else {\n+            peerstate->pending_block_hash = pblock->GetHash();\n+            peerstate->pending_block_processing = std::move(block_future);\n         }\n         return true;\n     }\n@@ -3292,6 +3310,24 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n     return false;\n }\n \n+bool static IsPendingBlockValidation(CNode* pfrom, CPeerState* peerstate) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n+{\n+    if (peerstate->pending_block_processing.valid()) {\n+        if (peerstate->pending_block_processing.wait_for(std::chrono::duration<int>::zero()) == std::future_status::ready) {\n+            bool fNewBlock = peerstate->pending_block_processing.get();\n+            if (fNewBlock) {\n+                pfrom->nLastBlockTime = GetTime();\n+            } else {\n+                LOCK(cs_main);\n+                mapBlockSource.erase(peerstate->pending_block_hash);\n+            }\n+            peerstate->pending_block_processing = std::future<bool>();\n+            peerstate->pending_block_hash = uint256();\n+            return false;\n+        } else { return true; }\n+    } else { return false; }\n+}\n+\n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     const CChainParams& chainparams = Params();\n@@ -3319,6 +3355,17 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         }\n     }\n \n+    if (IsPendingBlockValidation(pfrom, peerstate)) {\n+        return false;\n+    }\n+    {\n+        // Somewhat annoyingly, tests currently rely on any pending bans/disconnects\n+        // being processed prior to any pong responses, thus if we were waiting on a\n+        // block validation to complete, we need to recheck bans.\n+        LOCK(cs_main);\n+        SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n+    }\n+\n     if (pfrom->fDisconnect)\n         return false;\n \n@@ -3592,6 +3639,10 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         LOCK(cs_peerstate);\n         CPeerState* peerstate = PeerState(pto->GetId());\n \n+        if (IsPendingBlockValidation(pto, peerstate)) {\n+            return true;\n+        }\n+\n         //\n         // Message: ping\n         //"
      }
    ]
  },
  {
    "sha": "6859b228bc45445547bbf0e63d1b089f822f559e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODU5YjIyOGJjNDU0NDU1NDdiYmYwZTYzZDFiMDg5ZjgyMmY1NTll",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-07-21T21:06:11Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:00Z"
      },
      "message": "Run the ActivateBestChain in ProcessNewBlock in a background thread\n\nSpawn a background thread at startup which validates each block as\nit comes in from ProcessNewBlock, taking advantage of the new\nstd::future return value to keep tests simple (and the new\nnet_processing handling of such values async already).\n\nThis makes introducing subtle validationinterface deadlocks much\nharder as any locks held going into ProcessNewBlock do not interact\nwith (in the form of lockorder restrictions) locks taken in\nvalidationinterface callbacks.\n\nNote that after this commit, feature_block and feature_assumevalid\ntests time out due to increased latency between block processing\nwhen those blocks do not represent a new best block. This will be\nresolved in the next commit.",
      "tree": {
        "sha": "f83e66c654314f347a57d3743eac51c5d6488ccd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f83e66c654314f347a57d3743eac51c5d6488ccd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6859b228bc45445547bbf0e63d1b089f822f559e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6859b228bc45445547bbf0e63d1b089f822f559e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6859b228bc45445547bbf0e63d1b089f822f559e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6859b228bc45445547bbf0e63d1b089f822f559e/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56b98066d40bfc5a91a1e08bca401336c57561ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56b98066d40bfc5a91a1e08bca401336c57561ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56b98066d40bfc5a91a1e08bca401336c57561ef"
      }
    ],
    "stats": {
      "total": 112,
      "additions": 98,
      "deletions": 14
    },
    "files": [
      {
        "sha": "caf0a9608926eee97972fb32b0031b83c24f2efa",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6859b228bc45445547bbf0e63d1b089f822f559e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6859b228bc45445547bbf0e63d1b089f822f559e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6859b228bc45445547bbf0e63d1b089f822f559e",
        "patch": "@@ -1635,6 +1635,8 @@ bool AppInitMain(InitInterfaces& interfaces)\n         return false;\n     }\n \n+    threadGroup.create_thread(std::bind(&TraceThread<std::function<void()>>, \"blockconn\", std::function<void()>(std::bind(&CChainState::ProcessBlockValidationQueue, &ChainstateActive()))));\n+\n     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n     // Allowed to fail as this file IS missing on first startup."
      },
      {
        "sha": "2b537290dbcd26cd0bef619911ec40275b0e1297",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6859b228bc45445547bbf0e63d1b089f822f559e/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6859b228bc45445547bbf0e63d1b089f822f559e/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=6859b228bc45445547bbf0e63d1b089f822f559e",
        "patch": "@@ -104,12 +104,18 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     for (int i = 0; i < nScriptCheckThreads - 1; i++)\n         threadGroup.create_thread([i]() { return ThreadScriptCheck(i); });\n \n+    threadGroup.create_thread(std::function<void()>(std::bind(&CChainState::ProcessBlockValidationQueue, &ChainstateActive())));\n+\n     g_banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     g_connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n }\n \n TestingSetup::~TestingSetup()\n {\n+    // If eg the block connection thread is waiting on the queue to drain,\n+    // killing the scheduler thread now will hang us, so wait on the queue\n+    // to drain first.\n+    ChainstateActive().AwaitBlockValidationParked();\n     threadGroup.interrupt_all();\n     threadGroup.join_all();\n     GetMainSignals().FlushBackgroundCallbacks();"
      },
      {
        "sha": "f8579c982eb0a5f1d9cf813e0c17a06d3741d4ec",
        "filename": "src/test/txindex_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6859b228bc45445547bbf0e63d1b089f822f559e/src/test/txindex_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6859b228bc45445547bbf0e63d1b089f822f559e/src/test/txindex_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txindex_tests.cpp?ref=6859b228bc45445547bbf0e63d1b089f822f559e",
        "patch": "@@ -71,9 +71,6 @@ BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)\n     // shutdown sequence (c.f. Shutdown() in init.cpp)\n     txindex.Stop();\n \n-    threadGroup.interrupt_all();\n-    threadGroup.join_all();\n-\n     // Rest of shutdown sequence and destructors happen in ~TestingSetup()\n }\n "
      },
      {
        "sha": "8b7c43f800fb55f6ac02be55900893451a142cb0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 11,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6859b228bc45445547bbf0e63d1b089f822f559e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6859b228bc45445547bbf0e63d1b089f822f559e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6859b228bc45445547bbf0e63d1b089f822f559e",
        "patch": "@@ -3507,7 +3507,54 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     return true;\n }\n \n-std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing)\n+void CChainState::AwaitBlockValidationParked()\n+{\n+    std::unique_lock<CCriticalSection> lock(m_cs_block_validation_queue);\n+    m_cv_block_validation_parked.wait(lock, [this] { return m_block_validation_parked; });\n+}\n+\n+void CChainState::ProcessBlockValidationQueue()\n+{\n+    while (true) {\n+        std::shared_ptr<const CBlock> pblock;\n+        bool fForceProcessing;\n+        std::promise<bool> result_promise;\n+        {\n+            std::unique_lock<CCriticalSection> lock(m_cs_block_validation_queue);\n+            if (m_block_validation_queue.empty()) {\n+                m_block_validation_parked = true;\n+                m_cv_block_validation_parked.notify_all();\n+                m_cv_block_validation_queue.wait_for(lock, std::chrono::milliseconds(100));\n+                m_block_validation_parked = false;\n+            }\n+            if (ShutdownRequested())\n+                break;\n+            boost::this_thread::interruption_point();\n+            if (m_block_validation_queue.empty()) {\n+                continue;\n+            }\n+\n+            std::tuple<std::shared_ptr<const CBlock>, bool, std::promise<bool>>& tuple = m_block_validation_queue.front();\n+            pblock = std::move(std::get<0>(tuple));\n+            fForceProcessing = std::get<1>(tuple);\n+            result_promise = std::move(std::get<2>(tuple));\n+            m_block_validation_queue.pop_front();\n+        }\n+\n+        CChainParams chainparams = Params();\n+\n+        NotifyHeaderTip();\n+\n+        CValidationState state; // Only used to report errors, not invalidity - ignore it\n+        if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n+            error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n+\n+        result_promise.set_value(true);\n+        LimitValidationInterfaceQueue();\n+    }\n+}\n+\n+std::future<bool> CChainState::ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing)\n {\n     AssertLockNotHeld(cs_main);\n \n@@ -3529,24 +3576,28 @@ std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::sh\n             // Store to disk\n             ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n         }\n-        if (!ret) {\n-            error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+        if (!ret || !fNewBlock) {\n+            if (!ret) {\n+                error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n+            }\n             result_promise.set_value(fNewBlock);\n             return result;\n         }\n     }\n \n-    result_promise.set_value(fNewBlock);\n-\n-    NotifyHeaderTip();\n-\n-    CValidationState dummy_state; // Only used to report errors, not invalidity - ignore it\n-    if (!::ChainstateActive().ActivateBestChain(dummy_state, chainparams, pblock))\n-        error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n-\n+    {\n+        LOCK(m_cs_block_validation_queue);\n+        m_block_validation_queue.emplace_back(std::move(pblock), fForceProcessing, std::move(result_promise));\n+    }\n+    m_cv_block_validation_queue.notify_one();\n     return result;\n }\n \n+std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing)\n+{\n+    return ::ChainstateActive().ProcessNewBlock(chainparams, pblock, state, fForceProcessing);\n+}\n+\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     AssertLockHeld(cs_main);"
      },
      {
        "sha": "456afd00bce0a9ce3b8bf460d53e215479dbfe28",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6859b228bc45445547bbf0e63d1b089f822f559e/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6859b228bc45445547bbf0e63d1b089f822f559e/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=6859b228bc45445547bbf0e63d1b089f822f559e",
        "patch": "@@ -598,6 +598,21 @@ class CChainState {\n     //! Manages the UTXO set, which is a reflection of the contents of `m_chain`.\n     std::unique_ptr<CoinsViews> m_coins_views;\n \n+    /** Lock for m_block_validation_queue */\n+    CCriticalSection m_cs_block_validation_queue;\n+    /** CV for m_block_validation_queue */\n+    std::condition_variable_any m_cv_block_validation_queue;\n+    /**\n+     * Queue of blocks to validate\n+     * tuple<block, force-processing, promise-to-complete>\n+     */\n+    std::list<std::tuple<std::shared_ptr<const CBlock>, bool, std::promise<bool>>> m_block_validation_queue;\n+\n+    /** CV for waiting on the validation queue process to park */\n+    std::condition_variable_any m_cv_block_validation_parked;\n+    /** Indicates the block validation thread is parked */\n+    bool m_block_validation_parked;\n+\n public:\n     CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n     CChainState();\n@@ -708,6 +723,19 @@ class CChainState {\n     /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n     bool IsInitialBlockDownload() const;\n \n+    /** Drain the block validation queue in a loop. Should be run only in one thread. */\n+    void ProcessBlockValidationQueue();\n+\n+    /**\n+     * Wait for the block validation queue process loop to be parked with no more work to do.\n+     * Obviously only really useful during shutdown once no more blocks will be pushed to\n+     * ProcessNewBlock.\n+     */\n+    void AwaitBlockValidationParked();\n+\n+    /** Push a new block to the block validation queue */\n+    std::future<bool> ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, CValidationState& state, bool fForceProcessing);\n+\n     /**\n      * Make various assertions about the state of the block index.\n      *"
      }
    ]
  },
  {
    "sha": "e44b1e378558295ebd0461e690923a70e1ae3571",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDRiMWUzNzg1NTgyOTVlYmQwNDYxZTY5MDkyM2E3MGUxYWUzNTcx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-11T17:29:08Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:07Z"
      },
      "message": "Add a callback to indicate a block has been processed\n\nThis resolves the performance regression introduced in the previous\ncommit by always waking the message processing thread after each\nblock future resolves.\n\nSadly, this is somewhat awkward - all other validationinterface\ncallbacks represent an actual change to the global validation state,\nwhereas this callback indicates only that a call which one\nvalidation \"client\" made has completed. After going back and forth\nfor some time I didn't see a materially better way to resolve this\nissue, and luckily its a rather simple change, but its far from\nideal. Note that because we absolutely do not want to ever block on\na ProcessNewBlock-returned-future, the callback approach is\ncritical.",
      "tree": {
        "sha": "e04de868e36a225abad2e699517dca63f6d08e24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e04de868e36a225abad2e699517dca63f6d08e24"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e44b1e378558295ebd0461e690923a70e1ae3571",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e44b1e378558295ebd0461e690923a70e1ae3571",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e44b1e378558295ebd0461e690923a70e1ae3571",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e44b1e378558295ebd0461e690923a70e1ae3571/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6859b228bc45445547bbf0e63d1b089f822f559e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6859b228bc45445547bbf0e63d1b089f822f559e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6859b228bc45445547bbf0e63d1b089f822f559e"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 29,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dba3d287c26a6564edd0e34ba0946ea29aef9aaa",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e44b1e378558295ebd0461e690923a70e1ae3571/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e44b1e378558295ebd0461e690923a70e1ae3571/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e44b1e378558295ebd0461e690923a70e1ae3571",
        "patch": "@@ -1324,6 +1324,14 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     ::BlockChecked(block, state, connman);\n }\n \n+/**\n+ * Wake up message handler once a block has been processed to process the\n+ * next message from the peer that sent us that block.\n+ */\n+void PeerLogicValidation::BlockProcessed() {\n+    connman->WakeMessageHandler();\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Messages"
      },
      {
        "sha": "471b117227aa59daa4d5afd7dd8ef729b77b740e",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e44b1e378558295ebd0461e690923a70e1ae3571/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e44b1e378558295ebd0461e690923a70e1ae3571/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=e44b1e378558295ebd0461e690923a70e1ae3571",
        "patch": "@@ -46,6 +46,10 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n      * Overridden from CValidationInterface.\n      */\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+    /**\n+     * Overridden from CValidationInterface.\n+     */\n+    void BlockProcessed() override;\n \n     /** Initialize a peer by adding it to mapNodeState and pushing a message requesting its version */\n     void InitializeNode(CNode* pnode) override;"
      },
      {
        "sha": "6d023ee474f1a4f6d5941c76e0c07fb3e493c040",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e44b1e378558295ebd0461e690923a70e1ae3571/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e44b1e378558295ebd0461e690923a70e1ae3571/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e44b1e378558295ebd0461e690923a70e1ae3571",
        "patch": "@@ -3550,6 +3550,7 @@ void CChainState::ProcessBlockValidationQueue()\n             error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n         result_promise.set_value(true);\n+        GetMainSignals().BlockProcessed();\n         LimitValidationInterfaceQueue();\n     }\n }"
      },
      {
        "sha": "ed3c43b986a6cbf73444f0ea32f5b8b4e4b2997f",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e44b1e378558295ebd0461e690923a70e1ae3571/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e44b1e378558295ebd0461e690923a70e1ae3571/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=e44b1e378558295ebd0461e690923a70e1ae3571",
        "patch": "@@ -25,6 +25,7 @@ struct ValidationInterfaceConnections {\n     boost::signals2::scoped_connection ChainStateFlushed;\n     boost::signals2::scoped_connection BlockChecked;\n     boost::signals2::scoped_connection NewPoWValidBlock;\n+    boost::signals2::scoped_connection BlockProcessed;\n };\n \n struct MainSignalsInstance {\n@@ -36,6 +37,7 @@ struct MainSignalsInstance {\n     boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n     boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+    boost::signals2::signal<void ()> BlockProcessed;\n \n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n@@ -99,6 +101,7 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     conns.ChainStateFlushed = g_signals.m_internals->ChainStateFlushed.connect(std::bind(&CValidationInterface::ChainStateFlushed, pwalletIn, std::placeholders::_1));\n     conns.BlockChecked = g_signals.m_internals->BlockChecked.connect(std::bind(&CValidationInterface::BlockChecked, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n     conns.NewPoWValidBlock = g_signals.m_internals->NewPoWValidBlock.connect(std::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n+    conns.BlockProcessed = g_signals.m_internals->BlockProcessed.connect(std::bind(&CValidationInterface::BlockProcessed, pwalletIn));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n@@ -177,3 +180,9 @@ void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& sta\n void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {\n     m_internals->NewPoWValidBlock(pindex, block);\n }\n+\n+void CMainSignals::BlockProcessed() {\n+    m_internals->m_schedulerClient.AddToProcessQueue([this] {\n+        m_internals->BlockProcessed();\n+    });\n+}"
      },
      {
        "sha": "fac51efa12924622997bd251dccfb0da17be65f8",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e44b1e378558295ebd0461e690923a70e1ae3571/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e44b1e378558295ebd0461e690923a70e1ae3571/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=e44b1e378558295ebd0461e690923a70e1ae3571",
        "patch": "@@ -143,6 +143,12 @@ class CValidationInterface {\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */\n     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n+    /**\n+     * Notifies listeners that a block which was submitted has been fully processed.\n+     *\n+     * Called on a background thread.\n+     */\n+    virtual void BlockProcessed() {}\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterAllValidationInterfaces();\n@@ -182,6 +188,7 @@ class CMainSignals {\n     void ChainStateFlushed(const CBlockLocator &);\n     void BlockChecked(const CBlock&, const CValidationState&);\n     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n+    void BlockProcessed();\n };\n \n CMainSignals& GetMainSignals();"
      }
    ]
  },
  {
    "sha": "22400fbbde68f05a6b0ea233460118bfd755cfa2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMjQwMGZiYmRlNjhmMDVhNmIwZWEyMzM0NjAxMThiZmQ3NTVjZmEy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-07-06T01:43:39Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:07Z"
      },
      "message": "Split AcceptBlock into three stages to write to disk in background\n\nTo keep the API the same (and for simplicity of clients, ie\nnet_processing), this splits AcceptBlock into the do-I-want-this\nstage, the checking stage, and the writing stage.\n\nProcessNewBlock calls the do-I-want-this and checking (ie\nmalleability checking) stuff, and then dumps blocks that pass\ninto the background thread. In the background, we re-test the\ndo-I-want-this logic but skip the checking stuff, before writing\nthe block to disk and activating the best chain.",
      "tree": {
        "sha": "4475acc501fe92c4041a329185aacbac3c02f43b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4475acc501fe92c4041a329185aacbac3c02f43b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/22400fbbde68f05a6b0ea233460118bfd755cfa2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22400fbbde68f05a6b0ea233460118bfd755cfa2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/22400fbbde68f05a6b0ea233460118bfd755cfa2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22400fbbde68f05a6b0ea233460118bfd755cfa2/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e44b1e378558295ebd0461e690923a70e1ae3571",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e44b1e378558295ebd0461e690923a70e1ae3571",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e44b1e378558295ebd0461e690923a70e1ae3571"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 109,
      "deletions": 22
    },
    "files": [
      {
        "sha": "05d606eba7dd17e6203dca891d57f19f1189452c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 22,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/22400fbbde68f05a6b0ea233460118bfd755cfa2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/22400fbbde68f05a6b0ea233460118bfd755cfa2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=22400fbbde68f05a6b0ea233460118bfd755cfa2",
        "patch": "@@ -3423,23 +3423,10 @@ static FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, const CChai\n     return blockPos;\n }\n \n-/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n-bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n+bool CChainState::ShouldMaybeWrite(CBlockIndex* pindex, bool fRequested)\n {\n-    const CBlock& block = *pblock;\n-\n-    if (fNewBlock) *fNewBlock = false;\n     AssertLockHeld(cs_main);\n \n-    CBlockIndex *pindexDummy = nullptr;\n-    CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n-\n-    bool accepted_header = m_blockman.AcceptBlockHeader(block, state, chainparams, &pindex);\n-    CheckBlockIndex(chainparams.GetConsensus());\n-\n-    if (!accepted_header)\n-        return false;\n-\n     // Try to process all requested blocks that we don't have, but only\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n@@ -3459,19 +3446,41 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     // TODO: deal better with return value and error conditions for duplicate\n     // and unrequested blocks.\n-    if (fAlreadyHave) return true;\n+    if (fAlreadyHave) return false;\n     if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n-        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n-        if (fTooFarAhead) return true;        // Block height is too high\n+        if (pindex->nTx != 0) return false;    // This is a previously-processed block that was pruned\n+        if (!fHasMoreOrSameWork) return false; // Don't process less-work chains\n+        if (fTooFarAhead) return false;        // Block height is too high\n \n         // Protect against DoS attacks from low-work chains.\n         // If our tip is behind, a peer could try to send us\n         // low-work blocks on a fake chain that we would never\n         // request; don't process these.\n-        if (pindex->nChainWork < nMinimumChainWork) return true;\n+        if (pindex->nChainWork < nMinimumChainWork) return false;\n     }\n \n+    return true;\n+}\n+\n+/** Check block before we go to write it to disk */\n+bool CChainState::PreWriteCheckBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, bool* fShouldWrite)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    const CBlock& block = *pblock;\n+    if (fShouldWrite) *fShouldWrite = false;\n+\n+    CBlockIndex *pindexDummy = nullptr;\n+    CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n+\n+    bool accepted_header = m_blockman.AcceptBlockHeader(block, state, chainparams, &pindex);\n+    CheckBlockIndex(chainparams.GetConsensus());\n+\n+    if (!accepted_header)\n+        return false;\n+\n+    if (!ShouldMaybeWrite(pindex, fRequested)) return true;\n+\n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n         assert(IsBlockReason(state.GetReason()));\n@@ -3482,6 +3491,29 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n         return error(\"%s: %s\", __func__, FormatStateMessage(state));\n     }\n \n+    if (fShouldWrite) *fShouldWrite = true;\n+    return true;\n+}\n+\n+/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n+bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    const CBlock& block = *pblock;\n+    if (fNewBlock) *fNewBlock = false;\n+\n+    CBlockIndex *pindexDummy = nullptr;\n+    CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n+\n+    bool fShouldWrite = false;\n+    if (!PreWriteCheckBlock(pblock, state, chainparams, &pindex, fRequested, &fShouldWrite)) {\n+        return false;\n+    }\n+    if (!fShouldWrite) {\n+        return true;\n+    }\n+\n     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW\n     // (but if it does not build on our best tip, let the SendMessages loop relay it)\n     if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)\n@@ -3542,6 +3574,47 @@ void CChainState::ProcessBlockValidationQueue()\n         }\n \n         CChainParams chainparams = Params();\n+        {\n+            LOCK(cs_main);\n+\n+            CBlockIndex* pindex = LookupBlockIndex(pblock->GetHash());\n+            assert(pindex);\n+\n+            // Check that we still want this block\n+            if (!ShouldMaybeWrite(pindex, fForceProcessing)) {\n+                result_promise.set_value(false);\n+                continue;\n+            }\n+\n+            // We already verified the block in ProcessNewBlock, so no need to check merkle roots here again\n+\n+            // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW\n+            // (but if it does not build on our best tip, let the SendMessages loop relay it)\n+            if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)\n+                GetMainSignals().NewPoWValidBlock(pindex, pblock);\n+\n+            CValidationState state;\n+            try {\n+                FlatFilePos blockPos = SaveBlockToDisk(*pblock, pindex->nHeight, chainparams, nullptr);\n+                if (blockPos.IsNull()) {\n+                    error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__).c_str());\n+                    result_promise.set_value(false);\n+                    continue;\n+                }\n+                ReceivedBlockTransactions(*pblock, pindex, blockPos, chainparams.GetConsensus());\n+            } catch (const std::runtime_error& e) {\n+                AbortNode(state, std::string(\"System error: \") + e.what());\n+            }\n+\n+            FlushStateToDisk(chainparams, state, FlushStateMode::NONE);\n+\n+            CheckBlockIndex(chainparams.GetConsensus());\n+\n+            if (state.IsError()) {\n+                result_promise.set_value(false);\n+                continue;\n+            }\n+        }\n \n         NotifyHeaderTip();\n \n@@ -3564,8 +3637,6 @@ std::future<bool> CChainState::ProcessNewBlock(const CChainParams& chainparams,\n     bool fNewBlock = false;\n \n     {\n-        CBlockIndex *pindex = nullptr;\n-\n         // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n         // Therefore, the following critical section must include the CheckBlock() call as well.\n         LOCK(cs_main);\n@@ -3575,7 +3646,7 @@ std::future<bool> CChainState::ProcessNewBlock(const CChainParams& chainparams,\n         bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n         if (ret) {\n             // Store to disk\n-            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, &fNewBlock);\n+            ret = PreWriteCheckBlock(pblock, state, chainparams, nullptr, fForceProcessing, &fNewBlock);\n         }\n         if (!ret || !fNewBlock) {\n             if (!ret) {"
      },
      {
        "sha": "92fed4803ff3831b93fce4b516036ead31bbdcd2",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/22400fbbde68f05a6b0ea233460118bfd755cfa2/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/22400fbbde68f05a6b0ea233460118bfd755cfa2/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=22400fbbde68f05a6b0ea233460118bfd755cfa2",
        "patch": "@@ -613,6 +613,22 @@ class CChainState {\n     /** Indicates the block validation thread is parked */\n     bool m_block_validation_parked;\n \n+    /**\n+     * Utility function to check if it makes sense to write the given block to\n+     * disk right now.\n+     * Checks whether we already had/have the block and whether it meets DoS\n+     * criteria.\n+     */\n+    bool ShouldMaybeWrite(CBlockIndex* pindex, bool fRequested) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /**\n+     * Performs initial DoS checks for the given block (assuming ShouldMaybeWrite\n+     * passes).\n+     * Will detect any cases of malleability, ie if this passes, pblock is a\n+     * \"good\" copy of the block.\n+     */\n+    bool PreWriteCheckBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, bool* fShouldWrite) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n public:\n     CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n     CChainState();"
      }
    ]
  },
  {
    "sha": "b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNGYzYTMzOTc4MTM0M2ZkOGZiY2RmZDhmZmVlMzhlMjI0ZmQxNGNk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T15:27:07Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:09Z"
      },
      "message": "Move BlockChecked to a background thread\n\nAs reject messages are required to go out in-order (ie before any\nfurther messages are processed), this sadly requires that we\nfurther delay re-enabling a peer after a block has been processed\nby waiting for current validationinterface callbacks to drain.\n\nThis commit enables further reduction of cs_main in net_processing\nby allowing us to lock cs_peerstate before cs_main in BlockChecked\n(ie allows us to move things which are accessed in BlockChecked,\nincluding DoS state and rejects into CPeerState and out of\nCNodeState).",
      "tree": {
        "sha": "826daa423f796af7cc6688dad585d5e9fc2bb81b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/826daa423f796af7cc6688dad585d5e9fc2bb81b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "22400fbbde68f05a6b0ea233460118bfd755cfa2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22400fbbde68f05a6b0ea233460118bfd755cfa2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/22400fbbde68f05a6b0ea233460118bfd755cfa2"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 36,
      "deletions": 7
    },
    "files": [
      {
        "sha": "9fe548fdd87f50014c27ff80eb2c63c24d58e61c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 3,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "patch": "@@ -226,8 +226,14 @@ struct CPeerState {\n     std::future<bool> pending_block_processing;\n     //! The hash of the block which is pending download.\n     uint256 pending_block_hash;\n+    //! Once we've finished processing a block from this peer, we must still wait for\n+    //! any related callbacks to fire (to ensure, specifically, that rejects go out\n+    //! in order, though this may grow to include more such events in the future).\n+    bool pending_event_wait;\n \n-    CPeerState() {}\n+    CPeerState() {\n+        pending_event_wait = false;\n+    }\n };\n \n \n@@ -3331,9 +3337,26 @@ bool static IsPendingBlockValidation(CNode* pfrom, CPeerState* peerstate) EXCLUS\n             }\n             peerstate->pending_block_processing = std::future<bool>();\n             peerstate->pending_block_hash = uint256();\n-            return false;\n+\n+            // We need to wait for BlockChecked to fire, so we don't re-enable\n+            // this peer until the current pending validationinterface callbacks\n+            // drain. This ensures bans and reject messages happen in order, as\n+            // expected by some of our functional tests.\n+            peerstate->pending_event_wait = true;\n+            NodeId node_id = pfrom->GetId();\n+            CallFunctionInValidationInterfaceQueue([node_id] {\n+                LOCK(cs_peerstate);\n+                CPeerState* peerstate = PeerState(node_id);\n+                if (peerstate != nullptr) {\n+                    peerstate->pending_event_wait = false;\n+                    g_connman->WakeMessageHandler();\n+                }\n+            });\n+            return true;\n         } else { return true; }\n-    } else { return false; }\n+    } else {\n+        return peerstate->pending_event_wait;\n+    }\n }\n \n bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)"
      },
      {
        "sha": "d7a00d3992ba5fd3e51af31954a947bb1df5e19b",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "patch": "@@ -736,6 +736,7 @@ static UniValue submitblock(const JSONRPCRequest& request)\n     RegisterValidationInterface(&sc);\n     CValidationState dos_state;\n     bool new_block = ProcessNewBlock(Params(), blockptr, dos_state, /* fForceProcessing */ true).get();\n+    SyncWithValidationInterfaceQueue();\n     UnregisterValidationInterface(&sc);\n     if (!new_block && dos_state.IsValid()) {\n         return \"duplicate\";"
      },
      {
        "sha": "aa8ad8e8acda24cf987d940f0c3d9212a13323e4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "patch": "@@ -2365,7 +2365,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     {\n         CCoinsViewCache view(&CoinsTip());\n         bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);\n-        GetMainSignals().BlockChecked(blockConnecting, state);\n+        GetMainSignals().BlockChecked(pthisBlock, state);\n         if (!rv) {\n             if (state.IsInvalid())\n                 InvalidBlockFound(pindexNew, state);"
      },
      {
        "sha": "b1f7158a359e76ed29c9d8f75e3c00799ac578fe",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "patch": "@@ -5,6 +5,7 @@\n \n #include <validationinterface.h>\n \n+#include <consensus/validation.h>\n #include <primitives/block.h>\n #include <scheduler.h>\n #include <txmempool.h>\n@@ -173,8 +174,10 @@ void CMainSignals::ChainStateFlushed(const CBlockLocator &locator) {\n     });\n }\n \n-void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& state) {\n-    m_internals->BlockChecked(block, state);\n+void CMainSignals::BlockChecked(const std::shared_ptr<const CBlock> &pblock, const CValidationState& state) {\n+    m_internals->m_schedulerClient.AddToProcessQueue([pblock, state, this] {\n+        m_internals->BlockChecked(*pblock, state);\n+    });\n }\n \n void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {"
      },
      {
        "sha": "8020e3bfe3981b18491023a2f73ec8368df53fc9",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "patch": "@@ -137,6 +137,8 @@ class CValidationInterface {\n      * If the provided CValidationState IsValid, the provided block\n      * is guaranteed to be the current best block at the time the\n      * callback was generated (not necessarily now)\n+     *\n+     * Called on a background thread.\n      */\n     virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n     /**\n@@ -186,7 +188,7 @@ class CMainSignals {\n     void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::shared_ptr<const std::vector<CTransactionRef>> &);\n     void BlockDisconnected(const std::shared_ptr<const CBlock> &);\n     void ChainStateFlushed(const CBlockLocator &);\n-    void BlockChecked(const CBlock&, const CValidationState&);\n+    void BlockChecked(const std::shared_ptr<const CBlock> &block, const CValidationState&);\n     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n     void BlockProcessed();\n };"
      }
    ]
  },
  {
    "sha": "3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYTNiMTNlMTk4OGMzMTllMzVmNDJjZDM1OWI4ZmEzNmEzYTI1MDNk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-17T21:43:31Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:09Z"
      },
      "message": "Move mapBlockSource to cs_peerstate from cs_main\n\nThis technically resolves a race where entries are added to\nmapBlockSource before we know that they're non-malleated and then\nremoved only after PNB returns, though in practice this wasn't an\nissue since all access to mapBlockSource already held cs_peerstate.",
      "tree": {
        "sha": "6bf20634dcc109f13e1808d9d541ec048fbdfabc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6bf20634dcc109f13e1808d9d541ec048fbdfabc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a3b13e1988c319e35f42cd359b8fa36a3a2503d/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4f3a339781343fd8fbcdfd8ffee38e224fd14cd"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 20,
      "deletions": 28
    },
    "files": [
      {
        "sha": "0c1f0272b99c3302900c1c0adce607dfbd4e733e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 28,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a3b13e1988c319e35f42cd359b8fa36a3a2503d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a3b13e1988c319e35f42cd359b8fa36a3a2503d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
        "patch": "@@ -93,6 +93,8 @@ std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n \n void EraseOrphansFor(NodeId peer);\n \n+/** Note that this must be locked BEFORE cs_main! */\n+CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -127,16 +129,11 @@ namespace {\n      * ProcessNewBlock state.IsValid()). See the ProcessNewBlock docs for\n      * more info.\n      *\n-     * TODO: There is currently a race on the above - we add to this map\n-     * before calling PNB and then remove it if the block was malleated. We\n-     * should be able to just not add it to the map if the block is malleated.\n-     * (This is fixed later in this patch set, so should never hit master!)\n-     *\n      * However, things which are not on our best chain but were written to\n      * disk anyway may sit around in here forever, so be careful relying on\n      * its size for any decisions.\n      */\n-    std::map<uint256, std::pair<NodeId, bool>> mapBlockSource GUARDED_BY(cs_main);\n+    std::map<uint256, std::pair<NodeId, bool>> mapBlockSource GUARDED_BY(cs_peerstate);\n \n     /**\n      * Filter for transactions that were recently rejected by\n@@ -431,9 +428,6 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, std::chrono::microseconds> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n-/** Note that this must be locked BEFORE cs_main! */\n-CCriticalSection cs_peerstate;\n-\n /** Map maintaining per-node state. */\n static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n \n@@ -647,7 +641,7 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate, cs_main)\n {\n     if (count == 0)\n         return;\n@@ -1296,6 +1290,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n  * peers announce compact blocks.\n  */\n static void BlockChecked(const CBlock& block, const CValidationState& state, CConnman* connman) {\n+    LOCK(cs_peerstate);\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n@@ -1681,7 +1676,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -2882,10 +2877,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         if (fBlockReconstructed) {\n             // If we got here, we were able to optimistically reconstruct a\n             // block that is in flight from some other peer.\n-            {\n-                LOCK(cs_main);\n-                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n-            }\n             // Setting fForceProcessing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n             // unrequested blocks that might be trying to waste our resources\n@@ -2895,10 +2886,10 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n+            mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             CValidationState dos_state;\n             std::future<bool> block_future = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true);\n             if (!dos_state.IsValid()) {\n-                LOCK(cs_main);\n                 BlockChecked(*pblock, dos_state, connman);\n                 mapBlockSource.erase(pblock->GetHash());\n             } else {\n@@ -2969,15 +2960,13 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n                 // updated, reject messages go out, etc.\n                 MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n-                // mapBlockSource is only used for sending reject messages and DoS scores,\n-                // so the race between here and cs_main in ProcessNewBlock is fine.\n-                // BIP 152 permits peers to relay compact blocks after validating\n-                // the header only; we should not punish peers if the block turns\n-                // out to be invalid.\n-                mapBlockSource.emplace(resp.blockhash, std::make_pair(pfrom->GetId(), false));\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n+            // BIP 152 permits peers to relay compact blocks after validating\n+            // the header only; we should not punish peers if the block turns\n+            // out to be invalid.\n+            mapBlockSource.emplace(resp.blockhash, std::make_pair(pfrom->GetId(), false));\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n@@ -2987,7 +2976,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             CValidationState dos_state;\n             std::future<bool> block_future = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/true);\n             if (!dos_state.IsValid()) {\n-                LOCK(cs_main);\n                 BlockChecked(*pblock, dos_state, connman);\n                 mapBlockSource.erase(pblock->GetHash());\n             } else {\n@@ -3044,14 +3032,19 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n             forceProcessing |= MarkBlockAsReceived(hash);\n-            // mapBlockSource is only used for sending reject messages and DoS scores,\n-            // so the race between here and cs_main in ProcessNewBlock is fine.\n-            mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n+        // Note that ProcessNewBlock only guarantees that we have no need to ever re-download\n+        // this block in case forceProcessing is set to true or the future returns true, but\n+        // adding to mapBlockSource will prevent us from re-downloading this block until the\n+        // future completes. This is ok, as, if we requested the block we'll set forceProcessing,\n+        // and if the block is the same or higher work as our tip the block will be accepted\n+        // (and the future will return true). Thus, a peer sending us an unsolicited block can\n+        // force us to use FindNextBlocksToDownload to fetch a block, but only if that block\n+        // has less work than our current tip.\n+        mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         CValidationState dos_state;\n         std::future<bool> block_future = ProcessNewBlock(chainparams, pblock, dos_state, /*fForceProcessing=*/forceProcessing);\n         if (!dos_state.IsValid()) {\n-            LOCK(cs_main);\n             BlockChecked(*pblock, dos_state, connman);\n             mapBlockSource.erase(pblock->GetHash());\n         } else {\n@@ -3332,7 +3325,6 @@ bool static IsPendingBlockValidation(CNode* pfrom, CPeerState* peerstate) EXCLUS\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n-                LOCK(cs_main);\n                 mapBlockSource.erase(peerstate->pending_block_hash);\n             }\n             peerstate->pending_block_processing = std::future<bool>();"
      }
    ]
  },
  {
    "sha": "1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNDM5ZjcxOWQyYTBjMDJmN2U3Y2QzZjI5ZWIxNDJjMmU2MTU0Mzgz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-14T19:13:24Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:09Z"
      },
      "message": "Move nDoS counters to CPeerState (and, thus, out of cs_main)",
      "tree": {
        "sha": "3719586b23e704f5bed08a94241cc20e1602daaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3719586b23e704f5bed08a94241cc20e1602daaa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1439f719d2a0c02f7e7cd3f29eb142c2e6154383/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a3b13e1988c319e35f42cd359b8fa36a3a2503d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3a3b13e1988c319e35f42cd359b8fa36a3a2503d"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 63,
      "deletions": 58
    },
    "files": [
      {
        "sha": "53cbdd36d6825368bad74345c794f4df17165251",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 50,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1439f719d2a0c02f7e7cd3f29eb142c2e6154383/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1439f719d2a0c02f7e7cd3f29eb142c2e6154383/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
        "patch": "@@ -96,7 +96,7 @@ void EraseOrphansFor(NodeId peer);\n /** Note that this must be locked BEFORE cs_main! */\n CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n /** Increase a node's misbehavior score. */\n-void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\") EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate);\n \n /** Average delay between local address broadcasts in seconds. */\n static constexpr unsigned int AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24 * 60 * 60;\n@@ -217,6 +217,20 @@ struct CBlockReject {\n  * move most (non-validation-specific) state here.\n  */\n struct CPeerState {\n+    //! String name of this peer (debugging/logging purposes).\n+    const std::string name;\n+\n+    //! Whether this peer should be disconnected and banned (unless whitelisted).\n+    bool fShouldBan;\n+    //! Accumulated misbehaviour score for this peer.\n+    int nMisbehavior;\n+\n+    //! Whether this peer is an inbound connection\n+    bool m_is_inbound;\n+\n+    //! Whether this peer is a manual connection\n+    bool m_is_manual_connection;\n+\n     //! If this peer generated some headers for us to add, we store the resulting\n     //! future here and wait for it to complete before we process more data from this\n     //! peer.\n@@ -228,7 +242,13 @@ struct CPeerState {\n     //! in order, though this may grow to include more such events in the future).\n     bool pending_event_wait;\n \n-    CPeerState() {\n+    CPeerState(std::string addrNameIn, bool is_inbound, bool is_manual) :\n+        name(std::move(addrNameIn)),\n+        m_is_inbound(is_inbound),\n+        m_is_manual_connection (is_manual)\n+    {\n+        fShouldBan = false;\n+        nMisbehavior = 0;\n         pending_event_wait = false;\n     }\n };\n@@ -245,12 +265,6 @@ struct CNodeState {\n     const CService address;\n     //! Whether we have a fully established connection.\n     bool fCurrentlyConnected;\n-    //! Accumulated misbehaviour score for this peer.\n-    int nMisbehavior;\n-    //! Whether this peer should be disconnected and banned (unless whitelisted).\n-    bool fShouldBan;\n-    //! String name of this peer (debugging/logging purposes).\n-    const std::string name;\n     //! List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n@@ -395,13 +409,11 @@ struct CNodeState {\n     //! Whether this peer is a manual connection\n     bool m_is_manual_connection;\n \n-    CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :\n-        address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),\n+    CNodeState(CAddress addrIn, bool is_inbound, bool is_manual) :\n+        address(addrIn), m_is_inbound(is_inbound),\n         m_is_manual_connection (is_manual)\n     {\n         fCurrentlyConnected = false;\n-        nMisbehavior = 0;\n-        fShouldBan = false;\n         pindexBestKnownBlock = nullptr;\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = nullptr;\n@@ -431,7 +443,7 @@ limitedmap<uint256, std::chrono::microseconds> g_already_asked_for GUARDED_BY(cs\n /** Map maintaining per-node state. */\n static std::map<NodeId, CPeerState> mapPeerState GUARDED_BY(cs_peerstate);\n \n-static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) LOCKS_EXCLUDED(cs_main) {\n+static CPeerState *PeerState(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     std::map<NodeId, CPeerState>::iterator it = mapPeerState.find(pnode);\n     if (it == mapPeerState.end())\n         return nullptr;\n@@ -814,11 +826,11 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     NodeId nodeid = pnode->GetId();\n     {\n         LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, pnode->fInbound, pnode->m_manual_connection));\n     }\n     {\n         LOCK(cs_peerstate);\n-        mapPeerState.emplace_hint(mapPeerState.end(), nodeid, CPeerState{});\n+        mapPeerState.emplace_hint(mapPeerState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n \n     if(!pnode->fInbound)\n@@ -839,7 +851,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     if (state->fSyncStarted)\n         nSyncStarted--;\n \n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n+    if (peerstate->nMisbehavior == 0 && state->fCurrentlyConnected) {\n         fUpdateConnectionTime = true;\n     }\n \n@@ -868,11 +880,14 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n }\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n+    LOCK(cs_peerstate);\n+    CPeerState* peerstate = PeerState(nodeid);\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n-    if (state == nullptr)\n+    if (state == nullptr || peerstate == nullptr)\n         return false;\n-    stats.nMisbehavior = state->nMisbehavior;\n+\n+    stats.nMisbehavior = peerstate->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n     for (const QueuedBlock& queue : state->vBlocksInFlight) {\n@@ -1015,27 +1030,28 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     return nEvicted;\n }\n \n+\n /**\n  * Mark a misbehaving peer to be banned depending upon the value of `-banscore`.\n  */\n-void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void Misbehaving(NodeId pnode, int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     if (howmuch == 0)\n         return;\n \n-    CNodeState *state = State(pnode);\n-    if (state == nullptr)\n+    CPeerState *peerstate = PeerState(pnode);\n+    if (peerstate == nullptr)\n         return;\n \n-    state->nMisbehavior += howmuch;\n+    peerstate->nMisbehavior += howmuch;\n     int banscore = gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD);\n     std::string message_prefixed = message.empty() ? \"\" : (\": \" + message);\n-    if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n+    if (peerstate->nMisbehavior >= banscore && peerstate->nMisbehavior - howmuch < banscore)\n     {\n-        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n-        state->fShouldBan = true;\n+        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, peerstate->name, pnode, peerstate->nMisbehavior-howmuch, peerstate->nMisbehavior, message_prefixed);\n+        peerstate->fShouldBan = true;\n     } else\n-        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);\n+        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, peerstate->name, pnode, peerstate->nMisbehavior-howmuch, peerstate->nMisbehavior, message_prefixed);\n }\n \n /**\n@@ -1061,30 +1077,28 @@ static bool TxRelayMayResultInDisconnect(const CValidationState& state)\n  *\n  * Changes here may need to be reflected in TxRelayMayResultInDisconnect().\n  */\n-static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") {\n+static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool via_compact_block, const std::string& message = \"\") EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     switch (state.GetReason()) {\n     case ValidationInvalidReason::NONE:\n         break;\n     // The node is providing invalid data:\n     case ValidationInvalidReason::CONSENSUS:\n     case ValidationInvalidReason::BLOCK_MUTATED:\n         if (!via_compact_block) {\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n             return true;\n         }\n         break;\n     case ValidationInvalidReason::CACHED_INVALID:\n         {\n-            LOCK(cs_main);\n-            CNodeState *node_state = State(nodeid);\n-            if (node_state == nullptr) {\n+            CPeerState *peer_state = PeerState(nodeid);\n+            if (peer_state == nullptr) {\n                 break;\n             }\n \n             // Ban outbound (but not inbound) peers if on an invalid chain.\n             // Exempt HB compact block peers and manual connections.\n-            if (!via_compact_block && !node_state->m_is_inbound && !node_state->m_is_manual_connection) {\n+            if (!via_compact_block && !peer_state->m_is_inbound && !peer_state->m_is_manual_connection) {\n                 Misbehaving(nodeid, 100, message);\n                 return true;\n             }\n@@ -1094,15 +1108,13 @@ static bool MaybePunishNode(NodeId nodeid, const CValidationState& state, bool v\n     case ValidationInvalidReason::BLOCK_CHECKPOINT:\n     case ValidationInvalidReason::BLOCK_INVALID_PREV:\n         {\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 100, message);\n         }\n         return true;\n     // Conflicting (but not necessarily invalid) data or different policy:\n     case ValidationInvalidReason::BLOCK_MISSING_PREV:\n         {\n             // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)\n-            LOCK(cs_main);\n             Misbehaving(nodeid, 10, message);\n         }\n         return true;\n@@ -1660,11 +1672,10 @@ static uint32_t GetFetchFlags(CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode* pfrom, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId()));\n             return;\n         }\n@@ -1858,9 +1869,10 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate, cs_main, g_cs_orphans)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     AssertLockHeld(g_cs_orphans);\n     std::set<NodeId> setMisbehaving;\n     bool done = false;\n@@ -1935,7 +1947,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n                strCommand == NetMsgType::FILTERADD))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n             return false;\n         } else {\n@@ -1976,7 +1987,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             if (enable_bip61) {\n                 connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             }\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n         }\n@@ -2144,7 +2154,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n     if (pfrom->nVersion == 0) {\n         // Must have a version message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -2191,7 +2200,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n     if (!pfrom->fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -2205,7 +2213,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             return true;\n         if (vAddr.size() > 1000)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));\n             return false;\n         }\n@@ -2281,7 +2288,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));\n             return false;\n         }\n@@ -2339,7 +2345,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));\n             return false;\n         }\n@@ -2999,7 +3004,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20, strprintf(\"headers message size = %u\", nCount));\n             return false;\n         }\n@@ -3194,7 +3198,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         if (!filter.IsWithinSizeConstraints())\n         {\n             // There is no excuse for sending a too-large filter\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         else\n@@ -3225,7 +3228,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             }\n         }\n         if (bad) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n         return true;\n@@ -3283,10 +3285,12 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n     return true;\n }\n \n-bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_peerstate)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     CNodeState &state = *State(pnode->GetId());\n+    CPeerState &peerstate = *PeerState(pnode->GetId());\n \n     if (enable_bip61) {\n         for (const CBlockReject& reject : state.rejects) {\n@@ -3295,8 +3299,8 @@ bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_\n     }\n     state.rejects.clear();\n \n-    if (state.fShouldBan) {\n-        state.fShouldBan = false;\n+    if (peerstate.fShouldBan) {\n+        peerstate.fShouldBan = false;\n         if (pnode->HasPermission(PF_NOBAN))\n             LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());\n         else if (pnode->m_manual_connection)"
      },
      {
        "sha": "0c90bb4aeb24b0f6504ae3c0d3806535054d2dff",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1439f719d2a0c02f7e7cd3f29eb142c2e6154383/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1439f719d2a0c02f7e7cd3f29eb142c2e6154383/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
        "patch": "@@ -45,6 +45,7 @@ extern bool AddOrphanTx(const CTransactionRef& tx, NodeId peer);\n extern void EraseOrphansFor(NodeId peer);\n extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n extern void Misbehaving(NodeId nodeid, int howmuch, const std::string& message=\"\");\n+extern CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n \n struct COrphanTx {\n     CTransactionRef tx;\n@@ -231,7 +232,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     }\n     {\n@@ -248,7 +249,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n@@ -258,7 +259,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     BOOST_CHECK(!banman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(banman->IsBanned(addr1));  // ... but 1 still should be\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode2.GetId(), 50);\n     }\n     {\n@@ -287,7 +288,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 100);\n     }\n     {\n@@ -296,7 +297,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 10);\n     }\n     {\n@@ -305,7 +306,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     }\n     BOOST_CHECK(!banman->IsBanned(addr1));\n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode1.GetId(), 1);\n     }\n     {\n@@ -337,7 +338,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     dummyNode.fSuccessfullyConnected = true;\n \n     {\n-        LOCK(cs_main);\n+        LOCK(cs_peerstate);\n         Misbehaving(dummyNode.GetId(), 100);\n     }\n     {\n@@ -359,7 +360,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n static CTransactionRef RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;\n-    LOCK2(cs_main, g_cs_orphans);\n+    LOCK(g_cs_orphans);\n     it = mapOrphanTransactions.lower_bound(InsecureRand256());\n     if (it == mapOrphanTransactions.end())\n         it = mapOrphanTransactions.begin();"
      }
    ]
  },
  {
    "sha": "cbec3a36b21128bffc037f8a91f351c780354e22",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYmVjM2EzNmIyMTEyOGJmZmMwMzdmOGE5MWYzNTFjNzgwMzU0ZTIy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-06-09T11:32:18Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:09Z"
      },
      "message": "Move rejects into cs_peerstate.\n\nThis removes the cs_main lock which is taken on every\nProcessMessages call.",
      "tree": {
        "sha": "bf3206ca547c98047e50eed73eeae0afd207d8bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf3206ca547c98047e50eed73eeae0afd207d8bb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cbec3a36b21128bffc037f8a91f351c780354e22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbec3a36b21128bffc037f8a91f351c780354e22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cbec3a36b21128bffc037f8a91f351c780354e22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbec3a36b21128bffc037f8a91f351c780354e22/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1439f719d2a0c02f7e7cd3f29eb142c2e6154383",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1439f719d2a0c02f7e7cd3f29eb142c2e6154383"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 33,
      "deletions": 35
    },
    "files": [
      {
        "sha": "3202e521cad5da9c22c3cf8423dca8d95003d6d4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 34,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cbec3a36b21128bffc037f8a91f351c780354e22/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cbec3a36b21128bffc037f8a91f351c780354e22/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=cbec3a36b21128bffc037f8a91f351c780354e22",
        "patch": "@@ -220,6 +220,9 @@ struct CPeerState {\n     //! String name of this peer (debugging/logging purposes).\n     const std::string name;\n \n+    //! List of asynchronously-determined block rejections to notify this peer about.\n+    std::vector<CBlockReject> rejects;\n+\n     //! Whether this peer should be disconnected and banned (unless whitelisted).\n     bool fShouldBan;\n     //! Accumulated misbehaviour score for this peer.\n@@ -265,8 +268,6 @@ struct CNodeState {\n     const CService address;\n     //! Whether we have a fully established connection.\n     bool fCurrentlyConnected;\n-    //! List of asynchronously-determined block rejections to notify this peer about.\n-    std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n     const CBlockIndex *pindexBestKnownBlock;\n     //! The hash of the last unknown block this peer has announced.\n@@ -1308,29 +1309,29 @@ static void BlockChecked(const CBlock& block, const CValidationState& state, CCo\n     const uint256 hash(block.GetHash());\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n \n-    if (state.IsInvalid()) {\n-        // Don't send reject message with code 0 or an internal reject code.\n-        if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n-            CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n-            State(it->second.first)->rejects.push_back(reject);\n-            MaybePunishNode(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n+    if (it != mapBlockSource.end()) {\n+        if (state.IsInvalid()) {\n+            CPeerState *peerstate = PeerState(it->second.first);\n+            // Don't send reject message with code 0 or an internal reject code.\n+            if (peerstate && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n+                CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n+                peerstate->rejects.push_back(reject);\n+                MaybePunishNode(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n+            }\n         }\n-    }\n-    // Check that:\n-    // 1. The block is valid\n-    // 2. We're not in initial block download\n-    // 3. This is currently the best block we're aware of. We haven't updated\n-    //    the tip yet so we have no way to check this directly here. Instead we\n-    //    just check that there are currently no other blocks in flight.\n-    else if (state.IsValid() &&\n-             !::ChainstateActive().IsInitialBlockDownload() &&\n-             mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n-        if (it != mapBlockSource.end()) {\n+        // Check that:\n+        // 1. The block is valid\n+        // 2. We're not in initial block download\n+        // 3. This is currently the best block we're aware of. We haven't updated\n+        //    the tip yet so we have no way to check this directly here. Instead we\n+        //    just check that there are currently no other blocks in flight.\n+        else if (state.IsValid() &&\n+                 !::ChainstateActive().IsInitialBlockDownload() &&\n+                 mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);\n         }\n-    }\n-    if (it != mapBlockSource.end())\n         mapBlockSource.erase(it);\n+    }\n }\n \n void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n@@ -3285,19 +3286,17 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n     return true;\n }\n \n-bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_peerstate)\n+bool PeerLogicValidation::SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n-    AssertLockHeld(cs_main);\n     AssertLockHeld(cs_peerstate);\n-    CNodeState &state = *State(pnode->GetId());\n     CPeerState &peerstate = *PeerState(pnode->GetId());\n \n     if (enable_bip61) {\n-        for (const CBlockReject& reject : state.rejects) {\n+        for (const CBlockReject& reject : peerstate.rejects) {\n             connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::BLOCK), reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n         }\n     }\n-    state.rejects.clear();\n+    peerstate.rejects.clear();\n \n     if (peerstate.fShouldBan) {\n         peerstate.fShouldBan = false;\n@@ -3385,13 +3384,10 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     if (IsPendingBlockValidation(pfrom, peerstate)) {\n         return false;\n     }\n-    {\n-        // Somewhat annoyingly, tests currently rely on any pending bans/disconnects\n-        // being processed prior to any pong responses, thus if we were waiting on a\n-        // block validation to complete, we need to recheck bans.\n-        LOCK(cs_main);\n-        SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n-    }\n+    // Somewhat annoyingly, tests currently rely on any pending bans/disconnects\n+    // being processed prior to any pong responses, thus if we were waiting on a\n+    // block validation to complete, we need to recheck bans.\n+    SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n \n     if (pfrom->fDisconnect)\n         return false;\n@@ -3494,7 +3490,6 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n         LogPrint(BCLog::NET, \"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n     }\n \n-    LOCK(cs_main);\n     SendRejectsAndCheckIfBanned(pfrom, m_enable_bip61);\n \n     return fMoreWork;"
      },
      {
        "sha": "a308a0d052f60edf4f670a85556514f5adb66c25",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cbec3a36b21128bffc037f8a91f351c780354e22/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cbec3a36b21128bffc037f8a91f351c780354e22/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=cbec3a36b21128bffc037f8a91f351c780354e22",
        "patch": "@@ -13,6 +13,9 @@\n \n extern CCriticalSection cs_main;\n \n+/** Note that this must be locked BEFORE cs_main! */\n+extern CCriticalSection cs_peerstate ACQUIRED_BEFORE(cs_main);\n+\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n@@ -26,7 +29,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     CConnman* const connman;\n     BanMan* const m_banman;\n \n-    bool SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool SendRejectsAndCheckIfBanned(CNode* pnode, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate);\n public:\n     PeerLogicValidation(CConnman* connman, BanMan* banman, CScheduler &scheduler, bool enable_bip61);\n "
      }
    ]
  },
  {
    "sha": "ae11ddc3b22b88902cb94111238195491ccb95d2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZTExZGRjM2IyMmI4ODkwMmNiOTQxMTEyMzgxOTU0OTFjY2I5NWQy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-07-04T00:02:48Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:09Z"
      },
      "message": "Move blocks-in-flight related tracking from CNodeState to CPeerState\n\nThis moves one more group of variables out of cs_main. Importantly,\nthese moves allow us to do block processing almost entirely without\ncs_main once mapBlockIndex moves to its own (read) lock.",
      "tree": {
        "sha": "7d86395cb83ac194e13a644483b8c31d8b80cd69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7d86395cb83ac194e13a644483b8c31d8b80cd69"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae11ddc3b22b88902cb94111238195491ccb95d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae11ddc3b22b88902cb94111238195491ccb95d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ae11ddc3b22b88902cb94111238195491ccb95d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae11ddc3b22b88902cb94111238195491ccb95d2/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cbec3a36b21128bffc037f8a91f351c780354e22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbec3a36b21128bffc037f8a91f351c780354e22",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cbec3a36b21128bffc037f8a91f351c780354e22"
      }
    ],
    "stats": {
      "total": 179,
      "additions": 87,
      "deletions": 92
    },
    "files": [
      {
        "sha": "ca0d192158bac0edae55f77586dafc21f31815ca",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 92,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae11ddc3b22b88902cb94111238195491ccb95d2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae11ddc3b22b88902cb94111238195491ccb95d2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ae11ddc3b22b88902cb94111238195491ccb95d2",
        "patch": "@@ -164,7 +164,7 @@ namespace {\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_main);\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_peerstate);\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n@@ -173,7 +173,7 @@ namespace {\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n \n     /** Number of peers from which we're downloading blocks. */\n-    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n+    int nPeersWithValidatedDownloads GUARDED_BY(cs_peerstate) = 0;\n \n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int g_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n@@ -234,6 +234,14 @@ struct CPeerState {\n     //! Whether this peer is a manual connection\n     bool m_is_manual_connection;\n \n+    int nBlocksInFlight;\n+    int nBlocksInFlightValidHeaders;\n+    std::list<QueuedBlock> vBlocksInFlight;\n+    //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n+    int64_t nDownloadingSince;\n+    //! Since when we're stalling block download progress (in microseconds), or 0.\n+    int64_t nStallingSince;\n+\n     //! If this peer generated some headers for us to add, we store the resulting\n     //! future here and wait for it to complete before we process more data from this\n     //! peer.\n@@ -252,6 +260,10 @@ struct CPeerState {\n     {\n         fShouldBan = false;\n         nMisbehavior = 0;\n+        nBlocksInFlight = 0;\n+        nBlocksInFlightValidHeaders = 0;\n+        nDownloadingSince = 0;\n+        nStallingSince = 0;\n         pending_event_wait = false;\n     }\n };\n@@ -282,13 +294,6 @@ struct CNodeState {\n     bool fSyncStarted;\n     //! When to potentially disconnect peer for stalling headers download\n     int64_t nHeadersSyncTimeout;\n-    //! Since when we're stalling block download progress (in microseconds), or 0.\n-    int64_t nStallingSince;\n-    std::list<QueuedBlock> vBlocksInFlight;\n-    //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n-    int64_t nDownloadingSince;\n-    int nBlocksInFlight;\n-    int nBlocksInFlightValidHeaders;\n     //! Whether we consider this a preferred download peer.\n     bool fPreferredDownload;\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n@@ -422,10 +427,6 @@ struct CNodeState {\n         nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n         nHeadersSyncTimeout = 0;\n-        nStallingSince = 0;\n-        nDownloadingSince = 0;\n-        nBlocksInFlight = 0;\n-        nBlocksInFlightValidHeaders = 0;\n         fPreferredDownload = false;\n         fPreferHeaders = false;\n         fPreferHeaderAndIDs = false;\n@@ -494,10 +495,10 @@ static void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n \n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n-static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n+        CPeerState *state = PeerState(itInFlight->second.first);\n         assert(state != nullptr);\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n         if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n@@ -519,8 +520,8 @@ static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs\n \n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    CNodeState *state = State(nodeid);\n+static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate) {\n+    CPeerState *state = PeerState(nodeid);\n     assert(state != nullptr);\n \n     // Short-circuit most stuff in case it is from the same node\n@@ -629,9 +630,9 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connma\n     }\n }\n \n-static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n-    AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_peerstate);\n     if (g_last_tip_update == 0) {\n         g_last_tip_update = GetTime();\n     }\n@@ -856,12 +857,12 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         fUpdateConnectionTime = true;\n     }\n \n-    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n+    for (const QueuedBlock& entry : peerstate->vBlocksInFlight) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n     EraseOrphansFor(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n+    nPeersWithValidatedDownloads -= (peerstate->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n     g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n@@ -891,7 +892,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     stats.nMisbehavior = peerstate->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n-    for (const QueuedBlock& queue : state->vBlocksInFlight) {\n+    for (const QueuedBlock& queue : peerstate->vBlocksInFlight) {\n         if (queue.pindex)\n             stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n     }\n@@ -1688,7 +1689,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n+bool static ProcessHeadersMessage(CNode *pfrom, CPeerState* peerstate, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block) EXCLUSIVE_LOCKS_REQUIRED(cs_peerstate)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1812,7 +1813,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n                 std::vector<CInv> vGetData;\n                 // Download as much as possible, from earliest to latest.\n                 for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n-                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                    if (peerstate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         // Can't download any more from this peer\n                         break;\n                     }\n@@ -2793,7 +2794,7 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= ::ChainActive().Height() + 2) {\n-            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+            if ((!fAlreadyInFlight && peerstate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n@@ -2877,7 +2878,7 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             // the peer if the header turns out to be for an invalid block.\n             // Note that if a peer tries to build on an invalid chain, that\n             // will be detected and the peer will be banned.\n-            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n+            return ProcessHeadersMessage(pfrom, peerstate, connman, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n         }\n \n         if (fBlockReconstructed) {\n@@ -2901,7 +2902,6 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             } else {\n                 peerstate->pending_block_hash = pblock->GetHash();\n                 peerstate->pending_block_processing = std::move(block_future);\n-                LOCK(cs_main);\n                 // Clear download state for this block, which is in\n                 // process from some other peer.  We do this after calling\n                 // ProcessNewBlock so that a malleated cmpctblock announcement\n@@ -2924,51 +2924,49 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         vRecv >> resp;\n \n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n-        bool fBlockRead = false;\n+        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        ReadStatus status;\n         {\n+            // FillBlock calls CheckBlock, which requires cs_main\n             LOCK(cs_main);\n-\n-            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n-            if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n-                    it->second.first != pfrom->GetId()) {\n-                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n-                return true;\n-            }\n-\n-            PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n-            ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n-            if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n-                Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId()));\n-                return true;\n-            } else if (status == READ_STATUS_FAILED) {\n-                // Might have collided, fall back to getdata now :(\n-                std::vector<CInv> invs;\n-                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n-            } else {\n-                // Block is either okay, or possibly we received\n-                // READ_STATUS_CHECKBLOCK_FAILED.\n-                // Note that CheckBlock can only fail for one of a few reasons:\n-                // 1. bad-proof-of-work (impossible here, because we've already\n-                //    accepted the header)\n-                // 2. merkleroot doesn't match the transactions given (already\n-                //    caught in FillBlock with READ_STATUS_FAILED, so\n-                //    impossible here)\n-                // 3. the block is otherwise invalid (eg invalid coinbase,\n-                //    block is too big, too many legacy sigops, etc).\n-                // So if CheckBlock failed, #3 is the only possibility.\n-                // Under BIP 152, we don't DoS-ban unless proof of work is\n-                // invalid (we don't require all the stateless checks to have\n-                // been run).  This is handled below, so just treat this as\n-                // though the block was successfully read, and rely on the\n-                // handling in ProcessNewBlock to ensure the block index is\n-                // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n-                fBlockRead = true;\n-            }\n-        } // Don't hold cs_main when we call into ProcessNewBlock\n-        if (fBlockRead) {\n+            status = partialBlock.FillBlock(*pblock, resp.txn);\n+        }\n+        if (status == READ_STATUS_INVALID) {\n+            MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n+            Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId()));\n+            return true;\n+        } else if (status == READ_STATUS_FAILED) {\n+            // Might have collided, fall back to getdata now :(\n+            std::vector<CInv> invs;\n+            LOCK(cs_main);\n+            invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+        } else {\n+            // Block is either okay, or possibly we received\n+            // READ_STATUS_CHECKBLOCK_FAILED.\n+            // Note that CheckBlock can only fail for one of a few reasons:\n+            // 1. bad-proof-of-work (impossible here, because we've already\n+            //    accepted the header)\n+            // 2. merkleroot doesn't match the transactions given (already\n+            //    caught in FillBlock with READ_STATUS_FAILED, so\n+            //    impossible here)\n+            // 3. the block is otherwise invalid (eg invalid coinbase,\n+            //    block is too big, too many legacy sigops, etc).\n+            // So if CheckBlock failed, #3 is the only possibility.\n+            // Under BIP 152, we don't DoS-ban unless proof of work is\n+            // invalid (we don't require all the stateless checks to have\n+            // been run).  This is handled below, so just treat this as\n+            // though the block was successfully read, and rely on the\n+            // handling in ProcessNewBlock to ensure the block index is\n+            // updated, reject messages go out, etc.\n+            MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n             // BIP 152 permits peers to relay compact blocks after validating\n             // the header only; we should not punish peers if the block turns\n             // out to be invalid.\n@@ -3014,7 +3012,7 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, /*via_compact_block=*/false);\n+        return ProcessHeadersMessage(pfrom, peerstate, connman, headers, chainparams, /*via_compact_block=*/false);\n     }\n \n     if (strCommand == NetMsgType::BLOCK)\n@@ -3030,14 +3028,10 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n \n         LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n-        bool forceProcessing = false;\n         const uint256 hash(pblock->GetHash());\n-        {\n-            LOCK(cs_main);\n-            // Also always process if we requested the block explicitly, as we may\n-            // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n-        }\n+        // Also always process if we requested the block explicitly, as we may\n+        // need it even though it is not a candidate for a new best tip.\n+        bool forceProcessing = MarkBlockAsReceived(hash);\n         // Note that ProcessNewBlock only guarantees that we have no need to ever re-download\n         // this block in case forceProcessing is set to true or the future returns true, but\n         // adding to mapBlockSource will prevent us from re-downloading this block until the\n@@ -3576,20 +3570,20 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         });\n         if (worst_peer != -1) {\n             bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {\n-                AssertLockHeld(cs_main);\n+                AssertLockHeld(cs_peerstate);\n \n                 // Only disconnect a peer that has been connected to us for\n                 // some reasonable fraction of our check-frequency, to give\n                 // it time for new information to have arrived.\n                 // Also don't disconnect any peer we're trying to download a\n                 // block from.\n-                CNodeState &state = *State(pnode->GetId());\n-                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n+                CPeerState &peerstate = *PeerState(pnode->GetId());\n+                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && peerstate.nBlocksInFlight == 0) {\n                     LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n                     pnode->fDisconnect = true;\n                     return true;\n                 } else {\n-                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);\n+                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, peerstate.nBlocksInFlight);\n                     return false;\n                 }\n             });\n@@ -3607,6 +3601,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n \n void PeerLogicValidation::CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams)\n {\n+    LOCK(cs_peerstate);\n     LOCK(cs_main);\n \n     if (connman == nullptr) return;\n@@ -4044,7 +4039,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // nNow is the current system time (GetTimeMicros is not mockable) and\n         // should be replaced by the mockable current_time eventually\n         nNow = GetTimeMicros();\n-        if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+        if (peerstate->nStallingSince && peerstate->nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n@@ -4057,10 +4052,10 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // We compensate for other peers to prevent killing off peers due to our own downstream link\n         // being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes\n         // to unreasonably increase our timeout.\n-        if (state.vBlocksInFlight.size() > 0) {\n-            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n-            if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n+        if (peerstate->vBlocksInFlight.size() > 0) {\n+            QueuedBlock &queuedBlock = peerstate->vBlocksInFlight.front();\n+            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (peerstate->nBlocksInFlightValidHeaders > 0);\n+            if (nNow > peerstate->nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n                 LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n@@ -4107,20 +4102,20 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // Message: getdata (blocks)\n         //\n         std::vector<CInv> vGetData;\n-        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && peerstate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - peerstate->nBlocksInFlight, vToDownload, staller, consensusParams);\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n-                if (State(staller)->nStallingSince == 0) {\n-                    State(staller)->nStallingSince = nNow;\n+            if (peerstate->nBlocksInFlight == 0 && staller != -1) {\n+                if (PeerState(staller)->nStallingSince == 0) {\n+                    PeerState(staller)->nStallingSince = nNow;\n                     LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "99108e2b0c194c62843223bd17cc59fac44f48d5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTEwOGUyYjBjMTk0YzYyODQzMjIzYmQxN2NjNTlmYWM0NGY0OGQ1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-07-28T18:43:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-20T03:52:10Z"
      },
      "message": "Move CBlock::fChecked (and, thus, CheckBlock) out of cs_main\n\nThis has the effect of allowing CheckBlock to run in parallel with\nother block connection things in some cases during IBD.",
      "tree": {
        "sha": "ed4a1d9ec087cbc9a64b66056340e58b935f2391",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed4a1d9ec087cbc9a64b66056340e58b935f2391"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99108e2b0c194c62843223bd17cc59fac44f48d5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99108e2b0c194c62843223bd17cc59fac44f48d5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99108e2b0c194c62843223bd17cc59fac44f48d5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99108e2b0c194c62843223bd17cc59fac44f48d5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ae11ddc3b22b88902cb94111238195491ccb95d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae11ddc3b22b88902cb94111238195491ccb95d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ae11ddc3b22b88902cb94111238195491ccb95d2"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 16,
      "deletions": 23
    },
    "files": [
      {
        "sha": "243c0f06d27889265d58d9ed7d6b06f8315142d5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99108e2b0c194c62843223bd17cc59fac44f48d5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99108e2b0c194c62843223bd17cc59fac44f48d5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=99108e2b0c194c62843223bd17cc59fac44f48d5",
        "patch": "@@ -2932,12 +2932,7 @@ bool static ProcessMessage(CNode* pfrom, CPeerState* peerstate, const std::strin\n         }\n \n         PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n-        ReadStatus status;\n-        {\n-            // FillBlock calls CheckBlock, which requires cs_main\n-            LOCK(cs_main);\n-            status = partialBlock.FillBlock(*pblock, resp.txn);\n-        }\n+        ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n         if (status == READ_STATUS_INVALID) {\n             MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n             Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId()));"
      },
      {
        "sha": "725ce328cd157021762f451c9ea3ee47c8cd83c8",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99108e2b0c194c62843223bd17cc59fac44f48d5/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99108e2b0c194c62843223bd17cc59fac44f48d5/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=99108e2b0c194c62843223bd17cc59fac44f48d5",
        "patch": "@@ -76,6 +76,7 @@ class CBlock : public CBlockHeader\n     std::vector<CTransactionRef> vtx;\n \n     // memory only\n+    // protected by a lock inside CheckBlock, do not access elsewhere!\n     mutable bool fChecked;\n \n     CBlock()"
      },
      {
        "sha": "8b101085df5887f4f934a3a9140f45253f10b529",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 17,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99108e2b0c194c62843223bd17cc59fac44f48d5/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99108e2b0c194c62843223bd17cc59fac44f48d5/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=99108e2b0c194c62843223bd17cc59fac44f48d5",
        "patch": "@@ -3024,10 +3024,12 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+static CCriticalSection cs_blockchecked;\n bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     // These are checks that are independent of context.\n \n+    LOCK(cs_blockchecked);\n     if (block.fChecked)\n         return true;\n \n@@ -3636,25 +3638,20 @@ std::future<bool> CChainState::ProcessNewBlock(const CChainParams& chainparams,\n     std::future<bool> result = result_promise.get_future();\n     bool fNewBlock = false;\n \n-    {\n-        // CheckBlock() does not support multi-threaded block validation because CBlock::fChecked can cause data race.\n-        // Therefore, the following critical section must include the CheckBlock() call as well.\n+    // Ensure that CheckBlock() passes before calling AcceptBlock, as\n+    // belt-and-suspenders.\n+    bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n+    if (ret) {\n+        // Store to disk\n         LOCK(cs_main);\n-\n-        // Ensure that CheckBlock() passes before calling AcceptBlock, as\n-        // belt-and-suspenders.\n-        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n-        if (ret) {\n-            // Store to disk\n-            ret = PreWriteCheckBlock(pblock, state, chainparams, nullptr, fForceProcessing, &fNewBlock);\n-        }\n-        if (!ret || !fNewBlock) {\n-            if (!ret) {\n-                error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n-            }\n-            result_promise.set_value(fNewBlock);\n-            return result;\n+        ret = PreWriteCheckBlock(pblock, state, chainparams, nullptr, fForceProcessing, &fNewBlock);\n+    }\n+    if (!ret || !fNewBlock) {\n+        if (!ret) {\n+            error(\"%s: AcceptBlock FAILED (%s)\", __func__, FormatStateMessage(state));\n         }\n+        result_promise.set_value(fNewBlock);\n+        return result;\n     }\n \n     {"
      }
    ]
  }
]