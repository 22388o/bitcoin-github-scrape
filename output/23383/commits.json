[
  {
    "sha": "440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
    "node_id": "C_kwDOABII59oAKDQ0MGY3ZWM4MGVmZjFmNGY1YjIxMzlkNjZiODljYzZmMzMwNTNjODA",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-31T17:06:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-31T17:06:39Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from be8d9c262f..8fa41201bd\n\n8fa41201bd Merge bitcoin-core/secp256k1#1002: Make aux_rnd32==NULL behave identical to 0x0000..00.\n5324f8942d Make aux_rnd32==NULL behave identical to 0x0000..00.\n21c188b3c5 Merge bitcoin-core/secp256k1#943: VERIFY_CHECK precondition for secp256k1_fe_set_int.\n3e7b2ea194 Merge bitcoin-core/secp256k1#999: bench_ecmult: improve clarity of output\n23e2f66726 bench: don't return 1 in have_flag() if argc = 1\n96b1ad2ea9 bench_ecmult: improve clarity of output\n20d791edfb Merge bitcoin-core/secp256k1#989: Shared benchmark format for command line and CSV outputs\naa1b889b61 Merge bitcoin-core/secp256k1#996: Fix G.y parity in sage code\n044d956305 Fix G.y parity in sage code\nb4b130678d create csv file from the benchmark output\n26a255beb6 Shared benchmark format for command line and CSV outputs\n9526874d14 Merge bitcoin-core/secp256k1#810: Avoid overly-wide multiplications in 5x52 field mul/sqr\n920a0e5fa6 Merge bitcoin-core/secp256k1#952: Avoid computing out-of-bounds pointer.\nf34b5cae03 Merge bitcoin-core/secp256k1#983: [RFC] Remove OpenSSL testing support\n297ce82091 Merge bitcoin-core/secp256k1#966: Make aux_rand32 arg to secp256k1_schnorrsig_sign const\n2888640132 VERIFY_CHECK precondition for secp256k1_fe_set_int.\nd49011f54c Make _set_fe_int( . , 0 ) set magnitude to 0\nbc08599e77 Remove OpenSSL testing support\n10f9bd84f4 Merge bitcoin-core/secp256k1#987: Fix unused parameter warnings when building without VERIFY\n189f6bcfef Fix unused parameter warnings when building without VERIFY\nda0092bccc Merge bitcoin-core/secp256k1#986: tests: remove `secp256k1_fe_verify` from tests.c and modify `_fe_from_storage` to call `_fe_verify`\nd43993724d tests: remove `secp256k1_fe_verify` from tests.c and modify `secp256k1_fe_from_storage` to call `secp256k1_fe_verify`\n2a3a97c665 Merge bitcoin-core/secp256k1#976: `secp256k1_schnorrsig_sign_internal` should be static\naa5d34a8fe Merge bitcoin-core/secp256k1#783: Make the public API docs more consistent and explicit\n72713872a8 Add missing static to secp256k1_schnorrsig_sign_internal\ndb4667d5e0 Make aux_rand32 arg to secp256k1_schnorrsig_sign const\n9a5a87e0f1 Merge bitcoin-core/secp256k1#956: Replace ecmult_context with a generated static array.\n20abd52c2e Add tests for pre_g tables.\n6815761cf5 Remove ecmult_context.\nf20dcbbad1 Correct typo.\n16a3cc07e8 Generate ecmult_static_pre_g.h\n8de2d86a06 Bump memory limits in advance of making the ecmult context static.\nd7ec49a689 Merge bitcoin-core/secp256k1#969: ci: Fixes after Debian release\n5d5c74a057 tests: Rewrite code to circument potential bug in clang\n3d2f492ceb ci: Install libasan6 (instead of 5) after Debian upgrade\nadec5a1638 Add missing null check for ctx and input keys in the public API\nf4edfc7581 Improve consistency for NULL arguments in the public interface\n9be7b0f083 Avoid computing out-of-bounds pointer.\nb53e0cd61f Avoid overly-wide multiplications\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 8fa41201bde8844f79198401c60ec57fa84517e3",
      "tree": {
        "sha": "fc72ceb7fc310ec9ee39d6cbc04e1e1e1047c7d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc72ceb7fc310ec9ee39d6cbc04e1e1e1047c7d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273"
      }
    ],
    "stats": {
      "total": 18319,
      "additions": 17348,
      "deletions": 971
    },
    "files": [
      {
        "sha": "8111551a72815e36a9d60934df039efb5f0a37dd",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -278,14 +278,13 @@ task:\n   container:\n     dockerfile: ci/linux-debian.Dockerfile\n     cpu: 1\n-    memory: 1G\n+    memory: 2G\n   env:\n     ECDH: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n     CTIMETEST: no\n-    EXTRAFLAGS: \"--disable-openssl-tests\"\n   matrix:\n     - name: \"Valgrind (memcheck)\"\n       env:"
      },
      {
        "sha": "9cf2163c3978bbb5bfd37314ad2a40102d6a6a6a",
        "filename": ".gitattributes",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/.gitattributes",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/.gitattributes",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitattributes?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -0,0 +1 @@\n+src/ecmult_static_pre_g.h linguist-generated"
      },
      {
        "sha": "aa7009af148559b51d0b78012ddbc9eee9de58f1",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -9,10 +9,12 @@ bench_internal\n tests\n exhaustive_tests\n gen_context\n+gen_ecmult_static_pre_g\n valgrind_ctime_test\n *.exe\n *.so\n *.a\n+*.csv\n !.gitignore\n \n Makefile"
      },
      {
        "sha": "a04ad05e8dccf4c367c309f07421780e412026cf",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -84,8 +84,6 @@ if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n-# SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n-bench_verify_CPPFLAGS = $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n@@ -127,12 +125,19 @@ exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n \n+EXTRA_PROGRAMS = gen_ecmult_static_pre_g\n+gen_ecmult_static_pre_g_SOURCES = src/gen_ecmult_static_pre_g.c\n+# See Automake manual, Section \"Errors with distclean\"\n+src/ecmult_static_pre_g.h:\n+\t$(MAKE) $(AM_MAKEFLAGS) gen_ecmult_static_pre_g$(EXEEXT)\n+\t./gen_ecmult_static_pre_g$(EXEEXT)\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n+$(gen_context_OBJECTS): src/gen_context.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n@@ -149,7 +154,7 @@ src/ecmult_static_context.h: $(gen_context_BIN)\n CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/ecmult_static_pre_g.h src/basic-config.h\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "7499f84d420652f5b5b1636d1276c3a5eff09fc1",
        "filename": "README.md",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -100,6 +100,18 @@ To create a HTML report with coloured and annotated source code:\n     $ mkdir -p coverage\n     $ gcovr --exclude 'src/bench*' --html --html-details -o coverage/coverage.html\n \n+Benchmark\n+------------\n+If configured with `--enable-benchmark` (which is the default), binaries for benchmarking the libsecp256k1 functions will be present in the root directory after the build.\n+\n+To print the benchmark result to the command line:\n+\n+    $ ./bench_name\n+\n+To create a CSV file for the benchmark result :\n+\n+    $ ./bench_name | sed '2d;s/ \\{1,\\}//g' > bench_name.csv\n+\n Reporting a vulnerability\n ------------\n "
      },
      {
        "sha": "2ece0dfbb008fa2e79795ecd907bd5124697ce37",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 66,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -9,72 +9,6 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n AC_MSG_RESULT([$has_64bit_asm])\n ])\n \n-dnl\n-AC_DEFUN([SECP_OPENSSL_CHECK],[\n-  has_libcrypto=no\n-  m4_ifdef([PKG_CHECK_MODULES],[\n-    PKG_CHECK_MODULES([CRYPTO], [libcrypto], [has_libcrypto=yes],[has_libcrypto=no])\n-    if test x\"$has_libcrypto\" = x\"yes\"; then\n-      TEMP_LIBS=\"$LIBS\"\n-      LIBS=\"$LIBS $CRYPTO_LIBS\"\n-      AC_CHECK_LIB(crypto, main,[AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])],[has_libcrypto=no])\n-      LIBS=\"$TEMP_LIBS\"\n-    fi\n-  ])\n-  if test x$has_libcrypto = xno; then\n-    AC_CHECK_HEADER(openssl/crypto.h,[\n-      AC_CHECK_LIB(crypto, main,[\n-        has_libcrypto=yes\n-        CRYPTO_LIBS=-lcrypto\n-        AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])\n-      ])\n-    ])\n-    LIBS=\n-  fi\n-if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n-  AC_MSG_CHECKING(for EC functions in libcrypto)\n-  CPPFLAGS_TEMP=\"$CPPFLAGS\"\n-  CPPFLAGS=\"$CRYPTO_CPPFLAGS $CPPFLAGS\"\n-  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-    #include <openssl/bn.h>\n-    #include <openssl/ec.h>\n-    #include <openssl/ecdsa.h>\n-    #include <openssl/obj_mac.h>]],[[\n-    # if OPENSSL_VERSION_NUMBER < 0x10100000L\n-    void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {(void)sig->r; (void)sig->s;}\n-    # endif\n-\n-    unsigned int zero = 0;\n-    const unsigned char *zero_ptr = (unsigned char*)&zero;\n-    EC_KEY_free(EC_KEY_new_by_curve_name(NID_secp256k1));\n-    EC_KEY *eckey = EC_KEY_new();\n-    EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    EC_KEY_set_group(eckey, group);\n-    ECDSA_sign(0, NULL, 0, NULL, &zero, eckey);\n-    ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n-    o2i_ECPublicKey(&eckey, &zero_ptr, 0);\n-    d2i_ECPrivateKey(&eckey, &zero_ptr, 0);\n-    EC_KEY_check_key(eckey);\n-    EC_KEY_free(eckey);\n-    EC_GROUP_free(group);\n-    ECDSA_SIG *sig_openssl;\n-    sig_openssl = ECDSA_SIG_new();\n-    d2i_ECDSA_SIG(&sig_openssl, &zero_ptr, 0);\n-    i2d_ECDSA_SIG(sig_openssl, NULL);\n-    ECDSA_SIG_get0(sig_openssl, NULL, NULL);\n-    ECDSA_SIG_free(sig_openssl);\n-    const BIGNUM *bignum = BN_value_one();\n-    BN_is_negative(bignum);\n-    BN_num_bits(bignum);\n-    if (sizeof(zero) >= BN_num_bytes(bignum)) {\n-        BN_bn2bin(bignum, (unsigned char*)&zero);\n-    }\n-  ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n-  AC_MSG_RESULT([$has_openssl_ec])\n-  CPPFLAGS=\"$CPPFLAGS_TEMP\"\n-fi\n-])\n-\n AC_DEFUN([SECP_VALGRIND_CHECK],[\n if test x\"$has_valgrind\" != x\"yes\"; then\n   CPPFLAGS_TEMP=\"$CPPFLAGS\""
      },
      {
        "sha": "fdba12aa00b474a9043d8eb56eab1ff20bda6145",
        "filename": "ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/linux-debian.Dockerfile?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -14,7 +14,7 @@ RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n         gcc clang llvm libc6-dbg \\\n         g++ \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan6:i386 \\\n         gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n         gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n         gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\"
      },
      {
        "sha": "906f63cbb6e71e5abdcdb9e26e76a2928ca16060",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 38,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -43,13 +43,7 @@ case $host_os in\n          # These Homebrew packages may be keg-only, meaning that they won't be found\n          # in expected paths because they may conflict with system files. Ask\n          # Homebrew where each one is located, then adjust paths accordingly.\n-         openssl_prefix=`$BREW --prefix openssl 2>/dev/null`\n          valgrind_prefix=`$BREW --prefix valgrind 2>/dev/null`\n-         if test x$openssl_prefix != x; then\n-           PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n-           export PKG_CONFIG_PATH\n-           CRYPTO_CPPFLAGS=\"-I$openssl_prefix/include\"\n-         fi\n          if test x$valgrind_prefix != x; then\n            VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n@@ -121,11 +115,6 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n-AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n-    [enable_openssl_tests=$enableval],\n-    [enable_openssl_tests=auto])\n-\n AC_ARG_ENABLE(experimental,\n     AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n@@ -177,6 +166,8 @@ AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n [window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n [Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n [The table will store 2^(SIZE-1) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[A window size larger than 15 will require you delete the prebuilt ecmult_static_pre_g.h file so that it can be rebuilt.]\n+[For very large window sizes, use \"make -j 1\" to reduce memory use during compilation.]\n [\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n )],\n [req_ecmult_window=$withval], [req_ecmult_window=auto])\n@@ -327,32 +318,6 @@ case $set_ecmult_gen_precision in\n   ;;\n esac\n \n-if test x\"$use_tests\" = x\"yes\"; then\n-  SECP_OPENSSL_CHECK\n-  if test x\"$enable_openssl_tests\" != x\"no\" && test x\"$has_openssl_ec\" = x\"yes\"; then\n-      enable_openssl_tests=yes\n-      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS $CRYPTO_CPPFLAGS\"\n-      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-      case $host in\n-      *mingw*)\n-        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-        ;;\n-      esac\n-  else\n-    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n-      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n-    fi\n-    enable_openssl_tests=no\n-  fi\n-else\n-  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n-    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n-  fi\n-  enable_openssl_tests=no\n-fi\n-\n if test x\"$enable_valgrind\" = x\"yes\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n fi\n@@ -517,7 +482,6 @@ echo \"  with ecmult precomp     = $set_precomp\"\n echo \"  with external callbacks = $use_external_default_callbacks\"\n echo \"  with benchmarks         = $use_benchmark\"\n echo \"  with tests              = $use_tests\"\n-echo \"  with openssl tests      = $enable_openssl_tests\"\n echo \"  with coverage           = $enable_coverage\"\n echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\""
      },
      {
        "sha": "576953f49d4aaaf10165a5aa4715984fbe6154eb",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 48,
        "deletions": 49,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -226,7 +226,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n  *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx: an existing context to copy (cannot be NULL)\n+ *  Args:    ctx: an existing context to copy\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n@@ -247,7 +247,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Set a callback function to be called when an illegal argument is passed to\n  *  an API call. It will only trigger for violations that are mentioned\n@@ -278,11 +278,11 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  fails. In this case, the corresponding default handler will be called with\n  *  the data pointer argument set to NULL.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n  *              passed to the API, taking a message and an opaque pointer.\n  *              (NULL restores the default handler.)\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_error_callback.\n  */\n@@ -302,12 +302,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *  for that). After this callback returns, anything may happen, including\n  *  crashing.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n  *              taking a message and an opaque pointer (NULL restores the\n  *              default handler, see secp256k1_context_set_illegal_callback\n  *              for details).\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_illegal_callback.\n  */\n@@ -320,7 +320,7 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n /** Create a secp256k1 scratch space object.\n  *\n  *  Returns: a newly created scratch space.\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   size: amount of memory to be available as scratch space. Some extra\n  *              (<100 bytes) will be allocated for extra accounting.\n  */\n@@ -480,16 +480,16 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n  *  Returns: 1: correct signature\n  *           0: incorrect or unparseable signature\n  *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig:       the signature being verified (cannot be NULL)\n- *           msghash32: the 32-byte message hash being verified (cannot be NULL).\n+ *  In:      sig:       the signature being verified.\n+ *           msghash32: the 32-byte message hash being verified.\n  *                      The verifier must make sure to apply a cryptographic\n  *                      hash function to the message by itself and not accept an\n  *                      msghash32 value directly. Otherwise, it would be easy to\n  *                      create a \"valid\" signature without knowledge of the\n  *                      secret key. See also\n  *                      https://bitcoin.stackexchange.com/a/81116/35586 for more\n  *                      background on this topic.\n- *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)\n+ *           pubkey:    pointer to an initialized public key to verify with.\n  *\n  * To avoid accepting malleable signatures, only ECDSA signatures in lower-S\n  * form are accepted.\n@@ -515,8 +515,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n  *                or copy if the input was already normalized. (can be NULL if\n  *                you're only interested in whether the input was already\n  *                normalized).\n- *  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,\n- *                can be identical to sigout)\n+ *  In:   sigin:  a pointer to a signature to check/normalize (can be identical to sigout)\n  *\n  *  With ECDSA a third-party can forge a second distinct signature of the same\n  *  message, given a single initial signature, but without knowing the key. This\n@@ -568,12 +567,16 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL). If it is non-NULL and\n+ *                      secp256k1_nonce_function_default is used, then ndata must be a\n+ *                      pointer to 32-bytes of additional data.\n  *\n  * The created signature is always in lower-S form. See\n  * secp256k1_ecdsa_signature_normalize for more details.\n@@ -596,8 +599,8 @@ SECP256K1_API int secp256k1_ecdsa_sign(\n  *\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n- *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n     const secp256k1_context* ctx,\n@@ -606,11 +609,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n \n /** Compute the public key for a secret key.\n  *\n- *  Returns: 1: secret was valid, public key stores\n- *           0: secret was invalid, try again\n- *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:    pubkey:     pointer to the created public key (cannot be NULL)\n- *  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)\n+ *  Returns: 1: secret was valid, public key stores.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:    pointer to a context object, initialized for signing.\n+ *  Out:     pubkey: pointer to the created public key.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const secp256k1_context* ctx,\n@@ -626,8 +629,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n  *  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the\n  *                  secret key is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0 and\n- *                  seckey will be set to some unspecified value. (cannot be\n- *                  NULL)\n+ *                  seckey will be set to some unspecified value.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_negate(\n     const secp256k1_context* ctx,\n@@ -645,7 +647,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n  *\n  *  Returns: 1 always\n  *  Args:   ctx:        pointer to a context object\n- *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ *  In/Out: pubkey:     pointer to the public key to be negated.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n     const secp256k1_context* ctx,\n@@ -657,15 +659,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n  *  Returns: 0 if the arguments are invalid or the resulting secret key would be\n  *           invalid (only when the tweak is the negation of the secret key). 1\n  *           otherwise.\n- *  Args:    ctx:   pointer to a context object (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -686,14 +688,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n  *  Returns: 0 if the arguments are invalid or the resulting public key would be\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -704,15 +705,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n /** Tweak a secret key by multiplying it by a tweak.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx:    pointer to a context object (cannot be NULL).\n+ *  Args:   ctx:    pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -731,14 +732,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n /** Tweak a public key by multiplying it by a tweak value.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -749,7 +749,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n /** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated or nothing to randomize\n  *           0: error\n- *  Args:    ctx:       pointer to a context object (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object.\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n  *\n  * While secp256k1 code is written to be constant-time no matter what secret\n@@ -780,18 +780,17 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n  *\n  *  Returns: 1: the sum of the public keys is valid.\n  *           0: the sum of the public keys is not valid.\n- *  Args:   ctx:        pointer to a context object\n- *  Out:    out:        pointer to a public key object for placing the resulting public key\n- *                      (cannot be NULL)\n- *  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)\n- *          n:          the number of public keys to add together (must be at least 1)\n+ *  Args:   ctx:        pointer to a context object.\n+ *  Out:    out:        pointer to a public key object for placing the resulting public key.\n+ *  In:     ins:        pointer to array of pointers to public keys.\n+ *          n:          the number of public keys to add together (must be at least 1).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *out,\n     const secp256k1_pubkey * const * ins,\n     size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Compute a tagged hash as defined in BIP-340.\n  *"
      },
      {
        "sha": "c8577984b1a5ef35a8f3334e16e9865dd04e5ca1",
        "filename": "include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_ecdh.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -37,14 +37,15 @@ SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_func\n  *\n  *  Returns: 1: exponentiation was successful\n  *           0: scalar was invalid (zero or overflow) or hashfp returned 0\n- *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     output:     pointer to an array to be filled by hashfp\n- *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n- *                       initialized public key\n- *           seckey:     a 32-byte scalar with which to multiply the point\n- *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n- *                       (in which case, 32 bytes will be written to output)\n+ *  Args:    ctx:        pointer to a context object.\n+ *  Out:     output:     pointer to an array to be filled by hashfp.\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an initialized public key.\n+ *           seckey:     a 32-byte scalar with which to multiply the point.\n+ *           hashfp:     pointer to a hash function. If NULL,\n+ *                       secp256k1_ecdh_hash_function_sha256 is used\n+ *                       (in which case, 32 bytes will be written to output).\n  *           data:       arbitrary data pointer that is passed through to hashfp\n+ *                       (can be NULL for secp256k1_ecdh_hash_function_sha256).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,"
      },
      {
        "sha": "a64d561b60bff825a71892f959082aff9f6c5448",
        "filename": "include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 34,
        "deletions": 48,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_extrakeys.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -39,11 +39,10 @@ typedef struct {\n  *  Returns: 1 if the public key was fully valid.\n  *           0 if the public key could not be parsed or is invalid.\n  *\n- *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Args:   ctx: a secp256k1 context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n  *               parsed version of input. If not, it's set to an invalid value.\n- *               (cannot be NULL).\n- *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  In: input32: pointer to a serialized xonly_pubkey.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n     const secp256k1_context* ctx,\n@@ -55,11 +54,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n  *\n  *  Returns: 1 always.\n  *\n- *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n- *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n- *                 (cannot be NULL).\n- *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n- *                 initialized public key (cannot be NULL).\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an initialized public key.\n  */\n SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_context* ctx,\n@@ -87,13 +84,12 @@ SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n  *  Returns: 1 if the public key was successfully converted\n  *           0 otherwise\n  *\n- *  Args:         ctx: pointer to a context object (cannot be NULL)\n- *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n- *                     converted public key (cannot be NULL)\n- *          pk_parity: pointer to an integer that will be set to 1 if the point\n- *                     encoded by xonly_pubkey is the negation of the pubkey and\n- *                     set to 0 otherwise. (can be NULL)\n- *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key.\n+ *          pk_parity: Ignored if NULL. Otherwise, pointer to an integer that\n+ *                     will be set to 1 if the point encoded by xonly_pubkey is\n+ *                     the negation of the pubkey and set to 0 otherwise.\n+ *  In:        pubkey: pointer to a public key that is converted.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n     const secp256k1_context* ctx,\n@@ -113,18 +109,14 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n  *\n- *  Args:           ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n+ *  Args:           ctx: pointer to a context object initialized for verification.\n  *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n- *                       to an invalid value if this function returns 0 (cannot\n- *                       be NULL)\n+ *                       to an invalid value if this function returns 0.\n  *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n- *                       (cannot be NULL).\n  *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n  *                       according to secp256k1_ec_seckey_verify, this function\n  *                       returns 0. For uniformly random 32-byte arrays the\n- *                       chance of being invalid is negligible (around 1 in\n- *                       2^128) (cannot be NULL).\n+ *                       chance of being invalid is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -146,17 +138,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n  *\n  *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n  *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n- *  Args:            ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n- *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  Args:            ctx: pointer to a context object initialized for verification.\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey.\n  *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n  *                        is passed in as tweaked_pubkey32). This must match the\n  *                        pk_parity value that is returned when calling\n  *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n  *                        this function will fail.\n- *       internal_pubkey: pointer to an x-only public key object to apply the\n- *                        tweak to (cannot be NULL)\n- *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ *       internal_pubkey: pointer to an x-only public key object to apply the tweak to.\n+ *               tweak32: pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n     const secp256k1_context* ctx,\n@@ -170,9 +160,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_\n  *\n  *  Returns: 1: secret was valid, keypair is ready to use\n  *           0: secret was invalid, try again with a different secret\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out: keypair: pointer to the created keypair (cannot be NULL)\n- *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out: keypair: pointer to the created keypair.\n+ *  In:   seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n     const secp256k1_context* ctx,\n@@ -183,9 +173,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n /** Get the secret key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n- *  Out: seckey: pointer to a 32-byte buffer for the secret key (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n+ *  Out: seckey: pointer to a 32-byte buffer for the secret key.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n     const secp256k1_context* ctx,\n@@ -196,11 +186,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n /** Get the public key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n  *               the keypair public key. If not, it's set to an invalid value.\n- *               (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n     const secp256k1_context* ctx,\n@@ -214,14 +203,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n  *  secp256k1_xonly_pubkey_from_pubkey.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n  *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n  *               to the keypair public key after converting it to an\n- *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n- *               NULL).\n- *    pk_parity: pointer to an integer that will be set to the pk_parity\n- *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *               xonly_pubkey. If not, it's set to an invalid value.\n+ *    pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the\n+ *               pk_parity argument of secp256k1_xonly_pubkey_from_pubkey.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n     const secp256k1_context* ctx,\n@@ -241,15 +229,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n  *           invalid (only when the tweak is the negation of the keypair's\n  *           secret key). 1 otherwise.\n  *\n- *  Args:       ctx: pointer to a context object initialized for verification\n- *                   (cannot be NULL)\n+ *  Args:       ctx: pointer to a context object initialized for verification.\n  *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n- *                   an invalid value if this function returns 0 (cannot be\n- *                   NULL).\n+ *                   an invalid value if this function returns 0.\n  *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n  *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n  *                   uniformly random 32-byte arrays the chance of being invalid\n- *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                   is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "d2d9014f02881c5ac36164af5c63932d170c3c46",
        "filename": "include/secp256k1_preallocated.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_preallocated.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -55,7 +55,7 @@ SECP256K1_API size_t secp256k1_context_preallocated_size(\n  *  Returns: a newly created context object.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  *           flags:    which parts of the context to initialize.\n  *\n  *  See also secp256k1_context_randomize (in secp256k1.h)\n@@ -70,7 +70,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n  *  caller-provided memory.\n  *\n  *  Returns: the required size of the caller-provided memory block.\n- *  In:      ctx: an existing context to copy (cannot be NULL)\n+ *  In:      ctx: an existing context to copy.\n  */\n SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n     const secp256k1_context* ctx\n@@ -87,10 +87,10 @@ SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n  *  secp256k1_context_preallocated_create for details.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  Args:    ctx:      an existing context to copy.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n     const secp256k1_context* ctx,\n@@ -115,11 +115,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n  *\n  *  Args:   ctx: an existing context to destroy, constructed using\n  *               secp256k1_context_preallocated_create or\n- *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ *               secp256k1_context_preallocated_clone.\n  */\n SECP256K1_API void secp256k1_context_preallocated_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "0e2847db96c6925d0bf58c897b839870bfc677b5",
        "filename": "include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_recovery.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -43,8 +43,9 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_parse_compact(\n /** Convert a recoverable signature into a normal signature.\n  *\n  *  Returns: 1\n- *  Out: sig:    a pointer to a normal signature (cannot be NULL).\n- *  In:  sigin:  a pointer to a recoverable signature (cannot be NULL).\n+ *  Args: ctx:    a secp256k1 context object.\n+ *  Out:  sig:    a pointer to a normal signature.\n+ *  In:   sigin:  a pointer to a recoverable signature.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n     const secp256k1_context* ctx,\n@@ -55,10 +56,10 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n /** Serialize an ECDSA signature in compact format (64 bytes + recovery id).\n  *\n  *  Returns: 1\n- *  Args: ctx:      a secp256k1 context object\n- *  Out:  output64: a pointer to a 64-byte array of the compact signature (cannot be NULL)\n- *        recid:    a pointer to an integer to hold the recovery id (can be NULL).\n- *  In:   sig:      a pointer to an initialized signature object (cannot be NULL)\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  Out:  output64: a pointer to a 64-byte array of the compact signature.\n+ *        recid:    a pointer to an integer to hold the recovery id.\n+ *  In:   sig:      a pointer to an initialized signature object.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n     const secp256k1_context* ctx,\n@@ -71,12 +72,14 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL for secp256k1_nonce_function_default).\n  */\n SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n     const secp256k1_context* ctx,\n@@ -91,10 +94,10 @@ SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n  *\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  Args:    ctx:       pointer to a context object, initialized for verification (cannot be NULL)\n- *  Out:     pubkey:    pointer to the recovered public key (cannot be NULL)\n- *  In:      sig:       pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n- *           msghash32: the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for verification.\n+ *  Out:     pubkey:    pointer to the recovered public key.\n+ *  In:      sig:       pointer to initialized signature that supports pubkey recovery.\n+ *           msghash32: the 32-byte message hash assumed to be signed.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "e971ddc2aa8f2c4ccd40358595ec6018ff211cd8",
        "filename": "include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorrsig.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -106,12 +106,13 @@ typedef struct {\n  *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n- *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n- *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature.\n+ *  In:    msg32: the 32-byte message being signed.\n+ *       keypair: pointer to an initialized keypair.\n  *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n- *                this, it is only supplemental to security and can be NULL. See\n+ *                this, it is only supplemental to security and can be NULL. A\n+ *                NULL argument is treated the same as an all-zero one. See\n  *                BIP-340 \"Default Signing\" for a full explanation of this\n  *                argument and for guidance if randomness is expensive.\n  */\n@@ -120,7 +121,7 @@ SECP256K1_API int secp256k1_schnorrsig_sign(\n     unsigned char *sig64,\n     const unsigned char *msg32,\n     const secp256k1_keypair *keypair,\n-    unsigned char *aux_rand32\n+    const unsigned char *aux_rand32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Create a Schnorr signature with a more flexible API.\n@@ -150,7 +151,7 @@ SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n- *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *  In:    sig64: pointer to the 64-byte signature to verify.\n  *           msg: the message being verified. Can only be NULL if msglen is 0.\n  *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)"
      },
      {
        "sha": "68f95adec4be7970974107403d3aa8a435c25689",
        "filename": "sage/secp256k1_params.sage",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/sage/secp256k1_params.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/sage/secp256k1_params.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/secp256k1_params.sage?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -9,6 +9,9 @@ C = EllipticCurve([F(0), F(7)])\n \n \"\"\"Base point of secp256k1\"\"\"\n G = C.lift_x(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798)\n+if int(G[1]) & 1:\n+    # G.y is even\n+    G = -G\n \n \"\"\"Prime order of secp256k1\"\"\"\n N = C.order()"
      },
      {
        "sha": "65781a203ca183afecbdc829dbf21d7df380e747",
        "filename": "src/bench.h",
        "status": "modified",
        "additions": 24,
        "deletions": 11,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -24,7 +24,7 @@ static int64_t gettime_i64(void) {\n /* Format fixed point number. */\n void print_number(const int64_t x) {\n     int64_t x_abs, y;\n-    int c, i, rounding;\n+    int c, i, rounding, g; /* g = integer part size, c = fractional part size */\n     size_t ptr;\n     char buffer[30];\n \n@@ -56,21 +56,27 @@ void print_number(const int64_t x) {\n     /* Format and print the number. */\n     ptr = sizeof(buffer) - 1;\n     buffer[ptr] = 0;\n-    if (c != 0) {\n+    g = 0;\n+    if (c != 0) { /* non zero fractional part */\n         for (i = 0; i < c; ++i) {\n             buffer[--ptr] = '0' + (y % 10);\n             y /= 10;\n         }\n-        buffer[--ptr] = '.';\n+    } else if (c == 0) { /* fractional part is 0 */\n+        buffer[--ptr] = '0'; \n     }\n+    buffer[--ptr] = '.';\n     do {\n         buffer[--ptr] = '0' + (y % 10);\n         y /= 10;\n+        g++;\n     } while (y != 0);\n     if (x < 0) {\n         buffer[--ptr] = '-';\n+        g++;\n     }\n-    printf(\"%s\", &buffer[ptr]);\n+    printf(\"%5.*s\", g, &buffer[ptr]); /* Prints integer part */\n+    printf(\"%-*s\", FP_EXP, &buffer[ptr + g]); /* Prints fractional part */\n }\n \n void run_benchmark(char *name, void (*benchmark)(void*, int), void (*setup)(void*), void (*teardown)(void*, int), void* data, int count, int iter) {\n@@ -97,21 +103,19 @@ void run_benchmark(char *name, void (*benchmark)(void*, int), void (*setup)(void\n         }\n         sum += total;\n     }\n-    printf(\"%s: min \", name);\n+    /* ',' is used as a column delimiter */\n+    printf(\"%-30s, \", name);\n     print_number(min * FP_MULT / iter);\n-    printf(\"us / avg \");\n+    printf(\"   , \");\n     print_number(((sum * FP_MULT) / count) / iter);\n-    printf(\"us / max \");\n+    printf(\"   , \");\n     print_number(max * FP_MULT / iter);\n-    printf(\"us\\n\");\n+    printf(\"\\n\");\n }\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n     argv++;\n-    if (argv == argm) {\n-        return 1;\n-    }\n     while (argv != NULL && argv != argm) {\n         if (strcmp(*argv, flag) == 0) {\n             return 1;\n@@ -130,4 +134,13 @@ int get_iters(int default_iters) {\n     }\n }\n \n+void print_output_table_header_row(void) {\n+    char* bench_str = \"Benchmark\";     /* left justified */\n+    char* min_str = \"    Min(us)    \"; /* center alignment */\n+    char* avg_str = \"    Avg(us)    \";\n+    char* max_str = \"    Max(us)    \";\n+    printf(\"%-30s,%-15s,%-15s,%-15s\\n\", bench_str, min_str, avg_str, max_str);\n+    printf(\"\\n\");\n+}\n+\n #endif /* SECP256K1_BENCH_H */"
      },
      {
        "sha": "b6d4ee294191088ed46c7369bc0fba3b968eb0c7",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -52,6 +52,8 @@ int main(void) {\n     /* create a context with no capabilities */\n     data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n \n+    print_output_table_header_row();\n+\n     run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);"
      },
      {
        "sha": "335d9104231207afb52be74ca636c4a4ecfa786b",
        "filename": "src/bench_ecmult.c",
        "status": "modified",
        "additions": 23,
        "deletions": 18,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -124,46 +124,46 @@ static void bench_ecmult_const_teardown(void* arg, int iters) {\n     bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n }\n \n-static void bench_ecmult_1(void* arg, int iters) {\n+static void bench_ecmult_1p(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int i;\n \n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n     }\n }\n \n-static void bench_ecmult_1_teardown(void* arg, int iters) {\n+static void bench_ecmult_1p_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n }\n \n-static void bench_ecmult_1g(void* arg, int iters) {\n+static void bench_ecmult_0p_g(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     secp256k1_scalar zero;\n     int i;\n \n     secp256k1_scalar_set_int(&zero, 0);\n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n-static void bench_ecmult_1g_teardown(void* arg, int iters) {\n+static void bench_ecmult_0p_g_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n }\n \n-static void bench_ecmult_2g(void* arg, int iters) {\n+static void bench_ecmult_1p_g(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int i;\n \n     for (i = 0; i < iters/2; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n-static void bench_ecmult_2g_teardown(void* arg, int iters) {\n+static void bench_ecmult_1p_g_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, &data->offset1, iters/2);\n }\n@@ -175,14 +175,14 @@ static void run_ecmult_bench(bench_data* data, int iters) {\n     sprintf(str, \"ecmult_const\");\n     run_benchmark(str, bench_ecmult_const, bench_ecmult_setup, bench_ecmult_const_teardown, data, 10, iters);\n     /* ecmult with non generator point */\n-    sprintf(str, \"ecmult 1\");\n-    run_benchmark(str, bench_ecmult_1, bench_ecmult_setup, bench_ecmult_1_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_1p\");\n+    run_benchmark(str, bench_ecmult_1p, bench_ecmult_setup, bench_ecmult_1p_teardown, data, 10, iters);\n     /* ecmult with generator point */\n-    sprintf(str, \"ecmult 1g\");\n-    run_benchmark(str, bench_ecmult_1g, bench_ecmult_setup, bench_ecmult_1g_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_0p_g\");\n+    run_benchmark(str, bench_ecmult_0p_g, bench_ecmult_setup, bench_ecmult_0p_g_teardown, data, 10, iters);\n     /* ecmult with generator and non-generator point. The reported time is per point. */\n-    sprintf(str, \"ecmult 2g\");\n-    run_benchmark(str, bench_ecmult_2g, bench_ecmult_setup, bench_ecmult_2g_teardown, data, 10, 2*iters);\n+    sprintf(str, \"ecmult_1p_g\");\n+    run_benchmark(str, bench_ecmult_1p_g, bench_ecmult_setup, bench_ecmult_1p_g_teardown, data, 10, 2*iters);\n }\n \n static int bench_ecmult_multi_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n@@ -207,7 +207,7 @@ static void bench_ecmult_multi(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -266,11 +266,15 @@ static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_\n             secp256k1_scalar_add(&total, &total, &tmp);\n         }\n         secp256k1_scalar_negate(&total, &total);\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->expected_output[iter], NULL, &zero, &total);\n+        secp256k1_ecmult(&data->expected_output[iter], NULL, &zero, &total);\n     }\n \n     /* Run the benchmark. */\n-    sprintf(str, includes_g ? \"ecmult_multi %ig\" : \"ecmult_multi %i\", (int)count);\n+    if (includes_g) {\n+        sprintf(str, \"ecmult_multi_%ip_g\", (int)count - 1);\n+    } else {\n+        sprintf(str, \"ecmult_multi_%ip\", (int)count);\n+    }\n     run_benchmark(str, bench_ecmult_multi, bench_ecmult_multi_setup, bench_ecmult_multi_teardown, data, 10, count * iters);\n }\n \n@@ -333,6 +337,7 @@ int main(int argc, char **argv) {\n     secp256k1_ge_set_all_gej_var(data.pubkeys, data.pubkeys_gej, POINTS);\n \n \n+    print_output_table_header_row();\n     /* Initialize offset1 and offset2 */\n     hash_into_offset(&data, 0);\n     run_ecmult_bench(&data, iters);"
      },
      {
        "sha": "aed82161273d9e8cf82abd94acf38e023fca8f21",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 33,
        "deletions": 31,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -344,37 +344,39 @@ void bench_context_sign(void* arg, int iters) {\n int main(int argc, char **argv) {\n     bench_inv data;\n     int iters = get_iters(20000);\n-\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n+    int d = argc == 1; /* default */\n+    print_output_table_header_row();\n+\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n+    if (d || have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n \n     return 0;\n }"
      },
      {
        "sha": "3ccd86dd9bacd3317b0b2a9df1a357be5539c8a0",
        "filename": "src/bench_recover.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -55,6 +55,8 @@ int main(void) {\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n \n+    print_output_table_header_row();\n+\n     run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);"
      },
      {
        "sha": "e30735d8b9ee2e9ad5bfe9018409385c626afb1c",
        "filename": "src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_schnorrsig.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -86,6 +86,7 @@ int main(void) {\n         CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n     }\n \n+    print_output_table_header_row();\n     run_benchmark(\"schnorrsig_sign\", bench_schnorrsig_sign, NULL, NULL, (void *) &data, 10, iters);\n     run_benchmark(\"schnorrsig_verify\", bench_schnorrsig_verify, NULL, NULL, (void *) &data, 10, iters);\n "
      },
      {
        "sha": "c44f7b10ba84606ba72570003e78c61e0d545fa1",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -51,6 +51,8 @@ int main(void) {\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n+    print_output_table_header_row();\n+    \n     run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);"
      },
      {
        "sha": "d62e34b77ec16cc5f3fa186129fbe51295a44d50",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 1,
        "deletions": 45,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -11,13 +11,6 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-#include <openssl/bn.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n-#endif\n-\n-\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -26,9 +19,6 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n-#ifdef ENABLE_OPENSSL_TESTS\n-    EC_GROUP* ec_group;\n-#endif\n } bench_verify_data;\n \n static void bench_verify(void* arg, int iters) {\n@@ -50,36 +40,6 @@ static void bench_verify(void* arg, int iters) {\n     }\n }\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-static void bench_verify_openssl(void* arg, int iters) {\n-    int i;\n-    bench_verify_data* data = (bench_verify_data*)arg;\n-\n-    for (i = 0; i < iters; i++) {\n-        data->sig[data->siglen - 1] ^= (i & 0xFF);\n-        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n-        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n-        {\n-            EC_KEY *pkey = EC_KEY_new();\n-            const unsigned char *pubkey = &data->pubkey[0];\n-            int result;\n-\n-            CHECK(pkey != NULL);\n-            result = EC_KEY_set_group(pkey, data->ec_group);\n-            CHECK(result);\n-            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n-            CHECK(result);\n-            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n-            CHECK(result);\n-            EC_KEY_free(pkey);\n-        }\n-        data->sig[data->siglen - 1] ^= (i & 0xFF);\n-        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n-        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n-    }\n-}\n-#endif\n-\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -103,12 +63,8 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n+    print_output_table_header_row();\n     run_benchmark(\"ecdsa_verify\", bench_verify, NULL, NULL, &data, 10, iters);\n-#ifdef ENABLE_OPENSSL_TESTS\n-    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    run_benchmark(\"ecdsa_verify_openssl\", bench_verify_openssl, NULL, NULL, &data, 10, iters);\n-    EC_GROUP_free(data.ec_group);\n-#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "4441b08398499ba58c729334d1436764f2c71a1a",
        "filename": "src/ecdsa.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -15,7 +15,7 @@\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *r, secp256k1_scalar *s, const unsigned char *sig, size_t size);\n static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const secp256k1_scalar *r, const secp256k1_scalar *s);\n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid);\n \n #endif /* SECP256K1_ECDSA_H */"
      },
      {
        "sha": "a75a08833c1b8ddaf3ffcc4bf35f05679f27b29e",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -112,7 +112,7 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n     if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n         return 0;\n     }\n-    if (rlen == 0 || *sig + rlen > sigend) {\n+    if (rlen == 0 || rlen > (size_t)(sigend - *sig)) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -204,7 +204,7 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n #if !defined(EXHAUSTIVE_TEST_ORDER)\n@@ -221,7 +221,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, sigr);\n     secp256k1_gej_set_ge(&pubkeyj, pubkey);\n-    secp256k1_ecmult(ctx, &pr, &pubkeyj, &u2, &u1);\n+    secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }"
      },
      {
        "sha": "d54d44c997b6ab90782ad176517999d369be0038",
        "filename": "src/eckey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -18,8 +18,8 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge *elem, const unsigned char\n static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *pub, size_t *size, int compressed);\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak);\n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak);\n \n #endif /* SECP256K1_ECKEY_H */"
      },
      {
        "sha": "e0506d3e2b7e05f6adb0654b0971d8f5a29a3fa4",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -57,12 +57,12 @@ static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp25\n     return !secp256k1_scalar_is_zero(key);\n }\n \n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_gej pt;\n     secp256k1_scalar one;\n     secp256k1_gej_set_ge(&pt, key);\n     secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_ecmult(ctx, &pt, &pt, &one, tweak);\n+    secp256k1_ecmult(&pt, &pt, &one, tweak);\n \n     if (secp256k1_gej_is_infinity(&pt)) {\n         return 0;\n@@ -79,7 +79,7 @@ static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp25\n     return ret;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_scalar zero;\n     secp256k1_gej pt;\n     if (secp256k1_scalar_is_zero(tweak)) {\n@@ -88,7 +88,7 @@ static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx,\n \n     secp256k1_scalar_set_int(&zero, 0);\n     secp256k1_gej_set_ge(&pt, key);\n-    secp256k1_ecmult(ctx, &pt, &pt, tweak, &zero);\n+    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }"
      },
      {
        "sha": "b47d8f494a8034c4bd01baae4f3b183af8877fcb",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 19,
        "deletions": 13,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -11,20 +11,26 @@\n #include \"scalar.h\"\n #include \"scratch.h\"\n \n-typedef struct {\n-    /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_storage (*pre_g)[];    /* odd multiples of the generator */\n-    secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n-} secp256k1_ecmult_context;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n+#endif\n+\n+/** The number of entries a table with precomputed multiples needs to have. */\n+#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))\n \n /** Double multiply: R = na*A + ng*G */\n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n \n@@ -39,6 +45,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "87ccc733d584882fd1abafa188d69212f872027c",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 29,
        "deletions": 256,
        "changes": 285,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -14,20 +14,18 @@\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n+#include \"ecmult_static_pre_g.h\"\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n /* We need to lower these values for exhaustive tests because\n  * the tables cannot have infinities in them (this breaks the\n  * affine-isomorphism stuff which tracks z-ratios) */\n #  if EXHAUSTIVE_TEST_ORDER > 128\n #    define WINDOW_A 5\n-#    define WINDOW_G 8\n #  elif EXHAUSTIVE_TEST_ORDER > 8\n #    define WINDOW_A 4\n-#    define WINDOW_G 4\n #  else\n #    define WINDOW_A 2\n-#    define WINDOW_G 2\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n@@ -41,31 +39,12 @@\n  *  Two tables of this size are used (due to the endomorphism\n  *  optimization).\n  */\n-#  define WINDOW_G ECMULT_WINDOW_SIZE\n-#endif\n-\n-/* Noone will ever need more than a window size of 24. The code might\n- * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n- * not tested.\n- *\n- * The following limitations are known, and there are probably more:\n- * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n- * because the size of the memory object that we allocate (in bytes)\n- * will not fit in a size_t.\n- * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n- * because certain expressions will overflow.\n- */\n-#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n-#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #define WNAF_BITS 128\n #define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n #define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n \n-/** The number of entries a table with precomputed multiples needs to have. */\n-#define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n-\n /* The number of objects allocated on the scratch space for ecmult_multi algorithms */\n #define PIPPENGER_SCRATCH_OBJECTS 6\n #define STRAUSS_SCRATCH_OBJECTS 6\n@@ -119,18 +98,12 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n \n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n- *  There are two versions of this function:\n- *  - secp256k1_ecmult_odd_multiples_table_globalz_windowa which brings its\n- *    resulting point set to a single constant Z denominator, stores the X and Y\n- *    coordinates as ge_storage points in pre, and stores the global Z in rz.\n- *    It only operates on tables sized for WINDOW_A wnaf multiples.\n- *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n- *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size.\n+ *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n+ *  coordinates as ge_storage points in pre, and stores the global Z in rz.\n+ *  It only operates on tables sized for WINDOW_A wnaf multiples.\n  *\n- *  To compute a*P + b*G, we compute a table for P using the first function,\n- *  and for G using the second (which requires an inverse, but it only needs to\n- *  happen once).\n+ *  To compute a*P + b*G, we compute a table for P using this function,\n+ *  and use the precomputed table in <ecmult_static_pre_g.h> for G.\n  */\n static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -142,137 +115,6 @@ static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *p\n     secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A), pre, globalz, prej, zr);\n }\n \n-static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp256k1_ge_storage *pre, const secp256k1_gej *a) {\n-    secp256k1_gej d;\n-    secp256k1_ge d_ge, p_ge;\n-    secp256k1_gej pj;\n-    secp256k1_fe zi;\n-    secp256k1_fe zr;\n-    secp256k1_fe dx_over_dz_squared;\n-    int i;\n-\n-    VERIFY_CHECK(!a->infinity);\n-\n-    secp256k1_gej_double_var(&d, a, NULL);\n-\n-    /* First, we perform all the additions in an isomorphic curve obtained by multiplying\n-     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use\n-     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store\n-     * the resulting y-coordinate and the z-ratio, since we only have enough memory to\n-     * store two field elements. These are sufficient to efficiently undo the isomorphism\n-     * and recompute all the `x`s.\n-     */\n-    d_ge.x = d.x;\n-    d_ge.y = d.y;\n-    d_ge.infinity = 0;\n-\n-    secp256k1_ge_set_gej_zinv(&p_ge, a, &d.z);\n-    pj.x = p_ge.x;\n-    pj.y = p_ge.y;\n-    pj.z = a->z;\n-    pj.infinity = 0;\n-\n-    for (i = 0; i < (n - 1); i++) {\n-        secp256k1_fe_normalize_var(&pj.y);\n-        secp256k1_fe_to_storage(&pre[i].y, &pj.y);\n-        secp256k1_gej_add_ge_var(&pj, &pj, &d_ge, &zr);\n-        secp256k1_fe_normalize_var(&zr);\n-        secp256k1_fe_to_storage(&pre[i].x, &zr);\n-    }\n-\n-    /* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */\n-    secp256k1_fe_mul(&zi, &pj.z, &d.z);\n-    secp256k1_fe_inv_var(&zi, &zi);\n-\n-    /* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so\n-     * that we can combine it with the saved z-ratios to compute the other zs\n-     * without any more inversions. */\n-    secp256k1_ge_set_gej_zinv(&p_ge, &pj, &zi);\n-    secp256k1_ge_to_storage(&pre[n - 1], &p_ge);\n-\n-    /* Compute the actual x-coordinate of D, which will be needed below. */\n-    secp256k1_fe_mul(&d.z, &zi, &pj.z);  /* d.z = 1/d.z */\n-    secp256k1_fe_sqr(&dx_over_dz_squared, &d.z);\n-    secp256k1_fe_mul(&dx_over_dz_squared, &dx_over_dz_squared, &d.x);\n-\n-    /* Going into the second loop, we have set `pre[n-1]` to its final affine\n-     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We\n-     * have `zi = (p.z * d.z)^-1`, where\n-     *\n-     *     `p.z` is the z-coordinate of the point on the isomorphic curve\n-     *           which was ultimately assigned to `pre[n-1]`.\n-     *     `d.z` is the multiplier that must be applied to all z-coordinates\n-     *           to move from our isomorphic curve back to secp256k1; so the\n-     *           product `p.z * d.z` is the z-coordinate of the secp256k1\n-     *           point assigned to `pre[n-1]`.\n-     *\n-     * All subsequent inverse-z-coordinates can be obtained by multiplying this\n-     * factor by successive z-ratios, which is much more efficient than directly\n-     * computing each one.\n-     *\n-     * Importantly, these inverse-zs will be coordinates of points on secp256k1,\n-     * while our other stored values come from computations on the isomorphic\n-     * curve. So in the below loop, we will take care not to actually use `zi`\n-     * or any derived values until we're back on secp256k1.\n-     */\n-    i = n - 1;\n-    while (i > 0) {\n-        secp256k1_fe zi2, zi3;\n-        const secp256k1_fe *rzr;\n-        i--;\n-\n-        secp256k1_ge_from_storage(&p_ge, &pre[i]);\n-\n-        /* For each remaining point, we extract the z-ratio from the stored\n-         * x-coordinate, compute its z^-1 from that, and compute the full\n-         * point from that. */\n-        rzr = &p_ge.x;\n-        secp256k1_fe_mul(&zi, &zi, rzr);\n-        secp256k1_fe_sqr(&zi2, &zi);\n-        secp256k1_fe_mul(&zi3, &zi2, &zi);\n-        /* To compute the actual x-coordinate, we use the stored z ratio and\n-         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`\n-         * in the loop above, as well as the inverse of the square of its\n-         * z-coordinate. We store the latter in the `zi2` variable, which is\n-         * computed iteratively starting from the overall Z inverse then\n-         * multiplying by each z-ratio in turn.\n-         *\n-         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`\n-         * from the inside of the above `gej_add_ge_var` call. This satisfies\n-         *\n-         *    rzr = d_x * z^2 - x * d_z^2\n-         *\n-         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`\n-         * are Jacobian coordinates of our desired point -- except both are on\n-         * the isomorphic curve that we were using when we called `gej_add_ge_var`.\n-         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or\n-         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes\n-         *\n-         *    rzr = d_x * z^2 / d_z^2 - x\n-         *\n-         * (The left-hand-side, being a ratio of z-coordinates, is unaffected\n-         * by the isomorphism.)\n-         *\n-         * Rearranging to solve for `x`, we have\n-         *\n-         *     x = d_x * z^2 / d_z^2 - rzr\n-         *\n-         * But what we actually want is the affine coordinate `X = x/z^2`,\n-         * which will satisfy\n-         *\n-         *     X = d_x / d_z^2 - rzr / z^2\n-         *       = dx_over_dz_squared - rzr * zi2\n-         */\n-        secp256k1_fe_mul(&p_ge.x, rzr, &zi2);\n-        secp256k1_fe_negate(&p_ge.x, &p_ge.x, 1);\n-        secp256k1_fe_add(&p_ge.x, &dx_over_dz_squared);\n-        /* y is stored_y/z^3, as we expect */\n-        secp256k1_fe_mul(&p_ge.y, &p_ge.y, &zi3);\n-        /* Store */\n-        secp256k1_ge_to_storage(&pre[i], &p_ge);\n-    }\n-}\n-\n /** The following two macro retrieves a particular odd multiple from a table\n  *  of precomputed multiples. */\n #define ECMULT_TABLE_GET_GE(r,pre,n,w) do { \\\n@@ -299,74 +141,6 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n-    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    ;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n-    ctx->pre_g = NULL;\n-    ctx->pre_g_128 = NULL;\n-}\n-\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n-    secp256k1_gej gj;\n-    void* const base = *prealloc;\n-    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-\n-    if (ctx->pre_g != NULL) {\n-        return;\n-    }\n-\n-    /* get the generator */\n-    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n-\n-    {\n-        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-    }\n-\n-    /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n-\n-    {\n-        secp256k1_gej g_128j;\n-        int i;\n-\n-        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-\n-        /* calculate 2^128*generator */\n-        g_128j = gj;\n-        for (i = 0; i < 128; i++) {\n-            secp256k1_gej_double_var(&g_128j, &g_128j, NULL);\n-        }\n-        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n-    }\n-}\n-\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n-    if (src->pre_g != NULL) {\n-        /* We cast to void* first to suppress a -Wcast-align warning. */\n-        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n-    }\n-    if (src->pre_g_128 != NULL) {\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n-    }\n-}\n-\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx) {\n-    return ctx->pre_g != NULL;\n-}\n-\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    secp256k1_ecmult_context_init(ctx);\n-}\n-\n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n  *  with the following guarantees:\n  *  - each wnaf[i] is either 0, or an odd integer between -(1<<(w-1) - 1) and (1<<(w-1) - 1)\n@@ -443,7 +217,7 @@ struct secp256k1_strauss_state {\n     struct secp256k1_strauss_point_state* ps;\n };\n \n-static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult_strauss_wnaf(const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n     /* Splitted G factors. */\n@@ -544,11 +318,11 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             }\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n     }\n@@ -558,7 +332,7 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n     }\n }\n \n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -571,15 +345,15 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     state.pre_a = pre_a;\n     state.pre_a_lam = pre_a_lam;\n     state.ps = ps;\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, 1, a, na, ng);\n }\n \n static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n@@ -612,14 +386,14 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, n_points, points, scalars, inp_g_sc);\n     secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n@@ -866,7 +640,7 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n@@ -881,7 +655,6 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n     int i, j;\n     int bucket_window;\n \n-    (void)ctx;\n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n@@ -941,8 +714,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n@@ -986,7 +759,7 @@ static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_cal\n \n /* Computes ecmult_multi by simply multiplying and adding each point. Does not\n  * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n+static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n     size_t point_idx;\n     secp256k1_scalar szero;\n     secp256k1_gej tmpj;\n@@ -995,7 +768,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n     secp256k1_gej_set_infinity(r);\n     secp256k1_gej_set_infinity(&tmpj);\n     /* r = inp_g_sc*G */\n-    secp256k1_ecmult(ctx, r, &tmpj, &szero, inp_g_sc);\n+    secp256k1_ecmult(r, &tmpj, &szero, inp_g_sc);\n     for (point_idx = 0; point_idx < n_points; point_idx++) {\n         secp256k1_ge point;\n         secp256k1_gej pointj;\n@@ -1005,7 +778,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n         }\n         /* r += scalar*point */\n         secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(ctx, &tmpj, &pointj, &scalar, NULL);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n     return 1;\n@@ -1031,11 +804,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1045,33 +818,33 @@ static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback,\n     } else if (n == 0) {\n         secp256k1_scalar szero;\n         secp256k1_scalar_set_int(&szero, 0);\n-        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        secp256k1_ecmult(r, r, &szero, inp_g_sc);\n         return 1;\n     }\n     if (scratch == NULL) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n \n     /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n      * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n      * As a first step check if there's enough space for Pippenger's algo (which requires less space\n      * than Strauss' algo) and if not, use the simple algorithm. */\n     if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n         if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n-            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+            return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "9072fb268860c959bbde3b0074d6451e39db7445",
        "filename": "src/ecmult_static_pre_g.h",
        "status": "added",
        "additions": 16611,
        "deletions": 0,
        "changes": 16611,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecmult_static_pre_g.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/ecmult_static_pre_g.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_static_pre_g.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80"
      },
      {
        "sha": "55679a2fc130aa2643a70f9dd9deab47c9aa9ae0",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -14,8 +14,8 @@\n  *  - Each field element can be normalized or not.\n  *  - Each field element has a magnitude, which represents how far away\n  *    its representation is away from normalization. Normalized elements\n- *    always have a magnitude of 1, but a magnitude of 1 doesn't imply\n- *    normality.\n+ *    always have a magnitude of 0 or 1, but a magnitude of 1 doesn't\n+ *    imply normality.\n  */\n \n #if defined HAVE_CONFIG_H\n@@ -50,7 +50,9 @@ static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r);\n  *  without constant-time guarantee. */\n static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r);\n \n-/** Set a field element equal to a small integer. Resulting field element is normalized. */\n+/** Set a field element equal to a small (not greater than 0x7FFF), non-negative integer.\n+ *  Resulting field element is normalized; it has magnitude 0 if a == 0, and magnitude 1 otherwise.\n+ */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n \n /** Sets a field element equal to zero, initializing all fields. */"
      },
      {
        "sha": "4363e727e76e8d1ec2a9d96119c1b132f38f244f",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -264,10 +264,11 @@ static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n }\n \n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe *r, int a) {\n+    VERIFY_CHECK(0 <= a && a <= 0x7FFF);\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n #ifdef VERIFY\n-    r->magnitude = 1;\n+    r->magnitude = (a != 0);\n     r->normalized = 1;\n     secp256k1_fe_verify(r);\n #endif\n@@ -1162,6 +1163,7 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 1;\n+    secp256k1_fe_verify(r);\n #endif\n }\n "
      },
      {
        "sha": "b56bdd13534c4371fba432dc734ef3bc4787e008",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -227,10 +227,11 @@ static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n }\n \n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe *r, int a) {\n+    VERIFY_CHECK(0 <= a && a <= 0x7FFF);\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n #ifdef VERIFY\n-    r->magnitude = 1;\n+    r->magnitude = (a != 0);\n     r->normalized = 1;\n     secp256k1_fe_verify(r);\n #endif\n@@ -496,6 +497,7 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 1;\n+    secp256k1_fe_verify(r);\n #endif\n }\n "
      },
      {
        "sha": "0ed6118cc9b43b8df53003d9c3d4bbcc238c36f9",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 23,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -49,23 +49,23 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     c  = (uint128_t)a4 * b[4];\n     VERIFY_BITS(c, 112);\n     /* [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n-    d += (c & M) * R; c >>= 52;\n+    d += (uint128_t)R * (uint64_t)c; c >>= 64;\n     VERIFY_BITS(d, 115);\n-    VERIFY_BITS(c, 60);\n-    /* [c 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    VERIFY_BITS(c, 48);\n+    /* [(c<<12) 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n     t3 = d & M; d >>= 52;\n     VERIFY_BITS(t3, 52);\n     VERIFY_BITS(d, 63);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n \n     d += (uint128_t)a0 * b[4]\n        + (uint128_t)a1 * b[3]\n        + (uint128_t)a2 * b[2]\n        + (uint128_t)a3 * b[1]\n        + (uint128_t)a4 * b[0];\n     VERIFY_BITS(d, 115);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n-    d += c * R;\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n+    d += (uint128_t)(R << 12) * (uint64_t)c;\n     VERIFY_BITS(d, 116);\n     /* [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n     t4 = d & M; d >>= 52;\n@@ -129,17 +129,16 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n        + (uint128_t)a4 * b[3];\n     VERIFY_BITS(d, 114);\n     /* [d 0 0 t4 t3 c t1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c += (d & M) * R; d >>= 52;\n+    c += (uint128_t)R * (uint64_t)d; d >>= 64;\n     VERIFY_BITS(c, 115);\n-    VERIFY_BITS(d, 62);\n-    /* [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    VERIFY_BITS(d, 50);\n+    /* [(d<<12) 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    /* [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[2] = c & M; c >>= 52;\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n-    /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;\n+    /* [(d<<12) 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    c   += (uint128_t)(R << 12) * (uint64_t)d + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -178,22 +177,22 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     c  = (uint128_t)a4 * a4;\n     VERIFY_BITS(c, 112);\n     /* [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n-    d += (c & M) * R; c >>= 52;\n+    d += (uint128_t)R * (uint64_t)c; c >>= 64;\n     VERIFY_BITS(d, 115);\n-    VERIFY_BITS(c, 60);\n-    /* [c 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    VERIFY_BITS(c, 48);\n+    /* [(c<<12) 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n     t3 = d & M; d >>= 52;\n     VERIFY_BITS(t3, 52);\n     VERIFY_BITS(d, 63);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n \n     a4 *= 2;\n     d += (uint128_t)a0 * a4\n        + (uint128_t)(a1*2) * a3\n        + (uint128_t)a2 * a2;\n     VERIFY_BITS(d, 115);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n-    d += c * R;\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n+    d += (uint128_t)(R << 12) * (uint64_t)c;\n     VERIFY_BITS(d, 116);\n     /* [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n     t4 = d & M; d >>= 52;\n@@ -252,16 +251,16 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     d += (uint128_t)a3 * a4;\n     VERIFY_BITS(d, 114);\n     /* [d 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c += (d & M) * R; d >>= 52;\n+    c += (uint128_t)R * (uint64_t)d; d >>= 64;\n     VERIFY_BITS(c, 115);\n-    VERIFY_BITS(d, 62);\n-    /* [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    VERIFY_BITS(d, 50);\n+    /* [(d<<12) 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[2] = c & M; c >>= 52;\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n-    /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    /* [(d<<12) 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;\n+    c   += (uint128_t)(R << 12) * (uint64_t)d + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "af40d13f9c6a1dd76cf0a249a7ab4f82e75e45f6",
        "filename": "src/gen_ecmult_static_pre_g.c",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/gen_ecmult_static_pre_g.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/gen_ecmult_static_pre_g.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_ecmult_static_pre_g.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -0,0 +1,137 @@\n+/*****************************************************************************************************\n+ * Copyright (c) 2013, 2014, 2017, 2021 Pieter Wuille, Andrew Poelstra, Jonas Nick, Russell O'Connor *\n+ * Distributed under the MIT software license, see the accompanying                                  *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.                              *\n+ *****************************************************************************************************/\n+\n+#include <inttypes.h>\n+#include <stdio.h>\n+\n+/* Autotools creates libsecp256k1-config.h, of which ECMULT_WINDOW_SIZE is needed.\n+   ifndef guard so downstream users can define their own if they do not use autotools. */\n+#if !defined(ECMULT_WINDOW_SIZE)\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n+#include \"assumptions.h\"\n+#include \"util.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"ecmult.h\"\n+\n+void print_table(FILE *fp, const char *name, int window_g, const secp256k1_gej *gen, int with_conditionals) {\n+    static secp256k1_gej gj;\n+    static secp256k1_ge ge, dgen;\n+    static secp256k1_ge_storage ges;\n+    int j;\n+    int i;\n+\n+    gj = *gen;\n+    secp256k1_ge_set_gej_var(&ge, &gj);\n+    secp256k1_ge_to_storage(&ges, &ge);\n+\n+    fprintf(fp, \"static const secp256k1_ge_storage %s[ECMULT_TABLE_SIZE(WINDOW_G)] = {\\n\", name);\n+    fprintf(fp, \" S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                  \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                SECP256K1_GE_STORAGE_CONST_GET(ges));\n+\n+    secp256k1_gej_double_var(&gj, gen, NULL);\n+    secp256k1_ge_set_gej_var(&dgen, &gj);\n+\n+    j = 1;\n+    for(i = 3; i <= window_g; ++i) {\n+        if (with_conditionals) {\n+            fprintf(fp, \"#if ECMULT_TABLE_SIZE(WINDOW_G) > %ld\\n\", ECMULT_TABLE_SIZE(i-1));\n+        }\n+        for(;j < ECMULT_TABLE_SIZE(i); ++j) {\n+            secp256k1_gej_set_ge(&gj, &ge);\n+            secp256k1_gej_add_ge_var(&gj, &gj, &dgen, NULL);\n+            secp256k1_ge_set_gej_var(&ge, &gj);\n+            secp256k1_ge_to_storage(&ges, &ge);\n+\n+            fprintf(fp, \",S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                          \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                        SECP256K1_GE_STORAGE_CONST_GET(ges));\n+        }\n+        if (with_conditionals) {\n+            fprintf(fp, \"#endif\\n\");\n+        }\n+    }\n+    fprintf(fp, \"};\\n\");\n+}\n+\n+void print_two_tables(FILE *fp, int window_g, const secp256k1_ge *g, int with_conditionals) {\n+    secp256k1_gej gj;\n+    int i;\n+\n+    secp256k1_gej_set_ge(&gj, g);\n+    print_table(fp, \"secp256k1_pre_g\", window_g, &gj, with_conditionals);\n+    for (i = 0; i < 128; ++i) {\n+        secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    print_table(fp, \"secp256k1_pre_g_128\", window_g, &gj, with_conditionals);\n+}\n+\n+int main(void) {\n+    const secp256k1_ge g = SECP256K1_G;\n+    const secp256k1_ge g_13 = SECP256K1_G_ORDER_13;\n+    const secp256k1_ge g_199 = SECP256K1_G_ORDER_199;\n+    const int window_g_13 = 4;\n+    const int window_g_199 = 8;\n+    FILE* fp;\n+\n+    fp = fopen(\"src/ecmult_static_pre_g.h\",\"w\");\n+    if (fp == NULL) {\n+        fprintf(stderr, \"Could not open src/ecmult_static_pre_g.h for writing!\\n\");\n+        return -1;\n+    }\n+\n+    fprintf(fp, \"/* This file was automatically generated by gen_ecmult_static_pre_g. */\\n\");\n+    fprintf(fp, \"/* This file contains an array secp256k1_pre_g with odd multiples of the base point G and\\n\");\n+    fprintf(fp, \" * an array secp256k1_pre_g_128 with odd multiples of 2^128*G for accelerating the computation of a*P + b*G.\\n\");\n+    fprintf(fp, \" */\\n\");\n+    fprintf(fp, \"#ifndef SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#define SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#include \\\"group.h\\\"\\n\");\n+    fprintf(fp, \"#ifdef S\\n\");\n+    fprintf(fp, \"   #error macro identifier S already in use.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#define S(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \"\n+                \"SECP256K1_GE_STORAGE_CONST(0x##a##u,0x##b##u,0x##c##u,0x##d##u,0x##e##u,0x##f##u,0x##g##u,\"\n+                \"0x##h##u,0x##i##u,0x##j##u,0x##k##u,0x##l##u,0x##m##u,0x##n##u,0x##o##u,0x##p##u)\\n\");\n+    fprintf(fp, \"#if ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE) > %ld\\n\", ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE));\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_WINDOW_SIZE. Try deleting ecmult_static_pre_g.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#if defined(EXHAUSTIVE_TEST_ORDER)\\n\");\n+    fprintf(fp, \"#if EXHAUSTIVE_TEST_ORDER == 13\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_13);\n+\n+    print_two_tables(fp, window_g_13, &g_13, 0);\n+\n+    fprintf(fp, \"#elif EXHAUSTIVE_TEST_ORDER == 199\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_199);\n+\n+    print_two_tables(fp, window_g_199, &g_199, 0);\n+\n+    fprintf(fp, \"#else\\n\");\n+    fprintf(fp, \"   #error No known generator for the specified exhaustive test group order.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#else /* !defined(EXHAUSTIVE_TEST_ORDER) */\\n\");\n+    fprintf(fp, \"#define WINDOW_G ECMULT_WINDOW_SIZE\\n\");\n+\n+    print_two_tables(fp, ECMULT_WINDOW_SIZE, &g, 1);\n+\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#undef S\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fclose(fp);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "6fc58ea01599acdccf3ced5be62cc19030a861fa",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -10,6 +10,27 @@\n #include \"field.h\"\n #include \"group.h\"\n \n+#define SECP256K1_G_ORDER_13 SECP256K1_GE_CONST(\\\n+    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\\\n+    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\\\n+    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\\\n+    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\\\n+)\n+#define SECP256K1_G_ORDER_199 SECP256K1_GE_CONST(\\\n+    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\\\n+    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\\\n+    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\\\n+    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\\\n+)\n+/** Generator for secp256k1, value 'g' defined in\n+ *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n+ */\n+#define SECP256K1_G SECP256K1_GE_CONST(\\\n+    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\\\n+    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\\\n+    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\\\n+    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\\\n+)\n /* These exhaustive group test orders and generators are chosen such that:\n  * - The field size is equal to that of secp256k1, so field code is the same.\n  * - The curve equation is of the form y^2=x^3+B for some constant B.\n@@ -21,23 +42,15 @@\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 13\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\n-    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\n-    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\n-    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_13;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x3d3486b2, 0x159a9ca5, 0xc75638be, 0xb23a69bc,\n     0x946a45ab, 0x24801247, 0xb4ed2b8e, 0x26b6a417\n );\n #  elif EXHAUSTIVE_TEST_ORDER == 199\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\n-    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\n-    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\n-    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_199;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x2cca28fa, 0xfc614b80, 0x2a3db42b, 0x00ba00b1,\n     0xbea8d943, 0xdace9ab2, 0x9536daea, 0x0074defb\n@@ -46,15 +59,7 @@ static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n #else\n-/** Generator for secp256k1, value 'g' defined in\n- *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n- */\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\n-    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\n-    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\n-    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G;\n \n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 7);\n #endif"
      },
      {
        "sha": "e1003052f4c623092457fe3f4e482c27486db441",
        "filename": "src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/main_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -120,12 +120,11 @@ int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pub\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output_pubkey != NULL);\n     memset(output_pubkey, 0, sizeof(*output_pubkey));\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_pubkey_save(output_pubkey, &pk);\n@@ -137,13 +136,12 @@ int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const u\n     unsigned char pk_expected32[32];\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweaked_pubkey32 != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&pk.x);\n@@ -260,7 +258,6 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     int ret;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(keypair != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n@@ -273,7 +270,7 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     }\n \n     ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n-    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32);\n \n     secp256k1_declassify(ctx, &ret, sizeof(ret));\n     if (ret) {"
      },
      {
        "sha": "dd53f9e12aedefaf3b43f654c98a0d52cde8ea05",
        "filename": "src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -197,19 +197,19 @@ void test_xonly_pubkey_tweak(void) {\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n     ecount = 0;\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* NULL internal_xonly_pk zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     /* NULL tweak zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n \n@@ -274,20 +274,20 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     /* invalid pk_parity value */\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     memset(tweak, 1, sizeof(tweak));\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n@@ -306,7 +306,7 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -479,15 +479,15 @@ void test_keypair_add(void) {\n     memset(overflows, 0xFF, 32);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n \n-    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, NULL, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* This does not set the keypair to zeroes */\n     CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) != 0);\n "
      },
      {
        "sha": "e7906eb62e0ea10248ad31e8b6faac9a51f7b117",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -40,7 +40,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n     ARG_CHECK(recid >= 0 && recid <= 3);\n@@ -60,7 +60,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n int secp256k1_ecdsa_recoverable_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, int *recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(recid != NULL);\n@@ -75,7 +75,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     secp256k1_scalar r, s;\n     int recid;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(sigin != NULL);\n \n@@ -84,7 +84,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n     unsigned char brx[32];\n     secp256k1_fe fx;\n     secp256k1_ge x;\n@@ -115,7 +115,7 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n     secp256k1_scalar_mul(&u1, &rn, message);\n     secp256k1_scalar_negate(&u1, &u1);\n     secp256k1_scalar_mul(&u2, &rn, sigs);\n-    secp256k1_ecmult(ctx, &qj, &xj, &u2, &u1);\n+    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n     secp256k1_ge_set_gej_var(pubkey, &qj);\n     return !secp256k1_gej_is_infinity(&qj);\n }\n@@ -140,15 +140,14 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     secp256k1_scalar m;\n     int recid;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n     VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msghash32, NULL);\n-    if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n+    if (secp256k1_ecdsa_sig_recover(&r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);\n         return 1;\n     } else {"
      },
      {
        "sha": "2fcd46d206abd8d3258bf300c2c3bc00cfd9779e",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -92,20 +92,20 @@ void test_ecdsa_recovery_api(void) {\n \n     /* Check bad contexts and NULLs for recovery */\n     ecount = 0;\n-    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     /* Check NULLs for conversion */\n     CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);"
      },
      {
        "sha": "94e3ee414d6d1a43045345e6f65da2c189e2cd68",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -65,6 +65,17 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         for (i = 0; i < 32; i++) {\n             masked_key[i] ^= key32[i];\n         }\n+    } else {\n+        /* Precomputed TaggedHash(\"BIP0340/aux\", 0x0000...00); */\n+        static const unsigned char ZERO_MASK[32] = {\n+              84, 241, 105, 207, 201, 226, 229, 114,\n+             116, 128,  68,  31, 144, 186,  37, 196,\n+             136, 244,  97, 199,  11,  94, 165, 220,\n+             170, 247, 175, 105, 39,  10, 165,  20\n+        };\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] = key32[i] ^ ZERO_MASK[i];\n+        }\n     }\n \n     /* Tag the hash with algo which is important to avoid nonce reuse across\n@@ -77,12 +88,8 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         secp256k1_sha256_initialize_tagged(&sha, algo, algolen);\n     }\n \n-    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n-    if (data != NULL) {\n-        secp256k1_sha256_write(&sha, masked_key, 32);\n-    } else {\n-        secp256k1_sha256_write(&sha, key32, 32);\n-    }\n+    /* Hash masked-key||pk||msg using the tagged hash as per the spec */\n+    secp256k1_sha256_write(&sha, masked_key, 32);\n     secp256k1_sha256_write(&sha, xonly_pk32, 32);\n     secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, nonce32);\n@@ -122,7 +129,7 @@ static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned c\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+static int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -185,8 +192,9 @@ int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned ch\n     return ret;\n }\n \n-int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, unsigned char *aux_rand32) {\n-    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, aux_rand32);\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32) {\n+    /* We cast away const from the passed aux_rand32 argument since we know the default nonce function does not modify it. */\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, (unsigned char*)aux_rand32);\n }\n \n int secp256k1_schnorrsig_sign_custom(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams) {\n@@ -216,7 +224,6 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     int overflow;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n     ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n@@ -241,7 +248,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);\n     secp256k1_gej_set_ge(&pkj, &pk);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+    secp256k1_ecmult(&rj, &pkj, &e, &s);\n \n     secp256k1_ge_set_gej_var(&r, &rj);\n     if (secp256k1_ge_is_infinity(&r)) {"
      },
      {
        "sha": "d301abee51b97354966d07572f11b4628db5051b",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 16,
        "deletions": 13,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -38,7 +38,7 @@ void run_nonce_function_bip340_tests(void) {\n     size_t algolen = sizeof(algo);\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n-    unsigned char nonce[32];\n+    unsigned char nonce[32], nonce_z[32];\n     unsigned char msg[32];\n     size_t msglen = sizeof(msg);\n     unsigned char key[32];\n@@ -107,8 +107,11 @@ void run_nonce_function_bip340_tests(void) {\n         CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n     }\n \n-    /* NULL aux_rand argument is allowed. */\n+    /* NULL aux_rand argument is allowed, and identical to passing all zero aux_rand. */\n+    memset(aux_rand, 0, 32);\n+    CHECK(nonce_function_bip340(nonce_z, msg, msglen, key, pk, algo, algolen, &aux_rand) == 1);\n     CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+    CHECK(secp256k1_memcmp_var(nonce_z, nonce, 32) == 0);\n }\n \n void test_schnorrsig_api(void) {\n@@ -193,22 +196,22 @@ void test_schnorrsig_api(void) {\n \n     ecount = 0;\n     CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n-    CHECK(ecount == 6);\n+    CHECK(ecount == 4);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -230,7 +233,7 @@ void test_schnorrsig_sha256_tagged(void) {\n \n /* Helper function for schnorrsig_bip_vectors\n  * Signs the message and checks that it's the same as expected_sig. */\n-void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n     unsigned char sig[64];\n     secp256k1_keypair keypair;\n     secp256k1_xonly_pubkey pk, pk_expected;"
      },
      {
        "sha": "9b1141376c338343f88fc3d990b98cf730c00136",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 7,
        "deletions": 22,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -73,15 +73,13 @@ static const secp256k1_callback default_error_callback = {\n };\n \n struct secp256k1_context_struct {\n-    secp256k1_ecmult_context ecmult_ctx;\n     secp256k1_ecmult_gen_context ecmult_gen_ctx;\n     secp256k1_callback illegal_callback;\n     secp256k1_callback error_callback;\n     int declassify;\n };\n \n static const secp256k1_context secp256k1_context_no_precomp_ = {\n-    { 0 },\n     { 0 },\n     { secp256k1_default_illegal_callback_fn, 0 },\n     { secp256k1_default_error_callback_fn, 0 },\n@@ -103,9 +101,6 @@ size_t secp256k1_context_preallocated_size(unsigned int flags) {\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -115,9 +110,6 @@ size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n     if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -139,17 +131,13 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n-    secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     /* Flags have been checked by secp256k1_context_preallocated_size. */\n     VERIFY_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_CONTEXT);\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n-    }\n     ret->declassify = !!(flags & SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY);\n \n     return (secp256k1_context*) ret;\n@@ -176,7 +164,6 @@ secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context*\n     ret = (secp256k1_context*)prealloc;\n     memcpy(ret, ctx, prealloc_size);\n     secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n-    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n@@ -194,7 +181,6 @@ secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n     ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n-        secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n     }\n }\n@@ -458,7 +444,6 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(pubkey != NULL);\n@@ -467,7 +452,7 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_ecdsa_signature_load(ctx, &r, &s, sig);\n     return (!secp256k1_scalar_is_high(&s) &&\n             secp256k1_pubkey_load(ctx, &q, pubkey) &&\n-            secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &r, &s, &q, &m));\n+            secp256k1_ecdsa_sig_verify(&r, &s, &q, &m));\n }\n \n static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len) {\n@@ -685,24 +670,23 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak32);\n }\n \n-static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak32) {\n+static int secp256k1_ec_pubkey_tweak_add_helper(secp256k1_ge *p, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n     secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n-    return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n+    return !overflow && secp256k1_eckey_pubkey_tweak_add(p, &term);\n }\n \n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n-    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak32);\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&p, tweak32);\n     if (ret) {\n         secp256k1_pubkey_save(pubkey, &p);\n     }\n@@ -740,15 +724,14 @@ int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n     if (ret) {\n-        if (secp256k1_eckey_pubkey_tweak_mul(&ctx->ecmult_ctx, &p, &factor)) {\n+        if (secp256k1_eckey_pubkey_tweak_mul(&p, &factor)) {\n             secp256k1_pubkey_save(pubkey, &p);\n         } else {\n             ret = 0;\n@@ -771,6 +754,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej Qj;\n     secp256k1_ge Q;\n \n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubnonce != NULL);\n     memset(pubnonce, 0, sizeof(*pubnonce));\n     ARG_CHECK(n >= 1);\n@@ -779,6 +763,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej_set_infinity(&Qj);\n \n     for (i = 0; i < n; i++) {\n+        ARG_CHECK(pubnonces[i] != NULL);\n         secp256k1_pubkey_load(ctx, &Q, pubnonces[i]);\n         secp256k1_gej_add_ge(&Qj, &Qj, &Q);\n     }"
      },
      {
        "sha": "ebeef510f08e142ded0d1e3398c08835e03eb28d",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 154,
        "deletions": 200,
        "changes": 354,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -20,16 +20,6 @@\n #include \"testrand_impl.h\"\n #include \"util.h\"\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-#include <openssl/bn.h>\n-#include <openssl/ec.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n-# if OPENSSL_VERSION_NUMBER < 0x10100000L\n-void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {*pr = sig->r; *ps = sig->s;}\n-# endif\n-#endif\n-\n #include \"../contrib/lax_der_parsing.c\"\n #include \"../contrib/lax_der_privatekey_parsing.c\"\n \n@@ -273,22 +263,22 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sign(sign, &sig, ctmp, ctmp, NULL, NULL) == 1);\n     VG_CHECK(&sig, sizeof(sig));\n     CHECK(ecount2 == 10);\n-    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 0);\n-    CHECK(ecount2 == 11);\n+    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ecdsa_verify(vrfy, &sig, ctmp, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 12);\n+    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_tweak_add(vrfy, &pubkey, ctmp) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 13);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n@@ -298,9 +288,9 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_context_randomize(vrfy, NULL) == 1);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_context_randomize(sign, ctmp) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -314,8 +304,8 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sigr, &sigs, &key, &msg, &nonce, NULL));\n \n     /* try verifying */\n-    CHECK(secp256k1_ecdsa_sig_verify(&vrfy->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n-    CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n     if (use_prealloc) {\n@@ -3416,6 +3406,80 @@ void run_group_decompress(void) {\n \n /***** ECMULT TESTS *****/\n \n+void test_pre_g_table(const secp256k1_ge_storage * pre_g, size_t n) {\n+    /* Tests the pre_g / pre_g_128 tables for consistency.\n+     * For independent verification we take a \"geometric\" approach to verification.\n+     * We check that every entry is on-curve.\n+     * We check that for consecutive entries p and q, that p + gg - q = 0 by checking\n+     *  (1) p, gg, and -q are colinear.\n+     *  (2) p, gg, and -q are all distinct.\n+     * where gg is twice the generator, where the generator is the first table entry.\n+     *\n+     * Checking the table's generators are correct is done in run_ecmult_pre_g.\n+     */\n+    secp256k1_gej g2;\n+    secp256k1_ge p, q, gg;\n+    secp256k1_fe dpx, dpy, dqx, dqy;\n+    size_t i;\n+\n+    CHECK(0 < n);\n+\n+    secp256k1_ge_from_storage(&p, &pre_g[0]);\n+    CHECK(secp256k1_ge_is_valid_var(&p));\n+\n+    secp256k1_gej_set_ge(&g2, &p);\n+    secp256k1_gej_double_var(&g2, &g2, NULL);\n+    secp256k1_ge_set_gej_var(&gg, &g2);\n+    for (i = 1; i < n; ++i) {\n+        secp256k1_fe_negate(&dpx, &p.x, 1); secp256k1_fe_add(&dpx, &gg.x); secp256k1_fe_normalize_weak(&dpx);\n+        secp256k1_fe_negate(&dpy, &p.y, 1); secp256k1_fe_add(&dpy, &gg.y); secp256k1_fe_normalize_weak(&dpy);\n+        /* Check that p is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dpx) || !secp256k1_fe_normalizes_to_zero_var(&dpy));\n+\n+        secp256k1_ge_from_storage(&q, &pre_g[i]);\n+        CHECK(secp256k1_ge_is_valid_var(&q));\n+\n+        secp256k1_fe_negate(&dqx, &q.x, 1); secp256k1_fe_add(&dqx, &gg.x); secp256k1_fe_normalize_weak(&dqx);\n+        dqy = q.y; secp256k1_fe_add(&dqy, &gg.y); secp256k1_fe_normalize_weak(&dqy);\n+        /* Check that -q is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dqx) || !secp256k1_fe_normalizes_to_zero_var(&dqy));\n+\n+        /* Check that -q is not equal to p */\n+        CHECK(!secp256k1_fe_equal_var(&dpx, &dqx) || !secp256k1_fe_equal_var(&dpy, &dqy));\n+\n+        /* Check that p, -q and gg are colinear */\n+        secp256k1_fe_mul(&dpx, &dpx, &dqy);\n+        secp256k1_fe_mul(&dpy, &dpy, &dqx);\n+        CHECK(secp256k1_fe_equal_var(&dpx, &dpy));\n+\n+        p = q;\n+    }\n+}\n+\n+void run_ecmult_pre_g(void) {\n+    secp256k1_ge_storage gs;\n+    secp256k1_gej gj;\n+    secp256k1_ge g;\n+    size_t i;\n+\n+    /* Check that the pre_g and pre_g_128 tables are consistent. */\n+    test_pre_g_table(secp256k1_pre_g, ECMULT_TABLE_SIZE(WINDOW_G));\n+    test_pre_g_table(secp256k1_pre_g_128, ECMULT_TABLE_SIZE(WINDOW_G));\n+\n+    /* Check the first entry from the pre_g table. */\n+    secp256k1_ge_to_storage(&gs, &secp256k1_ge_const_g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g[0], sizeof(gs)) == 0);\n+\n+    /* Check the first entry from the pre_g_128 table. */\n+    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n+    for (i = 0; i < 128; ++i) {\n+      secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    secp256k1_ge_set_gej(&g, &gj);\n+    secp256k1_ge_to_storage(&gs, &g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g_128[0], sizeof(gs)) == 0);\n+}\n+\n void run_ecmult_chain(void) {\n     /* random starting point A (on the curve) */\n     secp256k1_gej a = SECP256K1_GEJ_CONST(\n@@ -3448,7 +3512,7 @@ void run_ecmult_chain(void) {\n     x = a;\n     for (i = 0; i < 200*count; i++) {\n         /* in each iteration, compute X = xn*X + gn*G; */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &x, &x, &xn, &gn);\n+        secp256k1_ecmult(&x, &x, &xn, &gn);\n         /* also compute ae and ge: the actual accumulated factors for A and G */\n         /* if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G) */\n         secp256k1_scalar_mul(&ae, &ae, &xn);\n@@ -3474,7 +3538,7 @@ void run_ecmult_chain(void) {\n         }\n     }\n     /* redo the computation, but directly with the resulting ae and ge coefficients: */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &x2, &a, &ae, &ge);\n+    secp256k1_ecmult(&x2, &a, &ae, &ge);\n     secp256k1_gej_neg(&x2, &x2);\n     secp256k1_gej_add_var(&x2, &x2, &x, NULL);\n     CHECK(secp256k1_gej_is_infinity(&x2));\n@@ -3492,8 +3556,8 @@ void test_point_times_order(const secp256k1_gej *point) {\n     size_t psize = 65;\n     random_scalar_order_test(&x);\n     secp256k1_scalar_negate(&nx, &x);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n+    secp256k1_ecmult(&res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n+    secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n     secp256k1_ge_set_gej(&res3, &res1);\n@@ -3503,13 +3567,13 @@ void test_point_times_order(const secp256k1_gej *point) {\n     psize = 65;\n     CHECK(secp256k1_eckey_pubkey_serialize(&res3, pub, &psize, 1) == 0);\n     /* check zero/one edge cases */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &zero);\n+    secp256k1_ecmult(&res1, point, &zero, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &one, &zero);\n+    secp256k1_ecmult(&res1, point, &one, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_gej(&res3, point);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &one);\n+    secp256k1_ecmult(&res1, point, &zero, &one);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_ge(&res3, &secp256k1_ge_const_g);\n }\n@@ -3568,9 +3632,9 @@ void test_ecmult_target(const secp256k1_scalar* target, int mode) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p2j, &n2);\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &ptj, target);\n     } else if (mode == 1) {\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p1j, &pj, &n1, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p2j, &pj, &n2, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptj, &pj, target, &zero);\n+        secp256k1_ecmult(&p1j, &pj, &n1, &zero);\n+        secp256k1_ecmult(&p2j, &pj, &n2, &zero);\n+        secp256k1_ecmult(&ptj, &pj, target, &zero);\n     } else {\n         secp256k1_ecmult_const(&p1j, &p, &n1, 256);\n         secp256k1_ecmult_const(&p2j, &p, &n2, 256);\n@@ -3753,7 +3817,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -3768,32 +3832,32 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         pt[1] = secp256k1_ge_const_g;\n \n         /* only G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        secp256k1_ecmult(&r2, &ptgj, &szero, &sc[0]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3810,7 +3874,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3820,7 +3884,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3833,7 +3897,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -3846,7 +3910,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3861,7 +3925,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -3879,8 +3943,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n         }\n \n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &r, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3902,8 +3966,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &p0j, &rs, &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3916,13 +3980,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -3946,8 +4010,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_scalar_set_int(&t1, (t1i + 1) / 2);\n                 secp256k1_scalar_cond_negate(&t1, t1i & 1);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t0p, &ptgj, &t0, &szero);\n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t1p, &ptgj, &t1, &szero);\n+                secp256k1_ecmult(&t0p, &ptgj, &t0, &szero);\n+                secp256k1_ecmult(&t1p, &ptgj, &t1, &szero);\n \n                 for(s0i = 0; s0i < TOP; s0i++) {\n                     for(s1i = 0; s1i < TOP; s1i++) {\n@@ -3966,8 +4030,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_mul(&tmp2, &t1, &sc[1]);\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n-                        secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        secp256k1_ecmult(&expected, &ptgj, &tmp1, &szero);\n+                        CHECK(ecmult_multi(&ctx->error_callback, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -3994,7 +4058,7 @@ void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n     scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    CHECK(!ecmult_multi(&ctx->error_callback, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n }\n \n@@ -4116,15 +4180,15 @@ void test_ecmult_multi_batching(void) {\n \n     /* Get random scalars and group elements and compute result */\n     random_scalar_order(&scG);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r2, &szero, &scG);\n+    secp256k1_ecmult(&r2, &r2, &szero, &scG);\n     for(i = 0; i < n_points; i++) {\n         secp256k1_ge ptg;\n         secp256k1_gej ptgj;\n         random_group_element_test(&ptg);\n         secp256k1_gej_set_ge(&ptgj, &ptg);\n         pt[i] = ptg;\n         random_scalar_order(&sc[i]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptgj, &ptgj, &sc[i], NULL);\n+        secp256k1_ecmult(&ptgj, &ptgj, &sc[i], NULL);\n         secp256k1_gej_add_var(&r2, &r2, &ptgj, NULL);\n     }\n     data.sc = sc;\n@@ -4134,7 +4198,7 @@ void test_ecmult_multi_batching(void) {\n     /* Test with empty scratch space. It should compute the correct result using\n      * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4143,7 +4207,7 @@ void test_ecmult_multi_batching(void) {\n      * ecmult_multi selects strauss which requires more memory. It should\n      * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4157,7 +4221,7 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n         secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -5262,22 +5326,24 @@ void test_ecdsa_sign_verify(void) {\n     secp256k1_scalar msg, key;\n     secp256k1_scalar sigr, sigs;\n     int getrec;\n-    /* Initialize recid to suppress a false positive -Wconditional-uninitialized in clang.\n-       VG_UNDEF ensures that valgrind will still treat the variable as uninitialized. */\n-    int recid = -1; VG_UNDEF(&recid, sizeof(recid));\n+    int recid;\n     random_scalar_order_test(&msg);\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n     getrec = secp256k1_testrand_bits(1);\n-    random_sign(&sigr, &sigs, &key, &msg, getrec?&recid:NULL);\n+    /* The specific way in which this conditional is written sidesteps a potential bug in clang.\n+       See the commit messages of the commit that introduced this comment for details. */\n     if (getrec) {\n+        random_sign(&sigr, &sigs, &key, &msg, &recid);\n         CHECK(recid >= 0 && recid < 4);\n+    } else {\n+        random_sign(&sigr, &sigs, &key, &msg, NULL);\n     }\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n }\n \n void run_ecdsa_sign_verify(void) {\n@@ -5609,14 +5675,6 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n-#ifdef ENABLE_OPENSSL_TESTS\n-    static const unsigned char max_scalar[32] = {\n-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n-        0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n-        0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n-    };\n-#endif\n \n     int ret = 0;\n \n@@ -5632,15 +5690,6 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     size_t len_der_lax = 2048;\n     int parsed_der_lax = 0, valid_der_lax = 0, roundtrips_der_lax = 0;\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-    ECDSA_SIG *sig_openssl;\n-    const BIGNUM *r = NULL, *s = NULL;\n-    const unsigned char *sigptr;\n-    unsigned char roundtrip_openssl[2048];\n-    int len_openssl = 2048;\n-    int parsed_openssl, valid_openssl = 0, roundtrips_openssl = 0;\n-#endif\n-\n     parsed_der = secp256k1_ecdsa_signature_parse_der(ctx, &sig_der, sig, siglen);\n     if (parsed_der) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_compact(ctx, compact_der, &sig_der)) << 0;\n@@ -5681,43 +5730,6 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n         ret |= (!parsed_der_lax) << 16;\n     }\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-    sig_openssl = ECDSA_SIG_new();\n-    sigptr = sig;\n-    parsed_openssl = (d2i_ECDSA_SIG(&sig_openssl, &sigptr, siglen) != NULL);\n-    if (parsed_openssl) {\n-        ECDSA_SIG_get0(sig_openssl, &r, &s);\n-        valid_openssl = !BN_is_negative(r) && !BN_is_negative(s) && BN_num_bits(r) > 0 && BN_num_bits(r) <= 256 && BN_num_bits(s) > 0 && BN_num_bits(s) <= 256;\n-        if (valid_openssl) {\n-            unsigned char tmp[32] = {0};\n-            BN_bn2bin(r, tmp + 32 - BN_num_bytes(r));\n-            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n-        }\n-        if (valid_openssl) {\n-            unsigned char tmp[32] = {0};\n-            BN_bn2bin(s, tmp + 32 - BN_num_bytes(s));\n-            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n-        }\n-    }\n-    len_openssl = i2d_ECDSA_SIG(sig_openssl, NULL);\n-    if (len_openssl <= 2048) {\n-        unsigned char *ptr = roundtrip_openssl;\n-        CHECK(i2d_ECDSA_SIG(sig_openssl, &ptr) == len_openssl);\n-        roundtrips_openssl = valid_openssl && ((size_t)len_openssl == siglen) && (secp256k1_memcmp_var(roundtrip_openssl, sig, siglen) == 0);\n-    } else {\n-        len_openssl = 0;\n-    }\n-    ECDSA_SIG_free(sig_openssl);\n-\n-    ret |= (parsed_der && !parsed_openssl) << 4;\n-    ret |= (valid_der && !valid_openssl) << 5;\n-    ret |= (roundtrips_openssl && !parsed_der) << 6;\n-    ret |= (roundtrips_der != roundtrips_openssl) << 7;\n-    if (roundtrips_openssl) {\n-        ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= ((len_der != (size_t)len_openssl) || (secp256k1_memcmp_var(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n-    }\n-#endif\n     return ret;\n }\n \n@@ -5955,7 +5967,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &keyj, &sr);\n         secp256k1_ge_set_gej(&key, &keyj);\n         msg = ss;\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with r of zero fails. */\n@@ -5974,7 +5986,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 0);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey_mods_zero, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify( &sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with s of zero fails. */\n@@ -5993,7 +6005,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 1);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with message 0 passes. */\n@@ -6021,14 +6033,14 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&sr, 2);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message 1 passes. */\n@@ -6062,15 +6074,15 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 2);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message -1 passes. */\n@@ -6096,12 +6108,12 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_negate(&msg, &msg);\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 3);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Signature where s would be zero. */\n@@ -6311,62 +6323,6 @@ void run_ecdsa_edge_cases(void) {\n     test_ecdsa_edge_cases();\n }\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-EC_KEY *get_openssl_key(const unsigned char *key32) {\n-    unsigned char privkey[300];\n-    size_t privkeylen;\n-    const unsigned char* pbegin = privkey;\n-    int compr = secp256k1_testrand_bits(1);\n-    EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    CHECK(ec_privkey_export_der(ctx, privkey, &privkeylen, key32, compr));\n-    CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n-    CHECK(EC_KEY_check_key(ec_key));\n-    return ec_key;\n-}\n-\n-void test_ecdsa_openssl(void) {\n-    secp256k1_gej qj;\n-    secp256k1_ge q;\n-    secp256k1_scalar sigr, sigs;\n-    secp256k1_scalar one;\n-    secp256k1_scalar msg2;\n-    secp256k1_scalar key, msg;\n-    EC_KEY *ec_key;\n-    unsigned int sigsize = 80;\n-    size_t secp_sigsize = 80;\n-    unsigned char message[32];\n-    unsigned char signature[80];\n-    unsigned char key32[32];\n-    secp256k1_testrand256_test(message);\n-    secp256k1_scalar_set_b32(&msg, message, NULL);\n-    random_scalar_order_test(&key);\n-    secp256k1_scalar_get_b32(key32, &key);\n-    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &qj, &key);\n-    secp256k1_ge_set_gej(&q, &qj);\n-    ec_key = get_openssl_key(key32);\n-    CHECK(ec_key != NULL);\n-    CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n-    CHECK(secp256k1_ecdsa_sig_parse(&sigr, &sigs, signature, sigsize));\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg));\n-    secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_scalar_add(&msg2, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg2));\n-\n-    random_sign(&sigr, &sigs, &key, &msg, NULL);\n-    CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sigr, &sigs));\n-    CHECK(ECDSA_verify(0, message, sizeof(message), signature, secp_sigsize, ec_key) == 1);\n-\n-    EC_KEY_free(ec_key);\n-}\n-\n-void run_ecdsa_openssl(void) {\n-    int i;\n-    for (i = 0; i < 10*count; i++) {\n-        test_ecdsa_openssl();\n-    }\n-}\n-#endif\n-\n #ifdef ENABLE_MODULE_ECDH\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n@@ -6618,6 +6574,7 @@ int main(int argc, char **argv) {\n     run_group_decompress();\n \n     /* ecmult tests */\n+    run_ecmult_pre_g();\n     run_wnaf();\n     run_point_times_order();\n     run_ecmult_near_split_bound();\n@@ -6652,9 +6609,6 @@ int main(int argc, char **argv) {\n     run_ecdsa_sign_verify();\n     run_ecdsa_end_to_end();\n     run_ecdsa_edge_cases();\n-#ifdef ENABLE_OPENSSL_TESTS\n-    run_ecdsa_openssl();\n-#endif\n \n #ifdef ENABLE_MODULE_RECOVERY\n     /* ECDSA pubkey recovery tests */"
      },
      {
        "sha": "4d96dd947b46f8beea95ca5631a7bf1b310e9463",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -163,7 +163,7 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     }\n }\n \n-void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj) {\n+void test_exhaustive_ecmult(const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j, r_log;\n     uint64_t iter = 0;\n     for (r_log = 1; r_log < EXHAUSTIVE_TEST_ORDER; r_log++) {\n@@ -175,7 +175,7 @@ void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *gr\n                 secp256k1_scalar_set_int(&na, i);\n                 secp256k1_scalar_set_int(&ng, j);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                secp256k1_ecmult(&tmp, &groupj[r_log], &na, &ng);\n                 ge_equals_gej(&group[(i * r_log + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n \n                 if (i > 0) {\n@@ -219,7 +219,7 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                     }\n                 }\n@@ -430,7 +430,7 @@ int main(int argc, char** argv) {\n         /* Run the tests */\n         test_exhaustive_endomorphism(group);\n         test_exhaustive_addition(group, groupj);\n-        test_exhaustive_ecmult(ctx, group, groupj);\n+        test_exhaustive_ecmult(group, groupj);\n         test_exhaustive_ecmult_multi(ctx, group);\n         test_exhaustive_sign(ctx, group);\n         test_exhaustive_verify(ctx, group);"
      },
      {
        "sha": "f6b72a6d488336fd79907ccfcbf236a55aacd999",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/440f7ec80eff1f4f5b2139d66b89cc6f33053c80/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "patch": "@@ -140,6 +140,8 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n     VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n     VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n     VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    /* Avoid unused parameter warnings when building without VERIFY */\n+    (void) base; (void) max_size;\n     ret = *prealloc_ptr;\n     *prealloc_ptr = (unsigned char*)*prealloc_ptr + aligned_alloc_size;\n     return ret;"
      }
    ]
  },
  {
    "sha": "52047b4ba15412bd8a010665840caa33da73e645",
    "node_id": "C_kwDOABII59oAKDUyMDQ3YjRiYTE1NDEyYmQ4YTAxMDY2NTg0MGNhYTMzZGE3M2U2NDU",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-31T17:06:40Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-31T17:06:40Z"
      },
      "message": "Update src/secp256k1 subtree to latest upstream master",
      "tree": {
        "sha": "64a707a42ded0dc364e8045c38218ee8b8e764de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64a707a42ded0dc364e8045c38218ee8b8e764de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52047b4ba15412bd8a010665840caa33da73e645",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52047b4ba15412bd8a010665840caa33da73e645",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/52047b4ba15412bd8a010665840caa33da73e645",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52047b4ba15412bd8a010665840caa33da73e645/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7efc628539573af4b4a76d93b853cc46e9e52eae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7efc628539573af4b4a76d93b853cc46e9e52eae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7efc628539573af4b4a76d93b853cc46e9e52eae"
      },
      {
        "sha": "440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/440f7ec80eff1f4f5b2139d66b89cc6f33053c80",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/440f7ec80eff1f4f5b2139d66b89cc6f33053c80"
      }
    ],
    "stats": {
      "total": 18319,
      "additions": 17348,
      "deletions": 971
    },
    "files": [
      {
        "sha": "8111551a72815e36a9d60934df039efb5f0a37dd",
        "filename": "src/secp256k1/.cirrus.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.cirrus.yml?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -278,14 +278,13 @@ task:\n   container:\n     dockerfile: ci/linux-debian.Dockerfile\n     cpu: 1\n-    memory: 1G\n+    memory: 2G\n   env:\n     ECDH: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n     CTIMETEST: no\n-    EXTRAFLAGS: \"--disable-openssl-tests\"\n   matrix:\n     - name: \"Valgrind (memcheck)\"\n       env:"
      },
      {
        "sha": "9cf2163c3978bbb5bfd37314ad2a40102d6a6a6a",
        "filename": "src/secp256k1/.gitattributes",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/.gitattributes",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/.gitattributes",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitattributes?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -0,0 +1 @@\n+src/ecmult_static_pre_g.h linguist-generated"
      },
      {
        "sha": "aa7009af148559b51d0b78012ddbc9eee9de58f1",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -9,10 +9,12 @@ bench_internal\n tests\n exhaustive_tests\n gen_context\n+gen_ecmult_static_pre_g\n valgrind_ctime_test\n *.exe\n *.so\n *.a\n+*.csv\n !.gitignore\n \n Makefile"
      },
      {
        "sha": "a04ad05e8dccf4c367c309f07421780e412026cf",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -84,8 +84,6 @@ if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n-# SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n-bench_verify_CPPFLAGS = $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n@@ -127,12 +125,19 @@ exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n \n+EXTRA_PROGRAMS = gen_ecmult_static_pre_g\n+gen_ecmult_static_pre_g_SOURCES = src/gen_ecmult_static_pre_g.c\n+# See Automake manual, Section \"Errors with distclean\"\n+src/ecmult_static_pre_g.h:\n+\t$(MAKE) $(AM_MAKEFLAGS) gen_ecmult_static_pre_g$(EXEEXT)\n+\t./gen_ecmult_static_pre_g$(EXEEXT)\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n+$(gen_context_OBJECTS): src/gen_context.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n@@ -149,7 +154,7 @@ src/ecmult_static_context.h: $(gen_context_BIN)\n CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/ecmult_static_pre_g.h src/basic-config.h\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "7499f84d420652f5b5b1636d1276c3a5eff09fc1",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -100,6 +100,18 @@ To create a HTML report with coloured and annotated source code:\n     $ mkdir -p coverage\n     $ gcovr --exclude 'src/bench*' --html --html-details -o coverage/coverage.html\n \n+Benchmark\n+------------\n+If configured with `--enable-benchmark` (which is the default), binaries for benchmarking the libsecp256k1 functions will be present in the root directory after the build.\n+\n+To print the benchmark result to the command line:\n+\n+    $ ./bench_name\n+\n+To create a CSV file for the benchmark result :\n+\n+    $ ./bench_name | sed '2d;s/ \\{1,\\}//g' > bench_name.csv\n+\n Reporting a vulnerability\n ------------\n "
      },
      {
        "sha": "2ece0dfbb008fa2e79795ecd907bd5124697ce37",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 66,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -9,72 +9,6 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n AC_MSG_RESULT([$has_64bit_asm])\n ])\n \n-dnl\n-AC_DEFUN([SECP_OPENSSL_CHECK],[\n-  has_libcrypto=no\n-  m4_ifdef([PKG_CHECK_MODULES],[\n-    PKG_CHECK_MODULES([CRYPTO], [libcrypto], [has_libcrypto=yes],[has_libcrypto=no])\n-    if test x\"$has_libcrypto\" = x\"yes\"; then\n-      TEMP_LIBS=\"$LIBS\"\n-      LIBS=\"$LIBS $CRYPTO_LIBS\"\n-      AC_CHECK_LIB(crypto, main,[AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])],[has_libcrypto=no])\n-      LIBS=\"$TEMP_LIBS\"\n-    fi\n-  ])\n-  if test x$has_libcrypto = xno; then\n-    AC_CHECK_HEADER(openssl/crypto.h,[\n-      AC_CHECK_LIB(crypto, main,[\n-        has_libcrypto=yes\n-        CRYPTO_LIBS=-lcrypto\n-        AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])\n-      ])\n-    ])\n-    LIBS=\n-  fi\n-if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n-  AC_MSG_CHECKING(for EC functions in libcrypto)\n-  CPPFLAGS_TEMP=\"$CPPFLAGS\"\n-  CPPFLAGS=\"$CRYPTO_CPPFLAGS $CPPFLAGS\"\n-  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-    #include <openssl/bn.h>\n-    #include <openssl/ec.h>\n-    #include <openssl/ecdsa.h>\n-    #include <openssl/obj_mac.h>]],[[\n-    # if OPENSSL_VERSION_NUMBER < 0x10100000L\n-    void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {(void)sig->r; (void)sig->s;}\n-    # endif\n-\n-    unsigned int zero = 0;\n-    const unsigned char *zero_ptr = (unsigned char*)&zero;\n-    EC_KEY_free(EC_KEY_new_by_curve_name(NID_secp256k1));\n-    EC_KEY *eckey = EC_KEY_new();\n-    EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    EC_KEY_set_group(eckey, group);\n-    ECDSA_sign(0, NULL, 0, NULL, &zero, eckey);\n-    ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n-    o2i_ECPublicKey(&eckey, &zero_ptr, 0);\n-    d2i_ECPrivateKey(&eckey, &zero_ptr, 0);\n-    EC_KEY_check_key(eckey);\n-    EC_KEY_free(eckey);\n-    EC_GROUP_free(group);\n-    ECDSA_SIG *sig_openssl;\n-    sig_openssl = ECDSA_SIG_new();\n-    d2i_ECDSA_SIG(&sig_openssl, &zero_ptr, 0);\n-    i2d_ECDSA_SIG(sig_openssl, NULL);\n-    ECDSA_SIG_get0(sig_openssl, NULL, NULL);\n-    ECDSA_SIG_free(sig_openssl);\n-    const BIGNUM *bignum = BN_value_one();\n-    BN_is_negative(bignum);\n-    BN_num_bits(bignum);\n-    if (sizeof(zero) >= BN_num_bytes(bignum)) {\n-        BN_bn2bin(bignum, (unsigned char*)&zero);\n-    }\n-  ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n-  AC_MSG_RESULT([$has_openssl_ec])\n-  CPPFLAGS=\"$CPPFLAGS_TEMP\"\n-fi\n-])\n-\n AC_DEFUN([SECP_VALGRIND_CHECK],[\n if test x\"$has_valgrind\" != x\"yes\"; then\n   CPPFLAGS_TEMP=\"$CPPFLAGS\""
      },
      {
        "sha": "fdba12aa00b474a9043d8eb56eab1ff20bda6145",
        "filename": "src/secp256k1/ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/linux-debian.Dockerfile?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -14,7 +14,7 @@ RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n         gcc clang llvm libc6-dbg \\\n         g++ \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan6:i386 \\\n         gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n         gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n         gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\"
      },
      {
        "sha": "906f63cbb6e71e5abdcdb9e26e76a2928ca16060",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 38,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -43,13 +43,7 @@ case $host_os in\n          # These Homebrew packages may be keg-only, meaning that they won't be found\n          # in expected paths because they may conflict with system files. Ask\n          # Homebrew where each one is located, then adjust paths accordingly.\n-         openssl_prefix=`$BREW --prefix openssl 2>/dev/null`\n          valgrind_prefix=`$BREW --prefix valgrind 2>/dev/null`\n-         if test x$openssl_prefix != x; then\n-           PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n-           export PKG_CONFIG_PATH\n-           CRYPTO_CPPFLAGS=\"-I$openssl_prefix/include\"\n-         fi\n          if test x$valgrind_prefix != x; then\n            VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n@@ -121,11 +115,6 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n-AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n-    [enable_openssl_tests=$enableval],\n-    [enable_openssl_tests=auto])\n-\n AC_ARG_ENABLE(experimental,\n     AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n@@ -177,6 +166,8 @@ AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n [window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n [Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n [The table will store 2^(SIZE-1) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[A window size larger than 15 will require you delete the prebuilt ecmult_static_pre_g.h file so that it can be rebuilt.]\n+[For very large window sizes, use \"make -j 1\" to reduce memory use during compilation.]\n [\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n )],\n [req_ecmult_window=$withval], [req_ecmult_window=auto])\n@@ -327,32 +318,6 @@ case $set_ecmult_gen_precision in\n   ;;\n esac\n \n-if test x\"$use_tests\" = x\"yes\"; then\n-  SECP_OPENSSL_CHECK\n-  if test x\"$enable_openssl_tests\" != x\"no\" && test x\"$has_openssl_ec\" = x\"yes\"; then\n-      enable_openssl_tests=yes\n-      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS $CRYPTO_CPPFLAGS\"\n-      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-      case $host in\n-      *mingw*)\n-        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-        ;;\n-      esac\n-  else\n-    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n-      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n-    fi\n-    enable_openssl_tests=no\n-  fi\n-else\n-  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n-    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n-  fi\n-  enable_openssl_tests=no\n-fi\n-\n if test x\"$enable_valgrind\" = x\"yes\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n fi\n@@ -517,7 +482,6 @@ echo \"  with ecmult precomp     = $set_precomp\"\n echo \"  with external callbacks = $use_external_default_callbacks\"\n echo \"  with benchmarks         = $use_benchmark\"\n echo \"  with tests              = $use_tests\"\n-echo \"  with openssl tests      = $enable_openssl_tests\"\n echo \"  with coverage           = $enable_coverage\"\n echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\""
      },
      {
        "sha": "576953f49d4aaaf10165a5aa4715984fbe6154eb",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 48,
        "deletions": 49,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -226,7 +226,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n  *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx: an existing context to copy (cannot be NULL)\n+ *  Args:    ctx: an existing context to copy\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n@@ -247,7 +247,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Set a callback function to be called when an illegal argument is passed to\n  *  an API call. It will only trigger for violations that are mentioned\n@@ -278,11 +278,11 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  fails. In this case, the corresponding default handler will be called with\n  *  the data pointer argument set to NULL.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n  *              passed to the API, taking a message and an opaque pointer.\n  *              (NULL restores the default handler.)\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_error_callback.\n  */\n@@ -302,12 +302,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *  for that). After this callback returns, anything may happen, including\n  *  crashing.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n  *              taking a message and an opaque pointer (NULL restores the\n  *              default handler, see secp256k1_context_set_illegal_callback\n  *              for details).\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_illegal_callback.\n  */\n@@ -320,7 +320,7 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n /** Create a secp256k1 scratch space object.\n  *\n  *  Returns: a newly created scratch space.\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   size: amount of memory to be available as scratch space. Some extra\n  *              (<100 bytes) will be allocated for extra accounting.\n  */\n@@ -480,16 +480,16 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n  *  Returns: 1: correct signature\n  *           0: incorrect or unparseable signature\n  *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig:       the signature being verified (cannot be NULL)\n- *           msghash32: the 32-byte message hash being verified (cannot be NULL).\n+ *  In:      sig:       the signature being verified.\n+ *           msghash32: the 32-byte message hash being verified.\n  *                      The verifier must make sure to apply a cryptographic\n  *                      hash function to the message by itself and not accept an\n  *                      msghash32 value directly. Otherwise, it would be easy to\n  *                      create a \"valid\" signature without knowledge of the\n  *                      secret key. See also\n  *                      https://bitcoin.stackexchange.com/a/81116/35586 for more\n  *                      background on this topic.\n- *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)\n+ *           pubkey:    pointer to an initialized public key to verify with.\n  *\n  * To avoid accepting malleable signatures, only ECDSA signatures in lower-S\n  * form are accepted.\n@@ -515,8 +515,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n  *                or copy if the input was already normalized. (can be NULL if\n  *                you're only interested in whether the input was already\n  *                normalized).\n- *  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,\n- *                can be identical to sigout)\n+ *  In:   sigin:  a pointer to a signature to check/normalize (can be identical to sigout)\n  *\n  *  With ECDSA a third-party can forge a second distinct signature of the same\n  *  message, given a single initial signature, but without knowing the key. This\n@@ -568,12 +567,16 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL). If it is non-NULL and\n+ *                      secp256k1_nonce_function_default is used, then ndata must be a\n+ *                      pointer to 32-bytes of additional data.\n  *\n  * The created signature is always in lower-S form. See\n  * secp256k1_ecdsa_signature_normalize for more details.\n@@ -596,8 +599,8 @@ SECP256K1_API int secp256k1_ecdsa_sign(\n  *\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n- *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n     const secp256k1_context* ctx,\n@@ -606,11 +609,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n \n /** Compute the public key for a secret key.\n  *\n- *  Returns: 1: secret was valid, public key stores\n- *           0: secret was invalid, try again\n- *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:    pubkey:     pointer to the created public key (cannot be NULL)\n- *  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)\n+ *  Returns: 1: secret was valid, public key stores.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:    pointer to a context object, initialized for signing.\n+ *  Out:     pubkey: pointer to the created public key.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const secp256k1_context* ctx,\n@@ -626,8 +629,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n  *  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the\n  *                  secret key is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0 and\n- *                  seckey will be set to some unspecified value. (cannot be\n- *                  NULL)\n+ *                  seckey will be set to some unspecified value.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_negate(\n     const secp256k1_context* ctx,\n@@ -645,7 +647,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n  *\n  *  Returns: 1 always\n  *  Args:   ctx:        pointer to a context object\n- *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ *  In/Out: pubkey:     pointer to the public key to be negated.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n     const secp256k1_context* ctx,\n@@ -657,15 +659,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n  *  Returns: 0 if the arguments are invalid or the resulting secret key would be\n  *           invalid (only when the tweak is the negation of the secret key). 1\n  *           otherwise.\n- *  Args:    ctx:   pointer to a context object (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -686,14 +688,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n  *  Returns: 0 if the arguments are invalid or the resulting public key would be\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -704,15 +705,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n /** Tweak a secret key by multiplying it by a tweak.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx:    pointer to a context object (cannot be NULL).\n+ *  Args:   ctx:    pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -731,14 +732,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n /** Tweak a public key by multiplying it by a tweak value.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -749,7 +749,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n /** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated or nothing to randomize\n  *           0: error\n- *  Args:    ctx:       pointer to a context object (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object.\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n  *\n  * While secp256k1 code is written to be constant-time no matter what secret\n@@ -780,18 +780,17 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n  *\n  *  Returns: 1: the sum of the public keys is valid.\n  *           0: the sum of the public keys is not valid.\n- *  Args:   ctx:        pointer to a context object\n- *  Out:    out:        pointer to a public key object for placing the resulting public key\n- *                      (cannot be NULL)\n- *  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)\n- *          n:          the number of public keys to add together (must be at least 1)\n+ *  Args:   ctx:        pointer to a context object.\n+ *  Out:    out:        pointer to a public key object for placing the resulting public key.\n+ *  In:     ins:        pointer to array of pointers to public keys.\n+ *          n:          the number of public keys to add together (must be at least 1).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *out,\n     const secp256k1_pubkey * const * ins,\n     size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Compute a tagged hash as defined in BIP-340.\n  *"
      },
      {
        "sha": "c8577984b1a5ef35a8f3334e16e9865dd04e5ca1",
        "filename": "src/secp256k1/include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_ecdh.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -37,14 +37,15 @@ SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_func\n  *\n  *  Returns: 1: exponentiation was successful\n  *           0: scalar was invalid (zero or overflow) or hashfp returned 0\n- *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     output:     pointer to an array to be filled by hashfp\n- *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n- *                       initialized public key\n- *           seckey:     a 32-byte scalar with which to multiply the point\n- *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n- *                       (in which case, 32 bytes will be written to output)\n+ *  Args:    ctx:        pointer to a context object.\n+ *  Out:     output:     pointer to an array to be filled by hashfp.\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an initialized public key.\n+ *           seckey:     a 32-byte scalar with which to multiply the point.\n+ *           hashfp:     pointer to a hash function. If NULL,\n+ *                       secp256k1_ecdh_hash_function_sha256 is used\n+ *                       (in which case, 32 bytes will be written to output).\n  *           data:       arbitrary data pointer that is passed through to hashfp\n+ *                       (can be NULL for secp256k1_ecdh_hash_function_sha256).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,"
      },
      {
        "sha": "a64d561b60bff825a71892f959082aff9f6c5448",
        "filename": "src/secp256k1/include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 34,
        "deletions": 48,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_extrakeys.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -39,11 +39,10 @@ typedef struct {\n  *  Returns: 1 if the public key was fully valid.\n  *           0 if the public key could not be parsed or is invalid.\n  *\n- *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Args:   ctx: a secp256k1 context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n  *               parsed version of input. If not, it's set to an invalid value.\n- *               (cannot be NULL).\n- *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  In: input32: pointer to a serialized xonly_pubkey.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n     const secp256k1_context* ctx,\n@@ -55,11 +54,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n  *\n  *  Returns: 1 always.\n  *\n- *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n- *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n- *                 (cannot be NULL).\n- *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n- *                 initialized public key (cannot be NULL).\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an initialized public key.\n  */\n SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_context* ctx,\n@@ -87,13 +84,12 @@ SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n  *  Returns: 1 if the public key was successfully converted\n  *           0 otherwise\n  *\n- *  Args:         ctx: pointer to a context object (cannot be NULL)\n- *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n- *                     converted public key (cannot be NULL)\n- *          pk_parity: pointer to an integer that will be set to 1 if the point\n- *                     encoded by xonly_pubkey is the negation of the pubkey and\n- *                     set to 0 otherwise. (can be NULL)\n- *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key.\n+ *          pk_parity: Ignored if NULL. Otherwise, pointer to an integer that\n+ *                     will be set to 1 if the point encoded by xonly_pubkey is\n+ *                     the negation of the pubkey and set to 0 otherwise.\n+ *  In:        pubkey: pointer to a public key that is converted.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n     const secp256k1_context* ctx,\n@@ -113,18 +109,14 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n  *\n- *  Args:           ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n+ *  Args:           ctx: pointer to a context object initialized for verification.\n  *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n- *                       to an invalid value if this function returns 0 (cannot\n- *                       be NULL)\n+ *                       to an invalid value if this function returns 0.\n  *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n- *                       (cannot be NULL).\n  *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n  *                       according to secp256k1_ec_seckey_verify, this function\n  *                       returns 0. For uniformly random 32-byte arrays the\n- *                       chance of being invalid is negligible (around 1 in\n- *                       2^128) (cannot be NULL).\n+ *                       chance of being invalid is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -146,17 +138,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n  *\n  *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n  *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n- *  Args:            ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n- *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  Args:            ctx: pointer to a context object initialized for verification.\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey.\n  *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n  *                        is passed in as tweaked_pubkey32). This must match the\n  *                        pk_parity value that is returned when calling\n  *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n  *                        this function will fail.\n- *       internal_pubkey: pointer to an x-only public key object to apply the\n- *                        tweak to (cannot be NULL)\n- *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ *       internal_pubkey: pointer to an x-only public key object to apply the tweak to.\n+ *               tweak32: pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n     const secp256k1_context* ctx,\n@@ -170,9 +160,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_\n  *\n  *  Returns: 1: secret was valid, keypair is ready to use\n  *           0: secret was invalid, try again with a different secret\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out: keypair: pointer to the created keypair (cannot be NULL)\n- *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out: keypair: pointer to the created keypair.\n+ *  In:   seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n     const secp256k1_context* ctx,\n@@ -183,9 +173,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n /** Get the secret key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n- *  Out: seckey: pointer to a 32-byte buffer for the secret key (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n+ *  Out: seckey: pointer to a 32-byte buffer for the secret key.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n     const secp256k1_context* ctx,\n@@ -196,11 +186,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n /** Get the public key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n  *               the keypair public key. If not, it's set to an invalid value.\n- *               (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n     const secp256k1_context* ctx,\n@@ -214,14 +203,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n  *  secp256k1_xonly_pubkey_from_pubkey.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n  *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n  *               to the keypair public key after converting it to an\n- *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n- *               NULL).\n- *    pk_parity: pointer to an integer that will be set to the pk_parity\n- *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *               xonly_pubkey. If not, it's set to an invalid value.\n+ *    pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the\n+ *               pk_parity argument of secp256k1_xonly_pubkey_from_pubkey.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n     const secp256k1_context* ctx,\n@@ -241,15 +229,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n  *           invalid (only when the tweak is the negation of the keypair's\n  *           secret key). 1 otherwise.\n  *\n- *  Args:       ctx: pointer to a context object initialized for verification\n- *                   (cannot be NULL)\n+ *  Args:       ctx: pointer to a context object initialized for verification.\n  *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n- *                   an invalid value if this function returns 0 (cannot be\n- *                   NULL).\n+ *                   an invalid value if this function returns 0.\n  *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n  *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n  *                   uniformly random 32-byte arrays the chance of being invalid\n- *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                   is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "d2d9014f02881c5ac36164af5c63932d170c3c46",
        "filename": "src/secp256k1/include/secp256k1_preallocated.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_preallocated.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -55,7 +55,7 @@ SECP256K1_API size_t secp256k1_context_preallocated_size(\n  *  Returns: a newly created context object.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  *           flags:    which parts of the context to initialize.\n  *\n  *  See also secp256k1_context_randomize (in secp256k1.h)\n@@ -70,7 +70,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n  *  caller-provided memory.\n  *\n  *  Returns: the required size of the caller-provided memory block.\n- *  In:      ctx: an existing context to copy (cannot be NULL)\n+ *  In:      ctx: an existing context to copy.\n  */\n SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n     const secp256k1_context* ctx\n@@ -87,10 +87,10 @@ SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n  *  secp256k1_context_preallocated_create for details.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  Args:    ctx:      an existing context to copy.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n     const secp256k1_context* ctx,\n@@ -115,11 +115,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n  *\n  *  Args:   ctx: an existing context to destroy, constructed using\n  *               secp256k1_context_preallocated_create or\n- *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ *               secp256k1_context_preallocated_clone.\n  */\n SECP256K1_API void secp256k1_context_preallocated_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "0e2847db96c6925d0bf58c897b839870bfc677b5",
        "filename": "src/secp256k1/include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_recovery.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -43,8 +43,9 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_parse_compact(\n /** Convert a recoverable signature into a normal signature.\n  *\n  *  Returns: 1\n- *  Out: sig:    a pointer to a normal signature (cannot be NULL).\n- *  In:  sigin:  a pointer to a recoverable signature (cannot be NULL).\n+ *  Args: ctx:    a secp256k1 context object.\n+ *  Out:  sig:    a pointer to a normal signature.\n+ *  In:   sigin:  a pointer to a recoverable signature.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n     const secp256k1_context* ctx,\n@@ -55,10 +56,10 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n /** Serialize an ECDSA signature in compact format (64 bytes + recovery id).\n  *\n  *  Returns: 1\n- *  Args: ctx:      a secp256k1 context object\n- *  Out:  output64: a pointer to a 64-byte array of the compact signature (cannot be NULL)\n- *        recid:    a pointer to an integer to hold the recovery id (can be NULL).\n- *  In:   sig:      a pointer to an initialized signature object (cannot be NULL)\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  Out:  output64: a pointer to a 64-byte array of the compact signature.\n+ *        recid:    a pointer to an integer to hold the recovery id.\n+ *  In:   sig:      a pointer to an initialized signature object.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n     const secp256k1_context* ctx,\n@@ -71,12 +72,14 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL for secp256k1_nonce_function_default).\n  */\n SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n     const secp256k1_context* ctx,\n@@ -91,10 +94,10 @@ SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n  *\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  Args:    ctx:       pointer to a context object, initialized for verification (cannot be NULL)\n- *  Out:     pubkey:    pointer to the recovered public key (cannot be NULL)\n- *  In:      sig:       pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n- *           msghash32: the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for verification.\n+ *  Out:     pubkey:    pointer to the recovered public key.\n+ *  In:      sig:       pointer to initialized signature that supports pubkey recovery.\n+ *           msghash32: the 32-byte message hash assumed to be signed.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "e971ddc2aa8f2c4ccd40358595ec6018ff211cd8",
        "filename": "src/secp256k1/include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorrsig.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -106,12 +106,13 @@ typedef struct {\n  *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n- *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n- *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature.\n+ *  In:    msg32: the 32-byte message being signed.\n+ *       keypair: pointer to an initialized keypair.\n  *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n- *                this, it is only supplemental to security and can be NULL. See\n+ *                this, it is only supplemental to security and can be NULL. A\n+ *                NULL argument is treated the same as an all-zero one. See\n  *                BIP-340 \"Default Signing\" for a full explanation of this\n  *                argument and for guidance if randomness is expensive.\n  */\n@@ -120,7 +121,7 @@ SECP256K1_API int secp256k1_schnorrsig_sign(\n     unsigned char *sig64,\n     const unsigned char *msg32,\n     const secp256k1_keypair *keypair,\n-    unsigned char *aux_rand32\n+    const unsigned char *aux_rand32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Create a Schnorr signature with a more flexible API.\n@@ -150,7 +151,7 @@ SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n- *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *  In:    sig64: pointer to the 64-byte signature to verify.\n  *           msg: the message being verified. Can only be NULL if msglen is 0.\n  *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)"
      },
      {
        "sha": "68f95adec4be7970974107403d3aa8a435c25689",
        "filename": "src/secp256k1/sage/secp256k1_params.sage",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/sage/secp256k1_params.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/sage/secp256k1_params.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/secp256k1_params.sage?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -9,6 +9,9 @@ C = EllipticCurve([F(0), F(7)])\n \n \"\"\"Base point of secp256k1\"\"\"\n G = C.lift_x(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798)\n+if int(G[1]) & 1:\n+    # G.y is even\n+    G = -G\n \n \"\"\"Prime order of secp256k1\"\"\"\n N = C.order()"
      },
      {
        "sha": "65781a203ca183afecbdc829dbf21d7df380e747",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 24,
        "deletions": 11,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -24,7 +24,7 @@ static int64_t gettime_i64(void) {\n /* Format fixed point number. */\n void print_number(const int64_t x) {\n     int64_t x_abs, y;\n-    int c, i, rounding;\n+    int c, i, rounding, g; /* g = integer part size, c = fractional part size */\n     size_t ptr;\n     char buffer[30];\n \n@@ -56,21 +56,27 @@ void print_number(const int64_t x) {\n     /* Format and print the number. */\n     ptr = sizeof(buffer) - 1;\n     buffer[ptr] = 0;\n-    if (c != 0) {\n+    g = 0;\n+    if (c != 0) { /* non zero fractional part */\n         for (i = 0; i < c; ++i) {\n             buffer[--ptr] = '0' + (y % 10);\n             y /= 10;\n         }\n-        buffer[--ptr] = '.';\n+    } else if (c == 0) { /* fractional part is 0 */\n+        buffer[--ptr] = '0'; \n     }\n+    buffer[--ptr] = '.';\n     do {\n         buffer[--ptr] = '0' + (y % 10);\n         y /= 10;\n+        g++;\n     } while (y != 0);\n     if (x < 0) {\n         buffer[--ptr] = '-';\n+        g++;\n     }\n-    printf(\"%s\", &buffer[ptr]);\n+    printf(\"%5.*s\", g, &buffer[ptr]); /* Prints integer part */\n+    printf(\"%-*s\", FP_EXP, &buffer[ptr + g]); /* Prints fractional part */\n }\n \n void run_benchmark(char *name, void (*benchmark)(void*, int), void (*setup)(void*), void (*teardown)(void*, int), void* data, int count, int iter) {\n@@ -97,21 +103,19 @@ void run_benchmark(char *name, void (*benchmark)(void*, int), void (*setup)(void\n         }\n         sum += total;\n     }\n-    printf(\"%s: min \", name);\n+    /* ',' is used as a column delimiter */\n+    printf(\"%-30s, \", name);\n     print_number(min * FP_MULT / iter);\n-    printf(\"us / avg \");\n+    printf(\"   , \");\n     print_number(((sum * FP_MULT) / count) / iter);\n-    printf(\"us / max \");\n+    printf(\"   , \");\n     print_number(max * FP_MULT / iter);\n-    printf(\"us\\n\");\n+    printf(\"\\n\");\n }\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n     argv++;\n-    if (argv == argm) {\n-        return 1;\n-    }\n     while (argv != NULL && argv != argm) {\n         if (strcmp(*argv, flag) == 0) {\n             return 1;\n@@ -130,4 +134,13 @@ int get_iters(int default_iters) {\n     }\n }\n \n+void print_output_table_header_row(void) {\n+    char* bench_str = \"Benchmark\";     /* left justified */\n+    char* min_str = \"    Min(us)    \"; /* center alignment */\n+    char* avg_str = \"    Avg(us)    \";\n+    char* max_str = \"    Max(us)    \";\n+    printf(\"%-30s,%-15s,%-15s,%-15s\\n\", bench_str, min_str, avg_str, max_str);\n+    printf(\"\\n\");\n+}\n+\n #endif /* SECP256K1_BENCH_H */"
      },
      {
        "sha": "b6d4ee294191088ed46c7369bc0fba3b968eb0c7",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -52,6 +52,8 @@ int main(void) {\n     /* create a context with no capabilities */\n     data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n \n+    print_output_table_header_row();\n+\n     run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);"
      },
      {
        "sha": "335d9104231207afb52be74ca636c4a4ecfa786b",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 23,
        "deletions": 18,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -124,46 +124,46 @@ static void bench_ecmult_const_teardown(void* arg, int iters) {\n     bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n }\n \n-static void bench_ecmult_1(void* arg, int iters) {\n+static void bench_ecmult_1p(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int i;\n \n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n     }\n }\n \n-static void bench_ecmult_1_teardown(void* arg, int iters) {\n+static void bench_ecmult_1p_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n }\n \n-static void bench_ecmult_1g(void* arg, int iters) {\n+static void bench_ecmult_0p_g(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     secp256k1_scalar zero;\n     int i;\n \n     secp256k1_scalar_set_int(&zero, 0);\n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n-static void bench_ecmult_1g_teardown(void* arg, int iters) {\n+static void bench_ecmult_0p_g_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n }\n \n-static void bench_ecmult_2g(void* arg, int iters) {\n+static void bench_ecmult_1p_g(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int i;\n \n     for (i = 0; i < iters/2; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n-static void bench_ecmult_2g_teardown(void* arg, int iters) {\n+static void bench_ecmult_1p_g_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, &data->offset1, iters/2);\n }\n@@ -175,14 +175,14 @@ static void run_ecmult_bench(bench_data* data, int iters) {\n     sprintf(str, \"ecmult_const\");\n     run_benchmark(str, bench_ecmult_const, bench_ecmult_setup, bench_ecmult_const_teardown, data, 10, iters);\n     /* ecmult with non generator point */\n-    sprintf(str, \"ecmult 1\");\n-    run_benchmark(str, bench_ecmult_1, bench_ecmult_setup, bench_ecmult_1_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_1p\");\n+    run_benchmark(str, bench_ecmult_1p, bench_ecmult_setup, bench_ecmult_1p_teardown, data, 10, iters);\n     /* ecmult with generator point */\n-    sprintf(str, \"ecmult 1g\");\n-    run_benchmark(str, bench_ecmult_1g, bench_ecmult_setup, bench_ecmult_1g_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_0p_g\");\n+    run_benchmark(str, bench_ecmult_0p_g, bench_ecmult_setup, bench_ecmult_0p_g_teardown, data, 10, iters);\n     /* ecmult with generator and non-generator point. The reported time is per point. */\n-    sprintf(str, \"ecmult 2g\");\n-    run_benchmark(str, bench_ecmult_2g, bench_ecmult_setup, bench_ecmult_2g_teardown, data, 10, 2*iters);\n+    sprintf(str, \"ecmult_1p_g\");\n+    run_benchmark(str, bench_ecmult_1p_g, bench_ecmult_setup, bench_ecmult_1p_g_teardown, data, 10, 2*iters);\n }\n \n static int bench_ecmult_multi_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n@@ -207,7 +207,7 @@ static void bench_ecmult_multi(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -266,11 +266,15 @@ static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_\n             secp256k1_scalar_add(&total, &total, &tmp);\n         }\n         secp256k1_scalar_negate(&total, &total);\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->expected_output[iter], NULL, &zero, &total);\n+        secp256k1_ecmult(&data->expected_output[iter], NULL, &zero, &total);\n     }\n \n     /* Run the benchmark. */\n-    sprintf(str, includes_g ? \"ecmult_multi %ig\" : \"ecmult_multi %i\", (int)count);\n+    if (includes_g) {\n+        sprintf(str, \"ecmult_multi_%ip_g\", (int)count - 1);\n+    } else {\n+        sprintf(str, \"ecmult_multi_%ip\", (int)count);\n+    }\n     run_benchmark(str, bench_ecmult_multi, bench_ecmult_multi_setup, bench_ecmult_multi_teardown, data, 10, count * iters);\n }\n \n@@ -333,6 +337,7 @@ int main(int argc, char **argv) {\n     secp256k1_ge_set_all_gej_var(data.pubkeys, data.pubkeys_gej, POINTS);\n \n \n+    print_output_table_header_row();\n     /* Initialize offset1 and offset2 */\n     hash_into_offset(&data, 0);\n     run_ecmult_bench(&data, iters);"
      },
      {
        "sha": "aed82161273d9e8cf82abd94acf38e023fca8f21",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 33,
        "deletions": 31,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -344,37 +344,39 @@ void bench_context_sign(void* arg, int iters) {\n int main(int argc, char **argv) {\n     bench_inv data;\n     int iters = get_iters(20000);\n-\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n-\n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n+    int d = argc == 1; /* default */\n+    print_output_table_header_row();\n+\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (d || have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (d || have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n+\n+    if (d || have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n+    if (d || have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n \n     return 0;\n }"
      },
      {
        "sha": "3ccd86dd9bacd3317b0b2a9df1a357be5539c8a0",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -55,6 +55,8 @@ int main(void) {\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n \n+    print_output_table_header_row();\n+\n     run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);"
      },
      {
        "sha": "e30735d8b9ee2e9ad5bfe9018409385c626afb1c",
        "filename": "src/secp256k1/src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorrsig.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -86,6 +86,7 @@ int main(void) {\n         CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n     }\n \n+    print_output_table_header_row();\n     run_benchmark(\"schnorrsig_sign\", bench_schnorrsig_sign, NULL, NULL, (void *) &data, 10, iters);\n     run_benchmark(\"schnorrsig_verify\", bench_schnorrsig_verify, NULL, NULL, (void *) &data, 10, iters);\n "
      },
      {
        "sha": "c44f7b10ba84606ba72570003e78c61e0d545fa1",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -51,6 +51,8 @@ int main(void) {\n \n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n+    print_output_table_header_row();\n+    \n     run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);"
      },
      {
        "sha": "d62e34b77ec16cc5f3fa186129fbe51295a44d50",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 1,
        "deletions": 45,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -11,13 +11,6 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-#include <openssl/bn.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n-#endif\n-\n-\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -26,9 +19,6 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n-#ifdef ENABLE_OPENSSL_TESTS\n-    EC_GROUP* ec_group;\n-#endif\n } bench_verify_data;\n \n static void bench_verify(void* arg, int iters) {\n@@ -50,36 +40,6 @@ static void bench_verify(void* arg, int iters) {\n     }\n }\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-static void bench_verify_openssl(void* arg, int iters) {\n-    int i;\n-    bench_verify_data* data = (bench_verify_data*)arg;\n-\n-    for (i = 0; i < iters; i++) {\n-        data->sig[data->siglen - 1] ^= (i & 0xFF);\n-        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n-        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n-        {\n-            EC_KEY *pkey = EC_KEY_new();\n-            const unsigned char *pubkey = &data->pubkey[0];\n-            int result;\n-\n-            CHECK(pkey != NULL);\n-            result = EC_KEY_set_group(pkey, data->ec_group);\n-            CHECK(result);\n-            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n-            CHECK(result);\n-            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n-            CHECK(result);\n-            EC_KEY_free(pkey);\n-        }\n-        data->sig[data->siglen - 1] ^= (i & 0xFF);\n-        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n-        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n-    }\n-}\n-#endif\n-\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -103,12 +63,8 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n+    print_output_table_header_row();\n     run_benchmark(\"ecdsa_verify\", bench_verify, NULL, NULL, &data, 10, iters);\n-#ifdef ENABLE_OPENSSL_TESTS\n-    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    run_benchmark(\"ecdsa_verify_openssl\", bench_verify_openssl, NULL, NULL, &data, 10, iters);\n-    EC_GROUP_free(data.ec_group);\n-#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "4441b08398499ba58c729334d1436764f2c71a1a",
        "filename": "src/secp256k1/src/ecdsa.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -15,7 +15,7 @@\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *r, secp256k1_scalar *s, const unsigned char *sig, size_t size);\n static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const secp256k1_scalar *r, const secp256k1_scalar *s);\n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid);\n \n #endif /* SECP256K1_ECDSA_H */"
      },
      {
        "sha": "a75a08833c1b8ddaf3ffcc4bf35f05679f27b29e",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -112,7 +112,7 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n     if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n         return 0;\n     }\n-    if (rlen == 0 || *sig + rlen > sigend) {\n+    if (rlen == 0 || rlen > (size_t)(sigend - *sig)) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -204,7 +204,7 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n #if !defined(EXHAUSTIVE_TEST_ORDER)\n@@ -221,7 +221,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, sigr);\n     secp256k1_gej_set_ge(&pubkeyj, pubkey);\n-    secp256k1_ecmult(ctx, &pr, &pubkeyj, &u2, &u1);\n+    secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }"
      },
      {
        "sha": "d54d44c997b6ab90782ad176517999d369be0038",
        "filename": "src/secp256k1/src/eckey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -18,8 +18,8 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge *elem, const unsigned char\n static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *pub, size_t *size, int compressed);\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak);\n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak);\n \n #endif /* SECP256K1_ECKEY_H */"
      },
      {
        "sha": "e0506d3e2b7e05f6adb0654b0971d8f5a29a3fa4",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -57,12 +57,12 @@ static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp25\n     return !secp256k1_scalar_is_zero(key);\n }\n \n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_gej pt;\n     secp256k1_scalar one;\n     secp256k1_gej_set_ge(&pt, key);\n     secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_ecmult(ctx, &pt, &pt, &one, tweak);\n+    secp256k1_ecmult(&pt, &pt, &one, tweak);\n \n     if (secp256k1_gej_is_infinity(&pt)) {\n         return 0;\n@@ -79,7 +79,7 @@ static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp25\n     return ret;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_scalar zero;\n     secp256k1_gej pt;\n     if (secp256k1_scalar_is_zero(tweak)) {\n@@ -88,7 +88,7 @@ static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx,\n \n     secp256k1_scalar_set_int(&zero, 0);\n     secp256k1_gej_set_ge(&pt, key);\n-    secp256k1_ecmult(ctx, &pt, &pt, tweak, &zero);\n+    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }"
      },
      {
        "sha": "b47d8f494a8034c4bd01baae4f3b183af8877fcb",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 19,
        "deletions": 13,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -11,20 +11,26 @@\n #include \"scalar.h\"\n #include \"scratch.h\"\n \n-typedef struct {\n-    /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_storage (*pre_g)[];    /* odd multiples of the generator */\n-    secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n-} secp256k1_ecmult_context;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n+#endif\n+\n+/** The number of entries a table with precomputed multiples needs to have. */\n+#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))\n \n /** Double multiply: R = na*A + ng*G */\n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n \n@@ -39,6 +45,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "87ccc733d584882fd1abafa188d69212f872027c",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 29,
        "deletions": 256,
        "changes": 285,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -14,20 +14,18 @@\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n+#include \"ecmult_static_pre_g.h\"\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n /* We need to lower these values for exhaustive tests because\n  * the tables cannot have infinities in them (this breaks the\n  * affine-isomorphism stuff which tracks z-ratios) */\n #  if EXHAUSTIVE_TEST_ORDER > 128\n #    define WINDOW_A 5\n-#    define WINDOW_G 8\n #  elif EXHAUSTIVE_TEST_ORDER > 8\n #    define WINDOW_A 4\n-#    define WINDOW_G 4\n #  else\n #    define WINDOW_A 2\n-#    define WINDOW_G 2\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n@@ -41,31 +39,12 @@\n  *  Two tables of this size are used (due to the endomorphism\n  *  optimization).\n  */\n-#  define WINDOW_G ECMULT_WINDOW_SIZE\n-#endif\n-\n-/* Noone will ever need more than a window size of 24. The code might\n- * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n- * not tested.\n- *\n- * The following limitations are known, and there are probably more:\n- * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n- * because the size of the memory object that we allocate (in bytes)\n- * will not fit in a size_t.\n- * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n- * because certain expressions will overflow.\n- */\n-#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n-#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #define WNAF_BITS 128\n #define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n #define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n \n-/** The number of entries a table with precomputed multiples needs to have. */\n-#define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n-\n /* The number of objects allocated on the scratch space for ecmult_multi algorithms */\n #define PIPPENGER_SCRATCH_OBJECTS 6\n #define STRAUSS_SCRATCH_OBJECTS 6\n@@ -119,18 +98,12 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n \n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n- *  There are two versions of this function:\n- *  - secp256k1_ecmult_odd_multiples_table_globalz_windowa which brings its\n- *    resulting point set to a single constant Z denominator, stores the X and Y\n- *    coordinates as ge_storage points in pre, and stores the global Z in rz.\n- *    It only operates on tables sized for WINDOW_A wnaf multiples.\n- *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n- *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size.\n+ *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n+ *  coordinates as ge_storage points in pre, and stores the global Z in rz.\n+ *  It only operates on tables sized for WINDOW_A wnaf multiples.\n  *\n- *  To compute a*P + b*G, we compute a table for P using the first function,\n- *  and for G using the second (which requires an inverse, but it only needs to\n- *  happen once).\n+ *  To compute a*P + b*G, we compute a table for P using this function,\n+ *  and use the precomputed table in <ecmult_static_pre_g.h> for G.\n  */\n static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -142,137 +115,6 @@ static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *p\n     secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A), pre, globalz, prej, zr);\n }\n \n-static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp256k1_ge_storage *pre, const secp256k1_gej *a) {\n-    secp256k1_gej d;\n-    secp256k1_ge d_ge, p_ge;\n-    secp256k1_gej pj;\n-    secp256k1_fe zi;\n-    secp256k1_fe zr;\n-    secp256k1_fe dx_over_dz_squared;\n-    int i;\n-\n-    VERIFY_CHECK(!a->infinity);\n-\n-    secp256k1_gej_double_var(&d, a, NULL);\n-\n-    /* First, we perform all the additions in an isomorphic curve obtained by multiplying\n-     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use\n-     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store\n-     * the resulting y-coordinate and the z-ratio, since we only have enough memory to\n-     * store two field elements. These are sufficient to efficiently undo the isomorphism\n-     * and recompute all the `x`s.\n-     */\n-    d_ge.x = d.x;\n-    d_ge.y = d.y;\n-    d_ge.infinity = 0;\n-\n-    secp256k1_ge_set_gej_zinv(&p_ge, a, &d.z);\n-    pj.x = p_ge.x;\n-    pj.y = p_ge.y;\n-    pj.z = a->z;\n-    pj.infinity = 0;\n-\n-    for (i = 0; i < (n - 1); i++) {\n-        secp256k1_fe_normalize_var(&pj.y);\n-        secp256k1_fe_to_storage(&pre[i].y, &pj.y);\n-        secp256k1_gej_add_ge_var(&pj, &pj, &d_ge, &zr);\n-        secp256k1_fe_normalize_var(&zr);\n-        secp256k1_fe_to_storage(&pre[i].x, &zr);\n-    }\n-\n-    /* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */\n-    secp256k1_fe_mul(&zi, &pj.z, &d.z);\n-    secp256k1_fe_inv_var(&zi, &zi);\n-\n-    /* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so\n-     * that we can combine it with the saved z-ratios to compute the other zs\n-     * without any more inversions. */\n-    secp256k1_ge_set_gej_zinv(&p_ge, &pj, &zi);\n-    secp256k1_ge_to_storage(&pre[n - 1], &p_ge);\n-\n-    /* Compute the actual x-coordinate of D, which will be needed below. */\n-    secp256k1_fe_mul(&d.z, &zi, &pj.z);  /* d.z = 1/d.z */\n-    secp256k1_fe_sqr(&dx_over_dz_squared, &d.z);\n-    secp256k1_fe_mul(&dx_over_dz_squared, &dx_over_dz_squared, &d.x);\n-\n-    /* Going into the second loop, we have set `pre[n-1]` to its final affine\n-     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We\n-     * have `zi = (p.z * d.z)^-1`, where\n-     *\n-     *     `p.z` is the z-coordinate of the point on the isomorphic curve\n-     *           which was ultimately assigned to `pre[n-1]`.\n-     *     `d.z` is the multiplier that must be applied to all z-coordinates\n-     *           to move from our isomorphic curve back to secp256k1; so the\n-     *           product `p.z * d.z` is the z-coordinate of the secp256k1\n-     *           point assigned to `pre[n-1]`.\n-     *\n-     * All subsequent inverse-z-coordinates can be obtained by multiplying this\n-     * factor by successive z-ratios, which is much more efficient than directly\n-     * computing each one.\n-     *\n-     * Importantly, these inverse-zs will be coordinates of points on secp256k1,\n-     * while our other stored values come from computations on the isomorphic\n-     * curve. So in the below loop, we will take care not to actually use `zi`\n-     * or any derived values until we're back on secp256k1.\n-     */\n-    i = n - 1;\n-    while (i > 0) {\n-        secp256k1_fe zi2, zi3;\n-        const secp256k1_fe *rzr;\n-        i--;\n-\n-        secp256k1_ge_from_storage(&p_ge, &pre[i]);\n-\n-        /* For each remaining point, we extract the z-ratio from the stored\n-         * x-coordinate, compute its z^-1 from that, and compute the full\n-         * point from that. */\n-        rzr = &p_ge.x;\n-        secp256k1_fe_mul(&zi, &zi, rzr);\n-        secp256k1_fe_sqr(&zi2, &zi);\n-        secp256k1_fe_mul(&zi3, &zi2, &zi);\n-        /* To compute the actual x-coordinate, we use the stored z ratio and\n-         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`\n-         * in the loop above, as well as the inverse of the square of its\n-         * z-coordinate. We store the latter in the `zi2` variable, which is\n-         * computed iteratively starting from the overall Z inverse then\n-         * multiplying by each z-ratio in turn.\n-         *\n-         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`\n-         * from the inside of the above `gej_add_ge_var` call. This satisfies\n-         *\n-         *    rzr = d_x * z^2 - x * d_z^2\n-         *\n-         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`\n-         * are Jacobian coordinates of our desired point -- except both are on\n-         * the isomorphic curve that we were using when we called `gej_add_ge_var`.\n-         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or\n-         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes\n-         *\n-         *    rzr = d_x * z^2 / d_z^2 - x\n-         *\n-         * (The left-hand-side, being a ratio of z-coordinates, is unaffected\n-         * by the isomorphism.)\n-         *\n-         * Rearranging to solve for `x`, we have\n-         *\n-         *     x = d_x * z^2 / d_z^2 - rzr\n-         *\n-         * But what we actually want is the affine coordinate `X = x/z^2`,\n-         * which will satisfy\n-         *\n-         *     X = d_x / d_z^2 - rzr / z^2\n-         *       = dx_over_dz_squared - rzr * zi2\n-         */\n-        secp256k1_fe_mul(&p_ge.x, rzr, &zi2);\n-        secp256k1_fe_negate(&p_ge.x, &p_ge.x, 1);\n-        secp256k1_fe_add(&p_ge.x, &dx_over_dz_squared);\n-        /* y is stored_y/z^3, as we expect */\n-        secp256k1_fe_mul(&p_ge.y, &p_ge.y, &zi3);\n-        /* Store */\n-        secp256k1_ge_to_storage(&pre[i], &p_ge);\n-    }\n-}\n-\n /** The following two macro retrieves a particular odd multiple from a table\n  *  of precomputed multiples. */\n #define ECMULT_TABLE_GET_GE(r,pre,n,w) do { \\\n@@ -299,74 +141,6 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n-    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    ;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n-    ctx->pre_g = NULL;\n-    ctx->pre_g_128 = NULL;\n-}\n-\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n-    secp256k1_gej gj;\n-    void* const base = *prealloc;\n-    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-\n-    if (ctx->pre_g != NULL) {\n-        return;\n-    }\n-\n-    /* get the generator */\n-    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n-\n-    {\n-        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-    }\n-\n-    /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n-\n-    {\n-        secp256k1_gej g_128j;\n-        int i;\n-\n-        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-\n-        /* calculate 2^128*generator */\n-        g_128j = gj;\n-        for (i = 0; i < 128; i++) {\n-            secp256k1_gej_double_var(&g_128j, &g_128j, NULL);\n-        }\n-        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n-    }\n-}\n-\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n-    if (src->pre_g != NULL) {\n-        /* We cast to void* first to suppress a -Wcast-align warning. */\n-        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n-    }\n-    if (src->pre_g_128 != NULL) {\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n-    }\n-}\n-\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx) {\n-    return ctx->pre_g != NULL;\n-}\n-\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    secp256k1_ecmult_context_init(ctx);\n-}\n-\n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n  *  with the following guarantees:\n  *  - each wnaf[i] is either 0, or an odd integer between -(1<<(w-1) - 1) and (1<<(w-1) - 1)\n@@ -443,7 +217,7 @@ struct secp256k1_strauss_state {\n     struct secp256k1_strauss_point_state* ps;\n };\n \n-static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult_strauss_wnaf(const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n     /* Splitted G factors. */\n@@ -544,11 +318,11 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             }\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n     }\n@@ -558,7 +332,7 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n     }\n }\n \n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -571,15 +345,15 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     state.pre_a = pre_a;\n     state.pre_a_lam = pre_a_lam;\n     state.ps = ps;\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, 1, a, na, ng);\n }\n \n static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n@@ -612,14 +386,14 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, n_points, points, scalars, inp_g_sc);\n     secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n@@ -866,7 +640,7 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n@@ -881,7 +655,6 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n     int i, j;\n     int bucket_window;\n \n-    (void)ctx;\n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n@@ -941,8 +714,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n@@ -986,7 +759,7 @@ static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_cal\n \n /* Computes ecmult_multi by simply multiplying and adding each point. Does not\n  * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n+static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n     size_t point_idx;\n     secp256k1_scalar szero;\n     secp256k1_gej tmpj;\n@@ -995,7 +768,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n     secp256k1_gej_set_infinity(r);\n     secp256k1_gej_set_infinity(&tmpj);\n     /* r = inp_g_sc*G */\n-    secp256k1_ecmult(ctx, r, &tmpj, &szero, inp_g_sc);\n+    secp256k1_ecmult(r, &tmpj, &szero, inp_g_sc);\n     for (point_idx = 0; point_idx < n_points; point_idx++) {\n         secp256k1_ge point;\n         secp256k1_gej pointj;\n@@ -1005,7 +778,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n         }\n         /* r += scalar*point */\n         secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(ctx, &tmpj, &pointj, &scalar, NULL);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n     return 1;\n@@ -1031,11 +804,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1045,33 +818,33 @@ static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback,\n     } else if (n == 0) {\n         secp256k1_scalar szero;\n         secp256k1_scalar_set_int(&szero, 0);\n-        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        secp256k1_ecmult(r, r, &szero, inp_g_sc);\n         return 1;\n     }\n     if (scratch == NULL) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n \n     /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n      * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n      * As a first step check if there's enough space for Pippenger's algo (which requires less space\n      * than Strauss' algo) and if not, use the simple algorithm. */\n     if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n         if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n-            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+            return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "9072fb268860c959bbde3b0074d6451e39db7445",
        "filename": "src/secp256k1/src/ecmult_static_pre_g.h",
        "status": "added",
        "additions": 16611,
        "deletions": 0,
        "changes": 16611,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecmult_static_pre_g.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/ecmult_static_pre_g.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_static_pre_g.h?ref=52047b4ba15412bd8a010665840caa33da73e645"
      },
      {
        "sha": "55679a2fc130aa2643a70f9dd9deab47c9aa9ae0",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -14,8 +14,8 @@\n  *  - Each field element can be normalized or not.\n  *  - Each field element has a magnitude, which represents how far away\n  *    its representation is away from normalization. Normalized elements\n- *    always have a magnitude of 1, but a magnitude of 1 doesn't imply\n- *    normality.\n+ *    always have a magnitude of 0 or 1, but a magnitude of 1 doesn't\n+ *    imply normality.\n  */\n \n #if defined HAVE_CONFIG_H\n@@ -50,7 +50,9 @@ static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r);\n  *  without constant-time guarantee. */\n static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r);\n \n-/** Set a field element equal to a small integer. Resulting field element is normalized. */\n+/** Set a field element equal to a small (not greater than 0x7FFF), non-negative integer.\n+ *  Resulting field element is normalized; it has magnitude 0 if a == 0, and magnitude 1 otherwise.\n+ */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n \n /** Sets a field element equal to zero, initializing all fields. */"
      },
      {
        "sha": "4363e727e76e8d1ec2a9d96119c1b132f38f244f",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -264,10 +264,11 @@ static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n }\n \n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe *r, int a) {\n+    VERIFY_CHECK(0 <= a && a <= 0x7FFF);\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n #ifdef VERIFY\n-    r->magnitude = 1;\n+    r->magnitude = (a != 0);\n     r->normalized = 1;\n     secp256k1_fe_verify(r);\n #endif\n@@ -1162,6 +1163,7 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 1;\n+    secp256k1_fe_verify(r);\n #endif\n }\n "
      },
      {
        "sha": "b56bdd13534c4371fba432dc734ef3bc4787e008",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -227,10 +227,11 @@ static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n }\n \n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe *r, int a) {\n+    VERIFY_CHECK(0 <= a && a <= 0x7FFF);\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n #ifdef VERIFY\n-    r->magnitude = 1;\n+    r->magnitude = (a != 0);\n     r->normalized = 1;\n     secp256k1_fe_verify(r);\n #endif\n@@ -496,6 +497,7 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 1;\n+    secp256k1_fe_verify(r);\n #endif\n }\n "
      },
      {
        "sha": "0ed6118cc9b43b8df53003d9c3d4bbcc238c36f9",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 23,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -49,23 +49,23 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     c  = (uint128_t)a4 * b[4];\n     VERIFY_BITS(c, 112);\n     /* [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n-    d += (c & M) * R; c >>= 52;\n+    d += (uint128_t)R * (uint64_t)c; c >>= 64;\n     VERIFY_BITS(d, 115);\n-    VERIFY_BITS(c, 60);\n-    /* [c 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    VERIFY_BITS(c, 48);\n+    /* [(c<<12) 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n     t3 = d & M; d >>= 52;\n     VERIFY_BITS(t3, 52);\n     VERIFY_BITS(d, 63);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n \n     d += (uint128_t)a0 * b[4]\n        + (uint128_t)a1 * b[3]\n        + (uint128_t)a2 * b[2]\n        + (uint128_t)a3 * b[1]\n        + (uint128_t)a4 * b[0];\n     VERIFY_BITS(d, 115);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n-    d += c * R;\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n+    d += (uint128_t)(R << 12) * (uint64_t)c;\n     VERIFY_BITS(d, 116);\n     /* [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n     t4 = d & M; d >>= 52;\n@@ -129,17 +129,16 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n        + (uint128_t)a4 * b[3];\n     VERIFY_BITS(d, 114);\n     /* [d 0 0 t4 t3 c t1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c += (d & M) * R; d >>= 52;\n+    c += (uint128_t)R * (uint64_t)d; d >>= 64;\n     VERIFY_BITS(c, 115);\n-    VERIFY_BITS(d, 62);\n-    /* [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    VERIFY_BITS(d, 50);\n+    /* [(d<<12) 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    /* [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[2] = c & M; c >>= 52;\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n-    /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;\n+    /* [(d<<12) 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    c   += (uint128_t)(R << 12) * (uint64_t)d + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -178,22 +177,22 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     c  = (uint128_t)a4 * a4;\n     VERIFY_BITS(c, 112);\n     /* [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n-    d += (c & M) * R; c >>= 52;\n+    d += (uint128_t)R * (uint64_t)c; c >>= 64;\n     VERIFY_BITS(d, 115);\n-    VERIFY_BITS(c, 60);\n-    /* [c 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    VERIFY_BITS(c, 48);\n+    /* [(c<<12) 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n     t3 = d & M; d >>= 52;\n     VERIFY_BITS(t3, 52);\n     VERIFY_BITS(d, 63);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */\n \n     a4 *= 2;\n     d += (uint128_t)a0 * a4\n        + (uint128_t)(a1*2) * a3\n        + (uint128_t)a2 * a2;\n     VERIFY_BITS(d, 115);\n-    /* [c 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n-    d += c * R;\n+    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n+    d += (uint128_t)(R << 12) * (uint64_t)c;\n     VERIFY_BITS(d, 116);\n     /* [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */\n     t4 = d & M; d >>= 52;\n@@ -252,16 +251,16 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     d += (uint128_t)a3 * a4;\n     VERIFY_BITS(d, 114);\n     /* [d 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c += (d & M) * R; d >>= 52;\n+    c += (uint128_t)R * (uint64_t)d; d >>= 64;\n     VERIFY_BITS(c, 115);\n-    VERIFY_BITS(d, 62);\n-    /* [d 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    VERIFY_BITS(d, 50);\n+    /* [(d<<12) 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[2] = c & M; c >>= 52;\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n-    /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n+    /* [(d<<12) 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;\n+    c   += (uint128_t)(R << 12) * (uint64_t)d + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "af40d13f9c6a1dd76cf0a249a7ab4f82e75e45f6",
        "filename": "src/secp256k1/src/gen_ecmult_static_pre_g.c",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/gen_ecmult_static_pre_g.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/gen_ecmult_static_pre_g.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_ecmult_static_pre_g.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -0,0 +1,137 @@\n+/*****************************************************************************************************\n+ * Copyright (c) 2013, 2014, 2017, 2021 Pieter Wuille, Andrew Poelstra, Jonas Nick, Russell O'Connor *\n+ * Distributed under the MIT software license, see the accompanying                                  *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.                              *\n+ *****************************************************************************************************/\n+\n+#include <inttypes.h>\n+#include <stdio.h>\n+\n+/* Autotools creates libsecp256k1-config.h, of which ECMULT_WINDOW_SIZE is needed.\n+   ifndef guard so downstream users can define their own if they do not use autotools. */\n+#if !defined(ECMULT_WINDOW_SIZE)\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n+#include \"assumptions.h\"\n+#include \"util.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"ecmult.h\"\n+\n+void print_table(FILE *fp, const char *name, int window_g, const secp256k1_gej *gen, int with_conditionals) {\n+    static secp256k1_gej gj;\n+    static secp256k1_ge ge, dgen;\n+    static secp256k1_ge_storage ges;\n+    int j;\n+    int i;\n+\n+    gj = *gen;\n+    secp256k1_ge_set_gej_var(&ge, &gj);\n+    secp256k1_ge_to_storage(&ges, &ge);\n+\n+    fprintf(fp, \"static const secp256k1_ge_storage %s[ECMULT_TABLE_SIZE(WINDOW_G)] = {\\n\", name);\n+    fprintf(fp, \" S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                  \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                SECP256K1_GE_STORAGE_CONST_GET(ges));\n+\n+    secp256k1_gej_double_var(&gj, gen, NULL);\n+    secp256k1_ge_set_gej_var(&dgen, &gj);\n+\n+    j = 1;\n+    for(i = 3; i <= window_g; ++i) {\n+        if (with_conditionals) {\n+            fprintf(fp, \"#if ECMULT_TABLE_SIZE(WINDOW_G) > %ld\\n\", ECMULT_TABLE_SIZE(i-1));\n+        }\n+        for(;j < ECMULT_TABLE_SIZE(i); ++j) {\n+            secp256k1_gej_set_ge(&gj, &ge);\n+            secp256k1_gej_add_ge_var(&gj, &gj, &dgen, NULL);\n+            secp256k1_ge_set_gej_var(&ge, &gj);\n+            secp256k1_ge_to_storage(&ges, &ge);\n+\n+            fprintf(fp, \",S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                          \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                        SECP256K1_GE_STORAGE_CONST_GET(ges));\n+        }\n+        if (with_conditionals) {\n+            fprintf(fp, \"#endif\\n\");\n+        }\n+    }\n+    fprintf(fp, \"};\\n\");\n+}\n+\n+void print_two_tables(FILE *fp, int window_g, const secp256k1_ge *g, int with_conditionals) {\n+    secp256k1_gej gj;\n+    int i;\n+\n+    secp256k1_gej_set_ge(&gj, g);\n+    print_table(fp, \"secp256k1_pre_g\", window_g, &gj, with_conditionals);\n+    for (i = 0; i < 128; ++i) {\n+        secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    print_table(fp, \"secp256k1_pre_g_128\", window_g, &gj, with_conditionals);\n+}\n+\n+int main(void) {\n+    const secp256k1_ge g = SECP256K1_G;\n+    const secp256k1_ge g_13 = SECP256K1_G_ORDER_13;\n+    const secp256k1_ge g_199 = SECP256K1_G_ORDER_199;\n+    const int window_g_13 = 4;\n+    const int window_g_199 = 8;\n+    FILE* fp;\n+\n+    fp = fopen(\"src/ecmult_static_pre_g.h\",\"w\");\n+    if (fp == NULL) {\n+        fprintf(stderr, \"Could not open src/ecmult_static_pre_g.h for writing!\\n\");\n+        return -1;\n+    }\n+\n+    fprintf(fp, \"/* This file was automatically generated by gen_ecmult_static_pre_g. */\\n\");\n+    fprintf(fp, \"/* This file contains an array secp256k1_pre_g with odd multiples of the base point G and\\n\");\n+    fprintf(fp, \" * an array secp256k1_pre_g_128 with odd multiples of 2^128*G for accelerating the computation of a*P + b*G.\\n\");\n+    fprintf(fp, \" */\\n\");\n+    fprintf(fp, \"#ifndef SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#define SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#include \\\"group.h\\\"\\n\");\n+    fprintf(fp, \"#ifdef S\\n\");\n+    fprintf(fp, \"   #error macro identifier S already in use.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#define S(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \"\n+                \"SECP256K1_GE_STORAGE_CONST(0x##a##u,0x##b##u,0x##c##u,0x##d##u,0x##e##u,0x##f##u,0x##g##u,\"\n+                \"0x##h##u,0x##i##u,0x##j##u,0x##k##u,0x##l##u,0x##m##u,0x##n##u,0x##o##u,0x##p##u)\\n\");\n+    fprintf(fp, \"#if ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE) > %ld\\n\", ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE));\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_WINDOW_SIZE. Try deleting ecmult_static_pre_g.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#if defined(EXHAUSTIVE_TEST_ORDER)\\n\");\n+    fprintf(fp, \"#if EXHAUSTIVE_TEST_ORDER == 13\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_13);\n+\n+    print_two_tables(fp, window_g_13, &g_13, 0);\n+\n+    fprintf(fp, \"#elif EXHAUSTIVE_TEST_ORDER == 199\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_199);\n+\n+    print_two_tables(fp, window_g_199, &g_199, 0);\n+\n+    fprintf(fp, \"#else\\n\");\n+    fprintf(fp, \"   #error No known generator for the specified exhaustive test group order.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#else /* !defined(EXHAUSTIVE_TEST_ORDER) */\\n\");\n+    fprintf(fp, \"#define WINDOW_G ECMULT_WINDOW_SIZE\\n\");\n+\n+    print_two_tables(fp, ECMULT_WINDOW_SIZE, &g, 1);\n+\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#undef S\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fclose(fp);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "6fc58ea01599acdccf3ced5be62cc19030a861fa",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -10,6 +10,27 @@\n #include \"field.h\"\n #include \"group.h\"\n \n+#define SECP256K1_G_ORDER_13 SECP256K1_GE_CONST(\\\n+    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\\\n+    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\\\n+    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\\\n+    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\\\n+)\n+#define SECP256K1_G_ORDER_199 SECP256K1_GE_CONST(\\\n+    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\\\n+    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\\\n+    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\\\n+    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\\\n+)\n+/** Generator for secp256k1, value 'g' defined in\n+ *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n+ */\n+#define SECP256K1_G SECP256K1_GE_CONST(\\\n+    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\\\n+    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\\\n+    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\\\n+    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\\\n+)\n /* These exhaustive group test orders and generators are chosen such that:\n  * - The field size is equal to that of secp256k1, so field code is the same.\n  * - The curve equation is of the form y^2=x^3+B for some constant B.\n@@ -21,23 +42,15 @@\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 13\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\n-    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\n-    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\n-    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_13;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x3d3486b2, 0x159a9ca5, 0xc75638be, 0xb23a69bc,\n     0x946a45ab, 0x24801247, 0xb4ed2b8e, 0x26b6a417\n );\n #  elif EXHAUSTIVE_TEST_ORDER == 199\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\n-    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\n-    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\n-    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_199;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x2cca28fa, 0xfc614b80, 0x2a3db42b, 0x00ba00b1,\n     0xbea8d943, 0xdace9ab2, 0x9536daea, 0x0074defb\n@@ -46,15 +59,7 @@ static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n #else\n-/** Generator for secp256k1, value 'g' defined in\n- *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n- */\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\n-    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\n-    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\n-    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G;\n \n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 7);\n #endif"
      },
      {
        "sha": "e1003052f4c623092457fe3f4e482c27486db441",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -120,12 +120,11 @@ int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pub\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output_pubkey != NULL);\n     memset(output_pubkey, 0, sizeof(*output_pubkey));\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_pubkey_save(output_pubkey, &pk);\n@@ -137,13 +136,12 @@ int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const u\n     unsigned char pk_expected32[32];\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweaked_pubkey32 != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&pk.x);\n@@ -260,7 +258,6 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     int ret;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(keypair != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n@@ -273,7 +270,7 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     }\n \n     ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n-    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32);\n \n     secp256k1_declassify(ctx, &ret, sizeof(ret));\n     if (ret) {"
      },
      {
        "sha": "dd53f9e12aedefaf3b43f654c98a0d52cde8ea05",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -197,19 +197,19 @@ void test_xonly_pubkey_tweak(void) {\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n     ecount = 0;\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* NULL internal_xonly_pk zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     /* NULL tweak zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n \n@@ -274,20 +274,20 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     /* invalid pk_parity value */\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     memset(tweak, 1, sizeof(tweak));\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n@@ -306,7 +306,7 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -479,15 +479,15 @@ void test_keypair_add(void) {\n     memset(overflows, 0xFF, 32);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n \n-    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, NULL, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* This does not set the keypair to zeroes */\n     CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) != 0);\n "
      },
      {
        "sha": "e7906eb62e0ea10248ad31e8b6faac9a51f7b117",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -40,7 +40,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n     ARG_CHECK(recid >= 0 && recid <= 3);\n@@ -60,7 +60,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n int secp256k1_ecdsa_recoverable_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, int *recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(recid != NULL);\n@@ -75,7 +75,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     secp256k1_scalar r, s;\n     int recid;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(sigin != NULL);\n \n@@ -84,7 +84,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n     unsigned char brx[32];\n     secp256k1_fe fx;\n     secp256k1_ge x;\n@@ -115,7 +115,7 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n     secp256k1_scalar_mul(&u1, &rn, message);\n     secp256k1_scalar_negate(&u1, &u1);\n     secp256k1_scalar_mul(&u2, &rn, sigs);\n-    secp256k1_ecmult(ctx, &qj, &xj, &u2, &u1);\n+    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n     secp256k1_ge_set_gej_var(pubkey, &qj);\n     return !secp256k1_gej_is_infinity(&qj);\n }\n@@ -140,15 +140,14 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     secp256k1_scalar m;\n     int recid;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n     VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msghash32, NULL);\n-    if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n+    if (secp256k1_ecdsa_sig_recover(&r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);\n         return 1;\n     } else {"
      },
      {
        "sha": "2fcd46d206abd8d3258bf300c2c3bc00cfd9779e",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -92,20 +92,20 @@ void test_ecdsa_recovery_api(void) {\n \n     /* Check bad contexts and NULLs for recovery */\n     ecount = 0;\n-    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     /* Check NULLs for conversion */\n     CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);"
      },
      {
        "sha": "94e3ee414d6d1a43045345e6f65da2c189e2cd68",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -65,6 +65,17 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         for (i = 0; i < 32; i++) {\n             masked_key[i] ^= key32[i];\n         }\n+    } else {\n+        /* Precomputed TaggedHash(\"BIP0340/aux\", 0x0000...00); */\n+        static const unsigned char ZERO_MASK[32] = {\n+              84, 241, 105, 207, 201, 226, 229, 114,\n+             116, 128,  68,  31, 144, 186,  37, 196,\n+             136, 244,  97, 199,  11,  94, 165, 220,\n+             170, 247, 175, 105, 39,  10, 165,  20\n+        };\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] = key32[i] ^ ZERO_MASK[i];\n+        }\n     }\n \n     /* Tag the hash with algo which is important to avoid nonce reuse across\n@@ -77,12 +88,8 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         secp256k1_sha256_initialize_tagged(&sha, algo, algolen);\n     }\n \n-    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n-    if (data != NULL) {\n-        secp256k1_sha256_write(&sha, masked_key, 32);\n-    } else {\n-        secp256k1_sha256_write(&sha, key32, 32);\n-    }\n+    /* Hash masked-key||pk||msg using the tagged hash as per the spec */\n+    secp256k1_sha256_write(&sha, masked_key, 32);\n     secp256k1_sha256_write(&sha, xonly_pk32, 32);\n     secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, nonce32);\n@@ -122,7 +129,7 @@ static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned c\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+static int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -185,8 +192,9 @@ int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned ch\n     return ret;\n }\n \n-int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, unsigned char *aux_rand32) {\n-    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, aux_rand32);\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32) {\n+    /* We cast away const from the passed aux_rand32 argument since we know the default nonce function does not modify it. */\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, (unsigned char*)aux_rand32);\n }\n \n int secp256k1_schnorrsig_sign_custom(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams) {\n@@ -216,7 +224,6 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     int overflow;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n     ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n@@ -241,7 +248,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);\n     secp256k1_gej_set_ge(&pkj, &pk);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+    secp256k1_ecmult(&rj, &pkj, &e, &s);\n \n     secp256k1_ge_set_gej_var(&r, &rj);\n     if (secp256k1_ge_is_infinity(&r)) {"
      },
      {
        "sha": "d301abee51b97354966d07572f11b4628db5051b",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 16,
        "deletions": 13,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -38,7 +38,7 @@ void run_nonce_function_bip340_tests(void) {\n     size_t algolen = sizeof(algo);\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n-    unsigned char nonce[32];\n+    unsigned char nonce[32], nonce_z[32];\n     unsigned char msg[32];\n     size_t msglen = sizeof(msg);\n     unsigned char key[32];\n@@ -107,8 +107,11 @@ void run_nonce_function_bip340_tests(void) {\n         CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n     }\n \n-    /* NULL aux_rand argument is allowed. */\n+    /* NULL aux_rand argument is allowed, and identical to passing all zero aux_rand. */\n+    memset(aux_rand, 0, 32);\n+    CHECK(nonce_function_bip340(nonce_z, msg, msglen, key, pk, algo, algolen, &aux_rand) == 1);\n     CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+    CHECK(secp256k1_memcmp_var(nonce_z, nonce, 32) == 0);\n }\n \n void test_schnorrsig_api(void) {\n@@ -193,22 +196,22 @@ void test_schnorrsig_api(void) {\n \n     ecount = 0;\n     CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n-    CHECK(ecount == 6);\n+    CHECK(ecount == 4);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -230,7 +233,7 @@ void test_schnorrsig_sha256_tagged(void) {\n \n /* Helper function for schnorrsig_bip_vectors\n  * Signs the message and checks that it's the same as expected_sig. */\n-void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n     unsigned char sig[64];\n     secp256k1_keypair keypair;\n     secp256k1_xonly_pubkey pk, pk_expected;"
      },
      {
        "sha": "9b1141376c338343f88fc3d990b98cf730c00136",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 7,
        "deletions": 22,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -73,15 +73,13 @@ static const secp256k1_callback default_error_callback = {\n };\n \n struct secp256k1_context_struct {\n-    secp256k1_ecmult_context ecmult_ctx;\n     secp256k1_ecmult_gen_context ecmult_gen_ctx;\n     secp256k1_callback illegal_callback;\n     secp256k1_callback error_callback;\n     int declassify;\n };\n \n static const secp256k1_context secp256k1_context_no_precomp_ = {\n-    { 0 },\n     { 0 },\n     { secp256k1_default_illegal_callback_fn, 0 },\n     { secp256k1_default_error_callback_fn, 0 },\n@@ -103,9 +101,6 @@ size_t secp256k1_context_preallocated_size(unsigned int flags) {\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -115,9 +110,6 @@ size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n     if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -139,17 +131,13 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n-    secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     /* Flags have been checked by secp256k1_context_preallocated_size. */\n     VERIFY_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_CONTEXT);\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n-    }\n     ret->declassify = !!(flags & SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY);\n \n     return (secp256k1_context*) ret;\n@@ -176,7 +164,6 @@ secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context*\n     ret = (secp256k1_context*)prealloc;\n     memcpy(ret, ctx, prealloc_size);\n     secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n-    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n@@ -194,7 +181,6 @@ secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n     ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n-        secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n     }\n }\n@@ -458,7 +444,6 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(pubkey != NULL);\n@@ -467,7 +452,7 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_ecdsa_signature_load(ctx, &r, &s, sig);\n     return (!secp256k1_scalar_is_high(&s) &&\n             secp256k1_pubkey_load(ctx, &q, pubkey) &&\n-            secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &r, &s, &q, &m));\n+            secp256k1_ecdsa_sig_verify(&r, &s, &q, &m));\n }\n \n static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len) {\n@@ -685,24 +670,23 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak32);\n }\n \n-static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak32) {\n+static int secp256k1_ec_pubkey_tweak_add_helper(secp256k1_ge *p, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n     secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n-    return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n+    return !overflow && secp256k1_eckey_pubkey_tweak_add(p, &term);\n }\n \n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n-    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak32);\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&p, tweak32);\n     if (ret) {\n         secp256k1_pubkey_save(pubkey, &p);\n     }\n@@ -740,15 +724,14 @@ int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n     if (ret) {\n-        if (secp256k1_eckey_pubkey_tweak_mul(&ctx->ecmult_ctx, &p, &factor)) {\n+        if (secp256k1_eckey_pubkey_tweak_mul(&p, &factor)) {\n             secp256k1_pubkey_save(pubkey, &p);\n         } else {\n             ret = 0;\n@@ -771,6 +754,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej Qj;\n     secp256k1_ge Q;\n \n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubnonce != NULL);\n     memset(pubnonce, 0, sizeof(*pubnonce));\n     ARG_CHECK(n >= 1);\n@@ -779,6 +763,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej_set_infinity(&Qj);\n \n     for (i = 0; i < n; i++) {\n+        ARG_CHECK(pubnonces[i] != NULL);\n         secp256k1_pubkey_load(ctx, &Q, pubnonces[i]);\n         secp256k1_gej_add_ge(&Qj, &Qj, &Q);\n     }"
      },
      {
        "sha": "ebeef510f08e142ded0d1e3398c08835e03eb28d",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 154,
        "deletions": 200,
        "changes": 354,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -20,16 +20,6 @@\n #include \"testrand_impl.h\"\n #include \"util.h\"\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-#include <openssl/bn.h>\n-#include <openssl/ec.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n-# if OPENSSL_VERSION_NUMBER < 0x10100000L\n-void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps) {*pr = sig->r; *ps = sig->s;}\n-# endif\n-#endif\n-\n #include \"../contrib/lax_der_parsing.c\"\n #include \"../contrib/lax_der_privatekey_parsing.c\"\n \n@@ -273,22 +263,22 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sign(sign, &sig, ctmp, ctmp, NULL, NULL) == 1);\n     VG_CHECK(&sig, sizeof(sig));\n     CHECK(ecount2 == 10);\n-    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 0);\n-    CHECK(ecount2 == 11);\n+    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ecdsa_verify(vrfy, &sig, ctmp, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 12);\n+    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_tweak_add(vrfy, &pubkey, ctmp) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 13);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n@@ -298,9 +288,9 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_context_randomize(vrfy, NULL) == 1);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_context_randomize(sign, ctmp) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -314,8 +304,8 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sigr, &sigs, &key, &msg, &nonce, NULL));\n \n     /* try verifying */\n-    CHECK(secp256k1_ecdsa_sig_verify(&vrfy->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n-    CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n     if (use_prealloc) {\n@@ -3416,6 +3406,80 @@ void run_group_decompress(void) {\n \n /***** ECMULT TESTS *****/\n \n+void test_pre_g_table(const secp256k1_ge_storage * pre_g, size_t n) {\n+    /* Tests the pre_g / pre_g_128 tables for consistency.\n+     * For independent verification we take a \"geometric\" approach to verification.\n+     * We check that every entry is on-curve.\n+     * We check that for consecutive entries p and q, that p + gg - q = 0 by checking\n+     *  (1) p, gg, and -q are colinear.\n+     *  (2) p, gg, and -q are all distinct.\n+     * where gg is twice the generator, where the generator is the first table entry.\n+     *\n+     * Checking the table's generators are correct is done in run_ecmult_pre_g.\n+     */\n+    secp256k1_gej g2;\n+    secp256k1_ge p, q, gg;\n+    secp256k1_fe dpx, dpy, dqx, dqy;\n+    size_t i;\n+\n+    CHECK(0 < n);\n+\n+    secp256k1_ge_from_storage(&p, &pre_g[0]);\n+    CHECK(secp256k1_ge_is_valid_var(&p));\n+\n+    secp256k1_gej_set_ge(&g2, &p);\n+    secp256k1_gej_double_var(&g2, &g2, NULL);\n+    secp256k1_ge_set_gej_var(&gg, &g2);\n+    for (i = 1; i < n; ++i) {\n+        secp256k1_fe_negate(&dpx, &p.x, 1); secp256k1_fe_add(&dpx, &gg.x); secp256k1_fe_normalize_weak(&dpx);\n+        secp256k1_fe_negate(&dpy, &p.y, 1); secp256k1_fe_add(&dpy, &gg.y); secp256k1_fe_normalize_weak(&dpy);\n+        /* Check that p is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dpx) || !secp256k1_fe_normalizes_to_zero_var(&dpy));\n+\n+        secp256k1_ge_from_storage(&q, &pre_g[i]);\n+        CHECK(secp256k1_ge_is_valid_var(&q));\n+\n+        secp256k1_fe_negate(&dqx, &q.x, 1); secp256k1_fe_add(&dqx, &gg.x); secp256k1_fe_normalize_weak(&dqx);\n+        dqy = q.y; secp256k1_fe_add(&dqy, &gg.y); secp256k1_fe_normalize_weak(&dqy);\n+        /* Check that -q is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dqx) || !secp256k1_fe_normalizes_to_zero_var(&dqy));\n+\n+        /* Check that -q is not equal to p */\n+        CHECK(!secp256k1_fe_equal_var(&dpx, &dqx) || !secp256k1_fe_equal_var(&dpy, &dqy));\n+\n+        /* Check that p, -q and gg are colinear */\n+        secp256k1_fe_mul(&dpx, &dpx, &dqy);\n+        secp256k1_fe_mul(&dpy, &dpy, &dqx);\n+        CHECK(secp256k1_fe_equal_var(&dpx, &dpy));\n+\n+        p = q;\n+    }\n+}\n+\n+void run_ecmult_pre_g(void) {\n+    secp256k1_ge_storage gs;\n+    secp256k1_gej gj;\n+    secp256k1_ge g;\n+    size_t i;\n+\n+    /* Check that the pre_g and pre_g_128 tables are consistent. */\n+    test_pre_g_table(secp256k1_pre_g, ECMULT_TABLE_SIZE(WINDOW_G));\n+    test_pre_g_table(secp256k1_pre_g_128, ECMULT_TABLE_SIZE(WINDOW_G));\n+\n+    /* Check the first entry from the pre_g table. */\n+    secp256k1_ge_to_storage(&gs, &secp256k1_ge_const_g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g[0], sizeof(gs)) == 0);\n+\n+    /* Check the first entry from the pre_g_128 table. */\n+    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n+    for (i = 0; i < 128; ++i) {\n+      secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    secp256k1_ge_set_gej(&g, &gj);\n+    secp256k1_ge_to_storage(&gs, &g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g_128[0], sizeof(gs)) == 0);\n+}\n+\n void run_ecmult_chain(void) {\n     /* random starting point A (on the curve) */\n     secp256k1_gej a = SECP256K1_GEJ_CONST(\n@@ -3448,7 +3512,7 @@ void run_ecmult_chain(void) {\n     x = a;\n     for (i = 0; i < 200*count; i++) {\n         /* in each iteration, compute X = xn*X + gn*G; */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &x, &x, &xn, &gn);\n+        secp256k1_ecmult(&x, &x, &xn, &gn);\n         /* also compute ae and ge: the actual accumulated factors for A and G */\n         /* if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G) */\n         secp256k1_scalar_mul(&ae, &ae, &xn);\n@@ -3474,7 +3538,7 @@ void run_ecmult_chain(void) {\n         }\n     }\n     /* redo the computation, but directly with the resulting ae and ge coefficients: */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &x2, &a, &ae, &ge);\n+    secp256k1_ecmult(&x2, &a, &ae, &ge);\n     secp256k1_gej_neg(&x2, &x2);\n     secp256k1_gej_add_var(&x2, &x2, &x, NULL);\n     CHECK(secp256k1_gej_is_infinity(&x2));\n@@ -3492,8 +3556,8 @@ void test_point_times_order(const secp256k1_gej *point) {\n     size_t psize = 65;\n     random_scalar_order_test(&x);\n     secp256k1_scalar_negate(&nx, &x);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n+    secp256k1_ecmult(&res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n+    secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n     secp256k1_ge_set_gej(&res3, &res1);\n@@ -3503,13 +3567,13 @@ void test_point_times_order(const secp256k1_gej *point) {\n     psize = 65;\n     CHECK(secp256k1_eckey_pubkey_serialize(&res3, pub, &psize, 1) == 0);\n     /* check zero/one edge cases */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &zero);\n+    secp256k1_ecmult(&res1, point, &zero, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &one, &zero);\n+    secp256k1_ecmult(&res1, point, &one, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_gej(&res3, point);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &one);\n+    secp256k1_ecmult(&res1, point, &zero, &one);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_ge(&res3, &secp256k1_ge_const_g);\n }\n@@ -3568,9 +3632,9 @@ void test_ecmult_target(const secp256k1_scalar* target, int mode) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p2j, &n2);\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &ptj, target);\n     } else if (mode == 1) {\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p1j, &pj, &n1, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p2j, &pj, &n2, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptj, &pj, target, &zero);\n+        secp256k1_ecmult(&p1j, &pj, &n1, &zero);\n+        secp256k1_ecmult(&p2j, &pj, &n2, &zero);\n+        secp256k1_ecmult(&ptj, &pj, target, &zero);\n     } else {\n         secp256k1_ecmult_const(&p1j, &p, &n1, 256);\n         secp256k1_ecmult_const(&p2j, &p, &n2, 256);\n@@ -3753,7 +3817,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -3768,32 +3832,32 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         pt[1] = secp256k1_ge_const_g;\n \n         /* only G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        secp256k1_ecmult(&r2, &ptgj, &szero, &sc[0]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3810,7 +3874,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3820,7 +3884,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3833,7 +3897,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -3846,7 +3910,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3861,7 +3925,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -3879,8 +3943,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n         }\n \n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &r, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3902,8 +3966,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &p0j, &rs, &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3916,13 +3980,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -3946,8 +4010,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_scalar_set_int(&t1, (t1i + 1) / 2);\n                 secp256k1_scalar_cond_negate(&t1, t1i & 1);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t0p, &ptgj, &t0, &szero);\n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t1p, &ptgj, &t1, &szero);\n+                secp256k1_ecmult(&t0p, &ptgj, &t0, &szero);\n+                secp256k1_ecmult(&t1p, &ptgj, &t1, &szero);\n \n                 for(s0i = 0; s0i < TOP; s0i++) {\n                     for(s1i = 0; s1i < TOP; s1i++) {\n@@ -3966,8 +4030,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_mul(&tmp2, &t1, &sc[1]);\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n-                        secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        secp256k1_ecmult(&expected, &ptgj, &tmp1, &szero);\n+                        CHECK(ecmult_multi(&ctx->error_callback, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -3994,7 +4058,7 @@ void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n     scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    CHECK(!ecmult_multi(&ctx->error_callback, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n }\n \n@@ -4116,15 +4180,15 @@ void test_ecmult_multi_batching(void) {\n \n     /* Get random scalars and group elements and compute result */\n     random_scalar_order(&scG);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r2, &szero, &scG);\n+    secp256k1_ecmult(&r2, &r2, &szero, &scG);\n     for(i = 0; i < n_points; i++) {\n         secp256k1_ge ptg;\n         secp256k1_gej ptgj;\n         random_group_element_test(&ptg);\n         secp256k1_gej_set_ge(&ptgj, &ptg);\n         pt[i] = ptg;\n         random_scalar_order(&sc[i]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptgj, &ptgj, &sc[i], NULL);\n+        secp256k1_ecmult(&ptgj, &ptgj, &sc[i], NULL);\n         secp256k1_gej_add_var(&r2, &r2, &ptgj, NULL);\n     }\n     data.sc = sc;\n@@ -4134,7 +4198,7 @@ void test_ecmult_multi_batching(void) {\n     /* Test with empty scratch space. It should compute the correct result using\n      * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4143,7 +4207,7 @@ void test_ecmult_multi_batching(void) {\n      * ecmult_multi selects strauss which requires more memory. It should\n      * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4157,7 +4221,7 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n         secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -5262,22 +5326,24 @@ void test_ecdsa_sign_verify(void) {\n     secp256k1_scalar msg, key;\n     secp256k1_scalar sigr, sigs;\n     int getrec;\n-    /* Initialize recid to suppress a false positive -Wconditional-uninitialized in clang.\n-       VG_UNDEF ensures that valgrind will still treat the variable as uninitialized. */\n-    int recid = -1; VG_UNDEF(&recid, sizeof(recid));\n+    int recid;\n     random_scalar_order_test(&msg);\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n     getrec = secp256k1_testrand_bits(1);\n-    random_sign(&sigr, &sigs, &key, &msg, getrec?&recid:NULL);\n+    /* The specific way in which this conditional is written sidesteps a potential bug in clang.\n+       See the commit messages of the commit that introduced this comment for details. */\n     if (getrec) {\n+        random_sign(&sigr, &sigs, &key, &msg, &recid);\n         CHECK(recid >= 0 && recid < 4);\n+    } else {\n+        random_sign(&sigr, &sigs, &key, &msg, NULL);\n     }\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n }\n \n void run_ecdsa_sign_verify(void) {\n@@ -5609,14 +5675,6 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n-#ifdef ENABLE_OPENSSL_TESTS\n-    static const unsigned char max_scalar[32] = {\n-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n-        0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n-        0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n-    };\n-#endif\n \n     int ret = 0;\n \n@@ -5632,15 +5690,6 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     size_t len_der_lax = 2048;\n     int parsed_der_lax = 0, valid_der_lax = 0, roundtrips_der_lax = 0;\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-    ECDSA_SIG *sig_openssl;\n-    const BIGNUM *r = NULL, *s = NULL;\n-    const unsigned char *sigptr;\n-    unsigned char roundtrip_openssl[2048];\n-    int len_openssl = 2048;\n-    int parsed_openssl, valid_openssl = 0, roundtrips_openssl = 0;\n-#endif\n-\n     parsed_der = secp256k1_ecdsa_signature_parse_der(ctx, &sig_der, sig, siglen);\n     if (parsed_der) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_compact(ctx, compact_der, &sig_der)) << 0;\n@@ -5681,43 +5730,6 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n         ret |= (!parsed_der_lax) << 16;\n     }\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-    sig_openssl = ECDSA_SIG_new();\n-    sigptr = sig;\n-    parsed_openssl = (d2i_ECDSA_SIG(&sig_openssl, &sigptr, siglen) != NULL);\n-    if (parsed_openssl) {\n-        ECDSA_SIG_get0(sig_openssl, &r, &s);\n-        valid_openssl = !BN_is_negative(r) && !BN_is_negative(s) && BN_num_bits(r) > 0 && BN_num_bits(r) <= 256 && BN_num_bits(s) > 0 && BN_num_bits(s) <= 256;\n-        if (valid_openssl) {\n-            unsigned char tmp[32] = {0};\n-            BN_bn2bin(r, tmp + 32 - BN_num_bytes(r));\n-            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n-        }\n-        if (valid_openssl) {\n-            unsigned char tmp[32] = {0};\n-            BN_bn2bin(s, tmp + 32 - BN_num_bytes(s));\n-            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n-        }\n-    }\n-    len_openssl = i2d_ECDSA_SIG(sig_openssl, NULL);\n-    if (len_openssl <= 2048) {\n-        unsigned char *ptr = roundtrip_openssl;\n-        CHECK(i2d_ECDSA_SIG(sig_openssl, &ptr) == len_openssl);\n-        roundtrips_openssl = valid_openssl && ((size_t)len_openssl == siglen) && (secp256k1_memcmp_var(roundtrip_openssl, sig, siglen) == 0);\n-    } else {\n-        len_openssl = 0;\n-    }\n-    ECDSA_SIG_free(sig_openssl);\n-\n-    ret |= (parsed_der && !parsed_openssl) << 4;\n-    ret |= (valid_der && !valid_openssl) << 5;\n-    ret |= (roundtrips_openssl && !parsed_der) << 6;\n-    ret |= (roundtrips_der != roundtrips_openssl) << 7;\n-    if (roundtrips_openssl) {\n-        ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= ((len_der != (size_t)len_openssl) || (secp256k1_memcmp_var(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n-    }\n-#endif\n     return ret;\n }\n \n@@ -5955,7 +5967,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &keyj, &sr);\n         secp256k1_ge_set_gej(&key, &keyj);\n         msg = ss;\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with r of zero fails. */\n@@ -5974,7 +5986,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 0);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey_mods_zero, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify( &sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with s of zero fails. */\n@@ -5993,7 +6005,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 1);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with message 0 passes. */\n@@ -6021,14 +6033,14 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&sr, 2);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message 1 passes. */\n@@ -6062,15 +6074,15 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 2);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message -1 passes. */\n@@ -6096,12 +6108,12 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_negate(&msg, &msg);\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 3);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Signature where s would be zero. */\n@@ -6311,62 +6323,6 @@ void run_ecdsa_edge_cases(void) {\n     test_ecdsa_edge_cases();\n }\n \n-#ifdef ENABLE_OPENSSL_TESTS\n-EC_KEY *get_openssl_key(const unsigned char *key32) {\n-    unsigned char privkey[300];\n-    size_t privkeylen;\n-    const unsigned char* pbegin = privkey;\n-    int compr = secp256k1_testrand_bits(1);\n-    EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n-    CHECK(ec_privkey_export_der(ctx, privkey, &privkeylen, key32, compr));\n-    CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n-    CHECK(EC_KEY_check_key(ec_key));\n-    return ec_key;\n-}\n-\n-void test_ecdsa_openssl(void) {\n-    secp256k1_gej qj;\n-    secp256k1_ge q;\n-    secp256k1_scalar sigr, sigs;\n-    secp256k1_scalar one;\n-    secp256k1_scalar msg2;\n-    secp256k1_scalar key, msg;\n-    EC_KEY *ec_key;\n-    unsigned int sigsize = 80;\n-    size_t secp_sigsize = 80;\n-    unsigned char message[32];\n-    unsigned char signature[80];\n-    unsigned char key32[32];\n-    secp256k1_testrand256_test(message);\n-    secp256k1_scalar_set_b32(&msg, message, NULL);\n-    random_scalar_order_test(&key);\n-    secp256k1_scalar_get_b32(key32, &key);\n-    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &qj, &key);\n-    secp256k1_ge_set_gej(&q, &qj);\n-    ec_key = get_openssl_key(key32);\n-    CHECK(ec_key != NULL);\n-    CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n-    CHECK(secp256k1_ecdsa_sig_parse(&sigr, &sigs, signature, sigsize));\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg));\n-    secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_scalar_add(&msg2, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg2));\n-\n-    random_sign(&sigr, &sigs, &key, &msg, NULL);\n-    CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sigr, &sigs));\n-    CHECK(ECDSA_verify(0, message, sizeof(message), signature, secp_sigsize, ec_key) == 1);\n-\n-    EC_KEY_free(ec_key);\n-}\n-\n-void run_ecdsa_openssl(void) {\n-    int i;\n-    for (i = 0; i < 10*count; i++) {\n-        test_ecdsa_openssl();\n-    }\n-}\n-#endif\n-\n #ifdef ENABLE_MODULE_ECDH\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n@@ -6618,6 +6574,7 @@ int main(int argc, char **argv) {\n     run_group_decompress();\n \n     /* ecmult tests */\n+    run_ecmult_pre_g();\n     run_wnaf();\n     run_point_times_order();\n     run_ecmult_near_split_bound();\n@@ -6652,9 +6609,6 @@ int main(int argc, char **argv) {\n     run_ecdsa_sign_verify();\n     run_ecdsa_end_to_end();\n     run_ecdsa_edge_cases();\n-#ifdef ENABLE_OPENSSL_TESTS\n-    run_ecdsa_openssl();\n-#endif\n \n #ifdef ENABLE_MODULE_RECOVERY\n     /* ECDSA pubkey recovery tests */"
      },
      {
        "sha": "4d96dd947b46f8beea95ca5631a7bf1b310e9463",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -163,7 +163,7 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     }\n }\n \n-void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj) {\n+void test_exhaustive_ecmult(const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j, r_log;\n     uint64_t iter = 0;\n     for (r_log = 1; r_log < EXHAUSTIVE_TEST_ORDER; r_log++) {\n@@ -175,7 +175,7 @@ void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *gr\n                 secp256k1_scalar_set_int(&na, i);\n                 secp256k1_scalar_set_int(&ng, j);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                secp256k1_ecmult(&tmp, &groupj[r_log], &na, &ng);\n                 ge_equals_gej(&group[(i * r_log + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n \n                 if (i > 0) {\n@@ -219,7 +219,7 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                     }\n                 }\n@@ -430,7 +430,7 @@ int main(int argc, char** argv) {\n         /* Run the tests */\n         test_exhaustive_endomorphism(group);\n         test_exhaustive_addition(group, groupj);\n-        test_exhaustive_ecmult(ctx, group, groupj);\n+        test_exhaustive_ecmult(group, groupj);\n         test_exhaustive_ecmult_multi(ctx, group);\n         test_exhaustive_sign(ctx, group);\n         test_exhaustive_verify(ctx, group);"
      },
      {
        "sha": "f6b72a6d488336fd79907ccfcbf236a55aacd999",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52047b4ba15412bd8a010665840caa33da73e645/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=52047b4ba15412bd8a010665840caa33da73e645",
        "patch": "@@ -140,6 +140,8 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n     VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n     VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n     VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    /* Avoid unused parameter warnings when building without VERIFY */\n+    (void) base; (void) max_size;\n     ret = *prealloc_ptr;\n     *prealloc_ptr = (unsigned char*)*prealloc_ptr + aligned_alloc_size;\n     return ret;"
      }
    ]
  },
  {
    "sha": "57b293329c3851fb04ea3b7a0629594eedc6837a",
    "node_id": "C_kwDOABII59oAKDU3YjI5MzMyOWMzODUxZmIwNGVhM2I3YTA2Mjk1OTRlZWRjNjgzN2E",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-28T17:53:25Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-31T17:07:19Z"
      },
      "message": "Remove --disable-openssl-tests for libsecp256k1 configure",
      "tree": {
        "sha": "622b3d8979ff5b5c6d44d2757c81913363eba248",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/622b3d8979ff5b5c6d44d2757c81913363eba248"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57b293329c3851fb04ea3b7a0629594eedc6837a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57b293329c3851fb04ea3b7a0629594eedc6837a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57b293329c3851fb04ea3b7a0629594eedc6837a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57b293329c3851fb04ea3b7a0629594eedc6837a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "52047b4ba15412bd8a010665840caa33da73e645",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52047b4ba15412bd8a010665840caa33da73e645",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52047b4ba15412bd8a010665840caa33da73e645"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ace81362e46de1ed49a839d7f05231086bf5611d",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57b293329c3851fb04ea3b7a0629594eedc6837a/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57b293329c3851fb04ea3b7a0629594eedc6837a/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=57b293329c3851fb04ea3b7a0629594eedc6837a",
        "patch": "@@ -1870,7 +1870,7 @@ PKGCONFIG_LIBDIR_TEMP=\"$PKG_CONFIG_LIBDIR\"\n unset PKG_CONFIG_LIBDIR\n PKG_CONFIG_LIBDIR=\"$PKGCONFIG_LIBDIR_TEMP\"\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental --disable-openssl-tests\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      }
    ]
  },
  {
    "sha": "63831b1088fa5b8f3b6b5364412700492849ab3c",
    "node_id": "C_kwDOABII59oAKDYzODMxYjEwODhmYTViOGYzYjZiNTM2NDQxMjcwMDQ5Mjg0OWFiM2M",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-28T17:55:47Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-31T17:07:19Z"
      },
      "message": "Remove unnecessary cast in CKey::SignSchnorr",
      "tree": {
        "sha": "94e20c68434033b7a7d9405facaa1b7dac01a3c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94e20c68434033b7a7d9405facaa1b7dac01a3c1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63831b1088fa5b8f3b6b5364412700492849ab3c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63831b1088fa5b8f3b6b5364412700492849ab3c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/63831b1088fa5b8f3b6b5364412700492849ab3c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63831b1088fa5b8f3b6b5364412700492849ab3c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57b293329c3851fb04ea3b7a0629594eedc6837a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57b293329c3851fb04ea3b7a0629594eedc6837a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57b293329c3851fb04ea3b7a0629594eedc6837a"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "87e67bc5e318c5c7a86ed966055f43b94ced5ee9",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/63831b1088fa5b8f3b6b5364412700492849ab3c/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/63831b1088fa5b8f3b6b5364412700492849ab3c/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=63831b1088fa5b8f3b6b5364412700492849ab3c",
        "patch": "@@ -274,7 +274,7 @@ bool CKey::SignSchnorr(const uint256& hash, Span<unsigned char> sig, const uint2\n         uint256 tweak = XOnlyPubKey(pubkey_bytes).ComputeTapTweakHash(merkle_root->IsNull() ? nullptr : merkle_root);\n         if (!secp256k1_keypair_xonly_tweak_add(GetVerifyContext(), &keypair, tweak.data())) return false;\n     }\n-    bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, aux ? (unsigned char*)aux->data() : nullptr);\n+    bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, aux ? aux->data() : nullptr);\n     memory_cleanse(&keypair, sizeof(keypair));\n     return ret;\n }"
      }
    ]
  }
]