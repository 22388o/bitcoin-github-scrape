[
  {
    "sha": "7813eb1db132c023902ad945995cc32a325893ca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODEzZWIxZGIxMzJjMDIzOTAyYWQ5NDU5OTVjYzMyYTMyNTg5M2Nh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-23T18:55:51Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-04-01T21:08:54Z"
      },
      "message": "[qa] Overhaul p2p_compactblocks.py\n\nRemove tests of:\n - compactblock behavior in a simulated pre-segwit version of bitcoind\n   This should have been removed a long time ago, as it is not generally\n   necessary for us to test the behavior of old nodes (except perhaps if we\n   want to test that upgrading from an old node to a new one behaves properly)\n\n - compactblock behavior during segwit upgrade (ie verifying that network\n   behavior before and after activation was as expected)\n   This is unnecessary to test now that segwit activation has already happened.\n\nIncludes changes by John Newbery.",
      "tree": {
        "sha": "6e8bac55d152d7333ac0f2cb9cb2470fb532abfa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e8bac55d152d7333ac0f2cb9cb2470fb532abfa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7813eb1db132c023902ad945995cc32a325893ca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7813eb1db132c023902ad945995cc32a325893ca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7813eb1db132c023902ad945995cc32a325893ca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7813eb1db132c023902ad945995cc32a325893ca/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7b13c646457980f44599412f243694fa682a1abf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b13c646457980f44599412f243694fa682a1abf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b13c646457980f44599412f243694fa682a1abf"
      }
    ],
    "stats": {
      "total": 207,
      "additions": 68,
      "deletions": 139
    },
    "files": [
      {
        "sha": "3ca6bec254293f50d6634d9d12ec15b575bec056",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 68,
        "deletions": 139,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7813eb1db132c023902ad945995cc32a325893ca/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7813eb1db132c023902ad945995cc32a325893ca/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=7813eb1db132c023902ad945995cc32a325893ca",
        "patch": "@@ -7,26 +7,26 @@\n Version 1 compact blocks are pre-segwit (txids)\n Version 2 compact blocks are post-segwit (wtxids)\n \"\"\"\n-from decimal import Decimal\n import random\n \n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n-from test_framework.messages import BlockTransactions, BlockTransactionsRequest, calculate_shortid, CBlock, CBlockHeader, CInv, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, HeaderAndShortIDs, msg_block, msg_blocktxn, msg_cmpctblock, msg_getblocktxn, msg_getdata, msg_getheaders, msg_headers, msg_inv, msg_sendcmpct, msg_sendheaders, msg_tx, msg_witness_block, msg_witness_blocktxn, MSG_WITNESS_FLAG, NODE_NETWORK, NODE_WITNESS, P2PHeaderAndShortIDs, PrefilledTransaction, ser_uint256, ToHex\n+from test_framework.messages import BlockTransactions, BlockTransactionsRequest, calculate_shortid, CBlock, CBlockHeader, CInv, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, HeaderAndShortIDs, msg_block, msg_blocktxn, msg_cmpctblock, msg_getblocktxn, msg_getdata, msg_getheaders, msg_headers, msg_inv, msg_sendcmpct, msg_sendheaders, msg_tx, msg_witness_block, msg_witness_blocktxn, MSG_WITNESS_FLAG, NODE_NETWORK, P2PHeaderAndShortIDs, PrefilledTransaction, ser_uint256, ToHex\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.script import CScript, OP_TRUE, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, get_bip9_status, satoshi_round, sync_blocks, wait_until\n+from test_framework.util import assert_equal, get_bip9_status, wait_until\n \n # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n class TestP2PConn(P2PInterface):\n-    def __init__(self):\n+    def __init__(self, cmpct_version):\n         super().__init__()\n         self.last_sendcmpct = []\n         self.block_announced = False\n         # Store the hashes of blocks we've seen announced.\n         # This is for synchronizing the p2p message traffic,\n         # so we can eg wait until a particular block is announced.\n         self.announced_blockhashes = set()\n+        self.cmpct_version = cmpct_version\n \n     def on_sendcmpct(self, message):\n         self.last_sendcmpct.append(message)\n@@ -94,11 +94,7 @@ def send_await_disconnect(self, message, timeout=30):\n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        # Node0 = pre-segwit, node1 = segwit-aware\n-        self.num_nodes = 2\n-        # This test was written assuming SegWit is activated using BIP9 at height 432 (3x confirmation window).\n-        # TODO: Rewrite this test to support SegWit being always active.\n-        self.extra_args = [[\"-vbparams=segwit:0:0\"], [\"-vbparams=segwit:0:999999999999\", \"-txindex\"]]\n+        self.num_nodes = 1\n         self.utxos = []\n \n     def skip_test_if_missing_module(self):\n@@ -117,11 +113,10 @@ def build_block_on_tip(self, node, segwit=False):\n \n     # Create 10 more anyone-can-spend utxo's for testing.\n     def make_utxos(self):\n-        # Doesn't matter which node we use, just use node0.\n         block = self.build_block_on_tip(self.nodes[0])\n-        self.test_node.send_and_ping(msg_block(block))\n+        self.segwit_node.send_and_ping(msg_block(block))\n         assert int(self.nodes[0].getbestblockhash(), 16) == block.sha256\n-        self.nodes[0].generate(100)\n+        self.nodes[0].generatetoaddress(100, self.nodes[0].getnewaddress(address_type=\"bech32\"))\n \n         total_value = block.vtx[0].vout[0].nValue\n         out_value = total_value // 10\n@@ -135,10 +130,10 @@ def make_utxos(self):\n         block2.vtx.append(tx)\n         block2.hashMerkleRoot = block2.calc_merkle_root()\n         block2.solve()\n-        self.test_node.send_and_ping(msg_block(block2))\n+        self.segwit_node.send_and_ping(msg_block(block2))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block2.sha256)\n         self.utxos.extend([[tx.sha256, i, out_value] for i in range(10)])\n-        return\n+\n \n     # Test \"sendcmpct\" (between peers preferring the same version):\n     # - No compact block announcements unless sendcmpct is sent.\n@@ -149,7 +144,10 @@ def make_utxos(self):\n     #   are made with compact blocks.\n     # If old_node is passed in, request compact blocks with version=preferred-1\n     # and verify that it receives block announcements via compact block.\n-    def test_sendcmpct(self, node, test_node, preferred_version, old_node=None):\n+    def test_sendcmpct(self, test_node, old_node=None):\n+        preferred_version = test_node.cmpct_version\n+        node = self.nodes[0]\n+\n         # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n             return (len(test_node.last_sendcmpct) > 0)\n@@ -251,23 +249,18 @@ def test_invalid_cmpctblock_message(self):\n         # This index will be too high\n         prefilled_txn = PrefilledTransaction(1, block.vtx[0])\n         cmpct_block.prefilled_txn = [prefilled_txn]\n-        self.test_node.send_await_disconnect(msg_cmpctblock(cmpct_block))\n+        self.segwit_node.send_await_disconnect(msg_cmpctblock(cmpct_block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n \n     # Compare the generated shortids to what we expect based on BIP 152, given\n     # bitcoind's choice of nonce.\n-    def test_compactblock_construction(self, node, test_node, version, use_witness_address):\n+    def test_compactblock_construction(self, test_node, use_witness_address=True):\n+        version = test_node.cmpct_version\n+        node = self.nodes[0]\n         # Generate a bunch of transactions.\n         node.generate(101)\n         num_transactions = 25\n         address = node.getnewaddress()\n-        if use_witness_address:\n-            # Want at least one segwit spend, so move all funds to\n-            # a witness address.\n-            address = node.getnewaddress(address_type='bech32')\n-            value_to_send = node.getbalance()\n-            node.sendtoaddress(address, satoshi_round(value_to_send - Decimal(0.1)))\n-            node.generate(1)\n \n         segwit_tx_generated = False\n         for i in range(num_transactions):\n@@ -285,7 +278,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         test_node.wait_for_block_announcement(tip)\n \n         # Make sure we will receive a fast-announce compact block\n-        self.request_cb_announcements(test_node, node, version)\n+        self.request_cb_announcements(test_node)\n \n         # Now mine a block, and look at the resulting compact block.\n         test_node.clear_block_announcement()\n@@ -375,7 +368,9 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n     # Post-segwit: upgraded nodes would only make this request of cb-version-2,\n     # NODE_WITNESS peers.  Unupgraded nodes would still make this request of\n     # any cb-version-1-supporting peer.\n-    def test_compactblock_requests(self, node, test_node, version, segwit):\n+    def test_compactblock_requests(self, test_node, segwit=True):\n+        version = test_node.cmpct_version\n+        node = self.nodes[0]\n         # Try announcing a block with an inv or header, expect a compactblock\n         # request\n         for announce in [\"inv\", \"header\"]:\n@@ -440,7 +435,9 @@ def build_block_with_transactions(self, node, utxo, num_transactions):\n     # Test that we only receive getblocktxn requests for transactions that the\n     # node needs, and that responding to them causes the block to be\n     # reconstructed.\n-    def test_getblocktxn_requests(self, node, test_node, version):\n+    def test_getblocktxn_requests(self, test_node):\n+        version = test_node.cmpct_version\n+        node = self.nodes[0]\n         with_witness = (version == 2)\n \n         def test_getblocktxn_response(compact_block, peer, expected_result):\n@@ -523,9 +520,9 @@ def test_tip_after_message(node, peer, msg, tip):\n \n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n-    def test_incorrect_blocktxn_response(self, node, test_node, version):\n-        if (len(self.utxos) == 0):\n-            self.make_utxos()\n+    def test_incorrect_blocktxn_response(self, test_node):\n+        version = test_node.cmpct_version\n+        node = self.nodes[0]\n         utxo = self.utxos.pop(0)\n \n         block = self.build_block_with_transactions(node, utxo, 10)\n@@ -579,7 +576,9 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n             test_node.send_and_ping(msg_block(block))\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n-    def test_getblocktxn_handler(self, node, test_node, version):\n+    def test_getblocktxn_handler(self, test_node):\n+        version = test_node.cmpct_version\n+        node = self.nodes[0]\n         # bitcoind will not send blocktxn responses for blocks whose height is\n         # more than 10 blocks deep.\n         MAX_GETBLOCKTXN_DEPTH = 10\n@@ -626,7 +625,8 @@ def test_getblocktxn_handler(self, node, test_node, version):\n             assert_equal(test_node.last_message[\"block\"].block.sha256, int(block_hash, 16))\n             assert \"blocktxn\" not in test_node.last_message\n \n-    def test_compactblocks_not_at_tip(self, node, test_node):\n+    def test_compactblocks_not_at_tip(self, test_node):\n+        node = self.nodes[0]\n         # Test that requesting old compactblocks doesn't work.\n         MAX_CMPCTBLOCK_DEPTH = 5\n         new_blocks = []\n@@ -681,11 +681,8 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n         with mininode_lock:\n             assert \"blocktxn\" not in test_node.last_message\n \n-    def activate_segwit(self, node):\n-        node.generate(144 * 3)\n-        assert_equal(get_bip9_status(node, \"segwit\")[\"status\"], 'active')\n-\n-    def test_end_to_end_block_relay(self, node, listeners):\n+    def test_end_to_end_block_relay(self, listeners):\n+        node = self.nodes[0]\n         utxo = self.utxos.pop(0)\n \n         block = self.build_block_with_transactions(node, utxo, 10)\n@@ -706,7 +703,8 @@ def test_end_to_end_block_relay(self, node, listeners):\n \n     # Test that we don't get disconnected if we relay a compact block with valid header,\n     # but invalid transactions.\n-    def test_invalid_tx_in_compactblock(self, node, test_node, use_segwit):\n+    def test_invalid_tx_in_compactblock(self, test_node, use_segwit=True):\n+        node = self.nodes[0]\n         assert len(self.utxos)\n         utxo = self.utxos[0]\n \n@@ -733,16 +731,18 @@ def test_invalid_tx_in_compactblock(self, node, test_node, use_segwit):\n \n     # Helper for enabling cb announcements\n     # Send the sendcmpct request and sync headers\n-    def request_cb_announcements(self, peer, node, version):\n+    def request_cb_announcements(self, peer):\n+        node = self.nodes[0]\n         tip = node.getbestblockhash()\n         peer.get_headers(locator=[int(tip, 16)], hashstop=0)\n \n         msg = msg_sendcmpct()\n-        msg.version = version\n+        msg.version = peer.cmpct_version\n         msg.announce = True\n         peer.send_and_ping(msg)\n \n-    def test_compactblock_reconstruction_multiple_peers(self, node, stalling_peer, delivery_peer):\n+    def test_compactblock_reconstruction_multiple_peers(self, stalling_peer, delivery_peer):\n+        node = self.nodes[0]\n         assert len(self.utxos)\n \n         def announce_cmpct_block(node, peer):\n@@ -793,126 +793,55 @@ def announce_cmpct_block(node, peer):\n \n     def run_test(self):\n         # Setup the p2p connections\n-        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n-        self.segwit_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n-        self.old_node = self.nodes[1].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))\n+        self.old_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=1), services=NODE_NETWORK)\n+        self.additional_segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))\n \n         # We will need UTXOs to construct transactions in later tests.\n         self.make_utxos()\n \n-        self.log.info(\"Running tests, pre-segwit activation:\")\n+        assert_equal(get_bip9_status(self.nodes[0], \"segwit\")[\"status\"], 'active')\n \n         self.log.info(\"Testing SENDCMPCT p2p message... \")\n-        self.test_sendcmpct(self.nodes[0], self.test_node, 1)\n-        sync_blocks(self.nodes)\n-        self.test_sendcmpct(self.nodes[1], self.segwit_node, 2, old_node=self.old_node)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing compactblock construction...\")\n-        self.test_compactblock_construction(self.nodes[0], self.test_node, 1, False)\n-        sync_blocks(self.nodes)\n-        self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, False)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing compactblock requests... \")\n-        self.test_compactblock_requests(self.nodes[0], self.test_node, 1, False)\n-        sync_blocks(self.nodes)\n-        self.test_compactblock_requests(self.nodes[1], self.segwit_node, 2, False)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing getblocktxn requests...\")\n-        self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n-        sync_blocks(self.nodes)\n-        self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing getblocktxn handler...\")\n-        self.test_getblocktxn_handler(self.nodes[0], self.test_node, 1)\n-        sync_blocks(self.nodes)\n-        self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n-        self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing compactblock requests/announcements not at chain tip...\")\n-        self.test_compactblocks_not_at_tip(self.nodes[0], self.test_node)\n-        sync_blocks(self.nodes)\n-        self.test_compactblocks_not_at_tip(self.nodes[1], self.segwit_node)\n-        self.test_compactblocks_not_at_tip(self.nodes[1], self.old_node)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing handling of incorrect blocktxn responses...\")\n-        self.test_incorrect_blocktxn_response(self.nodes[0], self.test_node, 1)\n-        sync_blocks(self.nodes)\n-        self.test_incorrect_blocktxn_response(self.nodes[1], self.segwit_node, 2)\n-        sync_blocks(self.nodes)\n-\n-        # End-to-end block relay tests\n-        self.log.info(\"Testing end-to-end block relay...\")\n-        self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n-        self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n-        self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n-        self.test_end_to_end_block_relay(self.nodes[0], [self.segwit_node, self.test_node, self.old_node])\n-        self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n-\n-        self.log.info(\"Testing handling of invalid compact blocks...\")\n-        self.test_invalid_tx_in_compactblock(self.nodes[0], self.test_node, False)\n-        self.test_invalid_tx_in_compactblock(self.nodes[1], self.segwit_node, False)\n-        self.test_invalid_tx_in_compactblock(self.nodes[1], self.old_node, False)\n-\n-        self.log.info(\"Testing reconstructing compact blocks from all peers...\")\n-        self.test_compactblock_reconstruction_multiple_peers(self.nodes[1], self.segwit_node, self.old_node)\n-        sync_blocks(self.nodes)\n-\n-        # Advance to segwit activation\n-        self.log.info(\"Advancing to segwit activation\")\n-        self.activate_segwit(self.nodes[1])\n-        self.log.info(\"Running tests, post-segwit activation...\")\n+        self.test_sendcmpct(self.segwit_node, old_node=self.old_node)\n+        self.test_sendcmpct(self.additional_segwit_node)\n \n         self.log.info(\"Testing compactblock construction...\")\n-        self.test_compactblock_construction(self.nodes[1], self.old_node, 1, True)\n-        self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, True)\n-        sync_blocks(self.nodes)\n-\n-        self.log.info(\"Testing compactblock requests (unupgraded node)... \")\n-        self.test_compactblock_requests(self.nodes[0], self.test_node, 1, True)\n-\n-        self.log.info(\"Testing getblocktxn requests (unupgraded node)...\")\n-        self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n-\n-        # Need to manually sync node0 and node1, because post-segwit activation,\n-        # node1 will not download blocks from node0.\n-        self.log.info(\"Syncing nodes...\")\n-        assert self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash()\n-        while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n-            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount() + 1)\n-            self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))\n-        assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n+        self.test_compactblock_construction(self.old_node)\n+        self.test_compactblock_construction(self.segwit_node)\n \n         self.log.info(\"Testing compactblock requests (segwit node)... \")\n-        self.test_compactblock_requests(self.nodes[1], self.segwit_node, 2, True)\n+        self.test_compactblock_requests(self.segwit_node)\n \n         self.log.info(\"Testing getblocktxn requests (segwit node)...\")\n-        self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n-        sync_blocks(self.nodes)\n+        self.test_getblocktxn_requests(self.segwit_node)\n \n         self.log.info(\"Testing getblocktxn handler (segwit node should return witnesses)...\")\n-        self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n-        self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n+        self.test_getblocktxn_handler(self.segwit_node)\n+        self.test_getblocktxn_handler(self.old_node)\n+\n+        self.log.info(\"Testing compactblock requests/announcements not at chain tip...\")\n+        self.test_compactblocks_not_at_tip(self.segwit_node)\n+        self.test_compactblocks_not_at_tip(self.old_node)\n+\n+        self.log.info(\"Testing handling of incorrect blocktxn responses...\")\n+        self.test_incorrect_blocktxn_response(self.segwit_node)\n+\n+        self.log.info(\"Testing reconstructing compact blocks from all peers...\")\n+        self.test_compactblock_reconstruction_multiple_peers(self.segwit_node, self.additional_segwit_node)\n \n         # Test that if we submitblock to node1, we'll get a compact block\n         # announcement to all peers.\n         # (Post-segwit activation, blocks won't propagate from node0 to node1\n         # automatically, so don't bother testing a block announced to node0.)\n         self.log.info(\"Testing end-to-end block relay...\")\n-        self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n-        self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n-        self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n-        self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n+        self.request_cb_announcements(self.old_node)\n+        self.request_cb_announcements(self.segwit_node)\n+        self.test_end_to_end_block_relay([self.segwit_node, self.old_node])\n \n         self.log.info(\"Testing handling of invalid compact blocks...\")\n-        self.test_invalid_tx_in_compactblock(self.nodes[0], self.test_node, False)\n-        self.test_invalid_tx_in_compactblock(self.nodes[1], self.segwit_node, True)\n-        self.test_invalid_tx_in_compactblock(self.nodes[1], self.old_node, True)\n+        self.test_invalid_tx_in_compactblock(self.segwit_node)\n+        self.test_invalid_tx_in_compactblock(self.old_node)\n \n         self.log.info(\"Testing invalid index in cmpctblock message...\")\n         self.test_invalid_cmpctblock_message()"
      }
    ]
  }
]