[
  {
    "sha": "b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMWFhMTZiMGFkMDA5NzBmZWIxNGEyM2Y3YWNjYzBlN2ZlNTQ3NzFk",
    "commit": {
      "author": {
        "name": "Tim Marchant",
        "email": "tmarchant@protonmail.com",
        "date": "2019-08-15T22:26:01Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2019-08-15T22:26:01Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nBringing fork up to date",
      "tree": {
        "sha": "365d1217fc9886ebf0335c7bdbb94ab834b305a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/365d1217fc9886ebf0335c7bdbb94ab834b305a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdVdv5CRBK7hj4Ov3rIwAAdHIIAChGtexHW8SnqMnUS8fNSM54\nBfYMjtm6b9HxW7s9SqoMP/EuhzNYzTk6+5BWGpHnE5NLb26/Hl5plh74/EC/nPDd\nyf1Wq1SGd5DT6+knmVId/jvdevhClQRyRPndOTztrocQhBnWxWDRy0vxzlsBWBDi\njp6YSM6HlbDiDkvC9dlevKqhpD1YqEVCm3JgDmlb8V6OvBm5p4buXPbM0qggzbxe\nfJ8QDhrtNjQxZV+pR1zOZQDUHWUWrMYhSbeiCgrcZW7ptyrmNR+M9ObeUKERJ4Pc\nwMB2KA36TzDMKEUczm/u/5CdfHgCakxCbSoUCjoseq4NZc5scZfTyNUew1ZiGuY=\n=X9eP\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 365d1217fc9886ebf0335c7bdbb94ab834b305a9\nparent f418c3379cbad8caaf3e988caf727fe62b218f8c\nparent 1bf2ff2bf8e8bef3ba21e635aabb1b0964062743\nauthor Tim Marchant <tmarchant@protonmail.com> 1565907961 -0500\ncommitter GitHub <noreply@github.com> 1565907961 -0500\n\nMerge pull request #1 from bitcoin/master\n\nBringing fork up to date"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/comments",
    "author": null,
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f418c3379cbad8caaf3e988caf727fe62b218f8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f418c3379cbad8caaf3e988caf727fe62b218f8c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f418c3379cbad8caaf3e988caf727fe62b218f8c"
      },
      {
        "sha": "1bf2ff2bf8e8bef3ba21e635aabb1b0964062743",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bf2ff2bf8e8bef3ba21e635aabb1b0964062743",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1bf2ff2bf8e8bef3ba21e635aabb1b0964062743"
      }
    ],
    "stats": {
      "total": 1613,
      "additions": 1083,
      "deletions": 530
    },
    "files": [
      {
        "sha": "1e6e6937da4e3852958e4ffda2ffc273c7e6ece4",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -27,3 +27,27 @@ task:\n     - gmake check ${MAKEJOBS} VERBOSE=1\n   functional_test_script:\n     - ./test/functional/test_runner.py --jobs 9 --ci --extended --exclude feature_dbcrash --combinedlogslen=1000 --quiet --failfast\n+task:\n+  name: \"x86_64 Linux  [GOAL: install]  [bionic]  [Using ./ci/ system]\"\n+  container:\n+    image: ubuntu:18.04\n+    cpu: 8\n+    memory: 8G\n+  timeout_in: 60m\n+  env:\n+    MAKEJOBS: \"-j9\"\n+    RUN_CI_ON_HOST: \"1\"\n+    CCACHE_SIZE: \"200M\"\n+    CCACHE_DIR: \"/tmp/ccache_dir\"\n+  ccache_cache:\n+    folder: \"/tmp/ccache_dir\"\n+  depends_built_cache:\n+    folder: \"/tmp/cirrus-ci-build/depends/built\"\n+  depends_sdk_cache:\n+    folder: \"/tmp/cirrus-ci-build/depends/sdk-sources\"\n+  install_script:\n+    - apt-get update\n+    - apt-get -y install git bash ccache\n+    - ccache --max-size=${CCACHE_SIZE}\n+  ci_script:\n+    - ./ci/test_run_all.sh"
      },
      {
        "sha": "7753dcc51f3bc8c50a82a5c4d5589a0897f30a08",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 26,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -40,38 +40,25 @@ stages:\n   - extended-lint\n env:\n   global:\n-    - MAKEJOBS=-j3\n-    - RUN_UNIT_TESTS=true\n-    - RUN_FUNCTIONAL_TESTS=true\n-    - RUN_FUZZ_TESTS=false\n-    - DOCKER_NAME_TAG=ubuntu:18.04\n-    - BOOST_TEST_RANDOM=1$TRAVIS_BUILD_ID\n-    - CCACHE_SIZE=100M\n-    - CCACHE_TEMPDIR=/tmp/.ccache-temp\n-    - CCACHE_COMPRESS=1\n-    - CCACHE_DIR=$HOME/.ccache\n-    - BASE_OUTDIR=$TRAVIS_BUILD_DIR/out\n-    - SDK_URL=https://bitcoincore.org/depends-sources/sdks\n-    - WINEDEBUG=fixme-all\n-    - DOCKER_PACKAGES=\"build-essential libtool autotools-dev automake pkg-config bsdmainutils curl git ca-certificates ccache\"\n+    - CI_RETRY_EXE=\"travis_retry\"\n     - CACHE_ERR_MSG=\"Error! Initial build successful, but not enough time remains to run later build stages and tests. Please manually re-run this job by using the travis restart button or asking a bitcoin maintainer to restart. The next run should not time out because the build cache has been saved.\"\n before_install:\n-  - set -o errexit; source .travis/test_03_before_install.sh\n+  - set -o errexit; source ./ci/test/00_setup_env.sh\n+  - set -o errexit; source ./ci/test/03_before_install.sh\n install:\n-  - set -o errexit; source .travis/test_04_install.sh\n+  - set -o errexit; source ./ci/test/04_install.sh\n before_script:\n-  - set -o errexit; source .travis/test_05_before_script.sh\n+  - set -o errexit; source ./ci/test/05_before_script.sh\n script:\n   - export CONTINUE=1\n   - if [ $SECONDS -gt 1200 ]; then export CONTINUE=0; fi  # Likely the depends build took very long\n   - if [ $TRAVIS_REPO_SLUG = \"bitcoin/bitcoin\" ]; then export CONTINUE=1; fi  # Whitelisted repo (90 minutes build time)\n-  - if [ $CONTINUE = \"1\" ]; then set -o errexit; source .travis/test_06_script_a.sh; else set +o errexit; echo \"$CACHE_ERR_MSG\"; false; fi\n+  - if [ $CONTINUE = \"1\" ]; then set -o errexit; source ./ci/test/06_script_a.sh; else set +o errexit; echo \"$CACHE_ERR_MSG\"; false; fi\n   - if [ $SECONDS -gt 2000 ]; then export CONTINUE=0; fi  # Likely the build took very long; The tests take about 1000s, so we should abort if we have less than 50*60-1000=2000s left\n   - if [ $TRAVIS_REPO_SLUG = \"bitcoin/bitcoin\" ]; then export CONTINUE=1; fi  # Whitelisted repo (90 minutes build time)\n-  - if [ $CONTINUE = \"1\" ]; then set -o errexit; source .travis/test_06_script_b.sh; else set +o errexit; echo \"$CACHE_ERR_MSG\"; false; fi\n+  - if [ $CONTINUE = \"1\" ]; then set -o errexit; source ./ci/test/06_script_b.sh; else set +o errexit; echo \"$CACHE_ERR_MSG\"; false; fi\n after_script:\n   - echo $TRAVIS_COMMIT_RANGE\n-  - echo $TRAVIS_COMMIT_LOG\n jobs:\n   include:\n \n@@ -82,11 +69,11 @@ jobs:\n       language: python\n       python: '3.5' # Oldest supported version according to doc/dependencies.md\n       install:\n-        - set -o errexit; source .travis/lint_04_install.sh\n+        - set -o errexit; source ./ci/lint/04_install.sh\n       before_script:\n-        - set -o errexit; source .travis/lint_05_before_script.sh\n+        - set -o errexit; source ./ci/lint/05_before_script.sh\n       script:\n-        - set -o errexit; source .travis/lint_06_script.sh\n+        - set -o errexit; source ./ci/lint/06_script.sh\n \n     - stage: extended-lint\n       name: 'extended lint [runtime >= 60 seconds]'\n@@ -95,11 +82,11 @@ jobs:\n       language: python\n       python: '3.5'\n       install:\n-        - set -o errexit; source .travis/extended_lint_04_install.sh\n+        - set -o errexit; source ./ci/extended_lint/04_install.sh\n       before_script:\n-        - set -o errexit; source .travis/lint_05_before_script.sh\n+        - set -o errexit; source ./ci/lint/05_before_script.sh\n       script:\n-        - set -o errexit; source .travis/extended_lint_06_script.sh\n+        - set -o errexit; source ./ci/extended_lint/06_script.sh\n \n     - stage: test\n       name: 'ARM  [GOAL: install]  [no unit or functional tests]'"
      },
      {
        "sha": "21d1b9cc03aea1599db7dd258c945f5bce240067",
        "filename": ".travis/README.md",
        "status": "removed",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f418c3379cbad8caaf3e988caf727fe62b218f8c/.travis/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f418c3379cbad8caaf3e988caf727fe62b218f8c/.travis/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/README.md?ref=f418c3379cbad8caaf3e988caf727fe62b218f8c",
        "patch": "@@ -1,8 +0,0 @@\n-## travis build scripts\n-\n-The `.travis` directory contains scripts for each build step in each build stage.\n-Currently the travis build defines two stages `lint` and `test`. Each stage has\n-it's own [lifecycle](https://docs.travis-ci.com/user/customizing-the-build/#the-build-lifecycle).\n-Every script in here is named and numbered according to which stage and lifecycle\n-step it belongs to.\n-"
      },
      {
        "sha": "319f2c5b212526193ff18546bd34cde8898cdbd2",
        "filename": ".travis/test_04_install.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 37,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f418c3379cbad8caaf3e988caf727fe62b218f8c/.travis/test_04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f418c3379cbad8caaf3e988caf727fe62b218f8c/.travis/test_04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis/test_04_install.sh?ref=f418c3379cbad8caaf3e988caf727fe62b218f8c",
        "patch": "@@ -1,37 +0,0 @@\n-#!/usr/bin/env bash\n-#\n-# Copyright (c) 2018 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-export LC_ALL=C.UTF-8\n-\n-free -m -h\n-echo \"Number of CPUs (nproc): $(nproc)\"\n-\n-travis_retry docker pull \"$DOCKER_NAME_TAG\"\n-\n-export DIR_FUZZ_IN=${TRAVIS_BUILD_DIR}/qa-assets\n-git clone https://github.com/bitcoin-core/qa-assets ${DIR_FUZZ_IN}\n-export DIR_FUZZ_IN=${DIR_FUZZ_IN}/fuzz_seed_corpus/\n-\n-mkdir -p \"${TRAVIS_BUILD_DIR}/sanitizer-output/\"\n-export ASAN_OPTIONS=\"\"\n-export LSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/lsan\"\n-export TSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/tsan:log_path=${TRAVIS_BUILD_DIR}/sanitizer-output/tsan\"\n-export UBSAN_OPTIONS=\"suppressions=${TRAVIS_BUILD_DIR}/test/sanitizer_suppressions/ubsan:print_stacktrace=1:halt_on_error=1\"\n-env | grep -E '^(BITCOIN_CONFIG|CCACHE_|WINEDEBUG|LC_ALL|BOOST_TEST_RANDOM|CONFIG_SHELL|(ASAN|LSAN|TSAN|UBSAN)_OPTIONS)' | tee /tmp/env\n-if [[ $HOST = *-mingw32 ]]; then\n-  DOCKER_ADMIN=\"--cap-add SYS_ADMIN\"\n-elif [[ $BITCOIN_CONFIG = *--with-sanitizers=*address* ]]; then # If ran with (ASan + LSan), Docker needs access to ptrace (https://github.com/google/sanitizers/issues/764)\n-  DOCKER_ADMIN=\"--cap-add SYS_PTRACE\"\n-fi\n-DOCKER_ID=$(docker run $DOCKER_ADMIN -idt --mount type=bind,src=$TRAVIS_BUILD_DIR,dst=$TRAVIS_BUILD_DIR --mount type=bind,src=$CCACHE_DIR,dst=$CCACHE_DIR -w $TRAVIS_BUILD_DIR --env-file /tmp/env $DOCKER_NAME_TAG)\n-\n-DOCKER_EXEC () {\n-  docker exec $DOCKER_ID bash -c \"cd $PWD && $*\"\n-}\n-\n-travis_retry DOCKER_EXEC apt-get update\n-travis_retry DOCKER_EXEC apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES $DOCKER_PACKAGES\n-"
      },
      {
        "sha": "754cbc7c95509d84561445c93939e17a7b3f3edb",
        "filename": "ci/README.md",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/README.md?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,25 @@\n+## ci scripts\n+\n+This directory contains scripts for each build step in each build stage.\n+\n+Currently three stages `lint`, `extended_lint` and `test` are defined. Each stage has its own lifecycle, similar to the\n+[Travis CI lifecycle](https://docs.travis-ci.com/user/job-lifecycle#the-job-lifecycle). Every script in here is named\n+and numbered according to which stage and lifecycle step it belongs to.\n+\n+### Running a stage locally\n+\n+To allow for a wide range of tested environments, but also ensure reproducibility to some extent, the test stage\n+requires `docker` to be installed. To install all requirements on Ubuntu, run\n+\n+```\n+sudo apt install docker.io ccache bash git\n+```\n+\n+To run the test stage,\n+\n+```\n+./ci/test_run_all.sh\n+```\n+\n+Be aware that the tests will be build and run in-place, so please run at your own risk.\n+If the repository is not a fresh git clone, you might have to clean files from previous builds or test runs first."
      },
      {
        "sha": "123d874a84da4b8531edf5e51052b581688cef27",
        "filename": "ci/extended_lint/04_install.sh",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/extended_lint/04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/extended_lint/04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/extended_lint/04_install.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "previous_filename": ".travis/extended_lint_04_install.sh"
      },
      {
        "sha": "e8228c9c4d912c81e16b772e79e85231a2b6c1b9",
        "filename": "ci/extended_lint/06_script.sh",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/extended_lint/06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/extended_lint/06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/extended_lint/06_script.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "previous_filename": ".travis/extended_lint_06_script.sh"
      },
      {
        "sha": "20bff368a583d1dfe164ca8bdb4a00f1dc36e682",
        "filename": "ci/lint/04_install.sh",
        "status": "renamed",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/lint/04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/lint/04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/lint/04_install.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -6,9 +6,9 @@\n \n export LC_ALL=C\n \n-travis_retry pip install codespell==1.15.0\n-travis_retry pip install flake8==3.5.0\n-travis_retry pip install vulture==0.29\n+travis_retry pip3 install codespell==1.15.0\n+travis_retry pip3 install flake8==3.5.0\n+travis_retry pip3 install vulture==0.29\n \n SHELLCHECK_VERSION=v0.6.0\n curl -s \"https://storage.googleapis.com/shellcheck/shellcheck-${SHELLCHECK_VERSION}.linux.x86_64.tar.xz\" | tar --xz -xf - --directory /tmp/",
        "previous_filename": ".travis/lint_04_install.sh"
      },
      {
        "sha": "28bcbb47f748986c8e95bb87abd5a45faef75e1b",
        "filename": "ci/lint/05_before_script.sh",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/lint/05_before_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/lint/05_before_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/lint/05_before_script.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "previous_filename": ".travis/lint_05_before_script.sh"
      },
      {
        "sha": "c7dea599dcd7e8769e088a561372195986a3693b",
        "filename": "ci/lint/06_script.sh",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/lint/06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/lint/06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/lint/06_script.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "previous_filename": ".travis/lint_06_script.sh"
      },
      {
        "sha": "983a4980708409020797091f1a73cbd0b6662b3f",
        "filename": "ci/retry/README.md",
        "status": "added",
        "additions": 123,
        "deletions": 0,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/retry/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/retry/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/retry/README.md?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,123 @@\n+retry - The command line retry tool\n+------------------------------------------\n+\n+Retry any shell command with exponential backoff or constant delay.\n+\n+### Instructions\n+\n+Install:\n+\n+retry is a shell script, so drop it somewhere and make sure it's added to your $PATH. Or you can use the following one-liner:\n+\n+```sh\n+sudo sh -c \"curl https://raw.githubusercontent.com/kadwanev/retry/master/retry -o /usr/local/bin/retry && chmod +x /usr/local/bin/retry\"\n+```\n+\n+If you're on OS X, retry is also on Homebrew:\n+\n+```\n+brew pull 27283\n+brew install retry\n+```\n+Not popular enough for homebrew-core. Please star this project to help.\n+\n+### Usage\n+\n+Help:\n+\n+`retry -?`\n+\n+    Usage: retry [options] -- execute command\n+        -h, -?, --help\n+        -v, --verbose                    Verbose output\n+        -t, --tries=#                    Set max retries: Default 10\n+        -s, --sleep=secs                 Constant sleep amount (seconds)\n+        -m, --min=secs                   Exponenetial Backoff: minimum sleep amount (seconds): Default 0.3\n+        -x, --max=secs                   Exponenetial Backoff: maximum sleep amount (seconds): Default 60\n+        -f, --fail=\"script +cmds\"        Fail Script: run in case of final failure\n+\n+### Examples\n+\n+No problem:\n+\n+`retry echo u work good`\n+\n+    u work good\n+\n+Test functionality:\n+\n+`retry 'echo \"y u no work\"; false'`\n+\n+    y u no work\n+    Before retry #1: sleeping 0.3 seconds\n+    y u no work\n+    Before retry #2: sleeping 0.6 seconds\n+    y u no work\n+    Before retry #3: sleeping 1.2 seconds\n+    y u no work\n+    Before retry #4: sleeping 2.4 seconds\n+    y u no work\n+    Before retry #5: sleeping 4.8 seconds\n+    y u no work\n+    Before retry #6: sleeping 9.6 seconds\n+    y u no work\n+    Before retry #7: sleeping 19.2 seconds\n+    y u no work\n+    Before retry #8: sleeping 38.4 seconds\n+    y u no work\n+    Before retry #9: sleeping 60.0 seconds\n+    y u no work\n+    Before retry #10: sleeping 60.0 seconds\n+    y u no work\n+    etc..\n+\n+Limit retries:\n+\n+`retry -t 4 'echo \"y u no work\"; false'`\n+\n+    y u no work\n+    Before retry #1: sleeping 0.3 seconds\n+    y u no work\n+    Before retry #2: sleeping 0.6 seconds\n+    y u no work\n+    Before retry #3: sleeping 1.2 seconds\n+    y u no work\n+    Before retry #4: sleeping 2.4 seconds\n+    y u no work\n+    Retries exhausted\n+\n+Bad command:\n+\n+`retry poop`\n+\n+    bash: poop: command not found\n+\n+Fail command:\n+\n+`retry -t 3 -f 'echo \"oh poopsickles\"' 'echo \"y u no work\"; false'`\n+\n+    y u no work\n+    Before retry #1: sleeping 0.3 seconds\n+    y u no work\n+    Before retry #2: sleeping 0.6 seconds\n+    y u no work\n+    Before retry #3: sleeping 1.2 seconds\n+    y u no work\n+    Retries exhausted, running fail script\n+    oh poopsickles\n+\n+Last attempt passed:\n+\n+`retry -t 3 -- 'if [ $RETRY_ATTEMPT -eq 3 ]; then echo Passed at attempt $RETRY_ATTEMPT; true; else echo Failed at attempt $RETRY_ATTEMPT; false; fi;'`\n+\n+    Failed at attempt 0\n+    Before retry #1: sleeping 0.3 seconds\n+    Failed at attempt 1\n+    Before retry #2: sleeping 0.6 seconds\n+    Failed at attempt 2\n+    Before retry #3: sleeping 1.2 seconds\n+    Passed at attempt 3\n+\n+### License\n+\n+Apache 2.0 - go nuts"
      },
      {
        "sha": "0e5f6e97014db2377acecf3e84e44b1b1ca1f683",
        "filename": "ci/retry/retry",
        "status": "added",
        "additions": 163,
        "deletions": 0,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/retry/retry",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/retry/retry",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/retry/retry?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,163 @@\n+#!/usr/bin/env bash\n+\n+GETOPT_BIN=$IN_GETOPT_BIN\n+GETOPT_BIN=${GETOPT_BIN:-getopt}\n+\n+__sleep_amount() {\n+  if [ -n \"$constant_sleep\" ]; then\n+    sleep_time=$constant_sleep\n+  else\n+    #TODO: check for awk\n+    #TODO: check if user would rather use one of the other possible dependencies: python, ruby, bc, dc\n+    sleep_time=`awk \"BEGIN {t = $min_sleep * $(( (1<<($attempts -1)) )); print (t > $max_sleep ? $max_sleep : t)}\"`\n+  fi\n+}\n+\n+__log_out() {\n+  echo \"$1\" 1>&2\n+}\n+\n+# Paramters: max_tries min_sleep max_sleep constant_sleep fail_script EXECUTION_COMMAND\n+retry()\n+{\n+  local max_tries=\"$1\"; shift\n+  local min_sleep=\"$1\"; shift\n+  local max_sleep=\"$1\"; shift\n+  local constant_sleep=\"$1\"; shift\n+  local fail_script=\"$1\"; shift\n+  if [ -n \"$VERBOSE\" ]; then\n+    __log_out \"Retry Parameters: max_tries=$max_tries min_sleep=$min_sleep max_sleep=$max_sleep constant_sleep=$constant_sleep\"\n+    if [ -n \"$fail_script\" ]; then __log_out \"Fail script: $fail_script\"; fi\n+    __log_out \"\"\n+    __log_out \"Execution Command: $*\"\n+    __log_out \"\"\n+  fi\n+\n+  local attempts=0\n+  local return_code=1\n+\n+\n+  while [[ $return_code -ne 0 && $attempts -le $max_tries ]]; do\n+    if [ $attempts -gt 0 ]; then\n+      __sleep_amount\n+      __log_out \"Before retry #$attempts: sleeping $sleep_time seconds\"\n+      sleep $sleep_time\n+    fi\n+\n+    P=\"$1\"\n+    for param in \"${@:2}\"; do P=\"$P '$param'\"; done\n+    #TODO: replace single quotes in each arg with '\"'\"' ?\n+    export RETRY_ATTEMPT=$attempts\n+    bash -c \"$P\"\n+    return_code=$?\n+    #__log_out \"Process returned $return_code on attempt $attempts\"\n+    if [ $return_code -eq 127 ]; then\n+      # command not found\n+      exit $return_code\n+    elif [ $return_code -ne 0 ]; then\n+      attempts=$[$attempts +1]\n+    fi\n+  done\n+\n+  if [ $attempts -gt $max_tries ]; then\n+    if [ -n \"$fail_script\" ]; then\n+      __log_out \"Retries exhausted, running fail script\"\n+      eval $fail_script\n+    else\n+      __log_out \"Retries exhausted\"\n+    fi\n+  fi\n+\n+  exit $return_code\n+}\n+\n+# If we're being sourced, don't worry about such things\n+if [ \"$BASH_SOURCE\" == \"$0\" ]; then\n+  # Prints the help text\n+  help()\n+  {\n+    local retry=$(basename $0)\n+    cat <<EOF\n+Usage: $retry [options] -- execute command\n+    -h, -?, --help\n+    -v, --verbose                    Verbose output\n+    -t, --tries=#                    Set max retries: Default 10\n+    -s, --sleep=secs                 Constant sleep amount (seconds)\n+    -m, --min=secs                   Exponenetial Backoff: minimum sleep amount (seconds): Default 0.3\n+    -x, --max=secs                   Exponenetial Backoff: maximum sleep amount (seconds): Default 60\n+    -f, --fail=\"script +cmds\"        Fail Script: run in case of final failure\n+EOF\n+  }\n+\n+  # show help for no arguments if stdin is a terminal\n+  if { [ -z \"$1\" ] && [ -t 0 ] ; } || [ \"$1\" == '-h' ] || [ \"$1\" == '-?' ] || [ \"$1\" == '--help' ]\n+  then\n+    help\n+    exit 0\n+  fi\n+\n+  $GETOPT_BIN --test > /dev/null\n+  if [[ $? -ne 4 ]]; then\n+      echo \"I\u2019m sorry, 'getopt --test' failed in this environment. Please load GNU getopt.\"\n+      exit 1\n+  fi\n+\n+  OPTIONS=vt:s:m:x:f:\n+  LONGOPTIONS=verbose,tries:,sleep:,min:,max:,fail:\n+\n+  PARSED=$($GETOPT_BIN --options=\"$OPTIONS\" --longoptions=\"$LONGOPTIONS\" --name \"$0\" -- \"$@\")\n+  if [[ $? -ne 0 ]]; then\n+    # e.g. $? == 1\n+    #  then getopt has complained about wrong arguments to stdout\n+    exit 2\n+  fi\n+  # read getopt\u2019s output this way to handle the quoting right:\n+  eval set -- \"$PARSED\"\n+\n+  max_tries=10\n+  min_sleep=0.3\n+  max_sleep=60.0\n+  constant_sleep=\n+  fail_script=\n+\n+  # now enjoy the options in order and nicely split until we see --\n+  while true; do\n+      case \"$1\" in\n+          -v|--verbose)\n+              VERBOSE=true\n+              shift\n+              ;;\n+          -t|--tries)\n+              max_tries=\"$2\"\n+              shift 2\n+              ;;\n+          -s|--sleep)\n+              constant_sleep=\"$2\"\n+              shift 2\n+              ;;\n+          -m|--min)\n+              min_sleep=\"$2\"\n+              shift 2\n+              ;;\n+          -x|--max)\n+              max_sleep=\"$2\"\n+              shift 2\n+              ;;\n+          -f|--fail)\n+              fail_script=\"$2\"\n+              shift 2\n+              ;;\n+          --)\n+              shift\n+              break\n+              ;;\n+          *)\n+              echo \"Programming error\"\n+              exit 3\n+              ;;\n+      esac\n+  done\n+\n+  retry \"$max_tries\" \"$min_sleep\" \"$max_sleep\" \"$constant_sleep\" \"$fail_script\" \"$@\"\n+\n+fi"
      },
      {
        "sha": "fae48ba17647e761eb3b3489ae518b1a7ed91215",
        "filename": "ci/test/00_setup_env.sh",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/00_setup_env.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/00_setup_env.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,33 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+export LC_ALL=C.UTF-8\n+\n+echo \"Setting default values in env\"\n+\n+BASE_ROOT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../../ >/dev/null 2>&1 && pwd )\n+export BASE_ROOT_DIR\n+\n+export MAKEJOBS=${MAKEJOBS:--j3}\n+export HOST=${HOST:-x86_64-unknown-linux-gnu}\n+export RUN_UNIT_TESTS=${RUN_UNIT_TESTS:-true}\n+export RUN_FUNCTIONAL_TESTS=${RUN_FUNCTIONAL_TESTS:-true}\n+export RUN_FUZZ_TESTS=${RUN_FUZZ_TESTS:-false}\n+export DOCKER_NAME_TAG=${DOCKER_NAME_TAG:-ubuntu:18.04}\n+export BOOST_TEST_RANDOM=${BOOST_TEST_RANDOM:-1$TRAVIS_BUILD_ID}\n+export CCACHE_SIZE=${CCACHE_SIZE:-100M}\n+export CCACHE_TEMPDIR=${CCACHE_TEMPDIR:-/tmp/.ccache-temp}\n+export CCACHE_COMPRESS=${CCACHE_COMPRESS:-1}\n+export CCACHE_DIR=${CCACHE_DIR:-$HOME/.ccache}\n+export BASE_BUILD_DIR=${BASE_BUILD_DIR:-${TRAVIS_BUILD_DIR:-$BASE_ROOT_DIR}}\n+export BASE_OUTDIR=${BASE_OUTDIR:-$BASE_BUILD_DIR/out/$HOST}\n+export SDK_URL=${SDK_URL:-https://bitcoincore.org/depends-sources/sdks}\n+export WINEDEBUG=${WINEDEBUG:-fixme-all}\n+export DOCKER_PACKAGES=${DOCKER_PACKAGES:-build-essential libtool autotools-dev automake pkg-config bsdmainutils curl ca-certificates ccache python3}\n+export GOAL=${GOAL:-install}\n+export DIR_QA_ASSETS=${DIR_QA_ASSETS:-${BASE_BUILD_DIR}/qa-assets}\n+export PATH=${BASE_ROOT_DIR}/ci/retry:$PATH\n+export CI_RETRY_EXE=${CI_RETRY_EXE:retry}"
      },
      {
        "sha": "5086114ba16e85b0399ffce587f6e1cf2b187bf9",
        "filename": "ci/test/03_before_install.sh",
        "status": "renamed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/03_before_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/03_before_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/03_before_install.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -6,7 +6,6 @@\n \n export LC_ALL=C.UTF-8\n \n-PATH=$(echo $PATH | tr ':' \"\\n\" | sed '/\\/opt\\/python/d' | tr \"\\n\" \":\" | sed \"s|::|:|g\")\n # Add llvm-symbolizer directory to PATH. Needed to get symbolized stack traces from the sanitizers.\n PATH=$PATH:/usr/lib/llvm-6.0/bin/\n export PATH",
        "previous_filename": ".travis/test_03_before_install.sh"
      },
      {
        "sha": "3535746e83f1a6fb8347fc4440f59a7706d1c6c4",
        "filename": "ci/test/04_install.sh",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/04_install.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,49 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+export LC_ALL=C.UTF-8\n+\n+ccache echo \"Creating ccache dir if it didn't already exist\"\n+\n+if [ ! -d ${DIR_QA_ASSETS} ]; then\n+  git clone https://github.com/bitcoin-core/qa-assets ${DIR_QA_ASSETS}\n+fi\n+export DIR_FUZZ_IN=${DIR_QA_ASSETS}/fuzz_seed_corpus/\n+\n+mkdir -p \"${BASE_BUILD_DIR}/sanitizer-output/\"\n+export ASAN_OPTIONS=\"\"\n+export LSAN_OPTIONS=\"suppressions=${BASE_BUILD_DIR}/test/sanitizer_suppressions/lsan\"\n+export TSAN_OPTIONS=\"suppressions=${BASE_BUILD_DIR}/test/sanitizer_suppressions/tsan:log_path=${BASE_BUILD_DIR}/sanitizer-output/tsan\"\n+export UBSAN_OPTIONS=\"suppressions=${BASE_BUILD_DIR}/test/sanitizer_suppressions/ubsan:print_stacktrace=1:halt_on_error=1\"\n+env | grep -E '^(BITCOIN_CONFIG|CCACHE_|WINEDEBUG|LC_ALL|BOOST_TEST_RANDOM|CONFIG_SHELL|(ASAN|LSAN|TSAN|UBSAN)_OPTIONS)' | tee /tmp/env\n+if [[ $HOST = *-mingw32 ]]; then\n+  DOCKER_ADMIN=\"--cap-add SYS_ADMIN\"\n+elif [[ $BITCOIN_CONFIG = *--with-sanitizers=*address* ]]; then # If ran with (ASan + LSan), Docker needs access to ptrace (https://github.com/google/sanitizers/issues/764)\n+  DOCKER_ADMIN=\"--cap-add SYS_PTRACE\"\n+fi\n+\n+if [ -z \"$RUN_CI_ON_HOST\" ]; then\n+  echo \"Creating $DOCKER_NAME_TAG container to run in\"\n+  ${CI_RETRY_EXE} docker pull \"$DOCKER_NAME_TAG\"\n+\n+  DOCKER_ID=$(docker run $DOCKER_ADMIN -idt --mount type=bind,src=$BASE_BUILD_DIR,dst=$BASE_BUILD_DIR --mount type=bind,src=$CCACHE_DIR,dst=$CCACHE_DIR -w $BASE_BUILD_DIR --env-file /tmp/env $DOCKER_NAME_TAG)\n+\n+  DOCKER_EXEC () {\n+    docker exec $DOCKER_ID bash -c \"cd $PWD && $*\"\n+  }\n+else\n+  echo \"Running on host system without docker wrapper\"\n+  DOCKER_EXEC () {\n+    bash -c \"cd $PWD && $*\"\n+  }\n+fi\n+\n+DOCKER_EXEC free -m -h\n+DOCKER_EXEC echo \"Number of CPUs \\(nproc\\): $(nproc)\"\n+\n+${CI_RETRY_EXE} DOCKER_EXEC apt-get update\n+${CI_RETRY_EXE} DOCKER_EXEC apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES $DOCKER_PACKAGES\n+"
      },
      {
        "sha": "516d3fc0428ba30588a1be864be324551318dcd4",
        "filename": "ci/test/05_before_script.sh",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/05_before_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/05_before_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/05_before_script.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "previous_filename": ".travis/test_05_before_script.sh"
      },
      {
        "sha": "eb6ade7919f89c60f0b5aa492b6778f0e929e409",
        "filename": "ci/test/06_script_a.sh",
        "status": "renamed",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/06_script_a.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/06_script_a.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/06_script_a.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -6,11 +6,7 @@\n \n export LC_ALL=C.UTF-8\n \n-TRAVIS_COMMIT_LOG=$(git log --format=fuller -1)\n-export TRAVIS_COMMIT_LOG\n-\n-OUTDIR=$BASE_OUTDIR/$TRAVIS_PULL_REQUEST/$TRAVIS_JOB_NUMBER-$HOST\n-BITCOIN_CONFIG_ALL=\"--disable-dependency-tracking --prefix=$TRAVIS_BUILD_DIR/depends/$HOST --bindir=$OUTDIR/bin --libdir=$OUTDIR/lib\"\n+BITCOIN_CONFIG_ALL=\"--disable-dependency-tracking --prefix=$BASE_BUILD_DIR/depends/$HOST --bindir=$BASE_OUTDIR/bin --libdir=$BASE_OUTDIR/lib\"\n if [ -z \"$NO_DEPENDS\" ]; then\n   DOCKER_EXEC ccache --max-size=$CCACHE_SIZE\n fi\n@@ -23,7 +19,7 @@ else\n fi\n END_FOLD\n \n-mkdir build\n+mkdir -p build\n cd build || (echo \"could not enter build directory\"; exit 1)\n \n BEGIN_FOLD configure\n@@ -41,10 +37,10 @@ DOCKER_EXEC ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOI\n END_FOLD\n \n set -o errtrace\n-trap 'DOCKER_EXEC \"cat ${TRAVIS_BUILD_DIR}/sanitizer-output/* 2> /dev/null\"' ERR\n+trap 'DOCKER_EXEC \"cat ${BASE_BUILD_DIR}/sanitizer-output/* 2> /dev/null\"' ERR\n \n BEGIN_FOLD build\n DOCKER_EXEC make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && DOCKER_EXEC make $GOAL V=1 ; false )\n END_FOLD\n \n-cd ${TRAVIS_BUILD_DIR} || (echo \"could not enter travis build dir $TRAVIS_BUILD_DIR\"; exit 1)\n+cd ${BASE_BUILD_DIR} || (echo \"could not enter travis build dir $BASE_BUILD_DIR\"; exit 1)",
        "previous_filename": ".travis/test_06_script_a.sh"
      },
      {
        "sha": "fafb6e0493b739e478e876918e00c5d02423ab7d",
        "filename": "ci/test/06_script_b.sh",
        "status": "renamed",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/06_script_b.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test/06_script_b.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/06_script_b.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -10,7 +10,7 @@ cd \"build/bitcoin-$HOST\" || (echo \"could not enter distdir build/bitcoin-$HOST\";\n \n if [ \"$RUN_UNIT_TESTS\" = \"true\" ]; then\n   BEGIN_FOLD unit-tests\n-  DOCKER_EXEC LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib make $MAKEJOBS check VERBOSE=1\n+  DOCKER_EXEC LD_LIBRARY_PATH=$BASE_BUILD_DIR/depends/$HOST/lib make $MAKEJOBS check VERBOSE=1\n   END_FOLD\n fi\n \n@@ -26,4 +26,4 @@ if [ \"$RUN_FUZZ_TESTS\" = \"true\" ]; then\n   END_FOLD\n fi\n \n-cd ${TRAVIS_BUILD_DIR} || (echo \"could not enter travis build dir $TRAVIS_BUILD_DIR\"; exit 1)\n+cd ${BASE_BUILD_DIR} || (echo \"could not enter travis build dir $BASE_BUILD_DIR\"; exit 1)",
        "previous_filename": ".travis/test_06_script_b.sh"
      },
      {
        "sha": "a39f1f9f09de177c9db155bc6ce5554929cd8464",
        "filename": "ci/test_run_all.sh",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test_run_all.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/ci/test_run_all.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test_run_all.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,16 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+export LC_ALL=C.UTF-8\n+\n+echo \"Setting default values in env\"\n+\n+set -o errexit; source ./ci/test/00_setup_env.sh\n+set -o errexit; source ./ci/test/03_before_install.sh\n+set -o errexit; source ./ci/test/04_install.sh\n+set -o errexit; source ./ci/test/05_before_script.sh\n+set -o errexit; source ./ci/test/06_script_a.sh\n+set -o errexit; source ./ci/test/06_script_b.sh"
      },
      {
        "sha": "8fb9df9e6c4493fce468e10dd4b0b828657d2377",
        "filename": "contrib/debian/copyright",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/contrib/debian/copyright",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/contrib/debian/copyright",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/copyright?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -60,7 +60,7 @@ Files: src/qt/res/icons/connect*.png\n Copyright: Marco Falke\n            Luke Dashjr\n License: Expat\n-Comment: Inspired by Stephan Hutchings Typicons\n+Comment: Inspired by Stephen Hutchings' Typicons\n \n Files: src/qt/res/icons/tx_mined.png\n        src/qt/res/src/mine.svg\n@@ -72,7 +72,6 @@ Files: src/qt/res/icons/tx_mined.png\n        src/qt/res/src/hd_enabled.svg\n Copyright: Jonas Schnelli\n License: Expat\n-Comment:\n \n Files: src/qt/res/icons/clock*.png\n        src/qt/res/icons/eye_*.png\n@@ -81,9 +80,9 @@ Files: src/qt/res/icons/clock*.png\n        src/qt/res/src/clock_*.svg\n        src/qt/res/src/tx_*.svg\n        src/qt/res/src/verify.svg\n-Copyright: Stephan Hutching, Jonas Schnelli\n+Copyright: Stephen Hutchings, Jonas Schnelli\n License: Expat\n-Comment: Modifications of Stephan Hutchings Typicons\n+Comment: Modifications of Stephen Hutchings' Typicons\n \n Files: src/qt/res/icons/about.png\n        src/qt/res/icons/bitcoin.*"
      },
      {
        "sha": "7e150d10e752e9e75dc8ddab00cf4426246893a4",
        "filename": "doc/release-notes-16060.md",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/doc/release-notes-16060.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/doc/release-notes-16060.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-16060.md?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,15 @@\n+Low-level RPC changes\n+----------------------\n+\n+- Soft fork reporting in the `getblockchaininfo` return object has been\n+  updated. For full details, see the RPC help text. In summary:\n+  - The `bip9_softforks` sub-object is no longer returned\n+  - The `softforks` sub-object now returns an object keyed by soft fork name,\n+    rather than an array\n+  - Each softfork object in the `softforks` object contains a `type` value which\n+    is either `buried` (for soft fork deployments where the activation height is\n+    hard-coded into the client implementation), or `bip9` (for soft fork deployments\n+    where activation is controlled by BIP 9 signaling).\n+\n+- `getblocktemplate` no longer returns a `rules` array containing `CSV`\n+  and `segwit` (the BIP 9 deployments that are currently in active state)."
      },
      {
        "sha": "ad766471dc13322206546d2437fe6c61eabd2cd1",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 29,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -69,6 +69,8 @@ class CMainParams : public CChainParams {\n         consensus.BIP34Hash = uint256S(\"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8\");\n         consensus.BIP65Height = 388381; // 000000000000000004c2b624ed5d7756c508d90fd0da2c7c679febfa6c4735f0\n         consensus.BIP66Height = 363725; // 00000000000000000379eaa19dce8c9b722d46ae6a57c2f1a988119488b50931\n+        consensus.CSVHeight = 419328; // 000000000000000004a1b34462cb8aeebd5799177f7a29cf28f2d1961716b5b5\n+        consensus.SegwitHeight = 481824; // 0000000000000000001c8018d9cb3b742ef25114f27563e3fc4a1902167f9893\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n         consensus.nPowTargetSpacing = 10 * 60;\n@@ -80,16 +82,6 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n-        // Deployment of BIP68, BIP112, and BIP113.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n-\n-        // Deployment of SegWit (BIP141, BIP143, and BIP147)\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\n-\n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000051dc8b82f450202ecb3d471\");\n \n@@ -183,6 +175,8 @@ class CTestNetParams : public CChainParams {\n         consensus.BIP34Hash = uint256S(\"0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8\");\n         consensus.BIP65Height = 581885; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6\n         consensus.BIP66Height = 330776; // 000000002104c8c45e99a8853285a3b592602a3ccde2b832481da85e9e4ba182\n+        consensus.CSVHeight = 770112; // 00000000025e930139bac5c6c31a403776da130831ab85be56578f3fa75369bb\n+        consensus.SegwitHeight = 834624; // 00000000002b980fcd729daaa248fd9316a5200e9b367f4ff2c42453e84201ca\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n         consensus.nPowTargetSpacing = 10 * 60;\n@@ -194,16 +188,6 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n-        // Deployment of BIP68, BIP112, and BIP113.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n-\n-        // Deployment of SegWit (BIP141, BIP143, and BIP147)\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800; // May 1st 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n-\n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000007dbe94253893cbd463\");\n \n@@ -275,6 +259,8 @@ class CRegTestParams : public CChainParams {\n         consensus.BIP34Hash = uint256();\n         consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in functional tests)\n         consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in functional tests)\n+        consensus.CSVHeight = 432; // CSV activated on regtest (Used in rpc activation tests)\n+        consensus.SegwitHeight = 0; // SEGWIT is always activated on regtest unless overridden\n         consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n         consensus.nPowTargetSpacing = 10 * 60;\n@@ -285,12 +271,6 @@ class CRegTestParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00\");\n@@ -307,7 +287,7 @@ class CRegTestParams : public CChainParams {\n         m_assumed_blockchain_size = 0;\n         m_assumed_chain_state_size = 0;\n \n-        UpdateVersionBitsParametersFromArgs(args);\n+        UpdateActivationParametersFromArgs(args);\n \n         genesis = CreateGenesisBlock(1296688602, 2, 0x207fffff, 1, 50 * COIN);\n         consensus.hashGenesisBlock = genesis.GetHash();\n@@ -350,11 +330,22 @@ class CRegTestParams : public CChainParams {\n         consensus.vDeployments[d].nStartTime = nStartTime;\n         consensus.vDeployments[d].nTimeout = nTimeout;\n     }\n-    void UpdateVersionBitsParametersFromArgs(const ArgsManager& args);\n+    void UpdateActivationParametersFromArgs(const ArgsManager& args);\n };\n \n-void CRegTestParams::UpdateVersionBitsParametersFromArgs(const ArgsManager& args)\n+void CRegTestParams::UpdateActivationParametersFromArgs(const ArgsManager& args)\n {\n+    if (gArgs.IsArgSet(\"-segwitheight\")) {\n+        int64_t height = gArgs.GetArg(\"-segwitheight\", consensus.SegwitHeight);\n+        if (height < -1 || height >= std::numeric_limits<int>::max()) {\n+            throw std::runtime_error(strprintf(\"Activation height %ld for segwit is out of valid range. Use -1 to disable segwit.\", height));\n+        } else if (height == -1) {\n+            LogPrintf(\"Segwit disabled for testing\\n\");\n+            height = std::numeric_limits<int>::max();\n+        }\n+        consensus.SegwitHeight = static_cast<int>(height);\n+    }\n+\n     if (!args.IsArgSet(\"-vbparams\")) return;\n \n     for (const std::string& strDeployment : args.GetArgs(\"-vbparams\")) {"
      },
      {
        "sha": "9b98dff3caf7b9d433e153c46e796faaff438166",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -19,6 +19,7 @@ void SetupChainParamsBaseOptions()\n {\n     gArgs.AddArg(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n                                    \"This is intended for regression testing tools and app development.\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n+    gArgs.AddArg(\"-segwitheight=<n>\", \"Set the activation height of segwit. -1 to disable. (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-testnet\", \"Use the test chain\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\n     gArgs.AddArg(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n }"
      },
      {
        "sha": "8263b0fef4a895e0d443eb5e19a14448bc1d4faf",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -16,8 +16,6 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n-    DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n-    DEPLOYMENT_SEGWIT, // Deployment of BIP141, BIP143, and BIP147.\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n };\n@@ -58,6 +56,12 @@ struct Params {\n     int BIP65Height;\n     /** Block height at which BIP66 becomes active */\n     int BIP66Height;\n+    /** Block height at which CSV (BIP68, BIP112 and BIP113) becomes active */\n+    int CSVHeight;\n+    /** Block height at which Segwit (BIP141, BIP143 and BIP147) becomes active.\n+     * Note that segwit v0 script rules are enforced on all blocks except the\n+     * BIP 16 exception blocks. */\n+    int SegwitHeight;\n     /**\n      * Minimum blocks including miner confirmation of the total of 2016 blocks in a retargeting period,\n      * (nPowTargetTimespan / nPowTargetSpacing) which is also used for BIP9 deployments."
      },
      {
        "sha": "d98f7c37673bba15e7f258621bbc9d278897ed7b",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 27,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -15,7 +15,6 @@\n #include <blockfilter.h>\n #include <chain.h>\n #include <chainparams.h>\n-#include <coins.h>\n #include <compat/sanity.h>\n #include <consensus/validation.h>\n #include <fs.h>\n@@ -150,7 +149,6 @@ NODISCARD static bool CreatePidFile()\n // shutdown thing.\n //\n \n-static std::unique_ptr<CCoinsViewErrorCatcher> pcoinscatcher;\n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n static boost::thread_group threadGroup;\n@@ -235,8 +233,14 @@ void Shutdown(InitInterfaces& interfaces)\n     }\n \n     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n-    if (pcoinsTip != nullptr) {\n-        ::ChainstateActive().ForceFlushStateToDisk();\n+    //\n+    // g_chainstate is referenced here directly (instead of ::ChainstateActive()) because it\n+    // may not have been initialized yet.\n+    {\n+        LOCK(cs_main);\n+        if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n+            g_chainstate->ForceFlushStateToDisk();\n+        }\n     }\n \n     // After there are no more peers/RPC left to give us new data which may generate\n@@ -251,12 +255,10 @@ void Shutdown(InitInterfaces& interfaces)\n \n     {\n         LOCK(cs_main);\n-        if (pcoinsTip != nullptr) {\n-            ::ChainstateActive().ForceFlushStateToDisk();\n+        if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n+            g_chainstate->ForceFlushStateToDisk();\n+            g_chainstate->ResetCoinsViews();\n         }\n-        pcoinsTip.reset();\n-        pcoinscatcher.reset();\n-        pcoinsdbview.reset();\n         pblocktree.reset();\n     }\n     for (const auto& client : interfaces.chain_clients) {\n@@ -1467,10 +1469,10 @@ bool AppInitMain(InitInterfaces& interfaces)\n             bool is_coinsview_empty;\n             try {\n                 LOCK(cs_main);\n+                // This statement makes ::ChainstateActive() usable.\n+                g_chainstate = MakeUnique<CChainState>();\n                 UnloadBlockIndex();\n-                pcoinsTip.reset();\n-                pcoinsdbview.reset();\n-                pcoinscatcher.reset();\n+\n                 // new CBlockTreeDB tries to delete the existing file, which\n                 // fails if it's still open from the previous loop. Close it first:\n                 pblocktree.reset();\n@@ -1521,33 +1523,38 @@ bool AppInitMain(InitInterfaces& interfaces)\n                 // At this point we're either in reindex or we've loaded a useful\n                 // block tree into BlockIndex()!\n \n-                pcoinsdbview.reset(new CCoinsViewDB(nCoinDBCache, false, fReset || fReindexChainState));\n-                pcoinscatcher.reset(new CCoinsViewErrorCatcher(pcoinsdbview.get()));\n-                pcoinscatcher->AddReadErrCallback([]() {\n+                ::ChainstateActive().InitCoinsDB(\n+                    /* cache_size_bytes */ nCoinDBCache,\n+                    /* in_memory */ false,\n+                    /* should_wipe */ fReset || fReindexChainState);\n+\n+                ::ChainstateActive().CoinsErrorCatcher().AddReadErrCallback([]() {\n                     uiInterface.ThreadSafeMessageBox(\n                         _(\"Error reading from database, shutting down.\").translated,\n                         \"\", CClientUIInterface::MSG_ERROR);\n                 });\n \n                 // If necessary, upgrade from older database format.\n                 // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!pcoinsdbview->Upgrade()) {\n+                if (!::ChainstateActive().CoinsDB().Upgrade()) {\n                     strLoadError = _(\"Error upgrading chainstate database\").translated;\n                     break;\n                 }\n \n                 // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!ReplayBlocks(chainparams, pcoinsdbview.get())) {\n+                if (!ReplayBlocks(chainparams, &::ChainstateActive().CoinsDB())) {\n                     strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\").translated;\n                     break;\n                 }\n \n                 // The on-disk coinsdb is now in a good state, create the cache\n-                pcoinsTip.reset(new CCoinsViewCache(pcoinscatcher.get()));\n+                ::ChainstateActive().InitCoinsCache();\n+                assert(::ChainstateActive().CanFlushToDisk());\n \n-                is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n+                is_coinsview_empty = fReset || fReindexChainState ||\n+                    ::ChainstateActive().CoinsTip().GetBestBlock().IsNull();\n                 if (!is_coinsview_empty) {\n-                    // LoadChainTip sets ::ChainActive() based on pcoinsTip's best block\n+                    // LoadChainTip sets ::ChainActive() based on CoinsTip()'s best block\n                     if (!LoadChainTip(chainparams)) {\n                         strLoadError = _(\"Error initializing block database\").translated;\n                         break;\n@@ -1589,7 +1596,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n                         break;\n                     }\n \n-                    if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n+                    if (!CVerifyDB().VerifyDB(chainparams, &::ChainstateActive().CoinsDB(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n                                   gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n                         strLoadError = _(\"Corrupted block database detected\").translated;\n                         break;\n@@ -1671,12 +1678,9 @@ bool AppInitMain(InitInterfaces& interfaces)\n         }\n     }\n \n-    if (chainparams.GetConsensus().vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {\n-        // Only advertise witness capabilities if they have a reasonable start time.\n-        // This allows us to have the code merged without a defined softfork, by setting its\n-        // end time to 0.\n-        // Note that setting NODE_WITNESS is never required: the only downside from not\n-        // doing so is that after activation, no upgraded nodes will fetch from you.\n+    if (chainparams.GetConsensus().SegwitHeight != std::numeric_limits<int>::max()) {\n+        // Advertise witness capabilities.\n+        // The option to not set NODE_WITNESS is only used in the tests and should be removed.\n         nLocalServices = ServiceFlags(nLocalServices | NODE_WITNESS);\n     }\n "
      },
      {
        "sha": "fc49817502f5595c8c14f64b9f53bf4393c71b41",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -232,7 +232,7 @@ class NodeImpl : public Node\n     bool getUnspentOutput(const COutPoint& output, Coin& coin) override\n     {\n         LOCK(::cs_main);\n-        return ::pcoinsTip->GetCoin(output, coin);\n+        return ::ChainstateActive().CoinsTip().GetCoin(output, coin);\n     }\n     std::string getWalletDir() override\n     {"
      },
      {
        "sha": "520dfcbb66aedcac2a7e29087c6c6f39ed734ced",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -1291,11 +1291,12 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 LOCK(g_cs_orphans);\n                 if (mapOrphanTransactions.count(inv.hash)) return true;\n             }\n+            const CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n \n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n-                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n-                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n+                   coins_cache.HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   coins_cache.HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n@@ -1844,7 +1845,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n             EraseOrphanTx(orphanHash);\n             done = true;\n         }\n-        mempool.check(pcoinsTip.get());\n+        mempool.check(&::ChainstateActive().CoinsTip());\n     }\n }\n \n@@ -2497,7 +2498,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!AlreadyHave(inv) &&\n             AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-            mempool.check(pcoinsTip.get());\n+            mempool.check(&::ChainstateActive().CoinsTip());\n             RelayTransaction(tx.GetHash(), *connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));"
      },
      {
        "sha": "ad8d1d3af44d61729d2b6af568de80b7ea628a14",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -10,8 +10,7 @@\n void FindCoins(std::map<COutPoint, Coin>& coins)\n {\n     LOCK2(cs_main, ::mempool.cs);\n-    assert(pcoinsTip);\n-    CCoinsViewCache& chain_view = *::pcoinsTip;\n+    CCoinsViewCache& chain_view = ::ChainstateActive().CoinsTip();\n     CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n     for (auto& coin : coins) {\n         if (!mempool_view.GetCoin(coin.first, coin.second)) {"
      },
      {
        "sha": "7e8291ddc8c61d9c24e7d2d690b8daf47260e592",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -28,7 +28,7 @@ TransactionError BroadcastTransaction(const CTransactionRef tx, std::string& err\n     LOCK(cs_main);\n     // If the transaction is already confirmed in the chain, don't do anything\n     // and return early.\n-    CCoinsViewCache &view = *pcoinsTip;\n+    CCoinsViewCache &view = ::ChainstateActive().CoinsTip();\n     for (size_t o = 0; o < tx->vout.size(); o++) {\n         const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n         // IsSpent doesnt mean the coin is spent, it means the output doesnt' exist."
      },
      {
        "sha": "5ce4f3c191a9ff61dff47276c91c492ac32a4d8a",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -169,8 +169,11 @@ void BitcoinCore::shutdown()\n     }\n }\n \n-BitcoinApplication::BitcoinApplication(interfaces::Node& node, int &argc, char **argv):\n-    QApplication(argc, argv),\n+static int qt_argc = 1;\n+static const char* qt_argv = \"bitcoin-qt\";\n+\n+BitcoinApplication::BitcoinApplication(interfaces::Node& node):\n+    QApplication(qt_argc, const_cast<char **>(&qt_argv)),\n     coreThread(nullptr),\n     m_node(node),\n     optionsModel(nullptr),\n@@ -433,7 +436,7 @@ int GuiMain(int argc, char* argv[])\n     QApplication::setAttribute(Qt::AA_DontShowIconsInMenus);\n #endif\n \n-    BitcoinApplication app(*node, argc, argv);\n+    BitcoinApplication app(*node);\n \n     // Register meta types used for QMetaObject::invokeMethod\n     qRegisterMetaType< bool* >();"
      },
      {
        "sha": "3869193a3a7d1382854fa6a4488691fe5a50315a",
        "filename": "src/qt/bitcoin.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/qt/bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/qt/bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.h?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -56,7 +56,7 @@ class BitcoinApplication: public QApplication\n {\n     Q_OBJECT\n public:\n-    explicit BitcoinApplication(interfaces::Node& node, int &argc, char **argv);\n+    explicit BitcoinApplication(interfaces::Node& node);\n     ~BitcoinApplication();\n \n #ifdef ENABLE_WALLET"
      },
      {
        "sha": "796cf24b364e1557011c876f6421463e03ed8fb2",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -68,7 +68,7 @@ int main(int argc, char *argv[])\n \n     // Don't remove this, it's needed to access\n     // QApplication:: and QCoreApplication:: in the tests\n-    BitcoinApplication app(*node, argc, argv);\n+    BitcoinApplication app(*node);\n     app.setApplicationName(\"Bitcoin-Qt-test\");\n \n     AppTests app_tests(app);"
      },
      {
        "sha": "2c4d47554267e847803a4620a5d68f6b95d78e92",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -503,12 +503,12 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         if (fCheckMemPool) {\n             // use db+mempool as cache backend in case user likes to query mempool\n             LOCK2(cs_main, mempool.cs);\n-            CCoinsViewCache& viewChain = *pcoinsTip;\n+            CCoinsViewCache& viewChain = ::ChainstateActive().CoinsTip();\n             CCoinsViewMemPool viewMempool(&viewChain, mempool);\n             process_utxos(viewMempool, mempool);\n         } else {\n             LOCK(cs_main);  // no need to lock mempool!\n-            process_utxos(*pcoinsTip, CTxMemPool());\n+            process_utxos(::ChainstateActive().CoinsTip(), CTxMemPool());\n         }\n \n         for (size_t i = 0; i < hits.size(); ++i) {"
      },
      {
        "sha": "bfb6ab6a216012ba9daece4f691f2f1095f112dd",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 83,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -1062,7 +1062,9 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n \n     CCoinsStats stats;\n     ::ChainstateActive().ForceFlushStateToDisk();\n-    if (GetUTXOStats(pcoinsdbview.get(), stats)) {\n+\n+    CCoinsView* coins_view = WITH_LOCK(cs_main, return &ChainstateActive().CoinsDB());\n+    if (GetUTXOStats(coins_view, stats)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n         ret.pushKV(\"transactions\", (int64_t)stats.nTransactions);\n@@ -1126,19 +1128,21 @@ UniValue gettxout(const JSONRPCRequest& request)\n         fMempool = request.params[2].get_bool();\n \n     Coin coin;\n+    CCoinsViewCache* coins_view = &::ChainstateActive().CoinsTip();\n+\n     if (fMempool) {\n         LOCK(mempool.cs);\n-        CCoinsViewMemPool view(pcoinsTip.get(), mempool);\n+        CCoinsViewMemPool view(coins_view, mempool);\n         if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {\n             return NullUniValue;\n         }\n     } else {\n-        if (!pcoinsTip->GetCoin(out, coin)) {\n+        if (!coins_view->GetCoin(out, coin)) {\n             return NullUniValue;\n         }\n     }\n \n-    const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n+    const CBlockIndex* pindex = LookupBlockIndex(coins_view->GetBestBlock());\n     ret.pushKV(\"bestblock\", pindex->GetBlockHash().GetHex());\n     if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.pushKV(\"confirmations\", 0);\n@@ -1180,57 +1184,53 @@ static UniValue verifychain(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n         nCheckDepth = request.params[1].get_int();\n \n-    return CVerifyDB().VerifyDB(Params(), pcoinsTip.get(), nCheckLevel, nCheckDepth);\n+    return CVerifyDB().VerifyDB(\n+        Params(), &::ChainstateActive().CoinsTip(), nCheckLevel, nCheckDepth);\n }\n \n-/** Implementation of IsSuperMajority with better feedback */\n-static UniValue SoftForkMajorityDesc(int version, const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n+static void BuriedForkDescPushBack(UniValue& softforks, const std::string &name, int height) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    UniValue rv(UniValue::VOBJ);\n-    bool activated = false;\n-    switch(version)\n-    {\n-        case 2:\n-            activated = pindex->nHeight >= consensusParams.BIP34Height;\n-            break;\n-        case 3:\n-            activated = pindex->nHeight >= consensusParams.BIP66Height;\n-            break;\n-        case 4:\n-            activated = pindex->nHeight >= consensusParams.BIP65Height;\n-            break;\n-    }\n-    rv.pushKV(\"status\", activated);\n-    return rv;\n-}\n+    // For buried deployments.\n+    // A buried deployment is one where the height of the activation has been hardcoded into\n+    // the client implementation long after the consensus change has activated. See BIP 90.\n+    // Buried deployments with activation height value of\n+    // std::numeric_limits<int>::max() are disabled and thus hidden.\n+    if (height == std::numeric_limits<int>::max()) return;\n \n-static UniValue SoftForkDesc(const std::string &name, int version, const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n-{\n     UniValue rv(UniValue::VOBJ);\n-    rv.pushKV(\"id\", name);\n-    rv.pushKV(\"version\", version);\n-    rv.pushKV(\"reject\", SoftForkMajorityDesc(version, pindex, consensusParams));\n-    return rv;\n+    rv.pushKV(\"type\", \"buried\");\n+    // getblockchaininfo reports the softfork as active from when the chain height is\n+    // one below the activation height\n+    rv.pushKV(\"active\", ::ChainActive().Tip()->nHeight + 1 >= height);\n+    rv.pushKV(\"height\", height);\n+    softforks.pushKV(name, rv);\n }\n \n-static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n+static void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    UniValue rv(UniValue::VOBJ);\n+    // For BIP9 deployments.\n+    // Deployments (e.g. testdummy) with timeout value before Jan 1, 2009 are hidden.\n+    // A timeout value of 0 guarantees a softfork will never be activated.\n+    // This is used when merging logic to implement a proposed softfork without a specified deployment schedule.\n+    if (consensusParams.vDeployments[id].nTimeout <= 1230768000) return;\n+\n+    UniValue bip9(UniValue::VOBJ);\n     const ThresholdState thresholdState = VersionBitsTipState(consensusParams, id);\n     switch (thresholdState) {\n-    case ThresholdState::DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n-    case ThresholdState::STARTED: rv.pushKV(\"status\", \"started\"); break;\n-    case ThresholdState::LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n-    case ThresholdState::ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n-    case ThresholdState::FAILED: rv.pushKV(\"status\", \"failed\"); break;\n+    case ThresholdState::DEFINED: bip9.pushKV(\"status\", \"defined\"); break;\n+    case ThresholdState::STARTED: bip9.pushKV(\"status\", \"started\"); break;\n+    case ThresholdState::LOCKED_IN: bip9.pushKV(\"status\", \"locked_in\"); break;\n+    case ThresholdState::ACTIVE: bip9.pushKV(\"status\", \"active\"); break;\n+    case ThresholdState::FAILED: bip9.pushKV(\"status\", \"failed\"); break;\n     }\n     if (ThresholdState::STARTED == thresholdState)\n     {\n-        rv.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n+        bip9.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n     }\n-    rv.pushKV(\"startTime\", consensusParams.vDeployments[id].nStartTime);\n-    rv.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n-    rv.pushKV(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id));\n+    bip9.pushKV(\"startTime\", consensusParams.vDeployments[id].nStartTime);\n+    bip9.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n+    int64_t since_height = VersionBitsTipStateSinceHeight(consensusParams, id);\n+    bip9.pushKV(\"since\", since_height);\n     if (ThresholdState::STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n@@ -1240,18 +1240,18 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n         statsUV.pushKV(\"elapsed\", statsStruct.elapsed);\n         statsUV.pushKV(\"count\", statsStruct.count);\n         statsUV.pushKV(\"possible\", statsStruct.possible);\n-        rv.pushKV(\"statistics\", statsUV);\n+        bip9.pushKV(\"statistics\", statsUV);\n     }\n-    return rv;\n-}\n \n-static void BIP9SoftForkDescPushBack(UniValue& bip9_softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n-{\n-    // Deployments with timeout value of 0 are hidden.\n-    // A timeout value of 0 guarantees a softfork will never be activated.\n-    // This is used when softfork codes are merged without specifying the deployment schedule.\n-    if (consensusParams.vDeployments[id].nTimeout > 0)\n-        bip9_softforks.pushKV(VersionBitsDeploymentInfo[id].name, BIP9SoftForkDesc(consensusParams, id));\n+    UniValue rv(UniValue::VOBJ);\n+    rv.pushKV(\"type\", \"bip9\");\n+    rv.pushKV(\"bip9\", bip9);\n+    if (ThresholdState::ACTIVE == thresholdState) {\n+        rv.pushKV(\"height\", since_height);\n+    }\n+    rv.pushKV(\"active\", ThresholdState::ACTIVE == thresholdState);\n+\n+    softforks.pushKV(name, rv);\n }\n \n UniValue getblockchaininfo(const JSONRPCRequest& request)\n@@ -1275,29 +1275,25 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n             \"  \\\"pruneheight\\\": xxxxxx,        (numeric) lowest-height complete block stored (only present if pruning is enabled)\\n\"\n             \"  \\\"automatic_pruning\\\": xx,      (boolean) whether automatic pruning is enabled (only present if pruning is enabled)\\n\"\n             \"  \\\"prune_target_size\\\": xxxxxx,  (numeric) the target size used by pruning (only present if automatic pruning is enabled)\\n\"\n-            \"  \\\"softforks\\\": [                (array) status of softforks in progress\\n\"\n-            \"     {\\n\"\n-            \"        \\\"id\\\": \\\"xxxx\\\",           (string) name of softfork\\n\"\n-            \"        \\\"version\\\": xx,          (numeric) block version\\n\"\n-            \"        \\\"reject\\\": {             (object) progress toward rejecting pre-softfork blocks\\n\"\n-            \"           \\\"status\\\": xx,        (boolean) true if threshold reached\\n\"\n-            \"        },\\n\"\n-            \"     }, ...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"bip9_softforks\\\": {           (object) status of BIP9 softforks in progress\\n\"\n+            \"  \\\"softforks\\\": {                (object) status of softforks\\n\"\n             \"     \\\"xxxx\\\" : {                 (string) name of the softfork\\n\"\n-            \"        \\\"status\\\": \\\"xxxx\\\",       (string) one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\\n\"\n-            \"        \\\"bit\\\": xx,              (numeric) the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" status)\\n\"\n-            \"        \\\"startTime\\\": xx,        (numeric) the minimum median time past of a block at which the bit gains its meaning\\n\"\n-            \"        \\\"timeout\\\": xx,          (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in\\n\"\n-            \"        \\\"since\\\": xx,            (numeric) height of the first block to which the status applies\\n\"\n-            \"        \\\"statistics\\\": {         (object) numeric statistics about BIP9 signalling for a softfork (only for \\\"started\\\" status)\\n\"\n-            \"           \\\"period\\\": xx,        (numeric) the length in blocks of the BIP9 signalling period \\n\"\n-            \"           \\\"threshold\\\": xx,     (numeric) the number of blocks with the version bit set required to activate the feature \\n\"\n-            \"           \\\"elapsed\\\": xx,       (numeric) the number of blocks elapsed since the beginning of the current period \\n\"\n-            \"           \\\"count\\\": xx,         (numeric) the number of blocks with the version bit set in the current period \\n\"\n-            \"           \\\"possible\\\": xx       (boolean) returns false if there are not enough blocks left in this period to pass activation threshold \\n\"\n-            \"        }\\n\"\n+            \"        \\\"type\\\": \\\"xxxx\\\",         (string) one of \\\"buried\\\", \\\"bip9\\\"\\n\"\n+            \"        \\\"bip9\\\": {               (object) status of bip9 softforks (only for \\\"bip9\\\" type)\\n\"\n+            \"           \\\"status\\\": \\\"xxxx\\\",    (string) one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\\n\"\n+            \"           \\\"bit\\\": xx,           (numeric) the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" status)\\n\"\n+            \"           \\\"startTime\\\": xx,     (numeric) the minimum median time past of a block at which the bit gains its meaning\\n\"\n+            \"           \\\"timeout\\\": xx,       (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in\\n\"\n+            \"           \\\"since\\\": xx,         (numeric) height of the first block to which the status applies\\n\"\n+            \"           \\\"statistics\\\": {      (object) numeric statistics about BIP9 signalling for a softfork\\n\"\n+            \"              \\\"period\\\": xx,     (numeric) the length in blocks of the BIP9 signalling period \\n\"\n+            \"              \\\"threshold\\\": xx,  (numeric) the number of blocks with the version bit set required to activate the feature \\n\"\n+            \"              \\\"elapsed\\\": xx,    (numeric) the number of blocks elapsed since the beginning of the current period \\n\"\n+            \"              \\\"count\\\": xx,      (numeric) the number of blocks with the version bit set in the current period \\n\"\n+            \"              \\\"possible\\\": xx    (boolean) returns false if there are not enough blocks left in this period to pass activation threshold \\n\"\n+            \"           }\\n\"\n+            \"        },\\n\"\n+            \"        \\\"height\\\": \\\"xxxxxx\\\",     (numeric) height of the first block which the rules are or will be enforced (only for \\\"buried\\\" type, or \\\"bip9\\\" type with \\\"active\\\" status)\\n\"\n+            \"        \\\"active\\\": xx,           (boolean) true if the rules are enforced for the mempool and the next block\\n\"\n             \"     }\\n\"\n             \"  }\\n\"\n             \"  \\\"warnings\\\" : \\\"...\\\",           (string) any network and blockchain warnings.\\n\"\n@@ -1342,16 +1338,14 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n     }\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n-    UniValue softforks(UniValue::VARR);\n-    UniValue bip9_softforks(UniValue::VOBJ);\n-    softforks.push_back(SoftForkDesc(\"bip34\", 2, tip, consensusParams));\n-    softforks.push_back(SoftForkDesc(\"bip66\", 3, tip, consensusParams));\n-    softforks.push_back(SoftForkDesc(\"bip65\", 4, tip, consensusParams));\n-    for (int pos = Consensus::DEPLOYMENT_CSV; pos != Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++pos) {\n-        BIP9SoftForkDescPushBack(bip9_softforks, consensusParams, static_cast<Consensus::DeploymentPos>(pos));\n-    }\n+    UniValue softforks(UniValue::VOBJ);\n+    BuriedForkDescPushBack(softforks, \"bip34\", consensusParams.BIP34Height);\n+    BuriedForkDescPushBack(softforks, \"bip66\", consensusParams.BIP66Height);\n+    BuriedForkDescPushBack(softforks, \"bip65\", consensusParams.BIP65Height);\n+    BuriedForkDescPushBack(softforks, \"csv\", consensusParams.CSVHeight);\n+    BuriedForkDescPushBack(softforks, \"segwit\", consensusParams.SegwitHeight);\n+    BIP9SoftForkDescPushBack(softforks, \"testdummy\", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);\n     obj.pushKV(\"softforks\",             softforks);\n-    obj.pushKV(\"bip9_softforks\", bip9_softforks);\n \n     obj.pushKV(\"warnings\", GetWarnings(\"statusbar\"));\n     return obj;\n@@ -2203,7 +2197,7 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n         {\n             LOCK(cs_main);\n             ::ChainstateActive().ForceFlushStateToDisk();\n-            pcursor = std::unique_ptr<CCoinsViewCursor>(pcoinsdbview->Cursor());\n+            pcursor = std::unique_ptr<CCoinsViewCursor>(::ChainstateActive().CoinsDB().Cursor());\n             assert(pcursor);\n         }\n         bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);"
      },
      {
        "sha": "07c2958635be6bf70d5f7529142878680beb0798",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -482,9 +482,8 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n         // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\n     }\n \n-    const struct VBDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\n     // GBT must be called with 'segwit' set in the rules\n-    if (setClientRules.count(segwit_info.name) != 1) {\n+    if (setClientRules.count(\"segwit\") != 1) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"getblocktemplate must be called with the segwit rule set (call with {\\\"rules\\\": [\\\"segwit\\\"]})\");\n     }\n \n@@ -521,7 +520,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n     pblock->nNonce = 0;\n \n     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n-    const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n+    const bool fPreSegWit = (pindexPrev->nHeight + 1 < consensusParams.SegwitHeight);\n \n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n "
      },
      {
        "sha": "ffbad457142dec413ec54f9cd5f50fa8bf8ac6c1",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -259,7 +259,7 @@ static UniValue gettxoutproof(const JSONRPCRequest& request)\n \n         // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n         for (const auto& tx : setTxids) {\n-            const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n+            const Coin& coin = AccessByTxid(::ChainstateActive().CoinsTip(), tx);\n             if (!coin.IsSpent()) {\n                 pblockindex = ::ChainActive()[coin.nHeight];\n                 break;\n@@ -636,7 +636,7 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     {\n         LOCK(cs_main);\n         LOCK(mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n@@ -1505,7 +1505,7 @@ UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n     CCoinsViewCache view(&viewDummy);\n     {\n         LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n "
      },
      {
        "sha": "c9661b730d9528f0726c438284a6056a249aed96",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -372,7 +372,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n         next->phashBlock = new uint256(InsecureRand256());\n-        pcoinsTip->SetBestBlock(next->GetBlockHash());\n+        ::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -384,7 +384,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         CBlockIndex* prev = ::ChainActive().Tip();\n         CBlockIndex* next = new CBlockIndex();\n         next->phashBlock = new uint256(InsecureRand256());\n-        pcoinsTip->SetBestBlock(next->GetBlockHash());\n+        ::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -414,7 +414,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (::ChainActive().Tip()->nHeight > nHeight) {\n         CBlockIndex* del = ::ChainActive().Tip();\n         ::ChainActive().SetTip(del->pprev);\n-        pcoinsTip->SetBestBlock(del->pprev->GetBlockHash());\n+        ::ChainstateActive().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n         delete del->phashBlock;\n         delete del;\n     }"
      },
      {
        "sha": "bbdf1ef830ee4a168ee78fadfca1699ab01f2d35",
        "filename": "src/test/setup_common.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/test/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/test/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/setup_common.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -85,8 +85,12 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n \n     mempool.setSanityCheck(1.0);\n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-    pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-    pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+    g_chainstate = MakeUnique<CChainState>();\n+    ::ChainstateActive().InitCoinsDB(\n+        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+    assert(!::ChainstateActive().CanFlushToDisk());\n+    ::ChainstateActive().InitCoinsCache();\n+    assert(::ChainstateActive().CanFlushToDisk());\n     if (!LoadGenesisBlock(chainparams)) {\n         throw std::runtime_error(\"LoadGenesisBlock failed.\");\n     }\n@@ -113,16 +117,15 @@ TestingSetup::~TestingSetup()\n     g_connman.reset();\n     g_banman.reset();\n     UnloadBlockIndex();\n-    pcoinsTip.reset();\n-    pcoinsdbview.reset();\n+    g_chainstate.reset();\n     pblocktree.reset();\n }\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)\n {\n     // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.\n     // TODO: fix the code to support SegWit blocks.\n-    gArgs.ForceSetArg(\"-vbparams\", strprintf(\"segwit:0:%d\", (int64_t)Consensus::BIP9Deployment::NO_TIMEOUT));\n+    gArgs.ForceSetArg(\"-segwitheight\", \"432\");\n     SelectParams(CBaseChainParams::REGTEST);\n \n     // Generate a 100-block chain:"
      },
      {
        "sha": "e69ebcc2c37844192fa71939701418b132b0bbd7",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -97,7 +97,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK_EQUAL(mempool.size(), 0U);\n }\n \n-// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n+// Run CheckInputs (using CoinsTip()) on the given transaction, for all script\n // flags.  Test that CheckInputs passes for all flags that don't overlap with\n // the failing_flags argument, but otherwise fails.\n // CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n@@ -125,7 +125,7 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n             // WITNESS requires P2SH\n             test_flags |= SCRIPT_VERIFY_P2SH;\n         }\n-        bool ret = CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, nullptr);\n+        bool ret = CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, nullptr);\n         // CheckInputs should succeed iff test_flags doesn't intersect with\n         // failing_flags\n         bool expected_return_value = !(test_flags & failing_flags);\n@@ -135,13 +135,13 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n         if (ret && add_to_cache) {\n             // Check that we get a cache hit if the tx was valid\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK(scriptchecks.empty());\n         } else {\n             // Check that we get script executions to check, if the transaction\n             // was invalid, or we didn't add to cache.\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n         }\n     }\n@@ -204,13 +204,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n@@ -227,7 +227,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n     LOCK(cs_main);\n     BOOST_CHECK(::ChainActive().Tip()->GetBlockHash() == block.GetHash());\n-    BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n+    BOOST_CHECK(::ChainstateActive().CoinsTip().GetBestBlock() == block.GetHash());\n \n     // Test P2SH: construct a transaction that is valid without P2SH, and\n     // then test validity with P2SH.\n@@ -272,7 +272,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -300,7 +300,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n@@ -362,12 +362,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(CTransaction(tx), state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      },
      {
        "sha": "18be07e6dbb023aeb6be2320d35eb150e9d2edc6",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -52,7 +52,7 @@ struct CoinEntry {\n \n }\n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true)\n+CCoinsViewDB::CCoinsViewDB(fs::path ldb_path, size_t nCacheSize, bool fMemory, bool fWipe) : db(ldb_path, nCacheSize, fMemory, fWipe, true)\n {\n }\n "
      },
      {
        "sha": "140ce2c7ff7d2637ef77f8441666303c8d22ef9b",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -48,7 +48,10 @@ class CCoinsViewDB final : public CCoinsView\n protected:\n     CDBWrapper db;\n public:\n-    explicit CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    /**\n+     * @param[in] ldb_path    Location in the filesystem where leveldb data will be stored.\n+     */\n+    explicit CCoinsViewDB(fs::path ldb_path, size_t nCacheSize, bool fMemory, bool fWipe);\n \n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;"
      },
      {
        "sha": "6e5ba445d3da1b836452c808b1d3488ea919e606",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -497,7 +497,7 @@ class CTxMemPool\n      *\n      * 1. Locking both `cs_main` and `mempool.cs` will give a view of mempool\n      *    that is consistent with current chain tip (`::ChainActive()` and\n-     *    `pcoinsTip`) and is fully populated. Fully populated means that if the\n+     *    `CoinsTip()`) and is fully populated. Fully populated means that if the\n      *    current active chain is missing transactions that were present in a\n      *    previously active chain, all the missing transactions will have been\n      *    re-added to the mempool and should be present if they meet size and"
      },
      {
        "sha": "74f68a30471de224a937224a293ecb2cd4a80afe",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 88,
        "deletions": 48,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -82,11 +82,17 @@ namespace {\n BlockManager g_blockman;\n } // anon namespace\n \n-static CChainState g_chainstate(g_blockman);\n+std::unique_ptr<CChainState> g_chainstate;\n \n-CChainState& ChainstateActive() { return g_chainstate; }\n+CChainState& ChainstateActive() {\n+    assert(g_chainstate);\n+    return *g_chainstate;\n+}\n \n-CChain& ChainActive() { return g_chainstate.m_chain; }\n+CChain& ChainActive() {\n+    assert(g_chainstate);\n+    return g_chainstate->m_chain;\n+}\n \n /**\n  * Mutex to guard access to validation specific variables, such as reading\n@@ -173,8 +179,6 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n     return chain.Genesis();\n }\n \n-std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n-std::unique_ptr<CCoinsViewCache> pcoinsTip;\n std::unique_ptr<CBlockTreeDB> pblocktree;\n \n // See definition for documentation\n@@ -260,8 +264,8 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n         lockPair.second = lp->time;\n     }\n     else {\n-        // pcoinsTip contains the UTXO set for ::ChainActive().Tip()\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+        // CoinsTip() contains the UTXO set for ::ChainActive().Tip()\n+        CCoinsViewMemPool viewMemPool(&::ChainstateActive().CoinsTip(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n@@ -310,7 +314,8 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n // Returns the script flags which should be checked for a given block\n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n \n-static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age)\n+    EXCLUSIVE_LOCKS_REQUIRED(pool.cs, ::cs_main)\n {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -320,7 +325,7 @@ static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age)\n     std::vector<COutPoint> vNoSpendsRemaining;\n     pool.TrimToSize(limit, &vNoSpendsRemaining);\n     for (const COutPoint& removed : vNoSpendsRemaining)\n-        pcoinsTip->Uncache(removed);\n+        ::ChainstateActive().CoinsTip().Uncache(removed);\n }\n \n static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -382,7 +387,7 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n     mempool.UpdateTransactionsFromBlock(vHashUpdate);\n \n     // We also need to remove any now-immature transactions\n-    mempool.removeForReorg(pcoinsTip.get(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    mempool.removeForReorg(&::ChainstateActive().CoinsTip(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     // Re-limit mempool size, in case we added any transactions\n     LimitMempoolSize(mempool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n@@ -414,7 +419,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n             assert(txFrom->vout.size() > txin.prevout.n);\n             assert(txFrom->vout[txin.prevout.n] == coin.out);\n         } else {\n-            const Coin& coinFromDisk = pcoinsTip->AccessCoin(txin.prevout);\n+            const Coin& coinFromDisk = ::ChainstateActive().CoinsTip().AccessCoin(txin.prevout);\n             assert(!coinFromDisk.IsSpent());\n             assert(coinFromDisk.out == coin.out);\n         }\n@@ -514,23 +519,24 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         CCoinsViewCache view(&dummy);\n \n         LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+        CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+        CCoinsViewMemPool viewMemPool(&coins_cache, pool);\n         view.SetBackend(viewMemPool);\n \n         // do all inputs exist?\n         for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n                 coins_to_uncache.push_back(txin.prevout);\n             }\n \n             // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+            // (CoinsTip().cacheCoins) by way of FetchCoin(). It should be removed\n             // later (via coins_to_uncache) if this tx turns out to be invalid.\n             if (!view.HaveCoin(txin.prevout)) {\n                 // Are inputs missing because we already have the tx?\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n                         return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n@@ -860,7 +866,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n         // (`CCoinsViewCache::cacheCoins`).\n \n         for (const COutPoint& hashTx : coins_to_uncache)\n-            pcoinsTip->Uncache(hashTx);\n+            ::ChainstateActive().CoinsTip().Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n@@ -1040,6 +1046,40 @@ CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n     return nSubsidy;\n }\n \n+CoinsViews::CoinsViews(\n+    std::string ldb_name,\n+    size_t cache_size_bytes,\n+    bool in_memory,\n+    bool should_wipe) : m_dbview(\n+                            GetDataDir() / ldb_name, cache_size_bytes, in_memory, should_wipe),\n+                        m_catcherview(&m_dbview) {}\n+\n+void CoinsViews::InitCache()\n+{\n+    m_cacheview = MakeUnique<CCoinsViewCache>(&m_catcherview);\n+}\n+\n+// NOTE: for now m_blockman is set to a global, but this will be changed\n+// in a future commit.\n+CChainState::CChainState() : m_blockman(g_blockman) {}\n+\n+\n+void CChainState::InitCoinsDB(\n+    size_t cache_size_bytes,\n+    bool in_memory,\n+    bool should_wipe,\n+    std::string leveldb_name)\n+{\n+    m_coins_views = MakeUnique<CoinsViews>(\n+        leveldb_name, cache_size_bytes, in_memory, should_wipe);\n+}\n+\n+void CChainState::InitCoinsCache()\n+{\n+    assert(m_coins_views != nullptr);\n+    m_coins_views->InitCache();\n+}\n+\n // Note that though this is marked const, we may end up modifying `m_cached_finished_ibd`, which\n // is a performance-related implementation detail. This function must be marked\n // `const` so that `CValidationInterface` clients (which are given a `const CChainState*`)\n@@ -1608,7 +1648,7 @@ static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS] GUARDED_BY(cs_\n // environment. See test/functional/p2p-segwit.py.\n static bool IsScriptWitnessEnabled(const Consensus::Params& params)\n {\n-    return params.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0;\n+    return params.SegwitHeight != std::numeric_limits<int>::max();\n }\n \n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n@@ -1644,12 +1684,13 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n         flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n     }\n \n-    // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n-    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n+    // Start enforcing BIP112 (CHECKSEQUENCEVERIFY)\n+    if (pindex->nHeight >= consensusparams.CSVHeight) {\n         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n     }\n \n-    if (IsNullDummyEnabled(pindex->pprev, consensusparams)) {\n+    // Start enforcing BIP147 NULLDUMMY (activated simultaneously with segwit)\n+    if (IsWitnessEnabled(pindex->pprev, consensusparams)) {\n         flags |= SCRIPT_VERIFY_NULLDUMMY;\n     }\n \n@@ -1834,9 +1875,9 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         }\n     }\n \n-    // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n+    // Start enforcing BIP68 (sequence locks)\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n+    if (pindex->nHeight >= chainparams.GetConsensus().CSVHeight) {\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n@@ -1981,6 +2022,7 @@ bool CChainState::FlushStateToDisk(\n {\n     int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n     LOCK(cs_main);\n+    assert(this->CanFlushToDisk());\n     static int64_t nLastWrite = 0;\n     static int64_t nLastFlush = 0;\n     std::set<int> setFilesToPrune;\n@@ -2014,7 +2056,7 @@ bool CChainState::FlushStateToDisk(\n             nLastFlush = nNow;\n         }\n         int64_t nMempoolSizeMax = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n-        int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n+        int64_t cacheSize = CoinsTip().DynamicMemoryUsage();\n         int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n         // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n         bool fCacheLarge = mode == FlushStateMode::PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n@@ -2058,17 +2100,17 @@ bool CChainState::FlushStateToDisk(\n             nLastWrite = nNow;\n         }\n         // Flush best chain related state. This can only be done if the blocks / block index write was also done.\n-        if (fDoFullFlush && !pcoinsTip->GetBestBlock().IsNull()) {\n+        if (fDoFullFlush && !CoinsTip().GetBestBlock().IsNull()) {\n             // Typical Coin structures on disk are around 48 bytes in size.\n             // Pushing a new one to the database can cause it to be written\n             // twice (once in the log, and once in the tables). This is already\n             // an overestimation, as most will delete an existing entry or\n             // overwrite one. Still, use a conservative safety factor of 2.\n-            if (!CheckDiskSpace(GetDataDir(), 48 * 2 * 2 * pcoinsTip->GetCacheSize())) {\n+            if (!CheckDiskSpace(GetDataDir(), 48 * 2 * 2 * CoinsTip().GetCacheSize())) {\n                 return AbortNode(state, \"Disk space is too low!\", _(\"Error: Disk space is too low!\").translated, CClientUIInterface::MSG_NOPREFIX);\n             }\n             // Flush the chainstate (which may refer to block index entries).\n-            if (!pcoinsTip->Flush())\n+            if (!CoinsTip().Flush())\n                 return AbortNode(state, \"Failed to write to coin database\");\n             nLastFlush = nNow;\n             full_flush_completed = true;\n@@ -2120,7 +2162,9 @@ static void AppendWarning(std::string& res, const std::string& warn)\n }\n \n /** Check warning conditions and do some notifications on new chain tip set. */\n-void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainParams) {\n+void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainParams)\n+    EXCLUSIVE_LOCKS_REQUIRED(::cs_main)\n+{\n     // New best block\n     mempool.AddTransactionsUpdated(1);\n \n@@ -2162,7 +2206,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight, pindexNew->nVersion,\n       log(pindexNew->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n       FormatISO8601DateTime(pindexNew->GetBlockTime()),\n-      GuessVerificationProgress(chainParams.TxData(), pindexNew), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize());\n+      GuessVerificationProgress(chainParams.TxData(), pindexNew), ::ChainstateActive().CoinsTip().DynamicMemoryUsage() * (1.0 / (1<<20)), ::ChainstateActive().CoinsTip().GetCacheSize());\n     if (!warningMessages.empty())\n         LogPrintf(\" warning='%s'\", warningMessages); /* Continued */\n     LogPrintf(\"\\n\");\n@@ -2191,7 +2235,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n     // Apply the block atomically to the chain state.\n     int64_t nStart = GetTimeMicros();\n     {\n-        CCoinsViewCache view(pcoinsTip.get());\n+        CCoinsViewCache view(&CoinsTip());\n         assert(view.GetBestBlock() == pindexDelete->GetBlockHash());\n         if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n@@ -2319,7 +2363,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     int64_t nTime3;\n     LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * MILLI, nTimeReadFromDisk * MICRO);\n     {\n-        CCoinsViewCache view(pcoinsTip.get());\n+        CCoinsViewCache view(&CoinsTip());\n         bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);\n         GetMainSignals().BlockChecked(blockConnecting, state);\n         if (!rv) {\n@@ -2506,7 +2550,7 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n         // any disconnected transactions back to the mempool.\n         UpdateMempoolForReorg(disconnectpool, true);\n     }\n-    mempool.check(pcoinsTip.get());\n+    mempool.check(&CoinsTip());\n \n     // Callbacks/notifications for a new best chain.\n     if (fInvalidFound)\n@@ -3045,14 +3089,8 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n {\n-    LOCK(cs_main);\n-    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE);\n-}\n-\n-bool IsNullDummyEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n-{\n-    LOCK(cs_main);\n-    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE);\n+    int height = pindexPrev == nullptr ? 0 : pindexPrev->nHeight + 1;\n+    return (height >= params.SegwitHeight);\n }\n \n // Compute at which vout of the block's coinbase transaction the witness\n@@ -3087,7 +3125,7 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     std::vector<unsigned char> commitment;\n     int commitpos = GetWitnessCommitmentIndex(block);\n     std::vector<unsigned char> ret(32, 0x00);\n-    if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {\n+    if (consensusParams.SegwitHeight != std::numeric_limits<int>::max()) {\n         if (commitpos == -1) {\n             uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);\n             CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());\n@@ -3185,9 +3223,9 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n {\n     const int nHeight = pindexPrev == nullptr ? 0 : pindexPrev->nHeight + 1;\n \n-    // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n+    // Start enforcing BIP113 (Median Time Past).\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n+    if (nHeight >= consensusParams.CSVHeight) {\n         assert(pindexPrev != nullptr);\n         nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;\n     }\n@@ -3222,7 +3260,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness reserved value). In case there are\n     //   multiple, the last one is used.\n     bool fHaveWitness = false;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE) {\n+    if (nHeight >= consensusParams.SegwitHeight) {\n         int commitpos = GetWitnessCommitmentIndex(block);\n         if (commitpos != -1) {\n             bool malleated = false;\n@@ -3508,7 +3546,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n {\n     AssertLockHeld(cs_main);\n     assert(pindexPrev && pindexPrev == ::ChainActive().Tip());\n-    CCoinsViewCache viewNew(pcoinsTip.get());\n+    CCoinsViewCache viewNew(&::ChainstateActive().CoinsTip());\n     uint256 block_hash(block.GetHash());\n     CBlockIndex indexDummy(block);\n     indexDummy.pprev = pindexPrev;\n@@ -3861,12 +3899,14 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_RE\n bool LoadChainTip(const CChainParams& chainparams)\n {\n     AssertLockHeld(cs_main);\n-    assert(!pcoinsTip->GetBestBlock().IsNull()); // Never called when the coins view is empty\n+    const CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+    assert(!coins_cache.GetBestBlock().IsNull()); // Never called when the coins view is empty\n \n-    if (::ChainActive().Tip() && ::ChainActive().Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return true;\n+    if (::ChainActive().Tip() &&\n+        ::ChainActive().Tip()->GetBlockHash() == coins_cache.GetBestBlock()) return true;\n \n     // Load pointer to end of best chain\n-    CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n+    CBlockIndex* pindex = LookupBlockIndex(coins_cache.GetBestBlock());\n     if (!pindex) {\n         return false;\n     }\n@@ -3943,7 +3983,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n             }\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n-        if (nCheckLevel >= 3 && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n+        if (nCheckLevel >= 3 && (coins.DynamicMemoryUsage() + ::ChainstateActive().CoinsTip().DynamicMemoryUsage()) <= nCoinCacheUsage) {\n             assert(coins.GetBestBlock() == pindex->GetBlockHash());\n             DisconnectResult res = ::ChainstateActive().DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {"
      },
      {
        "sha": "7cf3311f226087e201ba3dcd67c870c0e5525110",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 94,
        "deletions": 12,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -19,6 +19,7 @@\n #include <script/script_error.h>\n #include <sync.h>\n #include <txmempool.h> // For CTxMemPool::cs\n+#include <txdb.h>\n #include <versionbits.h>\n \n #include <algorithm>\n@@ -37,7 +38,6 @@ class CBlockIndex;\n class CBlockTreeDB;\n class CBlockUndo;\n class CChainParams;\n-class CCoinsViewDB;\n class CInv;\n class CConnman;\n class CScriptCheck;\n@@ -383,12 +383,10 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n /** Check a block is completely valid from start to finish (only works on top of our current best block) */\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-/** Check whether witness commitments are required for block. */\n+/** Check whether witness commitments are required for a block, and whether to enforce NULLDUMMY (BIP 147) rules.\n+ *  Note that transaction witness validation rules are always enforced when P2SH is enforced. */\n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n \n-/** Check whether NULLDUMMY (BIP 147) has activated. */\n-bool IsNullDummyEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n-\n /** When there are blocks in the active chain with missing data, rewind the chainstate and remove them from the block index */\n bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n \n@@ -505,6 +503,41 @@ class BlockManager {\n         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n+/**\n+ * A convenience class for constructing the CCoinsView* hierarchy used\n+ * to facilitate access to the UTXO set.\n+ *\n+ * This class consists of an arrangement of layered CCoinsView objects,\n+ * preferring to store and retrieve coins in memory via `m_cacheview` but\n+ * ultimately falling back on cache misses to the canonical store of UTXOs on\n+ * disk, `m_dbview`.\n+ */\n+class CoinsViews {\n+\n+public:\n+    //! The lowest level of the CoinsViews cache hierarchy sits in a leveldb database on disk.\n+    //! All unspent coins reside in this store.\n+    CCoinsViewDB m_dbview GUARDED_BY(cs_main);\n+\n+    //! This view wraps access to the leveldb instance and handles read errors gracefully.\n+    CCoinsViewErrorCatcher m_catcherview GUARDED_BY(cs_main);\n+\n+    //! This is the top layer of the cache hierarchy - it keeps as many coins in memory as\n+    //! can fit per the dbcache setting.\n+    std::unique_ptr<CCoinsViewCache> m_cacheview GUARDED_BY(cs_main);\n+\n+    //! This constructor initializes CCoinsViewDB and CCoinsViewErrorCatcher instances, but it\n+    //! *does not* create a CCoinsViewCache instance by default. This is done separately because the\n+    //! presence of the cache has implications on whether or not we're allowed to flush the cache's\n+    //! state to disk, which should not be done until the health of the database is verified.\n+    //!\n+    //! All arguments forwarded onto CCoinsViewDB.\n+    CoinsViews(std::string ldb_name, size_t cache_size_bytes, bool in_memory, bool should_wipe);\n+\n+    //! Initialize the CCoinsViewCache member.\n+    void InitCache() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+};\n+\n /**\n  * CChainState stores and provides an API to update our local knowledge of the\n  * current best chain.\n@@ -553,19 +586,69 @@ class CChainState {\n     //! easily as opposed to referencing a global.\n     BlockManager& m_blockman;\n \n+    //! Manages the UTXO set, which is a reflection of the contents of `m_chain`.\n+    std::unique_ptr<CoinsViews> m_coins_views;\n+\n public:\n-    CChainState(BlockManager& blockman) : m_blockman(blockman) { }\n+    CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n+    CChainState();\n+\n+    /**\n+     * Initialize the CoinsViews UTXO set database management data structures. The in-memory\n+     * cache is initialized separately.\n+     *\n+     * All parameters forwarded to CoinsViews.\n+     */\n+    void InitCoinsDB(\n+        size_t cache_size_bytes,\n+        bool in_memory,\n+        bool should_wipe,\n+        std::string leveldb_name = \"chainstate\");\n+\n+    //! Initialize the in-memory coins cache (to be done after the health of the on-disk database\n+    //! is verified).\n+    void InitCoinsCache() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n+    //! @returns whether or not the CoinsViews object has been fully initialized and we can\n+    //!          safely flush this object to disk.\n+    bool CanFlushToDisk() EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+        return m_coins_views && m_coins_views->m_cacheview;\n+    }\n \n     //! The current chain of blockheaders we consult and build on.\n     //! @see CChain, CBlockIndex.\n     CChain m_chain;\n+\n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n      * missing the data for the block.\n      */\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n \n+    //! @returns A reference to the in-memory cache of the UTXO set.\n+    CCoinsViewCache& CoinsTip() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+    {\n+        assert(m_coins_views->m_cacheview);\n+        return *m_coins_views->m_cacheview.get();\n+    }\n+\n+    //! @returns A reference to the on-disk UTXO set database.\n+    CCoinsViewDB& CoinsDB() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+    {\n+        return m_coins_views->m_dbview;\n+    }\n+\n+    //! @returns A reference to a wrapped view of the in-memory UTXO set that\n+    //!     handles disk read errors gracefully.\n+    CCoinsViewErrorCatcher& CoinsErrorCatcher() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+    {\n+        return m_coins_views->m_catcherview;\n+    }\n+\n+    //! Destructs all objects related to accessing the UTXO set.\n+    void ResetCoinsViews() { m_coins_views.reset(); }\n+\n     /**\n      * Update the on-disk chain state.\n      * The caches and indexes are flushed depending on the mode we're called with\n@@ -597,7 +680,7 @@ class CChainState {\n     bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n                       CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    // Block disconnection on our pcoinsTip:\n+    // Apply the effects of a block disconnection on the UTXO set.\n     bool DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n \n     // Manual block validity manipulation:\n@@ -659,11 +742,10 @@ CChain& ChainActive();\n /** @returns the global block index map. */\n BlockMap& BlockIndex();\n \n-/** Global variable that points to the coins database (protected by cs_main) */\n-extern std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n-\n-/** Global variable that points to the active CCoinsView (protected by cs_main) */\n-extern std::unique_ptr<CCoinsViewCache> pcoinsTip;\n+// Most often ::ChainstateActive() should be used instead of this, but some code\n+// may not be able to assume that this has been initialized yet and so must use it\n+// directly, e.g. init.cpp.\n+extern std::unique_ptr<CChainState> g_chainstate;\n \n /** Global variable that points to the active block tree (protected by cs_main) */\n extern std::unique_ptr<CBlockTreeDB> pblocktree;"
      },
      {
        "sha": "82df92ac90aebb04f36af9ea93afc2dd7d065dbe",
        "filename": "src/versionbitsinfo.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/versionbitsinfo.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/src/versionbitsinfo.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbitsinfo.cpp?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -11,12 +11,4 @@ const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_B\n         /*.name =*/ \"testdummy\",\n         /*.gbt_force =*/ true,\n     },\n-    {\n-        /*.name =*/ \"csv\",\n-        /*.gbt_force =*/ true,\n-    },\n-    {\n-        /*.name =*/ \"segwit\",\n-        /*.gbt_force =*/ true,\n-    }\n };"
      },
      {
        "sha": "fe6f9eade1491b169618bd3e8935535cc6d7e9f4",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -14,8 +14,8 @@\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n-    get_bip9_status,\n     satoshi_round,\n+    softfork_active,\n )\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n@@ -52,7 +52,7 @@ def run_test(self):\n         self.log.info(\"Running test sequence-lock-unconfirmed-inputs\")\n         self.test_sequence_lock_unconfirmed_inputs()\n \n-        self.log.info(\"Running test BIP68 not consensus before versionbits activation\")\n+        self.log.info(\"Running test BIP68 not consensus before activation\")\n         self.test_bip68_not_consensus()\n \n         self.log.info(\"Activating BIP68 (and 112/113)\")\n@@ -336,12 +336,12 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         self.nodes[0].invalidateblock(self.nodes[0].getblockhash(cur_height+1))\n         self.nodes[0].generate(10)\n \n-    # Make sure that BIP68 isn't being used to validate blocks, prior to\n-    # versionbits activation.  If more blocks are mined prior to this test\n+    # Make sure that BIP68 isn't being used to validate blocks prior to\n+    # activation height.  If more blocks are mined prior to this test\n     # being run, then it's possible the test has activated the soft fork, and\n     # this test should be moved to run earlier, or deleted.\n     def test_bip68_not_consensus(self):\n-        assert get_bip9_status(self.nodes[0], 'csv')['status'] != 'active'\n+        assert not softfork_active(self.nodes[0], 'csv')\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n \n         tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n@@ -391,9 +391,9 @@ def activateCSV(self):\n         height = self.nodes[0].getblockcount()\n         assert_greater_than(min_activation_height - height, 2)\n         self.nodes[0].generate(min_activation_height - height - 2)\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], \"locked_in\")\n+        assert not softfork_active(self.nodes[0], 'csv')\n         self.nodes[0].generate(1)\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], \"active\")\n+        assert softfork_active(self.nodes[0], 'csv')\n         self.sync_blocks()\n \n     # Use self.nodes[1] to test that version 2 transactions are standard."
      },
      {
        "sha": "e00219ca4a5ae106bf910f8415cae2114a44aae0",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -69,14 +69,11 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def test_cltv_info(self, *, is_active):\n-        assert_equal(\n-            next(s for s in self.nodes[0].getblockchaininfo()['softforks'] if s['id'] == 'bip65'),\n+        assert_equal(self.nodes[0].getblockchaininfo()['softforks']['bip65'],\n             {\n-                \"id\": \"bip65\",\n-                \"version\": 4,\n-                \"reject\": {\n-                    \"status\": is_active\n-                }\n+                \"active\": is_active,\n+                \"height\": CLTV_HEIGHT,\n+                \"type\": \"buried\",\n             },\n         )\n \n@@ -104,9 +101,9 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        self.test_cltv_info(is_active=False)\n+        self.test_cltv_info(is_active=False)  # Not active as of current tip and next block does not need to obey rules\n         self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        self.test_cltv_info(is_active=False)  # Not active as of current tip, but next block must obey rules\n+        self.test_cltv_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         self.log.info(\"Test that blocks must now be at least version 4\")\n@@ -155,7 +152,7 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        self.test_cltv_info(is_active=False)  # Not active as of current tip, but next block must obey rules\n+        self.test_cltv_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n         self.nodes[0].p2p.send_and_ping(msg_block(block))\n         self.test_cltv_info(is_active=True)  # Active as of current tip\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)"
      },
      {
        "sha": "6bd321992abf14eecb72f3412facc40e5c8ff167",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 31,
        "deletions": 66,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -2,23 +2,17 @@\n # Copyright (c) 2015-2019 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test activation of the first version bits soft fork.\n+\"\"\"Test CSV soft fork activation.\n \n This soft fork will activate the following BIPS:\n BIP 68  - nSequence relative lock times\n BIP 112 - CHECKSEQUENCEVERIFY\n BIP 113 - MedianTimePast semantics for nLockTime\n \n-regtest lock-in with 108/144 block signalling\n-activation after a further 144 blocks\n-\n mine 82 blocks whose coinbases will be used to generate inputs for our tests\n-mine 61 blocks to transition from DEFINED to STARTED\n-mine 144 blocks only 100 of which are signaling readiness in order to fail to change state this period\n-mine 144 blocks with 108 signaling and verify STARTED->LOCKED_IN\n-mine 140 blocks and seed block chain with the 82 inputs will use for our tests at height 572\n-mine 3 blocks and verify still at LOCKED_IN and test that enforcement has not triggered\n-mine 1 block and test that enforcement has triggered (which triggers ACTIVE)\n+mine 345 blocks and seed block chain with the 82 inputs will use for our tests at height 427\n+mine 2 blocks and verify soft fork not yet activated\n+mine 1 block and test that soft fork is activated (rules enforced for next block)\n Test BIP 113 is enforced\n Mine 4 blocks so next height is 580 and test BIP 68 is enforced for time and height\n Mine 1 block so next height is 581 and test BIP 68 now passes time but not height\n@@ -58,11 +52,12 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    get_bip9_status,\n     hex_str_to_bytes,\n+    softfork_active,\n )\n \n BASE_RELATIVE_LOCKTIME = 10\n+CSV_ACTIVATION_HEIGHT = 432\n SEQ_DISABLE_FLAG = 1 << 31\n SEQ_RANDOM_HIGH_BIT = 1 << 25\n SEQ_TYPE_FLAG = 1 << 22\n@@ -148,20 +143,19 @@ def set_test_params(self):\n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n-    def generate_blocks(self, number, version, test_blocks=None):\n-        if test_blocks is None:\n-            test_blocks = []\n+    def generate_blocks(self, number):\n+        test_blocks = []\n         for i in range(number):\n-            block = self.create_test_block([], version)\n+            block = self.create_test_block([])\n             test_blocks.append(block)\n             self.last_block_time += 600\n             self.tip = block.sha256\n             self.tipheight += 1\n         return test_blocks\n \n-    def create_test_block(self, txs, version=536870912):\n+    def create_test_block(self, txs):\n         block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n-        block.nVersion = version\n+        block.nVersion = 4\n         block.vtx.extend(txs)\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.rehash()\n@@ -187,45 +181,14 @@ def run_test(self):\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n \n-        self.log.info(\"Test that the csv softfork is DEFINED\")\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'defined')\n-        test_blocks = self.generate_blocks(61, 4)\n-        self.send_blocks(test_blocks)\n-\n-        self.log.info(\"Advance from DEFINED to STARTED, height = 143\")\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n-\n-        self.log.info(\"Fail to achieve LOCKED_IN\")\n-        # 100 out of 144 signal bit 0. Use a variety of bits to simulate multiple parallel softforks\n-\n-        test_blocks = self.generate_blocks(50, 536870913)  # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(20, 4, test_blocks)  # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(24, 536936448, test_blocks)  # 0x20010000 (signalling not)\n-        self.send_blocks(test_blocks)\n-\n-        self.log.info(\"Failed to advance past STARTED, height = 287\")\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n-\n-        self.log.info(\"Generate blocks to achieve LOCK-IN\")\n-        # 108 out of 144 signal bit 0 to achieve lock-in\n-        # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(58, 536870913)  # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(26, 4, test_blocks)  # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(10, 536936448, test_blocks)  # 0x20010000 (signalling not)\n-        self.send_blocks(test_blocks)\n-\n-        self.log.info(\"Advanced from STARTED to LOCKED_IN, height = 431\")\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n-\n-        # Generate 140 more version 4 blocks\n-        test_blocks = self.generate_blocks(140, 4)\n+        # Activation height is hardcoded\n+        test_blocks = self.generate_blocks(345)\n         self.send_blocks(test_blocks)\n+        assert not softfork_active(self.nodes[0], 'csv')\n \n-        # Inputs at height = 572\n+        # Inputs at height = 431\n         #\n-        # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n+        # Put inputs for all tests in the chain at height 431 (tip now = 430) (time increases by 600s per block)\n         # Note we reuse inputs for v1 and v2 txs so must test these separately\n         # 16 normal inputs\n         bip68inputs = []\n@@ -255,19 +218,20 @@ def run_test(self):\n         bip113input = send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n-        inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 572\n+        inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 431\n         self.nodes[0].setmocktime(0)\n         self.tip = int(inputblockhash, 16)\n         self.tipheight += 1\n         self.last_block_time += 600\n         assert_equal(len(self.nodes[0].getblock(inputblockhash, True)[\"tx\"]), 82 + 1)\n \n         # 2 more version 4 blocks\n-        test_blocks = self.generate_blocks(2, 4)\n+        test_blocks = self.generate_blocks(2)\n         self.send_blocks(test_blocks)\n \n-        self.log.info(\"Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\")\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n+        assert_equal(self.tipheight, CSV_ACTIVATION_HEIGHT - 2)\n+        self.log.info(\"Height = {}, CSV not yet active (will activate for block {}, not {})\".format(self.tipheight, CSV_ACTIVATION_HEIGHT, CSV_ACTIVATION_HEIGHT - 1))\n+        assert not softfork_active(self.nodes[0], 'csv')\n \n         # Test both version 1 and version 2 transactions for all tests\n         # BIP113 test transaction will be modified before each use to put in appropriate block time\n@@ -340,10 +304,11 @@ def run_test(self):\n         self.send_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n-        test_blocks = self.generate_blocks(1, 4)\n+        # 1 more version 4 block to get us to height 432 so the fork should now be active for the next block\n+        assert not softfork_active(self.nodes[0], 'csv')\n+        test_blocks = self.generate_blocks(1)\n         self.send_blocks(test_blocks)\n-        assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'active')\n+        assert softfork_active(self.nodes[0], 'csv')\n \n         self.log.info(\"Post-Soft Fork Tests.\")\n \n@@ -364,8 +329,8 @@ def run_test(self):\n             self.send_blocks([self.create_test_block([bip113tx])])\n             self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        # Next block height = 580 after 4 blocks of random version\n-        test_blocks = self.generate_blocks(4, 1234)\n+        # Next block height = 437 after 4 blocks of random version\n+        test_blocks = self.generate_blocks(4)\n         self.send_blocks(test_blocks)\n \n         self.log.info(\"BIP 68 tests\")\n@@ -392,8 +357,8 @@ def run_test(self):\n         for tx in bip68heighttxs:\n             self.send_blocks([self.create_test_block([tx])], success=False)\n \n-        # Advance one block to 581\n-        test_blocks = self.generate_blocks(1, 1234)\n+        # Advance one block to 438\n+        test_blocks = self.generate_blocks(1)\n         self.send_blocks(test_blocks)\n \n         # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n@@ -403,8 +368,8 @@ def run_test(self):\n         for tx in bip68heighttxs:\n             self.send_blocks([self.create_test_block([tx])], success=False)\n \n-        # Advance one block to 582\n-        test_blocks = self.generate_blocks(1, 1234)\n+        # Advance one block to 439\n+        test_blocks = self.generate_blocks(1)\n         self.send_blocks(test_blocks)\n \n         # All BIP 68 txs should pass"
      },
      {
        "sha": "b86f6af4ca8d750dc79f646621e00c237824fc70",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -58,7 +58,7 @@ def set_test_params(self):\n         self.base_args = [\"-limitdescendantsize=0\", \"-maxmempool=0\", \"-rpcservertimeout=900\", \"-dbbatchsize=200000\"]\n \n         # Set different crash ratios and cache sizes.  Note that not all of\n-        # -dbcache goes to pcoinsTip.\n+        # -dbcache goes to the in-memory coins cache.\n         self.node0_args = [\"-dbcrashratio=8\", \"-dbcache=4\"] + self.base_args\n         self.node1_args = [\"-dbcrashratio=16\", \"-dbcache=8\"] + self.base_args\n         self.node2_args = [\"-dbcrashratio=24\", \"-dbcache=16\"] + self.base_args"
      },
      {
        "sha": "1bd95863645b44166553f4bc57ba7987b4374554",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -52,14 +52,11 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def test_dersig_info(self, *, is_active):\n-        assert_equal(\n-            next(s for s in self.nodes[0].getblockchaininfo()['softforks'] if s['id'] == 'bip66'),\n+        assert_equal(self.nodes[0].getblockchaininfo()['softforks']['bip66'],\n             {\n-                \"id\": \"bip66\",\n-                \"version\": 3,\n-                \"reject\": {\n-                    \"status\": is_active\n-                }\n+                \"active\": is_active,\n+                \"height\": DERSIG_HEIGHT,\n+                \"type\": \"buried\",\n             },\n         )\n \n@@ -88,9 +85,9 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        self.test_dersig_info(is_active=False)\n+        self.test_dersig_info(is_active=False)  # Not active as of current tip and next block does not need to obey rules\n         self.nodes[0].p2p.send_and_ping(msg_block(block))\n-        self.test_dersig_info(is_active=False)  # Not active as of current tip, but next block must obey rules\n+        self.test_dersig_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         self.log.info(\"Test that blocks must now be at least version 3\")\n@@ -144,7 +141,7 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        self.test_dersig_info(is_active=False)  # Not active as of current tip, but next block must obey rules\n+        self.test_dersig_info(is_active=True)  # Not active as of current tip, but next block must obey rules\n         self.nodes[0].p2p.send_and_ping(msg_block(block))\n         self.test_dersig_info(is_active=True)  # Active as of current tip\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)"
      },
      {
        "sha": "250dee1528ebab9addce07a83d0241aac3e8e9c4",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -41,7 +41,7 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         # This script tests NULLDUMMY activation, which is part of the 'segwit' deployment, so we go through\n         # normal segwit activation here (and don't use the default always-on behaviour).\n-        self.extra_args = [['-whitelist=127.0.0.1', '-vbparams=segwit:0:999999999999', '-addresstype=legacy']]\n+        self.extra_args = [['-whitelist=127.0.0.1', '-segwitheight=432', '-addresstype=legacy']]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()"
      },
      {
        "sha": "d47065d1cbe810b39eb97748eff2890740bebb39",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -55,20 +55,20 @@ def set_test_params(self):\n             [\n                 \"-acceptnonstdtxn=1\",\n                 \"-rpcserialversion=0\",\n-                \"-vbparams=segwit:0:999999999999\",\n+                \"-segwitheight=432\",\n                 \"-addresstype=legacy\",\n             ],\n             [\n                 \"-acceptnonstdtxn=1\",\n                 \"-blockversion=4\",\n                 \"-rpcserialversion=1\",\n-                \"-vbparams=segwit:0:999999999999\",\n+                \"-segwitheight=432\",\n                 \"-addresstype=legacy\",\n             ],\n             [\n                 \"-acceptnonstdtxn=1\",\n                 \"-blockversion=536870915\",\n-                \"-vbparams=segwit:0:999999999999\",\n+                \"-segwitheight=432\",\n                 \"-addresstype=legacy\",\n             ],\n         ]"
      },
      {
        "sha": "7905cf5018ca6a1aa4b55ea08316f727e216c71c",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -14,7 +14,7 @@\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.script import CScript, OP_TRUE, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, get_bip9_status, wait_until\n+from test_framework.util import assert_equal, wait_until, softfork_active\n \n # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n class TestP2PConn(P2PInterface):\n@@ -803,7 +803,7 @@ def run_test(self):\n         # We will need UTXOs to construct transactions in later tests.\n         self.make_utxos()\n \n-        assert_equal(get_bip9_status(self.nodes[0], \"segwit\")[\"status\"], 'active')\n+        assert softfork_active(self.nodes[0], \"segwit\")\n \n         self.log.info(\"Testing SENDCMPCT p2p message... \")\n         self.test_sendcmpct(self.segwit_node, old_node=self.old_node)"
      },
      {
        "sha": "98f6b1d71ddb97cfef473362e9ec37868e15c0eb",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 27,
        "deletions": 55,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -76,7 +76,7 @@\n     assert_equal,\n     connect_nodes,\n     disconnect_nodes,\n-    get_bip9_status,\n+    softfork_active,\n     hex_str_to_bytes,\n     assert_raises_rpc_error,\n )\n@@ -88,6 +88,8 @@\n \n MAX_SIGOP_COST = 80000\n \n+SEGWIT_HEIGHT = 120\n+\n class UTXO():\n     \"\"\"Used to keep track of anyone-can-spend outputs that we can use in the tests.\"\"\"\n     def __init__(self, sha256, n, value):\n@@ -185,9 +187,9 @@ def set_test_params(self):\n         self.num_nodes = 3\n         # This test tests SegWit both pre and post-activation, so use the normal BIP9 activation.\n         self.extra_args = [\n-            [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=1\", \"-vbparams=segwit:0:999999999999\"],\n-            [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-vbparams=segwit:0:999999999999\"],\n-            [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=1\", \"-vbparams=segwit:0:0\"],\n+            [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=1\", \"-segwitheight={}\".format(SEGWIT_HEIGHT)],\n+            [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-segwitheight={}\".format(SEGWIT_HEIGHT)],\n+            [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=1\", \"-segwitheight=-1\"]\n         ]\n \n     def skip_test_if_missing_module(self):\n@@ -231,26 +233,18 @@ def run_test(self):\n         # Keep a place to store utxo's that can be used in later tests\n         self.utxo = []\n \n-        # Segwit status 'defined'\n-        self.segwit_status = 'defined'\n+        self.log.info(\"Starting tests before segwit activation\")\n+        self.segwit_active = False\n \n         self.test_non_witness_transaction()\n-        self.test_unnecessary_witness_before_segwit_activation()\n         self.test_v0_outputs_arent_spendable()\n         self.test_block_relay()\n-        self.advance_to_segwit_started()\n-\n-        # Segwit status 'started'\n-\n         self.test_getblocktemplate_before_lockin()\n-        self.advance_to_segwit_lockin()\n-\n-        # Segwit status 'locked_in'\n-\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_witness_tx_relay_before_segwit_activation()\n-        self.test_block_relay()\n         self.test_standardness_v0()\n+\n+        self.log.info(\"Advancing to segwit activation\")\n         self.advance_to_segwit_active()\n \n         # Segwit status 'active'\n@@ -282,15 +276,15 @@ def run_test(self):\n     def subtest(func):  # noqa: N805\n         \"\"\"Wraps the subtests for logging and state assertions.\"\"\"\n         def func_wrapper(self, *args, **kwargs):\n-            self.log.info(\"Subtest: {} (Segwit status = {})\".format(func.__name__, self.segwit_status))\n+            self.log.info(\"Subtest: {} (Segwit active = {})\".format(func.__name__, self.segwit_active))\n             # Assert segwit status is as expected\n-            assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], self.segwit_status)\n+            assert_equal(softfork_active(self.nodes[0], 'segwit'), self.segwit_active)\n             func(self, *args, **kwargs)\n             # Each subtest should leave some utxos for the next subtest\n             assert self.utxo\n             self.sync_blocks()\n             # Assert segwit status is as expected at end of subtest\n-            assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], self.segwit_status)\n+            assert_equal(softfork_active(self.nodes[0], 'segwit'), self.segwit_active)\n \n         return func_wrapper\n \n@@ -392,7 +386,7 @@ def test_block_relay(self):\n \n         # Check that we can getdata for witness blocks or regular blocks,\n         # and the right thing happens.\n-        if self.segwit_status != 'active':\n+        if not self.segwit_active:\n             # Before activation, we should be able to request old blocks with\n             # or without witness, and they should be the same.\n             chain_height = self.nodes[0].getblockcount()\n@@ -535,33 +529,19 @@ def test_v0_outputs_arent_spendable(self):\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(txid, 2, value))\n \n-    @subtest\n-    def advance_to_segwit_started(self):\n-        \"\"\"Mine enough blocks for segwit's vb state to be 'started'.\"\"\"\n-        height = self.nodes[0].getblockcount()\n-        # Will need to rewrite the tests here if we are past the first period\n-        assert height < VB_PERIOD - 1\n-        # Advance to end of period, status should now be 'started'\n-        self.nodes[0].generate(VB_PERIOD - height - 1)\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n-        self.segwit_status = 'started'\n-\n     @subtest\n     def test_getblocktemplate_before_lockin(self):\n         txid = int(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1), 16)\n \n         for node in [self.nodes[0], self.nodes[2]]:\n             gbt_results = node.getblocktemplate({\"rules\": [\"segwit\"]})\n-            block_version = gbt_results['version']\n             if node == self.nodes[2]:\n                 # If this is a non-segwit node, we should not get a witness\n-                # commitment, nor a version bit signalling segwit.\n-                assert_equal(block_version & (1 << VB_WITNESS_BIT), 0)\n+                # commitment.\n                 assert 'default_witness_commitment' not in gbt_results\n             else:\n-                # For segwit-aware nodes, check the version bit and the witness\n-                # commitment are correct.\n-                assert block_version & (1 << VB_WITNESS_BIT) != 0\n+                # For segwit-aware nodes, check the witness\n+                # commitment is correct.\n                 assert 'default_witness_commitment' in gbt_results\n                 witness_commitment = gbt_results['default_witness_commitment']\n \n@@ -571,18 +551,9 @@ def test_getblocktemplate_before_lockin(self):\n                 script = get_witness_script(witness_root, 0)\n                 assert_equal(witness_commitment, script.hex())\n \n-    @subtest\n-    def advance_to_segwit_lockin(self):\n-        \"\"\"Mine enough blocks to lock in segwit, but don't activate.\"\"\"\n-        height = self.nodes[0].getblockcount()\n-        # Advance to end of period, and verify lock-in happens at the end\n-        self.nodes[0].generate(VB_PERIOD - 1)\n-        height = self.nodes[0].getblockcount()\n-        assert (height % VB_PERIOD) == VB_PERIOD - 2\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n+        # Clear out the mempool\n         self.nodes[0].generate(1)\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n-        self.segwit_status = 'locked_in'\n+        self.sync_blocks()\n \n     @subtest\n     def test_witness_tx_relay_before_segwit_activation(self):\n@@ -686,7 +657,7 @@ def test_standardness_v0(self):\n         tx3.wit.vtxinwit.append(CTxInWitness())\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         tx3.rehash()\n-        if self.segwit_status != 'active':\n+        if not self.segwit_active:\n             # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n             # in blocks and the tx is impossible to mine right now.\n             assert_equal(self.nodes[0].testmempoolaccept([tx3.serialize_with_witness().hex()]), [{'txid': tx3.hash, 'allowed': True}])\n@@ -707,12 +678,13 @@ def test_standardness_v0(self):\n     @subtest\n     def advance_to_segwit_active(self):\n         \"\"\"Mine enough blocks to activate segwit.\"\"\"\n+        assert not softfork_active(self.nodes[0], 'segwit')\n         height = self.nodes[0].getblockcount()\n-        self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n+        self.nodes[0].generate(SEGWIT_HEIGHT - height - 2)\n+        assert not softfork_active(self.nodes[0], 'segwit')\n         self.nodes[0].generate(1)\n-        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n-        self.segwit_status = 'active'\n+        assert softfork_active(self.nodes[0], 'segwit')\n+        self.segwit_active = True\n \n     @subtest\n     def test_p2sh_witness(self):\n@@ -1924,13 +1896,13 @@ def test_upgrade_after_activation(self):\n \n         # Restart with the new binary\n         self.stop_node(2)\n-        self.start_node(2, extra_args=[\"-vbparams=segwit:0:999999999999\"])\n+        self.start_node(2, extra_args=[\"-segwitheight={}\".format(SEGWIT_HEIGHT)])\n         connect_nodes(self.nodes[0], 2)\n \n         self.sync_blocks()\n \n         # Make sure that this peer thinks segwit has activated.\n-        assert get_bip9_status(self.nodes[2], 'segwit')['status'] == \"active\"\n+        assert softfork_active(self.nodes[2], 'segwit')\n \n         # Make sure this peer's blocks match those of node0.\n         height = self.nodes[2].getblockcount()"
      },
      {
        "sha": "6c30e050847e1209668e297c89827fd4e83e432b",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -78,7 +78,6 @@ def _test_getblockchaininfo(self):\n \n         keys = [\n             'bestblockhash',\n-            'bip9_softforks',\n             'blocks',\n             'chain',\n             'chainwork',\n@@ -124,6 +123,31 @@ def _test_getblockchaininfo(self):\n         assert_equal(res['prune_target_size'], 576716800)\n         assert_greater_than(res['size_on_disk'], 0)\n \n+        assert_equal(res['softforks'], {\n+            'bip34': {'type': 'buried', 'active': False, 'height': 500},\n+            'bip66': {'type': 'buried', 'active': False, 'height': 1251},\n+            'bip65': {'type': 'buried', 'active': False, 'height': 1351},\n+            'csv': {'type': 'buried', 'active': False, 'height': 432},\n+            'segwit': {'type': 'buried', 'active': True, 'height': 0},\n+            'testdummy': {\n+                'type': 'bip9',\n+                'bip9': {\n+                    'status': 'started',\n+                    'bit': 28,\n+                    'startTime': 0,\n+                    'timeout': 0x7fffffffffffffff,  # testdummy does not have a timeout so is set to the max int64 value\n+                    'since': 144,\n+                    'statistics': {\n+                        'period': 144,\n+                        'threshold': 108,\n+                        'elapsed': 57,\n+                        'count': 57,\n+                        'possible': True,\n+                    },\n+                },\n+                'active': False}\n+        })\n+\n     def _test_getchaintxstats(self):\n         self.log.info(\"Test getchaintxstats\")\n "
      },
      {
        "sha": "194f2f061baca2172ab3eb6b623f82d80aff1543",
        "filename": "test/functional/test_framework/address.py",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/test_framework/address.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/test_framework/address.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/address.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -4,13 +4,22 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Encode and decode BASE58, P2PKH and P2SH addresses.\"\"\"\n \n+import enum\n+\n from .script import hash256, hash160, sha256, CScript, OP_0\n from .util import hex_str_to_bytes\n \n from . import segwit_addr\n \n ADDRESS_BCRT1_UNSPENDABLE = 'bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj'\n \n+\n+class AddressType(enum.Enum):\n+    bech32 = 'bech32'\n+    p2sh_segwit = 'p2sh-segwit'\n+    legacy = 'legacy'  # P2PKH\n+\n+\n chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n \n "
      },
      {
        "sha": "3d9be0d0a6b8cd3b38f364c4edbe1d443f06891a",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -335,9 +335,9 @@ def delete_cookie_file(datadir, chain):\n         logger.debug(\"Deleting leftover cookie file\")\n         os.remove(os.path.join(datadir, chain, \".cookie\"))\n \n-def get_bip9_status(node, key):\n-    info = node.getblockchaininfo()\n-    return info['bip9_softforks'][key]\n+def softfork_active(node, key):\n+    \"\"\"Return whether a softfork is active.\"\"\"\n+    return node.getblockchaininfo()['softforks'][key]['active']\n \n def set_node_times(nodes, t):\n     for node in nodes:"
      },
      {
        "sha": "ea8dbbaf95406c15a1d2f2e6d191cefe25354a39",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 18,
        "deletions": 5,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -228,6 +228,7 @@ def main():\n                                      epilog='''\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n+    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(), help=\"Use ANSI colors and dots in output (enabled by default when standard output is a TTY)\")\n     parser.add_argument('--combinedlogslen', '-c', type=int, default=0, metavar='n', help='On failure, print a log (of length n lines) to the console, combined from the test framework and all test nodes.')\n     parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n     parser.add_argument('--ci', action='store_true', help='Run checks and code that are usually only enabled in a continuous integration environment')\n@@ -240,7 +241,14 @@ def main():\n     parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n     parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n     parser.add_argument('--filter', help='filter scripts to run by regular expression')\n+\n     args, unknown_args = parser.parse_known_args()\n+    if not args.ansi:\n+        global BOLD, GREEN, RED, GREY\n+        BOLD = (\"\", \"\")\n+        GREEN = (\"\", \"\")\n+        RED = (\"\", \"\")\n+        GREY = (\"\", \"\")\n \n     # args to be passed on always start with two dashes; tests are the remaining unknown args\n     tests = [arg for arg in unknown_args if arg[:2] != \"--\"]\n@@ -342,9 +350,10 @@ def main():\n         combined_logs_len=args.combinedlogslen,\n         failfast=args.failfast,\n         runs_ci=args.ci,\n+        use_term_control=args.ansi,\n     )\n \n-def run_tests(*, test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=False, args=None, combined_logs_len=0, failfast=False, runs_ci):\n+def run_tests(*, test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=False, args=None, combined_logs_len=0, failfast=False, runs_ci, use_term_control):\n     args = args or []\n \n     # Warn if bitcoind is already running (unix only)\n@@ -386,6 +395,7 @@ def run_tests(*, test_list, src_dir, build_dir, tmpdir, jobs=1, enable_coverage=\n         test_list=test_list,\n         flags=flags,\n         timeout_duration=40 * 60 if runs_ci else float('inf'),  # in seconds\n+        use_term_control=use_term_control,\n     )\n     start_time = time.time()\n     test_results = []\n@@ -469,7 +479,7 @@ class TestHandler:\n     Trigger the test scripts passed in via the list.\n     \"\"\"\n \n-    def __init__(self, *, num_tests_parallel, tests_dir, tmpdir, test_list, flags, timeout_duration):\n+    def __init__(self, *, num_tests_parallel, tests_dir, tmpdir, test_list, flags, timeout_duration, use_term_control):\n         assert num_tests_parallel >= 1\n         self.num_jobs = num_tests_parallel\n         self.tests_dir = tests_dir\n@@ -479,6 +489,7 @@ def __init__(self, *, num_tests_parallel, tests_dir, tmpdir, test_list, flags, t\n         self.flags = flags\n         self.num_running = 0\n         self.jobs = []\n+        self.use_term_control = use_term_control\n \n     def get_next(self):\n         while self.num_running < self.num_jobs and self.test_list:\n@@ -530,11 +541,13 @@ def get_next(self):\n                         status = \"Failed\"\n                     self.num_running -= 1\n                     self.jobs.remove(job)\n-                    clearline = '\\r' + (' ' * dot_count) + '\\r'\n-                    print(clearline, end='', flush=True)\n+                    if self.use_term_control:\n+                        clearline = '\\r' + (' ' * dot_count) + '\\r'\n+                        print(clearline, end='', flush=True)\n                     dot_count = 0\n                     return TestResult(name, status, int(time.time() - start_time)), testdir, stdout, stderr\n-            print('.', end='', flush=True)\n+            if self.use_term_control:\n+                print('.', end='', flush=True)\n             dot_count += 1\n \n     def kill_and_join(self):"
      },
      {
        "sha": "4e20892596f221f97326bfa13801b8a00182c29b",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 54,
        "deletions": 23,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -20,28 +20,38 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.address import AddressType\n from test_framework.util import (\n     connect_nodes,\n     assert_equal,\n     set_node_times,\n )\n \n import collections\n+from decimal import Decimal\n import enum\n import itertools\n+import random\n \n Call = enum.Enum(\"Call\", \"single multiaddress multiscript\")\n Data = enum.Enum(\"Data\", \"address pub priv\")\n Rescan = enum.Enum(\"Rescan\", \"no yes late_timestamp\")\n \n \n-class Variant(collections.namedtuple(\"Variant\", \"call data rescan prune\")):\n+class Variant(collections.namedtuple(\"Variant\", \"call data address_type rescan prune\")):\n     \"\"\"Helper for importing one key and verifying scanned transactions.\"\"\"\n \n     def do_import(self, timestamp):\n         \"\"\"Call one key import RPC.\"\"\"\n         rescan = self.rescan == Rescan.yes\n \n+        assert_equal(self.address[\"solvable\"], True)\n+        assert_equal(self.address[\"isscript\"], self.address_type == AddressType.p2sh_segwit)\n+        assert_equal(self.address[\"iswitness\"], self.address_type == AddressType.bech32)\n+        if self.address[\"isscript\"]:\n+            assert_equal(self.address[\"embedded\"][\"isscript\"], False)\n+            assert_equal(self.address[\"embedded\"][\"iswitness\"], True)\n+\n         if self.call == Call.single:\n             if self.data == Data.address:\n                 response = self.node.importaddress(address=self.address[\"address\"], label=self.label, rescan=rescan)\n@@ -52,7 +62,7 @@ def do_import(self, timestamp):\n             assert_equal(response, None)\n \n         elif self.call in (Call.multiaddress, Call.multiscript):\n-            response = self.node.importmulti([{\n+            request = {\n                 \"scriptPubKey\": {\n                     \"address\": self.address[\"address\"]\n                 } if self.call == Call.multiaddress else self.address[\"scriptPubKey\"],\n@@ -61,13 +71,21 @@ def do_import(self, timestamp):\n                 \"keys\": [self.key] if self.data == Data.priv else [],\n                 \"label\": self.label,\n                 \"watchonly\": self.data != Data.priv\n-            }], {\"rescan\": self.rescan in (Rescan.yes, Rescan.late_timestamp)})\n+            }\n+            if self.address_type == AddressType.p2sh_segwit and self.data != Data.address:\n+                # We need solving data when providing a pubkey or privkey as data\n+                request.update({\"redeemscript\": self.address['embedded']['scriptPubKey']})\n+            response = self.node.importmulti(\n+                requests=[request],\n+                options={\"rescan\": self.rescan in (Rescan.yes, Rescan.late_timestamp)},\n+            )\n             assert_equal(response, [{\"success\": True}])\n \n-    def check(self, txid=None, amount=None, confirmations=None):\n+    def check(self, txid=None, amount=None, confirmation_height=None):\n         \"\"\"Verify that listtransactions/listreceivedbyaddress return expected values.\"\"\"\n \n         txs = self.node.listtransactions(label=self.label, count=10000, include_watchonly=True)\n+        current_height = self.node.getblockcount()\n         assert_equal(len(txs), self.expected_txs)\n \n         addresses = self.node.listreceivedbyaddress(minconf=0, include_watchonly=True, address_filter=self.address['address'])\n@@ -82,13 +100,13 @@ def check(self, txid=None, amount=None, confirmations=None):\n             assert_equal(tx[\"category\"], \"receive\")\n             assert_equal(tx[\"label\"], self.label)\n             assert_equal(tx[\"txid\"], txid)\n-            assert_equal(tx[\"confirmations\"], confirmations)\n+            assert_equal(tx[\"confirmations\"], 1 + current_height - confirmation_height)\n             assert_equal(\"trusted\" not in tx, True)\n \n             address, = [ad for ad in addresses if txid in ad[\"txids\"]]\n             assert_equal(address[\"address\"], self.address[\"address\"])\n             assert_equal(address[\"amount\"], self.expected_balance)\n-            assert_equal(address[\"confirmations\"], confirmations)\n+            assert_equal(address[\"confirmations\"], 1 + current_height - confirmation_height)\n             # Verify the transaction is correctly marked watchonly depending on\n             # whether the transaction pays to an imported public key or\n             # imported private key. The test setup ensures that transaction\n@@ -102,7 +120,7 @@ def check(self, txid=None, amount=None, confirmations=None):\n \n \n # List of Variants for each way a key or address could be imported.\n-IMPORT_VARIANTS = [Variant(*variants) for variants in itertools.product(Call, Data, Rescan, (False, True))]\n+IMPORT_VARIANTS = [Variant(*variants) for variants in itertools.product(Call, Data, AddressType, Rescan, (False, True))]\n \n # List of nodes to import keys to. Half the nodes will have pruning disabled,\n # half will have it enabled. Different nodes will be used for imports that are\n@@ -116,6 +134,13 @@ def check(self, txid=None, amount=None, confirmations=None):\n # Rescans start at the earliest block up to 2 hours before the key timestamp.\n TIMESTAMP_WINDOW = 2 * 60 * 60\n \n+AMOUNT_DUST = 0.00000546\n+\n+\n+def get_rand_amount():\n+    r = random.uniform(AMOUNT_DUST, 1)\n+    return Decimal(str(round(r, 8)))\n+\n \n class ImportRescanTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -125,12 +150,12 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def setup_network(self):\n-        extra_args = [[\"-addresstype=legacy\"] for _ in range(self.num_nodes)]\n+        self.extra_args = [[]] * self.num_nodes\n         for i, import_node in enumerate(IMPORT_NODES, 2):\n             if import_node.prune:\n-                extra_args[i] += [\"-prune=1\"]\n+                self.extra_args[i] += [\"-prune=1\"]\n \n-        self.add_nodes(self.num_nodes, extra_args=extra_args)\n+        self.add_nodes(self.num_nodes, extra_args=self.extra_args)\n \n         # Import keys with pruning disabled\n         self.start_nodes(extra_args=[[]] * self.num_nodes)\n@@ -147,17 +172,23 @@ def run_test(self):\n         # each possible type of wallet import RPC.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n             variant.label = \"label {} {}\".format(i, variant)\n-            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress(variant.label))\n+            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress(\n+                label=variant.label,\n+                address_type=variant.address_type.value,\n+            ))\n             variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n-            variant.initial_amount = 1 - (i + 1) / 64\n+            variant.initial_amount = get_rand_amount()\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n+            self.nodes[0].generate(1)  # Generate one block for each send\n+            variant.confirmation_height = self.nodes[0].getblockcount()\n+            variant.timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n \n-        # Generate a block containing the initial transactions, then another\n-        # block further in the future (past the rescan window).\n-        self.nodes[0].generate(1)\n+        # Generate a block further in the future (past the rescan window).\n         assert_equal(self.nodes[0].getrawmempool(), [])\n-        timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n-        set_node_times(self.nodes, timestamp + TIMESTAMP_WINDOW + 1)\n+        set_node_times(\n+            self.nodes,\n+            self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"] + TIMESTAMP_WINDOW + 1,\n+        )\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n@@ -167,23 +198,23 @@ def run_test(self):\n             self.log.info('Run import for variant {}'.format(variant))\n             expect_rescan = variant.rescan == Rescan.yes\n             variant.node = self.nodes[2 + IMPORT_NODES.index(ImportNode(variant.prune, expect_rescan))]\n-            variant.do_import(timestamp)\n+            variant.do_import(variant.timestamp)\n             if expect_rescan:\n                 variant.expected_balance = variant.initial_amount\n                 variant.expected_txs = 1\n-                variant.check(variant.initial_txid, variant.initial_amount, 2)\n+                variant.check(variant.initial_txid, variant.initial_amount, variant.confirmation_height)\n             else:\n                 variant.expected_balance = 0\n                 variant.expected_txs = 0\n                 variant.check()\n \n         # Create new transactions sending to each address.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n-            variant.sent_amount = 1 - (2 * i + 1) / 128\n+            variant.sent_amount = get_rand_amount()\n             variant.sent_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.sent_amount)\n+            self.nodes[0].generate(1)  # Generate one block for each send\n+            variant.confirmation_height = self.nodes[0].getblockcount()\n \n-        # Generate a block containing the new transactions.\n-        self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n         self.sync_all()\n \n@@ -192,7 +223,7 @@ def run_test(self):\n             self.log.info('Run check for variant {}'.format(variant))\n             variant.expected_balance += variant.sent_amount\n             variant.expected_txs += 1\n-            variant.check(variant.sent_txid, variant.sent_amount, 1)\n+            variant.check(variant.sent_txid, variant.sent_amount, variant.confirmation_height)\n \n if __name__ == \"__main__\":\n     ImportRescanTest().main()"
      },
      {
        "sha": "2522c8fa1cee150111b4b68a874998a273b637dd",
        "filename": "test/lint/lint-python-dead-code-whitelist",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/lint/lint-python-dead-code-whitelist",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/lint/lint-python-dead-code-whitelist",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python-dead-code-whitelist?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -0,0 +1,45 @@\n+BadInputOutpointIndex  # unused class (test/functional/data/invalid_txs.py)\n+_.carbon_path  # unused attribute (contrib/macdeploy/custom_dsstore.py)\n+connection_lost  # unused function (test/functional/test_framework/mininode.py)\n+connection_made  # unused function (test/functional/test_framework/mininode.py)\n+_.converter  # unused attribute (test/functional/test_framework/test_framework.py)\n+_.daemon  # unused attribute (test/functional/test_framework/socks5.py)\n+data_received  # unused function (test/functional/test_framework/mininode.py)\n+DuplicateInput  # unused class (test/functional/data/invalid_txs.py)\n+_.filename  # unused attribute (contrib/macdeploy/custom_dsstore.py)\n+InvalidOPIFConstruction  # unused class (test/functional/data/invalid_txs.py)\n+_.is_compressed  # unused property (test/functional/test_framework/key.py)\n+legacy  # unused variable (test/functional/test_framework/address.py)\n+msg_generic  # unused class (test/functional/test_framework/messages.py)\n+NonexistentInput  # unused class (test/functional/data/invalid_txs.py)\n+on_addr  # unused function (test/functional/test_framework/mininode.py)\n+on_blocktxn  # unused function (test/functional/test_framework/mininode.py)\n+on_block  # unused function (test/functional/test_framework/mininode.py)\n+on_cmpctblock  # unused function (test/functional/test_framework/mininode.py)\n+on_feefilter  # unused function (test/functional/test_framework/mininode.py)\n+on_getaddr  # unused function (test/functional/test_framework/mininode.py)\n+on_getblocks  # unused function (test/functional/test_framework/mininode.py)\n+on_getblocktxn  # unused function (test/functional/test_framework/mininode.py)\n+on_getdata  # unused function (test/functional/test_framework/mininode.py)\n+on_getheaders  # unused function (test/functional/test_framework/mininode.py)\n+on_headers  # unused function (test/functional/test_framework/mininode.py)\n+on_inv  # unused function (test/functional/test_framework/mininode.py)\n+on_mempool  # unused function (test/functional/test_framework/mininode.py)\n+on_notfound  # unused function (test/functional/test_framework/mininode.py)\n+on_ping  # unused function (test/functional/test_framework/mininode.py)\n+on_pong  # unused function (test/functional/test_framework/mininode.py)\n+on_reject  # unused function (test/functional/test_framework/mininode.py)\n+on_sendcmpct  # unused function (test/functional/test_framework/mininode.py)\n+on_sendheaders  # unused function (test/functional/test_framework/mininode.py)\n+on_tx  # unused function (test/functional/test_framework/mininode.py)\n+on_verack  # unused function (test/functional/test_framework/mininode.py)\n+on_version  # unused function (test/functional/test_framework/mininode.py)\n+_.optionxform  # unused attribute (test/util/bitcoin-util-test.py)\n+OutputMissing  # unused class (test/functional/data/invalid_txs.py)\n+_.posix_path  # unused attribute (contrib/macdeploy/custom_dsstore.py)\n+profile_with_perf  # unused function (test/functional/test_framework/test_node.py)\n+SizeTooSmall  # unused class (test/functional/data/invalid_txs.py)\n+SpendNegative  # unused class (test/functional/data/invalid_txs.py)\n+SpendTooMuch  # unused class (test/functional/data/invalid_txs.py)\n+TooManySigops  # unused class (test/functional/data/invalid_txs.py)\n+verify_ecdsa  # unused function (test/functional/test_framework/key.py)"
      },
      {
        "sha": "77bf5990a73e0606962140804dbce08c97106b33",
        "filename": "test/lint/lint-python-dead-code.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/lint/lint-python-dead-code.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1aa16b0ad00970feb14a23f7accc0e7fe54771d/test/lint/lint-python-dead-code.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python-dead-code.sh?ref=b1aa16b0ad00970feb14a23f7accc0e7fe54771d",
        "patch": "@@ -15,5 +15,5 @@ fi\n \n vulture \\\n     --min-confidence 60 \\\n-    --ignore-names \"argtypes,connection_lost,connection_made,converter,data_received,daemon,errcheck,is_compressed,is_valid,verify_ecdsa,msg_generic,on_*,optionxform,restype,profile_with_perf\" \\\n-    $(git ls-files -- \"*.py\" \":(exclude)contrib/\" \":(exclude)test/functional/data/invalid_txs.py\")\n+    $(git rev-parse --show-toplevel) \\\n+    $(dirname \"${BASH_SOURCE[0]}\")/lint-python-dead-code-whitelist"
      }
    ]
  }
]