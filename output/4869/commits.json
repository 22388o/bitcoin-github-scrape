[
  {
    "sha": "6050ab685553c7312ef105d2c4a5230c3fcf4002",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MDUwYWI2ODU1NTNjNzMxMmVmMTA1ZDJjNGE1MjMwYzNmY2Y0MDAy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-08T11:49:56Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-09-10T09:33:13Z"
      },
      "message": "netbase: Make SOCKS5 negotiation interruptible\n\nAvoids that SOCKS5 negotiation will hold up the shutdown process.\n\n- Sockets can stay in non-blocking mode, no need to switch it on/off\n  anymore\n- Adds a timeout (20 seconds) on SOCK5 negotiation. This should be\n  enough for even Tor to get a connection to a hidden service, and\n  avoids blocking the opencon thread indefinitely on a hanging proxy.\n\nFixes #2954.",
      "tree": {
        "sha": "ff96280109f4200733a4bbfc81278cad4ff5367f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff96280109f4200733a4bbfc81278cad4ff5367f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6050ab685553c7312ef105d2c4a5230c3fcf4002",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6050ab685553c7312ef105d2c4a5230c3fcf4002",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6050ab685553c7312ef105d2c4a5230c3fcf4002",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6050ab685553c7312ef105d2c4a5230c3fcf4002/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a8d15cc16875a2dce3d944b46eb21b3f72bb33b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a8d15cc16875a2dce3d944b46eb21b3f72bb33b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a8d15cc16875a2dce3d944b46eb21b3f72bb33b"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 70,
      "deletions": 22
    },
    "files": [
      {
        "sha": "4c9ff4ebed73cc0bac6de6c341c1c83d27680202",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6050ab685553c7312ef105d2c4a5230c3fcf4002/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6050ab685553c7312ef105d2c4a5230c3fcf4002/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6050ab685553c7312ef105d2c4a5230c3fcf4002",
        "patch": "@@ -488,10 +488,6 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n     {\n         addrman.Attempt(addrConnect);\n \n-        // Set to non-blocking\n-        if (!SetSocketNonBlocking(hSocket, true))\n-            LogPrintf(\"ConnectNode: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n-\n         // Add node\n         CNode* pnode = new CNode(hSocket, addrConnect, pszDest ? pszDest : \"\", false);\n         pnode->AddRef();"
      },
      {
        "sha": "5819c152a361b4754338042ad5c258da2b897c48",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 18,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6050ab685553c7312ef105d2c4a5230c3fcf4002/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6050ab685553c7312ef105d2c4a5230c3fcf4002/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=6050ab685553c7312ef105d2c4a5230c3fcf4002",
        "patch": "@@ -45,6 +45,9 @@ bool fNameLookup = false;\n \n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n \n+// Need ample time for negotiation for very slow proxies such as Tor (milliseconds)\n+static const int SOCKS5_RECV_TIMEOUT = 20 * 1000;\n+\n enum Network ParseNetwork(std::string net) {\n     boost::to_lower(net);\n     if (net == \"ipv4\") return NET_IPV4;\n@@ -225,6 +228,63 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n     return Lookup(pszName, addr, portDefault, false);\n }\n \n+/**\n+ * Convert milliseconds to a struct timeval for select.\n+ */\n+struct timeval static MillisToTimeval(int64_t nTimeout)\n+{\n+    struct timeval timeout;\n+    timeout.tv_sec  = nTimeout / 1000;\n+    timeout.tv_usec = (nTimeout % 1000) * 1000;\n+    return timeout;\n+}\n+\n+/**\n+ * Read bytes from socket. This will either read the full number of bytes requested\n+ * or return False on error or timeout.\n+ * This function can be interrupted by boost thread interrupt.\n+ *\n+ * @param data Buffer to receive into\n+ * @param len  Length of data to receive\n+ * @param timeout  Timeout in milliseconds for receive operation\n+ *\n+ * @note This function requires that hSocket is in non-blocking mode.\n+ */\n+bool static InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSocket)\n+{\n+    int64_t curTime = GetTimeMillis();\n+    int64_t endTime = curTime + timeout;\n+    // Maximum time to wait in one select call. It will take up until this time (in millis)\n+    // to break off in case of an interruption.\n+    const int64_t maxWait = 1000;\n+    while (len > 0 && curTime < endTime) {\n+        ssize_t ret = recv(hSocket, data, len, 0); // Optimistically try the recv first\n+        if (ret > 0) {\n+            len -= ret;\n+            data += ret;\n+        } else if (ret == 0) { // Unexpected disconnection\n+            return false;\n+        } else { // Other error or blocking\n+            int nErr = WSAGetLastError();\n+            if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL) {\n+                struct timeval tval = MillisToTimeval(std::min(endTime - curTime, maxWait));\n+                fd_set fdset;\n+                FD_ZERO(&fdset);\n+                FD_SET(hSocket, &fdset);\n+                int nRet = select(hSocket + 1, &fdset, NULL, NULL, &tval);\n+                if (nRet == SOCKET_ERROR) {\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        }\n+        boost::this_thread::interruption_point();\n+        curTime = GetTimeMillis();\n+    }\n+    return len == 0;\n+}\n+\n bool static Socks5(string strDest, int port, SOCKET& hSocket)\n {\n     LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n@@ -243,7 +303,7 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet1[2];\n-    if (recv(hSocket, pchRet1, 2, 0) != 2)\n+    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n@@ -266,7 +326,7 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet2[4];\n-    if (recv(hSocket, pchRet2, 4, 0) != 4)\n+    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket))\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n@@ -300,27 +360,27 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n     char pchRet3[256];\n     switch (pchRet2[3])\n     {\n-        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n-        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n+        case 0x01: ret = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket); break;\n+        case 0x04: ret = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket); break;\n         case 0x03:\n         {\n-            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n-            if (ret) {\n+            ret = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n+            if (!ret) {\n                 CloseSocket(hSocket);\n                 return error(\"Error reading from proxy\");\n             }\n             int nRecv = pchRet3[0];\n-            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n+            ret = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n             break;\n         }\n         default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n     }\n-    if (ret)\n+    if (!ret)\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    if (recv(hSocket, pchRet3, 2, 0) != 2)\n+    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n     {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n@@ -360,10 +420,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n         // WSAEINVAL is here because some legacy version of winsock uses it\n         if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL)\n         {\n-            struct timeval timeout;\n-            timeout.tv_sec  = nTimeout / 1000;\n-            timeout.tv_usec = (nTimeout % 1000) * 1000;\n-\n+            struct timeval timeout = MillisToTimeval(nTimeout);\n             fd_set fdset;\n             FD_ZERO(&fdset);\n             FD_SET(hSocket, &fdset);\n@@ -410,11 +467,6 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n         }\n     }\n \n-    // This is required when using SOCKS5 proxy!\n-    // CNode::ConnectNode turns the socket back to non-blocking.\n-    if (!SetSocketNonBlocking(hSocket, false))\n-        return error(\"ConnectSocketDirectly: Setting socket to blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n-\n     hSocketRet = hSocket;\n     return true;\n }"
      }
    ]
  }
]