[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411919967",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-411919967",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 411919967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTkxOTk2Nw==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-09T22:37:01Z",
    "updated_at": "2019-02-14T20:04:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#15404](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15404.html) ([test] Remove -txindex to start nodes by amitiuttarwar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411919967/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411982919",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-411982919",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 411982919,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTk4MjkxOQ==",
    "user": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?u=63e5c438c242094837a9deeda775d77988b508bf&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T05:53:56Z",
    "updated_at": "2018-08-10T05:53:56Z",
    "author_association": "CONTRIBUTOR",
    "body": ">  It only works with witness UTXOs because full transactions (as would be needed for non-witness UTXOs) are not available unless txindex is enabled.\r\n\r\nIt doesn't look in the wallet?",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411982919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411984826",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-411984826",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 411984826,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTk4NDgyNg==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T06:07:08Z",
    "updated_at": "2018-08-10T06:07:08Z",
    "author_association": "MEMBER",
    "body": "@gmaxwell `walletprocesspsbt` already exists for that. This is a node RPC that works without a wallet.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411984826/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/413010930",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-413010930",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 413010930,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzAxMDkzMA==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-14T20:48:49Z",
    "updated_at": "2018-08-14T20:48:49Z",
    "author_association": "MEMBER",
    "body": "Rebased",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/413010930/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416753468",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-416753468",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 416753468,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjc1MzQ2OA==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-28T21:53:42Z",
    "updated_at": "2018-08-28T21:53:42Z",
    "author_association": "MEMBER",
    "body": "Rebased",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416753468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/421187586",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-421187586",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 421187586,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTE4NzU4Ng==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-13T23:51:54Z",
    "updated_at": "2018-09-13T23:51:54Z",
    "author_association": "MEMBER",
    "body": "Rebased",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/421187586/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/439576833",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-439576833",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 439576833,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTU3NjgzMw==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-17T01:38:43Z",
    "updated_at": "2018-11-17T01:38:43Z",
    "author_association": "MEMBER",
    "body": "Rebased",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/439576833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/454619751",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-454619751",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 454619751,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NDYxOTc1MQ==",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-16T01:46:04Z",
    "updated_at": "2019-01-16T01:49:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "It looks like I'm going to depend on this for my offline-signing GUI work, so we can display nice messages in the GUI about the status of PSBTs that users hand us. Can I therefore encourage its revival? :-) @achow101 \r\n\r\nNote that, assuming #14978 goes in relatively soon, a little refactoring will be needed -- mostly just changing #includes I expect. The other PSBT RPCs have had their guts moved to another file, but I'm happy to do that for these RPCs as a followup PR to this one, if you like, so you don't have to modify this one too much. ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/454619751/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457441565",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-457441565",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 457441565,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzQ0MTU2NQ==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-25T03:18:50Z",
    "updated_at": "2019-01-25T03:18:50Z",
    "author_association": "MEMBER",
    "body": "Rebased and addressed comments.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457441565/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/458374378",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-458374378",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 458374378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1ODM3NDM3OA==",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-29T01:45:43Z",
    "updated_at": "2019-01-29T01:45:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "utACK modulo comments above. I have a general sense that analyzepsbt is a little hard to follow the logic of, but I don't immediately have suggestions for improving that.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/458374378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464109008",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-464109008",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 464109008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDEwOTAwOA==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-15T16:20:03Z",
    "updated_at": "2019-02-15T16:20:03Z",
    "author_association": "MEMBER",
    "body": "very strange!-one of the travis runs seems to be failing with\r\n```\r\n/bin/bash: test/test_bitcoin: No such file or directory\r\nMakefile:12966: recipe for target 'test/addrman_tests.cpp.test' failed\r\nmake[3]: *** [test/addrman_tests.cpp.test] Error 1\r\nmake[3]: *** Waiting for unfinished jobs....\r\n/bin/bash: test/test_bitcoin: No such file or directory\r\nMakefile:12966: recipe for target 'test/arith_uint256_tests.cpp.test' failed\r\nmake[3]: *** [test/arith_uint256_tests.cpp.test] Error 1\r\nPASS: qt/test/test_bitcoin-qt\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464109008/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464189036",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-464189036",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 464189036,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDE4OTAzNg==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-15T20:31:13Z",
    "updated_at": "2019-02-15T20:31:13Z",
    "author_association": "MEMBER",
    "body": "utACK 0c35f0e802274c27736b16a4542ad44bc3c7f794",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464189036/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464377172",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#issuecomment-464377172",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13932",
    "id": 464377172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDM3NzE3Mg==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-16T19:44:26Z",
    "updated_at": "2019-02-16T19:44:40Z",
    "author_association": "MEMBER",
    "body": "re-utACK 540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464377172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213502647",
    "pull_request_review_id": 150353114,
    "id": 213502647,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzUwMjY0Nw==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 16,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could reduce indentation?",
    "created_at": "2018-08-28T23:19:40Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213502647",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213502647"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213502647"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213502647/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1799,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213504242",
    "pull_request_review_id": 150353114,
    "id": 213504242,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzUwNDI0Mg==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 118,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could be more informative?",
    "created_at": "2018-08-28T23:29:53Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213504242",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213504242"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213504242"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213504242/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1888,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213504324",
    "pull_request_review_id": 150353114,
    "id": 213504324,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzUwNDMyNA==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 122,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should allow duplicate outputs? Or should sum values into one output?",
    "created_at": "2018-08-28T23:30:27Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213504324",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213504324"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213504324"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213504324/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1892,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213505237",
    "pull_request_review_id": 150353114,
    "id": 213505237,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzUwNTIzNw==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 111,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "So this is necessary because the first is a copy and the remaining psbt inputs are cleared because of `AddInput`. Maybe remove this \"optimization\" and merge all psbts to an empty psbt?",
    "created_at": "2018-08-28T23:36:08Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213505237",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213505237"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213505237"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213505237/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1881,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213507178",
    "pull_request_review_id": 150353114,
    "id": 213507178,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzUwNzE3OA==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 118,
    "original_position": 98,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should force `txs.size() > 1`?",
    "created_at": "2018-08-28T23:48:17Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213507178",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213507178"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r213507178"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213507178/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1794,
    "original_line": 1794,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215157287",
    "pull_request_review_id": 152360007,
    "id": 215157287,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTE1NzI4Nw==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"analyzepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                            \"        ]\\n\"\n+                            \"        \\\"signatures\\\" : [          (array)\\n\"\n+                            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                            \"        ]\\n\"\n+                            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                            \"        \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                            \"      }\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...\\n\"\n+                            \"  ]\\n\"\n+                            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            std::vector<CKeyID> missing_pubkeys;\n+            std::vector<CKeyID> missing_sigs;\n+            uint160 missing_redeem_script;\n+            uint256 missing_witness_script;\n+            SignatureData sigdata;\n+            bool complete = SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, i, 1, &missing_pubkeys, &missing_sigs, &missing_redeem_script, &missing_witness_script);\n+\n+            // Things are missing\n+            if (!complete) {\n+                if (!missing_pubkeys.empty()) {\n+                    // Missing pubkeys\n+                    UniValue missing_pubkeys_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_pubkeys) {\n+                        missing_pubkeys_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"pubkeys\", missing_pubkeys_univ);\n+                }\n+                if (!missing_redeem_script.IsNull()) {\n+                    // Missing redeemScript\n+                    missing.pushKV(\"redeemscript\", HexStr(missing_redeem_script));\n+                }\n+                if (!missing_witness_script.IsNull()) {\n+                    // Missing witnessScript\n+                    missing.pushKV(\"witnessscript\", HexStr(missing_witness_script));\n+                }\n+                if (!missing_sigs.empty()) {\n+                    // Missing sigs\n+                    UniValue missing_sigs_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_sigs) {\n+                        missing_sigs_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"signatures\", missing_sigs_univ);\n+                }\n+                input_univ.pushKV(\"missing\", missing);\n+\n+                // If we are only missing signatures and nothing else, then next is signer\n+                if (missing_pubkeys.empty() && missing_redeem_script.IsNull() && missing_witness_script.IsNull() && !missing_sigs.empty()) {\n+                    only_missing_sigs = true;\n+                    input_univ.pushKV(\"next\", \"signer\");\n+                } else {\n+                    input_univ.pushKV(\"next\", \"updater\");\n+                }\n+            } else {\n+                only_missing_final = true;\n+                input_univ.pushKV(\"next\", \"finalizer\");\n+            }\n+        } else {\n+            input_univ.pushKV(\"is_final\", true);\n+        }\n+        inputs_result.push_back(input_univ);\n+    }\n+    result.pushKV(\"inputs\", inputs_result);\n+\n+    if (all_final) {\n+        result.pushKV(\"next\", \"extractor\");\n+    }\n+    if (calc_fee) {\n+        // Get the output amount\n+        CAmount out_amt = 0;\n+        for (const CTxOut& out : psbtx.tx->vout) {\n+            out_amt += out.nValue;\n+        }\n+\n+        // Get the fee\n+        CAmount fee = in_amt - out_amt;\n+\n+        // Estimate the size\n+        size_t size;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 276,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The scope of `size` could be reduced?",
    "created_at": "2018-09-05T07:11:16Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r215157287",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215157287"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r215157287"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215157287/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2059,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217562904",
    "pull_request_review_id": 155307683,
    "id": 217562904,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzU2MjkwNA==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 118,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "What else could be said?",
    "created_at": "2018-09-13T23:21:44Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217562904",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217562904"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217562904"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217562904/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1888,
    "side": "RIGHT",
    "in_reply_to_id": 213504242
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217563202",
    "pull_request_review_id": 155307998,
    "id": 217563202,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzU2MzIwMg==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 122,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Duplicate outputs should be allowed. The idea is that there are two distinct transactions with separate inputs and outputs. They are just being combined into one transaction. Thus you can have duplicate outputs as outputs are still unique. However the inputs must be enforced to be unique.",
    "created_at": "2018-09-13T23:23:15Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217563202",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217563202"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217563202"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217563202/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1892,
    "side": "RIGHT",
    "in_reply_to_id": 213504324
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217563440",
    "pull_request_review_id": 155308261,
    "id": 217563440,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzU2MzQ0MA==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 111,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I don't see how that is better.",
    "created_at": "2018-09-13T23:24:42Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217563440",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217563440"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217563440"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217563440/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1881,
    "side": "RIGHT",
    "in_reply_to_id": 213505237
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567515",
    "pull_request_review_id": 155312917,
    "id": 217567515,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzU2NzUxNQ==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 16,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-09-13T23:51:39Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217567515",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567515"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217567515"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567515/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1799,
    "side": "RIGHT",
    "in_reply_to_id": 213502647
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567536",
    "pull_request_review_id": 155312935,
    "id": 217567536,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzU2NzUzNg==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 118,
    "original_position": 98,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-09-13T23:51:46Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217567536",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567536"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217567536"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567536/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1794,
    "original_line": 1794,
    "side": "RIGHT",
    "in_reply_to_id": 213507178
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567543",
    "pull_request_review_id": 155312949,
    "id": 217567543,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzU2NzU0Mw==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"analyzepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                            \"        ]\\n\"\n+                            \"        \\\"signatures\\\" : [          (array)\\n\"\n+                            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                            \"        ]\\n\"\n+                            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                            \"        \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                            \"      }\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...\\n\"\n+                            \"  ]\\n\"\n+                            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            std::vector<CKeyID> missing_pubkeys;\n+            std::vector<CKeyID> missing_sigs;\n+            uint160 missing_redeem_script;\n+            uint256 missing_witness_script;\n+            SignatureData sigdata;\n+            bool complete = SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, i, 1, &missing_pubkeys, &missing_sigs, &missing_redeem_script, &missing_witness_script);\n+\n+            // Things are missing\n+            if (!complete) {\n+                if (!missing_pubkeys.empty()) {\n+                    // Missing pubkeys\n+                    UniValue missing_pubkeys_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_pubkeys) {\n+                        missing_pubkeys_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"pubkeys\", missing_pubkeys_univ);\n+                }\n+                if (!missing_redeem_script.IsNull()) {\n+                    // Missing redeemScript\n+                    missing.pushKV(\"redeemscript\", HexStr(missing_redeem_script));\n+                }\n+                if (!missing_witness_script.IsNull()) {\n+                    // Missing witnessScript\n+                    missing.pushKV(\"witnessscript\", HexStr(missing_witness_script));\n+                }\n+                if (!missing_sigs.empty()) {\n+                    // Missing sigs\n+                    UniValue missing_sigs_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_sigs) {\n+                        missing_sigs_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"signatures\", missing_sigs_univ);\n+                }\n+                input_univ.pushKV(\"missing\", missing);\n+\n+                // If we are only missing signatures and nothing else, then next is signer\n+                if (missing_pubkeys.empty() && missing_redeem_script.IsNull() && missing_witness_script.IsNull() && !missing_sigs.empty()) {\n+                    only_missing_sigs = true;\n+                    input_univ.pushKV(\"next\", \"signer\");\n+                } else {\n+                    input_univ.pushKV(\"next\", \"updater\");\n+                }\n+            } else {\n+                only_missing_final = true;\n+                input_univ.pushKV(\"next\", \"finalizer\");\n+            }\n+        } else {\n+            input_univ.pushKV(\"is_final\", true);\n+        }\n+        inputs_result.push_back(input_univ);\n+    }\n+    result.pushKV(\"inputs\", inputs_result);\n+\n+    if (all_final) {\n+        result.pushKV(\"next\", \"extractor\");\n+    }\n+    if (calc_fee) {\n+        // Get the output amount\n+        CAmount out_amt = 0;\n+        for (const CTxOut& out : psbtx.tx->vout) {\n+            out_amt += out.nValue;\n+        }\n+\n+        // Get the fee\n+        CAmount fee = in_amt - out_amt;\n+\n+        // Estimate the size\n+        size_t size;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 276,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-09-13T23:51:50Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217567543",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567543"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r217567543"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217567543/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2059,
    "side": "RIGHT",
    "in_reply_to_id": 215157287
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221827004",
    "pull_request_review_id": 160568659,
    "id": 221827004,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTgyNzAwNA==",
    "diff_hunk": "@@ -7,6 +7,7 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, find_output\n+from decimal import Decimal",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 4,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "9004ce4969eb2e9ca255a5508fd0dcab180b0d31",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: Sort imports :-)",
    "created_at": "2018-10-02T05:14:10Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r221827004",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221827004"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r221827004"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221827004/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 10,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230893599",
    "pull_request_review_id": 171736107,
    "id": 230893599,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MzU5OQ==",
    "diff_hunk": "@@ -1693,6 +1694,324 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"analyzepsbt \\\"psbt\\\"\\n\"\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"        \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            std::vector<CKeyID> missing_pubkeys;\n+            std::vector<CKeyID> missing_sigs;\n+            uint160 missing_redeem_script;\n+            uint256 missing_witness_script;\n+            SignatureData sigdata;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 218,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "ba5f9058f6c874cd1a76b5fa468b2e9c58e4604a",
    "user": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Unused?",
    "created_at": "2018-11-05T20:06:27Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r230893599",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230893599"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r230893599"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230893599/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1983,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230893649",
    "pull_request_review_id": 171736165,
    "id": 230893649,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MzY0OQ==",
    "diff_hunk": "@@ -1693,6 +1694,324 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"analyzepsbt \\\"psbt\\\"\\n\"\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"        \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            std::vector<CKeyID> missing_pubkeys;\n+            std::vector<CKeyID> missing_sigs;\n+            uint160 missing_redeem_script;\n+            uint256 missing_witness_script;\n+            SignatureData sigdata;\n+            bool complete = SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, i, 1, &missing_pubkeys, &missing_sigs, &missing_redeem_script, &missing_witness_script);\n+\n+            // Things are missing\n+            if (!complete) {\n+                if (!missing_pubkeys.empty()) {\n+                    // Missing pubkeys\n+                    UniValue missing_pubkeys_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_pubkeys) {\n+                        missing_pubkeys_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"pubkeys\", missing_pubkeys_univ);\n+                }\n+                if (!missing_redeem_script.IsNull()) {\n+                    // Missing redeemScript\n+                    missing.pushKV(\"redeemscript\", HexStr(missing_redeem_script));\n+                }\n+                if (!missing_witness_script.IsNull()) {\n+                    // Missing witnessScript\n+                    missing.pushKV(\"witnessscript\", HexStr(missing_witness_script));\n+                }\n+                if (!missing_sigs.empty()) {\n+                    // Missing sigs\n+                    UniValue missing_sigs_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_sigs) {\n+                        missing_sigs_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"signatures\", missing_sigs_univ);\n+                }\n+                input_univ.pushKV(\"missing\", missing);\n+\n+                // If we are only missing signatures and nothing else, then next is signer\n+                if (missing_pubkeys.empty() && missing_redeem_script.IsNull() && missing_witness_script.IsNull() && !missing_sigs.empty()) {\n+                    only_missing_sigs = true;\n+                    input_univ.pushKV(\"next\", \"signer\");\n+                } else {\n+                    input_univ.pushKV(\"next\", \"updater\");\n+                }\n+            } else {\n+                only_missing_final = true;\n+                input_univ.pushKV(\"next\", \"finalizer\");\n+            }\n+        } else {\n+            input_univ.pushKV(\"is_final\", true);\n+        }\n+        inputs_result.push_back(input_univ);\n+    }\n+    result.pushKV(\"inputs\", inputs_result);\n+\n+    if (all_final) {\n+        result.pushKV(\"next\", \"extractor\");\n+    }\n+    if (calc_fee) {\n+        // Get the output amount\n+        CAmount out_amt = 0;\n+        for (const CTxOut& out : psbtx.tx->vout) {\n+            out_amt += out.nValue;\n+        }\n+\n+        // Get the fee\n+        CAmount fee = in_amt - out_amt;\n+\n+        // Estimate the size\n+        CMutableTransaction mtx(*psbtx.tx);\n+        CCoinsView view_dummy;\n+        CCoinsViewCache view(&view_dummy);\n+        bool success = true;\n+\n+        for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+            PSBTInput& input = psbtx.inputs[i];\n+            SignatureData sigdata;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 288,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "ba5f9058f6c874cd1a76b5fa468b2e9c58e4604a",
    "user": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Unused?",
    "created_at": "2018-11-05T20:06:36Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r230893649",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230893649"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r230893649"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230893649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2053,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232348313",
    "pull_request_review_id": 173533990,
    "id": 232348313,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjM0ODMxMw==",
    "diff_hunk": "@@ -1693,6 +1694,324 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"analyzepsbt \\\"psbt\\\"\\n\"\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"        \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            std::vector<CKeyID> missing_pubkeys;\n+            std::vector<CKeyID> missing_sigs;\n+            uint160 missing_redeem_script;\n+            uint256 missing_witness_script;\n+            SignatureData sigdata;\n+            bool complete = SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, i, 1, &missing_pubkeys, &missing_sigs, &missing_redeem_script, &missing_witness_script);\n+\n+            // Things are missing\n+            if (!complete) {\n+                if (!missing_pubkeys.empty()) {\n+                    // Missing pubkeys\n+                    UniValue missing_pubkeys_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_pubkeys) {\n+                        missing_pubkeys_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"pubkeys\", missing_pubkeys_univ);\n+                }\n+                if (!missing_redeem_script.IsNull()) {\n+                    // Missing redeemScript\n+                    missing.pushKV(\"redeemscript\", HexStr(missing_redeem_script));\n+                }\n+                if (!missing_witness_script.IsNull()) {\n+                    // Missing witnessScript\n+                    missing.pushKV(\"witnessscript\", HexStr(missing_witness_script));\n+                }\n+                if (!missing_sigs.empty()) {\n+                    // Missing sigs\n+                    UniValue missing_sigs_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : missing_sigs) {\n+                        missing_sigs_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"signatures\", missing_sigs_univ);\n+                }\n+                input_univ.pushKV(\"missing\", missing);\n+\n+                // If we are only missing signatures and nothing else, then next is signer\n+                if (missing_pubkeys.empty() && missing_redeem_script.IsNull() && missing_witness_script.IsNull() && !missing_sigs.empty()) {\n+                    only_missing_sigs = true;\n+                    input_univ.pushKV(\"next\", \"signer\");\n+                } else {\n+                    input_univ.pushKV(\"next\", \"updater\");\n+                }\n+            } else {\n+                only_missing_final = true;\n+                input_univ.pushKV(\"next\", \"finalizer\");\n+            }\n+        } else {\n+            input_univ.pushKV(\"is_final\", true);\n+        }\n+        inputs_result.push_back(input_univ);\n+    }\n+    result.pushKV(\"inputs\", inputs_result);\n+\n+    if (all_final) {\n+        result.pushKV(\"next\", \"extractor\");\n+    }\n+    if (calc_fee) {\n+        // Get the output amount\n+        CAmount out_amt = 0;\n+        for (const CTxOut& out : psbtx.tx->vout) {\n+            out_amt += out.nValue;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 274,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "ba5f9058f6c874cd1a76b5fa468b2e9c58e4604a",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: Looks like a case for `std::accumulate` perhaps? :-)",
    "created_at": "2018-11-09T18:27:27Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r232348313",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232348313"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r232348313"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232348313/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2039,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234827979",
    "pull_request_review_id": 176554059,
    "id": 234827979,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDgyNzk3OQ==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 118,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Like the conflicting input index?",
    "created_at": "2018-11-20T00:06:37Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234827979",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234827979"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234827979"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234827979/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1888,
    "side": "RIGHT",
    "in_reply_to_id": 213504242
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234828603",
    "pull_request_review_id": 176554765,
    "id": 234828603,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDgyODYwMw==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 122,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "@achow101 could you ack/nack on #12419, esp @MeshCollider https://github.com/bitcoin/bitcoin/pull/12419#issuecomment-437636604",
    "created_at": "2018-11-20T00:09:48Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234828603",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234828603"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234828603"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234828603/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1892,
    "side": "RIGHT",
    "in_reply_to_id": 213504324
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234829077",
    "pull_request_review_id": 176555323,
    "id": 234829077,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDgyOTA3Nw==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 8,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should use `RPCHelpMan` from #14530.",
    "created_at": "2018-11-20T00:12:20Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234829077",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234829077"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234829077"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234829077/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1780,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234830911",
    "pull_request_review_id": 176555323,
    "id": 234830911,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDgzMDkxMQ==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 44,
    "original_position": 24,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could add test for this error.",
    "created_at": "2018-11-20T00:22:00Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234830911",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234830911"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234830911"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234830911/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1720,
    "original_line": 1720,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234830933",
    "pull_request_review_id": 176555323,
    "id": 234830933,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDgzMDkzMw==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 6,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit, `{`",
    "created_at": "2018-11-20T00:22:07Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234830933",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234830933"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r234830933"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234830933/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1699,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237732910",
    "pull_request_review_id": 180106823,
    "id": 237732910,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzczMjkxMA==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 111,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It would be less code, and less complexity, which I would say is always better, absent a reason to write more code. Why write more code? \r\n",
    "created_at": "2018-11-30T03:05:00Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r237732910",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237732910"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r237732910"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237732910/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1881,
    "side": "RIGHT",
    "in_reply_to_id": 213505237
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238517900",
    "pull_request_review_id": 181077066,
    "id": 238517900,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODUxNzkwMA==",
    "diff_hunk": "@@ -1791,6 +1792,320 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+                            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+                            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+                            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+                            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 111,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f29d03c08e587b9eddb4d205b46eff7cb01f0328",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "(Also, this is copied from combinepsbt, where it is easiest to treat the first tx specially, because we need something to compare all the others to, to make sure the underlying transaction is the same. That restriction doesn't exist here, so the need for the extra step is gone.)",
    "created_at": "2018-12-04T03:14:31Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r238517900",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238517900"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r238517900"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238517900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1881,
    "side": "RIGHT",
    "in_reply_to_id": 213505237
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/248126733",
    "pull_request_review_id": 192943548,
    "id": 248126733,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0ODEyNjczMw==",
    "diff_hunk": "@@ -1773,6 +1774,324 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"joinpsbts [\\\"psbt\\\",...]\\n\"\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Clear signatures from all inputs\n+    for (auto& input : merged_psbt.inputs) {\n+        input.partial_sigs.clear();\n+    }\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        for (unsigned int i = 0; i < it->tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(it->tx->vin[i], it->inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"An input exists in multiple PSBTs\");\n+            }\n+        }\n+        for (unsigned int i = 0; i < it->tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(it->tx->vout[i], it->outputs[i]);\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"analyzepsbt \\\"psbt\\\"\\n\"\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"        \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 160,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "afdec9a0ef6c2d77e0a92650d8800e6be56d8950",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This doesn't match the code, right? \"next\" goes inside the input, not inside \"missing\"?",
    "created_at": "2019-01-16T01:43:07Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r248126733",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/248126733"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r248126733"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/248126733/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1925,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250855459",
    "pull_request_review_id": 196345641,
    "id": 250855459,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDg1NTQ1OQ==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"utxoupdatepsbt \\\"psbt\\\"\\n\"\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 44,
    "original_position": 24,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`DecodePSBT` has its own tests.",
    "created_at": "2019-01-25T03:17:56Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r250855459",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250855459"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r250855459"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250855459/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1720,
    "original_line": 1720,
    "side": "RIGHT",
    "in_reply_to_id": 234830911
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250855492",
    "pull_request_review_id": 196345691,
    "id": 250855492,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDg1NTQ5Mg==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 6,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Put the bracket where?",
    "created_at": "2019-01-25T03:18:20Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r250855492",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250855492"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r250855492"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250855492/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1699,
    "side": "RIGHT",
    "in_reply_to_id": 234830933
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251659769",
    "pull_request_review_id": 197339639,
    "id": 251659769,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTY1OTc2OQ==",
    "diff_hunk": "@@ -237,7 +248,7 @@ bool PSBTInputSigned(PSBTInput& input)\n     return !input.final_script_sig.empty() || !input.final_script_witness.IsNull();\n }\n \n-bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash)\n+bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash, std::vector<CKeyID>* missing_pubkeys, std::vector<CKeyID>* missing_sigs, uint160* missing_redeem_script, uint256* missing_witness_script, bool use_dummy)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 50,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "What about just having SignPSBTInput take an (optional) output-parameter sigdata, just like ProduceSignature? This function signature is getting unwieldy.",
    "created_at": "2019-01-29T01:20:56Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251659769",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251659769"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251659769"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251659769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 251,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251662651",
    "pull_request_review_id": 197342859,
    "id": 251662651,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTY2MjY1MQ==",
    "diff_hunk": "@@ -629,6 +679,18 @@ bool PSBTInput::IsSane() const\n     return true;\n }\n \n+bool PSBTInput::GetUTXO(CTxOut& utxo, int prevout_index) const",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 123,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This interface feels fragile to me. Could this instead be \"bool PartiallySignedTransaction::GetInputUTXO(CTxOut& utxo, int input_index)\"? That version would be resistant to misuse, whereas this version will do non-obvious crazy things if you accidentally give it the wrong prevout_index for your input (which seems easy to do.)",
    "created_at": "2019-01-29T01:35:54Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251662651",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251662651"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251662651"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251662651/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 682,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251663308",
    "pull_request_review_id": 197343622,
    "id": 251663308,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTY2MzMwOA==",
    "diff_hunk": "@@ -1739,6 +1741,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+                    }}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"      }\\n\"\n+            \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 228,
    "original_position": 221,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Are there cases where this isn't overwritten by a later check? If so, you should set all_final = false here. (If not you should remove this.)",
    "created_at": "2019-01-29T01:39:17Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251663308",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251663308"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251663308"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251663308/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1904,
    "original_line": 1904,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251663915",
    "pull_request_review_id": 197344349,
    "id": 251663915,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTY2MzkxNQ==",
    "diff_hunk": "@@ -1739,6 +1741,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+                    }}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"      }\\n\"\n+            \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 228,
    "original_position": 221,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Oh, I see, it's handled by calc_fee = false? The flow is a little hard to follow.",
    "created_at": "2019-01-29T01:42:50Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251663915",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251663915"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r251663915"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/251663915/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1904,
    "original_line": 1904,
    "side": "RIGHT",
    "in_reply_to_id": 251663308
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255283623",
    "pull_request_review_id": 201846275,
    "id": 255283623,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTI4MzYyMw==",
    "diff_hunk": "@@ -1739,6 +1739,68 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 75,
    "original_position": 56,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "b2c85b14f111b5011d3cf8a397679c159825766b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Not P2SH? There's no guarantee that P2SH outputs are witness of course, but there is no real harm in including too much.",
    "created_at": "2019-02-09T02:19:39Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255283623",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255283623"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255283623"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255283623/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1751,
    "original_line": 1751,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255313205",
    "pull_request_review_id": 201877843,
    "id": 255313205,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTMxMzIwNQ==",
    "diff_hunk": "@@ -1739,6 +1739,68 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 75,
    "original_position": 56,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "b2c85b14f111b5011d3cf8a397679c159825766b",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think that would be a problem right now since providing a witness utxo requires a witness signature and if a P2SH output was not witness, then it would never be signed.",
    "created_at": "2019-02-09T20:55:25Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255313205",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255313205"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255313205"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255313205/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1751,
    "original_line": 1751,
    "side": "RIGHT",
    "in_reply_to_id": 255283623
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315183",
    "pull_request_review_id": 201879995,
    "id": 255315183,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTMxNTE4Mw==",
    "diff_hunk": "@@ -237,7 +248,7 @@ bool PSBTInputSigned(PSBTInput& input)\n     return !input.final_script_sig.empty() || !input.final_script_witness.IsNull();\n }\n \n-bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash)\n+bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash, std::vector<CKeyID>* missing_pubkeys, std::vector<CKeyID>* missing_sigs, uint160* missing_redeem_script, uint256* missing_witness_script, bool use_dummy)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 50,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2019-02-09T22:03:50Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255315183",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315183"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255315183"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315183/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 251,
    "side": "RIGHT",
    "in_reply_to_id": 251659769
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315191",
    "pull_request_review_id": 201880002,
    "id": 255315191,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTMxNTE5MQ==",
    "diff_hunk": "@@ -629,6 +679,18 @@ bool PSBTInput::IsSane() const\n     return true;\n }\n \n+bool PSBTInput::GetUTXO(CTxOut& utxo, int prevout_index) const",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 123,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2019-02-09T22:04:04Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255315191",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315191"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255315191"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315191/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 682,
    "side": "RIGHT",
    "in_reply_to_id": 251662651
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315242",
    "pull_request_review_id": 201880063,
    "id": 255315242,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTMxNTI0Mg==",
    "diff_hunk": "@@ -1739,6 +1741,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+                    }}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"      }\\n\"\n+            \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 228,
    "original_position": 221,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'm not quite sure you are asking.",
    "created_at": "2019-02-09T22:06:01Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255315242",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315242"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255315242"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255315242/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1904,
    "original_line": 1904,
    "side": "RIGHT",
    "in_reply_to_id": 251663308
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255323243",
    "pull_request_review_id": 201888156,
    "id": 255323243,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTMyMzI0Mw==",
    "diff_hunk": "@@ -1739,6 +1741,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, /* opt */ false, /* default_val */ \"\", \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+                    }}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+            \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+            \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+            \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"signatures\\\" : [          (array)\\n\"\n+            \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+            \"        ]\\n\"\n+            \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+            \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+            \"      }\\n\"\n+            \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+            \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+            \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (input.GetUTXO(utxo, psbtx.tx->vin[i].prevout.n)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 228,
    "original_position": 221,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "e65b4a373b06dca26f1b2c291a3c98613800516d",
    "user": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yeah, I think I just have trouble following the state machine of this function, which is a little complicated, and so I was confused about whether all_final was actually getting set correctly in every case. Since nobody's relying on it yet, and I haven't found any actual issues, I think it should probably go in as-is, and I may propose some refactoring when I go to actually use it.",
    "created_at": "2019-02-10T04:32:19Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255323243",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255323243"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255323243"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255323243/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1904,
    "original_line": 1904,
    "side": "RIGHT",
    "in_reply_to_id": 251663308
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255835511",
    "pull_request_review_id": 202521987,
    "id": 255835511,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTgzNTUxMQ==",
    "diff_hunk": "@@ -572,9 +576,12 @@ struct PartiallySignedTransaction\n     bool IsNull() const;\n     void Merge(const PartiallySignedTransaction& psbt);\n     bool IsSane() const;\n+    bool AddInput(const CTxIn& txin, PSBTInput& psbtin);\n+    bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);\n     PartiallySignedTransaction() {}\n     PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n     explicit PartiallySignedTransaction(const CMutableTransaction& tx);\n+    bool GetInputUTXO(CTxOut& utxo, int input_index) const;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 20,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "1193ced586f5d55b4946f06cc2731c5a72389634",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Please add a short doxygen documentation for the new calls.\r\n(I know, the current ones don't, but every day is a good day to get started)\r\n\r\nEdit: also, what is our normal argument ordering here? input then output arguments or vice versa? Let's try to be consistent.",
    "created_at": "2019-02-12T07:53:15Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255835511",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255835511"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255835511"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255835511/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 591,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255850010",
    "pull_request_review_id": 202539443,
    "id": 255850010,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTg1MDAxMA==",
    "diff_hunk": "@@ -572,9 +576,12 @@ struct PartiallySignedTransaction\n     bool IsNull() const;\n     void Merge(const PartiallySignedTransaction& psbt);\n     bool IsSane() const;\n+    bool AddInput(const CTxIn& txin, PSBTInput& psbtin);\n+    bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);\n     PartiallySignedTransaction() {}\n     PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n     explicit PartiallySignedTransaction(const CMutableTransaction& tx);\n+    bool GetInputUTXO(CTxOut& utxo, int input_index) const;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 20,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "1193ced586f5d55b4946f06cc2731c5a72389634",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Maybe we can avoid the input/output order completely by returning an `Optional<CTxOut>` instead. We have this in `optional.h`, after all.",
    "created_at": "2019-02-12T08:43:04Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255850010",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255850010"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255850010"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255850010/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 591,
    "side": "RIGHT",
    "in_reply_to_id": 255835511
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255854713",
    "pull_request_review_id": 202544762,
    "id": 255854713,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NTg1NDcxMw==",
    "diff_hunk": "@@ -290,5 +291,72 @@ def run_test(self):\n         psbt = self.nodes[1].walletcreatefundedpsbt([], [{p2pkh : 1}], 0, {\"includeWatching\" : True}, True)\n         self.nodes[0].decodepsbt(psbt['psbt'])\n \n+        # Send to all types of addresses\n+        addr1 = self.nodes[1].getnewaddress(\"\", \"bech32\")\n+        txid1 = self.nodes[0].sendtoaddress(addr1, 11)\n+        vout1 = find_output(self.nodes[0], txid1, 11)\n+        addr2 = self.nodes[1].getnewaddress(\"\", \"legacy\")\n+        txid2 = self.nodes[0].sendtoaddress(addr2, 11)\n+        vout2 = find_output(self.nodes[0], txid2, 11)\n+        addr3 = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n+        txid3 = self.nodes[0].sendtoaddress(addr3, 11)\n+        vout3 = find_output(self.nodes[0], txid3, 11)\n+        self.sync_all()\n+\n+        # Update a PSBT with UTXOs from the node\n+        # Bech32 inputs should be filled with witness UTXO. Other inputs should not be filled because they are non-witness\n+        psbt = self.nodes[1].createpsbt([{\"txid\":txid1, \"vout\":vout1},{\"txid\":txid2, \"vout\":vout2},{\"txid\":txid3, \"vout\":vout3}], {self.nodes[0].getnewaddress():32.999})\n+        decoded = self.nodes[1].decodepsbt(psbt)\n+        assert \"witness_utxo\" not in decoded['inputs'][0] and \"non_witness_utxo\" not in decoded['inputs'][0]\n+        assert \"witness_utxo\" not in decoded['inputs'][1] and \"non_witness_utxo\" not in decoded['inputs'][1]\n+        assert \"witness_utxo\" not in decoded['inputs'][2] and \"non_witness_utxo\" not in decoded['inputs'][2]\n+        updated = self.nodes[1].utxoupdatepsbt(psbt)\n+        decoded = self.nodes[1].decodepsbt(updated)\n+        assert \"witness_utxo\" in decoded['inputs'][0] and \"non_witness_utxo\" not in decoded['inputs'][0]\n+        assert \"witness_utxo\" not in decoded['inputs'][1] and \"non_witness_utxo\" not in decoded['inputs'][1]\n+        assert \"witness_utxo\" not in decoded['inputs'][2] and \"non_witness_utxo\" not in decoded['inputs'][2]\n+\n+        # Two PSBTs with a common input should not be joinable\n+        psbt1 = self.nodes[1].createpsbt([{\"txid\":txid1, \"vout\":vout1}], {self.nodes[0].getnewaddress():10.999})",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 50,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "1193ced586f5d55b4946f06cc2731c5a72389634",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`Decimal(\"10.999\")` I guess?\r\n(there are some more occurrences of floats for monetary values, won't comment them individually)",
    "created_at": "2019-02-12T08:56:23Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255854713",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255854713"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r255854713"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/255854713/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 320,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256054582",
    "pull_request_review_id": 202793704,
    "id": 256054582,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NjA1NDU4Mg==",
    "diff_hunk": "@@ -572,9 +576,12 @@ struct PartiallySignedTransaction\n     bool IsNull() const;\n     void Merge(const PartiallySignedTransaction& psbt);\n     bool IsSane() const;\n+    bool AddInput(const CTxIn& txin, PSBTInput& psbtin);\n+    bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);\n     PartiallySignedTransaction() {}\n     PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n     explicit PartiallySignedTransaction(const CMutableTransaction& tx);\n+    bool GetInputUTXO(CTxOut& utxo, int input_index) const;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 20,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "1193ced586f5d55b4946f06cc2731c5a72389634",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Added doxygen comment",
    "created_at": "2019-02-12T17:08:01Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r256054582",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256054582"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r256054582"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256054582/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 591,
    "side": "RIGHT",
    "in_reply_to_id": 255835511
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256054620",
    "pull_request_review_id": 202793753,
    "id": 256054620,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NjA1NDYyMA==",
    "diff_hunk": "@@ -290,5 +291,72 @@ def run_test(self):\n         psbt = self.nodes[1].walletcreatefundedpsbt([], [{p2pkh : 1}], 0, {\"includeWatching\" : True}, True)\n         self.nodes[0].decodepsbt(psbt['psbt'])\n \n+        # Send to all types of addresses\n+        addr1 = self.nodes[1].getnewaddress(\"\", \"bech32\")\n+        txid1 = self.nodes[0].sendtoaddress(addr1, 11)\n+        vout1 = find_output(self.nodes[0], txid1, 11)\n+        addr2 = self.nodes[1].getnewaddress(\"\", \"legacy\")\n+        txid2 = self.nodes[0].sendtoaddress(addr2, 11)\n+        vout2 = find_output(self.nodes[0], txid2, 11)\n+        addr3 = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n+        txid3 = self.nodes[0].sendtoaddress(addr3, 11)\n+        vout3 = find_output(self.nodes[0], txid3, 11)\n+        self.sync_all()\n+\n+        # Update a PSBT with UTXOs from the node\n+        # Bech32 inputs should be filled with witness UTXO. Other inputs should not be filled because they are non-witness\n+        psbt = self.nodes[1].createpsbt([{\"txid\":txid1, \"vout\":vout1},{\"txid\":txid2, \"vout\":vout2},{\"txid\":txid3, \"vout\":vout3}], {self.nodes[0].getnewaddress():32.999})\n+        decoded = self.nodes[1].decodepsbt(psbt)\n+        assert \"witness_utxo\" not in decoded['inputs'][0] and \"non_witness_utxo\" not in decoded['inputs'][0]\n+        assert \"witness_utxo\" not in decoded['inputs'][1] and \"non_witness_utxo\" not in decoded['inputs'][1]\n+        assert \"witness_utxo\" not in decoded['inputs'][2] and \"non_witness_utxo\" not in decoded['inputs'][2]\n+        updated = self.nodes[1].utxoupdatepsbt(psbt)\n+        decoded = self.nodes[1].decodepsbt(updated)\n+        assert \"witness_utxo\" in decoded['inputs'][0] and \"non_witness_utxo\" not in decoded['inputs'][0]\n+        assert \"witness_utxo\" not in decoded['inputs'][1] and \"non_witness_utxo\" not in decoded['inputs'][1]\n+        assert \"witness_utxo\" not in decoded['inputs'][2] and \"non_witness_utxo\" not in decoded['inputs'][2]\n+\n+        # Two PSBTs with a common input should not be joinable\n+        psbt1 = self.nodes[1].createpsbt([{\"txid\":txid1, \"vout\":vout1}], {self.nodes[0].getnewaddress():10.999})",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 50,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "1193ced586f5d55b4946f06cc2731c5a72389634",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2019-02-12T17:08:05Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r256054620",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256054620"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r256054620"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256054620/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 320,
    "side": "RIGHT",
    "in_reply_to_id": 255854713
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257416737",
    "pull_request_review_id": 204471308,
    "id": 257416737,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQxNjczNw==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 6,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Technically this violates the style guide, as it's not putting the then clause on the same line as the `if`, so it needs braces + indenting on the next line.",
    "created_at": "2019-02-15T22:51:01Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257416737",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257416737"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257416737"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257416737/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1699,
    "side": "RIGHT",
    "in_reply_to_id": 234830933
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257418589",
    "pull_request_review_id": 204471308,
    "id": 257418589,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQxODU4OQ==",
    "diff_hunk": "@@ -1739,6 +1739,68 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"A base64 string of a PSBT\"}\n+            }}.ToString() +\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 75,
    "original_position": 56,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "b2c85b14f111b5011d3cf8a397679c159825766b",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I guess there's an obvious solution which can be added later, namely letting the RPC take in descriptor(s) that apply to its inputs. I'll look into that after this PR is merged.",
    "created_at": "2019-02-15T23:00:03Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257418589",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257418589"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257418589"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257418589/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1751,
    "original_line": 1751,
    "side": "RIGHT",
    "in_reply_to_id": 255283623
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420296",
    "pull_request_review_id": 204471308,
    "id": 257420296,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQyMDI5Ng==",
    "diff_hunk": "@@ -1691,6 +1694,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+                    }}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"{\\n\"\n+                \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                \"    {\\n\"\n+                \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"signatures\\\" : [          (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                \"      }\\n\"\n+                \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                \"    }\\n\"\n+                \"    ,...\\n\"\n+                \"  ]\\n\"\n+                \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                \"}\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (psbtx.GetInputUTXO(utxo, i)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 231,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "0c35f0e802274c27736b16a4542ad44bc3c7f794",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Use `PSBTInputSigned` here?",
    "created_at": "2019-02-15T23:08:49Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257420296",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420296"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257420296"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1907,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420598",
    "pull_request_review_id": 204471308,
    "id": 257420598,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQyMDU5OA==",
    "diff_hunk": "@@ -1691,6 +1694,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+                    }}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"{\\n\"\n+                \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                \"    {\\n\"\n+                \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"signatures\\\" : [          (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                \"      }\\n\"\n+                \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                \"    }\\n\"\n+                \"    ,...\\n\"\n+                \"  ]\\n\"\n+                \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                \"}\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (psbtx.GetInputUTXO(utxo, i)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 231,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "0c35f0e802274c27736b16a4542ad44bc3c7f794",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think you may want to add a check here for whether the input UTXO is present (if not, it's possible that you first set next=\"updater\", and then overwrite it in this conditional).",
    "created_at": "2019-02-15T23:10:23Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257420598",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420598"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257420598"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420598/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1907,
    "side": "RIGHT",
    "in_reply_to_id": 257420296
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420943",
    "pull_request_review_id": 204471308,
    "id": 257420943,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQyMDk0Mw==",
    "diff_hunk": "@@ -1691,6 +1694,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+                    }}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"{\\n\"\n+                \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                \"    {\\n\"\n+                \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"signatures\\\" : [          (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                \"      }\\n\"\n+                \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                \"    }\\n\"\n+                \"    ,...\\n\"\n+                \"  ]\\n\"\n+                \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                \"}\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (psbtx.GetInputUTXO(utxo, i)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            SignatureData outdata;\n+            bool complete = SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, 1, &outdata);\n+\n+            // Things are missing\n+            if (!complete) {\n+                if (!outdata.missing_pubkeys.empty()) {\n+                    // Missing pubkeys\n+                    UniValue missing_pubkeys_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : outdata.missing_pubkeys) {\n+                        missing_pubkeys_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"pubkeys\", missing_pubkeys_univ);\n+                }\n+                if (!outdata.missing_redeem_script.IsNull()) {\n+                    // Missing redeemScript\n+                    missing.pushKV(\"redeemscript\", HexStr(outdata.missing_redeem_script));\n+                }\n+                if (!outdata.missing_witness_script.IsNull()) {\n+                    // Missing witnessScript\n+                    missing.pushKV(\"witnessscript\", HexStr(outdata.missing_witness_script));\n+                }\n+                if (!outdata.missing_sigs.empty()) {\n+                    // Missing sigs\n+                    UniValue missing_sigs_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : outdata.missing_sigs) {\n+                        missing_sigs_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"signatures\", missing_sigs_univ);\n+                }\n+                input_univ.pushKV(\"missing\", missing);\n+\n+                // If we are only missing signatures and nothing else, then next is signer\n+                if (outdata.missing_pubkeys.empty() && outdata.missing_redeem_script.IsNull() && outdata.missing_witness_script.IsNull() && !outdata.missing_sigs.empty()) {\n+                    only_missing_sigs = true;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 269,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "0c35f0e802274c27736b16a4542ad44bc3c7f794",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think this (cross-input) variable can't be set to true here. If this branch is executed for the last input in a transaction, the global \"next\" will report \"signer\", even if keys/script or even UTXOs are missing for other inputs.\r\n\r\nYou probably want to have the variable start at true, and then set it to false if anything anywhere more than a signature is missing.",
    "created_at": "2019-02-15T23:12:27Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257420943",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420943"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257420943"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257420943/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1945,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447204",
    "pull_request_review_id": 204506278,
    "id": 257447204,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQ0NzIwNA==",
    "diff_hunk": "@@ -1691,6 +1694,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+                    }}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"{\\n\"\n+                \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                \"    {\\n\"\n+                \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"signatures\\\" : [          (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                \"      }\\n\"\n+                \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                \"    }\\n\"\n+                \"    ,...\\n\"\n+                \"  ]\\n\"\n+                \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                \"}\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (psbtx.GetInputUTXO(utxo, i)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 231,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "0c35f0e802274c27736b16a4542ad44bc3c7f794",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2019-02-16T05:16:45Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257447204",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447204"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257447204"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447204/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1907,
    "side": "RIGHT",
    "in_reply_to_id": 257420296
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447207",
    "pull_request_review_id": 204506282,
    "id": 257447207,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQ0NzIwNw==",
    "diff_hunk": "@@ -1691,6 +1694,334 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"utxoupdatepsbt\",\n+            \"\\nUpdates a PSBT with witness UTXOs retrieved from the UTXO set or the mempool.\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction with inputs updated\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"utxoupdatepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : psbtx.tx->vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Fill the inputs\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {\n+            continue;\n+        }\n+\n+        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);\n+\n+        std::vector<std::vector<unsigned char>> solutions_data;\n+        txnouttype which_type = Solver(coin.out.scriptPubKey, solutions_data);\n+        if (which_type == TX_WITNESS_V0_SCRIPTHASH || which_type == TX_WITNESS_V0_KEYHASH || which_type == TX_WITNESS_UNKNOWN) {\n+            input.witness_utxo = coin.out;\n+        }\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue joinpsbts(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"joinpsbts\",\n+            \"\\nJoins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\\n\"\n+            \"No input in any of the PSBTs can be in more than one of the PSBTs.\\n\",\n+            {\n+                {\"txs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of base64 strings of partially signed transactions\",\n+                    {\n+                        {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+                    }}\n+            },\n+            RPCResult {\n+                \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"joinpsbts\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+\n+    if (txs.size() <= 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"At least two PSBTs are required to join PSBTs.\");\n+    }\n+\n+    int32_t best_version = 1;\n+    uint32_t best_locktime = 0xffffffff;\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+        // Choose the highest version number\n+        if (psbtx.tx->nVersion > best_version) {\n+            best_version = psbtx.tx->nVersion;\n+        }\n+        // Choose the lowest lock time\n+        if (psbtx.tx->nLockTime < best_locktime) {\n+            best_locktime = psbtx.tx->nLockTime;\n+        }\n+    }\n+\n+    // Create a blank psbt where everything will be added\n+    PartiallySignedTransaction merged_psbt;\n+    merged_psbt.tx = CMutableTransaction();\n+    merged_psbt.tx->nVersion = best_version;\n+    merged_psbt.tx->nLockTime = best_locktime;\n+\n+    // Merge\n+    for (auto& psbt : psbtxs) {\n+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {\n+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input %s:%d exists in multiple PSBTs\", psbt.tx->vin[i].prevout.hash.ToString().c_str(), psbt.tx->vin[i].prevout.n));\n+            }\n+        }\n+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {\n+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);\n+        }\n+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+    }\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue analyzepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"analyzepsbt\",\n+            \"\\nAnalyzes and provides information about the current status of a PSBT and its inputs\\n\",\n+            {\n+                {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A base64 string of a PSBT\"}\n+            },\n+            RPCResult {\n+                \"{\\n\"\n+                \"  \\\"inputs\\\" : [                      (array of json objects)\\n\"\n+                \"    {\\n\"\n+                \"      \\\"has_utxo\\\" : true|false     (boolean) Whether a UTXO is provided\\n\"\n+                \"      \\\"is_final\\\" : true|false     (boolean) Whether the input is finalized\\n\"\n+                \"      \\\"missing\\\" : {               (json object, optional) Things that are missing that are required to complete this input\\n\"\n+                \"        \\\"pubkeys\\\" : [             (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"signatures\\\" : [          (array)\\n\"\n+                \"          \\\"keyid\\\"                 (string) Public key ID, hash160 of the public key, of a public key whose signature is missing\\n\"\n+                \"        ]\\n\"\n+                \"        \\\"redeemscript\\\" : \\\"hash\\\"   (string) Hash160 of the redeemScript that is missing\\n\"\n+                \"        \\\"witnessscript\\\" : \\\"hash\\\"  (string) SHA256 of the witnessScript that is missing\\n\"\n+                \"      }\\n\"\n+                \"      \\\"next\\\" : \\\"role\\\"           (string) Role of the next person that this input needs to go to\\n\"\n+                \"    }\\n\"\n+                \"    ,...\\n\"\n+                \"  ]\\n\"\n+                \"  \\\"estimated_vsize\\\" : vsize       (numeric) Estimated vsize of the final signed transaction\\n\"\n+                \"  \\\"estimated_feerate\\\" : feerate   (numeric, optional) Estimated feerate of the final signed transaction. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"fee\\\" : fee                     (numeric, optional) The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled.\\n\"\n+                \"  \\\"next\\\" : \\\"role\\\"                 (string) Role of the next person that this psbt needs to go to\\n\"\n+                \"}\\n\"\n+            },\n+            RPCExamples {\n+                HelpExampleCli(\"analyzepsbt\", \"\\\"psbt\\\"\")\n+            }}.ToString());\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Go through each input and build status\n+    UniValue result(UniValue::VOBJ);\n+    UniValue inputs_result(UniValue::VARR);\n+    bool calc_fee = true;\n+    bool all_final = true;\n+    bool only_missing_sigs = false;\n+    bool only_missing_final = false;\n+    CAmount in_amt = 0;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs[i];\n+        UniValue input_univ(UniValue::VOBJ);\n+        UniValue missing(UniValue::VOBJ);\n+\n+        // Check for a UTXO\n+        CTxOut utxo;\n+        if (psbtx.GetInputUTXO(utxo, i)) {\n+            in_amt += utxo.nValue;\n+            input_univ.pushKV(\"has_utxo\", true);\n+        } else {\n+            input_univ.pushKV(\"has_utxo\", false);\n+            input_univ.pushKV(\"is_final\", false);\n+            input_univ.pushKV(\"next\", \"updater\");\n+            calc_fee = false;\n+        }\n+\n+        // Check if it is final\n+        if (input.final_script_sig.empty() && input.final_script_witness.IsNull()) {\n+            input_univ.pushKV(\"is_final\", false);\n+            all_final = false;\n+\n+            // Figure out what is missing\n+            SignatureData outdata;\n+            bool complete = SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, 1, &outdata);\n+\n+            // Things are missing\n+            if (!complete) {\n+                if (!outdata.missing_pubkeys.empty()) {\n+                    // Missing pubkeys\n+                    UniValue missing_pubkeys_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : outdata.missing_pubkeys) {\n+                        missing_pubkeys_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"pubkeys\", missing_pubkeys_univ);\n+                }\n+                if (!outdata.missing_redeem_script.IsNull()) {\n+                    // Missing redeemScript\n+                    missing.pushKV(\"redeemscript\", HexStr(outdata.missing_redeem_script));\n+                }\n+                if (!outdata.missing_witness_script.IsNull()) {\n+                    // Missing witnessScript\n+                    missing.pushKV(\"witnessscript\", HexStr(outdata.missing_witness_script));\n+                }\n+                if (!outdata.missing_sigs.empty()) {\n+                    // Missing sigs\n+                    UniValue missing_sigs_univ(UniValue::VARR);\n+                    for (const CKeyID& pubkey : outdata.missing_sigs) {\n+                        missing_sigs_univ.push_back(HexStr(pubkey));\n+                    }\n+                    missing.pushKV(\"signatures\", missing_sigs_univ);\n+                }\n+                input_univ.pushKV(\"missing\", missing);\n+\n+                // If we are only missing signatures and nothing else, then next is signer\n+                if (outdata.missing_pubkeys.empty() && outdata.missing_redeem_script.IsNull() && outdata.missing_witness_script.IsNull() && !outdata.missing_sigs.empty()) {\n+                    only_missing_sigs = true;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 269,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "0c35f0e802274c27736b16a4542ad44bc3c7f794",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2019-02-16T05:16:51Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257447207",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447207"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257447207"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447207/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1945,
    "side": "RIGHT",
    "in_reply_to_id": 257420943
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447218",
    "pull_request_review_id": 204506290,
    "id": 257447218,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzQ0NzIxOA==",
    "diff_hunk": "@@ -1773,6 +1773,67 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n     return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n }\n \n+UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 6,
    "commit_id": "540729ef4bf1b6c6da1ec795e441d2ce56a9a58b",
    "original_commit_id": "f2a2f06fed01829e1f1ae574f50cce841fdcbbff",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2019-02-16T05:17:15Z",
    "updated_at": "2019-02-16T16:51:13Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257447218",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447218"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13932#discussion_r257447218"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13932"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/257447218/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1699,
    "side": "RIGHT",
    "in_reply_to_id": 234830933
  }
]