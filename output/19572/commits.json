[
  {
    "sha": "1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYjYxNWU2MWJmYzQ2NGYyMTVhMWI0OGU2ZTI3ZDFlOGZjMTZiMmQx",
    "commit": {
      "author": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-07-22T14:49:43Z"
      },
      "committer": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-22T15:17:50Z"
      },
      "message": "zmq test: Actually make reorg occur",
      "tree": {
        "sha": "f6b941a0efdee9cf6b510e926d86957e0d2e1eeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6b941a0efdee9cf6b510e926d86957e0d2e1eeb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d692d192cda37fda6359ad0736b85de20383db73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d692d192cda37fda6359ad0736b85de20383db73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d692d192cda37fda6359ad0736b85de20383db73"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e87def6930423a851fa9451fbcfba16abe8a86f2",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
        "patch": "@@ -5,7 +5,7 @@\n \"\"\"Test the ZMQ notification interface.\"\"\"\n import struct\n \n-from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE, ADDRESS_BCRT1_P2WSH_OP_TRUE\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.messages import CTransaction, hash256\n from test_framework.util import assert_equal, connect_nodes\n@@ -177,8 +177,8 @@ def test_reorg(self):\n         assert_equal(hashtx.receive().hex(), payment_txid)\n         assert_equal(hashtx.receive().hex(), disconnect_cb)\n \n-        # Generate 2 blocks in nodes[1]\n-        connect_blocks = self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_UNSPENDABLE)\n+        # Generate 2 blocks in nodes[1] to a different address to ensure split\n+        connect_blocks = self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         connect_nodes(self.nodes[0], 1)"
      }
    ]
  },
  {
    "sha": "e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzZmYzJiODRkMDY1YzlkMDYwMTBkMGExMGIzMTZmMWY5ZDM2ZmI5",
    "commit": {
      "author": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-04T15:55:58Z"
      },
      "committer": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-22T15:34:30Z"
      },
      "message": "Add 'sequence' zmq publisher to track all block (dis)connects, mempool deltas\n\nUsing the zmq notifications to avoid excessive mempool polling can be difficult\ngiven the current notifications available. It announces all transactions\nbeing added to mempool or included in blocks, but announces no evictions\nand gives no indication if the transaction is in the mempool or a block.\n\nBlock notifications for zmq are also substandard, in that it only announces\nblock tips, while all block transactions are still announced.\n\nThis commit adds a unified stream which can be used to closely track mempool:\n\n1) getrawmempool to fill out mempool knowledge\n2) if txhash is announced, add or remove from set\nbased on add/remove flag\n3) if blockhash is announced, get block txn list,\nremove from those transactions local view of mempool\n4) if we drop a sequence number, go to (1)\n\nThe mempool sequence number starts at the value 1, and\nincrements each time a transaction enters the mempool,\nor is evicted from the mempool for any reason, including\nblock inclusion. The mempool sequence number is published\nvia ZMQ for any transaction-related notification.\n\nThese features allow for ZMQ/RPC consumer to track mempool\nstate in a more exacting way, without unnecesarily polling\ngetrawmempool. See interface_zmq.py::test_mempool_sync for\nexample usage.",
      "tree": {
        "sha": "b475b1d196ca37be27c8271f9b8f3b7c1830d848",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b475b1d196ca37be27c8271f9b8f3b7c1830d848"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b615e61bfc464f215a1b48e6e27d1e8fc16b2d1"
      }
    ],
    "stats": {
      "total": 247,
      "additions": 206,
      "deletions": 41
    },
    "files": [
      {
        "sha": "132acbfc81a00e83180f94e71721c1f0a55737ab",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -488,19 +488,23 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-zmqpubhashtx=<address>\", \"Enable publish hash transaction in <address>\", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n     argsman.AddArg(\"-zmqpubrawblock=<address>\", \"Enable publish raw block in <address>\", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n     argsman.AddArg(\"-zmqpubrawtx=<address>\", \"Enable publish raw transaction in <address>\", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n+    argsman.AddArg(\"-zmqpubsequence=<address>\", \"Enable publish hash block and tx sequence in <address>\", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n     argsman.AddArg(\"-zmqpubhashblockhwm=<n>\", strprintf(\"Set publish hash block outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n     argsman.AddArg(\"-zmqpubhashtxhwm=<n>\", strprintf(\"Set publish hash transaction outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n     argsman.AddArg(\"-zmqpubrawblockhwm=<n>\", strprintf(\"Set publish raw block outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n     argsman.AddArg(\"-zmqpubrawtxhwm=<n>\", strprintf(\"Set publish raw transaction outbound message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n+    argsman.AddArg(\"-zmqpubsequencehwm=<n>\", strprintf(\"Set publish hash sequence message high water mark (default: %d)\", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);\n #else\n     hidden_args.emplace_back(\"-zmqpubhashblock=<address>\");\n     hidden_args.emplace_back(\"-zmqpubhashtx=<address>\");\n     hidden_args.emplace_back(\"-zmqpubrawblock=<address>\");\n     hidden_args.emplace_back(\"-zmqpubrawtx=<address>\");\n+    hidden_args.emplace_back(\"-zmqpubsequence=<n>\");\n     hidden_args.emplace_back(\"-zmqpubhashblockhwm=<n>\");\n     hidden_args.emplace_back(\"-zmqpubhashtxhwm=<n>\");\n     hidden_args.emplace_back(\"-zmqpubrawblockhwm=<n>\");\n     hidden_args.emplace_back(\"-zmqpubrawtxhwm=<n>\");\n+    hidden_args.emplace_back(\"-zmqpubsequencehwm=<n>\");\n #endif\n \n     argsman.AddArg(\"-checkblocks=<n>\", strprintf(\"How many blocks to check at startup (default: %u, 0 = all)\", DEFAULT_CHECKBLOCKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);"
      },
      {
        "sha": "4c5ebe66fc92d0a3ff94899a86dfec31780fce70",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -59,13 +59,13 @@ class NotificationsProxy : public CValidationInterface\n     explicit NotificationsProxy(std::shared_ptr<Chain::Notifications> notifications)\n         : m_notifications(std::move(notifications)) {}\n     virtual ~NotificationsProxy() = default;\n-    void TransactionAddedToMempool(const CTransactionRef& tx) override\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override\n     {\n-        m_notifications->transactionAddedToMempool(tx);\n+        m_notifications->transactionAddedToMempool(tx, mempool_sequence);\n     }\n-    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason) override\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override\n     {\n-        m_notifications->transactionRemovedFromMempool(tx, reason);\n+        m_notifications->transactionRemovedFromMempool(tx, reason, mempool_sequence);\n     }\n     void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override\n     {\n@@ -405,7 +405,7 @@ class ChainImpl : public Chain\n         if (!m_node.mempool) return;\n         LOCK2(::cs_main, m_node.mempool->cs);\n         for (const CTxMemPoolEntry& entry : m_node.mempool->mapTx) {\n-            notifications.transactionAddedToMempool(entry.GetSharedTx());\n+            notifications.transactionAddedToMempool(entry.GetSharedTx(), 0 /* mempool_sequence */);\n         }\n     }\n     NodeContext& m_node;"
      },
      {
        "sha": "85d09be0f33081ee2daac8ce6fa8436a7b1e3939",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -242,8 +242,8 @@ class Chain\n     {\n     public:\n         virtual ~Notifications() {}\n-        virtual void transactionAddedToMempool(const CTransactionRef& tx) {}\n-        virtual void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason) {}\n+        virtual void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}\n+        virtual void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}\n         virtual void blockConnected(const CBlock& block, int height) {}\n         virtual void blockDisconnected(const CBlock& block, int height) {}\n         virtual void updatedBlockTip() {}"
      },
      {
        "sha": "0bb7342db0212237347070c320a98db7515f1909",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 6,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -500,9 +500,12 @@ static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPool\n     info.pushKV(\"unbroadcast\", pool.IsUnbroadcastTx(tx.GetHash()));\n }\n \n-UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose)\n+UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose, bool include_mempool_sequence)\n {\n     if (verbose) {\n+        if (include_mempool_sequence) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Verbose results cannot contain mempool sequence values.\");\n+        }\n         LOCK(pool.cs);\n         UniValue o(UniValue::VOBJ);\n         for (const CTxMemPoolEntry& e : pool.mapTx) {\n@@ -516,14 +519,25 @@ UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose)\n         }\n         return o;\n     } else {\n+        uint64_t mempool_sequence;\n         std::vector<uint256> vtxid;\n-        pool.queryHashes(vtxid);\n-\n+        {\n+            LOCK(pool.cs);\n+            pool.queryHashes(vtxid);\n+            mempool_sequence = pool.GetSequence();\n+        }\n         UniValue a(UniValue::VARR);\n         for (const uint256& hash : vtxid)\n             a.push_back(hash.ToString());\n \n-        return a;\n+        if (!include_mempool_sequence) {\n+            return a;\n+        } else {\n+            UniValue o(UniValue::VOBJ);\n+            o.pushKV(\"txids\", a);\n+            o.pushKV(\"mempool_sequence\", mempool_sequence);\n+            return o;\n+        }\n     }\n }\n \n@@ -534,6 +548,7 @@ static RPCHelpMan getrawmempool()\n                 \"\\nHint: use getmempoolentry to fetch a specific transaction from the mempool.\\n\",\n                 {\n                     {\"verbose\", RPCArg::Type::BOOL, /* default */ \"false\", \"True for a json object, false for array of transaction ids\"},\n+                    {\"mempool_sequence\", RPCArg::Type::BOOL, /* default */ \"false\", \"If verbose=false, returns a json object with transaction list and mempool sequence number attached.\"},\n                 },\n                 {\n                     RPCResult{\"for verbose = false\",\n@@ -546,6 +561,15 @@ static RPCHelpMan getrawmempool()\n                         {\n                             {RPCResult::Type::OBJ, \"transactionid\", \"\", MempoolEntryDescription()},\n                         }},\n+                    RPCResult{\"for verbose = false and mempool_sequence = true\",\n+                        RPCResult::Type::OBJ, \"\", \"\",\n+                        {\n+                            {RPCResult::Type::ARR, \"txids\", \"\",\n+                            {\n+                                {RPCResult::Type::STR_HEX, \"\", \"The transaction id\"},\n+                            }},\n+                            {RPCResult::Type::NUM, \"mempool_sequence\", \"The mempool sequence value.\"},\n+                        }},\n                 },\n                 RPCExamples{\n                     HelpExampleCli(\"getrawmempool\", \"true\")\n@@ -557,7 +581,12 @@ static RPCHelpMan getrawmempool()\n     if (!request.params[0].isNull())\n         fVerbose = request.params[0].get_bool();\n \n-    return MempoolToJSON(EnsureMemPool(request.context), fVerbose);\n+    bool include_mempool_sequence = false;\n+    if (!request.params[1].isNull()) {\n+        include_mempool_sequence = request.params[1].get_bool();\n+    }\n+\n+    return MempoolToJSON(EnsureMemPool(request.context), fVerbose, include_mempool_sequence);\n },\n     };\n }\n@@ -2451,7 +2480,7 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"getmempooldescendants\",  &getmempooldescendants,  {\"txid\",\"verbose\"} },\n     { \"blockchain\",         \"getmempoolentry\",        &getmempoolentry,        {\"txid\"} },\n     { \"blockchain\",         \"getmempoolinfo\",         &getmempoolinfo,         {} },\n-    { \"blockchain\",         \"getrawmempool\",          &getrawmempool,          {\"verbose\"} },\n+    { \"blockchain\",         \"getrawmempool\",          &getrawmempool,          {\"verbose\", \"mempool_sequence\"} },\n     { \"blockchain\",         \"gettxout\",               &gettxout,               {\"txid\",\"n\",\"include_mempool\"} },\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        {\"hash_type\"} },\n     { \"blockchain\",         \"pruneblockchain\",        &pruneblockchain,        {\"height\"} },"
      },
      {
        "sha": "5b362bf211f73241556189b6b7e58af323c0d22f",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -43,7 +43,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIn\n UniValue MempoolInfoToJSON(const CTxMemPool& pool);\n \n /** Mempool to JSON */\n-UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose = false);\n+UniValue MempoolToJSON(const CTxMemPool& pool, bool verbose = false, bool include_mempool_sequence = false);\n \n /** Block header to JSON */\n UniValue blockheaderToJSON(const CBlockIndex* tip, const CBlockIndex* blockindex) LOCKS_EXCLUDED(cs_main);"
      },
      {
        "sha": "3c432464f241fc7dd1d6464531163378abfb116c",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -142,6 +142,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"pruneblockchain\", 0, \"height\" },\n     { \"keypoolrefill\", 0, \"newsize\" },\n     { \"getrawmempool\", 0, \"verbose\" },\n+    { \"getrawmempool\", 1, \"mempool_sequence\" },\n     { \"estimatesmartfee\", 0, \"conf_target\" },\n     { \"estimaterawfee\", 0, \"conf_target\" },\n     { \"estimaterawfee\", 1, \"threshold\" },"
      },
      {
        "sha": "0c2b7319677b55ed202e0887a7e9e08f611158f1",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -409,12 +409,16 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces\n \n void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n {\n+    // We increment mempool sequence value no matter removal reason\n+    // even if not directly reported below.\n+    uint64_t mempool_sequence = GetAndIncrementSequence();\n+\n     if (reason != MemPoolRemovalReason::BLOCK) {\n         // Notify clients that a transaction has been removed from the mempool\n         // for any reason except being included in a block. Clients interested\n         // in transactions included in blocks can subscribe to the BlockConnected\n         // notification.\n-        GetMainSignals().TransactionRemovedFromMempool(it->GetSharedTx(), reason);\n+        GetMainSignals().TransactionRemovedFromMempool(it->GetSharedTx(), reason, mempool_sequence);\n     }\n \n     const uint256 hash = it->GetTx().GetHash();"
      },
      {
        "sha": "f513f14af637fa2cf3b64e469c29fbf1d8331a95",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -501,6 +501,11 @@ class CTxMemPool\n     mutable uint64_t m_epoch;\n     mutable bool m_has_epoch_guard;\n \n+    // In-memory counter for external mempool tracking purposes.\n+    // This number is incremented once every time a transaction\n+    // is added or removed from the mempool for any reason.\n+    mutable uint64_t m_sequence_number{1};\n+\n     void trackPackageRemoved(const CFeeRate& rate) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     bool m_is_loaded GUARDED_BY(cs){false};\n@@ -776,6 +781,15 @@ class CTxMemPool\n         return m_unbroadcast_txids.count(txid) != 0;\n     }\n \n+    /** Guards this internal counter for external reporting */\n+    uint64_t GetAndIncrementSequence() const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+        return m_sequence_number++;\n+    }\n+\n+    uint64_t GetSequence() const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+        return m_sequence_number;\n+    }\n+\n private:\n     /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update\n      *  the descendants for a single transaction that has been added to the"
      },
      {
        "sha": "7020b59cb89c78b133c1aa2ed9953b2f1aa37947",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -1058,7 +1058,7 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n \n     if (!Finalize(args, workspace)) return false;\n \n-    GetMainSignals().TransactionAddedToMempool(ptx);\n+    GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());\n \n     return true;\n }"
      },
      {
        "sha": "1e07ff23ae8f6d162b41221c01f5eb290e1f89e2",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -199,18 +199,18 @@ void CMainSignals::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockInd\n                           fInitialDownload);\n }\n \n-void CMainSignals::TransactionAddedToMempool(const CTransactionRef& tx) {\n-    auto event = [tx, this] {\n-        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionAddedToMempool(tx); });\n+void CMainSignals::TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {\n+    auto event = [tx, mempool_sequence, this] {\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionAddedToMempool(tx, mempool_sequence); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: txid=%s wtxid=%s\", __func__,\n                           tx->GetHash().ToString(),\n                           tx->GetWitnessHash().ToString());\n }\n \n-void CMainSignals::TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason) {\n-    auto event = [tx, reason, this] {\n-        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionRemovedFromMempool(tx, reason); });\n+void CMainSignals::TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {\n+    auto event = [tx, reason, mempool_sequence, this] {\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionRemovedFromMempool(tx, reason, mempool_sequence); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: txid=%s wtxid=%s\", __func__,\n                           tx->GetHash().ToString(),"
      },
      {
        "sha": "7c3ce00fbcc2ac83bd6ba77391df0e2ede287055",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -97,7 +97,8 @@ class CValidationInterface {\n      *\n      * Called on a background thread.\n      */\n-    virtual void TransactionAddedToMempool(const CTransactionRef& tx) {}\n+    virtual void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}\n+\n     /**\n      * Notifies listeners of a transaction leaving mempool.\n      *\n@@ -130,7 +131,7 @@ class CValidationInterface {\n      *\n      * Called on a background thread.\n      */\n-    virtual void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason) {}\n+    virtual void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}\n     /**\n      * Notifies listeners of a block being connected.\n      * Provides a vector of transactions evicted from the mempool as a result.\n@@ -197,8 +198,8 @@ class CMainSignals {\n \n \n     void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *, bool fInitialDownload);\n-    void TransactionAddedToMempool(const CTransactionRef&);\n-    void TransactionRemovedFromMempool(const CTransactionRef&, MemPoolRemovalReason);\n+    void TransactionAddedToMempool(const CTransactionRef&, uint64_t mempool_sequence);\n+    void TransactionRemovedFromMempool(const CTransactionRef&, MemPoolRemovalReason, uint64_t mempool_sequence);\n     void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex);\n     void BlockDisconnected(const std::shared_ptr<const CBlock> &, const CBlockIndex* pindex);\n     void ChainStateFlushed(const CBlockLocator &);"
      },
      {
        "sha": "66857dbb39e359f5f801718baaba64a4c3841d80",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -1177,7 +1177,7 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, CWalletTx::Confirmatio\n     MarkInputsDirty(ptx);\n }\n \n-void CWallet::transactionAddedToMempool(const CTransactionRef& tx) {\n+void CWallet::transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {\n     LOCK(cs_wallet);\n     SyncTransaction(tx, {CWalletTx::Status::UNCONFIRMED, /* block height */ 0, /* block hash */ {}, /* index */ 0});\n \n@@ -1187,7 +1187,7 @@ void CWallet::transactionAddedToMempool(const CTransactionRef& tx) {\n     }\n }\n \n-void CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason) {\n+void CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {\n     LOCK(cs_wallet);\n     auto it = mapWallet.find(tx->GetHash());\n     if (it != mapWallet.end()) {\n@@ -1234,7 +1234,7 @@ void CWallet::blockConnected(const CBlock& block, int height)\n     m_last_block_processed = block_hash;\n     for (size_t index = 0; index < block.vtx.size(); index++) {\n         SyncTransaction(block.vtx[index], {CWalletTx::Status::CONFIRMED, height, block_hash, (int)index});\n-        transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK);\n+        transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);\n     }\n }\n "
      },
      {
        "sha": "f15712dd0e723994bbd227bbffcbaab2d4693f25",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -900,7 +900,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     CWalletTx* AddToWallet(CTransactionRef tx, const CWalletTx::Confirmation& confirm, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true);\n     bool LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    void transactionAddedToMempool(const CTransactionRef& tx) override;\n+    void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override;\n     void blockConnected(const CBlock& block, int height) override;\n     void blockDisconnected(const CBlock& block, int height) override;\n     void updatedBlockTip() override;\n@@ -922,7 +922,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n         uint256 last_failed_block;\n     };\n     ScanResult ScanForWalletTransactions(const uint256& start_block, int start_height, Optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate);\n-    void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason) override;\n+    void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n     void ReacceptWalletTransactions() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void ResendWalletTransactions();\n     struct Balance {"
      },
      {
        "sha": "3938f6fd2c334939c8f82ab8e0d992510b4b9a16",
        "filename": "src/zmq/zmqabstractnotifier.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqabstractnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqabstractnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqabstractnotifier.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -22,3 +22,23 @@ bool CZMQAbstractNotifier::NotifyTransaction(const CTransaction &/*transaction*/\n {\n     return true;\n }\n+\n+bool CZMQAbstractNotifier::NotifyBlockConnect(const CBlockIndex * /*CBlockIndex*/)\n+{\n+    return true;\n+}\n+\n+bool CZMQAbstractNotifier::NotifyBlockDisconnect(const CBlockIndex * /*CBlockIndex*/)\n+{\n+    return true;\n+}\n+\n+bool CZMQAbstractNotifier::NotifyTransactionAcceptance(const CTransaction &/*transaction*/, uint64_t mempool_sequence)\n+{\n+    return true;\n+}\n+\n+bool CZMQAbstractNotifier::NotifyTransactionRemoval(const CTransaction &/*transaction*/, uint64_t mempool_sequence)\n+{\n+    return true;\n+}"
      },
      {
        "sha": "dddba8d6b6ed53fbb701f37c5b3b729ae74c8ea7",
        "filename": "src/zmq/zmqabstractnotifier.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqabstractnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqabstractnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqabstractnotifier.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -44,7 +44,17 @@ class CZMQAbstractNotifier\n     virtual bool Initialize(void *pcontext) = 0;\n     virtual void Shutdown() = 0;\n \n+    // Notifies of ConnectTip result, i.e., new active tip only\n     virtual bool NotifyBlock(const CBlockIndex *pindex);\n+    // Notifies of every block connection\n+    virtual bool NotifyBlockConnect(const CBlockIndex *pindex);\n+    // Notifies of every block disconnection\n+    virtual bool NotifyBlockDisconnect(const CBlockIndex *pindex);\n+    // Notifies of every mempool acceptance\n+    virtual bool NotifyTransactionAcceptance(const CTransaction &transaction, uint64_t mempool_sequence);\n+    // Notifies of every mempool removal, except inclusion in blocks\n+    virtual bool NotifyTransactionRemoval(const CTransaction &transaction, uint64_t mempool_sequence);\n+    // Notifies of transactions added to mempool or appearing in blocks\n     virtual bool NotifyTransaction(const CTransaction &transaction);\n \n protected:"
      },
      {
        "sha": "a7e9a34269cd473b03d2b5fbf36795434b69e161",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 9,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -36,6 +36,7 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()\n     factories[\"pubhashtx\"] = CZMQAbstractNotifier::Create<CZMQPublishHashTransactionNotifier>;\n     factories[\"pubrawblock\"] = CZMQAbstractNotifier::Create<CZMQPublishRawBlockNotifier>;\n     factories[\"pubrawtx\"] = CZMQAbstractNotifier::Create<CZMQPublishRawTransactionNotifier>;\n+    factories[\"pubsequence\"] = CZMQAbstractNotifier::Create<CZMQPublishSequenceNotifier>;\n \n     std::list<std::unique_ptr<CZMQAbstractNotifier>> notifiers;\n     for (const auto& entry : factories)\n@@ -140,31 +141,53 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, co\n     });\n }\n \n-void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef& ptx)\n+void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef& ptx, uint64_t mempool_sequence)\n {\n-    // Used by BlockConnected and BlockDisconnected as well, because they're\n-    // all the same external callback.\n     const CTransaction& tx = *ptx;\n \n-    TryForEachAndRemoveFailed(notifiers, [&tx](CZMQAbstractNotifier* notifier) {\n-        return notifier->NotifyTransaction(tx);\n+    TryForEachAndRemoveFailed(notifiers, [&tx, mempool_sequence](CZMQAbstractNotifier* notifier) {\n+        return notifier->NotifyTransaction(tx) && notifier->NotifyTransactionAcceptance(tx, mempool_sequence);\n+    });\n+}\n+\n+void CZMQNotificationInterface::TransactionRemovedFromMempool(const CTransactionRef& ptx, MemPoolRemovalReason reason, uint64_t mempool_sequence)\n+{\n+    // Called for all non-block inclusion reasons\n+    const CTransaction& tx = *ptx;\n+\n+    TryForEachAndRemoveFailed(notifiers, [&tx, mempool_sequence](CZMQAbstractNotifier* notifier) {\n+        return notifier->NotifyTransactionRemoval(tx, mempool_sequence);\n     });\n }\n \n void CZMQNotificationInterface::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected)\n {\n     for (const CTransactionRef& ptx : pblock->vtx) {\n-        // Do a normal notify for each transaction added in the block\n-        TransactionAddedToMempool(ptx);\n+        const CTransaction& tx = *ptx;\n+        TryForEachAndRemoveFailed(notifiers, [&tx](CZMQAbstractNotifier* notifier) {\n+            return notifier->NotifyTransaction(tx);\n+        });\n     }\n+\n+    // Next we notify BlockConnect listeners for *all* blocks\n+    TryForEachAndRemoveFailed(notifiers, [pindexConnected](CZMQAbstractNotifier* notifier) {\n+        return notifier->NotifyBlockConnect(pindexConnected);\n+    });\n }\n \n void CZMQNotificationInterface::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexDisconnected)\n {\n     for (const CTransactionRef& ptx : pblock->vtx) {\n-        // Do a normal notify for each transaction removed in block disconnection\n-        TransactionAddedToMempool(ptx);\n+        const CTransaction& tx = *ptx;\n+        TryForEachAndRemoveFailed(notifiers, [&tx](CZMQAbstractNotifier* notifier) {\n+            return notifier->NotifyTransaction(tx);\n+        });\n     }\n+\n+    // Next we notify BlockDisconnect listeners for *all* blocks\n+    TryForEachAndRemoveFailed(notifiers, [pindexDisconnected](CZMQAbstractNotifier* notifier) {\n+        return notifier->NotifyBlockDisconnect(pindexDisconnected);\n+    });\n }\n \n CZMQNotificationInterface* g_zmq_notification_interface = nullptr;"
      },
      {
        "sha": "788a383517c40d5496050ab70e54a87544b90ee4",
        "filename": "src/zmq/zmqnotificationinterface.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqnotificationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqnotificationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -26,7 +26,8 @@ class CZMQNotificationInterface final : public CValidationInterface\n     void Shutdown();\n \n     // CValidationInterface\n-    void TransactionAddedToMempool(const CTransactionRef& tx) override;\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override;\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexDisconnected) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;"
      },
      {
        "sha": "a0e7a0a6001aac8a3e6cec39f1d8813f0e187c7e",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -26,6 +26,7 @@ static const char *MSG_HASHBLOCK = \"hashblock\";\n static const char *MSG_HASHTX    = \"hashtx\";\n static const char *MSG_RAWBLOCK  = \"rawblock\";\n static const char *MSG_RAWTX     = \"rawtx\";\n+static const char *MSG_SEQUENCE  = \"sequence\";\n \n // Internal function to send multipart message\n static int zmq_send_multipart(void *sock, const void* data, size_t size, ...)\n@@ -225,3 +226,51 @@ bool CZMQPublishRawTransactionNotifier::NotifyTransaction(const CTransaction &tr\n     ss << transaction;\n     return SendZmqMessage(MSG_RAWTX, &(*ss.begin()), ss.size());\n }\n+\n+\n+// TODO: Dedup this code to take label char, log string\n+bool CZMQPublishSequenceNotifier::NotifyBlockConnect(const CBlockIndex *pindex)\n+{\n+    uint256 hash = pindex->GetBlockHash();\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish sequence block connect %s\\n\", hash.GetHex());\n+    char data[sizeof(uint256)+1];\n+    for (unsigned int i = 0; i < sizeof(uint256); i++)\n+        data[sizeof(uint256) - 1 - i] = hash.begin()[i];\n+    data[sizeof(data) - 1] = 'C'; // Block (C)onnect\n+    return SendZmqMessage(MSG_SEQUENCE, data, sizeof(data));\n+}\n+\n+bool CZMQPublishSequenceNotifier::NotifyBlockDisconnect(const CBlockIndex *pindex)\n+{\n+    uint256 hash = pindex->GetBlockHash();\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish sequence block disconnect %s\\n\", hash.GetHex());\n+    char data[sizeof(uint256)+1];\n+    for (unsigned int i = 0; i < sizeof(uint256); i++)\n+        data[sizeof(uint256) - 1 - i] = hash.begin()[i];\n+    data[sizeof(data) - 1] = 'D'; // Block (D)isconnect\n+    return SendZmqMessage(MSG_SEQUENCE, data, sizeof(data));\n+}\n+\n+bool CZMQPublishSequenceNotifier::NotifyTransactionAcceptance(const CTransaction &transaction, uint64_t mempool_sequence)\n+{\n+    uint256 hash = transaction.GetHash();\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish hashtx mempool acceptance %s\\n\", hash.GetHex());\n+    unsigned char data[sizeof(uint256)+sizeof(mempool_sequence)+1];\n+    for (unsigned int i = 0; i < sizeof(uint256); i++)\n+        data[sizeof(uint256) - 1 - i] = hash.begin()[i];\n+    data[sizeof(uint256)] = 'A'; // Mempool (A)cceptance\n+    WriteLE64(data+sizeof(uint256)+1, mempool_sequence);\n+    return SendZmqMessage(MSG_SEQUENCE, data, sizeof(data));\n+}\n+\n+bool CZMQPublishSequenceNotifier::NotifyTransactionRemoval(const CTransaction &transaction, uint64_t mempool_sequence)\n+{\n+    uint256 hash = transaction.GetHash();\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish hashtx mempool removal %s\\n\", hash.GetHex());\n+    unsigned char data[sizeof(uint256)+sizeof(mempool_sequence)+1];\n+    for (unsigned int i = 0; i < sizeof(uint256); i++)\n+        data[sizeof(uint256) - 1 - i] = hash.begin()[i];\n+    data[sizeof(uint256)] = 'R'; // Mempool (R)emoval\n+    WriteLE64(data+sizeof(uint256)+1, mempool_sequence);\n+    return SendZmqMessage(MSG_SEQUENCE, data, sizeof(data));\n+}"
      },
      {
        "sha": "f13ed6f53763121855a07beafceee8b5d576e300",
        "filename": "src/zmq/zmqpublishnotifier.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqpublishnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9/src/zmq/zmqpublishnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.h?ref=e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "patch": "@@ -52,4 +52,13 @@ class CZMQPublishRawTransactionNotifier : public CZMQAbstractPublishNotifier\n     bool NotifyTransaction(const CTransaction &transaction) override;\n };\n \n+class CZMQPublishSequenceNotifier : public CZMQAbstractPublishNotifier\n+{\n+public:\n+    bool NotifyBlockConnect(const CBlockIndex *pindex) override;\n+    bool NotifyBlockDisconnect(const CBlockIndex *pindex) override;\n+    bool NotifyTransactionAcceptance(const CTransaction &transaction, uint64_t mempool_sequence) override;\n+    bool NotifyTransactionRemoval(const CTransaction &transaction, uint64_t mempool_sequence) override;\n+};\n+\n #endif // BITCOIN_ZMQ_ZMQPUBLISHNOTIFIER_H"
      }
    ]
  },
  {
    "sha": "68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OGMzYzdlMWJkZDAwYmJlN2Q3MDU5MmE4ZWIzOTUyMGZhM2Y4N2Yx",
    "commit": {
      "author": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-04T15:55:25Z"
      },
      "committer": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-22T15:34:30Z"
      },
      "message": "Add functional tests for zmq sequence topic and mempool sequence logic",
      "tree": {
        "sha": "160357cec20ac90b83c2551ee7d29982ab08c6f7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/160357cec20ac90b83c2551ee7d29982ab08c6f7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e76fc2b84d065c9d06010d0a10b316f1f9d36fb9"
      }
    ],
    "stats": {
      "total": 314,
      "additions": 308,
      "deletions": 6
    },
    "files": [
      {
        "sha": "17032a3b83b03af9c47729a3d4c3b65cfc28cc98",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 308,
        "deletions": 6,
        "changes": 314,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
        "patch": "@@ -6,12 +6,23 @@\n import struct\n \n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE, ADDRESS_BCRT1_P2WSH_OP_TRUE\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.messages import CTransaction, hash256\n-from test_framework.util import assert_equal, connect_nodes\n+from test_framework.messages import CTransaction, hash256, FromHex\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    assert_raises_rpc_error,\n+)\n from io import BytesIO\n from time import sleep\n \n+# Test may be skipped and not have zmq installed\n+try:\n+    import zmq\n+except ImportError:\n+    pass\n+\n def hash256_reversed(byte_str):\n     return hash256(byte_str)[::-1]\n \n@@ -21,7 +32,6 @@ def __init__(self, socket, topic):\n         self.socket = socket\n         self.topic = topic\n \n-        import zmq\n         self.socket.setsockopt(zmq.SUBSCRIBE, self.topic)\n \n     def receive(self):\n@@ -33,6 +43,22 @@ def receive(self):\n         self.sequence += 1\n         return body\n \n+    def receive_sequence(self):\n+        topic, body, seq = self.socket.recv_multipart()\n+        # Topic should match the subscriber topic.\n+        assert_equal(topic, self.topic)\n+        # Sequence should be incremental.\n+        assert_equal(struct.unpack('<I', seq)[-1], self.sequence)\n+        self.sequence += 1\n+        hash = body[:32].hex()\n+        label = chr(body[32])\n+        mempool_sequence = None if len(body) != 32+1+8 else struct.unpack(\"<Q\", body[32+1:])[0]\n+        if mempool_sequence is not None:\n+            assert label == \"A\" or label == \"R\"\n+        else:\n+            assert label == \"D\" or label == \"C\"\n+        return (hash, label, mempool_sequence)\n+\n \n class ZMQTest (BitcoinTestFramework):\n     def set_test_params(self):\n@@ -43,18 +69,18 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_bitcoind_zmq()\n \n     def run_test(self):\n-        import zmq\n         self.ctx = zmq.Context()\n         try:\n             self.test_basic()\n+            self.test_sequence()\n+            self.test_mempool_sync()\n             self.test_reorg()\n         finally:\n             # Destroy the ZMQ context.\n             self.log.debug(\"Destroying ZMQ context\")\n             self.ctx.destroy(linger=None)\n \n     def test_basic(self):\n-        import zmq\n \n         # Invalid zmq arguments don't take down the node, see #17185.\n         self.restart_node(0, [\"-zmqpubrawtx=foo\", \"-zmqpubhashtx=bar\"])\n@@ -146,7 +172,6 @@ def test_reorg(self):\n             self.log.info(\"Skipping reorg test because wallet is disabled\")\n             return\n \n-        import zmq\n         address = 'tcp://127.0.0.1:28333'\n \n         services = [b\"hashblock\", b\"hashtx\"]\n@@ -204,5 +229,282 @@ def test_reorg(self):\n         # And the current tip\n         assert_equal(hashtx.receive().hex(), self.nodes[1].getblock(connect_blocks[0])[\"tx\"][0])\n \n+    def test_sequence(self):\n+        \"\"\"\n+        Sequence zmq notifications give every blockhash and txhash in order\n+        of processing, regardless of IBD, re-orgs, etc.\n+        Format of messages:\n+        <32-byte hash>C :                 Blockhash connected\n+        <32-byte hash>D :                 Blockhash disconnected\n+        <32-byte hash>R<8-byte LE uint> : Transactionhash removed from mempool for non-block inclusion reason\n+        <32-byte hash>A<8-byte LE uint> : Transactionhash added mempool\n+        \"\"\"\n+        self.log.info(\"Testing 'sequence' publisher\")\n+        address = 'tcp://127.0.0.1:28333'\n+        socket = self.ctx.socket(zmq.SUB)\n+        socket.set(zmq.RCVTIMEO, 60000)\n+        seq = ZMQSubscriber(socket, b'sequence')\n+\n+        self.restart_node(0, ['-zmqpub%s=%s' % (seq.topic.decode(), address)])\n+        socket.connect(address)\n+        # Relax so that the subscriber is ready before publishing zmq messages\n+        sleep(0.2)\n+\n+        # Mempool sequence number starts at 1\n+        seq_num = 1\n+\n+        # Generate 1 block in nodes[0] and receive all notifications\n+        dc_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+\n+        # Note: We are not notified of any block transactions, coinbase or mined\n+        assert_equal((self.nodes[0].getbestblockhash(), \"C\", None), seq.receive_sequence())\n+\n+        # Generate 2 blocks in nodes[1] to a different address to ensure a chain split\n+        self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+\n+        # nodes[0] will reorg chain after connecting back nodes[1]\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # Then we receive all block (dis)connect notifications for the 2 block reorg\n+        assert_equal((dc_block, \"D\", None), seq.receive_sequence())\n+        block_count = self.nodes[1].getblockcount()\n+        assert_equal((self.nodes[1].getblockhash(block_count-1), \"C\", None), seq.receive_sequence())\n+        assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n+\n+        # Rest of test requires wallet functionality\n+        if self.is_wallet_compiled():\n+            self.log.info(\"Wait for tx from second node\")\n+            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n+            self.sync_all()\n+            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+            # Should receive the broadcasted txid.\n+            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n+            seq_num += 1\n+\n+            self.log.info(\"Testing RBF notification\")\n+            # Replace it to test eviction/addition notification\n+            rbf_info = self.nodes[1].bumpfee(payment_txid)\n+            self.sync_all()\n+            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n+            seq_num += 1\n+            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n+            seq_num += 1\n+\n+            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+            # though the mempool sequence number does go up by the number of transactions\n+            # removed from the mempool by the block mining it.\n+            mempool_size = len(self.nodes[0].getrawmempool())\n+            c_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            self.sync_all()\n+            # Make sure the number of mined transactions matches the number of txs out of mempool\n+            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+            seq_num += mempool_size_delta\n+            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n+            self.sync_all()\n+            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+            seq_num += 1\n+\n+            # Spot check getrawmempool results that they only show up when asked for\n+            assert type(self.nodes[0].getrawmempool()) is list\n+            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+            self.log.info(\"Testing reorg notifications\")\n+            # Manually invalidate the last block to test mempool re-entry\n+            # N.B. This part could be made more lenient in exact ordering\n+            # since it greatly depends on inner-workings of blocks/mempool\n+            # during \"deep\" re-orgs. Probably should \"re-construct\"\n+            # blockchain/mempool state from notifications instead.\n+            block_count = self.nodes[0].getblockcount()\n+            best_hash = self.nodes[0].getbestblockhash()\n+            self.nodes[0].invalidateblock(best_hash)\n+            sleep(2) # Bit of room to make sure transaction things happened\n+\n+            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+            # of the time they were gathered.\n+            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n+            seq_num += 1\n+\n+            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+            self.nodes[0].reconsiderblock(best_hash)\n+            self.nodes[1].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.sync_all()\n+\n+            self.log.info(\"Evict mempool transaction by block conflict\")\n+            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n+\n+            # More to be simply mined\n+            more_tx = []\n+            for _ in range(5):\n+                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n+\n+            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n+            bump_info = self.nodes[0].bumpfee(orig_txid)\n+            # Mine the pre-bump tx\n+            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1))\n+            tx = FromHex(CTransaction(), raw_tx)\n+            block.vtx.append(tx)\n+            for txid in more_tx:\n+                tx = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+                block.vtx.append(tx)\n+            add_witness_commitment(block)\n+            block.solve()\n+            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+            tip = self.nodes[0].getbestblockhash()\n+            assert_equal(int(tip, 16), block.sha256)\n+            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n+\n+            # Flush old notifications until evicted tx original entry\n+            (hash_str, label, mempool_seq) = seq.receive_sequence()\n+            while hash_str != orig_txid:\n+                (hash_str, label, mempool_seq) = seq.receive_sequence()\n+            mempool_seq += 1\n+\n+            # Added original tx\n+            assert_equal(label, \"A\")\n+            # More transactions to be simply mined\n+            for i in range(len(more_tx)):\n+                    assert_equal((more_tx[i], \"A\", mempool_seq), seq.receive_sequence())\n+                    mempool_seq += 1\n+            # Bumped by rbf\n+            assert_equal((orig_txid, \"R\", mempool_seq), seq.receive_sequence())\n+            mempool_seq += 1\n+            assert_equal((bump_info[\"txid\"], \"A\", mempool_seq), seq.receive_sequence())\n+            mempool_seq += 1\n+            # Conflict announced first, then block\n+            assert_equal((bump_info[\"txid\"], \"R\", mempool_seq), seq.receive_sequence())\n+            mempool_seq += 1\n+            assert_equal((tip, \"C\", None), seq.receive_sequence())\n+            mempool_seq += len(more_tx)\n+            # Last tx\n+            assert_equal((orig_txid_2, \"A\", mempool_seq), seq.receive_sequence())\n+            mempool_seq += 1\n+            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.sync_all() # want to make sure we didn't break \"consensus\" for other tests\n+\n+    def test_mempool_sync(self):\n+        \"\"\"\n+        Use sequence notification plus getrawmempool sequence results to \"sync mempool\"\n+        \"\"\"\n+        if not self.is_wallet_compiled():\n+            self.log.info(\"Skipping mempool sync test\")\n+            return\n+\n+        self.log.info(\"Testing 'mempool sync' usage of sequence notifier\")\n+        address = 'tcp://127.0.0.1:28333'\n+        socket = self.ctx.socket(zmq.SUB)\n+        socket.set(zmq.RCVTIMEO, 60000)\n+        seq = ZMQSubscriber(socket, b'sequence')\n+\n+        self.restart_node(0, ['-zmqpub%s=%s' % (seq.topic.decode(), address)])\n+        connect_nodes(self.nodes[0], 1)\n+        socket.connect(address)\n+        # Relax so that the subscriber is ready before publishing zmq messages\n+        sleep(0.2)\n+\n+        # In-memory counter, should always start at 1\n+        next_mempool_seq = self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"]\n+        assert_equal(next_mempool_seq, 1)\n+\n+        # Some transactions have been happening but we aren't consuming zmq notifications yet\n+        # or we lost a ZMQ message somehow and want to start over\n+        txids = []\n+        num_txs = 5\n+        for _ in range(num_txs):\n+            txids.append(self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True))\n+        self.sync_all()\n+\n+        # 1) Consume backlog until we get a mempool sequence number\n+        (hash_str, label, zmq_mem_seq) = seq.receive_sequence()\n+        while zmq_mem_seq is None:\n+                (hash_str, label, zmq_mem_seq) = seq.receive_sequence()\n+\n+        assert label == \"A\" or label == \"R\"\n+        assert hash_str is not None\n+\n+        # 2) We need to \"seed\" our view of the mempool\n+        mempool_snapshot = self.nodes[0].getrawmempool(mempool_sequence=True)\n+        mempool_view = set(mempool_snapshot[\"txids\"])\n+        get_raw_seq = mempool_snapshot[\"mempool_sequence\"]\n+        assert_equal(get_raw_seq, 6)\n+        # Snapshot may be too old compared to zmq message we read off latest\n+        while zmq_mem_seq >= get_raw_seq:\n+            sleep(2)\n+            mempool_snapshot = self.nodes[0].getrawmempool(mempool_sequence=True)\n+            mempool_view = set(mempool_snapshot[\"txids\"])\n+            get_raw_seq = mempool_snapshot[\"mempool_sequence\"]\n+\n+        # Things continue to happen in the \"interim\" while waiting for snapshot results\n+        # We have node 0 do all these to avoid p2p races with RBF announcements\n+        for _ in range(num_txs):\n+            txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n+        self.nodes[0].bumpfee(txids[-1])\n+        self.sync_all()\n+        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        final_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True)\n+\n+        # 3) Consume ZMQ backlog until we get to \"now\" for the mempool snapshot\n+        while True:\n+            if zmq_mem_seq == get_raw_seq - 1:\n+                break\n+            (hash_str, label, mempool_sequence) = seq.receive_sequence()\n+            if mempool_sequence is not None:\n+                zmq_mem_seq = mempool_sequence\n+                if zmq_mem_seq > get_raw_seq:\n+                    raise Exception(\"We somehow jumped mempool sequence numbers! zmq_mem_seq: {} > get_raw_seq: {}\".format(zmq_mem_seq, get_raw_seq))\n+\n+        # 4) Moving forward, we apply the delta to our local view\n+        #    remaining txs(5) + 1 rbf(A+R) + 1 block connect + 1 final tx\n+        expected_sequence = get_raw_seq\n+        r_gap = 0\n+        for _ in range(num_txs + 2 + 1 + 1):\n+            (hash_str, label, mempool_sequence) = seq.receive_sequence()\n+            if mempool_sequence is not None:\n+                if mempool_sequence != expected_sequence:\n+                    # Detected \"R\" gap, means this a conflict eviction, and mempool tx are being evicted before its\n+                    # position in the incoming block message \"C\"\n+                    if label == \"R\":\n+                        assert mempool_sequence > expected_sequence\n+                        r_gap += mempool_sequence - expected_sequence\n+                    else:\n+                        raise Exception(\"WARNING: txhash has unexpected mempool sequence value: {} vs expected {}\".format(mempool_sequence, expected_sequence))\n+            if label == \"A\":\n+                assert hash_str not in mempool_view\n+                mempool_view.add(hash_str)\n+                expected_sequence = mempool_sequence + 1\n+            elif label == \"R\":\n+                assert hash_str in mempool_view\n+                mempool_view.remove(hash_str)\n+                expected_sequence = mempool_sequence + 1\n+            elif label == \"C\":\n+                # (Attempt to) remove all txids from known block connects\n+                block_txids = self.nodes[0].getblock(hash_str)[\"tx\"][1:]\n+                for txid in block_txids:\n+                    if txid in mempool_view:\n+                        expected_sequence += 1\n+                        mempool_view.remove(txid)\n+                expected_sequence -= r_gap\n+                r_gap = 0\n+            elif label == \"D\":\n+                # Not useful for mempool tracking per se\n+                continue\n+            else:\n+                raise Exception(\"Unexpected ZMQ sequence label!\")\n+\n+        assert_equal(self.nodes[0].getrawmempool(), [final_txid])\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], expected_sequence)\n+\n+        # 5) If you miss a zmq/mempool sequence number, go back to step (2)\n+\n+        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n if __name__ == '__main__':\n     ZMQTest().main()"
      }
    ]
  },
  {
    "sha": "759d94e70f6844443106404882c7b105f3a4dba7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NTlkOTRlNzBmNjg0NDQ0MzEwNjQwNDg4MmM3YjEwNWYzYTRkYmE3",
    "commit": {
      "author": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-01T19:14:58Z"
      },
      "committer": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2020-09-22T15:34:30Z"
      },
      "message": "Update zmq notification documentation and sample consumer",
      "tree": {
        "sha": "21d8c98214a1e6e24c86f42fbe6d1ef8b59d634e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/21d8c98214a1e6e24c86f42fbe6d1ef8b59d634e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/759d94e70f6844443106404882c7b105f3a4dba7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/759d94e70f6844443106404882c7b105f3a4dba7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/759d94e70f6844443106404882c7b105f3a4dba7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/759d94e70f6844443106404882c7b105f3a4dba7/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/68c3c7e1bdd00bbe7d70592a8eb39520fa3f87f1"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 35,
      "deletions": 13
    },
    "files": [
      {
        "sha": "8b8503331d2c23abc9514f204bab1771de39b179",
        "filename": "contrib/zmq/zmq_sub.py",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/759d94e70f6844443106404882c7b105f3a4dba7/contrib/zmq/zmq_sub.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/759d94e70f6844443106404882c7b105f3a4dba7/contrib/zmq/zmq_sub.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.py?ref=759d94e70f6844443106404882c7b105f3a4dba7",
        "patch": "@@ -11,7 +11,8 @@\n                 -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n                 -zmqpubrawblock=tcp://127.0.0.1:28332 \\\n                 -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n-                -zmqpubhashblock=tcp://127.0.0.1:28332\n+                -zmqpubhashblock=tcp://127.0.0.1:28332 \\\n+                -zmqpubsequence=tcp://127.0.0.1:28332\n \n     We use the asyncio library here.  `self.handle()` installs itself as a\n     future at the end of the function.  Since it never returns with the event\n@@ -47,16 +48,14 @@ def __init__(self):\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")\n         self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtx\")\n+        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"sequence\")\n         self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n \n     async def handle(self) :\n-        msg = await self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        body = msg[1]\n+        topic, body, seq = await self.zmqSubSocket.recv_multipart()\n         sequence = \"Unknown\"\n-        if len(msg[-1]) == 4:\n-          msgSequence = struct.unpack('<I', msg[-1])[-1]\n-          sequence = str(msgSequence)\n+        if len(seq) == 4:\n+            sequence = str(struct.unpack('<I', seq)[-1])\n         if topic == b\"hashblock\":\n             print('- HASH BLOCK ('+sequence+') -')\n             print(binascii.hexlify(body))\n@@ -69,6 +68,12 @@ async def handle(self) :\n         elif topic == b\"rawtx\":\n             print('- RAW TX ('+sequence+') -')\n             print(binascii.hexlify(body))\n+        elif topic == b\"sequence\":\n+            hash = binascii.hexlify(body[:32])\n+            label = chr(body[32])\n+            mempool_sequence = None if len(body) != 32+1+8 else struct.unpack(\"<Q\", body[32+1:])[0]\n+            print('- SEQUENCE ('+sequence+') -')\n+            print(hash, label, mempool_sequence)\n         # schedule ourselves to receive the next message\n         asyncio.ensure_future(self.handle())\n "
      },
      {
        "sha": "f003c90d3a7f7ac59936d42b994aa303e7f1c59e",
        "filename": "doc/zmq.md",
        "status": "modified",
        "additions": 23,
        "deletions": 6,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/759d94e70f6844443106404882c7b105f3a4dba7/doc/zmq.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/759d94e70f6844443106404882c7b105f3a4dba7/doc/zmq.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/zmq.md?ref=759d94e70f6844443106404882c7b105f3a4dba7",
        "patch": "@@ -63,6 +63,7 @@ Currently, the following notifications are supported:\n     -zmqpubhashblock=address\n     -zmqpubrawblock=address\n     -zmqpubrawtx=address\n+    -zmqpubsequence=address\n \n The socket type is PUB and the address must be a valid ZeroMQ socket\n address. The same address can be used in more than one notification.\n@@ -74,6 +75,7 @@ The option to set the PUB socket's outbound message high water mark\n     -zmqpubhashblockhwm=n\n     -zmqpubrawblockhwm=n\n     -zmqpubrawtxhwm=n\n+    -zmqpubsequencehwm=address\n \n The high water mark value must be an integer greater than or equal to 0.\n \n@@ -87,7 +89,15 @@ Each PUB notification has a topic and body, where the header\n corresponds to the notification type. For instance, for the\n notification `-zmqpubhashtx` the topic is `hashtx` (no null\n terminator) and the body is the transaction hash (32\n-bytes).\n+bytes) for all but `sequence` topic. For `sequence`, the body\n+is structured as the following based on the type of message:\n+\n+    <32-byte hash>C :                 Blockhash connected\n+    <32-byte hash>D :                 Blockhash disconnected\n+    <32-byte hash>R<8-byte LE uint> : Transactionhash removed from mempool for non-block inclusion reason\n+    <32-byte hash>A<8-byte LE uint> : Transactionhash added mempool\n+\n+Where the 8-byte uints correspond to the mempool sequence number.\n \n These options can also be provided in bitcoin.conf.\n \n@@ -124,13 +134,20 @@ No authentication or authorization is done on connecting clients; it\n is assumed that the ZeroMQ port is exposed only to trusted entities,\n using other means such as firewalling.\n \n-Note that when the block chain tip changes, a reorganisation may occur\n-and just the tip will be notified. It is up to the subscriber to\n-retrieve the chain from the last known block to the new tip. Also note\n-that no notification occurs if the tip was in the active chain - this\n-is the case after calling invalidateblock RPC.\n+Note that for `*block` topics, when the block chain tip changes,\n+a reorganisation may occur and just the tip will be notified.\n+It is up to the subscriber to retrieve the chain from the last known\n+block to the new tip. Also note that no notification will occur if the tip\n+was in the active chain--as would be the case after calling invalidateblock RPC.\n+In contrast, the `sequence` topic publishes all block connections and\n+disconnections.\n \n There are several possibilities that ZMQ notification can get lost\n during transmission depending on the communication type you are\n using. Bitcoind appends an up-counting sequence number to each\n notification which allows listeners to detect lost notifications.\n+\n+The `sequence` topic refers specifically to the mempool sequence\n+number, which is also published along with all mempool events. This\n+is a different sequence value than in ZMQ itself in order to allow a total\n+ordering of mempool events to be constructed."
      }
    ]
  }
]