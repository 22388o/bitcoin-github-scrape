[
  {
    "sha": "9ebc927e0efc641960510ee84745d31bfaf75ff2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZWJjOTI3ZTBlZmM2NDE5NjA1MTBlZTg0NzQ1ZDMxYmZhZjc1ZmYy",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-03-29T21:48:20Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-05-03T04:09:54Z"
      },
      "message": "[POC] build: Integrate rust-cuckoofilter library\n\nIntegrates a slightly modified version of https://github.com/axiomhq/rust-cuckoofilter,\nso that headers are generated for use from our C++ code. You can see the\nmodifications in my fork: https://github.com/fanquake/rust-cuckoofilter.\n\nThis leverages existing work from Cory & Jeremy.\n\nCo-Authored-By: Jeremy Rubin <j@rubin.io>\nCo-Authored-By: Cory Fields <cory-nospam-@coryfields.com>",
      "tree": {
        "sha": "7409a2a644768c9b558531dc46cd235c5d0b88fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7409a2a644768c9b558531dc46cd235c5d0b88fb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ebc927e0efc641960510ee84745d31bfaf75ff2",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmCPd5QACgkQLuufXMCV\nJsEdcQ//VnsXzOBDPAc4ipSa3SYPA/n07G5vMy+KhZt6RIG7P2eqnasxnGLFfqgD\nd0ovZH9zh5ySD1DhoUAsqa8euGdGIf6LA01X7EyiTJUlDrA7zpYkNUG7jrbBexNO\n7Cxp4W2i7ditfe+7+UpDLJ0VXC4wo9Cg4G3QQk/QbjJSlvyfnm3s0bTARw/TpDsJ\nJRvO95zqq8+hIaoHi90CgTOUzLsVIP2VYh2n8gFzsvqEb4J+gNwtqUUwdytQLSe2\nU90KxV5dp1onoQBZqu3BOT1HMD6AWZpsHmLN/EA69GFchw+EI62GKTQlXljkOVJp\n6Avgz7vGFTwVjm1AFz9o3jXyZUTRbvZyE9ERdsUCmQBDE4m8v8lT4QZxD1XPdtB7\nisUoLyZ5T4sJKYxCiUvrSk3wzmAEVBWxUYNNmlVF9WcCem8Kr1QIzX5Zt0VHBhbc\nnjS3L9R0ff6ERe0a6cKdOfq3XRSsX2ATQsC/DhmcMssOKiBoGuUK1t2YiYix/RPz\njKXwpRo3c/4IBaDd0d85OAsl/Q5DvElw66azRBH4JgaL4TLXDusYNMXrncVQpxp8\n4t12l/WW1R4oX5aoNnRVLn2krTlY8IPKBvn9PHo4wiXgUL7Aec40EBa/tieuAr68\nifUPXoOF1mXo17kGNeOrhuEiNeXgo8ZBC6/WsL+BKIqIg9mywCg=\n=UZnG\n-----END PGP SIGNATURE-----",
        "payload": "tree 7409a2a644768c9b558531dc46cd235c5d0b88fb\nparent 2448457cca1858c2fcf3dfcb53de3f388ea72079\nauthor fanquake <fanquake@gmail.com> 1553896100 -0700\ncommitter fanquake <fanquake@gmail.com> 1620014994 +0800\n\n[POC] build: Integrate rust-cuckoofilter library\n\nIntegrates a slightly modified version of https://github.com/axiomhq/rust-cuckoofilter,\nso that headers are generated for use from our C++ code. You can see the\nmodifications in my fork: https://github.com/fanquake/rust-cuckoofilter.\n\nThis leverages existing work from Cory & Jeremy.\n\nCo-Authored-By: Jeremy Rubin <j@rubin.io>\nCo-Authored-By: Cory Fields <cory-nospam-@coryfields.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ebc927e0efc641960510ee84745d31bfaf75ff2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ebc927e0efc641960510ee84745d31bfaf75ff2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ebc927e0efc641960510ee84745d31bfaf75ff2/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2448457cca1858c2fcf3dfcb53de3f388ea72079",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2448457cca1858c2fcf3dfcb53de3f388ea72079",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2448457cca1858c2fcf3dfcb53de3f388ea72079"
      }
    ],
    "stats": {
      "total": 1290,
      "additions": 1282,
      "deletions": 8
    },
    "files": [
      {
        "sha": "a5dbc7d6b20d0d20752ca2f21534ca69a38cf4c1",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -151,3 +151,5 @@ dist/\n *.background.tiff\n \n /guix-build-*\n+\n+src/rusty/out"
      },
      {
        "sha": "e8fff10985e42af135097333e4a2d60a2d7ee137",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -264,6 +264,12 @@ AC_ARG_ENABLE([asm],\n   [use_asm=$enableval],\n   [use_asm=yes])\n \n+AC_ARG_ENABLE([experimental-rust],\n+  [AS_HELP_STRING([--enable-experimental-rust],\n+  [Enable experimental rust code (default is no)])],\n+  [use_rust=$enableval],\n+  [use_rust=no])\n+\n if test \"x$use_asm\" = xyes; then\n   AC_DEFINE(USE_ASM, 1, [Define this symbol to build in assembly routines])\n fi\n@@ -637,6 +643,24 @@ AC_ARG_WITH([daemon],\n   [build_bitcoind=$withval],\n   [build_bitcoind=yes])\n \n+if test \"x$use_rust\" = xyes; then\n+  AC_PATH_PROG(CARGO,cargo)\n+  if test x$CARGO = xnone; then\n+    use_rust=no\n+    AC_MSG_ERROR(\"Cargo required to enable experimental rust support.\")\n+  fi\n+\n+  case $host in\n+    ${host_cpu}-w64-mingw*) RUST_TARGET=${host_cpu}-pc-windows-gnu ;;\n+    ${host_cpu}-pc-linux*) RUST_TARGET=\"${host_cpu}-unknown-${host_os}\" ;;\n+    ${host_cpu}-apple-darwin*) RUST_TARGET=${host_cpu}-apple-darwin ;;\n+    *) RUST_TARGET=\"${host}\" ;;\n+  esac\n+\n+  dnl TODO: create a rust test project and check host_alias as well as host.\n+  AC_DEFINE(ENABLE_RUSTY, [true], [Use Rusty])\n+fi\n+\n case $host in\n   *mingw*)\n      TARGET_OS=windows\n@@ -654,6 +678,7 @@ case $host in\n      AC_CHECK_LIB([ws2_32],   [WSAStartup],, AC_MSG_ERROR(libws2_32 missing))\n      AC_CHECK_LIB([shlwapi],  [PathRemoveFileSpecW],, AC_MSG_ERROR(libshlwapi missing))\n      AC_CHECK_LIB([iphlpapi], [GetAdaptersAddresses],, AC_MSG_ERROR(libiphlpapi missing))\n+     AC_CHECK_LIB([userenv],      [main],, AC_MSG_ERROR(libuserenv missing))\n \n      dnl -static is interpreted by libtool, where it has a different meaning.\n      dnl In libtool-speak, it's -all-static.\n@@ -762,6 +787,14 @@ case $host in\n      ;;\n esac\n \n+dnl Find the additional lib (if any) responsible for handling\n+dnl dlopen/dlsym/etc.\n+TEMP_LIBS=\"$LIBS\"\n+LIBS=\n+AC_SEARCH_LIBS([dlsym],[dl])\n+DL_LIBS=\"$LIBS\"\n+LIBS=\"$TEMP_LIBS\"\n+\n if test x$use_extended_functional_tests != xno; then\n   AC_SUBST(EXTENDED_FUNCTIONAL_TESTS, --extended)\n fi\n@@ -1806,6 +1839,7 @@ AM_CONDITIONAL([USE_ASM],[test x$use_asm = xyes])\n AM_CONDITIONAL([WORDS_BIGENDIAN],[test x$ac_cv_c_bigendian = xyes])\n AM_CONDITIONAL([USE_NATPMP],[test x$use_natpmp = xyes])\n AM_CONDITIONAL([USE_UPNP],[test x$use_upnp = xyes])\n+AM_CONDITIONAL([ENABLE_RUSTY], [test x$use_rust = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1880,6 +1914,8 @@ AC_SUBST(HAVE_MM_PREFETCH)\n AC_SUBST(HAVE_STRONG_GETAUXVAL)\n AC_SUBST(HAVE_WEAK_GETAUXVAL)\n AC_SUBST(ANDROID_ARCH)\n+AC_SUBST(RUST_TARGET)\n+AC_SUBST(DL_LIBS)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])\n@@ -1963,6 +1999,7 @@ echo \"  sanitizers      = $use_sanitizers\"\n echo \"  debug enabled   = $enable_debug\"\n echo \"  gprof enabled   = $enable_gprof\"\n echo \"  werror          = $enable_werror\"\n+echo \"  rust enabled    = $use_rust\"\n echo\n echo \"  target os       = $TARGET_OS\"\n echo \"  build os        = $build_os\""
      },
      {
        "sha": "e7a2bfdb2c4b2420e139ae6ab2b4d1c523cbbb46",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 40,
        "deletions": 3,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -14,6 +14,8 @@ AM_CPPFLAGS = $(DEBUG_CPPFLAGS) $(HARDENED_CPPFLAGS)\n AM_LIBTOOLFLAGS = --preserve-dup-deps\n PTHREAD_FLAGS = $(PTHREAD_CFLAGS) $(PTHREAD_LIBS)\n EXTRA_LIBRARIES =\n+CLEANFILES =\n+LIBBITCOIN_RUST_LIBS =\n \n if EMBEDDED_UNIVALUE\n LIBUNIVALUE = univalue/libunivalue.la\n@@ -37,6 +39,9 @@ LIBBITCOIN_CRYPTO_BASE=crypto/libbitcoin_crypto_base.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n \n+if ENABLE_RUSTY\n+LIBBITCOIN_RUSTY = rusty/out/release/libcuckoofilter_cabi.a\n+endif\n if ENABLE_ZMQ\n LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n endif\n@@ -642,7 +647,7 @@ bitcoin_bin_ldadd = \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-bitcoin_bin_ldadd += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(SQLITE_LIBS)\n+bitcoin_bin_ldadd += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(SQLITE_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n \n bitcoind_SOURCES = $(bitcoin_daemon_sources) init/bitcoind.cpp\n bitcoind_CPPFLAGS = $(bitcoin_bin_cppflags)\n@@ -752,7 +757,37 @@ CTAES_DIST += crypto/ctaes/ctaes.h\n CTAES_DIST += crypto/ctaes/README.md\n CTAES_DIST += crypto/ctaes/test.c\n \n-CLEANFILES = $(EXTRA_LIBRARIES)\n+RUSTY_DIST =\n+\n+if ENABLE_RUSTY\n+RUSTY_H = rusty/out/rcf_cuckoofilter.h\n+LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY)\n+\n+$(RUSTY_H): | $(LIBBITCOIN_RUSTY)\n+$(libbitcoin_server_a_OBJECTS) : $(RUSTY_H)\n+\n+# TODO: Teach Cargo how to accept a target filename and upstream\n+# See https://github.com/rust-lang/rust/issues/43749\n+# Just move it as a temporary hack.\n+$(LIBBITCOIN_RUSTY): $(RUSTY_DIST)\n+\t$(AM_V_at)$(MKDIR_P) rusty/out\n+\t+$(AM_V_at)cd $(srcdir)/rusty/cuckoofilter/cabi && HEADER_FILE_OVERRIDE=$(abs_builddir)/$(RUSTY_H) $(CARGO) build --release --target=$(RUST_TARGET) --target-dir=$(abs_builddir)/rusty/out\n+if TARGET_WINDOWS\n+\tmv rusty/out/$(RUST_TARGET)/release/libcuckoofilter_cabi.lib $@\n+else\n+\tmv rusty/out/$(RUST_TARGET)/release/libcuckoofilter_cabi.a $@\n+endif\n+\n+RUSTY_CHECK=rusty-check\n+$(RUSTY_CHECK):\n+\tcd $(srcdir)/rusty/cuckoofilter && HEADER_FILE_OVERRIDE=/dev/null $(CARGO) test --release --target=$(RUST_TARGET) --target-dir=$(abs_builddir)/rusty/out\n+\n+CLEANFILES += $(LIBBITCOIN_RUSTY)\n+CLEANFILES += $(RUSTY_H)\n+\n+endif\n+\n+CLEANFILES += $(EXTRA_LIBRARIES)\n \n CLEANFILES += *.gcda *.gcno\n CLEANFILES += compat/*.gcda compat/*.gcno\n@@ -774,7 +809,7 @@ CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n CLEANFILES += zmq/*.gcda zmq/*.gcno\n CLEANFILES += obj/build.h\n \n-EXTRA_DIST = $(CTAES_DIST)\n+EXTRA_DIST = $(CTAES_DIST) $(RUSTY_DIST)\n \n \n config/bitcoin-config.h: config/stamp-h1\n@@ -787,6 +822,8 @@ $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n \t-$(MAKE) -C univalue clean\n+\t-rm -rf rusty/release\n+\t-rm -rf rusty/$(RUST_TARGET)\n \t-rm -f leveldb/*/*.gcda leveldb/*/*.gcno leveldb/helpers/memenv/*.gcda leveldb/helpers/memenv/*.gcno\n \t-rm -f config.h\n \t-rm -rf test/__pycache__"
      },
      {
        "sha": "0b0de308d0e9e3437fbf7d2c9ee5ffc22349005d",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -74,7 +74,7 @@ bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n bench_bench_bitcoin_SOURCES += bench/wallet_balance.cpp\n endif\n \n-bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(SQLITE_LIBS)\n+bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(SQLITE_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n \n CLEAN_BITCOIN_BENCH = bench/*.gcda bench/*.gcno $(GENERATED_BENCH_FILES)"
      },
      {
        "sha": "7309161ea84b44c3bad4d11d3c015b13b48dad77",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -329,7 +329,7 @@ bitcoin_qt_ldadd += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n bitcoin_qt_ldadd += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n bitcoin_qt_ldflags = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n bitcoin_qt_libtoolflags = $(AM_LIBTOOLFLAGS) --tag CXX\n "
      },
      {
        "sha": "cce60811f2f681cd88cd71848650aca283a8b083",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -53,7 +53,7 @@ endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n qt_test_test_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n "
      },
      {
        "sha": "a123317c0acc36d76aa40ea6e09ebf9b71bd2dc1",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -60,6 +60,10 @@ if USE_NATPMP\n FUZZ_SUITE_LD_COMMON += $(NATPMP_LIBS)\n endif\n \n+if ENABLE_RUSTY\n+FUZZ_SUITE_LD_COMMON += $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n+endif\n+\n # test_bitcoin binary #\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n@@ -186,7 +190,7 @@ test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_C\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n-test_test_bitcoin_LDADD += $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(SQLITE_LIBS)\n+test_test_bitcoin_LDADD += $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(SQLITE_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS) -static\n \n if ENABLE_ZMQ\n@@ -331,7 +335,7 @@ bitcoin_test_check: $(TEST_BINARY) FORCE\n bitcoin_test_clean : FORCE\n \trm -f $(CLEAN_BITCOIN_TEST) $(test_test_bitcoin_OBJECTS) $(TEST_BINARY)\n \n-check-local: $(BITCOIN_TESTS:.cpp=.cpp.test)\n+check-local: $(RUST_CHECK) $(BITCOIN_TESTS:.cpp=.cpp.test)\n if BUILD_BITCOIN_TX\n \t@echo \"Running test/util/bitcoin-util-test.py...\"\n \t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py"
      },
      {
        "sha": "e680b7e9717a02f18e21d8b6b375d7bd63712f12",
        "filename": "src/rusty/cuckoofilter/.gitignore",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/.gitignore?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,10 @@\n+target\n+Cargo.lock\n+\n+\n+#Added by cargo\n+#\n+#already existing elements were commented out\n+\n+/target\n+#Cargo.lock"
      },
      {
        "sha": "ea38e0864bb4031edf1cec4c96da1320ad95e117",
        "filename": "src/rusty/cuckoofilter/CHANGELOG.md",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/CHANGELOG.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/CHANGELOG.md?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,35 @@\n+# Changelog\n+All notable changes to this project will be documented in this file.\n+\n+The format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\n+and this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n+\n+## [Unreleased]\n+### Changed\n+- Serde support is now behind the feature flag `serde_support` and is disabled by default.\n+\n+## [v0.4.0] - 2018-04-1\n+### Added\n+- `ExportedCuckooFilter` adds the ability to serialize the memory map of a `CuckooFilter` via Serde; reducing communication overhead between nodes for example, or the ability to store the current state on disk for retrieval at a later time.\n+- Added a C interface for embedding this crate into other languages.\n+  The interface is an additional crate, located in the cabi/ subfolder.\n+### Changed\n+- add() now returns Result<(), CuckooError> instead of a bool, and returns a NotEnoughSpaceError instead of panicking\n+  when insertion fails.\n+- len() now returns usize instead of u64 to match std's data structures' len() functions.\n+- with_capacity() now takes an usize instead of an u64 to match std's data structures' with_capacity() functions.\n+\n+## [v0.3.2]\n+### Added\n+- Filters now have a memory_usage() function that return how much bytes a given filter occupies in memory.\n+  Let's show how little memory the filters need for their capacity!\n+### Fixed\n+- Use std::collections::hash_map::DefaultHasher as replacement for std::hah::SipHasher as default hasher, as\n+  SipHasher is deprecated since Rust 1.13.\n+- The same part of the item hash was used for generating the fingerprint as well as the index positions. This means that\n+  equal fingerprints always had the same index positions, resulting in increased rebucketing and less items fitting in\n+  the filter.\n+\n+[v0.4.0]: https://github.com/seiflotfy/rust-cuckoofilter/compare/v0.4.0...HEAD\n+[v0.4.0]: https://github.com/seiflotfy/rust-cuckoofilter/compare/v0.3.2...v0.4.0\n+[v0.3.2]: https://github.com/seiflotfy/rust-cuckoofilter/compare/v0.3.1...v0.3.2"
      },
      {
        "sha": "babe3a5755b5b63e5b9bf66264560e66cca95cc5",
        "filename": "src/rusty/cuckoofilter/Cargo.toml",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/Cargo.toml?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,49 @@\n+[package]\n+name = \"cuckoofilter\"\n+version = \"0.5.0\"\n+authors = [\n+  \"Seif Lotfy <seif.lotfy@gmail.com>\",\n+  \"Seif Lotfy <seif@axiom.co>\",\n+  \"Florian Jacob <accounts+git@florianjacob.de>\",\n+  \"The cuckoofilter contributors\",\n+]\n+\n+# A short blurb about the package. This is not rendered in any format when\n+# uploaded to crates.io (aka this is not markdown)\n+description = \"Cuckoo Filter: Practically Better Than Bloom\"\n+\n+# These URLs point to more information about the repository\n+homepage = \"http://axiom.co\"\n+repository = \"https://github.com/axiomhq/rust-cuckoofilter\"\n+\n+# This points to a file in the repository (relative to this Cargo.toml). The\n+# contents of this file are stored and indexed in the registry.\n+readme = \"./README.md\"\n+\n+# This is a small list of keywords used to categorize and search for this\n+# package.\n+keywords = [\"bloomfilter\", \"cuckoohashing\", \"cuckoofilter\"]\n+\n+# This is a string description of the license for this package. Currently\n+# crates.io will validate the license provided against a whitelist of known\n+# license identifiers from http://spdx.org/licenses/. Multiple licenses can\n+# be separated with a `/`\n+license = \"MIT\"\n+\n+edition = \"2018\"\n+\n+[features]\n+default = []\n+serde_support = [\"serde\", \"serde_derive\", \"serde_bytes\"]\n+\n+[dependencies]\n+byteorder = \"1.3.4\"\n+rand = \"0.7.3\"\n+serde = {version = \"1.0.114\", optional = true}\n+serde_derive = {version = \"1.0.114\", optional = true}\n+serde_bytes = {version = \"0.11.5\", optional = true}\n+fnv = \"1.0.7\"\n+farmhash = {version = \"1.1.5\", optional = true}\n+\n+[dev-dependencies]\n+serde_json = \"1.0\""
      },
      {
        "sha": "4658b9954f1863d1d8f16fdaf34823577b411b3d",
        "filename": "src/rusty/cuckoofilter/LICENSE",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/LICENSE?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,22 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2015 Seif Lotfy\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+"
      },
      {
        "sha": "20094a2c26f489aa8f9ab5a93c1c6c16449a70d5",
        "filename": "src/rusty/cuckoofilter/README.md",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/README.md?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,56 @@\n+# Cuckoo Filter\n+\n+[![Crates.io](https://img.shields.io/crates/v/cuckoofilter.svg?maxAge=2592000)](https://crates.io/crates/cuckoofilter)\n+\n+[Documentation](https://docs.rs/cuckoofilter)\n+\n+\n+Cuckoo filter is a Bloom filter replacement for approximated set-membership queries. While Bloom filters are well-known space-efficient data structures to serve queries like \"if item x is in a set?\", they do not support deletion. Their variances to enable deletion (like counting Bloom filters) usually require much more space.\n+\n+Cuckoo \ufb01lters provide the \ufb02exibility to add and remove items dynamically. A cuckoo filter is based on cuckoo hashing (and therefore named as cuckoo filter). It is essentially a cuckoo hash table storing each key's fingerprint. Cuckoo hash tables can be highly compact, thus a cuckoo filter could use less space than conventional Bloom \ufb01lters, for applications that require low false positive rates (< 3%).\n+\n+For details about the algorithm and citations please use this article for now\n+\n+[\"Cuckoo Filter: Better Than Bloom\" by Bin Fan, Dave Andersen and Michael Kaminsky](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf)\n+\n+\n+## Example usage\n+\n+```rust\n+extern crate cuckoofilter;\n+\n+...\n+\n+let value: &str = \"hello world\";\n+\n+// Create cuckoo filter with default max capacity of 1000000 items\n+let mut cf = cuckoofilter::new();\n+\n+// Add data to the filter\n+let success = cf.add(value).unwrap();\n+// success ==> Ok(())\n+\n+// Lookup if data is in the filter\n+let success = cf.contains(value);\n+// success ==> true\n+\n+// Test and add to the filter (if data does not exists then add)\n+let success = cf.test_and_add(value).unwrap();\n+// success ==> Ok(false)\n+\n+// Remove data from the filter.\n+let success = cf.delete(value);\n+// success ==> true\n+```\n+\n+## C Interface\n+This crate has a C interface for embedding it into other languages than Rust.\n+See the [C Interface Documentation](https://docs.rs/cuckoofilter_cabi) for more details.\n+\n+\n+## Notes & TODOs\n+* This implementation uses a a static bucket size of 4 fingerprints and a fingerprint size of 1 byte based on my understanding of an optimal bucket/fingerprint/size ratio from the aforementioned paper.\n+* When the filter returns `NotEnoughSpace`, the element given is actually added to the filter, but some random *other*\n+  element gets removed. This could be improved by implementing a single-item eviction cache for that removed item.\n+* There are no high-level bindings for other languages than C.\n+  One could add them e.g. for python using [milksnake](https://github.com/getsentry/milksnake)."
      },
      {
        "sha": "1e64b578f073b630ffcbf3121e9b7feab9aff76d",
        "filename": "src/rusty/cuckoofilter/benches/bench_lib.rs",
        "status": "added",
        "additions": 79,
        "deletions": 0,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/benches/bench_lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/benches/bench_lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/benches/bench_lib.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,79 @@\n+#![feature(test)]\n+\n+extern crate cuckoofilter;\n+#[cfg(feature = \"farmhash\")]\n+extern crate farmhash;\n+#[cfg(feature = \"fnv\")]\n+extern crate fnv;\n+extern crate rand;\n+extern crate test;\n+\n+use self::cuckoofilter::*;\n+use std::error::Error;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+fn get_words() -> String {\n+    let path = Path::new(\"/usr/share/dict/words\");\n+    let display = path.display();\n+\n+    // Open the path in read-only mode, returns `io::Result<File>`\n+    let mut file = match File::open(&path) {\n+        // The `description` method of `io::Error` returns a string that\n+        // describes the error\n+        Err(why) => panic!(\"couldn't open {}: {}\", display, Error::description(&why)),\n+        Ok(file) => file,\n+    };\n+\n+    let mut contents = String::new();\n+    if let Err(why) = file.read_to_string(&mut contents) {\n+        panic!(\"couldn't read {}: {}\", display, Error::description(&why));\n+    }\n+    contents\n+}\n+\n+fn perform_insertions<H: std::hash::Hasher + Default>(b: &mut test::Bencher) {\n+    let contents = get_words();\n+    let split: Vec<&str> = contents.split(\"\\n\").take(1000).collect();\n+    let mut cf = CuckooFilter::<H>::with_capacity(split.len() * 2);\n+\n+    b.iter(|| {\n+        for s in &split {\n+            test::black_box(cf.test_and_add(s).unwrap());\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn bench_new(b: &mut test::Bencher) {\n+    b.iter(|| {\n+        test::black_box(CuckooFilter::new());\n+    });\n+}\n+\n+#[bench]\n+fn bench_clear(b: &mut test::Bencher) {\n+    let mut cf = test::black_box(CuckooFilter::new());\n+\n+    b.iter(|| {\n+        test::black_box(cf.clear());\n+    });\n+}\n+\n+#[cfg(feature = \"farmhash\")]\n+#[bench]\n+fn bench_insertion_farmhash(b: &mut test::Bencher) {\n+    perform_insertions::<farmhash::FarmHasher>(b);\n+}\n+\n+#[cfg(feature = \"fnv\")]\n+#[bench]\n+fn bench_insertion_fnv(b: &mut test::Bencher) {\n+    perform_insertions::<fnv::FnvHasher>(b);\n+}\n+\n+#[bench]\n+fn bench_insertion_default(b: &mut test::Bencher) {\n+    perform_insertions::<std::collections::hash_map::DefaultHasher>(b);\n+}"
      },
      {
        "sha": "c6a64271a0221875aae143337e80cfc5c84623fa",
        "filename": "src/rusty/cuckoofilter/cabi/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/cabi/.gitignore?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1 @@\n+tests/build"
      },
      {
        "sha": "1af73d6263e6327f37a2d5b00d37c0a353384701",
        "filename": "src/rusty/cuckoofilter/cabi/Cargo.toml",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/cabi/Cargo.toml?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,26 @@\n+[package]\n+name = \"cuckoofilter-cabi\"\n+version = \"0.4.0\"\n+license = \"MIT\"\n+authors = [\n+    \"Florian Jacob <accounts+git@florianjacob.de>\"\n+]\n+homepage = \"http://geekyogre.com\"\n+repository = \"https://github.com/seiflotfy/rust-cuckoofilter\"\n+description = \"\"\"\n+C interface wrapper for cuckoofilter, a library for\n+the Bloom filter replacement for approximated set-membership queries.\n+\"\"\"\n+keywords = [\"bloomfilter\", \"cuckoohashing\", \"cuckoofilter\"]\n+\n+build = \"build.rs\"\n+\n+[dependencies]\n+cuckoofilter = { version = \"0.5\", path = \"../\" }\n+\n+[build-dependencies]\n+cbindgen = \"0.19.0\"\n+\n+[lib]\n+# foreign programs can link against cdylib or staticlib to use rust-cuckoofilter's C API\n+crate-type = [\"cdylib\", \"staticlib\"]"
      },
      {
        "sha": "a65766eed570580ee221b478c09f12dee8ceb340",
        "filename": "src/rusty/cuckoofilter/cabi/build.rs",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/build.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/build.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/cabi/build.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,38 @@\n+extern crate cbindgen;\n+\n+use std::env;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    let crate_dir = env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n+\n+    // either read from $LIBNAME_H the header file, or\n+    // set it equal to $TARGET/$(CARGO_PKG_NAME).h\n+    let header_file_name = env::var(\"HEADER_FILE_OVERRIDE\")\n+        .or(env::var(\"CARGO_PKG_NAME\").map(|f| {\n+            target_dir()\n+                .join(format!(\"{}.h\", f))\n+                .display()\n+                .to_string()\n+        }))\n+        .unwrap();\n+\n+    cbindgen::Builder::new()\n+        .with_crate(crate_dir)\n+        .with_language(cbindgen::Language::C)\n+        .with_parse_deps(true)\n+        .with_parse_include(&[\"cuckoofilter\"])\n+        .generate()\n+        .expect(\"Unable to generate bindings\")\n+        .write_to_file(&header_file_name);\n+}\n+\n+/// Find the location of the `target/` directory.\n+fn target_dir() -> PathBuf {\n+    env::var(\"HEADER_TARGET_DIR_OVERRIDE\")\n+        .or(env::var(\"CARGO_TARGET_DIR\"))\n+        .map(PathBuf::from)\n+        .unwrap_or_else(|_| {\n+            PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap()).join(\"target\")\n+        })\n+}"
      },
      {
        "sha": "a86b927487cdc5183a0885c677cca3c961067b62",
        "filename": "src/rusty/cuckoofilter/cabi/src/lib.rs",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/cabi/src/lib.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,197 @@\n+//! A C interface for the [cuckoofilter crate].\n+//!\n+//! You can use this crate to use the `cuckoofilter` crate from C/C++, or almost any other\n+//! language. There only needs to be a way to call foreign C functions, like in python or ruby.\n+//!\n+//! **Note**: For other languages, you'd probably want to add a language-specific layer on top of\n+//! this, e.g. using [milksnake] for python. Contributions welcome!\n+//!\n+//! # Build Setup\n+//!\n+//! You need to integrate this crate in your build system somehow, how you do this depends on your\n+//! specific build system. You can e.g. use a local checkout of the [cuckoofilter crate]:\n+//!\n+//! ```bash\n+//! git clone https://github.com/seiflotfy/rust-cuckoofilter\n+//! cd rust-cuckoofilter/cabi\n+//! cargo build --release\n+//! ```\n+//!\n+//! Then, put the generated file `cabi/target/include/rcf_cuckoofilter.h` on your compiler's\n+//! include path and link against either `cabi/target/release/libcuckoofilter_cabi.a` or\n+//! `cabi/target/release/libcuckoofilter_cabi.so`, depending on whether you want static or dynamic\n+//! linking. Alternatively, use the provided Makefile via `sudo make install` to install the header\n+//! and libraries system-wide. You can see the `tests` directory for basic examples using a\n+//! Makefile for C and C++, including static and dynamic linking in each case.\n+//!\n+//! If you found a nice way to integrate this crate in a build system,\n+//! please consider contributing the necessary build files!\n+//!\n+//! # Usage\n+//!\n+//! You can then use the interface like this:\n+//!\n+//! ```C\n+//! #include \"rcf_cuckoofilter.h\"\n+//!\n+//! rcf_cuckoofilter *filter = rcf_cuckoofilter_with_capacity(1000);\n+//! rcf_cuckoofilter_status result;\n+//! result = rcf_cuckoofilter_add(filter, 42);\n+//! assert(result == RCF_OK);\n+//! result = rcf_cuckoofilter_contains(filter, 42);\n+//! assert(result == RCF_OK);\n+//! result = rcf_cuckoofilter_delete(filter, 42);\n+//! assert(result == RCF_OK);\n+//! result = rcf_cuckoofilter_contains(filter, 42);\n+//! assert(result == RCF_NOT_FOUND);\n+//! ```\n+//!\n+//! # Hashing arbitrary data\n+//! The interface only takes unsigned 64bit integers as `data`.\n+//! If you want to insert structs or other types, search for something that hashes those to\n+//! integers. Those hashes don't need to be well-distributed as they're\n+//! hashed on the rust side again, so a very simple hash function is sufficient,\n+//! like `std::hash` for C++ or the `__hash__` method in python.\n+//! There's a good chance something like this is present in the\n+//! respective standard library, for implementing hash tables and the like.\n+//!\n+//! In the future, the interface could accept a pointer to arbitrary memory and a size parameter,\n+//! and hash that as byte array on the Rust side. But this approach is problematic if not all given\n+//! bytes are the same for two equal objects.\n+//!\n+//! # Naming\n+//! The prefix `rcf` is short for *rust cuckoo filter*.\n+//! It's used for C-style namespacing to avoid name conflicts with other libraries.\n+//!\n+//! [cuckoofilter crate]: https://crates.io/crates/cuckoofilter\n+//! [milksnake]: https://github.com/getsentry/milksnake\n+\n+extern crate cuckoofilter;\n+\n+use cuckoofilter::CuckooError;\n+use std::collections::hash_map::DefaultHasher;\n+\n+/// Opaque type for a cuckoo filter using Rust's `std::collections::hash_map::DefaultHasher` as\n+/// Hasher. The C ABI only supports that specific Hasher, currently.\n+#[allow(non_camel_case_types)]\n+pub type rcf_cuckoofilter = cuckoofilter::CuckooFilter<DefaultHasher>;\n+\n+#[allow(non_camel_case_types)]\n+#[repr(C)]\n+pub enum rcf_cuckoofilter_status {\n+    RCF_OK,\n+    RCF_NOT_FOUND,\n+    RCF_NOT_ENOUGH_SPACE,\n+}\n+\n+/// Constructs a cuckoo filter with a given max capacity.\n+/// The various wrapper methods of this crate operate on the returned reference.\n+/// At the end of its life, use [`rcf_cuckoofilter_free`] to free the allocated memory.\n+///\n+/// [`rcf_cuckoofilter_free`]: fn.rcf_cuckoofilter_free.html\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_with_capacity(capacity: usize) -> *mut rcf_cuckoofilter {\n+    let filter = cuckoofilter::CuckooFilter::with_capacity(capacity);\n+    let filter = Box::new(filter);\n+    Box::into_raw(filter)\n+}\n+\n+/// Free the given `filter`, releasing its allocated memory.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_free(filter: *mut rcf_cuckoofilter) {\n+    let filter = unsafe { Box::from_raw(filter) };\n+    drop(filter);\n+}\n+\n+/// Checks if the given `data` is in the `filter`.\n+///\n+/// Returns `rcf_cuckoofilter_status::RCF_OK` if the given `data` is in the `filter`,\n+/// `rcf_cuckoofilter_status::RCF_NOT_FOUND` otherwise.\n+/// Aborts if the given `filter` is a null pointer.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_contains(\n+    filter: *const rcf_cuckoofilter,\n+    data: u64,\n+) -> rcf_cuckoofilter_status {\n+    let filter = unsafe { filter.as_ref() };\n+    let found = filter\n+        .expect(\"Given rcf_cuckoofilter* is a null pointer\")\n+        .contains(&data);\n+    if found {\n+        rcf_cuckoofilter_status::RCF_OK\n+    } else {\n+        rcf_cuckoofilter_status::RCF_NOT_FOUND\n+    }\n+}\n+\n+/// Adds `data` to the `filter`.\n+///\n+/// Returns `rcf_cuckoofilter_status::RCF_OK` if the given `data` was successfully added to the\n+/// `filter`, `rcf_cuckoofilter_status::RCF_NOT_ENOUGH_SPACE` if the filter could not find a free\n+/// space for it.\n+/// Aborts if the given `filter` is a null pointer.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_add(\n+    filter: *mut rcf_cuckoofilter,\n+    data: u64,\n+) -> rcf_cuckoofilter_status {\n+    let filter = unsafe { filter.as_mut() };\n+    match filter\n+        .expect(\"Given rcf_cuckoofilter* is a null pointer\")\n+        .add(&data)\n+    {\n+        Ok(_) => rcf_cuckoofilter_status::RCF_OK,\n+        Err(CuckooError::NotEnoughSpace) => rcf_cuckoofilter_status::RCF_NOT_ENOUGH_SPACE,\n+    }\n+}\n+\n+/// Returns the number of items in the `filter`.\n+/// Aborts if the given `filter` is a null pointer.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_len(filter: *const rcf_cuckoofilter) -> usize {\n+    let filter = unsafe { filter.as_ref() };\n+    filter\n+        .expect(\"Given rcf_cuckoofilter* is a null pointer\")\n+        .len()\n+}\n+\n+/// Checks if `filter` is empty.\n+/// This is equivalent to `rcf_cuckoofilter_len(filter) == 0`\n+/// Aborts if the given `filter` is a null pointer.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_is_empty(filter: *const rcf_cuckoofilter) -> bool {\n+    let filter = unsafe { filter.as_ref() };\n+    filter\n+        .expect(\"Given rcf_cuckoofilter* is a null pointer\")\n+        .is_empty()\n+}\n+\n+/// Returns the number of bytes the `filter` occupies in memory.\n+/// Aborts if the given `filter` is a null pointer.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_memory_usage(filter: *const rcf_cuckoofilter) -> usize {\n+    let filter = unsafe { filter.as_ref() };\n+    filter\n+        .expect(\"Given rcf_cuckoofilter* is a null pointer\")\n+        .memory_usage()\n+}\n+\n+/// Deletes `data` from the `filter`.\n+/// Returns `rcf_cuckoofilter_status::RCF_OK` if `data` existed in the filter before,\n+/// `rcf_cuckoofilter_status::RCF_NOT_FOUND` if `data` did not exist.\n+/// Aborts if the given `filter` is a null pointer.\n+#[no_mangle]\n+pub extern \"C\" fn rcf_cuckoofilter_delete(\n+    filter: *mut rcf_cuckoofilter,\n+    data: u64,\n+) -> rcf_cuckoofilter_status {\n+    let filter = unsafe { filter.as_mut() };\n+    let found = filter\n+        .expect(\"Given rcf_cuckoofilter* is a null pointer\")\n+        .delete(&data);\n+    if found {\n+        rcf_cuckoofilter_status::RCF_OK\n+    } else {\n+        rcf_cuckoofilter_status::RCF_NOT_FOUND\n+    }\n+}"
      },
      {
        "sha": "3b153e8ffe2b489ba64101f104f1dc0c07292664",
        "filename": "src/rusty/cuckoofilter/cabi/tests/basic_operations.c",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/tests/basic_operations.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/cabi/tests/basic_operations.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/cabi/tests/basic_operations.c?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,38 @@\n+#include <stdio.h>\n+#include <assert.h>\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#include \"rcf_cuckoofilter.h\"\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int main(int argc, char **argv) {\n+    rcf_cuckoofilter *filter = rcf_cuckoofilter_with_capacity(1024);\n+    rcf_cuckoofilter_status status;\n+\n+    status = rcf_cuckoofilter_add(filter, 42);\n+    assert(status == RCF_OK);\n+    printf(\"added 42: %d\\n\", status == RCF_OK);\n+\n+    status = rcf_cuckoofilter_contains(filter, 42);\n+    assert(status == RCF_OK);\n+    printf(\"contains 42: %d\\n\", status == RCF_OK);\n+\n+    status = rcf_cuckoofilter_contains(filter, 4711);\n+    assert(status == RCF_NOT_FOUND);\n+    printf(\"contains 4711: %d\\n\", status == RCF_OK);\n+\n+    status = rcf_cuckoofilter_delete(filter, 42);\n+    assert(status == RCF_OK);\n+    printf(\"deleted 42: %d\\n\", status == RCF_OK);\n+\n+    status = rcf_cuckoofilter_contains(filter, 42);\n+    assert(status == RCF_NOT_FOUND);\n+    printf(\"contains 42: %d\\n\", status == RCF_OK);\n+\n+    rcf_cuckoofilter_free(filter);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "68014cca2902842e6a31a2bd0aa6f4a30ae88fae",
        "filename": "src/rusty/cuckoofilter/src/bucket.rs",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/src/bucket.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/src/bucket.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/src/bucket.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,109 @@\n+pub const FINGERPRINT_SIZE: usize = 1;\n+pub const BUCKET_SIZE: usize = 4;\n+const EMPTY_FINGERPRINT_DATA: [u8; FINGERPRINT_SIZE] = [100; FINGERPRINT_SIZE];\n+\n+// Fingerprint Size is 1 byte so lets remove the Vec\n+#[derive(PartialEq, Copy, Clone, Hash)]\n+pub struct Fingerprint {\n+    pub data: [u8; FINGERPRINT_SIZE],\n+}\n+\n+impl Fingerprint {\n+    /// Attempts to create a new Fingerprint based on the given\n+    /// number. If the created Fingerprint would be equal to the\n+    /// empty Fingerprint, None is returned.\n+    pub fn from_data(data: [u8; FINGERPRINT_SIZE]) -> Option<Self> {\n+        let result = Self { data };\n+        if result.is_empty() {\n+            None\n+        } else {\n+            Some(result)\n+        }\n+    }\n+\n+    /// Returns the empty Fingerprint.\n+    pub fn empty() -> Self {\n+        Self {\n+            data: EMPTY_FINGERPRINT_DATA,\n+        }\n+    }\n+\n+    /// Checks if this is the empty Fingerprint.\n+    pub fn is_empty(&self) -> bool {\n+        self.data == EMPTY_FINGERPRINT_DATA\n+    }\n+\n+    /// Sets the fingerprint value to a previously exported one via an in-memory copy.\n+    fn slice_copy(&mut self, fingerprint: &[u8]) {\n+        self.data.copy_from_slice(fingerprint);\n+    }\n+}\n+\n+/// Manages `BUCKET_SIZE` fingerprints at most.\n+#[derive(Clone)]\n+pub struct Bucket {\n+    pub buffer: [Fingerprint; BUCKET_SIZE],\n+}\n+\n+impl Bucket {\n+    /// Creates a new bucket with a pre-allocated buffer.\n+    pub fn new() -> Self {\n+        Self {\n+            buffer: [Fingerprint::empty(); BUCKET_SIZE],\n+        }\n+    }\n+\n+    /// Inserts the fingerprint into the buffer if the buffer is not full.\n+    /// This operation is O(1).\n+    pub fn insert(&mut self, fp: Fingerprint) -> bool {\n+        for entry in &mut self.buffer {\n+            if entry.is_empty() {\n+                *entry = fp;\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Deletes the given fingerprint from the bucket. This operation is O(1).\n+    pub fn delete(&mut self, fp: Fingerprint) -> bool {\n+        match self.get_fingerprint_index(fp) {\n+            Some(index) => {\n+                self.buffer[index] = Fingerprint::empty();\n+                true\n+            }\n+            None => false,\n+        }\n+    }\n+\n+    /// Returns the index of the given fingerprint, if its found. O(1)\n+    pub fn get_fingerprint_index(&self, fp: Fingerprint) -> Option<usize> {\n+        self.buffer.iter().position(|e| *e == fp)\n+    }\n+\n+    /// Returns all current fingerprint data of the current buffer for storage.\n+    pub fn get_fingerprint_data(&self) -> Vec<u8> {\n+        self.buffer\n+            .iter()\n+            .flat_map(|f| f.data.iter())\n+            .cloned()\n+            .collect()\n+    }\n+\n+    /// Empties the bucket by setting each used entry to Fingerprint::empty(). Returns the number of entries that were modified.\n+    #[inline(always)]\n+    pub fn clear(&mut self) {\n+        *self = Self::new()\n+    }\n+}\n+\n+impl From<&[u8]> for Bucket {\n+    /// Constructs a buffer of fingerprints from a set of previously exported fingerprints.\n+    fn from(fingerprints: &[u8]) -> Self {\n+        let mut buffer = [Fingerprint::empty(); BUCKET_SIZE];\n+        for (idx, value) in fingerprints.chunks(FINGERPRINT_SIZE).enumerate() {\n+            buffer[idx].slice_copy(value);\n+        }\n+        Self { buffer }\n+    }\n+}"
      },
      {
        "sha": "0f534f0ea9387542a61bc595cba6c0223b653c49",
        "filename": "src/rusty/cuckoofilter/src/lib.rs",
        "status": "added",
        "additions": 330,
        "deletions": 0,
        "changes": 330,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/src/lib.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,330 @@\n+//! Cuckoo filter probabilistic data structure for membership testing and cardinality counting.\n+//!\n+//! # Usage\n+//!\n+//! This crate is [on crates.io](https://crates.io/crates/cuckoofilter) and can be\n+//! used by adding `cuckoofilter` to the dependencies in your project's `Cargo.toml`.\n+//!\n+//! ```toml\n+//! [dependencies]\n+//! cuckoofilter = \"0.3\"\n+//! ```\n+//!\n+//! And this in your crate root:\n+//!\n+//! ```rust\n+//! extern crate cuckoofilter;\n+//! ```\n+\n+mod bucket;\n+mod util;\n+\n+use crate::bucket::{Bucket, Fingerprint, BUCKET_SIZE, FINGERPRINT_SIZE};\n+use crate::util::{get_alt_index, get_fai, FaI};\n+\n+use std::cmp;\n+use std::collections::hash_map::DefaultHasher;\n+use std::error::Error as StdError;\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::iter::repeat;\n+use std::marker::PhantomData;\n+use std::mem;\n+\n+use rand::Rng;\n+#[cfg(feature = \"serde_support\")]\n+use serde_derive::{Deserialize, Serialize};\n+\n+/// If insertion fails, we will retry this many times.\n+pub const MAX_REBUCKET: u32 = 500;\n+\n+/// The default number of buckets.\n+pub const DEFAULT_CAPACITY: usize = (1 << 20) - 1;\n+\n+#[derive(Debug)]\n+pub enum CuckooError {\n+    NotEnoughSpace,\n+}\n+\n+impl fmt::Display for CuckooError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"NotEnoughSpace\")\n+    }\n+}\n+\n+impl StdError for CuckooError {\n+    fn description(&self) -> &str {\n+        \"Not enough space to store this item, rebucketing failed.\"\n+    }\n+}\n+\n+/// A cuckoo filter class exposes a Bloomier filter interface,\n+/// providing methods of add, delete, contains.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// extern crate cuckoofilter;\n+///\n+/// let words = vec![\"foo\", \"bar\", \"xylophone\", \"milagro\"];\n+/// let mut cf = cuckoofilter::CuckooFilter::new();\n+///\n+/// let mut insertions = 0;\n+/// for s in &words {\n+///     if cf.test_and_add(s).unwrap() {\n+///         insertions += 1;\n+///     }\n+/// }\n+///\n+/// assert_eq!(insertions, words.len());\n+/// assert_eq!(cf.len(), words.len());\n+///\n+/// // Re-add the first element.\n+/// cf.add(words[0]);\n+///\n+/// assert_eq!(cf.len(), words.len() + 1);\n+///\n+/// for s in &words {\n+///     cf.delete(s);\n+/// }\n+///\n+/// assert_eq!(cf.len(), 1);\n+/// assert!(!cf.is_empty());\n+///\n+/// cf.delete(words[0]);\n+///\n+/// assert_eq!(cf.len(), 0);\n+/// assert!(cf.is_empty());\n+///\n+/// for s in &words {\n+///     if cf.test_and_add(s).unwrap() {\n+///         insertions += 1;\n+///     }\n+/// }\n+///\n+/// cf.clear();\n+///\n+/// assert!(cf.is_empty());\n+///\n+/// ```\n+pub struct CuckooFilter<H> {\n+    buckets: Box<[Bucket]>,\n+    len: usize,\n+    _hasher: std::marker::PhantomData<H>,\n+}\n+\n+impl Default for CuckooFilter<DefaultHasher> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl CuckooFilter<DefaultHasher> {\n+    /// Construct a CuckooFilter with default capacity and hasher.\n+    pub fn new() -> Self {\n+        Self::with_capacity(DEFAULT_CAPACITY)\n+    }\n+}\n+\n+impl<H> CuckooFilter<H>\n+where\n+    H: Hasher + Default,\n+{\n+    /// Constructs a Cuckoo Filter with a given max capacity\n+    pub fn with_capacity(cap: usize) -> Self {\n+        let capacity = cmp::max(1, cap.next_power_of_two() / BUCKET_SIZE);\n+\n+        Self {\n+            buckets: repeat(Bucket::new())\n+                .take(capacity)\n+                .collect::<Vec<_>>()\n+                .into_boxed_slice(),\n+            len: 0,\n+            _hasher: PhantomData,\n+        }\n+    }\n+\n+    /// Checks if `data` is in the filter.\n+    pub fn contains<T: ?Sized + Hash>(&self, data: &T) -> bool {\n+        let FaI { fp, i1, i2 } = get_fai::<T, H>(data);\n+        let len = self.buckets.len();\n+        self.buckets[i1 % len]\n+            .get_fingerprint_index(fp)\n+            .or_else(|| self.buckets[i2 % len].get_fingerprint_index(fp))\n+            .is_some()\n+    }\n+\n+    /// Adds `data` to the filter. Returns `Ok` if the insertion was successful,\n+    /// but could fail with a `NotEnoughSpace` error, especially when the filter\n+    /// is nearing its capacity.\n+    /// Note that while you can put any hashable type in the same filter, beware\n+    /// for side effects like that the same number can have diferent hashes\n+    /// depending on the type.\n+    /// So for the filter, 4711i64 isn't the same as 4711u64.\n+    ///\n+    /// **Note:** When this returns `NotEnoughSpace`, the element given was\n+    /// actually added to the filter, but some random *other* element was\n+    /// removed. This might improve in the future.\n+    pub fn add<T: ?Sized + Hash>(&mut self, data: &T) -> Result<(), CuckooError> {\n+        let fai = get_fai::<T, H>(data);\n+        if self.put(fai.fp, fai.i1) || self.put(fai.fp, fai.i2) {\n+            return Ok(());\n+        }\n+        let len = self.buckets.len();\n+        let mut rng = rand::thread_rng();\n+        let mut i = fai.random_index(&mut rng);\n+        let mut fp = fai.fp;\n+        for _ in 0..MAX_REBUCKET {\n+            let other_fp;\n+            {\n+                let loc = &mut self.buckets[i % len].buffer[rng.gen_range(0, BUCKET_SIZE)];\n+                other_fp = *loc;\n+                *loc = fp;\n+                i = get_alt_index::<H>(other_fp, i);\n+            }\n+            if self.put(other_fp, i) {\n+                return Ok(());\n+            }\n+            fp = other_fp;\n+        }\n+        // fp is dropped here, which means that the last item that was\n+        // rebucketed gets removed from the filter.\n+        // TODO: One could introduce a single-item cache for this element,\n+        // check this cache in all methods additionally to the actual filter,\n+        // and return NotEnoughSpace if that cache is already in use.\n+        // This would complicate the code, but stop random elements from\n+        // getting removed and result in nicer behaviour for the user.\n+        Err(CuckooError::NotEnoughSpace)\n+    }\n+\n+    /// Adds `data` to the filter if it does not exist in the filter yet.\n+    /// Returns `Ok(true)` if `data` was not yet present in the filter and added\n+    /// successfully.\n+    pub fn test_and_add<T: ?Sized + Hash>(&mut self, data: &T) -> Result<bool, CuckooError> {\n+        if self.contains(data) {\n+            Ok(false)\n+        } else {\n+            self.add(data).map(|_| true)\n+        }\n+    }\n+\n+    /// Number of items in the filter.\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    /// Exports fingerprints in all buckets, along with the filter's length for storage.\n+    /// The filter can be recovered by passing the `ExportedCuckooFilter` struct to the\n+    /// `from` method of `CuckooFilter`.\n+    pub fn export(&self) -> ExportedCuckooFilter {\n+        self.into()\n+    }\n+\n+    /// Number of bytes the filter occupies in memory\n+    pub fn memory_usage(&self) -> usize {\n+        mem::size_of_val(self) + self.buckets.len() * mem::size_of::<Bucket>()\n+    }\n+\n+    /// Check if filter is empty\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    /// Deletes `data` from the filter. Returns true if `data` existed in the\n+    /// filter before.\n+    pub fn delete<T: ?Sized + Hash>(&mut self, data: &T) -> bool {\n+        let FaI { fp, i1, i2 } = get_fai::<T, H>(data);\n+        self.remove(fp, i1) || self.remove(fp, i2)\n+    }\n+\n+    /// Empty all the buckets in a filter and reset the number of items.\n+    pub fn clear(&mut self) {\n+        if self.is_empty() {\n+            return;\n+        }\n+\n+        for bucket in self.buckets.iter_mut() {\n+            bucket.clear();\n+        }\n+        self.len = 0;\n+    }\n+\n+    /// Extracts fingerprint values from all buckets, used for exporting the filters data.\n+    fn values(&self) -> Vec<u8> {\n+        self.buckets\n+            .iter()\n+            .flat_map(|b| b.get_fingerprint_data().into_iter())\n+            .collect()\n+    }\n+\n+    /// Removes the item with the given fingerprint from the bucket indexed by i.\n+    fn remove(&mut self, fp: Fingerprint, i: usize) -> bool {\n+        let len = self.buckets.len();\n+        if self.buckets[i % len].delete(fp) {\n+            self.len -= 1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn put(&mut self, fp: Fingerprint, i: usize) -> bool {\n+        let len = self.buckets.len();\n+        if self.buckets[i % len].insert(fp) {\n+            self.len += 1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// A minimal representation of the CuckooFilter which can be transfered or stored, then recovered at a later stage.\n+#[derive(Debug)]\n+#[cfg_attr(feature = \"serde_support\", derive(Deserialize, Serialize))]\n+pub struct ExportedCuckooFilter {\n+    #[cfg_attr(feature = \"serde_support\", serde(with = \"serde_bytes\"))]\n+    pub values: Vec<u8>,\n+    pub length: usize,\n+}\n+\n+impl<H> From<ExportedCuckooFilter> for CuckooFilter<H> {\n+    /// Converts a simplified representation of a filter used for export to a\n+    /// fully functioning version.\n+    ///\n+    /// # Contents\n+    ///\n+    /// * `values` - A serialized version of the `CuckooFilter`'s memory, where the\n+    /// fingerprints in each bucket are chained one after another, then in turn all\n+    /// buckets are chained together.\n+    /// * `length` - The number of valid fingerprints inside the `CuckooFilter`.\n+    /// This value is used as a time saving method, otherwise all fingerprints\n+    /// would need to be checked for equivalence against the null pattern.\n+    fn from(exported: ExportedCuckooFilter) -> Self {\n+        // Assumes that the `BUCKET_SIZE` and `FINGERPRINT_SIZE` constants do not change.\n+        Self {\n+            buckets: exported\n+                .values\n+                .chunks(BUCKET_SIZE * FINGERPRINT_SIZE)\n+                .map(Bucket::from)\n+                .collect::<Vec<_>>()\n+                .into_boxed_slice(),\n+            len: exported.length,\n+            _hasher: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<H> From<&CuckooFilter<H>> for ExportedCuckooFilter\n+where\n+    H: Hasher + Default,\n+{\n+    /// Converts a `CuckooFilter` into a simplified version which can be serialized and stored\n+    /// for later use.\n+    fn from(cuckoo: &CuckooFilter<H>) -> Self {\n+        Self {\n+            values: cuckoo.values(),\n+            length: cuckoo.len(),\n+        }\n+    }\n+}"
      },
      {
        "sha": "ea87f92ba5030faed6b7ca4a6f4786e214daebf0",
        "filename": "src/rusty/cuckoofilter/src/util.rs",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/src/util.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/src/util.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/src/util.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,89 @@\n+use crate::bucket::{Fingerprint, FINGERPRINT_SIZE};\n+\n+use std::hash::{Hash, Hasher};\n+\n+use byteorder::{BigEndian, WriteBytesExt};\n+\n+// A struct combining *F*ingerprint *a*nd *I*ndexes,\n+// to have a return type with named fields\n+// instead of a tuple with unnamed fields.\n+pub struct FaI {\n+    pub fp: Fingerprint,\n+    pub i1: usize,\n+    pub i2: usize,\n+}\n+\n+fn get_hash<T: ?Sized + Hash, H: Hasher + Default>(data: &T) -> (u32, u32) {\n+    let mut hasher = <H as Default>::default();\n+    data.hash(&mut hasher);\n+    let result = hasher.finish();\n+\n+    // split 64bit hash value in the upper and the lower 32bit parts,\n+    // one used for the fingerprint, the other used for the indexes.\n+    ((result >> 32) as u32, result as u32)\n+}\n+\n+pub fn get_alt_index<H: Hasher + Default>(fp: Fingerprint, i: usize) -> usize {\n+    let (_, index_hash) = get_hash::<_, H>(&fp.data);\n+    let alt_i = index_hash as usize;\n+    (i ^ alt_i) as usize\n+}\n+\n+impl FaI {\n+    fn from_data<T: ?Sized + Hash, H: Hasher + Default>(data: &T) -> Self {\n+        let (fp_hash, index_hash) = get_hash::<_, H>(data);\n+\n+        let mut fp_hash_arr = [0; FINGERPRINT_SIZE];\n+        let _ = (&mut fp_hash_arr[..]).write_u32::<BigEndian>(fp_hash);\n+        let mut valid_fp_hash: [u8; FINGERPRINT_SIZE] = [0; FINGERPRINT_SIZE];\n+        let mut n = 0;\n+        let fp;\n+\n+        // increment every byte of the hash until we find one that is a valid fingerprint\n+        loop {\n+            for i in 0..FINGERPRINT_SIZE {\n+                valid_fp_hash[i] = fp_hash_arr[i] + n;\n+            }\n+\n+            if let Some(val) = Fingerprint::from_data(valid_fp_hash) {\n+                fp = val;\n+                break;\n+            }\n+            n += 1;\n+        }\n+\n+        let i1 = index_hash as usize;\n+        let i2 = get_alt_index::<H>(fp, i1);\n+        Self { fp, i1, i2 }\n+    }\n+\n+    pub fn random_index<R: ::rand::Rng>(&self, r: &mut R) -> usize {\n+        if r.gen() {\n+            self.i1\n+        } else {\n+            self.i2\n+        }\n+    }\n+}\n+\n+pub fn get_fai<T: ?Sized + Hash, H: Hasher + Default>(data: &T) -> FaI {\n+    FaI::from_data::<_, H>(data)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_fp_and_index() {\n+        use std::collections::hash_map::DefaultHasher;\n+        let data = \"seif\";\n+        let fai = get_fai::<_, DefaultHasher>(data);\n+        let FaI { fp, i1, i2 } = fai;\n+        let i11 = get_alt_index::<DefaultHasher>(fp, i2);\n+        assert_eq!(i11, i1);\n+\n+        let i22 = get_alt_index::<DefaultHasher>(fp, i11);\n+        assert_eq!(i22, i2);\n+    }\n+}"
      },
      {
        "sha": "ed4a095acb608dde890139963f5c0c245385d299",
        "filename": "src/rusty/cuckoofilter/tests/false_positive_rate.rs",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/tests/false_positive_rate.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/tests/false_positive_rate.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/tests/false_positive_rate.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,49 @@\n+use cuckoofilter::CuckooFilter;\n+\n+use std::collections::hash_map::DefaultHasher;\n+\n+// Modelled after\n+// https://github.com/efficient/cuckoofilter/blob/master/example/test.cc\n+// to make test setup and results comparable.\n+\n+#[test]\n+fn false_positive_rate() {\n+    let total_items = 1_000_000;\n+\n+    let mut filter = CuckooFilter::<DefaultHasher>::with_capacity(total_items);\n+\n+    let mut num_inserted: u64 = 0;\n+    // We might not be able to get all items in, but still there should be enough\n+    // so we can just use what has fit in and continue with the test.\n+    for i in 0..total_items {\n+        match filter.add(&i) {\n+            Ok(_) => num_inserted += 1,\n+            Err(_) => break,\n+        }\n+    }\n+\n+    // The range 0..num_inserted are all known to be in the filter.\n+    // The filter shouldn't return false negatives, and therefore they should all be contained.\n+    for i in 0..num_inserted {\n+        assert!(filter.contains(&i));\n+    }\n+\n+    // The range total_items..(2 * total_items) are all known *not* to be in the filter.\n+    // Every element for which the filter claims that it is contained is therefore a false positive.\n+    let mut false_queries: u64 = 0;\n+    for i in total_items..(2 * total_items) {\n+        if filter.contains(&i) {\n+            false_queries += 1;\n+        }\n+    }\n+    let false_positive_rate = (false_queries as f64) / (total_items as f64);\n+\n+    println!(\"elements inserted: {}\", num_inserted);\n+    println!(\n+        \"memory usage: {:.2}KiB\",\n+        (filter.memory_usage() as f64) / 1024.0\n+    );\n+    println!(\"false positive rate: {}%\", 100.0 * false_positive_rate);\n+    // ratio should be around 0.024, round up to 0.03 to accomodate for random fluctuation\n+    assert!(false_positive_rate < 0.03);\n+}"
      },
      {
        "sha": "3b2728f44158e61b8c9af7276c46bc4f9ccf99e4",
        "filename": "src/rusty/cuckoofilter/tests/interop.rs",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/tests/interop.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ebc927e0efc641960510ee84745d31bfaf75ff2/src/rusty/cuckoofilter/tests/interop.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/cuckoofilter/tests/interop.rs?ref=9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "patch": "@@ -0,0 +1,66 @@\n+use cuckoofilter::{CuckooFilter, ExportedCuckooFilter};\n+\n+use std::collections::hash_map::DefaultHasher;\n+\n+#[test]\n+fn interoperability() {\n+    let total_items = 1_000_000;\n+\n+    let mut filter = CuckooFilter::<DefaultHasher>::with_capacity(total_items);\n+\n+    let mut num_inserted: u64 = 0;\n+    // Fit as many values in as possible, count how many made it in.\n+    for i in 0..total_items {\n+        match filter.add(&i) {\n+            Ok(_) => num_inserted += 1,\n+            Err(_) => break,\n+        }\n+    }\n+\n+    // Export the fingerprint data stored in the filter,\n+    // along with the filter's current length.\n+    let store: ExportedCuckooFilter = filter.export();\n+\n+    // Create a new filter using the `recover` method and the values previously exported.\n+    let recovered_filter = CuckooFilter::<DefaultHasher>::from(store);\n+\n+    // The range 0..num_inserted are all known to be in the filter.\n+    // The filters shouldn't return false negatives, and therefore they should all be contained.\n+    // Both filters should also be identical.\n+    for i in 0..num_inserted {\n+        assert!(filter.contains(&i));\n+        assert!(recovered_filter.contains(&i));\n+    }\n+\n+    // The range total_items..(2 * total_items) are all known *not* to be in the filter.\n+    // Every element for which the filter claims that it is contained is therefore a false positive, and both the original filter and recovered filter should exhibit the same false positive behaviour.\n+    for i in total_items..(2 * total_items) {\n+        assert_eq!(filter.contains(&i), recovered_filter.contains(&i));\n+    }\n+}\n+\n+#[test]\n+#[cfg(feature = \"serde_support\")]\n+fn serialization() {\n+    // Just a small filter to test serialization.\n+    let mut filter = CuckooFilter::<DefaultHasher>::with_capacity(100);\n+\n+    // Fill a few values.\n+    for i in 0..50 {\n+        filter.add(&i).unwrap();\n+    }\n+    // export data.\n+    let store: ExportedCuckooFilter = filter.export();\n+\n+    // serialize using json (for example, any serde format can be used).\n+    let saved_json = serde_json::to_string(&store).unwrap();\n+\n+    // create a new filter from the json string.\n+    let restore_json: ExportedCuckooFilter = serde_json::from_str(&saved_json).unwrap();\n+    let recovered_filter = CuckooFilter::<DefaultHasher>::from(restore_json);\n+\n+    // Check our values exist within the reconstructed filter.\n+    for i in 0..50 {\n+        assert!(recovered_filter.contains(&i));\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "dd78b53d94528764968904b265bc8a629e4d6800",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZDc4YjUzZDk0NTI4NzY0OTY4OTA0YjI2NWJjOGE2MjllNGQ2ODAw",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-05-01T03:28:04Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-05-03T04:10:03Z"
      },
      "message": "p2p: experimental Rust based cuckoo filter",
      "tree": {
        "sha": "64c675c2e2ab2f279fd0f9560c5aeece170b4a44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64c675c2e2ab2f279fd0f9560c5aeece170b4a44"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd78b53d94528764968904b265bc8a629e4d6800",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmCPd5sACgkQLuufXMCV\nJsG45g//fZqqVhwbHGLXQZqNU4y7zceI5lRgfOvUmw0596gHkIcL4JRaGkPz/iNZ\nBlMkprnhGFdS/C86vhvFshVbPxXVxHbt8KPh7I00eALEeHolnJLKQ9B7GBuUqxQx\nzL1eiyEoVyyJVzTQ70jc9de+w42mpHzfmzunI/JL2UimSFci06trXkI3xNyJx5hw\nZSaD7x9AlpDxQ9ZTXi9B+maaH85RMG3IF1NuQJOBmamJIZ6R7oxg9kt5AP/8Qncx\nAZcqKy/uU14t26ywwmNT4it3MTv+rJ9EH8m2zUrAEyxx4+789+fi/1YDLJ969A+S\nATWsH+MZNhIy8An4w9kYpjz3HXrFAG/Y50TKVjQ9zBhsKpA2VspuyvBWcNKxqc+k\nz2EZ8SvRJ836YMPvv7/P6LMXlokEVryu6vlp6aClDzVx6vCFJss0CorBni0mQPu3\nnL/+Hcb4WCTC2z8KDxVv9DHZxyPGmibps7Tzlt5eO6ngXdh9qK5l5IvLXNvkOeiy\nRxJqWS7AgVAnZrfYlgC+gY4O071jWy5FsXkfYjdPGd80k10qe9TSL4P0+lo0zqQ3\nextgQTxiKz0zvwsxKuRTyzqakMgt/gSodSRa5EV7UbBCYnvJC9tY8JCirCfkRPKx\nrEtOYWSdMc7SStYLrj7MVA4qGOHxooGa50Aa948tV8iXqb9XzpY=\n=ora8\n-----END PGP SIGNATURE-----",
        "payload": "tree 64c675c2e2ab2f279fd0f9560c5aeece170b4a44\nparent 9ebc927e0efc641960510ee84745d31bfaf75ff2\nauthor fanquake <fanquake@gmail.com> 1619839684 +0800\ncommitter fanquake <fanquake@gmail.com> 1620015003 +0800\n\np2p: experimental Rust based cuckoo filter\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd78b53d94528764968904b265bc8a629e4d6800",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dd78b53d94528764968904b265bc8a629e4d6800",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd78b53d94528764968904b265bc8a629e4d6800/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ebc927e0efc641960510ee84745d31bfaf75ff2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ebc927e0efc641960510ee84745d31bfaf75ff2"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 69,
      "deletions": 1
    },
    "files": [
      {
        "sha": "af4418b5bd19e583bed2a63864b766924dac7214",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd78b53d94528764968904b265bc8a629e4d6800/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd78b53d94528764968904b265bc8a629e4d6800/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=dd78b53d94528764968904b265bc8a629e4d6800",
        "patch": "@@ -2934,7 +2934,11 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n     }\n \n     if (RelayAddrsWithConn()) {\n+        #if ENABLE_RUSTY\n+        m_addr_known = rcf_cuckoofilter_with_capacity(5000);\n+        #else\n         m_addr_known = std::make_unique<CRollingBloomFilter>(5000, 0.001);\n+        #endif\n     }\n \n     for (const std::string &msg : getAllNetMessageTypes())"
      },
      {
        "sha": "bd05d7577d2b18deb07b954f573828f49150b759",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 21,
        "deletions": 1,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd78b53d94528764968904b265bc8a629e4d6800/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd78b53d94528764968904b265bc8a629e4d6800/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=dd78b53d94528764968904b265bc8a629e4d6800",
        "patch": "@@ -38,6 +38,12 @@\n #include <thread>\n #include <vector>\n \n+#if ENABLE_RUSTY\n+extern \"C\" {\n+#include <rusty/out/rcf_cuckoofilter.h>\n+}\n+#endif\n+\n class CScheduler;\n class CNode;\n class BanMan;\n@@ -547,7 +553,11 @@ class CNode\n \n     // flood relay\n     std::vector<CAddress> vAddrToSend;\n+    #if ENABLE_RUSTY\n+    rcf_cuckoofilter* m_addr_known;\n+    #else\n     std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    #endif\n     bool fGetAddr{false};\n     Mutex m_addr_send_times_mutex;\n     std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n@@ -660,7 +670,11 @@ class CNode\n     void AddAddressKnown(const CAddress& _addr)\n     {\n         assert(m_addr_known);\n+        #if ENABLE_RUSTY\n+        rcf_cuckoofilter_add(m_addr_known, _addr.GetHashedKey());\n+        #else\n         m_addr_known->insert(_addr.GetKey());\n+        #endif\n     }\n \n     /**\n@@ -679,7 +693,13 @@ class CNode\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n         assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+        bool contains;\n+        #if ENABLE_RUSTY\n+        contains = (rcf_cuckoofilter_contains(m_addr_known, _addr.GetHashedKey()) == RCF_OK);\n+        #else\n+        contains = m_addr_known->contains(_addr.GetKey());\n+        #endif\n+        if (_addr.IsValid() && !contains && IsAddrCompatible(_addr)) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n                 vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n             } else {"
      },
      {
        "sha": "606681cd6d25dbf3f44bc4667130423736870ea7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd78b53d94528764968904b265bc8a629e4d6800/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd78b53d94528764968904b265bc8a629e4d6800/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=dd78b53d94528764968904b265bc8a629e4d6800",
        "patch": "@@ -4159,7 +4159,12 @@ void PeerManagerImpl::MaybeSendAddr(CNode& node, std::chrono::microseconds curre\n         // bandwidth cost that we can incur by doing this (which happens\n         // once a day on average).\n         if (node.m_next_local_addr_send != 0us) {\n+            #if ENABLE_RUSTY\n+            rcf_cuckoofilter_free(node.m_addr_known);\n+            node.m_addr_known = rcf_cuckoofilter_with_capacity(5000);\n+            #else\n             node.m_addr_known->reset();\n+            #endif\n         }\n         if (std::optional<CAddress> local_addr = GetLocalAddrForPeer(&node)) {\n             FastRandomContext insecure_rand;\n@@ -4182,8 +4187,13 @@ void PeerManagerImpl::MaybeSendAddr(CNode& node, std::chrono::microseconds curre\n     // Remove addr records that the peer already knows about, and add new\n     // addrs to the m_addr_known filter on the same pass.\n     auto addr_already_known = [&node](const CAddress& addr) {\n+        #if ENABLE_RUSTY\n+        bool ret = (rcf_cuckoofilter_contains(node.m_addr_known, addr.GetHashedKey()) == RCF_OK);\n+        if (!ret) rcf_cuckoofilter_add(node.m_addr_known, addr.GetHashedKey());\n+        #else\n         bool ret = node.m_addr_known->contains(addr.GetKey());\n         if (!ret) node.m_addr_known->insert(addr.GetKey());\n+        #endif\n         return ret;\n     };\n     node.vAddrToSend.erase(std::remove_if(node.vAddrToSend.begin(), node.vAddrToSend.end(), addr_already_known),"
      },
      {
        "sha": "b5a7a2ecf77ec80a6fa0c0b7eb80187c06611ea1",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd78b53d94528764968904b265bc8a629e4d6800/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd78b53d94528764968904b265bc8a629e4d6800/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=dd78b53d94528764968904b265bc8a629e4d6800",
        "patch": "@@ -1014,6 +1014,15 @@ std::vector<unsigned char> CService::GetKey() const\n     return key;\n }\n \n+#if ENABLE_RUSTY\n+// data is rehashed on the Rust side\n+std::size_t CService::GetHashedKey() const\n+{\n+    const std::vector<unsigned char> vec = GetKey();\n+    return MurmurHash3(vec.size(), vec);\n+}\n+#endif\n+\n std::string CService::ToStringPort() const\n {\n     return strprintf(\"%u\", port);"
      },
      {
        "sha": "e4a6026bfbd1daa1804dfc97c8ba96b36369010f",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd78b53d94528764968904b265bc8a629e4d6800/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd78b53d94528764968904b265bc8a629e4d6800/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=dd78b53d94528764968904b265bc8a629e4d6800",
        "patch": "@@ -565,6 +565,9 @@ class CService : public CNetAddr\n         friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n         friend bool operator<(const CService& a, const CService& b);\n         std::vector<unsigned char> GetKey() const;\n+        #if ENABLE_RUSTY\n+        std::size_t GetHashedKey() const;\n+        #endif\n         std::string ToString() const;\n         std::string ToStringPort() const;\n         std::string ToStringIPPort() const;"
      },
      {
        "sha": "39769d63ba0934b52d1e81a98f522148b1f7a208",
        "filename": "src/rusty/README.md",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd78b53d94528764968904b265bc8a629e4d6800/src/rusty/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd78b53d94528764968904b265bc8a629e4d6800/src/rusty/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/README.md?ref=dd78b53d94528764968904b265bc8a629e4d6800",
        "patch": "@@ -0,0 +1,22 @@\n+### Rust Cuckoo Filter\n+\n+Replaces the rolling bloom filter used for [`m_addr_known`](https://github.com/bitcoin/bitcoin/blob/13f24d135b280a9ab947f7948f6d86f00104cde1/src/net.h#L550) with a [Cuckoo Filter](https://github.com/axiomhq/rust-cuckoofilter) written in Rust.\n+\n+Cuckoo filters have some advantages over Bloom filters, including the ability to remove items.\n+\n+See [\"Cuckoo Filter: Practically Better Than Bloom\"](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf):\n+\n+> In many networking systems, Bloom filters are used for high-speed set membership tests. They permit a small fraction of false positive answers with very good space efficiency. However, they do not permit deletion of items from the set, and previous attempts to extend \u201cstandard\u201d Bloom filters to support deletion all degrade either space or performance.\n+\n+> We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set member- ship tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. \n+\n+> For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters out-perform previous data structures that extend Bloom filters to support deletions substantially in both time and space.\n+\n+Requires [`Cargo`](https://doc.rust-lang.org/cargo/) to be installed.\n+```bash\n+./autogen.sh\n+./configure --enable-experimental-rust\n+make\n+make -C src rusty-check\n+src/bitcoind\n+```"
      }
    ]
  }
]