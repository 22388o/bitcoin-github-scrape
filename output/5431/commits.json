[
  {
    "sha": "e958c5a3c9b70d83ba1076b78299f1070a20cae8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTU4YzVhM2M5YjcwZDgzYmExMDc2Yjc4Mjk5ZjEwNzBhMjBjYWU4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-12-06T17:35:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-12-06T17:35:39Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from b0210a9..8a3aa78\n\n8a3aa78 Merge remote-tracking branch 'origin/varnorm' into fast\n518576a Merge remote-tracking branch 'origin/fixes' into fast\n8c6e401 Merge remote-tracking branch 'origin/benches' into fast\nd5ad40c Merge branch 'tweakg' into fast\naff5158 Merge branch 'inlineasm' into fast\n57546ca Merge branch 'fastcheck' into fast\n39bd94d Variable time normalize\nad86bdf Merge pull request #140\n54b768c Another redundant secp256k1_fe_normalize\n69dcaab Merge pull request #139\n1c29f2e Remove redundant secp256k1_fe_normalize from secp256k1_gej_add_ge_var.\n0b32f35 Make the benchmarks print out stats\n2b9388b Remove unused secp256k1_fe_inv_all\nf461b76 Allocate precomputation arrays on the heap\nd444a27 Rename bench_verify to bench_recovery\nb2c9681 Make {mul,sqr}_inner use the same argument order as {mul,sqr}\n6793505 Convert YASM code into inline assembly\nf048615 Rewrite field assembly to match the C version\nda451ea Add explanation about how inversion can be avoided\n3023b03 Optimize verification: avoid field inverse\n3ce74b1 Tweak precomputed table size for G\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 8a3aa782a71fe6549dfc7fa126dfeb9efa02749d",
      "tree": {
        "sha": "d081197435d0a19bce459a8ae7e0bfa7eefb45a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d081197435d0a19bce459a8ae7e0bfa7eefb45a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e958c5a3c9b70d83ba1076b78299f1070a20cae8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e958c5a3c9b70d83ba1076b78299f1070a20cae8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e958c5a3c9b70d83ba1076b78299f1070a20cae8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e958c5a3c9b70d83ba1076b78299f1070a20cae8/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87bddb7a3a83aaad96b5b54b4bac34d8a71b3810",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87bddb7a3a83aaad96b5b54b4bac34d8a71b3810",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87bddb7a3a83aaad96b5b54b4bac34d8a71b3810"
      }
    ],
    "stats": {
      "total": 1681,
      "additions": 903,
      "deletions": 778
    },
    "files": [
      {
        "sha": "390d2c9ffa445ef8086fc9c719cc882f06a85824",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 21,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -1,12 +1,6 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n-if USE_ASM\n-COMMON_LIB = libsecp256k1_common.la\n-else\n-COMMON_LIB =\n-endif\n-noinst_LTLIBRARIES = $(COMMON_LIB)\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n@@ -43,30 +37,30 @@ noinst_HEADERS += src/field_gmp.h\n noinst_HEADERS += src/field_gmp_impl.h\n noinst_HEADERS += src/field.h\n noinst_HEADERS += src/field_impl.h\n+noinst_HEADERS += src/bench.h\n \n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n-if USE_ASM\n-libsecp256k1_common_la_SOURCES = src/field_5x52_asm.asm\n-endif\n-\n libsecp256k1_la_SOURCES = src/secp256k1.c\n libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(COMMON_LIB) $(SECP_LIBS)\n+libsecp256k1_la_LIBADD = $(SECP_LIBS)\n \n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n-noinst_PROGRAMS += bench_verify bench_sign bench_inv\n+noinst_PROGRAMS += bench_verify bench_recover bench_sign bench_inv\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n bench_verify_LDFLAGS = -static\n+bench_recover_SOURCES = src/bench_recover.c\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDFLAGS = -static\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n bench_sign_LDFLAGS = -static\n bench_inv_SOURCES = src/bench_inv.c\n-bench_inv_LDADD = $(COMMON_LIB) $(SECP_LIBS)\n+bench_inv_LDADD = $(SECP_LIBS)\n bench_inv_LDFLAGS = -static\n bench_inv_CPPFLAGS = $(SECP_INCLUDES)\n endif\n@@ -75,15 +69,9 @@ if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n tests_CPPFLAGS = -DVERIFY $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(COMMON_LIB) $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n tests_LDFLAGS = -static\n TESTS = tests\n endif\n \n-EXTRA_DIST = autogen.sh nasm_lt.sh\n-\n-#x86_64 only\n-if USE_ASM\n-.asm.lo:\n-\t$(LIBTOOL) --mode=compile --tag YASM $(srcdir)/nasm_lt.sh $(YASM) -f $(YASM_BINFMT) $(YAFLAGS) -I$(srcdir) -I. $< -o $@\n-endif\n+EXTRA_DIST = autogen.sh"
      },
      {
        "sha": "7163b9480900f004ff6ca8f981cd0a090ca73d11",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 10,
        "deletions": 32,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -11,38 +11,16 @@ fi\n \n dnl \n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n-if test x\"$host_cpu\" == x\"x86_64\"; then\n-  AC_CHECK_PROG(YASM, yasm, yasm)\n-else\n-  if test x\"$set_field\" = x\"64bit_asm\"; then\n-    AC_MSG_ERROR([$set_field field support explicitly requested but is not compatible with this host])\n-  fi\n-fi\n-if test x$YASM = x; then\n-  if test x\"$set_field\" = x\"64bit_asm\"; then\n-    AC_MSG_ERROR([$set_field field support explicitly requested but yasm was not found])\n-  fi\n-  has_64bit_asm=no\n-else\n-  case x\"$host_os\" in\n-  xdarwin*)\n-    YASM_BINFMT=macho64\n-    ;;\n-  x*-gnux32)\n-    YASM_BINFMT=elfx32\n-    ;;\n-  *)\n-    YASM_BINFMT=elf64\n-    ;;\n-  esac\n-  if $YASM -f help | grep -q $YASM_BINFMT; then\n-    has_64bit_asm=yes\n-  else\n-    if test x\"$set_field\" = x\"64bit_asm\"; then\n-      AC_MSG_ERROR([$set_field field support explicitly requested but yasm doesn't support $YASM_BINFMT format])\n-    fi\n-    AC_MSG_WARN([yasm too old for $YASM_BINFMT format])\n-    has_64bit_asm=no\n+AC_MSG_CHECKING(for x86_64 assembly availability)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+  #include <stdint.h>]],[[\n+  uint64_t a = 11, tmp;\n+  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n+AC_MSG_RESULT([$has_64bit_asm])\n+if test x\"$set_field\" == x\"64bit_asm\"; then\n+  if test x\"$has_64bit_asm\" == x\"no\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but no x86_64 assembly available])\n   fi\n fi\n ])"
      },
      {
        "sha": "60a54051576a17d4124b8407b36195f046760023",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -283,7 +283,6 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n-AC_SUBST(YASM_BINFMT)\n AM_CONDITIONAL([USE_ASM], [test x\"$set_field\" == x\"64bit_asm\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" != x\"no\"])"
      },
      {
        "sha": "6cd73294c0617c5d186926f1a7903afbde11044c",
        "filename": "nasm_lt.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 57,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87bddb7a3a83aaad96b5b54b4bac34d8a71b3810/nasm_lt.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87bddb7a3a83aaad96b5b54b4bac34d8a71b3810/nasm_lt.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/nasm_lt.sh?ref=87bddb7a3a83aaad96b5b54b4bac34d8a71b3810",
        "patch": "@@ -1,57 +0,0 @@\n-#! /bin/sh\n-command=\"\"\n-infile=\"\"\n-o_opt=no\n-pic=no\n-while [ $# -gt 0 ]; do\n-    case \"$1\" in\n-        -DPIC|-fPIC|-fpic|-Kpic|-KPIC)\n-            if [ \"$pic\" != \"yes\" ] ; then\n-                command=\"$command -DPIC\"\n-                pic=yes\n-            fi\n-            ;;\n-        -f|-fbin|-faout|-faoutb|-fcoff|-felf|-felf64|-fas86| \\\n-        -fobj|-fwin32|-fwin64|-frdf|-fieee|-fmacho|-fmacho64)\n-            # it's a file format specifier for nasm.\n-            command=\"$command $1\"\n-            ;;\n-        -f*)\n-            # maybe a code-generation flag for gcc.\n-            ;;\n-        -[Ii]*)\n-            incdir=`echo \"$1\" | sed 's/^-[Ii]//'`\n-            if [ \"x$incdir\" = x -a \"x$2\" != x ] ; then\n-                case \"$2\" in\n-                    -*) ;;\n-                    *) incdir=\"$2\"; shift;;\n-                esac\n-            fi\n-            if [ \"x$incdir\" != x ] ; then\n-                # In the case of NASM, the trailing slash is necessary.\n-                incdir=`echo \"$incdir\" | sed 's%/*$%/%'`\n-                command=\"$command -I$incdir\"\n-            fi\n-            ;;\n-        -o*)\n-            o_opt=yes\n-            command=\"$command $1\"\n-            ;;\n-        *.asm)\n-            infile=$1\n-            command=\"$command $1\"\n-            ;;\n-        *)\n-            command=\"$command $1\"\n-            ;;\n-    esac\n-    shift\n-done\n-if [ \"$o_opt\" != yes ] ; then\n-    # By default, NASM creates an output file\n-    # in the same directory as the input file.\n-    outfile=\"-o `echo $infile | sed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.o\"\n-    command=\"$command $outfile\"\n-fi\n-echo $command\n-exec $command"
      },
      {
        "sha": "adcb4afc4ae6aad9445cdd30a85a7b7c70bd8311",
        "filename": "src/bench.h",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -0,0 +1,36 @@\n+/**********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_BENCH_H_\n+#define _SECP256K1_BENCH_H_\n+\n+#include <stdio.h>\n+#include \"sys/time.h\"\n+\n+static double gettimedouble(void) {\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+}\n+\n+void run_benchmark(void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+    double min = 1.0 / 0.0;\n+    double sum = 0.0;\n+    double max = 0.0;\n+    for (int i = 0; i < count; i++) {\n+        if (setup) setup(data);\n+        double begin = gettimedouble();\n+        benchmark(data);\n+        double total = gettimedouble() - begin;\n+        if (teardown) teardown(data);\n+        if (total < min) min = total;\n+        if (total > max) max = total;\n+        sum += total;\n+    }\n+    printf(\"min %.3fus / avg %.3fus / max %.3fus\\n\", min * 1000000.0 / iter, (sum / count) * 1000000.0 / iter, max * 1000000.0 / iter);\n+}\n+\n+#endif"
      },
      {
        "sha": "3bdedea30e47119ade683786573e38a1642da2f1",
        "filename": "src/bench_inv.c",
        "status": "modified",
        "additions": 28,
        "deletions": 17,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_inv.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_inv.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_inv.c?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -12,30 +12,41 @@\n #include \"field_impl.h\"\n #include \"group_impl.h\"\n #include \"scalar_impl.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_scalar_t base, x;\n+} bench_inv_t;\n+\n+void bench_inv_setup(void* arg) {\n+    bench_inv_t *data = (bench_inv_t*)arg;\n \n-int main(void) {\n     static const unsigned char init[32] = {\n         0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n         0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n         0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n         0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n     };\n-    static const unsigned char fini[32] = {\n-        0xba, 0x28, 0x58, 0xd8, 0xaa, 0x11, 0xd6, 0xf2,\n-        0xfa, 0xce, 0x50, 0xb1, 0x67, 0x19, 0xb1, 0xa6,\n-        0xe0, 0xaa, 0x84, 0x53, 0xf6, 0x80, 0xfc, 0x23,\n-        0x88, 0x3c, 0xd6, 0x74, 0x9f, 0x27, 0x09, 0x03\n-    };\n-    secp256k1_ge_start();\n-    secp256k1_scalar_t base, x;\n-    secp256k1_scalar_set_b32(&base, init, NULL);\n-    secp256k1_scalar_set_b32(&x, init, NULL);\n-    for (int i=0; i<1000000; i++) {\n-        secp256k1_scalar_inverse(&x, &x);\n-        secp256k1_scalar_add(&x, &x, &base);\n+\n+    secp256k1_scalar_set_b32(&data->base, init, NULL);\n+    secp256k1_scalar_set_b32(&data->x, init, NULL);\n+}\n+\n+void bench_inv(void* arg) {\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (int i=0; i<20000; i++) {\n+        secp256k1_scalar_inverse(&data->x, &data->x);\n+        secp256k1_scalar_add(&data->x, &data->x, &data->base);\n     }\n-    unsigned char res[32];\n-    secp256k1_scalar_get_b32(res, &x);\n-    CHECK(memcmp(res, fini, 32) == 0);\n+}\n+\n+int main(void) {\n+    secp256k1_ge_start();\n+\n+    bench_inv_t data;\n+    run_benchmark(bench_inv, bench_inv_setup, NULL, &data, 10, 20000);\n+\n+    secp256k1_ge_stop();\n     return 0;\n }"
      },
      {
        "sha": "286ad064de661acc878b577cd8c34a3bf612a06c",
        "filename": "src/bench_recover.c",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -0,0 +1,46 @@\n+/**********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    unsigned char msg[32];\n+    unsigned char sig[64];\n+} bench_recover_t;\n+\n+void bench_recover(void* arg) {\n+    bench_recover_t *data = (bench_recover_t*)arg;\n+\n+    unsigned char pubkey[33];\n+    for (int i=0; i<20000; i++) {\n+        int pubkeylen = 33;\n+        CHECK(secp256k1_ecdsa_recover_compact(data->msg, 32, data->sig, pubkey, &pubkeylen, 1, i % 2));\n+        for (int j = 0; j < 32; j++) {\n+            data->sig[j + 32] = data->msg[j];    /* Move former message to S. */\n+            data->msg[j] = data->sig[j];         /* Move former R to message. */\n+            data->sig[j] = pubkey[j + 1];        /* Move recovered pubkey X coordinate to R (which must be a valid X coordinate). */\n+        }\n+    }\n+}\n+\n+void bench_recover_setup(void* arg) {\n+    bench_recover_t *data = (bench_recover_t*)arg;\n+\n+    for (int i = 0; i < 32; i++) data->msg[i] = 1 + i;\n+    for (int i = 0; i < 64; i++) data->sig[i] = 65 + i;\n+}\n+\n+int main(void) {\n+    secp256k1_start(SECP256K1_START_VERIFY);\n+\n+    bench_recover_t data;\n+    run_benchmark(bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n+\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "0b33e77396d58d064ef8edfd7c5a1615d554719c",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 24,
        "deletions": 25,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -3,46 +3,45 @@\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n-#include <stdio.h>\n-#include <string.h>\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n+#include \"bench.h\"\n \n-int main(void) {\n-    secp256k1_start(SECP256K1_START_SIGN);\n-\n+typedef struct {\n     unsigned char msg[32];\n     unsigned char nonce[32];\n     unsigned char key[32];\n+} bench_sign_t;\n \n-    for (int i = 0; i < 32; i++) msg[i] = i + 1;\n-    for (int i = 0; i < 32; i++) nonce[i] = i + 33;\n-    for (int i = 0; i < 32; i++) key[i] = i + 65;\n+static void bench_sign_setup(void* arg) {\n+    bench_sign_t *data = (bench_sign_t*)arg;\n \n-    unsigned char sig[64];\n+    for (int i = 0; i < 32; i++) data->msg[i] = i + 1;\n+    for (int i = 0; i < 32; i++) data->nonce[i] = i + 33;\n+    for (int i = 0; i < 32; i++) data->key[i] = i + 65;\n+}\n+\n+static void bench_sign(void* arg) {\n+    bench_sign_t *data = (bench_sign_t*)arg;\n \n-    for (int i=0; i<1000000; i++) {\n+    unsigned char sig[64];\n+    for (int i=0; i<20000; i++) {\n         int recid = 0;\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, 32, sig, key, nonce, &recid));\n+        CHECK(secp256k1_ecdsa_sign_compact(data->msg, 32, sig, data->key, data->nonce, &recid));\n         for (int j = 0; j < 32; j++) {\n-            nonce[j] = key[j];     /* Move former key to nonce  */\n-            msg[j] = sig[j];       /* Move former R to message. */\n-            key[j] = sig[j + 32];  /* Move former S to key.     */\n+            data->nonce[j] = data->key[j];     /* Move former key to nonce  */\n+            data->msg[j] = sig[j];             /* Move former R to message. */\n+            data->key[j] = sig[j + 32];        /* Move former S to key.     */\n         }\n     }\n+}\n+\n+int main(void) {\n+    secp256k1_start(SECP256K1_START_SIGN);\n \n-    static const unsigned char fini[64] = {\n-        0x92, 0x03, 0xef, 0xf1, 0x58, 0x0b, 0x49, 0x8d,\n-        0x22, 0x3d, 0x49, 0x0e, 0xbf, 0x26, 0x50, 0x0e,\n-        0x2d, 0x62, 0x90, 0xd7, 0x82, 0xbd, 0x3d, 0x5c,\n-        0xa9, 0x10, 0xa5, 0x49, 0xb1, 0xd8, 0x8c, 0xc0,\n-        0x5b, 0x5e, 0x9e, 0x68, 0x51, 0x3d, 0xe8, 0xec,\n-        0x82, 0x30, 0x82, 0x88, 0x8c, 0xfd, 0xe7, 0x71,\n-        0x15, 0x92, 0xfc, 0x14, 0x59, 0x78, 0x31, 0xb3,\n-        0xf6, 0x07, 0x91, 0x18, 0x00, 0x8d, 0x4c, 0xb2\n-    };\n-    CHECK(memcmp(sig, fini, 64) == 0);\n+    bench_sign_t data;\n+    run_benchmark(bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "a2f633d3451e710d987d8de5ce1ad3050588ea49",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 35,
        "deletions": 24,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -9,35 +9,46 @@\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n+#include \"bench.h\"\n \n-int main(void) {\n-    secp256k1_start(SECP256K1_START_VERIFY);\n-\n+typedef struct {\n     unsigned char msg[32];\n-    unsigned char sig[64];\n-\n-    for (int i = 0; i < 32; i++) msg[i] = 1 + i;\n-    for (int i = 0; i < 64; i++) sig[i] = 65 + i;\n-\n+    unsigned char key[32];\n+    unsigned char nonce[32];\n+    unsigned char sig[72];\n+    int siglen;\n     unsigned char pubkey[33];\n-    for (int i=0; i<1000000; i++) {\n-        int pubkeylen = 33;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg, 32, sig, pubkey, &pubkeylen, 1, i % 2));\n-        for (int j = 0; j < 32; j++) {\n-            sig[j + 32] = msg[j];    /* Move former message to S. */\n-            msg[j] = sig[j];         /* Move former R to message. */\n-            sig[j] = pubkey[j + 1];  /* Move recovered pubkey X coordinate to R (which must be a valid X coordinate). */\n-        }\n+    int pubkeylen;\n+} benchmark_verify_t;\n+\n+static void benchmark_verify(void* arg) {\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (int i=0; i<20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        CHECK(secp256k1_ecdsa_verify(data->msg, 32, data->sig, data->siglen, data->pubkey, data->pubkeylen) == (i == 0));\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n     }\n+}\n+\n+int main(void) {\n+    secp256k1_start(SECP256K1_START_VERIFY | SECP256K1_START_SIGN);\n+\n+    benchmark_verify_t data;\n+\n+    for (int i = 0; i < 32; i++) data.msg[i] = 1 + i;\n+    for (int i = 0; i < 32; i++) data.key[i] = 33 + i;\n+    for (int i = 0; i < 32; i++) data.nonce[i] = 65 + i;\n+    data.siglen = 72;\n+    CHECK(secp256k1_ecdsa_sign(data.msg, 32, data.sig, &data.siglen, data.key, data.nonce));\n+    data.pubkeylen = 33;\n+    CHECK(secp256k1_ec_pubkey_create(data.pubkey, &data.pubkeylen, data.key, 1));\n \n-    static const unsigned char fini[33] = {\n-        0x02,\n-        0x52, 0x63, 0xae, 0x9a, 0x9d, 0x47, 0x1f, 0x1a,\n-        0xb2, 0x36, 0x65, 0x89, 0x11, 0xe7, 0xcc, 0x86,\n-        0xa3, 0xab, 0x97, 0xb6, 0xf1, 0xaf, 0xfd, 0x8f,\n-        0x9b, 0x38, 0xb6, 0x18, 0x55, 0xe5, 0xc2, 0x43\n-    };\n-    CHECK(memcmp(fini, pubkey, 33) == 0);\n+    run_benchmark(benchmark_verify, NULL, NULL, &data, 10, 20000);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "0a2e8962a34ea82556a0db57a8820d6edcc149f6",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 18,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -38,7 +38,7 @@ static void secp256k1_ecdsa_start(void) {\n \n     secp256k1_fe_set_b32(&ret->order_as_fe, order);\n     secp256k1_fe_negate(&ret->p_minus_order, &ret->order_as_fe, 1);\n-    secp256k1_fe_normalize(&ret->p_minus_order);\n+    secp256k1_fe_normalize_var(&ret->p_minus_order);\n \n     /* Set the global pointer. */\n     secp256k1_ecdsa_consts = ret;\n@@ -109,25 +109,51 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const se\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_recompute(secp256k1_scalar_t *r2, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n     if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s))\n         return 0;\n \n-    int ret = 0;\n     secp256k1_scalar_t sn, u1, u2;\n     secp256k1_scalar_inverse_var(&sn, &sig->s);\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, &sig->r);\n     secp256k1_gej_t pubkeyj; secp256k1_gej_set_ge(&pubkeyj, pubkey);\n     secp256k1_gej_t pr; secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n-    if (!secp256k1_gej_is_infinity(&pr)) {\n-        secp256k1_fe_t xr; secp256k1_gej_get_x_var(&xr, &pr);\n-        secp256k1_fe_normalize(&xr);\n-        unsigned char xrb[32]; secp256k1_fe_get_b32(xrb, &xr);\n-        secp256k1_scalar_set_b32(r2, xrb, NULL);\n-        ret = 1;\n+    if (secp256k1_gej_is_infinity(&pr)) {\n+        return 0;\n+    }\n+    unsigned char c[32];\n+    secp256k1_scalar_get_b32(c, &sig->r);\n+    secp256k1_fe_t xr;\n+    secp256k1_fe_set_b32(&xr, c);\n+\n+    // We now have the recomputed R point in pr, and its claimed x coordinate (modulo the order)\n+    // in xr. Naively, we would extract the x coordinate from pr (requiring a inversion modulo p),\n+    // compute the remainder modulo the order, and compare it to xr. However:\n+    //\n+    //   x(R) mod n == xr\n+    //   <=> exists h. (x(R) + h * order < p && x(R) == xr + h * order)\n+    //   [Since 2 * order > p, h can only be 0 or 1]\n+    //   <=> (x(R) == xr) || (xr + order < p && x(R) == xr + order)\n+    //   <=> (R.x / R.z^2 mod p == xr) || (xr + order < p && R.x / R.z^2 mod p == xr + order)\n+    //   <=> (R.x == xr * R.z^2 mod p) || (xr + order < p && R.x == (xr + order) * R.z^2 mod p)\n+    //\n+    // Thus, we can avoid the inversion, but we have to check both cases separately.\n+    // secp256k1_gej_eq_x implements the (R.x == xr*R.z^2 mod p) test.\n+    if (secp256k1_gej_eq_x_var(&xr, &pr)) {\n+        // R.x == xr * R.z^2 mod p, so the signature is valid.\n+        return 1;\n+    }\n+    if (secp256k1_fe_cmp_var(&xr, &secp256k1_ecdsa_consts->p_minus_order) >= 0) {\n+        // xr + order >= n, so we can skip testing the second case.\n+        return 0;\n     }\n-    return ret;\n+    secp256k1_fe_add(&xr, &secp256k1_ecdsa_consts->order_as_fe);\n+    if (secp256k1_gej_eq_x_var(&xr, &pr)) {\n+        // R.x == (xr + order) * R.z^2 mod p, so the signature is valid.\n+        return 1;\n+    }\n+    return 0;\n }\n \n static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid) {\n@@ -144,7 +170,7 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256\n         secp256k1_fe_add(&fx, &secp256k1_ecdsa_consts->order_as_fe);\n     }\n     secp256k1_ge_t x;\n-    if (!secp256k1_ge_set_xo(&x, &fx, recid & 1))\n+    if (!secp256k1_ge_set_xo_var(&x, &fx, recid & 1))\n         return 0;\n     secp256k1_gej_t xj;\n     secp256k1_gej_set_ge(&xj, &x);\n@@ -159,13 +185,6 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256\n     return !secp256k1_gej_is_infinity(&qj);\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n-    secp256k1_scalar_t r2;\n-    int ret = 0;\n-    ret = secp256k1_ecdsa_sig_recompute(&r2, sig, pubkey, message) && secp256k1_scalar_eq(&sig->r, &r2);\n-    return ret;\n-}\n-\n static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n     secp256k1_gej_t rp;\n     secp256k1_ecmult_gen(&rp, nonce);"
      },
      {
        "sha": "b3fa7d9bd21a974e755e0c9f0d475e9808a264f3",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -17,7 +17,7 @@\n static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size) {\n     if (size == 33 && (pub[0] == 0x02 || pub[0] == 0x03)) {\n         secp256k1_fe_t x;\n-        return secp256k1_fe_set_b32(&x, pub+1) && secp256k1_ge_set_xo(elem, &x, pub[0] == 0x03);\n+        return secp256k1_fe_set_b32(&x, pub+1) && secp256k1_ge_set_xo_var(elem, &x, pub[0] == 0x03);\n     } else if (size == 65 && (pub[0] == 0x04 || pub[0] == 0x06 || pub[0] == 0x07)) {\n         secp256k1_fe_t x, y;\n         if (!secp256k1_fe_set_b32(&x, pub+1) || !secp256k1_fe_set_b32(&y, pub+33)) {\n@@ -26,7 +26,7 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned cha\n         secp256k1_ge_set_xy(elem, &x, &y);\n         if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07))\n             return 0;\n-        return secp256k1_ge_is_valid(elem);\n+        return secp256k1_ge_is_valid_var(elem);\n     } else {\n         return 0;\n     }\n@@ -36,8 +36,8 @@ static int secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char\n     if (secp256k1_ge_is_infinity(elem)) {\n         return 0;\n     }\n-    secp256k1_fe_normalize(&elem->x);\n-    secp256k1_fe_normalize(&elem->y);\n+    secp256k1_fe_normalize_var(&elem->x);\n+    secp256k1_fe_normalize_var(&elem->y);\n     secp256k1_fe_get_b32(&pub[1], &elem->x);\n     if (compressed) {\n         *size = 33;"
      },
      {
        "sha": "6f154f2be04d670a4e2917052ace7b28f6cea09c",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ecmult_gen_start(void) {\n         secp256k1_fe_t nums_x;\n         VERIFY_CHECK(secp256k1_fe_set_b32(&nums_x, nums_b32));\n         secp256k1_ge_t nums_ge;\n-        VERIFY_CHECK(secp256k1_ge_set_xo(&nums_ge, &nums_x, 0));\n+        VERIFY_CHECK(secp256k1_ge_set_xo_var(&nums_ge, &nums_x, 0));\n         secp256k1_gej_set_ge(&nums_gej, &nums_ge);\n         /* Add G to make the bits in x uniformly distributed. */\n         secp256k1_gej_add_ge_var(&nums_gej, &nums_gej, g);\n@@ -73,7 +73,7 @@ static void secp256k1_ecmult_gen_start(void) {\n             secp256k1_gej_double_var(&numsbase, &numsbase);\n             if (j == 62) {\n                 /* In the last iteration, numsbase is (1 - 2^j) * nums instead. */\n-                secp256k1_gej_neg(&numsbase, &numsbase);\n+                secp256k1_gej_neg_var(&numsbase, &numsbase);\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej);\n             }\n         }"
      },
      {
        "sha": "6f386ca6129392a38936e79d1305e6e17a02f8ff",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -15,11 +15,13 @@\n #define WINDOW_A 5\n \n /** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. WINDOW_G == 14 results in 640 KiB. */\n+    exponentially larger precomputed tables. */\n #ifdef USE_ENDOMORPHISM\n-#define WINDOW_G 14\n-#else\n+/** Two tables for window size 15: 1.375 MiB. */\n #define WINDOW_G 15\n+#else\n+/** One table for window size 16: 1.375 MiB. */\n+#define WINDOW_G 16\n #endif\n \n /** Fill a table 'pre' with precomputed odd multiples of a. W determines the size of the table.\n@@ -43,13 +45,14 @@ static void secp256k1_ecmult_table_precomp_gej_var(secp256k1_gej_t *pre, const s\n \n static void secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const secp256k1_gej_t *a, int w) {\n     const int table_size = 1 << (w-2);\n-    secp256k1_gej_t prej[table_size];\n+    secp256k1_gej_t *prej = malloc(sizeof(secp256k1_gej_t) * table_size);\n     prej[0] = *a;\n     secp256k1_gej_t d; secp256k1_gej_double_var(&d, a);\n     for (int i=1; i<table_size; i++) {\n         secp256k1_gej_add_var(&prej[i], &d, &prej[i-1]);\n     }\n     secp256k1_ge_set_all_gej_var(table_size, pre, prej);\n+    free(prej);\n }\n \n /** The number of entries a table with precomputed multiples needs to have. */\n@@ -67,8 +70,8 @@ static void secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const sec\n         (neg)((r), &(pre)[(-(n)-1)/2]); \\\n } while(0)\n \n-#define ECMULT_TABLE_GET_GEJ(r,pre,n,w) ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_gej_neg)\n-#define ECMULT_TABLE_GET_GE(r,pre,n,w)  ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_ge_neg)\n+#define ECMULT_TABLE_GET_GEJ(r,pre,n,w) ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_gej_neg_var)\n+#define ECMULT_TABLE_GET_GE(r,pre,n,w)  ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_ge_neg_var)\n \n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */"
      },
      {
        "sha": "53aa29e13fd563b6f65db1bb240340d36970073e",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -50,6 +50,9 @@ static void secp256k1_fe_stop(void);\n /** Normalize a field element. */\n static void secp256k1_fe_normalize(secp256k1_fe_t *r);\n \n+/** Normalize a field element, without constant-time guarantee. */\n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r);\n+\n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a);\n \n@@ -93,7 +96,7 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n /** Sets a field element to be the (modular) square root (if any exist) of another. Requires the\n  *  input's magnitude to be at most 8. The output magnitude is 1 (but not guaranteed to be\n  *  normalized). Return value indicates whether a square root was found. */\n-static int secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+static int secp256k1_fe_sqrt_var(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n@@ -105,9 +108,6 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n /** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n  *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n  *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n-\n-/** Potentially faster version of secp256k1_fe_inv_all, without constant-time guarantee. */\n static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n \n /** Convert a field element to a hexadecimal string. */"
      },
      {
        "sha": "d20229cda6b955615961916fde4138ceae8cdd60",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 60,
        "deletions": 4,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -103,6 +103,62 @@ static void secp256k1_fe_normalize(secp256k1_fe_t *r) {\n #endif\n }\n \n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r) {\n+    uint32_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4],\n+             t5 = r->n[5], t6 = r->n[6], t7 = r->n[7], t8 = r->n[8], t9 = r->n[9];\n+\n+    /* Reduce t9 at the start so there will be at most a single carry from the first pass */\n+    uint32_t x = t9 >> 22; t9 &= 0x03FFFFFUL;\n+    uint32_t m;\n+\n+    /* The first pass ensures the magnitude is 1, ... */\n+    t0 += x * 0x3D1UL; t1 += (x << 6);\n+    t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+    t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+    t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL; m = t2;\n+    t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL; m &= t3;\n+    t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL; m &= t4;\n+    t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL; m &= t5;\n+    t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL; m &= t6;\n+    t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL; m &= t7;\n+    t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL; m &= t8;\n+\n+    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */\n+    VERIFY_CHECK(t9 >> 23 == 0);\n+\n+    /* At most a single final reduction is needed; check if the value is >= the field characteristic */\n+    x = (t9 >> 22) | ((t9 == 0x03FFFFFUL) & (m == 0x3FFFFFFUL)\n+        & ((t1 + 0x40UL + ((t0 + 0x3D1UL) >> 26)) > 0x3FFFFFFUL));\n+\n+    if (x) {\n+        t0 += 0x3D1UL; t1 += (x << 6);\n+        t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+        t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+        t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL;\n+        t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL;\n+        t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL;\n+        t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL;\n+        t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL;\n+        t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL;\n+        t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL;\n+\n+        /* If t9 didn't carry to bit 22 already, then it should have after any final reduction */\n+        VERIFY_CHECK(t9 >> 22 == x);\n+\n+        /* Mask off the possible multiple of 2^256 from the final reduction */\n+        t9 &= 0x03FFFFFUL;\n+    }\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+    r->n[5] = t5; r->n[6] = t6; r->n[7] = t7; r->n[8] = t8; r->n[9] = t9;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n@@ -271,7 +327,7 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1\n #define VERIFY_BITS(x, n) do { } while(0)\n #endif\n \n-SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b, uint32_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b) {\n     VERIFY_BITS(a[0], 30);\n     VERIFY_BITS(a[1], 30);\n     VERIFY_BITS(a[2], 30);\n@@ -598,7 +654,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint32_t *a, const uin\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n \n-SECP256K1_INLINE static void secp256k1_fe_sqr_inner(const uint32_t *a, uint32_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a) {\n     VERIFY_BITS(a[0], 30);\n     VERIFY_BITS(a[1], 30);\n     VERIFY_BITS(a[2], 30);\n@@ -879,7 +935,7 @@ static void secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const s\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n #endif\n-    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+    secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;\n@@ -892,7 +948,7 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     VERIFY_CHECK(a->magnitude <= 8);\n     secp256k1_fe_verify(a);\n #endif\n-    secp256k1_fe_sqr_inner(a->n, r->n);\n+    secp256k1_fe_sqr_inner(r->n, a->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;"
      },
      {
        "sha": "5e785f763055eaf695f92116dc3582a0985bf71d",
        "filename": "src/field_5x52_asm.asm",
        "status": "removed",
        "additions": 0,
        "deletions": 469,
        "changes": 469,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87bddb7a3a83aaad96b5b54b4bac34d8a71b3810/src/field_5x52_asm.asm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87bddb7a3a83aaad96b5b54b4bac34d8a71b3810/src/field_5x52_asm.asm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_asm.asm?ref=87bddb7a3a83aaad96b5b54b4bac34d8a71b3810",
        "patch": "@@ -1,469 +0,0 @@\n-\t;; Added by Diederik Huys, March 2013\n-\t;;\n-\t;; Provided public procedures:\n-\t;; \tsecp256k1_fe_mul_inner\n-\t;; \tsecp256k1_fe_sqr_inner\n-\t;;\n-\t;; Needed tools: YASM (http://yasm.tortall.net)\n-\t;;\n-\t;; \n-\n-\tBITS 64\n-\n-%ifidn   __OUTPUT_FORMAT__,macho64\n-%define SYM(x) _ %+ x\n-%else\n-%define SYM(x) x\n-%endif\n-\n-\t;;  Procedure ExSetMult\n-\t;;  Register Layout:\n-\t;;  INPUT: \trdi\t= a->n\n-\t;; \t   \trsi  \t= b->n\n-\t;; \t   \trdx  \t= r->a\n-\t;; \n-\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n-\t;; \t\tr9:r8    = c\n-\t;; \t\tr10-r13  = t0-t3\n-\t;; \t\tr14\t = b.n[0] / t4\n-\t;; \t\tr15\t = b.n[1] / t5\n-\t;; \t\trbx\t = b.n[2] / t6\n-\t;; \t\trcx\t = b.n[3] / t7\n-\t;; \t\trbp\t = Constant 0FFFFFFFFFFFFFh / t8\n-\t;; \t\trsi\t = b.n / b.n[4] / t9\n-\n-\tGLOBAL SYM(secp256k1_fe_mul_inner)\n-\tALIGN 32\n-SYM(secp256k1_fe_mul_inner):\n-\tpush rbp\n-\tpush rbx\n-\tpush r12\n-\tpush r13\n-\tpush r14\n-\tpush r15\n-\tpush rdx\n-\tmov r14,[rsi+8*0]\t; preload b.n[0]. This will be the case until\n-\t\t\t\t; b.n[0] is no longer needed, then we reassign\n-\t\t\t\t; r14 to t4\n-\t;; c=a.n[0] * b.n[0]\n-   \tmov rax,[rdi+0*8]\t; load a.n[0]\n-\tmov rbp,0FFFFFFFFFFFFFh\n-\tmul r14\t\t\t; rdx:rax=a.n[0]*b.n[0]\n-\tmov r15,[rsi+1*8]\n-\tmov r10,rbp\t\t; load modulus into target register for t0\n-\tmov r8,rax\n-\tand r10,rax\t\t; only need lower qword of c\n-\tshrd r8,rdx,52\n-\txor r9,r9\t\t; c < 2^64, so we ditch the HO part \n-\n-\t;; c+=a.n[0] * b.n[1] + a.n[1] * b.n[0]\n-\tmov rax,[rdi+0*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul r14\t\t\t\n-\tmov r11,rbp\n-\tmov rbx,[rsi+2*8]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r11,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\t;; c+=a.n[0 1 2] * b.n[2 1 0]\n-\tmov rax,[rdi+0*8]\n-\tmul rbx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul r14\n-\tmov r12,rbp\t\t\n-\tmov rcx,[rsi+3*8]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r12,r8\t\t\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[0 1 2 3] * b.n[3 2 1 0]\n-\tmov rax,[rdi+0*8]\n-\tmul rcx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul rbx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\t\n-\tmov rax,[rdi+3*8]\n-\tmul r14\t\t\t\n-\tmov r13,rbp             \n-\tmov rsi,[rsi+4*8]\t; load b.n[4] and destroy pointer\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r13,r8\n-\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\n-\t;; c+=a.n[0 1 2 3 4] * b.n[4 3 2 1 0]\n-\tmov rax,[rdi+0*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul rbx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+3*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul r14\t\t\t\n-\tmov r14,rbp             ; load modulus into t4 and destroy a.n[0]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r14,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[1 2 3 4] * b.n[4 3 2 1]\n-\tmov rax,[rdi+1*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+3*8]\n-\tmul rbx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul r15\n-\tmov r15,rbp\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tand r15,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[2 3 4] * b.n[4 3 2]\n-\tmov rax,[rdi+2*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+3*8]\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul rbx\n-\tmov rbx,rbp\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tand rbx,r8\t\t\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[3 4] * b.n[4 3]\n-\tmov rax,[rdi+3*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul rcx\n-\tmov rcx,rbp\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rcx,r8\t\t\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[4] * b.n[4]\n-\tmov rax,[rdi+4*8]\n-\tmul rsi\n-\t;; mov rbp,rbp\t\t; modulus already there!\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rbp,r8 \n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\tmov rsi,r8\t\t; load c into t9 and destroy b.n[4]\n-\n-\t;; *******************************************************\n-common_exit_norm:\n-\tmov rdi,01000003D10h\t; load constant\n-\n-\tmov rax,r15\t\t; get t5\n-\tmul rdi\n-\tadd rax,r10    \t\t; +t0\n-\tadc rdx,0\n-\tmov r10,0FFFFFFFFFFFFFh ; modulus. Sadly, we ran out of registers!\n-\tmov r8,rax\t\t; +c\n-\tand r10,rax\n-\tshrd r8,rdx,52\n-\txor r9,r9\n-\n-\tmov rax,rbx\t\t; get t6\n-\tmul rdi\n-\tadd rax,r11\t\t; +t1\n-\tadc rdx,0\n-\tmov r11,0FFFFFFFFFFFFFh ; modulus\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r11,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\n-\tmov rax,rcx    \t\t; get t7\n-\tmul rdi\n-\tadd rax,r12\t\t; +t2\n-\tadc rdx,0\n-\tpop rbx\t\t\t; retrieve pointer to this.n\t\n-\tmov r12,0FFFFFFFFFFFFFh ; modulus\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r12,r8\n-\tmov [rbx+2*8],r12\t; mov into this.n[2]\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\tmov rax,rbp    \t\t; get t8\n-\tmul rdi\n-\tadd rax,r13    \t\t; +t3\n-\tadc rdx,0\n-\tmov r13,0FFFFFFFFFFFFFh ; modulus\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r13,r8\n-\tmov [rbx+3*8],r13\t; -> this.n[3]\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\tmov rax,rsi    \t\t; get t9\n-\tmul rdi\n-\tadd rax,r14    \t\t; +t4\n-\tadc rdx,0\n-\tmov r14,0FFFFFFFFFFFFh\t; !!!\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r14,r8\n-\tmov [rbx+4*8],r14\t; -> this.n[4]\n-\tshrd r8,r9,48\t\t; !!!\n-\txor r9,r9\n-\t\n-\tmov rax,01000003D1h\n-\tmul r8\t\t\n-\tadd rax,r10\n-\tadc rdx,0\n-\tmov r10,0FFFFFFFFFFFFFh ; modulus\n-\tmov r8,rax\n-\tand rax,r10\n-\tshrd r8,rdx,52\n-\tmov [rbx+0*8],rax\t; -> this.n[0]\n-\tadd r8,r11\n-\tmov [rbx+1*8],r8\t; -> this.n[1]\n-\n-\tpop r15\n-\tpop r14\n-\tpop r13\n-\tpop r12\n-\tpop rbx\n-\tpop rbp\n-\tret\n-\n-\t\n-\t;;  PROC ExSetSquare\n-\t;;  Register Layout:\n-\t;;  INPUT: \trdi\t = a.n\n-\t;; \t   \trsi  \t = this.a\n-\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n-\t;; \t\tr9:r8    = c\n-\t;; \t\tr10-r13  = t0-t3\n-\t;; \t\tr14\t = a.n[0] / t4\n-\t;; \t\tr15\t = a.n[1] / t5\n-\t;; \t\trbx\t = a.n[2] / t6\n-\t;; \t\trcx\t = a.n[3] / t7\n-\t;; \t\trbp\t = 0FFFFFFFFFFFFFh / t8\n-\t;; \t\trsi\t = a.n[4] / t9\n-\tGLOBAL SYM(secp256k1_fe_sqr_inner)\n-\tALIGN 32\n-SYM(secp256k1_fe_sqr_inner):\n-\tpush rbp\n-\tpush rbx\n-\tpush r12\n-\tpush r13\n-\tpush r14\n-\tpush r15\n-\tpush rsi\n-\tmov rbp,0FFFFFFFFFFFFFh\n-\t\n-\t;; c=a.n[0] * a.n[0]\n-   \tmov r14,[rdi+0*8]\t; r14=a.n[0]\n-\tmov r10,rbp\t\t; modulus \n-\tmov rax,r14\n-\tmul rax\n-\tmov r15,[rdi+1*8]\t; a.n[1]\n-\tadd r14,r14\t\t; r14=2*a.n[0]\n-\tmov r8,rax\n-\tand r10,rax\t\t; only need lower qword\n-\tshrd r8,rdx,52\n-\txor r9,r9\n-\n-\t;; c+=2*a.n[0] * a.n[1]\n-\tmov rax,r14\t\t; r14=2*a.n[0]\n-\tmul r15\n-\tmov rbx,[rdi+2*8]\t; rbx=a.n[2]\n-\tmov r11,rbp \t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r11,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\t;; c+=2*a.n[0]*a.n[2]+a.n[1]*a.n[1]\n-\tmov rax,r14\n-\tmul rbx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,r15\n-\tmov r12,rbp\t\t; modulus\n-\tmul rax\n-\tmov rcx,[rdi+3*8]\t; rcx=a.n[3]\n-\tadd r15,r15\t\t; r15=a.n[1]*2\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r12,r8\t\t; only need lower dword\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[0]*a.n[3]+2*a.n[1]*a.n[2]\n-\tmov rax,r14\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,r15\t\t; rax=2*a.n[1]\n-\tmov r13,rbp\t\t; modulus\n-\tmul rbx\n-\tmov rsi,[rdi+4*8]\t; rsi=a.n[4]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r13,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[0]*a.n[4]+2*a.n[1]*a.n[3]+a.n[2]*a.n[2]\n-\tmov rax,r14\t\t; last time we need 2*a.n[0]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,r15\n-\tmul rcx\n-\tmov r14,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,rbx\n-\tmul rax\n-\tadd rbx,rbx\t\t; rcx=2*a.n[2]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r14,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[1]*a.n[4]+2*a.n[2]*a.n[3]\n-\tmov rax,r15\t\t; last time we need 2*a.n[1]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,rbx\n-\tmul rcx\n-\tmov r15,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r15,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[2]*a.n[4]+a.n[3]*a.n[3]\n-\tmov rax,rbx\t\t; last time we need 2*a.n[2]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,rcx\t\t; a.n[3]\n-\tmul rax\n-\tmov rbx,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rbx,r8\t\t; only need lower dword\n-\tlea rax,[2*rcx]\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[3]*a.n[4]\n-\tmul rsi\n-\tmov rcx,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rcx,r8\t\t; only need lower dword\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[4]*a.n[4]\n-\tmov rax,rsi\n-\tmul rax\n-\t;; mov rbp,rbp\t\t; modulus is already there!\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rbp,r8 \n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\tmov rsi,r8\n-\n-\t;; *******************************************************\n-\tjmp common_exit_norm\n-\tend\n-\n-\t"
      },
      {
        "sha": "af12fd30d2cf629e18fb8be72b2277d9f04528d2",
        "filename": "src/field_5x52_asm_impl.h",
        "status": "modified",
        "additions": 492,
        "deletions": 3,
        "changes": 495,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_5x52_asm_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_5x52_asm_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_asm_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -1,13 +1,502 @@\n /**********************************************************************\n- * Copyright (c) 2013 Pieter Wuille                                   *\n+ * Copyright (c) 2013-2014 Diederik Huys, Pieter Wuille               *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+/**\n+ * Changelog:\n+ * - March 2013, Diederik Huys:    original version\n+ * - November 2014, Pieter Wuille: updated to use Peter Dettman's parallel multiplication algorithm\n+ * - December 2014, Pieter Wuille: converted from YASM to GCC inline assembly\n+ */\n+\n #ifndef _SECP256K1_FIELD_INNER5X52_IMPL_H_\n #define _SECP256K1_FIELD_INNER5X52_IMPL_H_\n \n-void __attribute__ ((sysv_abi)) secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t *b, uint64_t *r);\n-void __attribute__ ((sysv_abi)) secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r);\n+SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b) {\n+/**\n+ * Registers: rdx:rax = multiplication accumulator\n+ *            r9:r8   = c\n+ *            r15:rcx = d\n+ *            r10-r14 = a0-a4\n+ *            rbx     = b\n+ *            %2      = r\n+ *            %0      = a / t?\n+ *            rbp     = R (0x1000003d10)\n+ */\n+__asm__ __volatile__(\n+    \"pushq %%rbp\\n\"\n+\n+    \"movq 0(%0),%%r10\\n\"\n+    \"movq 8(%0),%%r11\\n\"\n+    \"movq 16(%0),%%r12\\n\"\n+    \"movq 24(%0),%%r13\\n\"\n+    \"movq 32(%0),%%r14\\n\"\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+\n+    /* d += a3 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"movq %%rax,%%rcx\\n\"\n+    \"movq %%rdx,%%r15\\n\"\n+    /* d += a2 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a1 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d = a0 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* c = a4 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += (c & M) * R */\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* t3 (stack) = d & M */\n+    \"movq %%rcx,%0\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* d += a4 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a2 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a1 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a0 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += c * R */\n+    \"movq %%r8,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* t4 = d & M (%0) */\n+    \"movq %%rcx,%0\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* tx = t4 >> 48 (%%rbp, overwrites R) */\n+    \"movq %0,%%rbp\\n\"\n+    \"shrq $48,%%rbp\\n\"\n+    /* t4 &= (M >> 4) (stack) */\n+    \"movq $0xffffffffffff,%%rax\\n\"\n+    \"andq %%rax,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* c = a0 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += a4 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a2 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a1 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* u0 = d & M (%0) */\n+    \"movq %%rcx,%0\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* u0 = (u0 << 4) | tx (%0) */\n+    \"shlq $4,%0\\n\"\n+    \"orq %%rbp,%0\\n\"\n+    /* c += u0 * (R >> 4) */\n+    \"movq $0x1000003d1,%%rax\\n\"\n+    \"mulq %0\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[0] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,0(%2)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += a1 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* c += a0 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d += a4 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a2 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* restore rdp = R */\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rcx,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* r[1] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,8(%2)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += a2 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* c += a1 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* c += a0 * b2 (last use of %%r10 = a0) */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* fetch t3 (%%r10, overwrites a0),t4 (%0) */\n+    \"popq %0\\n\"\n+    \"popq %%r10\\n\"\n+    /* d += a4 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rcx,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 (%%rcx only) */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    /* r[2] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,16(%2)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += t3 */\n+    \"addq %%r10,%%r8\\n\"\n+    /* c += d * R */\n+    \"movq %%rcx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[3] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,24(%2)\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* c += t4 (%%r8 only) */\n+    \"addq %0,%%r8\\n\"\n+    /* r[4] = c */\n+    \"movq %%r8,32(%2)\\n\"\n+\n+    \"popq %%rbp\\n\"\n+: \"+S\"(a)\n+: \"b\"(b), \"D\"(r)\n+: \"%rax\", \"%rcx\", \"%rdx\", \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\", \"cc\", \"memory\"\n+);\n+}\n+\n+SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t *a) {\n+/**\n+ * Registers: rdx:rax = multiplication accumulator\n+ *            r9:r8   = c\n+ *            rcx:rbx = d\n+ *            r10-r14 = a0-a4\n+ *            r15     = M (0xfffffffffffff)\n+ *            %1      = r\n+ *            %0      = a / t?\n+ *            rbp     = R (0x1000003d10)\n+ */\n+__asm__ __volatile__(\n+    \"pushq %%rbp\\n\"\n+\n+    \"movq 0(%0),%%r10\\n\"\n+    \"movq 8(%0),%%r11\\n\"\n+    \"movq 16(%0),%%r12\\n\"\n+    \"movq 24(%0),%%r13\\n\"\n+    \"movq 32(%0),%%r14\\n\"\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+    \"movq $0xfffffffffffff,%%r15\\n\"\n+\n+    /* d = (a0*2) * a3 */\n+    \"leaq (%%r10,%%r10,1),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"movq %%rax,%%rbx\\n\"\n+    \"movq %%rdx,%%rcx\\n\"\n+    /* d += (a1*2) * a2 */\n+    \"leaq (%%r11,%%r11,1),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* c = a4 * a4 */\n+    \"movq %%r14,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += (c & M) * R */\n+    \"andq %%r15,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* t3 (stack) = d & M */\n+    \"movq %%rbx,%0\\n\"\n+    \"andq %%r15,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* a4 *= 2 */\n+    \"addq %%r14,%%r14\\n\"\n+    /* d += a0 * a4 */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d+= (a1*2) * a3 */\n+    \"leaq (%%r11,%%r11,1),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += a2 * a2 */\n+    \"movq %%r12,%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += c * R */\n+    \"movq %%r8,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* t4 = d & M (%0) */\n+    \"movq %%rbx,%0\\n\"\n+    \"andq %%r15,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* tx = t4 >> 48 (%%rbp, overwrites constant) */\n+    \"movq %0,%%rbp\\n\"\n+    \"shrq $48,%%rbp\\n\"\n+    /* t4 &= (M >> 4) (stack) */\n+    \"movq $0xffffffffffff,%%rax\\n\"\n+    \"andq %%rax,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* c = a0 * a0 */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += a1 * a4 */\n+    \"movq %%r11,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += (a2*2) * a3 */\n+    \"leaq (%%r12,%%r12,1),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* u0 = d & M (%0) */\n+    \"movq %%rbx,%0\\n\"\n+    \"andq %%r15,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* u0 = (u0 << 4) | tx (%0) */\n+    \"shlq $4,%0\\n\"\n+    \"orq %%rbp,%0\\n\"\n+    /* c += u0 * (R >> 4) */\n+    \"movq $0x1000003d1,%%rax\\n\"\n+    \"mulq %0\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[0] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,0(%1)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* a0 *= 2 */\n+    \"addq %%r10,%%r10\\n\"\n+    /* c += a0 * a1 */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d += a2 * a4 */\n+    \"movq %%r12,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += a3 * a3 */\n+    \"movq %%r13,%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* load R in %%rbp */\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rbx,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* r[1] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,8(%1)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += a0 * a2 (last use of %%r10) */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* fetch t3 (%%r10, overwrites a0),t4 (%0) */\n+    \"popq %0\\n\"\n+    \"popq %%r10\\n\"\n+    /* c += a1 * a1 */\n+    \"movq %%r11,%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d += a3 * a4 */\n+    \"movq %%r13,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rbx,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 (%%rbx only) */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    /* r[2] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,16(%1)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += t3 */\n+    \"addq %%r10,%%r8\\n\"\n+    /* c += d * R */\n+    \"movq %%rbx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[3] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,24(%1)\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* c += t4 (%%r8 only) */\n+    \"addq %0,%%r8\\n\"\n+    /* r[4] = c */\n+    \"movq %%r8,32(%1)\\n\"\n+\n+    \"popq %%rbp\\n\"\n+: \"+S\"(a)\n+: \"D\"(r)\n+: \"%rax\", \"%rbx\", \"%rcx\", \"%rdx\", \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\", \"cc\", \"memory\"\n+);\n+}\n \n #endif"
      },
      {
        "sha": "63176d6de406cf1276a612904be248e13550576a",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 46,
        "deletions": 2,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -102,6 +102,50 @@ static void secp256k1_fe_normalize(secp256k1_fe_t *r) {\n #endif\n }\n \n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r) {\n+    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];\n+\n+    /* Reduce t4 at the start so there will be at most a single carry from the first pass */\n+    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;\n+    uint64_t m;\n+\n+    /* The first pass ensures the magnitude is 1, ... */\n+    t0 += x * 0x1000003D1ULL;\n+    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; m = t1;\n+    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; m &= t2;\n+    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; m &= t3;\n+\n+    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */\n+    VERIFY_CHECK(t4 >> 49 == 0);\n+\n+    /* At most a single final reduction is needed; check if the value is >= the field characteristic */\n+    x = (t4 >> 48) | ((t4 == 0x0FFFFFFFFFFFFULL) & (m == 0xFFFFFFFFFFFFFULL)\n+        & (t0 >= 0xFFFFEFFFFFC2FULL));\n+\n+    if (x) {\n+        t0 += 0x1000003D1ULL;\n+        t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+        t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;\n+        t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;\n+        t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;\n+\n+        /* If t4 didn't carry to bit 48 already, then it should have after any final reduction */\n+        VERIFY_CHECK(t4 >> 48 == x);\n+\n+        /* Mask off the possible multiple of 2^256 from the final reduction */\n+        t4 &= 0x0FFFFFFFFFFFFULL;\n+    }\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n@@ -255,7 +299,7 @@ static void secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const s\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n #endif\n-    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+    secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;\n@@ -268,7 +312,7 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     VERIFY_CHECK(a->magnitude <= 8);\n     secp256k1_fe_verify(a);\n #endif\n-    secp256k1_fe_sqr_inner(a->n, r->n);\n+    secp256k1_fe_sqr_inner(r->n, a->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;"
      },
      {
        "sha": "ec631833cfa1ad86109691ae05f60d05de933423",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -15,7 +15,7 @@\n #define VERIFY_BITS(x, n) do { } while(0)\n #endif\n \n-SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b, uint64_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b) {\n     VERIFY_BITS(a[0], 56);\n     VERIFY_BITS(a[1], 56);\n     VERIFY_BITS(a[2], 56);\n@@ -152,7 +152,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint64_t *a, const uin\n     /* [r4 r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n \n-SECP256K1_INLINE static void secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t *a) {\n     VERIFY_BITS(a[0], 56);\n     VERIFY_BITS(a[1], 56);\n     VERIFY_BITS(a[2], 56);"
      },
      {
        "sha": "73a55c4f00d4523f5851daa9c45ffd5f9ca6dd2e",
        "filename": "src/field_gmp_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_gmp_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -46,6 +46,10 @@ static void secp256k1_fe_normalize(secp256k1_fe_t *r) {\n         mpn_sub(r->n, r->n, FIELD_LIMBS, secp256k1_field_p, FIELD_LIMBS);\n }\n \n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r) {\n+    secp256k1_fe_normalize(r);\n+}\n+\n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n     r->n[0] = a;\n     for (int i=1; i<FIELD_LIMBS+1; i++)"
      },
      {
        "sha": "77d9dbf87613e45edecc03034af268a8a0f1517f",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 27,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -66,7 +66,7 @@ static int secp256k1_fe_set_hex(secp256k1_fe_t *r, const char *a, int alen) {\n     return secp256k1_fe_set_b32(r, tmp);\n }\n \n-static int secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+static int secp256k1_fe_sqrt_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n \n     /** The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n      *  { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n@@ -132,7 +132,7 @@ static int secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_sqr(&t1, r);\n     secp256k1_fe_negate(&t1, &t1, 1);\n     secp256k1_fe_add(&t1, a);\n-    secp256k1_fe_normalize(&t1);\n+    secp256k1_fe_normalize_var(&t1);\n     return secp256k1_fe_is_zero(&t1);\n }\n \n@@ -206,7 +206,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #elif defined(USE_FIELD_INV_NUM)\n     unsigned char b[32];\n     secp256k1_fe_t c = *a;\n-    secp256k1_fe_normalize(&c);\n+    secp256k1_fe_normalize_var(&c);\n     secp256k1_fe_get_b32(b, &c);\n     secp256k1_num_t n;\n     secp256k1_num_set_bin(&n, b, 32);\n@@ -218,30 +218,6 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #endif\n }\n \n-static void secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n-    if (len < 1)\n-        return;\n-\n-    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n-\n-    r[0] = a[0];\n-\n-    size_t i = 0;\n-    while (++i < len) {\n-        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n-    }\n-\n-    secp256k1_fe_t u; secp256k1_fe_inv(&u, &r[--i]);\n-\n-    while (i > 0) {\n-        int j = i--;\n-        secp256k1_fe_mul(&r[j], &r[i], &u);\n-        secp256k1_fe_mul(&u, &u, &a[j]);\n-    }\n-\n-    r[0] = u;\n-}\n-\n static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n     if (len < 1)\n         return;"
      },
      {
        "sha": "330e0696f4e16a22c60c81452403751cb5e6b3dc",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -51,15 +51,16 @@ static void secp256k1_ge_set_xy(secp256k1_ge_t *r, const secp256k1_fe_t *x, cons\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n-static int secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd);\n+static int secp256k1_ge_set_xo_var(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd);\n \n /** Check whether a group element is the point at infinity. */\n static int secp256k1_ge_is_infinity(const secp256k1_ge_t *a);\n \n /** Check whether a group element is valid (i.e., on the curve). */\n-static int secp256k1_ge_is_valid(const secp256k1_ge_t *a);\n+static int secp256k1_ge_is_valid_var(const secp256k1_ge_t *a);\n \n static void secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a);\n+static void secp256k1_ge_neg_var(secp256k1_ge_t *r, const secp256k1_ge_t *a);\n \n /** Get a hex representation of a point. *rlen will be overwritten with the real length. */\n static void secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a);\n@@ -80,11 +81,11 @@ static void secp256k1_gej_set_xy(secp256k1_gej_t *r, const secp256k1_fe_t *x, co\n /** Set a group element (jacobian) equal to another which is given in affine coordinates. */\n static void secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a);\n \n-/** Get the X coordinate of a group element (jacobian). */\n-static void secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a);\n+/** Compare the X coordinate of a group element (jacobian). */\n+static int secp256k1_gej_eq_x_var(const secp256k1_fe_t *x, const secp256k1_gej_t *a);\n \n /** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n-static void secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+static void secp256k1_gej_neg_var(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n \n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej_t *a);"
      },
      {
        "sha": "b34ed9b25123e137b0524a63deb73e79a4316d84",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 38,
        "deletions": 29,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -28,13 +28,17 @@ static int secp256k1_ge_is_infinity(const secp256k1_ge_t *a) {\n }\n \n static void secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a) {\n-    r->infinity = a->infinity;\n-    r->x = a->x;\n-    r->y = a->y;\n+    *r = *a;\n     secp256k1_fe_normalize(&r->y);\n     secp256k1_fe_negate(&r->y, &r->y, 1);\n }\n \n+static void secp256k1_ge_neg_var(secp256k1_ge_t *r, const secp256k1_ge_t *a) {\n+    *r = *a;\n+    secp256k1_fe_normalize_var(&r->y);\n+    secp256k1_fe_negate(&r->y, &r->y, 1);\n+}\n+\n static void secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a) {\n     char cx[65]; int lx=65;\n     char cy[65]; int ly=65;\n@@ -85,15 +89,16 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge_t *r, secp256k1_gej_t *a) {\n \n static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], const secp256k1_gej_t a[len]) {\n     size_t count = 0;\n-    secp256k1_fe_t az[len];\n+    secp256k1_fe_t *az = malloc(sizeof(secp256k1_fe_t) * len);\n     for (size_t i=0; i<len; i++) {\n         if (!a[i].infinity) {\n             az[count++] = a[i].z;\n         }\n     }\n \n-    secp256k1_fe_t azi[count];\n+    secp256k1_fe_t *azi = malloc(sizeof(secp256k1_fe_t) * count);\n     secp256k1_fe_inv_all_var(count, azi, az);\n+    free(az);\n \n     count = 0;\n     for (size_t i=0; i<len; i++) {\n@@ -106,6 +111,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], cons\n             secp256k1_fe_mul(&r[i].y, &a[i].y, &zi3);\n         }\n     }\n+    free(azi);\n }\n \n static void secp256k1_gej_set_infinity(secp256k1_gej_t *r) {\n@@ -135,16 +141,16 @@ static void secp256k1_ge_clear(secp256k1_ge_t *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd) {\n+static int secp256k1_ge_set_xo_var(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd) {\n     r->x = *x;\n     secp256k1_fe_t x2; secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_t x3; secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    if (!secp256k1_fe_sqrt(&r->y, &c))\n+    if (!secp256k1_fe_sqrt_var(&r->y, &c))\n         return 0;\n-    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_normalize_var(&r->y);\n     if (secp256k1_fe_is_odd(&r->y) != odd)\n         secp256k1_fe_negate(&r->y, &r->y, 1);\n     return 1;\n@@ -157,25 +163,29 @@ static void secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a) {\n    secp256k1_fe_set_int(&r->z, 1);\n }\n \n-static void secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a) {\n-    secp256k1_fe_t zi2; secp256k1_fe_inv_var(&zi2, &a->z); secp256k1_fe_sqr(&zi2, &zi2);\n-    secp256k1_fe_mul(r, &a->x, &zi2);\n+static int secp256k1_gej_eq_x_var(const secp256k1_fe_t *x, const secp256k1_gej_t *a) {\n+    VERIFY_CHECK(!a->infinity);\n+    secp256k1_fe_t r; secp256k1_fe_sqr(&r, &a->z); secp256k1_fe_mul(&r, &r, x);\n+    secp256k1_fe_t r2 = a->x;\n+    secp256k1_fe_normalize_var(&r);\n+    secp256k1_fe_normalize_var(&r2);\n+    return secp256k1_fe_equal(&r, &r2);\n }\n \n-static void secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+static void secp256k1_gej_neg_var(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n     r->infinity = a->infinity;\n     r->x = a->x;\n     r->y = a->y;\n     r->z = a->z;\n-    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_normalize_var(&r->y);\n     secp256k1_fe_negate(&r->y, &r->y, 1);\n }\n \n static int secp256k1_gej_is_infinity(const secp256k1_gej_t *a) {\n     return a->infinity;\n }\n \n-static int secp256k1_gej_is_valid(const secp256k1_gej_t *a) {\n+static int secp256k1_gej_is_valid_var(const secp256k1_gej_t *a) {\n     if (a->infinity)\n         return 0;\n     /** y^2 = x^3 + 7\n@@ -189,21 +199,21 @@ static int secp256k1_gej_is_valid(const secp256k1_gej_t *a) {\n     secp256k1_fe_t z6; secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n     secp256k1_fe_mul_int(&z6, 7);\n     secp256k1_fe_add(&x3, &z6);\n-    secp256k1_fe_normalize(&y2);\n-    secp256k1_fe_normalize(&x3);\n+    secp256k1_fe_normalize_var(&y2);\n+    secp256k1_fe_normalize_var(&x3);\n     return secp256k1_fe_equal(&y2, &x3);\n }\n \n-static int secp256k1_ge_is_valid(const secp256k1_ge_t *a) {\n+static int secp256k1_ge_is_valid_var(const secp256k1_ge_t *a) {\n     if (a->infinity)\n         return 0;\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_t y2; secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_t x3; secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n     secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&x3, &c);\n-    secp256k1_fe_normalize(&y2);\n-    secp256k1_fe_normalize(&x3);\n+    secp256k1_fe_normalize_var(&y2);\n+    secp256k1_fe_normalize_var(&x3);\n     return secp256k1_fe_equal(&y2, &x3);\n }\n \n@@ -255,11 +265,11 @@ static void secp256k1_gej_add_var(secp256k1_gej_t *r, const secp256k1_gej_t *a,\n     secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n     secp256k1_fe_t s1; secp256k1_fe_mul(&s1, &a->y, &z22); secp256k1_fe_mul(&s1, &s1, &b->z);\n     secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n-    secp256k1_fe_normalize(&u1);\n-    secp256k1_fe_normalize(&u2);\n+    secp256k1_fe_normalize_var(&u1);\n+    secp256k1_fe_normalize_var(&u2);\n     if (secp256k1_fe_equal(&u1, &u2)) {\n-        secp256k1_fe_normalize(&s1);\n-        secp256k1_fe_normalize(&s2);\n+        secp256k1_fe_normalize_var(&s1);\n+        secp256k1_fe_normalize_var(&s2);\n         if (secp256k1_fe_equal(&s1, &s2)) {\n             secp256k1_gej_double_var(r, a);\n         } else {\n@@ -294,15 +304,14 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *\n     }\n     r->infinity = 0;\n     secp256k1_fe_t z12; secp256k1_fe_sqr(&z12, &a->z);\n-    secp256k1_fe_t u1 = a->x; secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_t u1 = a->x;\n     secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n-    secp256k1_fe_t s1 = a->y; secp256k1_fe_normalize(&s1);\n+    secp256k1_fe_t s1 = a->y; secp256k1_fe_normalize_var(&s1);\n     secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n-    secp256k1_fe_normalize(&u1);\n-    secp256k1_fe_normalize(&u2);\n+    secp256k1_fe_normalize_var(&u1);\n+    secp256k1_fe_normalize_var(&u2);\n     if (secp256k1_fe_equal(&u1, &u2)) {\n-        secp256k1_fe_normalize(&s1);\n-        secp256k1_fe_normalize(&s2);\n+        secp256k1_fe_normalize_var(&s2);\n         if (secp256k1_fe_equal(&s1, &s2)) {\n             secp256k1_gej_double_var(r, a);\n         } else {"
      },
      {
        "sha": "305a240e6c652b6776f278e1da29e53e94fe95e5",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 8,
        "deletions": 26,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e958c5a3c9b70d83ba1076b78299f1070a20cae8/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "patch": "@@ -46,7 +46,7 @@ void random_group_element_test(secp256k1_ge_t *ge) {\n     secp256k1_fe_t fe;\n     do {\n         random_field_element_test(&fe);\n-        if (secp256k1_ge_set_xo(ge, &fe, secp256k1_rand32() & 1))\n+        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand32() & 1))\n             break;\n     } while(1);\n }\n@@ -459,7 +459,7 @@ void random_fe_non_zero(secp256k1_fe_t *nz) {\n void random_fe_non_square(secp256k1_fe_t *ns) {\n     random_fe_non_zero(ns);\n     secp256k1_fe_t r;\n-    if (secp256k1_fe_sqrt(&r, ns)) {\n+    if (secp256k1_fe_sqrt_var(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -498,23 +498,6 @@ void run_field_inv_var(void) {\n     }\n }\n \n-void run_field_inv_all(void) {\n-    secp256k1_fe_t x[16], xi[16], xii[16];\n-    /* Check it's safe to call for 0 elements */\n-    secp256k1_fe_inv_all(0, xi, x);\n-    for (int i=0; i<count; i++) {\n-        size_t len = (secp256k1_rand32() & 15) + 1;\n-        for (size_t j=0; j<len; j++)\n-            random_fe_non_zero(&x[j]);\n-        secp256k1_fe_inv_all(len, xi, x);\n-        for (size_t j=0; j<len; j++)\n-            CHECK(check_fe_inverse(&x[j], &xi[j]));\n-        secp256k1_fe_inv_all(len, xii, xi);\n-        for (size_t j=0; j<len; j++)\n-            CHECK(check_fe_equal(&x[j], &xii[j]));\n-    }\n-}\n-\n void run_field_inv_all_var(void) {\n     secp256k1_fe_t x[16], xi[16], xii[16];\n     /* Check it's safe to call for 0 elements */\n@@ -549,7 +532,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe_t *a, const secp256k1_fe_t *k) {\n     secp256k1_fe_t r1, r2;\n-    int v = secp256k1_fe_sqrt(&r1, a);\n+    int v = secp256k1_fe_sqrt_var(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -779,22 +762,22 @@ void test_point_times_order(const secp256k1_gej_t *point) {\n     secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n-    CHECK(secp256k1_gej_is_valid(&res1) == 0);\n+    CHECK(secp256k1_gej_is_valid_var(&res1) == 0);\n     secp256k1_ge_t res3;\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n-    CHECK(secp256k1_ge_is_valid(&res3) == 0);\n+    CHECK(secp256k1_ge_is_valid_var(&res3) == 0);\n }\n \n void run_point_times_order(void) {\n     secp256k1_fe_t x; VERIFY_CHECK(secp256k1_fe_set_hex(&x, \"02\", 2));\n     for (int i=0; i<500; i++) {\n         secp256k1_ge_t p;\n-        if (secp256k1_ge_set_xo(&p, &x, 1)) {\n-            CHECK(secp256k1_ge_is_valid(&p));\n+        if (secp256k1_ge_set_xo_var(&p, &x, 1)) {\n+            CHECK(secp256k1_ge_is_valid_var(&p));\n             secp256k1_gej_t j;\n             secp256k1_gej_set_ge(&j, &p);\n-            CHECK(secp256k1_gej_is_valid(&j));\n+            CHECK(secp256k1_gej_is_valid_var(&j));\n             test_point_times_order(&j);\n         }\n         secp256k1_fe_sqr(&x, &x);\n@@ -1185,7 +1168,6 @@ int main(int argc, char **argv) {\n     /* field tests */\n     run_field_inv();\n     run_field_inv_var();\n-    run_field_inv_all();\n     run_field_inv_all_var();\n     run_sqr();\n     run_sqrt();"
      }
    ]
  },
  {
    "sha": "b755db9228aad4bed241a8cdb4ebeb2cc3532827",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzU1ZGI5MjI4YWFkNGJlZDI0MWE4Y2RiNGViZWIyY2MzNTMyODI3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-12-06T17:35:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-12-06T17:35:39Z"
      },
      "message": "Update libsecp256k1 with unmerged patches",
      "tree": {
        "sha": "528bba65abcd913ae1e4a3d41bdfb015bb9eb2b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/528bba65abcd913ae1e4a3d41bdfb015bb9eb2b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b755db9228aad4bed241a8cdb4ebeb2cc3532827",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b755db9228aad4bed241a8cdb4ebeb2cc3532827",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b755db9228aad4bed241a8cdb4ebeb2cc3532827",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b755db9228aad4bed241a8cdb4ebeb2cc3532827/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4383319e4e0cb96818d2be734f7280181daac9fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4383319e4e0cb96818d2be734f7280181daac9fa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4383319e4e0cb96818d2be734f7280181daac9fa"
      },
      {
        "sha": "e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e958c5a3c9b70d83ba1076b78299f1070a20cae8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e958c5a3c9b70d83ba1076b78299f1070a20cae8"
      }
    ],
    "stats": {
      "total": 1681,
      "additions": 903,
      "deletions": 778
    },
    "files": [
      {
        "sha": "390d2c9ffa445ef8086fc9c719cc882f06a85824",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 21,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -1,12 +1,6 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n-if USE_ASM\n-COMMON_LIB = libsecp256k1_common.la\n-else\n-COMMON_LIB =\n-endif\n-noinst_LTLIBRARIES = $(COMMON_LIB)\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n@@ -43,30 +37,30 @@ noinst_HEADERS += src/field_gmp.h\n noinst_HEADERS += src/field_gmp_impl.h\n noinst_HEADERS += src/field.h\n noinst_HEADERS += src/field_impl.h\n+noinst_HEADERS += src/bench.h\n \n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n-if USE_ASM\n-libsecp256k1_common_la_SOURCES = src/field_5x52_asm.asm\n-endif\n-\n libsecp256k1_la_SOURCES = src/secp256k1.c\n libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(COMMON_LIB) $(SECP_LIBS)\n+libsecp256k1_la_LIBADD = $(SECP_LIBS)\n \n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n-noinst_PROGRAMS += bench_verify bench_sign bench_inv\n+noinst_PROGRAMS += bench_verify bench_recover bench_sign bench_inv\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n bench_verify_LDFLAGS = -static\n+bench_recover_SOURCES = src/bench_recover.c\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDFLAGS = -static\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n bench_sign_LDFLAGS = -static\n bench_inv_SOURCES = src/bench_inv.c\n-bench_inv_LDADD = $(COMMON_LIB) $(SECP_LIBS)\n+bench_inv_LDADD = $(SECP_LIBS)\n bench_inv_LDFLAGS = -static\n bench_inv_CPPFLAGS = $(SECP_INCLUDES)\n endif\n@@ -75,15 +69,9 @@ if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n tests_CPPFLAGS = -DVERIFY $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(COMMON_LIB) $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n tests_LDFLAGS = -static\n TESTS = tests\n endif\n \n-EXTRA_DIST = autogen.sh nasm_lt.sh\n-\n-#x86_64 only\n-if USE_ASM\n-.asm.lo:\n-\t$(LIBTOOL) --mode=compile --tag YASM $(srcdir)/nasm_lt.sh $(YASM) -f $(YASM_BINFMT) $(YAFLAGS) -I$(srcdir) -I. $< -o $@\n-endif\n+EXTRA_DIST = autogen.sh"
      },
      {
        "sha": "7163b9480900f004ff6ca8f981cd0a090ca73d11",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 10,
        "deletions": 32,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -11,38 +11,16 @@ fi\n \n dnl \n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n-if test x\"$host_cpu\" == x\"x86_64\"; then\n-  AC_CHECK_PROG(YASM, yasm, yasm)\n-else\n-  if test x\"$set_field\" = x\"64bit_asm\"; then\n-    AC_MSG_ERROR([$set_field field support explicitly requested but is not compatible with this host])\n-  fi\n-fi\n-if test x$YASM = x; then\n-  if test x\"$set_field\" = x\"64bit_asm\"; then\n-    AC_MSG_ERROR([$set_field field support explicitly requested but yasm was not found])\n-  fi\n-  has_64bit_asm=no\n-else\n-  case x\"$host_os\" in\n-  xdarwin*)\n-    YASM_BINFMT=macho64\n-    ;;\n-  x*-gnux32)\n-    YASM_BINFMT=elfx32\n-    ;;\n-  *)\n-    YASM_BINFMT=elf64\n-    ;;\n-  esac\n-  if $YASM -f help | grep -q $YASM_BINFMT; then\n-    has_64bit_asm=yes\n-  else\n-    if test x\"$set_field\" = x\"64bit_asm\"; then\n-      AC_MSG_ERROR([$set_field field support explicitly requested but yasm doesn't support $YASM_BINFMT format])\n-    fi\n-    AC_MSG_WARN([yasm too old for $YASM_BINFMT format])\n-    has_64bit_asm=no\n+AC_MSG_CHECKING(for x86_64 assembly availability)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+  #include <stdint.h>]],[[\n+  uint64_t a = 11, tmp;\n+  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n+AC_MSG_RESULT([$has_64bit_asm])\n+if test x\"$set_field\" == x\"64bit_asm\"; then\n+  if test x\"$has_64bit_asm\" == x\"no\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but no x86_64 assembly available])\n   fi\n fi\n ])"
      },
      {
        "sha": "60a54051576a17d4124b8407b36195f046760023",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -283,7 +283,6 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n-AC_SUBST(YASM_BINFMT)\n AM_CONDITIONAL([USE_ASM], [test x\"$set_field\" == x\"64bit_asm\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" != x\"no\"])"
      },
      {
        "sha": "6cd73294c0617c5d186926f1a7903afbde11044c",
        "filename": "src/secp256k1/nasm_lt.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 57,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4383319e4e0cb96818d2be734f7280181daac9fa/src/secp256k1/nasm_lt.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4383319e4e0cb96818d2be734f7280181daac9fa/src/secp256k1/nasm_lt.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/nasm_lt.sh?ref=4383319e4e0cb96818d2be734f7280181daac9fa",
        "patch": "@@ -1,57 +0,0 @@\n-#! /bin/sh\n-command=\"\"\n-infile=\"\"\n-o_opt=no\n-pic=no\n-while [ $# -gt 0 ]; do\n-    case \"$1\" in\n-        -DPIC|-fPIC|-fpic|-Kpic|-KPIC)\n-            if [ \"$pic\" != \"yes\" ] ; then\n-                command=\"$command -DPIC\"\n-                pic=yes\n-            fi\n-            ;;\n-        -f|-fbin|-faout|-faoutb|-fcoff|-felf|-felf64|-fas86| \\\n-        -fobj|-fwin32|-fwin64|-frdf|-fieee|-fmacho|-fmacho64)\n-            # it's a file format specifier for nasm.\n-            command=\"$command $1\"\n-            ;;\n-        -f*)\n-            # maybe a code-generation flag for gcc.\n-            ;;\n-        -[Ii]*)\n-            incdir=`echo \"$1\" | sed 's/^-[Ii]//'`\n-            if [ \"x$incdir\" = x -a \"x$2\" != x ] ; then\n-                case \"$2\" in\n-                    -*) ;;\n-                    *) incdir=\"$2\"; shift;;\n-                esac\n-            fi\n-            if [ \"x$incdir\" != x ] ; then\n-                # In the case of NASM, the trailing slash is necessary.\n-                incdir=`echo \"$incdir\" | sed 's%/*$%/%'`\n-                command=\"$command -I$incdir\"\n-            fi\n-            ;;\n-        -o*)\n-            o_opt=yes\n-            command=\"$command $1\"\n-            ;;\n-        *.asm)\n-            infile=$1\n-            command=\"$command $1\"\n-            ;;\n-        *)\n-            command=\"$command $1\"\n-            ;;\n-    esac\n-    shift\n-done\n-if [ \"$o_opt\" != yes ] ; then\n-    # By default, NASM creates an output file\n-    # in the same directory as the input file.\n-    outfile=\"-o `echo $infile | sed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.o\"\n-    command=\"$command $outfile\"\n-fi\n-echo $command\n-exec $command"
      },
      {
        "sha": "adcb4afc4ae6aad9445cdd30a85a7b7c70bd8311",
        "filename": "src/secp256k1/src/bench.h",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -0,0 +1,36 @@\n+/**********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_BENCH_H_\n+#define _SECP256K1_BENCH_H_\n+\n+#include <stdio.h>\n+#include \"sys/time.h\"\n+\n+static double gettimedouble(void) {\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+}\n+\n+void run_benchmark(void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+    double min = 1.0 / 0.0;\n+    double sum = 0.0;\n+    double max = 0.0;\n+    for (int i = 0; i < count; i++) {\n+        if (setup) setup(data);\n+        double begin = gettimedouble();\n+        benchmark(data);\n+        double total = gettimedouble() - begin;\n+        if (teardown) teardown(data);\n+        if (total < min) min = total;\n+        if (total > max) max = total;\n+        sum += total;\n+    }\n+    printf(\"min %.3fus / avg %.3fus / max %.3fus\\n\", min * 1000000.0 / iter, (sum / count) * 1000000.0 / iter, max * 1000000.0 / iter);\n+}\n+\n+#endif"
      },
      {
        "sha": "3bdedea30e47119ade683786573e38a1642da2f1",
        "filename": "src/secp256k1/src/bench_inv.c",
        "status": "modified",
        "additions": 28,
        "deletions": 17,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_inv.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_inv.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_inv.c?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -12,30 +12,41 @@\n #include \"field_impl.h\"\n #include \"group_impl.h\"\n #include \"scalar_impl.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_scalar_t base, x;\n+} bench_inv_t;\n+\n+void bench_inv_setup(void* arg) {\n+    bench_inv_t *data = (bench_inv_t*)arg;\n \n-int main(void) {\n     static const unsigned char init[32] = {\n         0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n         0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n         0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n         0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n     };\n-    static const unsigned char fini[32] = {\n-        0xba, 0x28, 0x58, 0xd8, 0xaa, 0x11, 0xd6, 0xf2,\n-        0xfa, 0xce, 0x50, 0xb1, 0x67, 0x19, 0xb1, 0xa6,\n-        0xe0, 0xaa, 0x84, 0x53, 0xf6, 0x80, 0xfc, 0x23,\n-        0x88, 0x3c, 0xd6, 0x74, 0x9f, 0x27, 0x09, 0x03\n-    };\n-    secp256k1_ge_start();\n-    secp256k1_scalar_t base, x;\n-    secp256k1_scalar_set_b32(&base, init, NULL);\n-    secp256k1_scalar_set_b32(&x, init, NULL);\n-    for (int i=0; i<1000000; i++) {\n-        secp256k1_scalar_inverse(&x, &x);\n-        secp256k1_scalar_add(&x, &x, &base);\n+\n+    secp256k1_scalar_set_b32(&data->base, init, NULL);\n+    secp256k1_scalar_set_b32(&data->x, init, NULL);\n+}\n+\n+void bench_inv(void* arg) {\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (int i=0; i<20000; i++) {\n+        secp256k1_scalar_inverse(&data->x, &data->x);\n+        secp256k1_scalar_add(&data->x, &data->x, &data->base);\n     }\n-    unsigned char res[32];\n-    secp256k1_scalar_get_b32(res, &x);\n-    CHECK(memcmp(res, fini, 32) == 0);\n+}\n+\n+int main(void) {\n+    secp256k1_ge_start();\n+\n+    bench_inv_t data;\n+    run_benchmark(bench_inv, bench_inv_setup, NULL, &data, 10, 20000);\n+\n+    secp256k1_ge_stop();\n     return 0;\n }"
      },
      {
        "sha": "286ad064de661acc878b577cd8c34a3bf612a06c",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -0,0 +1,46 @@\n+/**********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    unsigned char msg[32];\n+    unsigned char sig[64];\n+} bench_recover_t;\n+\n+void bench_recover(void* arg) {\n+    bench_recover_t *data = (bench_recover_t*)arg;\n+\n+    unsigned char pubkey[33];\n+    for (int i=0; i<20000; i++) {\n+        int pubkeylen = 33;\n+        CHECK(secp256k1_ecdsa_recover_compact(data->msg, 32, data->sig, pubkey, &pubkeylen, 1, i % 2));\n+        for (int j = 0; j < 32; j++) {\n+            data->sig[j + 32] = data->msg[j];    /* Move former message to S. */\n+            data->msg[j] = data->sig[j];         /* Move former R to message. */\n+            data->sig[j] = pubkey[j + 1];        /* Move recovered pubkey X coordinate to R (which must be a valid X coordinate). */\n+        }\n+    }\n+}\n+\n+void bench_recover_setup(void* arg) {\n+    bench_recover_t *data = (bench_recover_t*)arg;\n+\n+    for (int i = 0; i < 32; i++) data->msg[i] = 1 + i;\n+    for (int i = 0; i < 64; i++) data->sig[i] = 65 + i;\n+}\n+\n+int main(void) {\n+    secp256k1_start(SECP256K1_START_VERIFY);\n+\n+    bench_recover_t data;\n+    run_benchmark(bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n+\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "0b33e77396d58d064ef8edfd7c5a1615d554719c",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 24,
        "deletions": 25,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -3,46 +3,45 @@\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n-#include <stdio.h>\n-#include <string.h>\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n+#include \"bench.h\"\n \n-int main(void) {\n-    secp256k1_start(SECP256K1_START_SIGN);\n-\n+typedef struct {\n     unsigned char msg[32];\n     unsigned char nonce[32];\n     unsigned char key[32];\n+} bench_sign_t;\n \n-    for (int i = 0; i < 32; i++) msg[i] = i + 1;\n-    for (int i = 0; i < 32; i++) nonce[i] = i + 33;\n-    for (int i = 0; i < 32; i++) key[i] = i + 65;\n+static void bench_sign_setup(void* arg) {\n+    bench_sign_t *data = (bench_sign_t*)arg;\n \n-    unsigned char sig[64];\n+    for (int i = 0; i < 32; i++) data->msg[i] = i + 1;\n+    for (int i = 0; i < 32; i++) data->nonce[i] = i + 33;\n+    for (int i = 0; i < 32; i++) data->key[i] = i + 65;\n+}\n+\n+static void bench_sign(void* arg) {\n+    bench_sign_t *data = (bench_sign_t*)arg;\n \n-    for (int i=0; i<1000000; i++) {\n+    unsigned char sig[64];\n+    for (int i=0; i<20000; i++) {\n         int recid = 0;\n-        CHECK(secp256k1_ecdsa_sign_compact(msg, 32, sig, key, nonce, &recid));\n+        CHECK(secp256k1_ecdsa_sign_compact(data->msg, 32, sig, data->key, data->nonce, &recid));\n         for (int j = 0; j < 32; j++) {\n-            nonce[j] = key[j];     /* Move former key to nonce  */\n-            msg[j] = sig[j];       /* Move former R to message. */\n-            key[j] = sig[j + 32];  /* Move former S to key.     */\n+            data->nonce[j] = data->key[j];     /* Move former key to nonce  */\n+            data->msg[j] = sig[j];             /* Move former R to message. */\n+            data->key[j] = sig[j + 32];        /* Move former S to key.     */\n         }\n     }\n+}\n+\n+int main(void) {\n+    secp256k1_start(SECP256K1_START_SIGN);\n \n-    static const unsigned char fini[64] = {\n-        0x92, 0x03, 0xef, 0xf1, 0x58, 0x0b, 0x49, 0x8d,\n-        0x22, 0x3d, 0x49, 0x0e, 0xbf, 0x26, 0x50, 0x0e,\n-        0x2d, 0x62, 0x90, 0xd7, 0x82, 0xbd, 0x3d, 0x5c,\n-        0xa9, 0x10, 0xa5, 0x49, 0xb1, 0xd8, 0x8c, 0xc0,\n-        0x5b, 0x5e, 0x9e, 0x68, 0x51, 0x3d, 0xe8, 0xec,\n-        0x82, 0x30, 0x82, 0x88, 0x8c, 0xfd, 0xe7, 0x71,\n-        0x15, 0x92, 0xfc, 0x14, 0x59, 0x78, 0x31, 0xb3,\n-        0xf6, 0x07, 0x91, 0x18, 0x00, 0x8d, 0x4c, 0xb2\n-    };\n-    CHECK(memcmp(sig, fini, 64) == 0);\n+    bench_sign_t data;\n+    run_benchmark(bench_sign, bench_sign_setup, NULL, &data, 10, 20000);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "a2f633d3451e710d987d8de5ce1ad3050588ea49",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 35,
        "deletions": 24,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -9,35 +9,46 @@\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n+#include \"bench.h\"\n \n-int main(void) {\n-    secp256k1_start(SECP256K1_START_VERIFY);\n-\n+typedef struct {\n     unsigned char msg[32];\n-    unsigned char sig[64];\n-\n-    for (int i = 0; i < 32; i++) msg[i] = 1 + i;\n-    for (int i = 0; i < 64; i++) sig[i] = 65 + i;\n-\n+    unsigned char key[32];\n+    unsigned char nonce[32];\n+    unsigned char sig[72];\n+    int siglen;\n     unsigned char pubkey[33];\n-    for (int i=0; i<1000000; i++) {\n-        int pubkeylen = 33;\n-        CHECK(secp256k1_ecdsa_recover_compact(msg, 32, sig, pubkey, &pubkeylen, 1, i % 2));\n-        for (int j = 0; j < 32; j++) {\n-            sig[j + 32] = msg[j];    /* Move former message to S. */\n-            msg[j] = sig[j];         /* Move former R to message. */\n-            sig[j] = pubkey[j + 1];  /* Move recovered pubkey X coordinate to R (which must be a valid X coordinate). */\n-        }\n+    int pubkeylen;\n+} benchmark_verify_t;\n+\n+static void benchmark_verify(void* arg) {\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (int i=0; i<20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        CHECK(secp256k1_ecdsa_verify(data->msg, 32, data->sig, data->siglen, data->pubkey, data->pubkeylen) == (i == 0));\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n     }\n+}\n+\n+int main(void) {\n+    secp256k1_start(SECP256K1_START_VERIFY | SECP256K1_START_SIGN);\n+\n+    benchmark_verify_t data;\n+\n+    for (int i = 0; i < 32; i++) data.msg[i] = 1 + i;\n+    for (int i = 0; i < 32; i++) data.key[i] = 33 + i;\n+    for (int i = 0; i < 32; i++) data.nonce[i] = 65 + i;\n+    data.siglen = 72;\n+    CHECK(secp256k1_ecdsa_sign(data.msg, 32, data.sig, &data.siglen, data.key, data.nonce));\n+    data.pubkeylen = 33;\n+    CHECK(secp256k1_ec_pubkey_create(data.pubkey, &data.pubkeylen, data.key, 1));\n \n-    static const unsigned char fini[33] = {\n-        0x02,\n-        0x52, 0x63, 0xae, 0x9a, 0x9d, 0x47, 0x1f, 0x1a,\n-        0xb2, 0x36, 0x65, 0x89, 0x11, 0xe7, 0xcc, 0x86,\n-        0xa3, 0xab, 0x97, 0xb6, 0xf1, 0xaf, 0xfd, 0x8f,\n-        0x9b, 0x38, 0xb6, 0x18, 0x55, 0xe5, 0xc2, 0x43\n-    };\n-    CHECK(memcmp(fini, pubkey, 33) == 0);\n+    run_benchmark(benchmark_verify, NULL, NULL, &data, 10, 20000);\n \n     secp256k1_stop();\n     return 0;"
      },
      {
        "sha": "0a2e8962a34ea82556a0db57a8820d6edcc149f6",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 18,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -38,7 +38,7 @@ static void secp256k1_ecdsa_start(void) {\n \n     secp256k1_fe_set_b32(&ret->order_as_fe, order);\n     secp256k1_fe_negate(&ret->p_minus_order, &ret->order_as_fe, 1);\n-    secp256k1_fe_normalize(&ret->p_minus_order);\n+    secp256k1_fe_normalize_var(&ret->p_minus_order);\n \n     /* Set the global pointer. */\n     secp256k1_ecdsa_consts = ret;\n@@ -109,25 +109,51 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const se\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_recompute(secp256k1_scalar_t *r2, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n     if (secp256k1_scalar_is_zero(&sig->r) || secp256k1_scalar_is_zero(&sig->s))\n         return 0;\n \n-    int ret = 0;\n     secp256k1_scalar_t sn, u1, u2;\n     secp256k1_scalar_inverse_var(&sn, &sig->s);\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, &sig->r);\n     secp256k1_gej_t pubkeyj; secp256k1_gej_set_ge(&pubkeyj, pubkey);\n     secp256k1_gej_t pr; secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n-    if (!secp256k1_gej_is_infinity(&pr)) {\n-        secp256k1_fe_t xr; secp256k1_gej_get_x_var(&xr, &pr);\n-        secp256k1_fe_normalize(&xr);\n-        unsigned char xrb[32]; secp256k1_fe_get_b32(xrb, &xr);\n-        secp256k1_scalar_set_b32(r2, xrb, NULL);\n-        ret = 1;\n+    if (secp256k1_gej_is_infinity(&pr)) {\n+        return 0;\n+    }\n+    unsigned char c[32];\n+    secp256k1_scalar_get_b32(c, &sig->r);\n+    secp256k1_fe_t xr;\n+    secp256k1_fe_set_b32(&xr, c);\n+\n+    // We now have the recomputed R point in pr, and its claimed x coordinate (modulo the order)\n+    // in xr. Naively, we would extract the x coordinate from pr (requiring a inversion modulo p),\n+    // compute the remainder modulo the order, and compare it to xr. However:\n+    //\n+    //   x(R) mod n == xr\n+    //   <=> exists h. (x(R) + h * order < p && x(R) == xr + h * order)\n+    //   [Since 2 * order > p, h can only be 0 or 1]\n+    //   <=> (x(R) == xr) || (xr + order < p && x(R) == xr + order)\n+    //   <=> (R.x / R.z^2 mod p == xr) || (xr + order < p && R.x / R.z^2 mod p == xr + order)\n+    //   <=> (R.x == xr * R.z^2 mod p) || (xr + order < p && R.x == (xr + order) * R.z^2 mod p)\n+    //\n+    // Thus, we can avoid the inversion, but we have to check both cases separately.\n+    // secp256k1_gej_eq_x implements the (R.x == xr*R.z^2 mod p) test.\n+    if (secp256k1_gej_eq_x_var(&xr, &pr)) {\n+        // R.x == xr * R.z^2 mod p, so the signature is valid.\n+        return 1;\n+    }\n+    if (secp256k1_fe_cmp_var(&xr, &secp256k1_ecdsa_consts->p_minus_order) >= 0) {\n+        // xr + order >= n, so we can skip testing the second case.\n+        return 0;\n     }\n-    return ret;\n+    secp256k1_fe_add(&xr, &secp256k1_ecdsa_consts->order_as_fe);\n+    if (secp256k1_gej_eq_x_var(&xr, &pr)) {\n+        // R.x == (xr + order) * R.z^2 mod p, so the signature is valid.\n+        return 1;\n+    }\n+    return 0;\n }\n \n static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message, int recid) {\n@@ -144,7 +170,7 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256\n         secp256k1_fe_add(&fx, &secp256k1_ecdsa_consts->order_as_fe);\n     }\n     secp256k1_ge_t x;\n-    if (!secp256k1_ge_set_xo(&x, &fx, recid & 1))\n+    if (!secp256k1_ge_set_xo_var(&x, &fx, recid & 1))\n         return 0;\n     secp256k1_gej_t xj;\n     secp256k1_gej_set_ge(&xj, &x);\n@@ -159,13 +185,6 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256\n     return !secp256k1_gej_is_infinity(&qj);\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_scalar_t *message) {\n-    secp256k1_scalar_t r2;\n-    int ret = 0;\n-    ret = secp256k1_ecdsa_sig_recompute(&r2, sig, pubkey, message) && secp256k1_scalar_eq(&sig->r, &r2);\n-    return ret;\n-}\n-\n static int secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n     secp256k1_gej_t rp;\n     secp256k1_ecmult_gen(&rp, nonce);"
      },
      {
        "sha": "b3fa7d9bd21a974e755e0c9f0d475e9808a264f3",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -17,7 +17,7 @@\n static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size) {\n     if (size == 33 && (pub[0] == 0x02 || pub[0] == 0x03)) {\n         secp256k1_fe_t x;\n-        return secp256k1_fe_set_b32(&x, pub+1) && secp256k1_ge_set_xo(elem, &x, pub[0] == 0x03);\n+        return secp256k1_fe_set_b32(&x, pub+1) && secp256k1_ge_set_xo_var(elem, &x, pub[0] == 0x03);\n     } else if (size == 65 && (pub[0] == 0x04 || pub[0] == 0x06 || pub[0] == 0x07)) {\n         secp256k1_fe_t x, y;\n         if (!secp256k1_fe_set_b32(&x, pub+1) || !secp256k1_fe_set_b32(&y, pub+33)) {\n@@ -26,7 +26,7 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned cha\n         secp256k1_ge_set_xy(elem, &x, &y);\n         if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07))\n             return 0;\n-        return secp256k1_ge_is_valid(elem);\n+        return secp256k1_ge_is_valid_var(elem);\n     } else {\n         return 0;\n     }\n@@ -36,8 +36,8 @@ static int secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char\n     if (secp256k1_ge_is_infinity(elem)) {\n         return 0;\n     }\n-    secp256k1_fe_normalize(&elem->x);\n-    secp256k1_fe_normalize(&elem->y);\n+    secp256k1_fe_normalize_var(&elem->x);\n+    secp256k1_fe_normalize_var(&elem->y);\n     secp256k1_fe_get_b32(&pub[1], &elem->x);\n     if (compressed) {\n         *size = 33;"
      },
      {
        "sha": "6f154f2be04d670a4e2917052ace7b28f6cea09c",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ecmult_gen_start(void) {\n         secp256k1_fe_t nums_x;\n         VERIFY_CHECK(secp256k1_fe_set_b32(&nums_x, nums_b32));\n         secp256k1_ge_t nums_ge;\n-        VERIFY_CHECK(secp256k1_ge_set_xo(&nums_ge, &nums_x, 0));\n+        VERIFY_CHECK(secp256k1_ge_set_xo_var(&nums_ge, &nums_x, 0));\n         secp256k1_gej_set_ge(&nums_gej, &nums_ge);\n         /* Add G to make the bits in x uniformly distributed. */\n         secp256k1_gej_add_ge_var(&nums_gej, &nums_gej, g);\n@@ -73,7 +73,7 @@ static void secp256k1_ecmult_gen_start(void) {\n             secp256k1_gej_double_var(&numsbase, &numsbase);\n             if (j == 62) {\n                 /* In the last iteration, numsbase is (1 - 2^j) * nums instead. */\n-                secp256k1_gej_neg(&numsbase, &numsbase);\n+                secp256k1_gej_neg_var(&numsbase, &numsbase);\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej);\n             }\n         }"
      },
      {
        "sha": "6f386ca6129392a38936e79d1305e6e17a02f8ff",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -15,11 +15,13 @@\n #define WINDOW_A 5\n \n /** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. WINDOW_G == 14 results in 640 KiB. */\n+    exponentially larger precomputed tables. */\n #ifdef USE_ENDOMORPHISM\n-#define WINDOW_G 14\n-#else\n+/** Two tables for window size 15: 1.375 MiB. */\n #define WINDOW_G 15\n+#else\n+/** One table for window size 16: 1.375 MiB. */\n+#define WINDOW_G 16\n #endif\n \n /** Fill a table 'pre' with precomputed odd multiples of a. W determines the size of the table.\n@@ -43,13 +45,14 @@ static void secp256k1_ecmult_table_precomp_gej_var(secp256k1_gej_t *pre, const s\n \n static void secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const secp256k1_gej_t *a, int w) {\n     const int table_size = 1 << (w-2);\n-    secp256k1_gej_t prej[table_size];\n+    secp256k1_gej_t *prej = malloc(sizeof(secp256k1_gej_t) * table_size);\n     prej[0] = *a;\n     secp256k1_gej_t d; secp256k1_gej_double_var(&d, a);\n     for (int i=1; i<table_size; i++) {\n         secp256k1_gej_add_var(&prej[i], &d, &prej[i-1]);\n     }\n     secp256k1_ge_set_all_gej_var(table_size, pre, prej);\n+    free(prej);\n }\n \n /** The number of entries a table with precomputed multiples needs to have. */\n@@ -67,8 +70,8 @@ static void secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const sec\n         (neg)((r), &(pre)[(-(n)-1)/2]); \\\n } while(0)\n \n-#define ECMULT_TABLE_GET_GEJ(r,pre,n,w) ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_gej_neg)\n-#define ECMULT_TABLE_GET_GE(r,pre,n,w)  ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_ge_neg)\n+#define ECMULT_TABLE_GET_GEJ(r,pre,n,w) ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_gej_neg_var)\n+#define ECMULT_TABLE_GET_GE(r,pre,n,w)  ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_ge_neg_var)\n \n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */"
      },
      {
        "sha": "53aa29e13fd563b6f65db1bb240340d36970073e",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -50,6 +50,9 @@ static void secp256k1_fe_stop(void);\n /** Normalize a field element. */\n static void secp256k1_fe_normalize(secp256k1_fe_t *r);\n \n+/** Normalize a field element, without constant-time guarantee. */\n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r);\n+\n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a);\n \n@@ -93,7 +96,7 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n /** Sets a field element to be the (modular) square root (if any exist) of another. Requires the\n  *  input's magnitude to be at most 8. The output magnitude is 1 (but not guaranteed to be\n  *  normalized). Return value indicates whether a square root was found. */\n-static int secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+static int secp256k1_fe_sqrt_var(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n@@ -105,9 +108,6 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n /** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n  *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n  *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n-\n-/** Potentially faster version of secp256k1_fe_inv_all, without constant-time guarantee. */\n static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n \n /** Convert a field element to a hexadecimal string. */"
      },
      {
        "sha": "d20229cda6b955615961916fde4138ceae8cdd60",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 60,
        "deletions": 4,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -103,6 +103,62 @@ static void secp256k1_fe_normalize(secp256k1_fe_t *r) {\n #endif\n }\n \n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r) {\n+    uint32_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4],\n+             t5 = r->n[5], t6 = r->n[6], t7 = r->n[7], t8 = r->n[8], t9 = r->n[9];\n+\n+    /* Reduce t9 at the start so there will be at most a single carry from the first pass */\n+    uint32_t x = t9 >> 22; t9 &= 0x03FFFFFUL;\n+    uint32_t m;\n+\n+    /* The first pass ensures the magnitude is 1, ... */\n+    t0 += x * 0x3D1UL; t1 += (x << 6);\n+    t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+    t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+    t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL; m = t2;\n+    t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL; m &= t3;\n+    t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL; m &= t4;\n+    t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL; m &= t5;\n+    t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL; m &= t6;\n+    t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL; m &= t7;\n+    t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL; m &= t8;\n+\n+    /* ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element) */\n+    VERIFY_CHECK(t9 >> 23 == 0);\n+\n+    /* At most a single final reduction is needed; check if the value is >= the field characteristic */\n+    x = (t9 >> 22) | ((t9 == 0x03FFFFFUL) & (m == 0x3FFFFFFUL)\n+        & ((t1 + 0x40UL + ((t0 + 0x3D1UL) >> 26)) > 0x3FFFFFFUL));\n+\n+    if (x) {\n+        t0 += 0x3D1UL; t1 += (x << 6);\n+        t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+        t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+        t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL;\n+        t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL;\n+        t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL;\n+        t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL;\n+        t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL;\n+        t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL;\n+        t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL;\n+\n+        /* If t9 didn't carry to bit 22 already, then it should have after any final reduction */\n+        VERIFY_CHECK(t9 >> 22 == x);\n+\n+        /* Mask off the possible multiple of 2^256 from the final reduction */\n+        t9 &= 0x03FFFFFUL;\n+    }\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+    r->n[5] = t5; r->n[6] = t6; r->n[7] = t7; r->n[8] = t8; r->n[9] = t9;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n@@ -271,7 +327,7 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1\n #define VERIFY_BITS(x, n) do { } while(0)\n #endif\n \n-SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b, uint32_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b) {\n     VERIFY_BITS(a[0], 30);\n     VERIFY_BITS(a[1], 30);\n     VERIFY_BITS(a[2], 30);\n@@ -598,7 +654,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint32_t *a, const uin\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n \n-SECP256K1_INLINE static void secp256k1_fe_sqr_inner(const uint32_t *a, uint32_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a) {\n     VERIFY_BITS(a[0], 30);\n     VERIFY_BITS(a[1], 30);\n     VERIFY_BITS(a[2], 30);\n@@ -879,7 +935,7 @@ static void secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const s\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n #endif\n-    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+    secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;\n@@ -892,7 +948,7 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     VERIFY_CHECK(a->magnitude <= 8);\n     secp256k1_fe_verify(a);\n #endif\n-    secp256k1_fe_sqr_inner(a->n, r->n);\n+    secp256k1_fe_sqr_inner(r->n, a->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;"
      },
      {
        "sha": "5e785f763055eaf695f92116dc3582a0985bf71d",
        "filename": "src/secp256k1/src/field_5x52_asm.asm",
        "status": "removed",
        "additions": 0,
        "deletions": 469,
        "changes": 469,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4383319e4e0cb96818d2be734f7280181daac9fa/src/secp256k1/src/field_5x52_asm.asm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4383319e4e0cb96818d2be734f7280181daac9fa/src/secp256k1/src/field_5x52_asm.asm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_asm.asm?ref=4383319e4e0cb96818d2be734f7280181daac9fa",
        "patch": "@@ -1,469 +0,0 @@\n-\t;; Added by Diederik Huys, March 2013\n-\t;;\n-\t;; Provided public procedures:\n-\t;; \tsecp256k1_fe_mul_inner\n-\t;; \tsecp256k1_fe_sqr_inner\n-\t;;\n-\t;; Needed tools: YASM (http://yasm.tortall.net)\n-\t;;\n-\t;; \n-\n-\tBITS 64\n-\n-%ifidn   __OUTPUT_FORMAT__,macho64\n-%define SYM(x) _ %+ x\n-%else\n-%define SYM(x) x\n-%endif\n-\n-\t;;  Procedure ExSetMult\n-\t;;  Register Layout:\n-\t;;  INPUT: \trdi\t= a->n\n-\t;; \t   \trsi  \t= b->n\n-\t;; \t   \trdx  \t= r->a\n-\t;; \n-\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n-\t;; \t\tr9:r8    = c\n-\t;; \t\tr10-r13  = t0-t3\n-\t;; \t\tr14\t = b.n[0] / t4\n-\t;; \t\tr15\t = b.n[1] / t5\n-\t;; \t\trbx\t = b.n[2] / t6\n-\t;; \t\trcx\t = b.n[3] / t7\n-\t;; \t\trbp\t = Constant 0FFFFFFFFFFFFFh / t8\n-\t;; \t\trsi\t = b.n / b.n[4] / t9\n-\n-\tGLOBAL SYM(secp256k1_fe_mul_inner)\n-\tALIGN 32\n-SYM(secp256k1_fe_mul_inner):\n-\tpush rbp\n-\tpush rbx\n-\tpush r12\n-\tpush r13\n-\tpush r14\n-\tpush r15\n-\tpush rdx\n-\tmov r14,[rsi+8*0]\t; preload b.n[0]. This will be the case until\n-\t\t\t\t; b.n[0] is no longer needed, then we reassign\n-\t\t\t\t; r14 to t4\n-\t;; c=a.n[0] * b.n[0]\n-   \tmov rax,[rdi+0*8]\t; load a.n[0]\n-\tmov rbp,0FFFFFFFFFFFFFh\n-\tmul r14\t\t\t; rdx:rax=a.n[0]*b.n[0]\n-\tmov r15,[rsi+1*8]\n-\tmov r10,rbp\t\t; load modulus into target register for t0\n-\tmov r8,rax\n-\tand r10,rax\t\t; only need lower qword of c\n-\tshrd r8,rdx,52\n-\txor r9,r9\t\t; c < 2^64, so we ditch the HO part \n-\n-\t;; c+=a.n[0] * b.n[1] + a.n[1] * b.n[0]\n-\tmov rax,[rdi+0*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul r14\t\t\t\n-\tmov r11,rbp\n-\tmov rbx,[rsi+2*8]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r11,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\t;; c+=a.n[0 1 2] * b.n[2 1 0]\n-\tmov rax,[rdi+0*8]\n-\tmul rbx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul r14\n-\tmov r12,rbp\t\t\n-\tmov rcx,[rsi+3*8]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r12,r8\t\t\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[0 1 2 3] * b.n[3 2 1 0]\n-\tmov rax,[rdi+0*8]\n-\tmul rcx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul rbx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\t\n-\tmov rax,[rdi+3*8]\n-\tmul r14\t\t\t\n-\tmov r13,rbp             \n-\tmov rsi,[rsi+4*8]\t; load b.n[4] and destroy pointer\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r13,r8\n-\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\n-\t;; c+=a.n[0 1 2 3 4] * b.n[4 3 2 1 0]\n-\tmov rax,[rdi+0*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+1*8]\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul rbx\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+3*8]\n-\tmul r15\t\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul r14\t\t\t\n-\tmov r14,rbp             ; load modulus into t4 and destroy a.n[0]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r14,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[1 2 3 4] * b.n[4 3 2 1]\n-\tmov rax,[rdi+1*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+2*8]\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+3*8]\n-\tmul rbx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul r15\n-\tmov r15,rbp\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tand r15,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[2 3 4] * b.n[4 3 2]\n-\tmov rax,[rdi+2*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+3*8]\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul rbx\n-\tmov rbx,rbp\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tand rbx,r8\t\t\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[3 4] * b.n[4 3]\n-\tmov rax,[rdi+3*8]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,[rdi+4*8]\n-\tmul rcx\n-\tmov rcx,rbp\t\t\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rcx,r8\t\t\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[4] * b.n[4]\n-\tmov rax,[rdi+4*8]\n-\tmul rsi\n-\t;; mov rbp,rbp\t\t; modulus already there!\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rbp,r8 \n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\tmov rsi,r8\t\t; load c into t9 and destroy b.n[4]\n-\n-\t;; *******************************************************\n-common_exit_norm:\n-\tmov rdi,01000003D10h\t; load constant\n-\n-\tmov rax,r15\t\t; get t5\n-\tmul rdi\n-\tadd rax,r10    \t\t; +t0\n-\tadc rdx,0\n-\tmov r10,0FFFFFFFFFFFFFh ; modulus. Sadly, we ran out of registers!\n-\tmov r8,rax\t\t; +c\n-\tand r10,rax\n-\tshrd r8,rdx,52\n-\txor r9,r9\n-\n-\tmov rax,rbx\t\t; get t6\n-\tmul rdi\n-\tadd rax,r11\t\t; +t1\n-\tadc rdx,0\n-\tmov r11,0FFFFFFFFFFFFFh ; modulus\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r11,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\n-\tmov rax,rcx    \t\t; get t7\n-\tmul rdi\n-\tadd rax,r12\t\t; +t2\n-\tadc rdx,0\n-\tpop rbx\t\t\t; retrieve pointer to this.n\t\n-\tmov r12,0FFFFFFFFFFFFFh ; modulus\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r12,r8\n-\tmov [rbx+2*8],r12\t; mov into this.n[2]\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\tmov rax,rbp    \t\t; get t8\n-\tmul rdi\n-\tadd rax,r13    \t\t; +t3\n-\tadc rdx,0\n-\tmov r13,0FFFFFFFFFFFFFh ; modulus\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r13,r8\n-\tmov [rbx+3*8],r13\t; -> this.n[3]\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\tmov rax,rsi    \t\t; get t9\n-\tmul rdi\n-\tadd rax,r14    \t\t; +t4\n-\tadc rdx,0\n-\tmov r14,0FFFFFFFFFFFFh\t; !!!\n-\tadd r8,rax\t\t; +c\n-\tadc r9,rdx\n-\tand r14,r8\n-\tmov [rbx+4*8],r14\t; -> this.n[4]\n-\tshrd r8,r9,48\t\t; !!!\n-\txor r9,r9\n-\t\n-\tmov rax,01000003D1h\n-\tmul r8\t\t\n-\tadd rax,r10\n-\tadc rdx,0\n-\tmov r10,0FFFFFFFFFFFFFh ; modulus\n-\tmov r8,rax\n-\tand rax,r10\n-\tshrd r8,rdx,52\n-\tmov [rbx+0*8],rax\t; -> this.n[0]\n-\tadd r8,r11\n-\tmov [rbx+1*8],r8\t; -> this.n[1]\n-\n-\tpop r15\n-\tpop r14\n-\tpop r13\n-\tpop r12\n-\tpop rbx\n-\tpop rbp\n-\tret\n-\n-\t\n-\t;;  PROC ExSetSquare\n-\t;;  Register Layout:\n-\t;;  INPUT: \trdi\t = a.n\n-\t;; \t   \trsi  \t = this.a\n-\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n-\t;; \t\tr9:r8    = c\n-\t;; \t\tr10-r13  = t0-t3\n-\t;; \t\tr14\t = a.n[0] / t4\n-\t;; \t\tr15\t = a.n[1] / t5\n-\t;; \t\trbx\t = a.n[2] / t6\n-\t;; \t\trcx\t = a.n[3] / t7\n-\t;; \t\trbp\t = 0FFFFFFFFFFFFFh / t8\n-\t;; \t\trsi\t = a.n[4] / t9\n-\tGLOBAL SYM(secp256k1_fe_sqr_inner)\n-\tALIGN 32\n-SYM(secp256k1_fe_sqr_inner):\n-\tpush rbp\n-\tpush rbx\n-\tpush r12\n-\tpush r13\n-\tpush r14\n-\tpush r15\n-\tpush rsi\n-\tmov rbp,0FFFFFFFFFFFFFh\n-\t\n-\t;; c=a.n[0] * a.n[0]\n-   \tmov r14,[rdi+0*8]\t; r14=a.n[0]\n-\tmov r10,rbp\t\t; modulus \n-\tmov rax,r14\n-\tmul rax\n-\tmov r15,[rdi+1*8]\t; a.n[1]\n-\tadd r14,r14\t\t; r14=2*a.n[0]\n-\tmov r8,rax\n-\tand r10,rax\t\t; only need lower qword\n-\tshrd r8,rdx,52\n-\txor r9,r9\n-\n-\t;; c+=2*a.n[0] * a.n[1]\n-\tmov rax,r14\t\t; r14=2*a.n[0]\n-\tmul r15\n-\tmov rbx,[rdi+2*8]\t; rbx=a.n[2]\n-\tmov r11,rbp \t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r11,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\n-\t\n-\t;; c+=2*a.n[0]*a.n[2]+a.n[1]*a.n[1]\n-\tmov rax,r14\n-\tmul rbx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,r15\n-\tmov r12,rbp\t\t; modulus\n-\tmul rax\n-\tmov rcx,[rdi+3*8]\t; rcx=a.n[3]\n-\tadd r15,r15\t\t; r15=a.n[1]*2\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r12,r8\t\t; only need lower dword\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[0]*a.n[3]+2*a.n[1]*a.n[2]\n-\tmov rax,r14\n-\tmul rcx\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,r15\t\t; rax=2*a.n[1]\n-\tmov r13,rbp\t\t; modulus\n-\tmul rbx\n-\tmov rsi,[rdi+4*8]\t; rsi=a.n[4]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r13,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[0]*a.n[4]+2*a.n[1]*a.n[3]+a.n[2]*a.n[2]\n-\tmov rax,r14\t\t; last time we need 2*a.n[0]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,r15\n-\tmul rcx\n-\tmov r14,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,rbx\n-\tmul rax\n-\tadd rbx,rbx\t\t; rcx=2*a.n[2]\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r14,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[1]*a.n[4]+2*a.n[2]*a.n[3]\n-\tmov rax,r15\t\t; last time we need 2*a.n[1]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,rbx\n-\tmul rcx\n-\tmov r15,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand r15,r8\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[2]*a.n[4]+a.n[3]*a.n[3]\n-\tmov rax,rbx\t\t; last time we need 2*a.n[2]\n-\tmul rsi\n-\tadd r8,rax\n-\tadc r9,rdx\n-\n-\tmov rax,rcx\t\t; a.n[3]\n-\tmul rax\n-\tmov rbx,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rbx,r8\t\t; only need lower dword\n-\tlea rax,[2*rcx]\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=2*a.n[3]*a.n[4]\n-\tmul rsi\n-\tmov rcx,rbp\t\t; modulus\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rcx,r8\t\t; only need lower dword\n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\t;; c+=a.n[4]*a.n[4]\n-\tmov rax,rsi\n-\tmul rax\n-\t;; mov rbp,rbp\t\t; modulus is already there!\n-\tadd r8,rax\n-\tadc r9,rdx\n-\tand rbp,r8 \n-\tshrd r8,r9,52\n-\txor r9,r9\t\t\n-\n-\tmov rsi,r8\n-\n-\t;; *******************************************************\n-\tjmp common_exit_norm\n-\tend\n-\n-\t"
      },
      {
        "sha": "af12fd30d2cf629e18fb8be72b2277d9f04528d2",
        "filename": "src/secp256k1/src/field_5x52_asm_impl.h",
        "status": "modified",
        "additions": 492,
        "deletions": 3,
        "changes": 495,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_5x52_asm_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_5x52_asm_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_asm_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -1,13 +1,502 @@\n /**********************************************************************\n- * Copyright (c) 2013 Pieter Wuille                                   *\n+ * Copyright (c) 2013-2014 Diederik Huys, Pieter Wuille               *\n  * Distributed under the MIT software license, see the accompanying   *\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+/**\n+ * Changelog:\n+ * - March 2013, Diederik Huys:    original version\n+ * - November 2014, Pieter Wuille: updated to use Peter Dettman's parallel multiplication algorithm\n+ * - December 2014, Pieter Wuille: converted from YASM to GCC inline assembly\n+ */\n+\n #ifndef _SECP256K1_FIELD_INNER5X52_IMPL_H_\n #define _SECP256K1_FIELD_INNER5X52_IMPL_H_\n \n-void __attribute__ ((sysv_abi)) secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t *b, uint64_t *r);\n-void __attribute__ ((sysv_abi)) secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r);\n+SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b) {\n+/**\n+ * Registers: rdx:rax = multiplication accumulator\n+ *            r9:r8   = c\n+ *            r15:rcx = d\n+ *            r10-r14 = a0-a4\n+ *            rbx     = b\n+ *            %2      = r\n+ *            %0      = a / t?\n+ *            rbp     = R (0x1000003d10)\n+ */\n+__asm__ __volatile__(\n+    \"pushq %%rbp\\n\"\n+\n+    \"movq 0(%0),%%r10\\n\"\n+    \"movq 8(%0),%%r11\\n\"\n+    \"movq 16(%0),%%r12\\n\"\n+    \"movq 24(%0),%%r13\\n\"\n+    \"movq 32(%0),%%r14\\n\"\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+\n+    /* d += a3 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"movq %%rax,%%rcx\\n\"\n+    \"movq %%rdx,%%r15\\n\"\n+    /* d += a2 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a1 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d = a0 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* c = a4 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += (c & M) * R */\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* t3 (stack) = d & M */\n+    \"movq %%rcx,%0\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* d += a4 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a2 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a1 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a0 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += c * R */\n+    \"movq %%r8,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* t4 = d & M (%0) */\n+    \"movq %%rcx,%0\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* tx = t4 >> 48 (%%rbp, overwrites R) */\n+    \"movq %0,%%rbp\\n\"\n+    \"shrq $48,%%rbp\\n\"\n+    /* t4 &= (M >> 4) (stack) */\n+    \"movq $0xffffffffffff,%%rax\\n\"\n+    \"andq %%rax,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* c = a0 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += a4 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a2 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a1 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* u0 = d & M (%0) */\n+    \"movq %%rcx,%0\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* u0 = (u0 << 4) | tx (%0) */\n+    \"shlq $4,%0\\n\"\n+    \"orq %%rbp,%0\\n\"\n+    /* c += u0 * (R >> 4) */\n+    \"movq $0x1000003d1,%%rax\\n\"\n+    \"mulq %0\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[0] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,0(%2)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += a1 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* c += a0 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d += a4 * b2 */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a2 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* restore rdp = R */\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rcx,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    \"xorq %%r15,%%r15\\n\"\n+    /* r[1] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,8(%2)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += a2 * b0 */\n+    \"movq 0(%%rbx),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* c += a1 * b1 */\n+    \"movq 8(%%rbx),%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* c += a0 * b2 (last use of %%r10 = a0) */\n+    \"movq 16(%%rbx),%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* fetch t3 (%%r10, overwrites a0),t4 (%0) */\n+    \"popq %0\\n\"\n+    \"popq %%r10\\n\"\n+    /* d += a4 * b3 */\n+    \"movq 24(%%rbx),%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* d += a3 * b4 */\n+    \"movq 32(%%rbx),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rcx\\n\"\n+    \"adcq %%rdx,%%r15\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rcx,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 (%%rcx only) */\n+    \"shrdq $52,%%r15,%%rcx\\n\"\n+    /* r[2] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,16(%2)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += t3 */\n+    \"addq %%r10,%%r8\\n\"\n+    /* c += d * R */\n+    \"movq %%rcx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[3] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"movq $0xfffffffffffff,%%rdx\\n\"\n+    \"andq %%rdx,%%rax\\n\"\n+    \"movq %%rax,24(%2)\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* c += t4 (%%r8 only) */\n+    \"addq %0,%%r8\\n\"\n+    /* r[4] = c */\n+    \"movq %%r8,32(%2)\\n\"\n+\n+    \"popq %%rbp\\n\"\n+: \"+S\"(a)\n+: \"b\"(b), \"D\"(r)\n+: \"%rax\", \"%rcx\", \"%rdx\", \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\", \"cc\", \"memory\"\n+);\n+}\n+\n+SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t *a) {\n+/**\n+ * Registers: rdx:rax = multiplication accumulator\n+ *            r9:r8   = c\n+ *            rcx:rbx = d\n+ *            r10-r14 = a0-a4\n+ *            r15     = M (0xfffffffffffff)\n+ *            %1      = r\n+ *            %0      = a / t?\n+ *            rbp     = R (0x1000003d10)\n+ */\n+__asm__ __volatile__(\n+    \"pushq %%rbp\\n\"\n+\n+    \"movq 0(%0),%%r10\\n\"\n+    \"movq 8(%0),%%r11\\n\"\n+    \"movq 16(%0),%%r12\\n\"\n+    \"movq 24(%0),%%r13\\n\"\n+    \"movq 32(%0),%%r14\\n\"\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+    \"movq $0xfffffffffffff,%%r15\\n\"\n+\n+    /* d = (a0*2) * a3 */\n+    \"leaq (%%r10,%%r10,1),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"movq %%rax,%%rbx\\n\"\n+    \"movq %%rdx,%%rcx\\n\"\n+    /* d += (a1*2) * a2 */\n+    \"leaq (%%r11,%%r11,1),%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* c = a4 * a4 */\n+    \"movq %%r14,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += (c & M) * R */\n+    \"andq %%r15,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* t3 (stack) = d & M */\n+    \"movq %%rbx,%0\\n\"\n+    \"andq %%r15,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* a4 *= 2 */\n+    \"addq %%r14,%%r14\\n\"\n+    /* d += a0 * a4 */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d+= (a1*2) * a3 */\n+    \"leaq (%%r11,%%r11,1),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += a2 * a2 */\n+    \"movq %%r12,%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += c * R */\n+    \"movq %%r8,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* t4 = d & M (%0) */\n+    \"movq %%rbx,%0\\n\"\n+    \"andq %%r15,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* tx = t4 >> 48 (%%rbp, overwrites constant) */\n+    \"movq %0,%%rbp\\n\"\n+    \"shrq $48,%%rbp\\n\"\n+    /* t4 &= (M >> 4) (stack) */\n+    \"movq $0xffffffffffff,%%rax\\n\"\n+    \"andq %%rax,%0\\n\"\n+    \"pushq %0\\n\"\n+    /* c = a0 * a0 */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r10\\n\"\n+    \"movq %%rax,%%r8\\n\"\n+    \"movq %%rdx,%%r9\\n\"\n+    /* d += a1 * a4 */\n+    \"movq %%r11,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += (a2*2) * a3 */\n+    \"leaq (%%r12,%%r12,1),%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* u0 = d & M (%0) */\n+    \"movq %%rbx,%0\\n\"\n+    \"andq %%r15,%0\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* u0 = (u0 << 4) | tx (%0) */\n+    \"shlq $4,%0\\n\"\n+    \"orq %%rbp,%0\\n\"\n+    /* c += u0 * (R >> 4) */\n+    \"movq $0x1000003d1,%%rax\\n\"\n+    \"mulq %0\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[0] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,0(%1)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* a0 *= 2 */\n+    \"addq %%r10,%%r10\\n\"\n+    /* c += a0 * a1 */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d += a2 * a4 */\n+    \"movq %%r12,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* d += a3 * a3 */\n+    \"movq %%r13,%%rax\\n\"\n+    \"mulq %%r13\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* load R in %%rbp */\n+    \"movq $0x1000003d10,%%rbp\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rbx,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    \"xorq %%rcx,%%rcx\\n\"\n+    /* r[1] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,8(%1)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += a0 * a2 (last use of %%r10) */\n+    \"movq %%r10,%%rax\\n\"\n+    \"mulq %%r12\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* fetch t3 (%%r10, overwrites a0),t4 (%0) */\n+    \"popq %0\\n\"\n+    \"popq %%r10\\n\"\n+    /* c += a1 * a1 */\n+    \"movq %%r11,%%rax\\n\"\n+    \"mulq %%r11\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d += a3 * a4 */\n+    \"movq %%r13,%%rax\\n\"\n+    \"mulq %%r14\\n\"\n+    \"addq %%rax,%%rbx\\n\"\n+    \"adcq %%rdx,%%rcx\\n\"\n+    /* c += (d & M) * R */\n+    \"movq %%rbx,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* d >>= 52 (%%rbx only) */\n+    \"shrdq $52,%%rcx,%%rbx\\n\"\n+    /* r[2] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,16(%1)\\n\"\n+    /* c >>= 52 */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    \"xorq %%r9,%%r9\\n\"\n+    /* c += t3 */\n+    \"addq %%r10,%%r8\\n\"\n+    /* c += d * R */\n+    \"movq %%rbx,%%rax\\n\"\n+    \"mulq %%rbp\\n\"\n+    \"addq %%rax,%%r8\\n\"\n+    \"adcq %%rdx,%%r9\\n\"\n+    /* r[3] = c & M */\n+    \"movq %%r8,%%rax\\n\"\n+    \"andq %%r15,%%rax\\n\"\n+    \"movq %%rax,24(%1)\\n\"\n+    /* c >>= 52 (%%r8 only) */\n+    \"shrdq $52,%%r9,%%r8\\n\"\n+    /* c += t4 (%%r8 only) */\n+    \"addq %0,%%r8\\n\"\n+    /* r[4] = c */\n+    \"movq %%r8,32(%1)\\n\"\n+\n+    \"popq %%rbp\\n\"\n+: \"+S\"(a)\n+: \"D\"(r)\n+: \"%rax\", \"%rbx\", \"%rcx\", \"%rdx\", \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\", \"cc\", \"memory\"\n+);\n+}\n \n #endif"
      },
      {
        "sha": "63176d6de406cf1276a612904be248e13550576a",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 46,
        "deletions": 2,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -102,6 +102,50 @@ static void secp256k1_fe_normalize(secp256k1_fe_t *r) {\n #endif\n }\n \n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r) {\n+    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];\n+\n+    /* Reduce t4 at the start so there will be at most a single carry from the first pass */\n+    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;\n+    uint64_t m;\n+\n+    /* The first pass ensures the magnitude is 1, ... */\n+    t0 += x * 0x1000003D1ULL;\n+    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; m = t1;\n+    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; m &= t2;\n+    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; m &= t3;\n+\n+    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */\n+    VERIFY_CHECK(t4 >> 49 == 0);\n+\n+    /* At most a single final reduction is needed; check if the value is >= the field characteristic */\n+    x = (t4 >> 48) | ((t4 == 0x0FFFFFFFFFFFFULL) & (m == 0xFFFFFFFFFFFFFULL)\n+        & (t0 >= 0xFFFFEFFFFFC2FULL));\n+\n+    if (x) {\n+        t0 += 0x1000003D1ULL;\n+        t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+        t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;\n+        t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;\n+        t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;\n+\n+        /* If t4 didn't carry to bit 48 already, then it should have after any final reduction */\n+        VERIFY_CHECK(t4 >> 48 == x);\n+\n+        /* Mask off the possible multiple of 2^256 from the final reduction */\n+        t4 &= 0x0FFFFFFFFFFFFULL;\n+    }\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n     r->n[0] = a;\n     r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n@@ -255,7 +299,7 @@ static void secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const s\n     secp256k1_fe_verify(b);\n     VERIFY_CHECK(r != b);\n #endif\n-    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+    secp256k1_fe_mul_inner(r->n, a->n, b->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;\n@@ -268,7 +312,7 @@ static void secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     VERIFY_CHECK(a->magnitude <= 8);\n     secp256k1_fe_verify(a);\n #endif\n-    secp256k1_fe_sqr_inner(a->n, r->n);\n+    secp256k1_fe_sqr_inner(r->n, a->n);\n #ifdef VERIFY\n     r->magnitude = 1;\n     r->normalized = 0;"
      },
      {
        "sha": "ec631833cfa1ad86109691ae05f60d05de933423",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -15,7 +15,7 @@\n #define VERIFY_BITS(x, n) do { } while(0)\n #endif\n \n-SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b, uint64_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b) {\n     VERIFY_BITS(a[0], 56);\n     VERIFY_BITS(a[1], 56);\n     VERIFY_BITS(a[2], 56);\n@@ -152,7 +152,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(const uint64_t *a, const uin\n     /* [r4 r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n \n-SECP256K1_INLINE static void secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r) {\n+SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t *a) {\n     VERIFY_BITS(a[0], 56);\n     VERIFY_BITS(a[1], 56);\n     VERIFY_BITS(a[2], 56);"
      },
      {
        "sha": "73a55c4f00d4523f5851daa9c45ffd5f9ca6dd2e",
        "filename": "src/secp256k1/src/field_gmp_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_gmp_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -46,6 +46,10 @@ static void secp256k1_fe_normalize(secp256k1_fe_t *r) {\n         mpn_sub(r->n, r->n, FIELD_LIMBS, secp256k1_field_p, FIELD_LIMBS);\n }\n \n+static void secp256k1_fe_normalize_var(secp256k1_fe_t *r) {\n+    secp256k1_fe_normalize(r);\n+}\n+\n SECP256K1_INLINE static void secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n     r->n[0] = a;\n     for (int i=1; i<FIELD_LIMBS+1; i++)"
      },
      {
        "sha": "77d9dbf87613e45edecc03034af268a8a0f1517f",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 27,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -66,7 +66,7 @@ static int secp256k1_fe_set_hex(secp256k1_fe_t *r, const char *a, int alen) {\n     return secp256k1_fe_set_b32(r, tmp);\n }\n \n-static int secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+static int secp256k1_fe_sqrt_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n \n     /** The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n      *  { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n@@ -132,7 +132,7 @@ static int secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n     secp256k1_fe_sqr(&t1, r);\n     secp256k1_fe_negate(&t1, &t1, 1);\n     secp256k1_fe_add(&t1, a);\n-    secp256k1_fe_normalize(&t1);\n+    secp256k1_fe_normalize_var(&t1);\n     return secp256k1_fe_is_zero(&t1);\n }\n \n@@ -206,7 +206,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #elif defined(USE_FIELD_INV_NUM)\n     unsigned char b[32];\n     secp256k1_fe_t c = *a;\n-    secp256k1_fe_normalize(&c);\n+    secp256k1_fe_normalize_var(&c);\n     secp256k1_fe_get_b32(b, &c);\n     secp256k1_num_t n;\n     secp256k1_num_set_bin(&n, b, 32);\n@@ -218,30 +218,6 @@ static void secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n #endif\n }\n \n-static void secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n-    if (len < 1)\n-        return;\n-\n-    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n-\n-    r[0] = a[0];\n-\n-    size_t i = 0;\n-    while (++i < len) {\n-        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n-    }\n-\n-    secp256k1_fe_t u; secp256k1_fe_inv(&u, &r[--i]);\n-\n-    while (i > 0) {\n-        int j = i--;\n-        secp256k1_fe_mul(&r[j], &r[i], &u);\n-        secp256k1_fe_mul(&u, &u, &a[j]);\n-    }\n-\n-    r[0] = u;\n-}\n-\n static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n     if (len < 1)\n         return;"
      },
      {
        "sha": "330e0696f4e16a22c60c81452403751cb5e6b3dc",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -51,15 +51,16 @@ static void secp256k1_ge_set_xy(secp256k1_ge_t *r, const secp256k1_fe_t *x, cons\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n-static int secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd);\n+static int secp256k1_ge_set_xo_var(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd);\n \n /** Check whether a group element is the point at infinity. */\n static int secp256k1_ge_is_infinity(const secp256k1_ge_t *a);\n \n /** Check whether a group element is valid (i.e., on the curve). */\n-static int secp256k1_ge_is_valid(const secp256k1_ge_t *a);\n+static int secp256k1_ge_is_valid_var(const secp256k1_ge_t *a);\n \n static void secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a);\n+static void secp256k1_ge_neg_var(secp256k1_ge_t *r, const secp256k1_ge_t *a);\n \n /** Get a hex representation of a point. *rlen will be overwritten with the real length. */\n static void secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a);\n@@ -80,11 +81,11 @@ static void secp256k1_gej_set_xy(secp256k1_gej_t *r, const secp256k1_fe_t *x, co\n /** Set a group element (jacobian) equal to another which is given in affine coordinates. */\n static void secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a);\n \n-/** Get the X coordinate of a group element (jacobian). */\n-static void secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a);\n+/** Compare the X coordinate of a group element (jacobian). */\n+static int secp256k1_gej_eq_x_var(const secp256k1_fe_t *x, const secp256k1_gej_t *a);\n \n /** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n-static void secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+static void secp256k1_gej_neg_var(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n \n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej_t *a);"
      },
      {
        "sha": "b34ed9b25123e137b0524a63deb73e79a4316d84",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 38,
        "deletions": 29,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -28,13 +28,17 @@ static int secp256k1_ge_is_infinity(const secp256k1_ge_t *a) {\n }\n \n static void secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a) {\n-    r->infinity = a->infinity;\n-    r->x = a->x;\n-    r->y = a->y;\n+    *r = *a;\n     secp256k1_fe_normalize(&r->y);\n     secp256k1_fe_negate(&r->y, &r->y, 1);\n }\n \n+static void secp256k1_ge_neg_var(secp256k1_ge_t *r, const secp256k1_ge_t *a) {\n+    *r = *a;\n+    secp256k1_fe_normalize_var(&r->y);\n+    secp256k1_fe_negate(&r->y, &r->y, 1);\n+}\n+\n static void secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a) {\n     char cx[65]; int lx=65;\n     char cy[65]; int ly=65;\n@@ -85,15 +89,16 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge_t *r, secp256k1_gej_t *a) {\n \n static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], const secp256k1_gej_t a[len]) {\n     size_t count = 0;\n-    secp256k1_fe_t az[len];\n+    secp256k1_fe_t *az = malloc(sizeof(secp256k1_fe_t) * len);\n     for (size_t i=0; i<len; i++) {\n         if (!a[i].infinity) {\n             az[count++] = a[i].z;\n         }\n     }\n \n-    secp256k1_fe_t azi[count];\n+    secp256k1_fe_t *azi = malloc(sizeof(secp256k1_fe_t) * count);\n     secp256k1_fe_inv_all_var(count, azi, az);\n+    free(az);\n \n     count = 0;\n     for (size_t i=0; i<len; i++) {\n@@ -106,6 +111,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], cons\n             secp256k1_fe_mul(&r[i].y, &a[i].y, &zi3);\n         }\n     }\n+    free(azi);\n }\n \n static void secp256k1_gej_set_infinity(secp256k1_gej_t *r) {\n@@ -135,16 +141,16 @@ static void secp256k1_ge_clear(secp256k1_ge_t *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd) {\n+static int secp256k1_ge_set_xo_var(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd) {\n     r->x = *x;\n     secp256k1_fe_t x2; secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_t x3; secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&c, &x3);\n-    if (!secp256k1_fe_sqrt(&r->y, &c))\n+    if (!secp256k1_fe_sqrt_var(&r->y, &c))\n         return 0;\n-    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_normalize_var(&r->y);\n     if (secp256k1_fe_is_odd(&r->y) != odd)\n         secp256k1_fe_negate(&r->y, &r->y, 1);\n     return 1;\n@@ -157,25 +163,29 @@ static void secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a) {\n    secp256k1_fe_set_int(&r->z, 1);\n }\n \n-static void secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a) {\n-    secp256k1_fe_t zi2; secp256k1_fe_inv_var(&zi2, &a->z); secp256k1_fe_sqr(&zi2, &zi2);\n-    secp256k1_fe_mul(r, &a->x, &zi2);\n+static int secp256k1_gej_eq_x_var(const secp256k1_fe_t *x, const secp256k1_gej_t *a) {\n+    VERIFY_CHECK(!a->infinity);\n+    secp256k1_fe_t r; secp256k1_fe_sqr(&r, &a->z); secp256k1_fe_mul(&r, &r, x);\n+    secp256k1_fe_t r2 = a->x;\n+    secp256k1_fe_normalize_var(&r);\n+    secp256k1_fe_normalize_var(&r2);\n+    return secp256k1_fe_equal(&r, &r2);\n }\n \n-static void secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+static void secp256k1_gej_neg_var(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n     r->infinity = a->infinity;\n     r->x = a->x;\n     r->y = a->y;\n     r->z = a->z;\n-    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_normalize_var(&r->y);\n     secp256k1_fe_negate(&r->y, &r->y, 1);\n }\n \n static int secp256k1_gej_is_infinity(const secp256k1_gej_t *a) {\n     return a->infinity;\n }\n \n-static int secp256k1_gej_is_valid(const secp256k1_gej_t *a) {\n+static int secp256k1_gej_is_valid_var(const secp256k1_gej_t *a) {\n     if (a->infinity)\n         return 0;\n     /** y^2 = x^3 + 7\n@@ -189,21 +199,21 @@ static int secp256k1_gej_is_valid(const secp256k1_gej_t *a) {\n     secp256k1_fe_t z6; secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n     secp256k1_fe_mul_int(&z6, 7);\n     secp256k1_fe_add(&x3, &z6);\n-    secp256k1_fe_normalize(&y2);\n-    secp256k1_fe_normalize(&x3);\n+    secp256k1_fe_normalize_var(&y2);\n+    secp256k1_fe_normalize_var(&x3);\n     return secp256k1_fe_equal(&y2, &x3);\n }\n \n-static int secp256k1_ge_is_valid(const secp256k1_ge_t *a) {\n+static int secp256k1_ge_is_valid_var(const secp256k1_ge_t *a) {\n     if (a->infinity)\n         return 0;\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_t y2; secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_t x3; secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n     secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n     secp256k1_fe_add(&x3, &c);\n-    secp256k1_fe_normalize(&y2);\n-    secp256k1_fe_normalize(&x3);\n+    secp256k1_fe_normalize_var(&y2);\n+    secp256k1_fe_normalize_var(&x3);\n     return secp256k1_fe_equal(&y2, &x3);\n }\n \n@@ -255,11 +265,11 @@ static void secp256k1_gej_add_var(secp256k1_gej_t *r, const secp256k1_gej_t *a,\n     secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n     secp256k1_fe_t s1; secp256k1_fe_mul(&s1, &a->y, &z22); secp256k1_fe_mul(&s1, &s1, &b->z);\n     secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n-    secp256k1_fe_normalize(&u1);\n-    secp256k1_fe_normalize(&u2);\n+    secp256k1_fe_normalize_var(&u1);\n+    secp256k1_fe_normalize_var(&u2);\n     if (secp256k1_fe_equal(&u1, &u2)) {\n-        secp256k1_fe_normalize(&s1);\n-        secp256k1_fe_normalize(&s2);\n+        secp256k1_fe_normalize_var(&s1);\n+        secp256k1_fe_normalize_var(&s2);\n         if (secp256k1_fe_equal(&s1, &s2)) {\n             secp256k1_gej_double_var(r, a);\n         } else {\n@@ -294,15 +304,14 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *\n     }\n     r->infinity = 0;\n     secp256k1_fe_t z12; secp256k1_fe_sqr(&z12, &a->z);\n-    secp256k1_fe_t u1 = a->x; secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_t u1 = a->x;\n     secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n-    secp256k1_fe_t s1 = a->y; secp256k1_fe_normalize(&s1);\n+    secp256k1_fe_t s1 = a->y; secp256k1_fe_normalize_var(&s1);\n     secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n-    secp256k1_fe_normalize(&u1);\n-    secp256k1_fe_normalize(&u2);\n+    secp256k1_fe_normalize_var(&u1);\n+    secp256k1_fe_normalize_var(&u2);\n     if (secp256k1_fe_equal(&u1, &u2)) {\n-        secp256k1_fe_normalize(&s1);\n-        secp256k1_fe_normalize(&s2);\n+        secp256k1_fe_normalize_var(&s2);\n         if (secp256k1_fe_equal(&s1, &s2)) {\n             secp256k1_gej_double_var(r, a);\n         } else {"
      },
      {
        "sha": "305a240e6c652b6776f278e1da29e53e94fe95e5",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 8,
        "deletions": 26,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b755db9228aad4bed241a8cdb4ebeb2cc3532827/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=b755db9228aad4bed241a8cdb4ebeb2cc3532827",
        "patch": "@@ -46,7 +46,7 @@ void random_group_element_test(secp256k1_ge_t *ge) {\n     secp256k1_fe_t fe;\n     do {\n         random_field_element_test(&fe);\n-        if (secp256k1_ge_set_xo(ge, &fe, secp256k1_rand32() & 1))\n+        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand32() & 1))\n             break;\n     } while(1);\n }\n@@ -459,7 +459,7 @@ void random_fe_non_zero(secp256k1_fe_t *nz) {\n void random_fe_non_square(secp256k1_fe_t *ns) {\n     random_fe_non_zero(ns);\n     secp256k1_fe_t r;\n-    if (secp256k1_fe_sqrt(&r, ns)) {\n+    if (secp256k1_fe_sqrt_var(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -498,23 +498,6 @@ void run_field_inv_var(void) {\n     }\n }\n \n-void run_field_inv_all(void) {\n-    secp256k1_fe_t x[16], xi[16], xii[16];\n-    /* Check it's safe to call for 0 elements */\n-    secp256k1_fe_inv_all(0, xi, x);\n-    for (int i=0; i<count; i++) {\n-        size_t len = (secp256k1_rand32() & 15) + 1;\n-        for (size_t j=0; j<len; j++)\n-            random_fe_non_zero(&x[j]);\n-        secp256k1_fe_inv_all(len, xi, x);\n-        for (size_t j=0; j<len; j++)\n-            CHECK(check_fe_inverse(&x[j], &xi[j]));\n-        secp256k1_fe_inv_all(len, xii, xi);\n-        for (size_t j=0; j<len; j++)\n-            CHECK(check_fe_equal(&x[j], &xii[j]));\n-    }\n-}\n-\n void run_field_inv_all_var(void) {\n     secp256k1_fe_t x[16], xi[16], xii[16];\n     /* Check it's safe to call for 0 elements */\n@@ -549,7 +532,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe_t *a, const secp256k1_fe_t *k) {\n     secp256k1_fe_t r1, r2;\n-    int v = secp256k1_fe_sqrt(&r1, a);\n+    int v = secp256k1_fe_sqrt_var(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -779,22 +762,22 @@ void test_point_times_order(const secp256k1_gej_t *point) {\n     secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n-    CHECK(secp256k1_gej_is_valid(&res1) == 0);\n+    CHECK(secp256k1_gej_is_valid_var(&res1) == 0);\n     secp256k1_ge_t res3;\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n-    CHECK(secp256k1_ge_is_valid(&res3) == 0);\n+    CHECK(secp256k1_ge_is_valid_var(&res3) == 0);\n }\n \n void run_point_times_order(void) {\n     secp256k1_fe_t x; VERIFY_CHECK(secp256k1_fe_set_hex(&x, \"02\", 2));\n     for (int i=0; i<500; i++) {\n         secp256k1_ge_t p;\n-        if (secp256k1_ge_set_xo(&p, &x, 1)) {\n-            CHECK(secp256k1_ge_is_valid(&p));\n+        if (secp256k1_ge_set_xo_var(&p, &x, 1)) {\n+            CHECK(secp256k1_ge_is_valid_var(&p));\n             secp256k1_gej_t j;\n             secp256k1_gej_set_ge(&j, &p);\n-            CHECK(secp256k1_gej_is_valid(&j));\n+            CHECK(secp256k1_gej_is_valid_var(&j));\n             test_point_times_order(&j);\n         }\n         secp256k1_fe_sqr(&x, &x);\n@@ -1185,7 +1168,6 @@ int main(int argc, char **argv) {\n     /* field tests */\n     run_field_inv();\n     run_field_inv_var();\n-    run_field_inv_all();\n     run_field_inv_all_var();\n     run_sqr();\n     run_sqrt();"
      }
    ]
  }
]