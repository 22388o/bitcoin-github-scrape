[
  {
    "sha": "8feb4e4b667361bf23344149c01594abebd56fdb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZmViNGU0YjY2NzM2MWJmMjMzNDQxNDljMDE1OTRhYmViZDU2ZmRi",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2019-12-18T19:27:03Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2019-12-18T19:27:03Z"
      },
      "message": " Add asmap utility which queries a mapping\n\nThe scripts for creating a compact IP->ASN mapping are here:\nhttps://github.com/sipa/asmap\n\nCo-authored-by: Pieter Wuille <pieter.wuille@gmail.com>",
      "tree": {
        "sha": "dec8069422964d91614770ee7966b8f58d9ee2bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dec8069422964d91614770ee7966b8f58d9ee2bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8feb4e4b667361bf23344149c01594abebd56fdb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8feb4e4b667361bf23344149c01594abebd56fdb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8feb4e4b667361bf23344149c01594abebd56fdb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8feb4e4b667361bf23344149c01594abebd56fdb/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89a1f7a250ef70ff2d65701564f1e24bb9280d90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89a1f7a250ef70ff2d65701564f1e24bb9280d90",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89a1f7a250ef70ff2d65701564f1e24bb9280d90"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 109,
      "deletions": 0
    },
    "files": [
      {
        "sha": "cf1a264805490e2f9e53cf6824916b6e3a93015f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8feb4e4b667361bf23344149c01594abebd56fdb/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8feb4e4b667361bf23344149c01594abebd56fdb/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=8feb4e4b667361bf23344149c01594abebd56fdb",
        "patch": "@@ -210,6 +210,7 @@ BITCOIN_CORE_H = \\\n   txmempool.h \\\n   ui_interface.h \\\n   undo.h \\\n+  util/asmap.h \\\n   util/bip32.h \\\n   util/bytevectorhash.h \\\n   util/check.h \\\n@@ -510,6 +511,7 @@ libbitcoin_util_a_SOURCES = \\\n   support/cleanse.cpp \\\n   sync.cpp \\\n   threadinterrupt.cpp \\\n+  util/asmap.cpp \\\n   util/bip32.cpp \\\n   util/bytevectorhash.cpp \\\n   util/error.cpp \\"
      },
      {
        "sha": "ac230e9ee51b5c5313c7e5364deac99fa59dfce5",
        "filename": "src/util/asmap.cpp",
        "status": "added",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8feb4e4b667361bf23344149c01594abebd56fdb/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8feb4e4b667361bf23344149c01594abebd56fdb/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=8feb4e4b667361bf23344149c01594abebd56fdb",
        "patch": "@@ -0,0 +1,97 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <vector>\n+#include <assert.h>\n+#include <crypto/common.h>\n+\n+namespace {\n+\n+uint32_t DecodeBits(std::vector<bool>::const_iterator& bitpos, uint8_t minval, const std::vector<uint8_t> &bit_sizes)\n+{\n+    uint32_t val = minval;\n+    bool bit;\n+    for (std::vector<uint8_t>::const_iterator bit_sizes_it = bit_sizes.begin();\n+        bit_sizes_it != bit_sizes.end(); ++bit_sizes_it) {\n+        if (bit_sizes_it + 1 != bit_sizes.end()) {\n+            bit = *bitpos;\n+            bitpos++;\n+        } else {\n+            bit = 0;\n+        }\n+        if (bit) {\n+            val += (1 << *bit_sizes_it);\n+        } else {\n+            for (int b = 0; b < *bit_sizes_it; b++) {\n+                bit = *bitpos;\n+                bitpos++;\n+                val += bit << (*bit_sizes_it - 1 - b);\n+            }\n+            return val;\n+        }\n+    }\n+    return -1;\n+}\n+\n+const std::vector<uint8_t> TYPE_BIT_SIZES{0, 0, 1};\n+uint32_t DecodeType(std::vector<bool>::const_iterator& bitpos)\n+{\n+    return DecodeBits(bitpos, 0, TYPE_BIT_SIZES);\n+}\n+\n+const std::vector<uint8_t> ASN_BIT_SIZES{15, 16, 17, 18, 19, 20, 21, 22, 23, 24};\n+uint32_t DecodeASN(std::vector<bool>::const_iterator& bitpos)\n+{\n+    return DecodeBits(bitpos, 1, ASN_BIT_SIZES);\n+}\n+\n+\n+const std::vector<uint8_t> MATCH_BIT_SIZES{1, 2, 3, 4, 5, 6, 7, 8};\n+uint32_t DecodeMatch(std::vector<bool>::const_iterator& bitpos)\n+{\n+    return DecodeBits(bitpos, 2, MATCH_BIT_SIZES);\n+}\n+\n+\n+const std::vector<uint8_t> JUMP_BIT_SIZES{5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};\n+uint32_t DecodeJump(std::vector<bool>::const_iterator& bitpos)\n+{\n+    return DecodeBits(bitpos, 17, JUMP_BIT_SIZES);\n+}\n+\n+}\n+\n+uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n+{\n+    std::vector<bool>::const_iterator pos = asmap.begin();\n+    uint8_t bits = ip.size();\n+    uint8_t default_asn = 0;\n+    uint32_t opcode, jump, match, matchlen;\n+    while (1) {\n+        assert(pos != asmap.end());\n+        opcode = DecodeType(pos);\n+        if (opcode == 0) {\n+            return DecodeASN(pos);\n+        } else if (opcode == 1) {\n+            jump = DecodeJump(pos);\n+            if (ip[ip.size() - bits]) {\n+                pos += jump;\n+            }\n+            bits--;\n+        } else if (opcode == 2) {\n+            match = DecodeMatch(pos);\n+            matchlen = CountBits(match) - 1;\n+            for (uint32_t bit = 0; bit < matchlen; bit++) {\n+                if ((ip[ip.size() - bits]) != ((match >> (matchlen - 1 - bit)) & 1)) {\n+                    return default_asn;\n+                }\n+                bits--;\n+            }\n+        } else if (opcode == 3) {\n+            default_asn = DecodeASN(pos);\n+        } else {\n+            assert(0);\n+        }\n+    }\n+}"
      },
      {
        "sha": "a0e14013c56a6cae52208cd87b9f4f11e2f31040",
        "filename": "src/util/asmap.h",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8feb4e4b667361bf23344149c01594abebd56fdb/src/util/asmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8feb4e4b667361bf23344149c01594abebd56fdb/src/util/asmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.h?ref=8feb4e4b667361bf23344149c01594abebd56fdb",
        "patch": "@@ -0,0 +1,10 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_ASMAP_H\n+#define BITCOIN_UTIL_ASMAP_H\n+\n+uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip);\n+\n+#endif // BITCOIN_UTIL_ASMAP_H"
      }
    ]
  },
  {
    "sha": "ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzQ1NjQ2ZGU5ZTYyYjNkNDJjODU3MTZiZmViMDZkOGYyYjUwN2Rj",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2019-12-24T18:18:44Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2019-12-25T13:59:08Z"
      },
      "message": "Integrate ASN bucketing in Addrman and add tests\n\nInstead of using /16 netgroups to bucket nodes in Addrman for connection\ndiversification, ASN, which better represents an actor in terms\nof network-layer infrastructure, is used.\nFor testing, asmap.raw is used. It represents a minimal\nasmap needed for testing purposes.",
      "tree": {
        "sha": "2d3717818d8ea1b9a53f9b53af2390f7aee9ac21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d3717818d8ea1b9a53f9b53af2390f7aee9ac21"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8feb4e4b667361bf23344149c01594abebd56fdb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8feb4e4b667361bf23344149c01594abebd56fdb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8feb4e4b667361bf23344149c01594abebd56fdb"
      }
    ],
    "stats": {
      "total": 551,
      "additions": 473,
      "deletions": 78
    },
    "files": [
      {
        "sha": "f3fc6c706b48e9c6a13013a64dfe0dd404d8758d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -53,7 +53,8 @@ JSON_TEST_FILES = \\\n   test/data/tx_invalid.json \\\n   test/data/tx_valid.json\n \n-RAW_TEST_FILES =\n+RAW_TEST_FILES = \\\n+  test/data/asmap.raw\n \n GENERATED_TEST_FILES = $(JSON_TEST_FILES:.json=.json.h) $(RAW_TEST_FILES:.raw=.raw.h)\n \n@@ -429,3 +430,12 @@ endif\n \t echo \"};};\"; \\\n \t} > \"$@.new\" && mv -f \"$@.new\" \"$@\"\n \t@echo \"Generated $@\"\n+\n+%.raw.h: %.raw\n+\t@$(MKDIR_P) $(@D)\n+\t@{ \\\n+\t echo \"static unsigned const char $(*F)_raw[] = {\" && \\\n+\t $(HEXDUMP) -v -e '8/1 \"0x%02x, \"' -e '\"\\n\"' $< | $(SED) -e 's/0x  ,//g' && \\\n+\t echo \"};\"; \\\n+\t} > \"$@.new\" && mv -f \"$@.new\" \"$@\"\n+\t@echo \"Generated $@\""
      },
      {
        "sha": "2516c6dc7c3d9035e7b82ee41ab24c7294a1eaaf",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 12,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -8,17 +8,17 @@\n #include <hash.h>\n #include <serialize.h>\n \n-int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n+int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n-    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n \n-int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n+int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n {\n-    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n-    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << vchSourceGroupKey).GetCheapHash();\n+    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n }\n@@ -153,7 +153,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     assert(info.nRefCount == 0);\n \n     // which tried bucket to move the entry to\n-    int nKBucket = info.GetTriedBucket(nKey);\n+    int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n     int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n \n     // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n@@ -169,7 +169,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n         nTried--;\n \n         // find which new bucket it belongs to\n-        int nUBucket = infoOld.GetNewBucket(nKey);\n+        int nUBucket = infoOld.GetNewBucket(nKey, m_asmap);\n         int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);\n         ClearNew(nUBucket, nUBucketPos);\n         assert(vvNew[nUBucket][nUBucketPos] == -1);\n@@ -233,7 +233,7 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n         return;\n \n     // which tried bucket to move the entry to\n-    int tried_bucket = info.GetTriedBucket(nKey);\n+    int tried_bucket = info.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);\n \n     // Will moving this address into tried evict another entry?\n@@ -301,7 +301,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n         fNew = true;\n     }\n \n-    int nUBucket = pinfo->GetNewBucket(nKey, source);\n+    int nUBucket = pinfo->GetNewBucket(nKey, source, m_asmap);\n     int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n@@ -439,7 +439,7 @@ int CAddrMan::Check_()\n              if (vvTried[n][i] != -1) {\n                  if (!setTried.count(vvTried[n][i]))\n                      return -11;\n-                 if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey) != n)\n+                 if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey, m_asmap) != n)\n                      return -17;\n                  if (mapInfo[vvTried[n][i]].GetBucketPosition(nKey, false, n) != i)\n                      return -18;\n@@ -545,7 +545,7 @@ void CAddrMan::ResolveCollisions_()\n             CAddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n-            int tried_bucket = info_new.GetTriedBucket(nKey);\n+            int tried_bucket = info_new.GetTriedBucket(nKey, m_asmap);\n             int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);\n             if (!info_new.IsValid()) { // id_new may no longer map to a valid address\n                 erase_collision = true;\n@@ -609,10 +609,33 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     CAddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n-    int tried_bucket = newInfo.GetTriedBucket(nKey);\n+    int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n     int id_old = vvTried[tried_bucket][tried_bucket_pos];\n \n     return mapInfo[id_old];\n }\n+\n+std::vector<bool> CAddrMan::DecodeAsmap(fs::path path)\n+{\n+    std::vector<bool> bits;\n+    FILE *filestr = fsbridge::fopen(path, \"rb\");\n+    CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"Failed to open asmap file from disk.\\n\");\n+        return bits;\n+    }\n+    fseek(filestr, 0, SEEK_END);\n+    int length = ftell(filestr);\n+    LogPrintf(\"Opened asmap file %s (%d bytes) from disk.\\n\", path, length);\n+    fseek(filestr, 0, SEEK_SET);\n+    char cur_byte;\n+    for (int i = 0; i < length; ++i) {\n+        file >> cur_byte;\n+        for (int bit = 0; bit < 8; ++bit) {\n+            bits.push_back((cur_byte >> bit) & 1);\n+        }\n+    }\n+    return bits;\n+}"
      },
      {
        "sha": "40ecef4625669d92618867f73ffcc7f22e3eb291",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 76,
        "deletions": 25,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -12,11 +12,17 @@\n #include <sync.h>\n #include <timedata.h>\n #include <util/system.h>\n+#include <clientversion.h>\n \n #include <map>\n #include <set>\n #include <stdint.h>\n #include <vector>\n+#include <iostream>\n+#include <streams.h>\n+#include <fs.h>\n+#include <hash.h>\n+\n \n /**\n  * Extended statistics about a CAddress\n@@ -72,15 +78,15 @@ class CAddrInfo : public CAddress\n     }\n \n     //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const uint256 &nKey) const;\n+    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const uint256 &nKey, const CNetAddr& src) const;\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const uint256 &nKey) const\n+    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n     {\n-        return GetNewBucket(nKey, source);\n+        return GetNewBucket(nKey, source, asmap);\n     }\n \n     //! Calculate in which position of a bucket to store this entry.\n@@ -174,6 +180,7 @@ static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n  */\n class CAddrMan\n {\n+friend class CAddrManTest;\n protected:\n     //! critical section to protect the inner data structures\n     mutable CCriticalSection cs;\n@@ -268,9 +275,29 @@ class CAddrMan\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n public:\n+    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n+    // Should be always empty if no file was provided.\n+    // This mapping is then used for bucketing nodes in Addrman.\n+    //\n+    // If asmap is provided, nodes will be bucketed by\n+    // AS they belong to, in order to make impossible for a node\n+    // to connect to several nodes hosted in a single AS.\n+    // This is done in response to Erebus attack, but also to generally\n+    // diversify the connections every node creates,\n+    // especially useful when a large fraction of nodes\n+    // operate under a couple of cloud providers.\n+    //\n+    // If a new asmap was provided, the existing records\n+    // would be re-bucketed accordingly.\n+    std::vector<bool> m_asmap;\n+\n+    // Read asmap from provided binary file\n+    static std::vector<bool> DecodeAsmap(fs::path path);\n+\n+\n     /**\n      * serialized format:\n-     * * version byte (currently 1)\n+     * * version byte (1 for pre-asmap files, 2 for files including asmap version)\n      * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)\n      * * nNew\n      * * nTried\n@@ -302,7 +329,7 @@ class CAddrMan\n     {\n         LOCK(cs);\n \n-        unsigned char nVersion = 1;\n+        unsigned char nVersion = 2;\n         s << nVersion;\n         s << ((unsigned char)32);\n         s << nKey;\n@@ -345,6 +372,13 @@ class CAddrMan\n                 }\n             }\n         }\n+        // Store asmap version after bucket entries so that it\n+        // can be ignored by older clients for backward compatibility.\n+        uint256 asmap_version;\n+        if (m_asmap.size() != 0) {\n+            asmap_version = SerializeHash(m_asmap);\n+        }\n+        s << asmap_version;\n     }\n \n     template<typename Stream>\n@@ -353,7 +387,6 @@ class CAddrMan\n         LOCK(cs);\n \n         Clear();\n-\n         unsigned char nVersion;\n         s >> nVersion;\n         unsigned char nKeySize;\n@@ -383,16 +416,6 @@ class CAddrMan\n             mapAddr[info] = n;\n             info.nRandomPos = vRandom.size();\n             vRandom.push_back(n);\n-            if (nVersion != 1 || nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n-                // In case the new table data cannot be used (nVersion unknown, or bucket count wrong),\n-                // immediately try to give them a reference based on their primary source address.\n-                int nUBucket = info.GetNewBucket(nKey);\n-                int nUBucketPos = info.GetBucketPosition(nKey, true, nUBucket);\n-                if (vvNew[nUBucket][nUBucketPos] == -1) {\n-                    vvNew[nUBucket][nUBucketPos] = n;\n-                    info.nRefCount++;\n-                }\n-            }\n         }\n         nIdCount = nNew;\n \n@@ -401,7 +424,7 @@ class CAddrMan\n         for (int n = 0; n < nTried; n++) {\n             CAddrInfo info;\n             s >> info;\n-            int nKBucket = info.GetTriedBucket(nKey);\n+            int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n             int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n             if (vvTried[nKBucket][nKBucketPos] == -1) {\n                 info.nRandomPos = vRandom.size();\n@@ -417,20 +440,48 @@ class CAddrMan\n         }\n         nTried -= nLost;\n \n-        // Deserialize positions in the new table (if possible).\n+        // Store positions in the new table buckets to apply later (if possible).\n+        std::map<int, int> entryToBucket; // Represents which entry belonged to which bucket when serializing\n+\n         for (int bucket = 0; bucket < nUBuckets; bucket++) {\n             int nSize = 0;\n             s >> nSize;\n             for (int n = 0; n < nSize; n++) {\n                 int nIndex = 0;\n                 s >> nIndex;\n                 if (nIndex >= 0 && nIndex < nNew) {\n-                    CAddrInfo &info = mapInfo[nIndex];\n-                    int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n-                    if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n-                        info.nRefCount++;\n-                        vvNew[bucket][nUBucketPos] = nIndex;\n-                    }\n+                    entryToBucket[nIndex] = bucket;\n+                }\n+            }\n+        }\n+\n+        uint256 supplied_asmap_version;\n+        if (m_asmap.size() != 0) {\n+            supplied_asmap_version = SerializeHash(m_asmap);\n+        }\n+        uint256 serialized_asmap_version;\n+        if (nVersion > 1) {\n+            s >> serialized_asmap_version;\n+        }\n+\n+        for (int n = 0; n < nNew; n++) {\n+            CAddrInfo &info = mapInfo[n];\n+            int bucket = entryToBucket[n];\n+            int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n+            if (nVersion == 2 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 &&\n+                info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS && serialized_asmap_version == supplied_asmap_version) {\n+                // Bucketing has not changed, using existing bucket positions for the new table\n+                vvNew[bucket][nUBucketPos] = n;\n+                info.nRefCount++;\n+            } else {\n+                // In case the new table data cannot be used (nVersion unknown, bucket count wrong or new asmap),\n+                // try to give them a reference based on their primary source address.\n+                LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n+                bucket = info.GetNewBucket(nKey, m_asmap);\n+                nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n+                if (vvNew[bucket][nUBucketPos] == -1) {\n+                    vvNew[bucket][nUBucketPos] = n;\n+                    info.nRefCount++;\n                 }\n             }\n         }"
      },
      {
        "sha": "842eea526b9cde5d20ff38bd8426281eee2e8e27",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -52,7 +52,11 @@\n #include <util/threadnames.h>\n #include <util/translation.h>\n #include <util/validation.h>\n+#include <util/asmap.h>\n #include <validation.h>\n+#include <hash.h>\n+\n+\n #include <validationinterface.h>\n #include <walletinitinterface.h>\n \n@@ -97,6 +101,8 @@ static constexpr int DUMP_BANS_INTERVAL = 60 * 15;\n \n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n \n+static const char* DEFAULT_ASMAP_FILENAME=\"ip_asn.map\";\n+\n /**\n  * The PID file facilities.\n  */\n@@ -426,6 +432,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-peertimeout=<n>\", strprintf(\"Specify p2p connection timeout in seconds. This option determines the amount of time a peer may be inactive before the connection to it is dropped. (minimum: 1, default: %d)\", DEFAULT_PEER_CONNECT_TIMEOUT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n #ifdef USE_UPNP\n #if USE_UPNP\n     gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n@@ -1807,6 +1814,25 @@ bool AppInitMain(NodeContext& node)\n         return false;\n     }\n \n+    // Read asmap file if configured\n+    if (gArgs.IsArgSet(\"-asmap\")) {\n+        std::string asmap_file = gArgs.GetArg(\"-asmap\", \"\");\n+        if (asmap_file.empty()) {\n+            asmap_file = DEFAULT_ASMAP_FILENAME;\n+        }\n+        const fs::path asmap_path = GetDataDir() / asmap_file;\n+        std::vector<bool> asmap = CAddrMan::DecodeAsmap(asmap_path);\n+        if (asmap.size() == 0) {\n+            InitError(strprintf(_(\"Could not find or parse specified asmap: '%s'\").translated, asmap_path));\n+            return false;\n+        }\n+        node.connman->SetAsmap(asmap);\n+        const uint256 asmap_version = SerializeHash(asmap);\n+        LogPrintf(\"Using asmap version %s for IP bucketing.\\n\", asmap_version.ToString());\n+    } else {\n+        LogPrintf(\"Using /16 prefix for IP bucketing.\\n\");\n+    }\n+\n     // ********************************************************* Step 13: finished\n \n     SetRPCWarmupFinished();"
      },
      {
        "sha": "004f1de583d0c215b37853d2b90d0c84da058403",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -1758,7 +1758,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     // but inbound and addnode peers do not use our outbound slots.  Inbound peers\n                     // also have the added issue that they're attacker controlled and could be used\n                     // to prevent us from connecting to particular hosts if we used them here.\n-                    setConnected.insert(pnode->addr.GetGroup());\n+                    setConnected.insert(pnode->addr.GetGroup(addrman.m_asmap));\n                     if (pnode->m_tx_relay == nullptr) {\n                         nOutboundBlockRelay++;\n                     } else if (!pnode->fFeeler) {\n@@ -1806,7 +1806,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n-            if (!fFeeler && setConnected.count(addr.GetGroup())) {\n+            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.m_asmap))) {\n                 break;\n             }\n \n@@ -2778,7 +2778,7 @@ CSipHasher CConnman::GetDeterministicRandomizer(uint64_t id) const\n \n uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n {\n-    std::vector<unsigned char> vchNetGroup(ad.GetGroup());\n+    std::vector<unsigned char> vchNetGroup(ad.GetGroup(addrman.m_asmap));\n \n     return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }"
      },
      {
        "sha": "fe520cea73059216065082f71c45df9cc0283773",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -153,6 +153,7 @@ class CConnman\n         bool m_use_addrman_outgoing = true;\n         std::vector<std::string> m_specified_outgoing;\n         std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n     };\n \n     void Init(const Options& connOptions) {\n@@ -330,6 +331,8 @@ class CConnman\n     */\n     int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = asmap; }\n+\n private:\n     struct ListenSocket {\n     public:"
      },
      {
        "sha": "20b6a85905027186d2638add0da82ef6a19ddf4f",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 1,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -6,6 +6,7 @@\n #include <netaddress.h>\n #include <hash.h>\n #include <util/strencodings.h>\n+#include <util/asmap.h>\n #include <tinyformat.h>\n \n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n@@ -410,7 +411,7 @@ bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n  * @note No two connections will be attempted to addresses with the same network\n  *       group.\n  */\n-std::vector<unsigned char> CNetAddr::GetGroup() const\n+std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) const\n {\n     std::vector<unsigned char> vchRet;\n     int nClass = NET_IPV6;\n@@ -470,6 +471,27 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     else\n         nBits = 32;\n \n+    // If asmap is supplied and the address is IPv4/IPv6,\n+    // ignore nBits and use 32/128 bits to obtain ASN from asmap.\n+    // ASN is then returned to be used for bucketing.\n+    if (asmap.size() != 0 && (nClass == NET_IPV4 || nClass == NET_IPV6)) {\n+        nClass = NET_IPV6;\n+        std::vector<bool> ip_bits(128);\n+        for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n+            uint8_t cur_byte = GetByte(15 - byte_i);\n+            for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n+                ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n+            }\n+        }\n+\n+        uint32_t asn = Interpret(asmap, ip_bits);\n+        vchRet.push_back(nClass);\n+        for (int i = 0; i < 4; i++) {\n+            vchRet.push_back((asn >> (8 * i)) & 0xFF);\n+        }\n+        return vchRet;\n+    }\n+\n     vchRet.push_back(nClass);\n \n     // push our ip onto vchRet byte by byte..."
      },
      {
        "sha": "b1a6054e480c2cdd99ffe3847fb4495dfb9b02c1",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -78,7 +78,8 @@ class CNetAddr\n         unsigned int GetByte(int n) const;\n         uint64_t GetHash() const;\n         bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        std::vector<unsigned char> GetGroup() const;\n+        std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n+\n         int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n \n         explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);"
      },
      {
        "sha": "27831dfa9e6be0468f120471dace1b4020ff3b26",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 280,
        "deletions": 21,
        "changes": 301,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -5,20 +5,27 @@\n #include <test/util/setup_common.h>\n #include <string>\n #include <boost/test/unit_test.hpp>\n+#include <util/asmap.h>\n+#include <test/data/asmap.raw.h>\n \n #include <hash.h>\n #include <netbase.h>\n #include <random.h>\n \n class CAddrManTest : public CAddrMan\n {\n+private:\n+    bool deterministic;\n public:\n-    explicit CAddrManTest(bool makeDeterministic = true)\n+    explicit CAddrManTest(bool makeDeterministic = true,\n+        std::vector<bool> asmap = std::vector<bool>())\n     {\n         if (makeDeterministic) {\n             //  Set addrman addr placement to be deterministic.\n             MakeDeterministic();\n         }\n+        deterministic = makeDeterministic;\n+        m_asmap = asmap;\n     }\n \n     //! Ensure that bucket placement is always the same for testing purposes.\n@@ -46,6 +53,21 @@ class CAddrManTest : public CAddrMan\n         CAddrMan::Delete(nId);\n     }\n \n+    // Used to test deserialization\n+    std::pair<int, int> GetBucketAndEntry(const CAddress& addr)\n+    {\n+        LOCK(cs);\n+        int nId = mapAddr[addr];\n+        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n+            for (int entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n+                if (nId == vvNew[bucket][entry]) {\n+                    return std::pair<int, int>(bucket, entry);\n+                }\n+            }\n+        }\n+        return std::pair<int, int>(-1, -1);\n+    }\n+\n     // Simulates connection failure so that we can test eviction of offline nodes\n     void SimConnFail(CService& addr)\n     {\n@@ -57,6 +79,16 @@ class CAddrManTest : public CAddrMan\n          int64_t nLastTry = GetAdjustedTime()-61;\n          Attempt(addr, count_failure, nLastTry);\n      }\n+\n+    void Clear()\n+    {\n+        CAddrMan::Clear();\n+        if (deterministic) {\n+            nKey.SetNull();\n+            insecure_rand = FastRandomContext(true);\n+        }\n+    }\n+\n };\n \n static CNetAddr ResolveIP(const char* ip)\n@@ -83,6 +115,18 @@ static CService ResolveService(std::string ip, int port = 0)\n     return ResolveService(ip.c_str(), port);\n }\n \n+static std::vector<bool> FromBytes(const unsigned char* source, int vector_size) {\n+    std::vector<bool> result(vector_size);\n+    for (int byte_i = 0; byte_i < vector_size / 8; ++byte_i) {\n+        unsigned char cur_byte = source[byte_i];\n+        for (int bit_i = 0; bit_i < 8; ++bit_i) {\n+            result[byte_i * 8 + bit_i] = (cur_byte >> bit_i) & 1;\n+        }\n+    }\n+    return result;\n+}\n+\n+\n BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n@@ -409,7 +453,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n }\n \n \n-BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n+BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n {\n     CAddrManTest addrman;\n \n@@ -424,46 +468,47 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n+    std::vector<bool> asmap; // use /16\n \n-    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1), 40);\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1, asmap), 40);\n \n     // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info1.GetTriedBucket(nKey2, asmap));\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) != info2.GetTriedBucket(nKey1));\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + std::to_string(i)));\n-        int bucket = infoi.GetTriedBucket(nKey1);\n+        int bucket = infoi.GetTriedBucket(nKey1, asmap);\n         buckets.insert(bucket);\n     }\n-    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n-    //  never get more than 8 buckets\n+    // Test: IP addresses in the same /16 prefix should\n+    // never get more than 8 buckets with legacy grouping\n     BOOST_CHECK_EQUAL(buckets.size(), 8U);\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(ResolveService(\"250.\" + std::to_string(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + std::to_string(j) + \".1.1\"));\n-        int bucket = infoj.GetTriedBucket(nKey1);\n+        int bucket = infoj.GetTriedBucket(nKey1, asmap);\n         buckets.insert(bucket);\n     }\n-    // Test: IP addresses in the different groups should map to more than\n-    //  8 buckets.\n+    // Test: IP addresses in the different /16 prefix should map to more than\n+    // 8 buckets with legacy grouping\n     BOOST_CHECK_EQUAL(buckets.size(), 160U);\n }\n \n-BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n+BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n {\n     CAddrManTest addrman;\n \n@@ -477,25 +522,27 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n+    std::vector<bool> asmap; // use /16\n+\n     // Test: Make sure the buckets are what we expect\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), 786);\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1, asmap), 786);\n \n     // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n+    BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), info2.GetNewBucket(nKey1));\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + std::to_string(i)));\n-        int bucket = infoi.GetNewBucket(nKey1);\n+        int bucket = infoi.GetNewBucket(nKey1, asmap);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n@@ -508,10 +555,10 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n                                         ResolveService(\n                                             std::to_string(250 + (j / 255)) + \".\" + std::to_string(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1);\n+        int bucket = infoj.GetNewBucket(nKey1, asmap);\n         buckets.insert(bucket);\n     }\n-    // Test: IP addresses in the same source groups should map to no more\n+    // Test: IP addresses in the same source groups should map to NO MORE\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() <= 64);\n \n@@ -520,14 +567,226 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + std::to_string(p) + \".1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1);\n+        int bucket = infoj.GetNewBucket(nKey1, asmap);\n         buckets.insert(bucket);\n     }\n-    // Test: IP addresses in the different source groups should map to more\n+    // Test: IP addresses in the different source groups should map to MORE\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() > 64);\n }\n \n+// The following three test cases use asmap.raw\n+// We use an artificial minimal mock mapping\n+// 250.0.0.0/8 AS1000\n+// 101.1.0.0/16 AS1\n+// 101.2.0.0/16 AS2\n+// 101.3.0.0/16 AS3\n+// 101.4.0.0/16 AS4\n+// 101.5.0.0/16 AS5\n+// 101.6.0.0/16 AS6\n+// 101.7.0.0/16 AS7\n+// 101.8.0.0/16 AS8\n+BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n+{\n+    CAddrManTest addrman;\n+\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n+\n+    CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n+\n+\n+    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+\n+    uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n+    uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n+\n+    std::vector<bool> asmap = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n+\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1, asmap), 236);\n+\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n+    //  this test could be a security issue.\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info1.GetTriedBucket(nKey2, asmap));\n+\n+    // Test: Two addresses with same IP but different ports can map to\n+    //  different buckets because they have different keys.\n+    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+\n+    BOOST_CHECK(info1.GetKey() != info2.GetKey());\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n+\n+    std::set<int> buckets;\n+    for (int j = 0; j < 255; j++) {\n+        CAddrInfo infoj = CAddrInfo(\n+            CAddress(ResolveService(\"101.\" + std::to_string(j) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"101.\" + std::to_string(j) + \".1.1\"));\n+        int bucket = infoj.GetTriedBucket(nKey1, asmap);\n+        buckets.insert(bucket);\n+    }\n+    // Test: IP addresses in the different /16 prefix MAY map to more than\n+    // 8 buckets.\n+    BOOST_CHECK(buckets.size() > 8);\n+\n+    buckets.clear();\n+    for (int j = 0; j < 255; j++) {\n+        CAddrInfo infoj = CAddrInfo(\n+            CAddress(ResolveService(\"250.\" + std::to_string(j) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + std::to_string(j) + \".1.1\"));\n+        int bucket = infoj.GetTriedBucket(nKey1, asmap);\n+        buckets.insert(bucket);\n+    }\n+    // Test: IP addresses in the different /16 prefix MAY NOT map to more than\n+    // 8 buckets.\n+    BOOST_CHECK(buckets.size() == 8);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n+{\n+    CAddrManTest addrman;\n+\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n+\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n+\n+    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+\n+    uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n+    uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n+\n+    std::vector<bool> asmap = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n+\n+    // Test: Make sure the buckets are what we expect\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), 795);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1, asmap), 795);\n+\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n+    //  this test could be a security issue.\n+    BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n+\n+    // Test: Ports should not affect bucket placement in the addr\n+    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    BOOST_CHECK(info1.GetKey() != info2.GetKey());\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n+\n+    std::set<int> buckets;\n+    for (int i = 0; i < 255; i++) {\n+        CAddrInfo infoi = CAddrInfo(\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n+        int bucket = infoi.GetNewBucket(nKey1, asmap);\n+        buckets.insert(bucket);\n+    }\n+    // Test: IP addresses in the same /16 prefix\n+    // usually map to the same bucket.\n+    BOOST_CHECK_EQUAL(buckets.size(), 1U);\n+\n+    buckets.clear();\n+    for (int j = 0; j < 4 * 255; j++) {\n+        CAddrInfo infoj = CAddrInfo(CAddress(\n+                                        ResolveService(\n+                                            std::to_string(250 + (j / 255)) + \".\" + std::to_string(j % 256) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"251.4.1.1\"));\n+        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        buckets.insert(bucket);\n+    }\n+    // Test: IP addresses in the same source /16 prefix should not map to more\n+    // than 64 buckets.\n+    BOOST_CHECK(buckets.size() <= 64);\n+\n+    buckets.clear();\n+    for (int p = 0; p < 255; p++) {\n+        CAddrInfo infoj = CAddrInfo(\n+            CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n+            ResolveIP(\"101.\" + std::to_string(p) + \".1.1\"));\n+        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        buckets.insert(bucket);\n+    }\n+    // Test: IP addresses in the different source /16 prefixes usually map to MORE\n+    // than 1 bucket.\n+    BOOST_CHECK(buckets.size() > 1);\n+\n+    buckets.clear();\n+    for (int p = 0; p < 255; p++) {\n+        CAddrInfo infoj = CAddrInfo(\n+            CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + std::to_string(p) + \".1.1\"));\n+        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        buckets.insert(bucket);\n+    }\n+    // Test: IP addresses in the different source /16 prefixes sometimes map to NO MORE\n+    // than 1 bucket.\n+    BOOST_CHECK(buckets.size() == 1);\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_serialization)\n+{\n+    std::vector<bool> asmap1 = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n+\n+    CAddrManTest addrman_asmap1(true, asmap1);\n+    CAddrManTest addrman_asmap1_dup(true, asmap1);\n+    CAddrManTest addrman_noasmap;\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+\n+    CAddress addr = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n+    CNetAddr default_source;\n+\n+\n+    addrman_asmap1.Add(addr, default_source);\n+\n+    stream << addrman_asmap1;\n+    // serizalizing/deserializing addrman with the same asmap\n+    stream >> addrman_asmap1_dup;\n+\n+    std::pair<int, int> bucketAndEntry_asmap1 = addrman_asmap1.GetBucketAndEntry(addr);\n+    std::pair<int, int> bucketAndEntry_asmap1_dup = addrman_asmap1_dup.GetBucketAndEntry(addr);\n+    BOOST_CHECK(bucketAndEntry_asmap1.second != -1);\n+    BOOST_CHECK(bucketAndEntry_asmap1_dup.second != -1);\n+\n+    BOOST_CHECK(bucketAndEntry_asmap1.first == bucketAndEntry_asmap1_dup.first);\n+    BOOST_CHECK(bucketAndEntry_asmap1.second == bucketAndEntry_asmap1_dup.second);\n+\n+    // deserializing asmaped peers.dat to non-asmaped addrman\n+    stream << addrman_asmap1;\n+    stream >> addrman_noasmap;\n+    std::pair<int, int> bucketAndEntry_noasmap = addrman_noasmap.GetBucketAndEntry(addr);\n+    BOOST_CHECK(bucketAndEntry_noasmap.second != -1);\n+    BOOST_CHECK(bucketAndEntry_asmap1.first != bucketAndEntry_noasmap.first);\n+    BOOST_CHECK(bucketAndEntry_asmap1.second != bucketAndEntry_noasmap.second);\n+\n+    // deserializing non-asmaped peers.dat to asmaped addrman\n+    addrman_asmap1.Clear();\n+    addrman_noasmap.Clear();\n+    addrman_noasmap.Add(addr, default_source);\n+    stream << addrman_noasmap;\n+    stream >> addrman_asmap1;\n+    std::pair<int, int> bucketAndEntry_asmap1_deser = addrman_asmap1.GetBucketAndEntry(addr);\n+    BOOST_CHECK(bucketAndEntry_asmap1_deser.second != -1);\n+    BOOST_CHECK(bucketAndEntry_asmap1_deser.first != bucketAndEntry_noasmap.first);\n+    BOOST_CHECK(bucketAndEntry_asmap1_deser.first == bucketAndEntry_asmap1_dup.first);\n+    BOOST_CHECK(bucketAndEntry_asmap1_deser.second == bucketAndEntry_asmap1_dup.second);\n+\n+    // used to map to different buckets, now maps to the same bucket.\n+    addrman_asmap1.Clear();\n+    addrman_noasmap.Clear();\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.2.1.1\"), NODE_NONE);\n+    addrman_noasmap.Add(addr, default_source);\n+    addrman_noasmap.Add(addr2, default_source);\n+    std::pair<int, int> bucketAndEntry_noasmap_addr1 = addrman_noasmap.GetBucketAndEntry(addr1);\n+    std::pair<int, int> bucketAndEntry_noasmap_addr2 = addrman_noasmap.GetBucketAndEntry(addr2);\n+    BOOST_CHECK(bucketAndEntry_noasmap_addr1.first != bucketAndEntry_noasmap_addr2.first);\n+    BOOST_CHECK(bucketAndEntry_noasmap_addr1.second != bucketAndEntry_noasmap_addr2.second);\n+    stream << addrman_noasmap;\n+    stream >> addrman_asmap1;\n+    std::pair<int, int> bucketAndEntry_asmap1_deser_addr1 = addrman_asmap1.GetBucketAndEntry(addr1);\n+    std::pair<int, int> bucketAndEntry_asmap1_deser_addr2 = addrman_asmap1.GetBucketAndEntry(addr2);\n+    BOOST_CHECK(bucketAndEntry_asmap1_deser_addr1.first == bucketAndEntry_asmap1_deser_addr2.first);\n+    BOOST_CHECK(bucketAndEntry_asmap1_deser_addr1.second != bucketAndEntry_asmap1_deser_addr2.second);\n+}\n+\n \n BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n {"
      },
      {
        "sha": "3dcf1f3940890af14f613b08aa11387fd002c228",
        "filename": "src/test/data/asmap.raw",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/test/data/asmap.raw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/test/data/asmap.raw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/asmap.raw?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc"
      },
      {
        "sha": "46ca1c8c688c6ecd8405798eeeee73b5a5a7df72",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec45646de9e62b3d42c85716bfeb06d8f2b507dc/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "patch": "@@ -285,23 +285,23 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n \n BOOST_AUTO_TEST_CASE(netbase_getgroup)\n {\n-\n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == std::vector<unsigned char>({0})); // Local -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == std::vector<unsigned char>({0})); // !Valid -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == std::vector<unsigned char>({0})); // RFC1918 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == std::vector<unsigned char>({0})); // RFC3927 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // IPv4\n-    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6145\n-    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6052\n-    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC3964\n-    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC4380\n-    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_ONION, 239})); // Tor\n-    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n-    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n+    std::vector<bool> asmap; // use /16\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // Local -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // !Valid -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // RFC1918 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // RFC3927 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // IPv4\n+    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6145\n+    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6052\n+    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC3964\n+    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC4380\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_ONION, 239})); // Tor\n+    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n+    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n \n     // baz.net sha256 hash: 12929400eb4607c4ac075f087167e75286b179c693eb059a01774b864e8fe505\n     std::vector<unsigned char> internal_group = {NET_INTERNAL, 0x12, 0x92, 0x94, 0x00, 0xeb, 0x46, 0x07, 0xc4, 0xac, 0x07};\n-    BOOST_CHECK(CreateInternal(\"baz.net\").GetGroup() == internal_group);\n+    BOOST_CHECK(CreateInternal(\"baz.net\").GetGroup(asmap) == internal_group);\n }\n \n BOOST_AUTO_TEST_CASE(netbase_parsenetwork)"
      }
    ]
  },
  {
    "sha": "e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDY1OGFhOGVhZjE2MjlkZDVhZjhjZjdiOTcxN2E4ZTcyMDI4MjUx",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2019-12-24T18:26:46Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-01-23T19:22:56Z"
      },
      "message": "Return mapped AS in RPC call getpeerinfo\n\nIf ASN bucketing is used, return a corresponding AS\nused in bucketing for a given peer.",
      "tree": {
        "sha": "1f2ba6f5bfca20d4780d23fb074bdb449796327f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f2ba6f5bfca20d4780d23fb074bdb449796327f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec45646de9e62b3d42c85716bfeb06d8f2b507dc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec45646de9e62b3d42c85716bfeb06d8f2b507dc"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 62,
      "deletions": 35
    },
    "files": [
      {
        "sha": "8068c4010aca91f7d4a25a2af97cebba4c2414ae",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "patch": "@@ -493,12 +493,13 @@ void CNode::SetAddrLocal(const CService& addrLocalIn) {\n \n #undef X\n #define X(name) stats.name = name\n-void CNode::copyStats(CNodeStats &stats)\n+void CNode::copyStats(CNodeStats &stats, std::vector<bool> &m_asmap)\n {\n     stats.nodeid = this->GetId();\n     X(nServices);\n     X(addr);\n     X(addrBind);\n+    stats.m_mapped_as = addr.GetMappedAS(m_asmap);\n     if (m_tx_relay != nullptr) {\n         LOCK(m_tx_relay->cs_filter);\n         stats.fRelayTxes = m_tx_relay->fRelayTxes;\n@@ -2491,7 +2492,7 @@ void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats)\n     vstats.reserve(vNodes.size());\n     for (CNode* pnode : vNodes) {\n         vstats.emplace_back();\n-        pnode->copyStats(vstats.back());\n+        pnode->copyStats(vstats.back(), addrman.m_asmap);\n     }\n }\n "
      },
      {
        "sha": "3180a8c89768f18d0a50b18962ff78d7d20c16e7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "patch": "@@ -606,6 +606,7 @@ class CNodeStats\n     CAddress addr;\n     // Bind address of our side of the connection\n     CAddress addrBind;\n+    uint32_t m_mapped_as;\n };\n \n \n@@ -982,7 +983,7 @@ class CNode\n \n     void CloseSocketDisconnect();\n \n-    void copyStats(CNodeStats &stats);\n+    void copyStats(CNodeStats &stats, std::vector<bool> &m_asmap);\n \n     ServiceFlags GetLocalServices() const\n     {"
      },
      {
        "sha": "bb73c3e013a5224c9f4614dce8eaff0c85574075",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 31,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "patch": "@@ -401,6 +401,39 @@ bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n     return true;\n }\n \n+uint32_t CNetAddr::GetNetClass() const {\n+    uint32_t net_class = NET_IPV6;\n+    if (IsLocal()) {\n+        net_class = 255;\n+    }\n+    if (IsInternal()) {\n+        net_class = NET_INTERNAL;\n+    } else if (!IsRoutable()) {\n+        net_class = NET_UNROUTABLE;\n+    } else if (IsIPv4() || IsRFC6145() || IsRFC6052() || IsRFC3964() || IsRFC4380()) {\n+        net_class = NET_IPV4;\n+    } else if (IsTor()) {\n+        net_class = NET_ONION;\n+    }\n+    return net_class;\n+}\n+\n+uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {\n+    uint32_t net_class = GetNetClass();\n+    if (asmap.size() == 0 || (net_class != NET_IPV4 && net_class != NET_IPV6)) {\n+        return 0; // Indicates not found, safe because AS0 is reserved per RFC7607.\n+    }\n+    std::vector<bool> ip_bits(128);\n+    for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n+        uint8_t cur_byte = GetByte(15 - byte_i);\n+        for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n+            ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n+        }\n+    }\n+    uint32_t mapped_as = Interpret(asmap, ip_bits);\n+    return mapped_as;\n+}\n+\n /**\n  * Get the canonical identifier of our network group\n  *\n@@ -414,53 +447,58 @@ bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) const\n {\n     std::vector<unsigned char> vchRet;\n-    int nClass = NET_IPV6;\n+    uint32_t net_class = GetNetClass();\n+    // If non-empty asmap is supplied and the address is IPv4/IPv6,\n+    // return ASN to be used for bucketing.\n+    uint32_t asn = GetMappedAS(asmap);\n+    if (asn != 0) { // Either asmap was empty, or address has non-asmappable net class (e.g. TOR).\n+        vchRet.push_back(NET_IPV6); // IPv4 and IPv6 with same ASN should be in the same bucket\n+        for (int i = 0; i < 4; i++) {\n+            vchRet.push_back((asn >> (8 * i)) & 0xFF);\n+        }\n+        return vchRet;\n+    }\n+\n+    vchRet.push_back(net_class);\n     int nStartByte = 0;\n     int nBits = 16;\n \n     // all local addresses belong to the same group\n     if (IsLocal())\n     {\n-        nClass = 255;\n         nBits = 0;\n     }\n     // all internal-usage addresses get their own group\n     if (IsInternal())\n     {\n-        nClass = NET_INTERNAL;\n         nStartByte = sizeof(g_internal_prefix);\n         nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;\n     }\n     // all other unroutable addresses belong to the same group\n     else if (!IsRoutable())\n     {\n-        nClass = NET_UNROUTABLE;\n         nBits = 0;\n     }\n     // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n     // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n     else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n     {\n-        nClass = NET_IPV4;\n         nStartByte = 12;\n     }\n     // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n     else if (IsRFC3964())\n     {\n-        nClass = NET_IPV4;\n         nStartByte = 2;\n     }\n     // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n     else if (IsRFC4380())\n     {\n-        vchRet.push_back(NET_IPV4);\n         vchRet.push_back(GetByte(3) ^ 0xFF);\n         vchRet.push_back(GetByte(2) ^ 0xFF);\n         return vchRet;\n     }\n     else if (IsTor())\n     {\n-        nClass = NET_ONION;\n         nStartByte = 6;\n         nBits = 4;\n     }\n@@ -471,29 +509,6 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n     else\n         nBits = 32;\n \n-    // If asmap is supplied and the address is IPv4/IPv6,\n-    // ignore nBits and use 32/128 bits to obtain ASN from asmap.\n-    // ASN is then returned to be used for bucketing.\n-    if (asmap.size() != 0 && (nClass == NET_IPV4 || nClass == NET_IPV6)) {\n-        nClass = NET_IPV6;\n-        std::vector<bool> ip_bits(128);\n-        for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n-            uint8_t cur_byte = GetByte(15 - byte_i);\n-            for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n-                ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n-            }\n-        }\n-\n-        uint32_t asn = Interpret(asmap, ip_bits);\n-        vchRet.push_back(nClass);\n-        for (int i = 0; i < 4; i++) {\n-            vchRet.push_back((asn >> (8 * i)) & 0xFF);\n-        }\n-        return vchRet;\n-    }\n-\n-    vchRet.push_back(nClass);\n-\n     // push our ip onto vchRet byte by byte...\n     while (nBits >= 8)\n     {"
      },
      {
        "sha": "e03a88db94162b98030f9046317b9da5f412a584",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "patch": "@@ -78,8 +78,14 @@ class CNetAddr\n         unsigned int GetByte(int n) const;\n         uint64_t GetHash() const;\n         bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n+        uint32_t GetNetClass() const;\n+\n+        // The AS on the BGP path to the node we use to diversify\n+        // peers in AddrMan bucketing based on the AS infrastructure.\n+        // The ip->AS mapping depends on how asmap is constructed.\n+        uint32_t GetMappedAS(const std::vector<bool> &asmap) const;\n \n+        std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n         int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n \n         explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);"
      },
      {
        "sha": "16ee911c0b80c56ba87265e37f26564e7125f798",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4658aa8eaf1629dd5af8cf7b9717a8e72028251/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "patch": "@@ -83,6 +83,7 @@ static UniValue getpeerinfo(const JSONRPCRequest& request)\n             \"    \\\"addr\\\":\\\"host:port\\\",      (string) The IP address and port of the peer\\n\"\n             \"    \\\"addrbind\\\":\\\"ip:port\\\",    (string) Bind address of the connection to the peer\\n\"\n             \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) Local address as reported by the peer\\n\"\n+            \"    \\\"mapped_as\\\":\\\"mapped_as\\\", (string) The AS in the BGP route to the peer used for diversifying peer selection\\n\"\n             \"    \\\"services\\\":\\\"xxxxxxxxxxxxxxxx\\\",   (string) The services offered\\n\"\n             \"    \\\"servicesnames\\\":[              (array) the services offered, in human-readable form\\n\"\n             \"        \\\"SERVICE_NAME\\\",         (string) the service name if it is recognised\\n\"\n@@ -152,6 +153,9 @@ static UniValue getpeerinfo(const JSONRPCRequest& request)\n             obj.pushKV(\"addrlocal\", stats.addrLocal);\n         if (stats.addrBind.IsValid())\n             obj.pushKV(\"addrbind\", stats.addrBind.ToString());\n+        if (stats.m_mapped_as != 0) {\n+            obj.pushKV(\"mapped_as\", uint64_t(stats.m_mapped_as));\n+        }\n         obj.pushKV(\"services\", strprintf(\"%016x\", stats.nServices));\n         obj.pushKV(\"servicesnames\", GetServicesNames(stats.nServices));\n         obj.pushKV(\"relaytxes\", stats.fRelayTxes);"
      }
    ]
  },
  {
    "sha": "3c1bc40205a3fcab606e70b0e3c13d68b2860e34",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYzFiYzQwMjA1YTNmY2FiNjA2ZTcwYjBlM2MxM2Q2OGIyODYwZTM0",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-01-10T18:08:15Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-01-23T19:23:06Z"
      },
      "message": "Add extra logging of asmap use and bucketing",
      "tree": {
        "sha": "15e674a90f50f0232e73dfe22033b195c72c8200",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15e674a90f50f0232e73dfe22033b195c72c8200"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c1bc40205a3fcab606e70b0e3c13d68b2860e34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c1bc40205a3fcab606e70b0e3c13d68b2860e34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3c1bc40205a3fcab606e70b0e3c13d68b2860e34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c1bc40205a3fcab606e70b0e3c13d68b2860e34/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4658aa8eaf1629dd5af8cf7b9717a8e72028251",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e4658aa8eaf1629dd5af8cf7b9717a8e72028251"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 9,
      "deletions": 2
    },
    "files": [
      {
        "sha": "fc50cf4f9b168aa3b2aa6c861db48ac661322478",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c1bc40205a3fcab606e70b0e3c13d68b2860e34/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c1bc40205a3fcab606e70b0e3c13d68b2860e34/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=3c1bc40205a3fcab606e70b0e3c13d68b2860e34",
        "patch": "@@ -7,20 +7,27 @@\n \n #include <hash.h>\n #include <serialize.h>\n+#include <logging.h>\n \n int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n-    return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n+    int tried_bucket = hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n+    uint32_t mapped_as = GetMappedAS(asmap);\n+    LogPrint(BCLog::NET, \"IP %s mapped to AS%i belongs to tried bucket %i.\\n\", ToStringIP(), mapped_as, tried_bucket);\n+    return tried_bucket;\n }\n \n int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();\n-    return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n+    int new_bucket = hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n+    uint32_t mapped_as = GetMappedAS(asmap);\n+    LogPrint(BCLog::NET, \"IP %s mapped to AS%i belongs to new bucket %i.\\n\", ToStringIP(), mapped_as, new_bucket);\n+    return new_bucket;\n }\n \n int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const"
      }
    ]
  }
]