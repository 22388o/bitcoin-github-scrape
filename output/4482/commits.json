[
  {
    "sha": "42a956709f4f0ca091c63fe3e2cf2c0c2a359741",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MmE5NTY3MDlmNGYwY2EwOTFjNjNmZTNlMmNmMmMwYzJhMzU5NzQx",
    "commit": {
      "author": {
        "name": "Clinton Christian",
        "email": "Clinton.Christian@me.com",
        "date": "2014-07-08T03:22:23Z"
      },
      "committer": {
        "name": "Clinton Christian",
        "email": "Clinton.Christian@me.com",
        "date": "2014-07-08T03:22:23Z"
      },
      "message": "Replace tabs with spaces\n\nWhoever created this file used tabs instead of spaces, which is very inconvenient to anyone that needs to edit this. It also violates PEP 8 (http://legacy.python.org/dev/peps/pep-0008/#id13).",
      "tree": {
        "sha": "6dc4c51573b32c0c9452118cc7103a555767f2bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6dc4c51573b32c0c9452118cc7103a555767f2bf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/42a956709f4f0ca091c63fe3e2cf2c0c2a359741",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42a956709f4f0ca091c63fe3e2cf2c0c2a359741",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/42a956709f4f0ca091c63fe3e2cf2c0c2a359741",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42a956709f4f0ca091c63fe3e2cf2c0c2a359741/comments",
    "author": {
      "login": "pygeek",
      "id": 253664,
      "node_id": "MDQ6VXNlcjI1MzY2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/253664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pygeek",
      "html_url": "https://github.com/pygeek",
      "followers_url": "https://api.github.com/users/pygeek/followers",
      "following_url": "https://api.github.com/users/pygeek/following{/other_user}",
      "gists_url": "https://api.github.com/users/pygeek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pygeek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pygeek/subscriptions",
      "organizations_url": "https://api.github.com/users/pygeek/orgs",
      "repos_url": "https://api.github.com/users/pygeek/repos",
      "events_url": "https://api.github.com/users/pygeek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pygeek/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "pygeek",
      "id": 253664,
      "node_id": "MDQ6VXNlcjI1MzY2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/253664?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pygeek",
      "html_url": "https://github.com/pygeek",
      "followers_url": "https://api.github.com/users/pygeek/followers",
      "following_url": "https://api.github.com/users/pygeek/following{/other_user}",
      "gists_url": "https://api.github.com/users/pygeek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pygeek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pygeek/subscriptions",
      "organizations_url": "https://api.github.com/users/pygeek/orgs",
      "repos_url": "https://api.github.com/users/pygeek/repos",
      "events_url": "https://api.github.com/users/pygeek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pygeek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1fedd65fcf9ac04b70f0fa8cf6caa9629857d586",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fedd65fcf9ac04b70f0fa8cf6caa9629857d586",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1fedd65fcf9ac04b70f0fa8cf6caa9629857d586"
      }
    ],
    "stats": {
      "total": 425,
      "additions": 213,
      "deletions": 212
    },
    "files": [
      {
        "sha": "732de3ef5ea24397ecf7bd3bae50b309e45261d6",
        "filename": "contrib/pyminer/pyminer.py",
        "status": "modified",
        "additions": 213,
        "deletions": 212,
        "changes": 425,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42a956709f4f0ca091c63fe3e2cf2c0c2a359741/contrib/pyminer/pyminer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42a956709f4f0ca091c63fe3e2cf2c0c2a359741/contrib/pyminer/pyminer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/pyminer/pyminer.py?ref=42a956709f4f0ca091c63fe3e2cf2c0c2a359741",
        "patch": "@@ -23,230 +23,231 @@\n pp = pprint.PrettyPrinter(indent=4)\n \n class BitcoinRPC:\n-\tOBJID = 1\n-\n-\tdef __init__(self, host, port, username, password):\n-\t\tauthpair = \"%s:%s\" % (username, password)\n-\t\tself.authhdr = \"Basic %s\" % (base64.b64encode(authpair))\n-\t\tself.conn = httplib.HTTPConnection(host, port, False, 30)\n-\tdef rpc(self, method, params=None):\n-\t\tself.OBJID += 1\n-\t\tobj = { 'version' : '1.1',\n-\t\t\t'method' : method,\n-\t\t\t'id' : self.OBJID }\n-\t\tif params is None:\n-\t\t\tobj['params'] = []\n-\t\telse:\n-\t\t\tobj['params'] = params\n-\t\tself.conn.request('POST', '/', json.dumps(obj),\n-\t\t\t{ 'Authorization' : self.authhdr,\n-\t\t\t  'Content-type' : 'application/json' })\n-\n-\t\tresp = self.conn.getresponse()\n-\t\tif resp is None:\n-\t\t\tprint \"JSON-RPC: no response\"\n-\t\t\treturn None\n-\n-\t\tbody = resp.read()\n-\t\tresp_obj = json.loads(body)\n-\t\tif resp_obj is None:\n-\t\t\tprint \"JSON-RPC: cannot JSON-decode body\"\n-\t\t\treturn None\n-\t\tif 'error' in resp_obj and resp_obj['error'] != None:\n-\t\t\treturn resp_obj['error']\n-\t\tif 'result' not in resp_obj:\n-\t\t\tprint \"JSON-RPC: no result in object\"\n-\t\t\treturn None\n-\n-\t\treturn resp_obj['result']\n-\tdef getblockcount(self):\n-\t\treturn self.rpc('getblockcount')\n-\tdef getwork(self, data=None):\n-\t\treturn self.rpc('getwork', data)\n+    OBJID = 1\n+\n+    def __init__(self, host, port, username, password):\n+        authpair = \"%s:%s\" % (username, password)\n+        self.authhdr = \"Basic %s\" % (base64.b64encode(authpair))\n+        self.conn = httplib.HTTPConnection(host, port, False, 30)\n+    def rpc(self, method, params=None):\n+        self.OBJID += 1\n+        obj = { 'version' : '1.1',\n+            'method' : method,\n+            'id' : self.OBJID }\n+        if params is None:\n+            obj['params'] = []\n+        else:\n+            obj['params'] = params\n+        self.conn.request('POST', '/', json.dumps(obj),\n+            { 'Authorization' : self.authhdr,\n+              'Content-type' : 'application/json' })\n+\n+        resp = self.conn.getresponse()\n+        if resp is None:\n+            print \"JSON-RPC: no response\"\n+            return None\n+\n+        body = resp.read()\n+        resp_obj = json.loads(body)\n+        if resp_obj is None:\n+            print \"JSON-RPC: cannot JSON-decode body\"\n+            return None\n+        if 'error' in resp_obj and resp_obj['error'] != None:\n+            return resp_obj['error']\n+        if 'result' not in resp_obj:\n+            print \"JSON-RPC: no result in object\"\n+            return None\n+\n+        return resp_obj['result']\n+    def getblockcount(self):\n+        return self.rpc('getblockcount')\n+    def getwork(self, data=None):\n+        return self.rpc('getwork', data)\n \n def uint32(x):\n-\treturn x & 0xffffffffL\n+    return x & 0xffffffffL\n \n def bytereverse(x):\n-\treturn uint32(( ((x) << 24) | (((x) << 8) & 0x00ff0000) |\n-\t\t\t(((x) >> 8) & 0x0000ff00) | ((x) >> 24) ))\n+    return uint32(( ((x) << 24) | (((x) << 8) & 0x00ff0000) |\n+            (((x) >> 8) & 0x0000ff00) | ((x) >> 24) ))\n \n def bufreverse(in_buf):\n-\tout_words = []\n-\tfor i in range(0, len(in_buf), 4):\n-\t\tword = struct.unpack('@I', in_buf[i:i+4])[0]\n-\t\tout_words.append(struct.pack('@I', bytereverse(word)))\n-\treturn ''.join(out_words)\n+    out_words = []\n+    for i in range(0, len(in_buf), 4):\n+        word = struct.unpack('@I', in_buf[i:i+4])[0]\n+        out_words.append(struct.pack('@I', bytereverse(word)))\n+    return ''.join(out_words)\n \n def wordreverse(in_buf):\n-\tout_words = []\n-\tfor i in range(0, len(in_buf), 4):\n-\t\tout_words.append(in_buf[i:i+4])\n-\tout_words.reverse()\n-\treturn ''.join(out_words)\n+    out_words = []\n+    for i in range(0, len(in_buf), 4):\n+        out_words.append(in_buf[i:i+4])\n+    out_words.reverse()\n+    return ''.join(out_words)\n \n class Miner:\n-\tdef __init__(self, id):\n-\t\tself.id = id\n-\t\tself.max_nonce = MAX_NONCE\n-\n-\tdef work(self, datastr, targetstr):\n-\t\t# decode work data hex string to binary\n-\t\tstatic_data = datastr.decode('hex')\n-\t\tstatic_data = bufreverse(static_data)\n-\n-\t\t# the first 76b of 80b do not change\n-\t\tblk_hdr = static_data[:76]\n-\n-\t\t# decode 256-bit target value\n-\t\ttargetbin = targetstr.decode('hex')\n-\t\ttargetbin = targetbin[::-1]\t# byte-swap and dword-swap\n-\t\ttargetbin_str = targetbin.encode('hex')\n-\t\ttarget = long(targetbin_str, 16)\n-\n-\t\t# pre-hash first 76b of block header\n-\t\tstatic_hash = hashlib.sha256()\n-\t\tstatic_hash.update(blk_hdr)\n-\n-\t\tfor nonce in xrange(self.max_nonce):\n-\n-\t\t\t# encode 32-bit nonce value\n-\t\t\tnonce_bin = struct.pack(\"<I\", nonce)\n-\n-\t\t\t# hash final 4b, the nonce value\n-\t\t\thash1_o = static_hash.copy()\n-\t\t\thash1_o.update(nonce_bin)\n-\t\t\thash1 = hash1_o.digest()\n-\n-\t\t\t# sha256 hash of sha256 hash\n-\t\t\thash_o = hashlib.sha256()\n-\t\t\thash_o.update(hash1)\n-\t\t\thash = hash_o.digest()\n-\n-\t\t\t# quick test for winning solution: high 32 bits zero?\n-\t\t\tif hash[-4:] != '\\0\\0\\0\\0':\n-\t\t\t\tcontinue\n-\n-\t\t\t# convert binary hash to 256-bit Python long\n-\t\t\thash = bufreverse(hash)\n-\t\t\thash = wordreverse(hash)\n-\n-\t\t\thash_str = hash.encode('hex')\n-\t\t\tl = long(hash_str, 16)\n-\n-\t\t\t# proof-of-work test:  hash < target\n-\t\t\tif l < target:\n-\t\t\t\tprint time.asctime(), \"PROOF-OF-WORK found: %064x\" % (l,)\n-\t\t\t\treturn (nonce + 1, nonce_bin)\n-\t\t\telse:\n-\t\t\t\tprint time.asctime(), \"PROOF-OF-WORK false positive %064x\" % (l,)\n-#\t\t\t\treturn (nonce + 1, nonce_bin)\n-\n-\t\treturn (nonce + 1, None)\n-\n-\tdef submit_work(self, rpc, original_data, nonce_bin):\n-\t\tnonce_bin = bufreverse(nonce_bin)\n-\t\tnonce = nonce_bin.encode('hex')\n-\t\tsolution = original_data[:152] + nonce + original_data[160:256]\n-\t\tparam_arr = [ solution ]\n-\t\tresult = rpc.getwork(param_arr)\n-\t\tprint time.asctime(), \"--> Upstream RPC result:\", result\n-\n-\tdef iterate(self, rpc):\n-\t\twork = rpc.getwork()\n-\t\tif work is None:\n-\t\t\ttime.sleep(ERR_SLEEP)\n-\t\t\treturn\n-\t\tif 'data' not in work or 'target' not in work:\n-\t\t\ttime.sleep(ERR_SLEEP)\n-\t\t\treturn\n-\n-\t\ttime_start = time.time()\n-\n-\t\t(hashes_done, nonce_bin) = self.work(work['data'],\n-\t\t\t\t\t\t     work['target'])\n-\n-\t\ttime_end = time.time()\n-\t\ttime_diff = time_end - time_start\n-\n-\t\tself.max_nonce = long(\n-\t\t\t(hashes_done * settings['scantime']) / time_diff)\n-\t\tif self.max_nonce > 0xfffffffaL:\n-\t\t\tself.max_nonce = 0xfffffffaL\n-\n-\t\tif settings['hashmeter']:\n-\t\t\tprint \"HashMeter(%d): %d hashes, %.2f Khash/sec\" % (\n-\t\t\t      self.id, hashes_done,\n-\t\t\t      (hashes_done / 1000.0) / time_diff)\n-\n-\t\tif nonce_bin is not None:\n-\t\t\tself.submit_work(rpc, work['data'], nonce_bin)\n-\n-\tdef loop(self):\n-\t\trpc = BitcoinRPC(settings['host'], settings['port'],\n-\t\t\t\t settings['rpcuser'], settings['rpcpass'])\n-\t\tif rpc is None:\n-\t\t\treturn\n-\n-\t\twhile True:\n-\t\t\tself.iterate(rpc)\n+    def __init__(self, id):\n+        self.id = id\n+        self.max_nonce = MAX_NONCE\n+\n+    def work(self, datastr, targetstr):\n+        # decode work data hex string to binary\n+        static_data = datastr.decode('hex')\n+        static_data = bufreverse(static_data)\n+\n+        # the first 76b of 80b do not change\n+        blk_hdr = static_data[:76]\n+\n+        # decode 256-bit target value\n+        targetbin = targetstr.decode('hex')\n+        targetbin = targetbin[::-1]    # byte-swap and dword-swap\n+        targetbin_str = targetbin.encode('hex')\n+        target = long(targetbin_str, 16)\n+\n+        # pre-hash first 76b of block header\n+        static_hash = hashlib.sha256()\n+        static_hash.update(blk_hdr)\n+\n+        for nonce in xrange(self.max_nonce):\n+\n+            # encode 32-bit nonce value\n+            nonce_bin = struct.pack(\"<I\", nonce)\n+\n+            # hash final 4b, the nonce value\n+            hash1_o = static_hash.copy()\n+            hash1_o.update(nonce_bin)\n+            hash1 = hash1_o.digest()\n+\n+            # sha256 hash of sha256 hash\n+            hash_o = hashlib.sha256()\n+            hash_o.update(hash1)\n+            hash = hash_o.digest()\n+\n+            # quick test for winning solution: high 32 bits zero?\n+            if hash[-4:] != '\\0\\0\\0\\0':\n+            \tcontinue\n+\n+            # convert binary hash to 256-bit Python long\n+            hash = bufreverse(hash)\n+            hash = wordreverse(hash)\n+\n+            hash_str = hash.encode('hex')\n+            l = long(hash_str, 16)\n+\n+            # proof-of-work test:  hash < target\n+            if l < target:\n+            \tprint time.asctime(), \"PROOF-OF-WORK found: %064x\" % (l,)\n+            \treturn (nonce + 1, nonce_bin)\n+            else:\n+            \tprint time.asctime(), \"PROOF-OF-WORK false positive %064x\" % (l,)\n+#            \treturn (nonce + 1, nonce_bin)\n+\n+        return (nonce + 1, None)\n+\n+    def submit_work(self, rpc, original_data, nonce_bin):\n+        nonce_bin = bufreverse(nonce_bin)\n+        nonce = nonce_bin.encode('hex')\n+        solution = original_data[:152] + nonce + original_data[160:256]\n+        param_arr = [ solution ]\n+        result = rpc.getwork(param_arr)\n+        print time.asctime(), \"--> Upstream RPC result:\", result\n+\n+    def iterate(self, rpc):\n+        work = rpc.getwork()\n+        if work is None:\n+            time.sleep(ERR_SLEEP)\n+            return\n+        if 'data' not in work or 'target' not in work:\n+            time.sleep(ERR_SLEEP)\n+            return\n+\n+        time_start = time.time()\n+\n+        (hashes_done, nonce_bin) = self.work(work['data'],\n+            \t\t\t     work['target'])\n+\n+        time_end = time.time()\n+        time_diff = time_end - time_start\n+\n+        self.max_nonce = long(\n+            (hashes_done * settings['scantime']) / time_diff)\n+        if self.max_nonce > 0xfffffffaL:\n+            self.max_nonce = 0xfffffffaL\n+\n+        if settings['hashmeter']:\n+            print \"HashMeter(%d): %d hashes, %.2f Khash/sec\" % (\n+                  self.id, hashes_done,\n+                  (hashes_done / 1000.0) / time_diff)\n+\n+        if nonce_bin is not None:\n+            self.submit_work(rpc, work['data'], nonce_bin)\n+\n+    def loop(self):\n+        rpc = BitcoinRPC(settings['host'], settings['port'],\n+            \t settings['rpcuser'], settings['rpcpass'])\n+        if rpc is None:\n+            return\n+\n+        while True:\n+            self.iterate(rpc)\n \n def miner_thread(id):\n-\tminer = Miner(id)\n-\tminer.loop()\n+    miner = Miner(id)\n+    miner.loop()\n \n if __name__ == '__main__':\n-\tif len(sys.argv) != 2:\n-\t\tprint \"Usage: pyminer.py CONFIG-FILE\"\n-\t\tsys.exit(1)\n-\n-\tf = open(sys.argv[1])\n-\tfor line in f:\n-\t\t# skip comment lines\n-\t\tm = re.search('^\\s*#', line)\n-\t\tif m:\n-\t\t\tcontinue\n-\n-\t\t# parse key=value lines\n-\t\tm = re.search('^(\\w+)\\s*=\\s*(\\S.*)$', line)\n-\t\tif m is None:\n-\t\t\tcontinue\n-\t\tsettings[m.group(1)] = m.group(2)\n-\tf.close()\n-\n-\tif 'host' not in settings:\n-\t\tsettings['host'] = '127.0.0.1'\n-\tif 'port' not in settings:\n-\t\tsettings['port'] = 8332\n-\tif 'threads' not in settings:\n-\t\tsettings['threads'] = 1\n-\tif 'hashmeter' not in settings:\n-\t\tsettings['hashmeter'] = 0\n-\tif 'scantime' not in settings:\n-\t\tsettings['scantime'] = 30L\n-\tif 'rpcuser' not in settings or 'rpcpass' not in settings:\n-\t\tprint \"Missing username and/or password in cfg file\"\n-\t\tsys.exit(1)\n-\n-\tsettings['port'] = int(settings['port'])\n-\tsettings['threads'] = int(settings['threads'])\n-\tsettings['hashmeter'] = int(settings['hashmeter'])\n-\tsettings['scantime'] = long(settings['scantime'])\n-\n-\tthr_list = []\n-\tfor thr_id in range(settings['threads']):\n-\t\tp = Process(target=miner_thread, args=(thr_id,))\n-\t\tp.start()\n-\t\tthr_list.append(p)\n-\t\ttime.sleep(1)\t\t\t# stagger threads\n-\n-\tprint settings['threads'], \"mining threads started\"\n-\n-\tprint time.asctime(), \"Miner Starts - %s:%s\" % (settings['host'], settings['port'])\n-\ttry:\n-\t\tfor thr_proc in thr_list:\n-\t\t\tthr_proc.join()\n-\texcept KeyboardInterrupt:\n-\t\tpass\n-\tprint time.asctime(), \"Miner Stops - %s:%s\" % (settings['host'], settings['port'])\n+    if len(sys.argv) != 2:\n+        print \"Usage: pyminer.py CONFIG-FILE\"\n+        sys.exit(1)\n+\n+    f = open(sys.argv[1])\n+    for line in f:\n+        # skip comment lines\n+        m = re.search('^\\s*#', line)\n+        if m:\n+            continue\n+\n+        # parse key=value lines\n+        m = re.search('^(\\w+)\\s*=\\s*(\\S.*)$', line)\n+        if m is None:\n+            continue\n+        settings[m.group(1)] = m.group(2)\n+    f.close()\n+\n+    if 'host' not in settings:\n+        settings['host'] = '127.0.0.1'\n+    if 'port' not in settings:\n+        settings['port'] = 8332\n+    if 'threads' not in settings:\n+        settings['threads'] = 1\n+    if 'hashmeter' not in settings:\n+        settings['hashmeter'] = 0\n+    if 'scantime' not in settings:\n+        settings['scantime'] = 30L\n+    if 'rpcuser' not in settings or 'rpcpass' not in settings:\n+        print \"Missing username and/or password in cfg file\"\n+        sys.exit(1)\n+\n+    settings['port'] = int(settings['port'])\n+    settings['threads'] = int(settings['threads'])\n+    settings['hashmeter'] = int(settings['hashmeter'])\n+    settings['scantime'] = long(settings['scantime'])\n+\n+    thr_list = []\n+    for thr_id in range(settings['threads']):\n+        p = Process(target=miner_thread, args=(thr_id,))\n+        p.start()\n+        thr_list.append(p)\n+        time.sleep(1) # stagger threads\n+\n+    print settings['threads'], \"mining threads started\"\n+\n+    print time.asctime(), \"Miner Starts - %s:%s\" % (settings['host'], settings['port'])\n+    try:\n+        for thr_proc in thr_list:\n+            thr_proc.join()\n+    except KeyboardInterrupt:\n+        pass\n+    print time.asctime(), \"Miner Stops - %s:%s\" % (settings['host'], settings['port'])\n+\n "
      }
    ]
  }
]