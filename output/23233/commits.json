[
  {
    "sha": "f36558871c23087ac57fe68e46183865c5ef400f",
    "node_id": "C_kwDOABII59oAKGYzNjU1ODg3MWMyMzA4N2FjNTdmZTY4ZTQ2MTgzODY1YzVlZjQwMGY",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-06T08:48:08Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-04T19:34:10Z"
      },
      "message": "Alter the ChaCha20Poly1305@Bitcoin AEAD to the new specification\n\nCo-authored-by: Dhruv Mehta <856960+dhruv@users.noreply.github.com>",
      "tree": {
        "sha": "8727f51b31fa6bc535547928ddd221e2d312dbaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8727f51b31fa6bc535547928ddd221e2d312dbaf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f36558871c23087ac57fe68e46183865c5ef400f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f36558871c23087ac57fe68e46183865c5ef400f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f36558871c23087ac57fe68e46183865c5ef400f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f36558871c23087ac57fe68e46183865c5ef400f/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24abd8312ec1caa04f9b3bd92cd960e28ca91e17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24abd8312ec1caa04f9b3bd92cd960e28ca91e17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24abd8312ec1caa04f9b3bd92cd960e28ca91e17"
      }
    ],
    "stats": {
      "total": 457,
      "additions": 197,
      "deletions": 260
    },
    "files": [
      {
        "sha": "8c5348f4b048a7bb6daeb682ecd05b588cd64392",
        "filename": "src/bench/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 29,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/bench/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/bench/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha_poly_aead.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -9,7 +9,6 @@\n #include <hash.h>\n \n #include <assert.h>\n-#include <limits>\n \n /* Number of bytes to process per iteration */\n static constexpr uint64_t BUFFER_SIZE_TINY = 64;\n@@ -19,43 +18,28 @@ static constexpr uint64_t BUFFER_SIZE_LARGE = 1024 * 1024;\n static const unsigned char k1[32] = {0};\n static const unsigned char k2[32] = {0};\n \n-static ChaCha20Poly1305AEAD aead(k1, 32, k2, 32);\n-\n static void CHACHA20_POLY1305_AEAD(benchmark::Bench& bench, size_t buffersize, bool include_decryption)\n {\n-    std::vector<unsigned char> in(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-    std::vector<unsigned char> out(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-    uint64_t seqnr_payload = 0;\n-    uint64_t seqnr_aad = 0;\n-    int aad_pos = 0;\n-    uint32_t len = 0;\n+    ChaCha20Poly1305AEAD aead_in(k1, 32, k2, 32);\n+    ChaCha20Poly1305AEAD aead_out(k1, 32, k2, 32);\n+\n+    auto plaintext_len = buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN;\n+    auto ciphertext_len = plaintext_len + POLY1305_TAGLEN;\n+\n+    std::vector<unsigned char> in(plaintext_len, 0);\n+    std::vector<unsigned char> out(ciphertext_len, 0);\n+\n     bench.batch(buffersize).unit(\"byte\").run([&] {\n         // encrypt or decrypt the buffer with a static key\n-        const bool crypt_ok_1 = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true);\n+        const bool crypt_ok_1 = aead_out.Crypt(out.data(), ciphertext_len, in.data(), plaintext_len, true);\n         assert(crypt_ok_1);\n \n         if (include_decryption) {\n-            // if we decrypt, include the GetLength\n-            const bool get_length_ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n-            assert(get_length_ok);\n-            const bool crypt_ok_2 = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true);\n+            // if we decrypt, we need to decrypt the length first and advance the keystream\n+            (void)aead_in.DecryptLength(out.data());\n+            const bool crypt_ok_2 = aead_in.Crypt(in.data(), plaintext_len, out.data(), ciphertext_len, false);\n             assert(crypt_ok_2);\n         }\n-\n-        // increase main sequence number\n-        seqnr_payload++;\n-        // increase aad position (position in AAD keystream)\n-        aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-        if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-            aad_pos = 0;\n-            seqnr_aad++;\n-        }\n-        if (seqnr_payload + 1 == std::numeric_limits<uint64_t>::max()) {\n-            // reuse of nonce+key is okay while benchmarking.\n-            seqnr_payload = 0;\n-            seqnr_aad = 0;\n-            aad_pos = 0;\n-        }\n     });\n }\n "
      },
      {
        "sha": "11f5e396e1ffc9b4fe59bbae6ad577381a154eeb",
        "filename": "src/crypto/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 57,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -4,15 +4,14 @@\n \n #include <crypto/chacha_poly_aead.h>\n \n+#include <crypto/common.h>\n #include <crypto/poly1305.h>\n #include <support/cleanse.h>\n \n #include <assert.h>\n+#include <cstring>\n #include <string.h>\n \n-#include <cstdio>\n-#include <limits>\n-\n #ifndef HAVE_TIMINGSAFE_BCMP\n \n int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n@@ -27,20 +26,56 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n \n-    m_chacha_header.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    m_chacha_main.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    // Set IV to the initial sequence number 0.\n+    m_ctx.SetIV(m_seqnr);\n \n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n }\n \n-bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n+void ChaCha20Forward4064::Crypt(const unsigned char* input, unsigned char* output, size_t bytes)\n+{\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ m_keystream[m_keystream_pos];\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE - CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+\n+            // m_ctx.SetKey() sets both IV and counter to zero, but we need the IV to increment.\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n+\n+ChaCha20Forward4064::~ChaCha20Forward4064()\n+{\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n+\n+ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1,\n+                                           size_t K_1_len,\n+                                           const unsigned char* K_2,\n+                                           size_t K_2_len) : m_chacha_header(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN), m_chacha_main(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN)\n+{\n+    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+}\n+\n+bool ChaCha20Poly1305AEAD::Crypt(unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n {\n     // check buffer boundaries\n     if (\n@@ -53,18 +88,24 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n \n     unsigned char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n     memset(poly_key, 0, sizeof(poly_key));\n-    m_chacha_main.SetIV(seqnr_payload);\n \n-    // block counter 0 for the poly1305 key\n-    // use lower 32bytes for the poly1305 key\n-    // (throws away 32 unused bytes (upper 32) from this ChaCha20 round)\n-    m_chacha_main.Seek(0);\n-    m_chacha_main.Crypt(poly_key, poly_key, sizeof(poly_key));\n+    // 1. AAD (the encrypted packet length), use the header-keystream\n+    if (is_encrypt) {\n+        m_chacha_header.Crypt(src, dest, 3);\n+    } else {\n+        // we must use ChaCha20Poly1305AEAD::DecryptLength before calling ChaCha20Poly1305AEAD::Crypt\n+        // thus the length has already been decrypted, avoid doing it again and messing up the keystream position\n+        // keep the encrypted version of the AAD to not break verifying the MAC\n+        memcpy(dest, src, 3);\n+    }\n+\n+    // 2. derive the poly1305 key from the header-keystream\n+    m_chacha_header.Crypt(poly_key, poly_key, sizeof(poly_key));\n \n-    // if decrypting, verify the tag prior to decryption\n+    // 3. if decrypting, verify the MAC prior to decryption\n     if (!is_encrypt) {\n-        const unsigned char* tag = src + src_len - POLY1305_TAGLEN;\n-        poly1305_auth(expected_tag, src, src_len - POLY1305_TAGLEN, poly_key);\n+        const unsigned char* tag = src + src_len - POLY1305_TAGLEN;            //the MAC appended in the package\n+        poly1305_auth(expected_tag, src, src_len - POLY1305_TAGLEN, poly_key); //the calculated MAC\n \n         // constant time compare the calculated MAC with the provided MAC\n         if (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n@@ -73,54 +114,35 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n             return false;\n         }\n         memory_cleanse(expected_tag, sizeof(expected_tag));\n-        // MAC has been successfully verified, make sure we don't covert it in decryption\n+        // MAC has been successfully verified, make sure we don't decrypt it\n         src_len -= POLY1305_TAGLEN;\n     }\n \n-    // calculate and cache the next 64byte keystream block if requested sequence number is not yet the cache\n-    if (m_cached_aad_seqnr != seqnr_aad) {\n-        m_cached_aad_seqnr = seqnr_aad;\n-        m_chacha_header.SetIV(seqnr_aad);\n-        m_chacha_header.Seek(0);\n-        m_chacha_header.Keystream(m_aad_keystream_buffer, CHACHA20_ROUND_OUTPUT);\n-    }\n-    // crypt the AAD (3 bytes message length) with given position in AAD cipher instance keystream\n-    dest[0] = src[0] ^ m_aad_keystream_buffer[aad_pos];\n-    dest[1] = src[1] ^ m_aad_keystream_buffer[aad_pos + 1];\n-    dest[2] = src[2] ^ m_aad_keystream_buffer[aad_pos + 2];\n-\n-    // Set the playload ChaCha instance block counter to 1 and crypt the payload\n-    m_chacha_main.Seek(1);\n+    // 4. crypt the payload\n     m_chacha_main.Crypt(src + CHACHA20_POLY1305_AEAD_AAD_LEN, dest + CHACHA20_POLY1305_AEAD_AAD_LEN, src_len - CHACHA20_POLY1305_AEAD_AAD_LEN);\n \n-    // If encrypting, calculate and append tag\n+    // 5. If encrypting, calculate and append MAC\n     if (is_encrypt) {\n-        // the poly1305 tag expands over the AAD (3 bytes length) & encrypted payload\n+        // the poly1305 MAC expands over the AAD (3 bytes length) & encrypted payload\n         poly1305_auth(dest + src_len, dest, src_len, poly_key);\n     }\n \n-    // cleanse no longer required MAC and polykey\n+    // cleanse no longer required polykey\n     memory_cleanse(poly_key, sizeof(poly_key));\n     return true;\n }\n \n-bool ChaCha20Poly1305AEAD::GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext)\n+uint32_t ChaCha20Poly1305AEAD::DecryptLength(const uint8_t* ciphertext)\n {\n-    // enforce valid aad position to avoid accessing outside of the 64byte keystream cache\n-    // (there is space for 21 times 3 bytes)\n-    assert(aad_pos >= 0 && aad_pos < CHACHA20_ROUND_OUTPUT - CHACHA20_POLY1305_AEAD_AAD_LEN);\n-    if (m_cached_aad_seqnr != seqnr_aad) {\n-        // we need to calculate the 64 keystream bytes since we reached a new aad sequence number\n-        m_cached_aad_seqnr = seqnr_aad;\n-        m_chacha_header.SetIV(seqnr_aad);                                         // use LE for the nonce\n-        m_chacha_header.Seek(0);                                                  // block counter 0\n-        m_chacha_header.Keystream(m_aad_keystream_buffer, CHACHA20_ROUND_OUTPUT); // write keystream to the cache\n-    }\n-\n-    // decrypt the ciphertext length by XORing the right position of the 64byte keystream cache with the ciphertext\n-    *len24_out = (ciphertext[0] ^ m_aad_keystream_buffer[aad_pos + 0]) |\n-                 (ciphertext[1] ^ m_aad_keystream_buffer[aad_pos + 1]) << 8 |\n-                 (ciphertext[2] ^ m_aad_keystream_buffer[aad_pos + 2]) << 16;\n-\n-    return true;\n+    // decrypt the length\n+    // once we hit the re-key limit in the keystream (byte 4064) we can't go back to decrypt the length again\n+    // we need to keep the decrypted and the encrypted version in memory to check the max packet length and\n+    // to have the capability to verify the MAC\n+    unsigned char length_buffer[CHACHA20_POLY1305_AEAD_AAD_LEN];\n+    m_chacha_header.Crypt(ciphertext, length_buffer, sizeof(length_buffer));\n+\n+    uint32_t len24_out = (length_buffer[0]) |\n+                         (length_buffer[1]) << 8 |\n+                         (length_buffer[2]) << 16;\n+    return len24_out;\n }"
      },
      {
        "sha": "47951e49281902a3c65d9cc08e40f3e90478c5dd",
        "filename": "src/crypto/chacha_poly_aead.h",
        "status": "modified",
        "additions": 71,
        "deletions": 71,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.h?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -6,13 +6,11 @@\n #define BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n \n #include <crypto/chacha20.h>\n-\n-#include <cmath>\n+#include <crypto/poly1305.h>\n \n static constexpr int CHACHA20_POLY1305_AEAD_KEY_LEN = 32;\n static constexpr int CHACHA20_POLY1305_AEAD_AAD_LEN = 3; /* 3 bytes length */\n static constexpr int CHACHA20_ROUND_OUTPUT = 64;         /* 64 bytes per round */\n-static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n \n /* A AEAD class for ChaCha20-Poly1305@bitcoin.\n  *\n@@ -40,107 +38,109 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n  * instances of chacha20.\n  *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n+ * The instance keyed by K_1 is a stream cipher that is used for the per-message\n+ * metadata, specifically for the poly1305 authentication key as well as for the\n+ * length encryption. The second instance, keyed by K_2, is used to encrypt the\n+ * entire payload.\n  *\n  * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n+ * confidential (best effort; for passive observing) but not create an oracle for\n+ * the packet payload cipher by decrypting and using the packet length prior to\n+ * checking the MAC. By using an independently-keyed cipher instance to encrypt\n+ * the length, an active attacker seeking to exploit the packet input handling as\n+ * a decryption oracle can learn nothing about the payload contents or its MAC\n+ * (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+ * can still obtain the message length (ex. active ciphertext bit flipping or\n+ * traffic semantics analysis)\n  *\n- * ==== Packet Handling ====\n+ * The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+ * keyed with K_1 and K_2 and sequence number 0 as IV and a block counter of 0.\n+ * After encrypting 4064 bytes, the following 32 bytes are used to\n+ * re-key the ChaCha20 context.\n  *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n+ * Byte-level forward security is possible by precomputing 4096 bytes of stream\n+ * output, caching it, resetting the key to the final 32 bytes of the output, and\n+ * then wiping the remaining 4064 bytes of cached data as it gets used.\n+ *\n+ * For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+ * K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+ * generate a Poly1305 key.\n  *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n+ * If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+ * 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+ * incrementing the sequence number + 1 and set is as IV (little endian encoding).\n  *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n+ * For the payload, use the ChaCha20 stream keyed with K_2 and apply the same\n+ * re-key rules.\n+ *\n+ *\n+ * ==== Packet Handling ====\n+ *\n+ * When receiving a packet, the length must be decrypted first. When 3 bytes of\n+ * ciphertext length have been received, they MUST be decrypted.\n  *\n  * Once the entire packet has been received, the MAC MUST be checked before\n  * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n+ * MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n  * packet length and the payload together. The calculated MAC is then compared in\n  * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n+ * using ChaCha20 as described above (using stream keyed with K_2).\n  *\n  * Detection of an invalid MAC MUST lead to immediate connection termination.\n  *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n+ * To send a packet, first encode the 3 byte length and encrypt it using the\n+ * ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+ * (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+ * length. Finally, calculate a MAC tag (using poly1305 key from stream keyed with K_1)\n+ * and append it.\n  */\n \n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20Forward4064\n+{\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+\n+public:\n+    ChaCha20Forward4064(const unsigned char* key, size_t keylen);\n+    ~ChaCha20Forward4064();\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n+\n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length) and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_main;                                      // payload\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20Forward4064 m_chacha_header; // AAD cipher instance (encrypted length) and poly1305 key-derivation cipher instance\n+    ChaCha20Forward4064 m_chacha_main;   // payload\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n+\n+        Returns true if encipher succeeds. Upon failure, the data at dest should not be used.\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    [[nodiscard]] bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+\n+    /** Decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AAD keystream will advance. As a result,\n+        DecryptLength() cannot be called multiple times to get the same result. The caller must\n+        cache the result for re-use.\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+        Ciphertext needs to stay encrypted due to the MAC check that will follow (requires encrypted length)\n+        */\n+    [[nodiscard]] uint32_t DecryptLength(const uint8_t* ciphertext);\n };\n \n #endif // BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H"
      },
      {
        "sha": "2b27c1e9e2656524082f259a8d73b0c73e68a686",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 74,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -590,37 +590,24 @@ BOOST_AUTO_TEST_CASE(hkdf_hmac_sha256_l32_tests)\n                 \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\");\n }\n \n-static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aad_length, const std::string& hex_m, const std::string& hex_k1, const std::string& hex_k2, const std::string& hex_aad_keystream, const std::string& hex_encrypted_message, const std::string& hex_encrypted_message_seq_999)\n+static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aad_length, const std::string& hex_m, const std::string& hex_k1, const std::string& hex_k2, const std::string& hex_encrypted_message, const std::string& hex_encrypted_message_seq_999)\n {\n-    // we need two sequence numbers, one for the payload cipher instance...\n-    uint32_t seqnr_payload = 0;\n-    // ... and one for the AAD (length) cipher instance\n-    uint32_t seqnr_aad = 0;\n-    // we need to keep track of the position in the AAD cipher instance\n-    // keystream since we use the same 64byte output 21 times\n-    // (21 times 3 bytes length < 64)\n-    int aad_pos = 0;\n-\n     std::vector<unsigned char> aead_K_1 = ParseHex(hex_k1);\n     std::vector<unsigned char> aead_K_2 = ParseHex(hex_k2);\n     std::vector<unsigned char> plaintext_buf = ParseHex(hex_m);\n-    std::vector<unsigned char> expected_aad_keystream = ParseHex(hex_aad_keystream);\n     std::vector<unsigned char> expected_ciphertext_and_mac = ParseHex(hex_encrypted_message);\n     std::vector<unsigned char> expected_ciphertext_and_mac_sequence999 = ParseHex(hex_encrypted_message_seq_999);\n \n     std::vector<unsigned char> ciphertext_buf(plaintext_buf.size() + POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> plaintext_buf_new(plaintext_buf.size(), 0);\n-    std::vector<unsigned char> cmp_ctx_buffer(64);\n     uint32_t out_len = 0;\n \n     // create the AEAD instance\n-    ChaCha20Poly1305AEAD aead(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n-\n-    // create a chacha20 instance to compare against\n-    ChaCha20 cmp_ctx(aead_K_1.data(), 32);\n+    ChaCha20Poly1305AEAD aead_out(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n+    ChaCha20Poly1305AEAD aead_in(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n \n     // encipher\n-    bool res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n+    bool res = aead_out.Crypt(ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n     // make sure the operation succeeded if expected to succeed\n     BOOST_CHECK_EQUAL(res, must_succeed);\n     if (!res) return;\n@@ -629,56 +616,29 @@ static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aa\n     BOOST_CHECK_EQUAL(expected_ciphertext_and_mac.size(), ciphertext_buf.size());\n     BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac.data(), ciphertext_buf.size()) == 0);\n \n-    // manually construct the AAD keystream\n-    cmp_ctx.SetIV(seqnr_aad);\n-    cmp_ctx.Seek(0);\n-    cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-    BOOST_CHECK(memcmp(expected_aad_keystream.data(), cmp_ctx_buffer.data(), expected_aad_keystream.size()) == 0);\n-    // crypt the 3 length bytes and compare the length\n-    uint32_t len_cmp = 0;\n-    len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-              (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-              (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-    BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-    // encrypt / decrypt 1000 packets\n+    out_len = aead_in.DecryptLength(ciphertext_buf.data());\n+    BOOST_CHECK_EQUAL(out_len, expected_aad_length);\n+    res = aead_in.Crypt(plaintext_buf.data(), plaintext_buf.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n+    BOOST_CHECK_EQUAL(res, must_succeed);\n+    WriteLE32(plaintext_buf.data(), out_len);\n+\n+    // encrypt / decrypt the packet 1000 times\n     for (size_t i = 0; i < 1000; ++i) {\n-        res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n+        res = aead_out.Crypt(ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n         BOOST_CHECK(res);\n-        BOOST_CHECK(aead.GetLength(&out_len, seqnr_aad, aad_pos, ciphertext_buf.data()));\n+        out_len = aead_in.DecryptLength(ciphertext_buf.data());\n         BOOST_CHECK_EQUAL(out_len, expected_aad_length);\n-        res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, plaintext_buf_new.data(), plaintext_buf_new.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n+        res = aead_in.Crypt(plaintext_buf_new.data(), plaintext_buf_new.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n         BOOST_CHECK(res);\n \n+        // length is not decrypted, copy it over\n+        WriteLE32(plaintext_buf_new.data(), out_len);\n+\n         // make sure we repetitive get the same plaintext\n         BOOST_CHECK(memcmp(plaintext_buf.data(), plaintext_buf_new.data(), plaintext_buf.size()) == 0);\n \n-        // compare sequence number 999 against the test vector\n-        if (seqnr_payload == 999) {\n-            BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac_sequence999.data(), expected_ciphertext_and_mac_sequence999.size()) == 0);\n-        }\n-        // set nonce and block counter, output the keystream\n-        cmp_ctx.SetIV(seqnr_aad);\n-        cmp_ctx.Seek(0);\n-        cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-\n-        // crypt the 3 length bytes and compare the length\n-        len_cmp = 0;\n-        len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-                  (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-                  (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-        BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-        // increment the sequence number(s)\n-        // always increment the payload sequence number\n-        // increment the AAD keystream position by its size (3)\n-        // increment the AAD sequence number if we would hit the 64 byte limit\n-        seqnr_payload++;\n-        aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-        if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-            aad_pos = 0;\n-            seqnr_aad++;\n-        }\n+        // compare at iteration 999 against the test vector\n+        if (i == 999) BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac_sequence999.data(), expected_ciphertext_and_mac_sequence999.size()) == 0);\n     }\n }\n \n@@ -688,9 +648,9 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n \n     // must fail with no message\n     TestChaCha20Poly1305AEAD(false, 0,\n-        \"\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\", \"\");\n+                             \"\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\");\n \n     TestChaCha20Poly1305AEAD(true, 0,\n         /* m  */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n@@ -700,19 +660,17 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n         /* encrypted message & MAC */ \"76b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32d2fc11829c1b6c1df1f551cd6131ff08\",\n         /* encrypted message & MAC at sequence 999 */ \"b0a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3aaa7aa16ec62c5e24f040c08bb20c3598\");\n     TestChaCha20Poly1305AEAD(true, 1,\n-        \"0100000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\",\n-        \"77b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32baf0c85b6dff8602b06cf52a6aefc62e\",\n-        \"b1a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3a8bd94d54b5ecabbc41ffbb0c90924080\");\n+                             \"0100000000000000000000000000000000000000000000000000000000000000\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\",\n+                             \"77b8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8bfb6cf9dcd7e2ee807d5ff981eb4a135a\",\n+                             \"c81eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a860942b2888c98e0c1003d0611e527776e88\");\n     TestChaCha20Poly1305AEAD(true, 255,\n-        \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n-        \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-        \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-        \"c640c1711e3ee904ac35c57ab9791c8a1c408603a90b77a83b54f6c844cb4b06d94e7fc6c800e165acd66147e80ec45a567f6ce66d05ec0cae679dceeb890017\",\n-        \"3940c1e92da4582ff6f92a776aeb14d014d384eeb30f660dacf70a14a23fd31e91212701334e2ce1acf5199dc84f4d61ddbe6571bca5af874b4c9226c26e650995d157644e1848b96ed6c2102d5489a050e71d29a5a66ece11de5fb5c9558d54da28fe45b0bc4db4e5b88030bfc4a352b4b7068eccf656bae7ad6a35615315fc7c49d4200388d5eca67c2e822e069336c69b40db67e0f3c81209c50f3216a4b89fb3ae1b984b7851a2ec6f68ab12b101ab120e1ea7313bb93b5a0f71185c7fea017ddb92769861c29dba4fbc432280d5dff21b36d1c4c790128b22699950bb18bf74c448cdfe547d8ed4f657d8005fdc0cd7a050c2d46050a44c4376355858981fbe8b184288276e7a93eabc899c4a\",\n-        \"f039c6689eaeef0456685200feaab9d54bbd9acde4410a3b6f4321296f4a8ca2604b49727d8892c57e005d799b2a38e85e809f20146e08eec75169691c8d4f54a0d51a1e1c7b381e0474eb02f994be9415ef3ffcbd2343f0601e1f3b172a1d494f838824e4df570f8e3b0c04e27966e36c82abd352d07054ef7bd36b84c63f9369afe7ed79b94f953873006b920c3fa251a771de1b63da927058ade119aa898b8c97e42a606b2f6df1e2d957c22f7593c1e2002f4252f4c9ae4bf773499e5cfcfe14dfc1ede26508953f88553bf4a76a802f6a0068d59295b01503fd9a600067624203e880fdf53933b96e1f4d9eb3f4e363dd8165a278ff667a41ee42b9892b077cefff92b93441f7be74cf10e6cd\");\n+                             \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n+                             \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n+                             \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n+                             \"3940c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f897364617ac8d935a41bf9546432360e1c543708\",\n+                             \"c5ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7bd214de0e986fbb1e04de90db8dfb055\");\n }\n \n BOOST_AUTO_TEST_CASE(countbits_tests)"
      },
      {
        "sha": "c9ac69a7561e9c7e77139c61a2145c0ed07eac20",
        "filename": "src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 29,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -8,9 +8,7 @@\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n \n-#include <cassert>\n #include <cstdint>\n-#include <limits>\n #include <vector>\n \n FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n@@ -21,9 +19,6 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n     const std::vector<uint8_t> k2 = ConsumeFixedLengthByteVector(fuzzed_data_provider, CHACHA20_POLY1305_AEAD_KEY_LEN);\n \n     ChaCha20Poly1305AEAD aead(k1.data(), k1.size(), k2.data(), k2.size());\n-    uint64_t seqnr_payload = 0;\n-    uint64_t seqnr_aad = 0;\n-    int aad_pos = 0;\n     size_t buffer_size = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n     std::vector<uint8_t> in(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     std::vector<uint8_t> out(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n@@ -37,32 +32,10 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n                 out = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n             },\n             [&] {\n-                (void)aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n+                (void)aead.Crypt(out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n             },\n             [&] {\n-                uint32_t len = 0;\n-                const bool ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n-                assert(ok);\n-            },\n-            [&] {\n-                if (AdditionOverflow(seqnr_payload, static_cast<uint64_t>(1))) {\n-                    return;\n-                }\n-                seqnr_payload += 1;\n-                aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-                if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-                    aad_pos = 0;\n-                    if (AdditionOverflow(seqnr_aad, static_cast<uint64_t>(1))) {\n-                        return;\n-                    }\n-                    seqnr_aad += 1;\n-                }\n-            },\n-            [&] {\n-                seqnr_payload = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n-            },\n-            [&] {\n-                seqnr_aad = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                (void)aead.DecryptLength(in.data());\n             },\n             [&] {\n                 is_encrypt = fuzzed_data_provider.ConsumeBool();"
      }
    ]
  },
  {
    "sha": "6a651b5352e7444ad55e04e2738d241f8ef72518",
    "node_id": "C_kwDOABII59oAKDZhNjUxYjUzNTJlNzQ0NGFkNTVlMDRlMjczOGQyNDFmOGVmNzI1MTg",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-08-23T18:54:58Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-04T19:34:13Z"
      },
      "message": "test: clarify that encrypted length is payload length",
      "tree": {
        "sha": "e27ddb48428660da4288a4466400e4bfb113bb27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e27ddb48428660da4288a4466400e4bfb113bb27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a651b5352e7444ad55e04e2738d241f8ef72518",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a651b5352e7444ad55e04e2738d241f8ef72518",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a651b5352e7444ad55e04e2738d241f8ef72518",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a651b5352e7444ad55e04e2738d241f8ef72518/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f36558871c23087ac57fe68e46183865c5ef400f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f36558871c23087ac57fe68e46183865c5ef400f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f36558871c23087ac57fe68e46183865c5ef400f"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 13,
      "deletions": 9
    },
    "files": [
      {
        "sha": "fe968fe5ca98025c21c66b6590043bd2e9b34290",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a651b5352e7444ad55e04e2738d241f8ef72518/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a651b5352e7444ad55e04e2738d241f8ef72518/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=6a651b5352e7444ad55e04e2738d241f8ef72518",
        "patch": "@@ -652,25 +652,29 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n                              \"0000000000000000000000000000000000000000000000000000000000000000\",\n                              \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\");\n \n-    TestChaCha20Poly1305AEAD(true, 0,\n-        /* m  */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n+    // The expected AAD length is the length of the payload portion of the ciphertext.\n+    TestChaCha20Poly1305AEAD(true, 29,\n+        /* m  */ \"1d00000000000000000000000000000000000000000000000000000000000000\",\n         /* k1 (AAD) */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n         /* k2 (payload) */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        /* AAD keystream */ \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\",\n-        /* encrypted message & MAC */ \"76b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32d2fc11829c1b6c1df1f551cd6131ff08\",\n-        /* encrypted message & MAC at sequence 999 */ \"b0a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3aaa7aa16ec62c5e24f040c08bb20c3598\");\n+        /* encrypted message & MAC */ \"6bb8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8babf71de83e6e27c82490bdc8615d0c9e\",\n+        /* encrypted message & MAC at encrypt/decrypt-loop 999 */ \"d41eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a8609f829400edc18e70080d082eae6a1e2f6\");\n+\n+    // If the encrypted length is wrong, the MAC will help us catch a man-in-the-middle bit flipping attack. However, if the incorrect\n+    // length was encrypted by the sender, the cipher suite cannot help.\n     TestChaCha20Poly1305AEAD(true, 1,\n                              \"0100000000000000000000000000000000000000000000000000000000000000\",\n                              \"0000000000000000000000000000000000000000000000000000000000000000\",\n                              \"0000000000000000000000000000000000000000000000000000000000000000\",\n                              \"77b8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8bfb6cf9dcd7e2ee807d5ff981eb4a135a\",\n                              \"c81eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a860942b2888c98e0c1003d0611e527776e88\");\n-    TestChaCha20Poly1305AEAD(true, 255,\n-                             \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n+\n+    TestChaCha20Poly1305AEAD(true, 252,\n+                             \"fc0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n                              \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n                              \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-                             \"3940c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f897364617ac8d935a41bf9546432360e1c543708\",\n-                             \"c5ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7bd214de0e986fbb1e04de90db8dfb055\");\n+                             \"3a40c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f89736461917bb2791faffbe34650c8501daaef76\",\n+                             \"c6ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7474f2e646d37ea226eb611c315bdee8b\");\n }\n \n BOOST_AUTO_TEST_CASE(countbits_tests)"
      }
    ]
  },
  {
    "sha": "d47be87560f128ba7e913b068b9d33fa84310efd",
    "node_id": "C_kwDOABII59oAKGQ0N2JlODc1NjBmMTI4YmE3ZTkxM2IwNjhiOWQzM2ZhODQzMTBlZmQ",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2019-08-09T13:32:26Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-08T20:43:34Z"
      },
      "message": "Add BIP324 short-IDs to protocol.cpp\n\nCo-authored-by: Jonas Schnelli <dev@jonasschnelli.ch>",
      "tree": {
        "sha": "4767729d803795775e11d74f58c238e86c011724",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4767729d803795775e11d74f58c238e86c011724"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d47be87560f128ba7e913b068b9d33fa84310efd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d47be87560f128ba7e913b068b9d33fa84310efd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d47be87560f128ba7e913b068b9d33fa84310efd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d47be87560f128ba7e913b068b9d33fa84310efd/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a651b5352e7444ad55e04e2738d241f8ef72518",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a651b5352e7444ad55e04e2738d241f8ef72518",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a651b5352e7444ad55e04e2738d241f8ef72518"
      }
    ],
    "stats": {
      "total": 115,
      "additions": 72,
      "deletions": 43
    },
    "files": [
      {
        "sha": "921f983c3e618061e5d69593b3f694df920926bf",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d47be87560f128ba7e913b068b9d33fa84310efd/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d47be87560f128ba7e913b068b9d33fa84310efd/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d47be87560f128ba7e913b068b9d33fa84310efd",
        "patch": "@@ -2971,8 +2971,9 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n         m_tx_relay = std::make_unique<TxRelay>();\n     }\n \n-    for (const std::string &msg : getAllNetMessageTypes())\n-        mapRecvBytesPerMsgCmd[msg] = 0;\n+    for (const auto& msg : getAllNetMessageTypes()) {\n+        mapRecvBytesPerMsgCmd[msg.second] = 0;\n+    }\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n     if (fLogIPs) {"
      },
      {
        "sha": "0dccfdc417bf0788ab2c9dba392f0dacf5c7f8eb",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 40,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d47be87560f128ba7e913b068b9d33fa84310efd/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d47be87560f128ba7e913b068b9d33fa84310efd/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=d47be87560f128ba7e913b068b9d33fa84310efd",
        "patch": "@@ -46,46 +46,44 @@ const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n } // namespace NetMsgType\n \n-/** All known message types. Keep this in the same order as the list of\n+/** All known message types including the short-ID. Keep this in the same order as the list of\n  * messages above and in protocol.h.\n  */\n-const static std::string allNetMessageTypes[] = {\n-    NetMsgType::VERSION,\n-    NetMsgType::VERACK,\n-    NetMsgType::ADDR,\n-    NetMsgType::ADDRV2,\n-    NetMsgType::SENDADDRV2,\n-    NetMsgType::INV,\n-    NetMsgType::GETDATA,\n-    NetMsgType::MERKLEBLOCK,\n-    NetMsgType::GETBLOCKS,\n-    NetMsgType::GETHEADERS,\n-    NetMsgType::TX,\n-    NetMsgType::HEADERS,\n-    NetMsgType::BLOCK,\n-    NetMsgType::GETADDR,\n-    NetMsgType::MEMPOOL,\n-    NetMsgType::PING,\n-    NetMsgType::PONG,\n-    NetMsgType::NOTFOUND,\n-    NetMsgType::FILTERLOAD,\n-    NetMsgType::FILTERADD,\n-    NetMsgType::FILTERCLEAR,\n-    NetMsgType::SENDHEADERS,\n-    NetMsgType::FEEFILTER,\n-    NetMsgType::SENDCMPCT,\n-    NetMsgType::CMPCTBLOCK,\n-    NetMsgType::GETBLOCKTXN,\n-    NetMsgType::BLOCKTXN,\n-    NetMsgType::GETCFILTERS,\n-    NetMsgType::CFILTER,\n-    NetMsgType::GETCFHEADERS,\n-    NetMsgType::CFHEADERS,\n-    NetMsgType::GETCFCHECKPT,\n-    NetMsgType::CFCHECKPT,\n-    NetMsgType::WTXIDRELAY,\n-};\n-const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n+const static std::map<uint8_t, std::string> allNetMessageTypes = {\n+    {37, NetMsgType::VERSION},\n+    {36, NetMsgType::VERACK},\n+    {13, NetMsgType::ADDR},\n+    {45, NetMsgType::ADDRV2},\n+    {46, NetMsgType::SENDADDRV2},\n+    {27, NetMsgType::INV},\n+    {24, NetMsgType::GETDATA},\n+    {29, NetMsgType::MERKLEBLOCK},\n+    {22, NetMsgType::GETBLOCKS},\n+    {25, NetMsgType::GETHEADERS},\n+    {35, NetMsgType::TX},\n+    {26, NetMsgType::HEADERS},\n+    {14, NetMsgType::BLOCK},\n+    {21, NetMsgType::GETADDR},\n+    {28, NetMsgType::MEMPOOL},\n+    {31, NetMsgType::PING},\n+    {32, NetMsgType::PONG},\n+    {30, NetMsgType::NOTFOUND},\n+    {20, NetMsgType::FILTERLOAD},\n+    {18, NetMsgType::FILTERADD},\n+    {19, NetMsgType::FILTERCLEAR},\n+    {34, NetMsgType::SENDHEADERS},\n+    {17, NetMsgType::FEEFILTER},\n+    {33, NetMsgType::SENDCMPCT},\n+    {16, NetMsgType::CMPCTBLOCK},\n+    {23, NetMsgType::GETBLOCKTXN},\n+    {15, NetMsgType::BLOCKTXN},\n+    {38, NetMsgType::GETCFILTERS},\n+    {39, NetMsgType::CFILTER},\n+    {40, NetMsgType::GETCFHEADERS},\n+    {41, NetMsgType::CFHEADERS},\n+    {42, NetMsgType::GETCFCHECKPT},\n+    {43, NetMsgType::CFCHECKPT},\n+    {44, NetMsgType::WTXIDRELAY}};\n \n CMessageHeader::CMessageHeader(const MessageStartChars& pchMessageStartIn, const char* pszCommand, unsigned int nMessageSizeIn)\n {\n@@ -176,9 +174,9 @@ std::string CInv::ToString() const\n     }\n }\n \n-const std::vector<std::string> &getAllNetMessageTypes()\n+const std::map<uint8_t, std::string>& getAllNetMessageTypes()\n {\n-    return allNetMessageTypesVec;\n+    return allNetMessageTypes;\n }\n \n /**\n@@ -225,3 +223,23 @@ GenTxid ToGenTxid(const CInv& inv)\n     assert(inv.IsGenTxMsg());\n     return inv.IsMsgWtx() ? GenTxid::Wtxid(inv.hash) : GenTxid::Txid(inv.hash);\n }\n+\n+std::optional<uint8_t> GetShortIDFromMessageType(const std::string& message_type)\n+{\n+    for (const std::pair<uint8_t, std::string> entry : allNetMessageTypes) {\n+        if (entry.second == message_type) {\n+            return entry.first;\n+        }\n+    }\n+    return {};\n+}\n+\n+bool GetMessageTypeFromShortID(const uint8_t shortID, std::string& message_type)\n+{\n+    auto it = allNetMessageTypes.find(shortID);\n+    if (it != allNetMessageTypes.end()) {\n+        message_type = it->second;\n+        return true;\n+    }\n+    return false;\n+}"
      },
      {
        "sha": "0a2c62cacc3097dbd7e711fbb723aac62532d8cd",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d47be87560f128ba7e913b068b9d33fa84310efd/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d47be87560f128ba7e913b068b9d33fa84310efd/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=d47be87560f128ba7e913b068b9d33fa84310efd",
        "patch": "@@ -265,7 +265,17 @@ extern const char* WTXIDRELAY;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */\n-const std::vector<std::string>& getAllNetMessageTypes();\n+const std::map<uint8_t, std::string>& getAllNetMessageTypes();\n+\n+/** Short message type IDs are a low bandwidth representations of a message type\n+ *   The mapping is a peer to peer agreement\n+ *\n+ *   returns the short ID for a message type (if known) */\n+std::optional<uint8_t> GetShortIDFromMessageType(const std::string& message_type);\n+\n+/** returns the message type (string) from a short ID\n+ * returns an empty string if short ID has not been found */\n+bool GetMessageTypeFromShortID(const uint8_t shortID, std::string& message_type);\n \n /** nServices flags */\n enum ServiceFlags : uint64_t {"
      }
    ]
  },
  {
    "sha": "756179741e329b9f14081ccc44e6e03608d5821a",
    "node_id": "C_kwDOABII59oAKDc1NjE3OTc0MWUzMjliOWYxNDA4MWNjYzQ0ZTZlMDM2MDhkNTgyMWE",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2020-03-02T13:30:45Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-23T20:09:33Z"
      },
      "message": "Add BIP324 v2 transport serializer and deserializer\n\nCo-authored-by: Jonas Schnelli <dev@jonasschnelli.ch>",
      "tree": {
        "sha": "a32a5fb8203a130e6c61cbe80213899afadcd1cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a32a5fb8203a130e6c61cbe80213899afadcd1cd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/756179741e329b9f14081ccc44e6e03608d5821a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/756179741e329b9f14081ccc44e6e03608d5821a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/756179741e329b9f14081ccc44e6e03608d5821a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/756179741e329b9f14081ccc44e6e03608d5821a/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d47be87560f128ba7e913b068b9d33fa84310efd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d47be87560f128ba7e913b068b9d33fa84310efd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d47be87560f128ba7e913b068b9d33fa84310efd"
      }
    ],
    "stats": {
      "total": 262,
      "additions": 253,
      "deletions": 9
    },
    "files": [
      {
        "sha": "f63cf685e67b5f661597d4bd72c9ad6015c6da42",
        "filename": "src/crypto/chacha_poly_aead.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/756179741e329b9f14081ccc44e6e03608d5821a/src/crypto/chacha_poly_aead.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/756179741e329b9f14081ccc44e6e03608d5821a/src/crypto/chacha_poly_aead.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.h?ref=756179741e329b9f14081ccc44e6e03608d5821a",
        "patch": "@@ -10,6 +10,7 @@\n \n static constexpr int CHACHA20_POLY1305_AEAD_KEY_LEN = 32;\n static constexpr int CHACHA20_POLY1305_AEAD_AAD_LEN = 3; /* 3 bytes length */\n+static constexpr int CHACHA20_POLY1305_AEAD_TAG_LEN = POLY1305_TAGLEN;\n static constexpr int CHACHA20_ROUND_OUTPUT = 64;         /* 64 bytes per round */\n \n /* A AEAD class for ChaCha20-Poly1305@bitcoin."
      },
      {
        "sha": "6237332b2350dc5de387ab2f7ccc6c2394cd442f",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 176,
        "deletions": 4,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/756179741e329b9f14081ccc44e6e03608d5821a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/756179741e329b9f14081ccc44e6e03608d5821a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=756179741e329b9f14081ccc44e6e03608d5821a",
        "patch": "@@ -27,6 +27,7 @@\n #include <util/strencodings.h>\n #include <util/syscall_sandbox.h>\n #include <util/system.h>\n+#include <util/string.h>\n #include <util/thread.h>\n #include <util/trace.h>\n #include <util/translation.h>\n@@ -60,6 +61,8 @@ static_assert (MAX_BLOCK_RELAY_ONLY_ANCHORS <= static_cast<size_t>(MAX_BLOCK_REL\n /** Anchor IP address database file name */\n const char* const ANCHORS_DATABASE_FILENAME = \"anchors.dat\";\n \n+static constexpr uint64_t V2_MAX_PAYLOAD_LENGTH = 0x01000000 - 1; // 2^24 - 1\n+\n // How often to dump addresses to peers.dat\n static constexpr std::chrono::minutes DUMP_PEERS_INTERVAL{15};\n \n@@ -106,6 +109,8 @@ const std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n static const uint64_t RANDOMIZER_ID_LOCALHOSTNONCE = 0xd93e69e2bbfa5735ULL; // SHA256(\"localhostnonce\")[0:8]\n static const uint64_t RANDOMIZER_ID_ADDRCACHE = 0x1cf2e4ddd306dda9ULL; // SHA256(\"addrcache\")[0:8]\n+\n+static constexpr uint8_t NET_P2P_V2_CMD_MAX_CHARS_SIZE = 12; //maximal length for V2 (BIP324) string message commands\n //\n // Global state variables\n //\n@@ -627,7 +632,14 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n         if (m_deserializer->Complete()) {\n             // decompose a transport agnostic CNetMessage from the deserializer\n             bool reject_message{false};\n-            CNetMessage msg = m_deserializer->GetMessage(time, reject_message);\n+            bool disconnect{false};\n+            CNetMessage msg = m_deserializer->GetMessage(time, reject_message, disconnect);\n+\n+            if (disconnect) {\n+                // v2 p2p incorrect MAC tag. Disconnect from peer.\n+                return false;\n+            }\n+\n             if (reject_message) {\n                 // Message deserialization failed.  Drop the message but don't disconnect the peer.\n                 // store the size of the corrupt message\n@@ -719,10 +731,12 @@ const uint256& V1TransportDeserializer::GetMessageHash() const\n     return data_hash;\n }\n \n-CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds time, bool& reject_message)\n+CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds time, bool& reject_message, bool& disconnect)\n {\n     // Initialize out parameter\n     reject_message = false;\n+    disconnect = false;\n+\n     // decompose a single CNetMessage from the TransportDeserializer\n     CNetMessage msg(std::move(vRecv));\n \n@@ -744,6 +758,7 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n                  HexStr(Span<uint8_t>(hash.begin(), hash.begin() + CMessageHeader::CHECKSUM_SIZE)),\n                  HexStr(hdr.pchChecksum),\n                  m_node_id);\n+        // TODO: Should we disconnect the v1 peer in this case?\n         reject_message = true;\n     } else if (!hdr.IsCommandValid()) {\n         LogPrint(BCLog::NET, \"Header error: Invalid message type (%s, %u bytes), peer=%d\\n\",\n@@ -756,7 +771,160 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) {\n+int V2TransportDeserializer::readHeader(Span<const uint8_t> msg_bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    const unsigned int remaining = CHACHA20_POLY1305_AEAD_AAD_LEN - m_hdr_pos;\n+    const unsigned int copy_bytes = std::min<unsigned int>(remaining, msg_bytes.size());\n+\n+    memcpy(&vRecv[m_hdr_pos], msg_bytes.data(), copy_bytes);\n+    m_hdr_pos += copy_bytes;\n+\n+    // if AAD incomplete, exit\n+    if (m_hdr_pos < CHACHA20_POLY1305_AEAD_AAD_LEN) {\n+        return copy_bytes;\n+    }\n+\n+    // we got the AAD bytes at this point (3 bytes encrypted packet length)\n+    m_message_size = m_aead->DecryptLength((const uint8_t*)vRecv.data());\n+\n+    // reject messages larger than MAX_SIZE\n+    if (m_message_size > V2_MAX_PAYLOAD_LENGTH) {\n+        return -1;\n+    }\n+\n+    // switch state to reading message data\n+    m_in_data = true;\n+\n+    return copy_bytes;\n+}\n+int V2TransportDeserializer::readData(Span<const uint8_t> msg_bytes)\n+{\n+    // Read the message data (command, payload & MAC)\n+    const unsigned int remaining = m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN - m_data_pos;\n+    const unsigned int copy_bytes = std::min<unsigned int>(remaining, msg_bytes.size());\n+\n+    // extend buffer, respect previous copied AAD part\n+    if (vRecv.size() < CHACHA20_POLY1305_AEAD_AAD_LEN + m_data_pos + copy_bytes) {\n+        // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+        vRecv.resize(CHACHA20_POLY1305_AEAD_AAD_LEN + std::min(m_message_size, m_data_pos + copy_bytes + 256 * 1024) + CHACHA20_POLY1305_AEAD_TAG_LEN);\n+    }\n+\n+    memcpy(&vRecv[CHACHA20_POLY1305_AEAD_AAD_LEN + m_data_pos], msg_bytes.data(), copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+\n+CNetMessage V2TransportDeserializer::GetMessage(const std::chrono::microseconds time, bool& reject_message, bool& disconnect)\n+{\n+    // Initialize out parameters\n+    reject_message = false;\n+    disconnect = false;\n+\n+    // In v2, vRecv contains the encrypted length (AAD), encrypted payload plus the MAC tag\n+    // (3 bytes AAD + 1-13 bytes serialized message command + ? bytes message payload + 16 byte MAC tag)\n+    assert(Complete());\n+\n+    std::string command_name;\n+\n+    // defensive decryption (MAC check, decryption, command deserialization)\n+    // we'll always return a CNetMessage (even if decryption fails)\n+    if (m_aead->Crypt((unsigned char*)vRecv.data(), vRecv.size(), (const uint8_t*)vRecv.data(), vRecv.size(), false)) {\n+        // MAC check was successful\n+        // We can remove packet length (stored in m_message_size) and MAC tag (verified)\n+        assert(vRecv.size() >= CHACHA20_POLY1305_AEAD_AAD_LEN + CHACHA20_POLY1305_AEAD_TAG_LEN);\n+\n+        // CDataStream::erase at the begin will just increase the read pos\n+        vRecv.erase(vRecv.begin(), vRecv.begin() + CHACHA20_POLY1305_AEAD_AAD_LEN);\n+        vRecv.erase(vRecv.end() - CHACHA20_POLY1305_AEAD_TAG_LEN, vRecv.end());\n+\n+        uint8_t size_or_shortid = 0;\n+        try {\n+            vRecv >> size_or_shortid;\n+        } catch (const std::ios_base::failure&) {\n+            LogPrint(BCLog::NET, \"Invalid message type, peer=%d\\n\", m_node_id);\n+            reject_message = true;\n+        }\n+\n+        if (size_or_shortid > 0 && size_or_shortid <= NET_P2P_V2_CMD_MAX_CHARS_SIZE && vRecv.size() >= size_or_shortid) {\n+            // first byte is a number between 1 and 12. Must be a string command.\n+            // use direct read since we already read the varlen size\n+            command_name.resize(size_or_shortid);\n+            vRecv.read(&command_name[0], size_or_shortid);\n+        } else if (!GetMessageTypeFromShortID(size_or_shortid, command_name)) {\n+            // unknown-short-id results in a valid but unknown message (will be skipped)\n+            command_name = \"unknown-\" + ToString(size_or_shortid);\n+        }\n+    } else {\n+        // Invalid mac tag\n+        LogPrint(BCLog::NET, \"Invalid v2 mac tag, peer=%d\\n\", m_node_id);\n+        disconnect = true;\n+        reject_message = true;\n+    }\n+\n+    // decompose a single CNetMessage from the TransportDeserializer\n+    CNetMessage msg(std::move(vRecv));\n+    msg.m_command = command_name;\n+\n+    msg.m_message_size = msg.m_recv.size();\n+    msg.m_raw_message_size = CHACHA20_POLY1305_AEAD_AAD_LEN + m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN; // raw wire size\n+    msg.m_time = time;\n+\n+    Reset();\n+    return msg;\n+}\n+\n+bool V2TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header)\n+{\n+    size_t serialized_command_size = 1; // short-IDs are 1 byte\n+    std::optional<uint8_t> cmd_short_id = GetShortIDFromMessageType(msg.m_type);\n+    if (!cmd_short_id) {\n+        // message command without an assigned short-ID\n+        assert(msg.m_type.size() <= NET_P2P_V2_CMD_MAX_CHARS_SIZE);\n+        // encode as varstr, max 12 chars\n+        serialized_command_size = ::GetSerializeSize(msg.m_type, PROTOCOL_VERSION);\n+    }\n+    // prepare the packet length that will later be encrypted and part of the MAC (AAD)\n+    // the packet length excludes the 16 byte MAC tag\n+    uint32_t packet_length = serialized_command_size + msg.data.size();\n+\n+    // prepare the packet length & message command and reserve 4 bytes (3bytes AAD + 1byte short-ID)\n+    std::vector<unsigned char> serialized_header(CHACHA20_POLY1305_AEAD_AAD_LEN + 1);\n+    // LE serialize the 24bits length\n+    // we do \"manually\" encode this since there is no helper for 24bit serialization\n+    packet_length = htole32(packet_length);\n+    memcpy(serialized_header.data(), &packet_length, 3);\n+\n+    // append the short-ID or (eventually) the varstr of the command\n+    CVectorWriter vector_writer(SER_NETWORK, INIT_PROTO_VERSION, serialized_header, 3);\n+    if (cmd_short_id) {\n+        // append the single byte short ID...\n+        vector_writer << cmd_short_id.value();\n+    } else {\n+        // or the ASCII command string\n+        vector_writer << msg.m_type;\n+    }\n+\n+    // insert header directly into the CSerializedNetMsg data buffer (insert at begin)\n+    // TODO: if we refactor the ChaCha20Poly1305 crypt function to allow separate buffers for\n+    //       the AAD, payload and MAC, we could avoid a insert and thus a potential reallocation\n+    msg.data.insert(msg.data.begin(), serialized_header.begin(), serialized_header.end());\n+\n+    // resize the message buffer to make space for the MAC tag\n+    msg.data.resize(msg.data.size() + CHACHA20_POLY1305_AEAD_TAG_LEN, 0);\n+\n+    // encrypt the payload, this should always succeed (controlled buffers, don't check the MAC during encrypting)\n+    auto success = m_aead->Crypt(msg.data.data(), msg.data.size(), msg.data.data(), msg.data.size() - CHACHA20_POLY1305_AEAD_TAG_LEN, true);\n+    if (!success) {\n+        LogPrint(BCLog::NET, \"error in v2 p2p AEAD encryption for message type: %s\\n\", msg.m_type);\n+    }\n+    return success;\n+}\n+\n+bool V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header)\n+{\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n@@ -767,6 +935,7 @@ void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vec\n     // serialize header\n     header.reserve(CMessageHeader::HEADER_SIZE);\n     CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    return true;\n }\n \n size_t CConnman::SocketSendData(CNode& node) const\n@@ -3015,7 +3184,10 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n \n     // make sure we use the appropriate network transport format\n     std::vector<unsigned char> serializedHeader;\n-    pnode->m_serializer->prepareForTransport(msg, serializedHeader);\n+    if (!pnode->m_serializer->prepareForTransport(msg, serializedHeader)) {\n+        return;\n+    }\n+\n     size_t nTotalSize = nMessageSize + serializedHeader.size();\n \n     size_t nBytesSent = 0;"
      },
      {
        "sha": "5576861bae7283406f2747de089816b798e4bc30",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 74,
        "deletions": 4,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/756179741e329b9f14081ccc44e6e03608d5821a/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/756179741e329b9f14081ccc44e6e03608d5821a/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=756179741e329b9f14081ccc44e6e03608d5821a",
        "patch": "@@ -11,9 +11,11 @@\n #include <common/bloom.h>\n #include <compat.h>\n #include <consensus/amount.h>\n+#include <crypto/chacha_poly_aead.h>\n #include <crypto/siphash.h>\n #include <hash.h>\n #include <i2p.h>\n+#include <key.h>\n #include <net_permissions.h>\n #include <netaddress.h>\n #include <netbase.h>\n@@ -308,7 +310,7 @@ class TransportDeserializer {\n     /** read and deserialize data, advances msg_bytes data pointer */\n     virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message, bool& disconnect) = 0;\n     virtual ~TransportDeserializer() {}\n };\n \n@@ -372,21 +374,89 @@ class V1TransportDeserializer final : public TransportDeserializer\n         }\n         return ret;\n     }\n-    CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) override;\n+    CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message, bool& disconnect) override;\n+};\n+\n+/** V2TransportDeserializer is a transport deserializer after BIP324 */\n+class V2TransportDeserializer final : public TransportDeserializer\n+{\n+private:\n+    std::unique_ptr<ChaCha20Poly1305AEAD> m_aead;\n+    const NodeId m_node_id;      // Only for logging\n+    bool m_in_data = false;      // parsing header (false) or data (true)\n+    uint32_t m_message_size = 0; // expected message size\n+    CDataStream vRecv;           // received message data (encrypted length, payload ciphertext, MAC tag)\n+    unsigned int m_hdr_pos = 0;  // read pos in header\n+    unsigned int m_data_pos = 0; // read pos in data\n+\n+public:\n+    V2TransportDeserializer(const NodeId node_id, const CPrivKey& k1, const CPrivKey& k2) : m_aead(new ChaCha20Poly1305AEAD(k1.data(), k1.size(), k2.data(), k2.size())), m_node_id(node_id), vRecv(SER_NETWORK, INIT_PROTO_VERSION)\n+    {\n+        Reset();\n+    }\n+\n+    void Reset()\n+    {\n+        vRecv.clear();\n+        vRecv.resize(CHACHA20_POLY1305_AEAD_AAD_LEN);\n+        m_in_data = false;\n+        m_hdr_pos = 0;\n+        m_message_size = 0;\n+        m_data_pos = 0;\n+    }\n+    bool Complete() const override\n+    {\n+        if (!m_in_data) {\n+            return false;\n+        }\n+        return (m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN == m_data_pos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = m_in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    CNetMessage GetMessage(const std::chrono::microseconds time, bool& reject_message, bool& disconnect) override;\n };\n \n /** The TransportSerializer prepares messages for the network transport\n  */\n class TransportSerializer {\n public:\n     // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual bool prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n     virtual ~TransportSerializer() {}\n };\n \n class V1TransportSerializer  : public TransportSerializer {\n public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+    bool prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n+\n+class V2TransportSerializer : public TransportSerializer\n+{\n+private:\n+    std::unique_ptr<ChaCha20Poly1305AEAD> m_aead;\n+    CPrivKey m_aead_k1; //keep the keys for a later rekeying\n+    CPrivKey m_aead_k2;\n+\n+public:\n+    V2TransportSerializer(const CPrivKey& k1, const CPrivKey& k2) : m_aead(new ChaCha20Poly1305AEAD(k1.data(), k1.size(), k2.data(), k2.size())), m_aead_k1(k1), m_aead_k2(k2)\n+    {\n+    }\n+    // prepare for next message\n+    bool prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n };\n \n /** Information about a peer */"
      },
      {
        "sha": "d5b0701412dc6d0403350c38b5ae8f89ed7341ac",
        "filename": "src/test/fuzz/p2p_transport_serialization.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/756179741e329b9f14081ccc44e6e03608d5821a/src/test/fuzz/p2p_transport_serialization.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/756179741e329b9f14081ccc44e6e03608d5821a/src/test/fuzz/p2p_transport_serialization.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/p2p_transport_serialization.cpp?ref=756179741e329b9f14081ccc44e6e03608d5821a",
        "patch": "@@ -69,7 +69,8 @@ FUZZ_TARGET_INIT(p2p_transport_serialization, initialize_p2p_transport_serializa\n         if (deserializer.Complete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            bool disconnect{false};\n+            CNetMessage msg = deserializer.GetMessage(m_time, reject_message, disconnect);\n             assert(msg.m_command.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);"
      }
    ]
  },
  {
    "sha": "7ae260f519b862e5eabe2768066c5bd1390208e1",
    "node_id": "C_kwDOABII59oAKDdhZTI2MGY1MTliODYyZTVlYWJlMjc2ODA2NmM1YmQxMzkwMjA4ZTE",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2020-03-02T12:53:06Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-23T20:10:35Z"
      },
      "message": "Add p2p network v2 serializer/deserializer unit tests\n\nCo-authored-by: Jonas Schnelli <dev@jonasschnelli.ch>",
      "tree": {
        "sha": "826a607ba2ff575e5b876c4c3293f0ff735333a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/826a607ba2ff575e5b876c4c3293f0ff735333a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7ae260f519b862e5eabe2768066c5bd1390208e1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ae260f519b862e5eabe2768066c5bd1390208e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7ae260f519b862e5eabe2768066c5bd1390208e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ae260f519b862e5eabe2768066c5bd1390208e1/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "756179741e329b9f14081ccc44e6e03608d5821a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/756179741e329b9f14081ccc44e6e03608d5821a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/756179741e329b9f14081ccc44e6e03608d5821a"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 82,
      "deletions": 0
    },
    "files": [
      {
        "sha": "79fdf2a9991134cec0c63006891d2e2295585306",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ae260f519b862e5eabe2768066c5bd1390208e1/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ae260f519b862e5eabe2768066c5bd1390208e1/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=7ae260f519b862e5eabe2768066c5bd1390208e1",
        "patch": "@@ -8,6 +8,7 @@\n #include <net.h>\n #include <netaddress.h>\n #include <netbase.h>\n+#include <netmessagemaker.h>\n #include <serialize.h>\n #include <span.h>\n #include <streams.h>\n@@ -704,4 +705,85 @@ BOOST_AUTO_TEST_CASE(LocalAddress_BasicLifecycle)\n     BOOST_CHECK(!IsLocal(addr));\n }\n \n+void message_serialize_deserialize_test(bool v2, const std::vector<CSerializedNetMsg>& test_msgs)\n+{\n+    // use 32 byte keys with all zeros\n+    CPrivKey k1(32, 0);\n+    CPrivKey k2(32, 0);\n+\n+    // construct the serializers\n+    std::unique_ptr<TransportSerializer> serializer;\n+    std::unique_ptr<TransportDeserializer> deserializer;\n+\n+    if (v2) {\n+        serializer = std::make_unique<V2TransportSerializer>(V2TransportSerializer(k1, k2));\n+        deserializer = std::make_unique<V2TransportDeserializer>(V2TransportDeserializer((NodeId)0, k1, k2));\n+    } else {\n+        serializer = std::make_unique<V1TransportSerializer>(V1TransportSerializer());\n+        deserializer = std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), (NodeId)0, SER_NETWORK, INIT_PROTO_VERSION));\n+    }\n+    // run a couple of times through all messages with the same AEAD instance\n+    for (unsigned int i = 0; i < 100; i++) {\n+        for (const CSerializedNetMsg& msg_orig : test_msgs) {\n+            // bypass the copy protection\n+            CSerializedNetMsg msg;\n+            msg.data = msg_orig.data;\n+            msg.m_type = msg_orig.m_type;\n+            size_t raw_msg_size{msg.data.size()};\n+\n+            std::vector<unsigned char> serialized_header;\n+            serializer->prepareForTransport(msg, serialized_header);\n+\n+            // read two times\n+            //  first: read header\n+            size_t read_bytes{0};\n+            Span<const uint8_t> span_header(serialized_header.data(), serialized_header.size());\n+            if (serialized_header.size() > 0) read_bytes += deserializer->Read(span_header);\n+            //  second: read the encrypted payload (if required)\n+            Span<const uint8_t> span_msg(msg.data.data(), msg.data.size());\n+            if (msg.data.size() > 0) read_bytes += deserializer->Read(span_msg);\n+            if (msg.data.size() > read_bytes) {\n+                Span<const uint8_t> span_msg(msg.data.data() + read_bytes, msg.data.size() - read_bytes);\n+                read_bytes += deserializer->Read(span_msg);\n+            }\n+            BOOST_CHECK(deserializer->Complete());\n+            BOOST_CHECK_EQUAL(read_bytes, msg.data.size() + serialized_header.size());\n+            // message must be complete\n+            bool reject_message{true};\n+            bool disconnect{true};\n+            CNetMessage result{deserializer->GetMessage(GetTime<std::chrono::microseconds>(), reject_message, disconnect)};\n+            BOOST_CHECK(!reject_message);\n+            BOOST_CHECK(!disconnect);\n+            BOOST_CHECK_EQUAL(result.m_command, msg.m_type);\n+            BOOST_CHECK_EQUAL(raw_msg_size, result.m_message_size);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(net_v2)\n+{\n+    // create some messages where we perform serialization and deserialization\n+    std::vector<CSerializedNetMsg> test_msgs;\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (int)NODE_NETWORK, 123, CAddress(CService(), NODE_NONE), CAddress(CService(), NODE_NONE), 123, \"foobar\", 500000, true));\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::PING, 123456));\n+    CDataStream stream(ParseHex(\"020000000001013107ca31e1950a9b44b75ce3e8f30127e4d823ed8add1263a1cc8adcc8e49164000000001716001487835ecf51ea0351ef266d216a7e7a3e74b84b4efeffffff02082268590000000017a9144a94391b99e672b03f56d3f60800ef28bc304c4f8700ca9a3b0000000017a9146d5df9e79f752e3c53fc468db89cafda4f7d00cb87024730440220677de5b11a5617d541ba06a1fa5921ab6b4509f8028b23f18ab8c01c5eb1fcfb02202fe382e6e87653f60ff157aeb3a18fc888736720f27ced546b0b77431edabdb0012102608c772598e9645933a86bcd662a3b939e02fb3e77966c9713db5648d5ba8a0006010000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::TX, CTransaction(deserialize, stream)));\n+    std::vector<CInv> vInv;\n+    for (unsigned int i = 0; i < 1000; i++) {\n+        vInv.push_back(CInv(MSG_BLOCK, Params().GenesisBlock().GetHash()));\n+    }\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::INV, vInv));\n+\n+    // add a dummy message\n+    std::string dummy;\n+    for (unsigned int i = 0; i < 100; i++) {\n+        dummy += \"020000000001013107ca31e1950a9b44b75ce3e8f30127e4d823ed8add1263a1cc8adcc8e49164000000001716001487835ecf51ea0351ef266d216a7e7a3e74b84b4efeffffff02082268590000000017a9144a94391b99e672b03f56d3f60800ef28bc304c4f8700ca9a3b0000000017a9146d5df9e79f752e3c53fc468db89cafda4f7d00cb87024730440220677de5b11a5617d541ba06a1fa5921ab6b4509f8028b23f18ab8c01c5eb1fcfb02202fe382e6e87653f60ff157aeb3a18fc888736720f27ced546b0b77431edabdb0012102608c772598e9645933a86bcd662a3b939e02fb3e77966c9713db5648d5ba8a0006010000\";\n+    }\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(\"foobar\", dummy));\n+\n+    message_serialize_deserialize_test(true, test_msgs);\n+    message_serialize_deserialize_test(false, test_msgs);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "7255324a010805f6e4c9145484ddd92a30a761f6",
    "node_id": "C_kwDOABII59oAKDcyNTUzMjRhMDEwODA1ZjZlNGM5MTQ1NDg0ZGRkOTJhMzBhNzYxZjY",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-10-01T18:29:39Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-23T20:14:56Z"
      },
      "message": "fuzz: Add fuzz test for v2 transport {de}serialization",
      "tree": {
        "sha": "5d94617ab9a2cf66fb6015e868c78dca9312d3f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5d94617ab9a2cf66fb6015e868c78dca9312d3f6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7255324a010805f6e4c9145484ddd92a30a761f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7255324a010805f6e4c9145484ddd92a30a761f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7255324a010805f6e4c9145484ddd92a30a761f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7255324a010805f6e4c9145484ddd92a30a761f6/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7ae260f519b862e5eabe2768066c5bd1390208e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ae260f519b862e5eabe2768066c5bd1390208e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7ae260f519b862e5eabe2768066c5bd1390208e1"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 45,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b8589f38aa058957eb5b429eb0a4e9fab1ec85f0",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7255324a010805f6e4c9145484ddd92a30a761f6/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7255324a010805f6e4c9145484ddd92a30a761f6/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=7255324a010805f6e4c9145484ddd92a30a761f6",
        "patch": "@@ -261,6 +261,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/netbase_dns_lookup.cpp \\\n  test/fuzz/node_eviction.cpp \\\n  test/fuzz/p2p_transport_serialization.cpp \\\n+ test/fuzz/p2p_v2_transport_serialization.cpp \\\n  test/fuzz/parse_hd_keypath.cpp \\\n  test/fuzz/parse_iso8601.cpp \\\n  test/fuzz/parse_numbers.cpp \\"
      },
      {
        "sha": "23500bfbe668a133bc1c8b158f90dd3f6b1c4a5a",
        "filename": "src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7255324a010805f6e4c9145484ddd92a30a761f6/src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7255324a010805f6e4c9145484ddd92a30a761f6/src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/p2p_v2_transport_serialization.cpp?ref=7255324a010805f6e4c9145484ddd92a30a761f6",
        "patch": "@@ -0,0 +1,44 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha_poly_aead.h>\n+#include <key.h>\n+#include <net.h>\n+#include <netmessagemaker.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <cassert>\n+\n+FUZZ_TARGET(p2p_v2_transport_serialization)\n+{\n+    const CPrivKey k1(32, 0);\n+    const CPrivKey k2(32, 0);\n+\n+    // Construct deserializer, with a dummy NodeId\n+    V2TransportDeserializer deserializer{(NodeId)0, k1, k2};\n+    V2TransportSerializer serializer{k1, k2};\n+\n+    while (buffer.size() > 0) {\n+        const int handled = deserializer.Read(buffer);\n+        if (handled < 0) {\n+            break;\n+        }\n+        if (deserializer.Complete()) {\n+            const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n+            bool reject_message{true};\n+            bool disconnect{true};\n+            CNetMessage result{deserializer.GetMessage(m_time, reject_message, disconnect)};\n+            if (!reject_message) {\n+                assert(result.m_command.size() <= CMessageHeader::COMMAND_SIZE);\n+                assert(result.m_raw_message_size <= buffer.size());\n+                assert(result.m_raw_message_size == CHACHA20_POLY1305_AEAD_AAD_LEN + result.m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN);\n+                assert(result.m_time == m_time);\n+\n+                std::vector<unsigned char> header;\n+                auto msg = CNetMsgMaker{result.m_recv.GetVersion()}.Make(result.m_command, MakeUCharSpan(result.m_recv));\n+                serializer.prepareForTransport(msg, header);\n+            }\n+        }\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
    "node_id": "C_kwDOABII59oAKGMwYzFlZTk1OGEyZTgxZDA1YWMxMDZjMzRmZDRkODQ4MGQ3M2FiZGY",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-10-01T19:05:55Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-23T20:14:59Z"
      },
      "message": "fuzz: Provide correct length to assist fuzzer for v2 transport\n\nbefore commit:\n121493 REDUCE cov: 1744 ft: 2328 corp: 30/9789b lim: 976 exec/s: 979 rss: 443Mb L: 733/779\n\nafter commit:\n121218 REDUCE cov: 1889 ft: 2574 corp: 36/2305b lim: 877 exec/s: 939 rss: 442Mb L: 345/345",
      "tree": {
        "sha": "966cc98eb2628fbcfe4e6a21ca327e02a8eaa764",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/966cc98eb2628fbcfe4e6a21ca327e02a8eaa764"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7255324a010805f6e4c9145484ddd92a30a761f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7255324a010805f6e4c9145484ddd92a30a761f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7255324a010805f6e4c9145484ddd92a30a761f6"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 15,
      "deletions": 2
    },
    "files": [
      {
        "sha": "a4ac424d3cc41049bfbb7183995dea31ea8b705b",
        "filename": "src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf/src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf/src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/p2p_v2_transport_serialization.cpp?ref=c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
        "patch": "@@ -2,10 +2,12 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <compat/endian.h>\n #include <crypto/chacha_poly_aead.h>\n #include <key.h>\n #include <net.h>\n #include <netmessagemaker.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n \n #include <cassert>\n@@ -18,9 +20,20 @@ FUZZ_TARGET(p2p_v2_transport_serialization)\n     // Construct deserializer, with a dummy NodeId\n     V2TransportDeserializer deserializer{(NodeId)0, k1, k2};\n     V2TransportSerializer serializer{k1, k2};\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n \n-    while (buffer.size() > 0) {\n-        const int handled = deserializer.Read(buffer);\n+    bool length_assist = fuzzed_data_provider.ConsumeBool();\n+    auto payload_bytes = fuzzed_data_provider.ConsumeRemainingBytes<uint8_t>();\n+\n+    if (length_assist && payload_bytes.size() >= CHACHA20_POLY1305_AEAD_AAD_LEN + CHACHA20_POLY1305_AEAD_TAG_LEN) {\n+        uint32_t packet_length = payload_bytes.size() - CHACHA20_POLY1305_AEAD_AAD_LEN - CHACHA20_POLY1305_AEAD_TAG_LEN;\n+        packet_length = htole32(packet_length);\n+        memcpy(payload_bytes.data(), &packet_length, 3);\n+    }\n+\n+    Span<const uint8_t> msg_bytes{payload_bytes};\n+    while (msg_bytes.size() > 0) {\n+        const int handled = deserializer.Read(msg_bytes);\n         if (handled < 0) {\n             break;\n         }"
      }
    ]
  },
  {
    "sha": "0305c31cb447cd37272303dac0b01c911c4124a6",
    "node_id": "C_kwDOABII59oAKDAzMDVjMzFjYjQ0N2NkMzcyNzIzMDNkYWMwYjAxYzkxMWM0MTI0YTY",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-10-07T21:52:44Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-23T20:19:27Z"
      },
      "message": "fuzz: Provide correct MAC tag to assist v2 transport fuzzing\n\nbefore commit:\n121218 REDUCE cov: 1889 ft: 2574 corp: 36/2305b lim: 877 exec/s: 939 rss: 442Mb L: 345/345\n\nafter commit:\n119632 REDUCE cov: 2692 ft: 3657 corp: 57/8816b lim: 1021 exec/s: 61 rss: 478Mb L: 1000/1013",
      "tree": {
        "sha": "a71264e01354c29309d68fd77edec7ab5ef1041f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a71264e01354c29309d68fd77edec7ab5ef1041f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0305c31cb447cd37272303dac0b01c911c4124a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0305c31cb447cd37272303dac0b01c911c4124a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0305c31cb447cd37272303dac0b01c911c4124a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0305c31cb447cd37272303dac0b01c911c4124a6/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c0c1ee958a2e81d05ac106c34fd4d8480d73abdf"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 28,
      "deletions": 6
    },
    "files": [
      {
        "sha": "b77fc44fd3c96fd8e5270eac9a5dc3b2a5c9301c",
        "filename": "src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 6,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0305c31cb447cd37272303dac0b01c911c4124a6/src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0305c31cb447cd37272303dac0b01c911c4124a6/src/test/fuzz/p2p_v2_transport_serialization.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/p2p_v2_transport_serialization.cpp?ref=0305c31cb447cd37272303dac0b01c911c4124a6",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <compat/endian.h>\n #include <crypto/chacha_poly_aead.h>\n+#include <crypto/poly1305.h>\n #include <key.h>\n #include <net.h>\n #include <netmessagemaker.h>\n@@ -14,21 +15,33 @@\n \n FUZZ_TARGET(p2p_v2_transport_serialization)\n {\n-    const CPrivKey k1(32, 0);\n-    const CPrivKey k2(32, 0);\n+    const CPrivKey k1(CHACHA20_POLY1305_AEAD_KEY_LEN, 0);\n+    const CPrivKey k2(CHACHA20_POLY1305_AEAD_KEY_LEN, 0);\n \n     // Construct deserializer, with a dummy NodeId\n     V2TransportDeserializer deserializer{(NodeId)0, k1, k2};\n     V2TransportSerializer serializer{k1, k2};\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n \n     bool length_assist = fuzzed_data_provider.ConsumeBool();\n+    bool mac_assist = fuzzed_data_provider.ConsumeBool();\n     auto payload_bytes = fuzzed_data_provider.ConsumeRemainingBytes<uint8_t>();\n \n-    if (length_assist && payload_bytes.size() >= CHACHA20_POLY1305_AEAD_AAD_LEN + CHACHA20_POLY1305_AEAD_TAG_LEN) {\n-        uint32_t packet_length = payload_bytes.size() - CHACHA20_POLY1305_AEAD_AAD_LEN - CHACHA20_POLY1305_AEAD_TAG_LEN;\n-        packet_length = htole32(packet_length);\n-        memcpy(payload_bytes.data(), &packet_length, 3);\n+    if (payload_bytes.size() >= CHACHA20_POLY1305_AEAD_AAD_LEN + CHACHA20_POLY1305_AEAD_TAG_LEN) {\n+        if (length_assist) {\n+            uint32_t packet_length = payload_bytes.size() - CHACHA20_POLY1305_AEAD_AAD_LEN - CHACHA20_POLY1305_AEAD_TAG_LEN;\n+            packet_length = htole32(packet_length);\n+            memcpy(payload_bytes.data(), &packet_length, 3);\n+        }\n+\n+        if (mac_assist) {\n+            unsigned char pseudorandom_bytes[CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_KEYLEN];\n+            memset(pseudorandom_bytes, 0, sizeof(pseudorandom_bytes));\n+            ChaCha20Forward4064 chacha{k1.data(), CHACHA20_POLY1305_AEAD_KEY_LEN};\n+            chacha.Crypt(pseudorandom_bytes, pseudorandom_bytes, CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_KEYLEN);\n+\n+            poly1305_auth(payload_bytes.data() + (payload_bytes.size() - POLY1305_TAGLEN), payload_bytes.data(), (payload_bytes.size() - POLY1305_TAGLEN), pseudorandom_bytes + CHACHA20_POLY1305_AEAD_AAD_LEN);\n+        }\n     }\n \n     Span<const uint8_t> msg_bytes{payload_bytes};\n@@ -42,6 +55,15 @@ FUZZ_TARGET(p2p_v2_transport_serialization)\n             bool reject_message{true};\n             bool disconnect{true};\n             CNetMessage result{deserializer.GetMessage(m_time, reject_message, disconnect)};\n+\n+            if (mac_assist) {\n+                assert(!disconnect);\n+            }\n+\n+            if (length_assist && mac_assist) {\n+                assert(!reject_message);\n+            }\n+\n             if (!reject_message) {\n                 assert(result.m_command.size() <= CMessageHeader::COMMAND_SIZE);\n                 assert(result.m_raw_message_size <= buffer.size());"
      }
    ]
  }
]