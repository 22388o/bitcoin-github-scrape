[
  {
    "sha": "e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMjg2Y2QwZDdiNGUxMmM4ZWZlNWU3YWMzMDY2YTEwMGUwYmEyYzBh",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-04-08T14:37:54Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-04-13T15:26:20Z"
      },
      "message": "net: flag relevant Sock methods with [[nodiscard]]",
      "tree": {
        "sha": "4569f2cdb11d296506a15533e1bebc10fd143b77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4569f2cdb11d296506a15533e1bebc10fd143b77"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmB1uB0ACgkQVN8G9ktV\ny7+Csx//dM9skj1NTKue0FbRWRzyWGjV/7XE4RR2rV/+AO+yWqMyx9K5PfGISutg\nJAIGaLlWJdEqh/gjO2O4CsLdXPQmktUTbhyTiGolDzRyZlrcDFtoi0y00JlMjKYb\n5DkpkNTEckMB1G/3t2nBilWL8WTgIQvqwJzOHlT40qom/INHysPGW+0J5AH38U4d\nNBtXrERro1K4Ykfq7y/Ms/IEMmC63QXBzS+Qax18h7rhav3meBfatWrXWclB8N8L\nlhUw1hVB/tGBXn7ZbKJ4qg+/GlRgUnfDVWHXkgZpQOEeyzxumd3f4P5yJFBxFynW\nqvuSuK1yTVaXGgViiZghMZwkv9VPeQsujMF4wfXvyJ8hz7jJ+i6t63youN3JRIKB\nj5XdCDe+ZKimQN6P87QBXi2lRjM9+n7+BY5RpDI+ZkaByMs8M3MB6esDXOOjYV3F\ne0SUZZOjG1Cy/b4JO7HzXX5JsCgy8omkWSLTgWh+/IJ3ehQqFdnr7nbsYL9xmv5A\nrsQ8BUx0nDtRK0rc6p66ngN/tzreRcohh+wFONEy8zSevGgihVtUcmKGY7YIIizO\nwWENIasYCI254oUdZOd7HDTjpPW4U/IkvtNFdT73OYEhM7mnYAbimaJ4j6dCeH31\nzYMzKs50Aq0l3Hoz6OQTCGMdIXvlYKbruIv/BwvlLH+JvhcPaQCe6gSxLty/n4n2\nMY0WbDCKGM3tleGCWUj8bZbJs7ZezXJhL71bbDkWJQ5f2raY7T0dg65diVOtJraW\npvhCJvPUwRpJoRlXpH2foQfpO79jKD2JTRpjxyBGvSUMJlcfXANI27Th5FFbFn0E\nKT7mI1PY1LfODkPQu6e8df0hR3IlkA5QLlCUKO+iakSqCQon8Q0OwuNoDHpdUqH4\nEYt+SuqG569CWITyZeXCCPUjaspourvEnVFMDnC0G6cGhq49ucvcIk+upPTeSupr\nRFb3z5667wF/gXBujBf6nUw9+/Zf6yO3tMHGqLgdgCcnsEzwZf5NQDFoXizIX2uy\nfHvrukXWzvBD5alp9UXG9uU9utFDj0zhh/l3TtG+Y/UeT0wcqQZIoWBy5t8yuBMg\nYo8iFL37VAma5w/jV1OMm/oxDhjikch70RA8FtHDaX+G+b4tKxCEz5eYRQ7oljGR\n8q8nyO1sLW/wIzVttIbZ7Lx5TGrnIwyGqGvGFRwX/v9mHYHpOb9pyqqRFnetMXOl\nBbxzQ5p1lCIFexNM95Nf4umcSlwoReBFGgJazIYKMR4OwVECdEtu71H0dGn1vIKo\n3YQj5DT5mSjFh/yyrc5KZ/wZOvHNQQVngEEbnzJ2umxW4p7MWHUwhWi7PB1lBL26\nZKfexKbaKoYrbiiVtd21xhGM8hHXwg==\n=CtIE\n-----END PGP SIGNATURE-----",
        "payload": "tree 4569f2cdb11d296506a15533e1bebc10fd143b77\nparent a1f0b8b62eb851c837a3618583b7c2fd4d12006c\nauthor Vasil Dimov <vd@FreeBSD.org> 1617892674 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1618327580 +0200\n\nnet: flag relevant Sock methods with [[nodiscard]]\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1f0b8b62eb851c837a3618583b7c2fd4d12006c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1f0b8b62eb851c837a3618583b7c2fd4d12006c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1f0b8b62eb851c837a3618583b7c2fd4d12006c"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 21,
      "deletions": 18
    },
    "files": [
      {
        "sha": "e0d62fb49393b236fddb70175390009eae490782",
        "filename": "src/test/fuzz/i2p.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/test/fuzz/i2p.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/test/fuzz/i2p.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/i2p.cpp?ref=e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
        "patch": "@@ -37,7 +37,7 @@ FUZZ_TARGET_INIT(i2p, initialize_i2p)\n     if (sess.Listen(conn)) {\n         if (sess.Accept(conn)) {\n             try {\n-                conn.sock->RecvUntilTerminator('\\n', 10ms, interrupt, i2p::sam::MAX_MSG_SIZE);\n+                (void)conn.sock->RecvUntilTerminator('\\n', 10ms, interrupt, i2p::sam::MAX_MSG_SIZE);\n             } catch (const std::runtime_error&) {\n             }\n         }"
      },
      {
        "sha": "9e98f4f0b1783d8281e1fbcf6506b7f10b47af46",
        "filename": "src/test/sock_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/test/sock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/test/sock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sock_tests.cpp?ref=e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
        "patch": "@@ -139,7 +139,7 @@ BOOST_AUTO_TEST_CASE(wait)\n     Sock sock0(s[0]);\n     Sock sock1(s[1]);\n \n-    std::thread waiter([&sock0]() { sock0.Wait(24h, Sock::RECV); });\n+    std::thread waiter([&sock0]() { (void)sock0.Wait(24h, Sock::RECV); });\n \n     BOOST_REQUIRE_EQUAL(sock1.Send(\"a\", 1, 0), 1);\n \n@@ -162,7 +162,7 @@ BOOST_AUTO_TEST_CASE(recv_until_terminator_limit)\n         // BOOST_CHECK_EXCEPTION() writes to some variables shared with the main thread which\n         // creates a data race. So mimic it manually.\n         try {\n-            sock_recv.RecvUntilTerminator('\\n', timeout, interrupt, max_data);\n+            (void)sock_recv.RecvUntilTerminator('\\n', timeout, interrupt, max_data);\n         } catch (const std::runtime_error& e) {\n             threw_as_expected = HasReason(\"too many bytes without a terminator\")(e);\n         }"
      },
      {
        "sha": "b6c2a47434cd4039fbeafdb2fd3bcf28ba64b836",
        "filename": "src/util/sock.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
        "patch": "@@ -179,7 +179,7 @@ void Sock::SendComplete(const std::string& data,\n         // Wait for a short while (or the socket to become ready for sending) before retrying\n         // if nothing was sent.\n         const auto wait_time = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});\n-        Wait(wait_time, SEND);\n+        (void)Wait(wait_time, SEND);\n     }\n }\n \n@@ -262,7 +262,7 @@ std::string Sock::RecvUntilTerminator(uint8_t terminator,\n \n         // Wait for a short while (or the socket to become ready for reading) before retrying.\n         const auto wait_time = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});\n-        Wait(wait_time, RECV);\n+        (void)Wait(wait_time, RECV);\n     }\n }\n "
      },
      {
        "sha": "59cc8c0b1df6e782905886965a1a3df88f18b2ba",
        "filename": "src/util/sock.h",
        "status": "modified",
        "additions": 16,
        "deletions": 13,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=e286cd0d7b4e12c8efe5e7ac3066a100e0ba2c0a",
        "patch": "@@ -64,7 +64,7 @@ class Sock\n      * Get the value of the contained socket.\n      * @return socket or INVALID_SOCKET if empty\n      */\n-    virtual SOCKET Get() const;\n+    [[nodiscard]] virtual SOCKET Get() const;\n \n     /**\n      * Get the value of the contained socket and drop ownership. It will not be closed by the\n@@ -82,26 +82,29 @@ class Sock\n      * send(2) wrapper. Equivalent to `send(this->Get(), data, len, flags);`. Code that uses this\n      * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n      */\n-    virtual ssize_t Send(const void* data, size_t len, int flags) const;\n+    [[nodiscard]] virtual ssize_t Send(const void* data, size_t len, int flags) const;\n \n     /**\n      * recv(2) wrapper. Equivalent to `recv(this->Get(), buf, len, flags);`. Code that uses this\n      * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n      */\n-    virtual ssize_t Recv(void* buf, size_t len, int flags) const;\n+    [[nodiscard]] virtual ssize_t Recv(void* buf, size_t len, int flags) const;\n \n     /**\n      * connect(2) wrapper. Equivalent to `connect(this->Get(), addr, addrlen)`. Code that uses this\n      * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n      */\n-    virtual int Connect(const sockaddr* addr, socklen_t addr_len) const;\n+    [[nodiscard]] virtual int Connect(const sockaddr* addr, socklen_t addr_len) const;\n \n     /**\n      * getsockopt(2) wrapper. Equivalent to\n      * `getsockopt(this->Get(), level, opt_name, opt_val, opt_len)`. Code that uses this\n      * wrapper can be unit tested if this method is overridden by a mock Sock implementation.\n      */\n-    virtual int GetSockOpt(int level, int opt_name, void* opt_val, socklen_t* opt_len) const;\n+    [[nodiscard]] virtual int GetSockOpt(int level,\n+                                         int opt_name,\n+                                         void* opt_val,\n+                                         socklen_t* opt_len) const;\n \n     using Event = uint8_t;\n \n@@ -124,9 +127,9 @@ class Sock\n      * value of `true` and `occurred` being set to 0.\n      * @return true on success and false otherwise\n      */\n-    virtual bool Wait(std::chrono::milliseconds timeout,\n-                      Event requested,\n-                      Event* occurred = nullptr) const;\n+    [[nodiscard]] virtual bool Wait(std::chrono::milliseconds timeout,\n+                                    Event requested,\n+                                    Event* occurred = nullptr) const;\n \n     /* Higher level, convenience, methods. These may throw. */\n \n@@ -154,17 +157,17 @@ class Sock\n      * @throws std::runtime_error if the operation cannot be completed. In this case some bytes may\n      * have been consumed from the socket.\n      */\n-    virtual std::string RecvUntilTerminator(uint8_t terminator,\n-                                            std::chrono::milliseconds timeout,\n-                                            CThreadInterrupt& interrupt,\n-                                            size_t max_data) const;\n+    [[nodiscard]] virtual std::string RecvUntilTerminator(uint8_t terminator,\n+                                                          std::chrono::milliseconds timeout,\n+                                                          CThreadInterrupt& interrupt,\n+                                                          size_t max_data) const;\n \n     /**\n      * Check if still connected.\n      * @param[out] errmsg The error string, if the socket has been disconnected.\n      * @return true if connected\n      */\n-    virtual bool IsConnected(std::string& errmsg) const;\n+    [[nodiscard]] virtual bool IsConnected(std::string& errmsg) const;\n \n protected:\n     /**"
      }
    ]
  }
]