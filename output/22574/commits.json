[
  {
    "sha": "445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NDViM2NiNWQ3ZGYyNWI4NzdlMDZiNDc4OGFkMGFjMmNmMmEwNzA5",
    "commit": {
      "author": {
        "name": "Shorya",
        "email": "shoryak@iitk.ac.in",
        "date": "2021-07-28T01:39:26Z"
      },
      "committer": {
        "name": "Shorya",
        "email": "shoryak@iitk.ac.in",
        "date": "2021-07-28T10:36:30Z"
      },
      "message": "conflicts resolved",
      "tree": {
        "sha": "ed2e3c92d4ff220608be52a27018ee935fe54872",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed2e3c92d4ff220608be52a27018ee935fe54872"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/comments",
    "author": {
      "login": "shoryak",
      "id": 60062252,
      "node_id": "MDQ6VXNlcjYwMDYyMjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60062252?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoryak",
      "html_url": "https://github.com/shoryak",
      "followers_url": "https://api.github.com/users/shoryak/followers",
      "following_url": "https://api.github.com/users/shoryak/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoryak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoryak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoryak/subscriptions",
      "organizations_url": "https://api.github.com/users/shoryak/orgs",
      "repos_url": "https://api.github.com/users/shoryak/repos",
      "events_url": "https://api.github.com/users/shoryak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoryak/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "shoryak",
      "id": 60062252,
      "node_id": "MDQ6VXNlcjYwMDYyMjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60062252?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoryak",
      "html_url": "https://github.com/shoryak",
      "followers_url": "https://api.github.com/users/shoryak/followers",
      "following_url": "https://api.github.com/users/shoryak/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoryak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoryak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoryak/subscriptions",
      "organizations_url": "https://api.github.com/users/shoryak/orgs",
      "repos_url": "https://api.github.com/users/shoryak/repos",
      "events_url": "https://api.github.com/users/shoryak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoryak/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be175cef24a0b4613d79d05156358841bf2bad98",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be175cef24a0b4613d79d05156358841bf2bad98",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be175cef24a0b4613d79d05156358841bf2bad98"
      }
    ],
    "stats": {
      "total": 361,
      "additions": 300,
      "deletions": 61
    },
    "files": [
      {
        "sha": "4fbb49cb0da7146534e3b4d5898fd5a0f3b351a6",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -28,12 +28,21 @@ struct TestBlockAndIndex {\n \n         stream >> block;\n \n-        blockHash = block.GetHash();\n+//<<<<<<< HEAD\n+       /*  blockHash = block.GetHash();\n         blockindex.phashBlock = &blockHash;\n+        blockindex.nBits = 403014710; */\n+         CBlockIndex blockindex;\n+        blockindex.m_hash_block = block.GetHash();\n         blockindex.nBits = 403014710;\n     }\n };\n-\n+/* =======\n+    CBlockIndex blockindex;\n+    blockindex.m_hash_block = block.GetHash();\n+    blockindex.nBits = 403014710;\n+>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n+ */\n } // namespace\n \n static void BlockToJsonVerbose(benchmark::Bench& bench)"
      },
      {
        "sha": "741065b9e211d4d1bc4c8d38cc83f5fd1c5849c1",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -137,8 +137,8 @@ enum BlockStatus: uint32_t {\n class CBlockIndex\n {\n public:\n-    //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex\n-    const uint256* phashBlock{nullptr};\n+    //! hash of the block. m_hash_block.IsNull() if there is not yet a hash\n+    uint256 m_hash_block;\n \n     //! pointer to the index of the predecessor of this block\n     CBlockIndex* pprev{nullptr};\n@@ -243,9 +243,9 @@ class CBlockIndex\n         return block;\n     }\n \n-    uint256 GetBlockHash() const\n+    const uint256& GetBlockHash() const\n     {\n-        return *phashBlock;\n+        return m_hash_block;\n     }\n \n     /**"
      },
      {
        "sha": "c95f2abf27b8f869e29a9980a52d6df1cbb588cc",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -1578,10 +1578,17 @@ static RPCHelpMan getchaintips()\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n+/* <<<<<<< HEAD\n     for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {\n         if (!active_chain.Contains(item.second)) {\n             setOrphans.insert(item.second);\n             setPrevs.insert(item.second->pprev);\n+======= */\n+    for (CBlockIndex* pindex : chainman.BlockIndex()) {\n+        if (!chainman.ActiveChain().Contains(pindex)) {\n+            setOrphans.insert(pindex);\n+            setPrevs.insert(pindex->pprev);\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         }\n     }\n \n@@ -1599,7 +1606,7 @@ static RPCHelpMan getchaintips()\n     for (const CBlockIndex* block : setTips) {\n         UniValue obj(UniValue::VOBJ);\n         obj.pushKV(\"height\", block->nHeight);\n-        obj.pushKV(\"hash\", block->phashBlock->GetHex());\n+        obj.pushKV(\"hash\", block->m_hash_block.GetHex());\n \n         const int branchLen = block->nHeight - active_chain.FindFork(block)->nHeight;\n         obj.pushKV(\"branchlen\", branchLen);"
      },
      {
        "sha": "9442ac9a8e683da6fa6759ff40ca7762ca0cdd11",
        "filename": "src/test/fuzz/chain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/test/fuzz/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/test/fuzz/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/chain.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -19,8 +19,6 @@ FUZZ_TARGET(chain)\n         return;\n     }\n \n-    const uint256 zero{};\n-    disk_block_index->phashBlock = &zero;\n     (void)disk_block_index->GetBlockHash();\n     (void)disk_block_index->GetBlockPos();\n     (void)disk_block_index->GetBlockTime();\n@@ -59,7 +57,6 @@ FUZZ_TARGET(chain)\n     }\n \n     CBlockIndex block_index{block_header};\n-    block_index.phashBlock = &zero;\n     (void)block_index.GetBlockHash();\n     (void)block_index.ToString();\n }"
      },
      {
        "sha": "a74b6239951c5715a9ad75742feda079521f5d6a",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -369,8 +369,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (m_node.chainman->ActiveChain().Tip()->nHeight < 209999) {\n         CBlockIndex* prev = m_node.chainman->ActiveChain().Tip();\n         CBlockIndex* next = new CBlockIndex();\n+/* <<<<<<< HEAD\n         next->phashBlock = new uint256(InsecureRand256());\n         m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n+======= */\n+        next->m_hash_block = uint256(InsecureRand256());\n+        m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n+        //::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -381,8 +387,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (m_node.chainman->ActiveChain().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = m_node.chainman->ActiveChain().Tip();\n         CBlockIndex* next = new CBlockIndex();\n+/* <<<<<<< HEAD\n         next->phashBlock = new uint256(InsecureRand256());\n         m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n+======= */\n+        next->m_hash_block = uint256(InsecureRand256());\n+        //::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n+        m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -409,11 +421,22 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n+/* <<<<<<< HEAD\n     while (m_node.chainman->ActiveChain().Tip()->nHeight > nHeight) {\n         CBlockIndex* del = m_node.chainman->ActiveChain().Tip();\n         m_node.chainman->ActiveChain().SetTip(del->pprev);\n         m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n         delete del->phashBlock;\n+=======\n+    while (::ChainActive().Tip()->nHeight > nHeight) {\n+        CBlockIndex* del = ::ChainActive().Tip();\n+        ::ChainActive().SetTip(del->pprev); */\n+        //::ChainstateActive().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n+    while (m_node.chainman->ActiveChain().Tip()->nHeight > nHeight) {\n+        CBlockIndex* del = m_node.chainman->ActiveChain().Tip();\n+        m_node.chainman->ActiveChain().SetTip(del->pprev);\n+        m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         delete del;\n     }\n "
      },
      {
        "sha": "ad86c288e2092b3ca849026bc55e033dc7f41874",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -51,7 +51,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vHashMain[i] = ArithToUint256(i); // Set the hash equal to the height, so we can quickly check the distances.\n         vBlocksMain[i].nHeight = i;\n         vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : nullptr;\n-        vBlocksMain[i].phashBlock = &vHashMain[i];\n+        vBlocksMain[i].m_hash_block = vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n         BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksMain[i].GetBlockHash()).GetLow64(), vBlocksMain[i].nHeight);\n         BOOST_CHECK(vBlocksMain[i].pprev == nullptr || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n@@ -64,7 +64,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vHashSide[i] = ArithToUint256(i + 50000 + (arith_uint256(1) << 128)); // Add 1<<128 to the hashes, so GetLow64() still returns the height.\n         vBlocksSide[i].nHeight = i + 50000;\n         vBlocksSide[i].pprev = i ? &vBlocksSide[i - 1] : (vBlocksMain.data()+49999);\n-        vBlocksSide[i].phashBlock = &vHashSide[i];\n+        vBlocksSide[i].m_hash_block = vHashSide[i];\n         vBlocksSide[i].BuildSkip();\n         BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksSide[i].GetBlockHash()).GetLow64(), vBlocksSide[i].nHeight);\n         BOOST_CHECK(vBlocksSide[i].pprev == nullptr || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n@@ -106,7 +106,7 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_test)\n         vHashMain[i] = ArithToUint256(i); // Set the hash equal to the height\n         vBlocksMain[i].nHeight = i;\n         vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : nullptr;\n-        vBlocksMain[i].phashBlock = &vHashMain[i];\n+        vBlocksMain[i].m_hash_block = vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n         if (i < 10) {\n             vBlocksMain[i].nTime = i;"
      },
      {
        "sha": "db0aae2a3ca64f29ed4ca891941a057ce31a38c9",
        "filename": "src/util/hasher.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/util/hasher.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/util/hasher.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/hasher.h?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -76,13 +76,13 @@ class SignatureCacheHasher\n     }\n };\n \n-struct BlockHasher\n+/* struct BlockHasher\n {\n     // this used to call `GetCheapHash()` in uint256, which was later moved; the\n     // cheap hash function simply calls ReadLE64() however, so the end result is\n     // identical\n     size_t operator()(const uint256& hash) const { return ReadLE64(hash.begin()); }\n-};\n+}; */\n \n class SaltedSipHasher\n {"
      },
      {
        "sha": "f49aae6b7ed45b050ae5dca012edf2cebd3955b0",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 211,
        "deletions": 41,
        "changes": 252,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -148,8 +148,15 @@ void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n {\n     AssertLockHeld(cs_main);\n+/* <<<<<<< HEAD\n     BlockMap::const_iterator it = m_block_index.find(hash);\n     return it == m_block_index.end() ? nullptr : it->second;\n+======= */\n+    //auto& idx = g_chainman.BlockIndex();\n+    //BlockMap::const_iterator it = idx.find(idx.hash_function()(hash));\n+    BlockMap::const_iterator it = m_block_index.find( m_block_index.hash_function()(hash));\n+    return it ==  m_block_index.end() ? nullptr : *it;\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n }\n \n CBlockIndex* BlockManager::FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -1295,6 +1302,40 @@ void CChainState::CheckForkWarningConditions()\n     // (we assume we don't get stuck on a fork before finishing our initial sync)\n     if (IsInitialBlockDownload()) {\n         return;\n+/* <<<<<<< HEAD\n+=======\n+\n+    // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n+    // of our head, drop it\n+    if (pindexBestForkTip && ::ChainActive().Height() - pindexBestForkTip->nHeight >= 72)\n+        pindexBestForkTip = nullptr;\n+\n+    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > ::ChainActive().Tip()->nChainWork + (GetBlockProof(*::ChainActive().Tip()) * 6)))\n+    {\n+        if (!GetfLargeWorkForkFound() && pindexBestForkBase)\n+        {\n+            std::string warning = std::string(\"'Warning: Large-work fork detected, forking after block \") +\n+                pindexBestForkBase->m_hash_block.ToString() + std::string(\"'\");\n+            AlertNotify(warning);\n+        }\n+        if (pindexBestForkTip && pindexBestForkBase)\n+        {\n+            LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,\n+                   pindexBestForkBase->nHeight, pindexBestForkBase->m_hash_block.ToString(),\n+                   pindexBestForkTip->nHeight, pindexBestForkTip->m_hash_block.ToString());\n+            SetfLargeWorkForkFound(true);\n+        }\n+        else\n+        {\n+            LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__);\n+            SetfLargeWorkInvalidChainFound(true);\n+        }\n+    }\n+    else\n+    {\n+        SetfLargeWorkForkFound(false);\n+        SetfLargeWorkInvalidChainFound(false);\n+>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map */\n     }\n \n     if (pindexBestInvalid && pindexBestInvalid->nChainWork > m_chain.Tip()->nChainWork + (GetBlockProof(*m_chain.Tip()) * 6)) {\n@@ -1648,8 +1689,8 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n     // mainnet and testnet), so for simplicity, always leave P2SH\n     // on except for the one violating block.\n     if (consensusparams.BIP16Exception.IsNull() || // no bip16 exception on this chain\n-        pindex->phashBlock == nullptr || // this is a new candidate block, eg from TestBlockValidity()\n-        *pindex->phashBlock != consensusparams.BIP16Exception) // this block isn't the historical exception\n+        pindex->m_hash_block.IsNull() || // this is a new candidate block, eg from TestBlockValidity()\n+        pindex->m_hash_block != consensusparams.BIP16Exception) // this block isn't the historical exception\n     {\n         // Enforce WITNESS rules whenever P2SH is in effect\n         flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\n@@ -1702,7 +1743,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n {\n     AssertLockHeld(cs_main);\n     assert(pindex);\n-    assert(*pindex->phashBlock == block.GetHash());\n+    assert(pindex->m_hash_block == block.GetHash());\n     int64_t nTimeStart = GetTimeMicros();\n \n     // Check it again in case a previous version let a bad block in\n@@ -1749,9 +1790,10 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         //  relative to a piece of software is an objective fact these defaults can be easily reviewed.\n         // This setting doesn't force the selection of any particular chain but makes validating some faster by\n         //  effectively caching the result of part of the verification.\n-        BlockMap::const_iterator  it = m_blockman.m_block_index.find(hashAssumeValid);\n+        //\n+        BlockMap::const_iterator  it = m_blockman.m_block_index.find(m_blockman.m_block_index.hash_function()(hashAssumeValid));\n         if (it != m_blockman.m_block_index.end()) {\n-            if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n@@ -1988,7 +2030,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         setDirtyBlockIndex.insert(pindex);\n     }\n \n-    assert(pindex->phashBlock);\n+    assert(!pindex->m_hash_block.IsNull());\n     // add this block to the view's block chain\n     view.SetBestBlock(pindex->GetBlockHash());\n \n@@ -2779,8 +2821,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n \n     {\n         LOCK(cs_main);\n-        for (const auto& entry : m_blockman.m_block_index) {\n-            CBlockIndex *candidate = entry.second;\n+        for (CBlockIndex* candidate : m_blockman.m_block_index) {\n             // We don't need to put anything in our active chain into the\n             // multimap, because those candidates will be found and considered\n             // as we disconnect.\n@@ -2879,8 +2920,8 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind\n         // to setBlockIndexCandidates.\n         BlockMap::iterator it = m_blockman.m_block_index.begin();\n         while (it != m_blockman.m_block_index.end()) {\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {\n-                setBlockIndexCandidates.insert(it->second);\n+            if ((*it)->IsValid(BLOCK_VALID_TRANSACTIONS) && (*it)->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(*it, m_chain.Tip())) {\n+                setBlockIndexCandidates.insert(*it);\n             }\n             it++;\n         }\n@@ -2903,17 +2944,18 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     // Remove the invalidity flag from this block and all its descendants.\n     BlockMap::iterator it = m_blockman.m_block_index.begin();\n     while (it != m_blockman.m_block_index.end()) {\n-        if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n-            it->second->nStatus &= ~BLOCK_FAILED_MASK;\n-            setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n-                setBlockIndexCandidates.insert(it->second);\n+        CBlockIndex& block = **it;\n+        if (!block.IsValid() && block.GetAncestor(nHeight) == pindex) {\n+            block.nStatus &= ~BLOCK_FAILED_MASK;\n+            setDirtyBlockIndex.insert(&block);\n+            if (block.IsValid(BLOCK_VALID_TRANSACTIONS) && block.HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), &block)) {\n+                setBlockIndexCandidates.insert(&block);\n             }\n-            if (it->second == pindexBestInvalid) {\n+            if (&block == pindexBestInvalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n                 pindexBestInvalid = nullptr;\n             }\n-            m_blockman.m_failed_blocks.erase(it->second);\n+            m_blockman.m_failed_blocks.erase(&block);\n         }\n         it++;\n     }\n@@ -2935,22 +2977,22 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n \n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator it = m_block_index.find(hash);\n+    BlockMap::iterator it = m_block_index.find(m_block_index.hash_function()(hash));\n     if (it != m_block_index.end())\n-        return it->second;\n+        return *it;\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n     // We assign the sequence id to blocks only when the full data is available,\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n+    pindexNew->m_hash_block = hash;\n+    m_block_index.insert(pindexNew);\n+    BlockMap::iterator miPrev = m_block_index.find(m_block_index.hash_function()(block.hashPrevBlock));\n     if (miPrev != m_block_index.end())\n     {\n-        pindexNew->pprev = (*miPrev).second;\n+        pindexNew->pprev = *miPrev;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n         pindexNew->BuildSkip();\n     }\n@@ -3292,11 +3334,20 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n+/* <<<<<<< HEAD\n     BlockMap::iterator miSelf = m_block_index.find(hash);\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n         if (miSelf != m_block_index.end()) {\n             // Block header is already known.\n             CBlockIndex* pindex = miSelf->second;\n+======= */\n+    BlockMap::iterator miSelf = m_block_index.find(m_block_index.hash_function()(hash));\n+    CBlockIndex *pindex = nullptr;\n+    if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n+        if (miSelf != m_block_index.end()) {\n+            // Block header is already known.\n+            pindex = *miSelf;\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n@@ -3313,12 +3364,12 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n+        BlockMap::iterator mi = m_block_index.find(m_block_index.hash_function()(block.hashPrevBlock));\n         if (mi == m_block_index.end()) {\n             LogPrintf(\"ERROR: %s: prev block not found\\n\", __func__);\n             return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, \"prev-blk-not-found\");\n         }\n-        pindexPrev = (*mi).second;\n+        pindexPrev = *mi;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n             LogPrintf(\"ERROR: %s: prev block invalid\\n\", __func__);\n             return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, \"bad-prevblk\");\n@@ -3365,7 +3416,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n             }\n         }\n     }\n-    CBlockIndex* pindex = AddToBlockIndex(block);\n+    /* CBlockIndex* */ pindex = AddToBlockIndex(block);\n \n     if (ppindex)\n         *ppindex = pindex;\n@@ -3538,7 +3589,7 @@ bool TestBlockValidity(BlockValidationState& state,\n     CBlockIndex indexDummy(block);\n     indexDummy.pprev = pindexPrev;\n     indexDummy.nHeight = pindexPrev->nHeight + 1;\n-    indexDummy.phashBlock = &block_hash;\n+    indexDummy.m_hash_block = block_hash;\n \n     // NOTE: CheckBlockHeader is called by CheckBlock\n     if (!ContextualCheckBlockHeader(block, state, chainstate.m_blockman, chainparams, pindexPrev, GetAdjustedTime()))\n@@ -3564,8 +3615,13 @@ void BlockManager::PruneOneBlockFile(const int fileNumber)\n     AssertLockHeld(cs_main);\n     LOCK(cs_LastBlockFile);\n \n+/* <<<<<<< HEAD\n     for (const auto& entry : m_block_index) {\n         CBlockIndex* pindex = entry.second;\n+======= */\n+    //for (CBlockIndex* pindex : m_blockman.m_block_index) {\n+    for (CBlockIndex* pindex : m_block_index) {\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n             pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n@@ -3693,14 +3749,14 @@ CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n         return nullptr;\n \n     // Return existing\n-    BlockMap::iterator mi = m_block_index.find(hash);\n+    BlockMap::iterator mi = m_block_index.find(m_block_index.hash_function()(hash));\n     if (mi != m_block_index.end())\n-        return (*mi).second;\n+        return *mi;\n \n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n-    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n+    pindexNew->m_hash_block = hash;\n+    mi = m_block_index.insert(pindexNew).first;\n \n     return pindexNew;\n }\n@@ -3716,9 +3772,8 @@ bool BlockManager::LoadBlockIndex(\n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(m_block_index.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n+    for (CBlockIndex* pindex : m_block_index)\n     {\n-        CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n@@ -3764,8 +3819,8 @@ void BlockManager::Unload() {\n     m_failed_blocks.clear();\n     m_blocks_unlinked.clear();\n \n-    for (const BlockMap::value_type& entry : m_block_index) {\n-        delete entry.second;\n+    for (CBlockIndex* pindex : m_block_index) {\n+        delete pindex;\n     }\n \n     m_block_index.clear();\n@@ -3799,8 +3854,13 @@ bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n+/* <<<<<<< HEAD\n     for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n         CBlockIndex* pindex = item.second;\n+======= */\n+    //for (CBlockIndex* pindex : chainman.BlockIndex()) {\n+    for (CBlockIndex* pindex : m_block_index) {\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n@@ -4022,16 +4082,18 @@ bool CChainState::ReplayBlocks()\n     const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n     const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n \n-    if (m_blockman.m_block_index.count(hashHeads[0]) == 0) {\n+    auto mi = m_blockman.m_block_index.find(m_blockman.m_block_index.hash_function()(hashHeads[0]));\n+    if (mi == m_blockman.m_block_index.end()) {\n         return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n     }\n-    pindexNew = m_blockman.m_block_index[hashHeads[0]];\n+    pindexNew = *mi;\n \n     if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n-        if (m_blockman.m_block_index.count(hashHeads[1]) == 0) {\n+        auto mi2 = m_blockman.m_block_index.find(m_blockman.m_block_index.hash_function()(hashHeads[1]));\n+        if (mi2 == m_blockman.m_block_index.end()) {\n             return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n         }\n-        pindexOld = m_blockman.m_block_index[hashHeads[1]];\n+        pindexOld = *mi2;\n         pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n         assert(pindexFork != nullptr);\n     }\n@@ -4074,6 +4136,92 @@ bool CChainState::ReplayBlocks()\n bool CChainState::NeedsRedownload() const\n {\n     AssertLockHeld(cs_main);\n+/* <<<<<<< HEAD\n+=======\n+    assert(!m_chain.Contains(index)); // Make sure this block isn't active\n+\n+    // Reduce validity\n+    index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n+    // Remove have-data flags.\n+    index->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n+    // Remove storage location.\n+    index->nFile = 0;\n+    index->nDataPos = 0;\n+    index->nUndoPos = 0;\n+    // Remove various other things\n+    index->nTx = 0;\n+    index->nChainTx = 0;\n+    index->nSequenceId = 0;\n+    // Make sure it gets written.\n+    setDirtyBlockIndex.insert(index);\n+    // Update indexes\n+    setBlockIndexCandidates.erase(index);\n+    auto ret = m_blockman.m_blocks_unlinked.equal_range(index->pprev);\n+    while (ret.first != ret.second) {\n+        if (ret.first->second == index) {\n+            m_blockman.m_blocks_unlinked.erase(ret.first++);\n+        } else {\n+            ++ret.first;\n+        }\n+    }\n+    // Mark parent as eligible for main chain again\n+    if (index->pprev && index->pprev->IsValid(BLOCK_VALID_TRANSACTIONS) && index->pprev->HaveTxsDownloaded()) {\n+        setBlockIndexCandidates.insert(index->pprev);\n+    }\n+}\n+\n+bool CChainState::RewindBlockIndex(const CChainParams& params)\n+{\n+    // Note that during -reindex-chainstate we are called with an empty m_chain!\n+\n+    // First erase all post-segwit blocks without witness not in the main chain,\n+    // as this can we done without costly DisconnectTip calls. Active\n+    // blocks will be dealt with below (releasing cs_main in between).\n+    {\n+        LOCK(cs_main);\n+        for (CBlockIndex* pindex : m_blockman.m_block_index) {\n+            if (IsWitnessEnabled(pindex->pprev, params.GetConsensus()) && !(pindex->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(pindex)) {\n+                EraseBlockData(pindex);\n+            }\n+        }\n+    }\n+\n+    // Find what height we need to reorganize to.\n+    CBlockIndex *tip;\n+    int nHeight = 1;\n+    {\n+        LOCK(cs_main);\n+        while (nHeight <= m_chain.Height()) {\n+            // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n+            // blocks in ConnectBlock, we don't need to go back and\n+            // re-download/re-verify blocks from before segwit actually activated.\n+            if (IsWitnessEnabled(m_chain[nHeight - 1], params.GetConsensus()) && !(m_chain[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+                break;\n+            }\n+            nHeight++;\n+        }\n+\n+        tip = m_chain.Tip();\n+    }\n+    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+\n+    BlockValidationState state;\n+    // Loop until the tip is below nHeight, or we reach a pruned block.\n+    while (!ShutdownRequested()) {\n+        {\n+            LOCK2(cs_main, ::mempool.cs);\n+            // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n+            assert(tip == m_chain.Tip());\n+            if (tip == nullptr || tip->nHeight < nHeight) break;\n+            if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n+                // If pruning, don't try rewinding past the HAVE_DATA point;\n+                // since older blocks can't be served anyway, there's\n+                // no need to walk further, and trying to DisconnectTip()\n+                // will fail (and require a needless reindex/redownload\n+                // of the blockchain).\n+                break;\n+            } */\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n \n     // At and above m_params.SegwitHeight, segwit consensus rules must be validated\n     CBlockIndex* block{m_chain.Tip()};\n@@ -4146,7 +4294,12 @@ bool CChainState::LoadGenesisBlock()\n     // m_blockman.m_block_index. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n+/* <<<<<<< HEAD\n     if (m_blockman.m_block_index.count(m_params.GenesisBlock().GetHash()))\n+======= */\n+    //if (m_blockman.m_block_index.count(m_blockman.m_block_index.hash_function()(chainparams.GenesisBlock().GetHash())))\n+    if (m_blockman.m_block_index.count(m_blockman.m_block_index.hash_function()(m_params.GenesisBlock().GetHash())))\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         return true;\n \n     try {\n@@ -4299,8 +4452,8 @@ void CChainState::CheckBlockIndex()\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (const std::pair<const uint256, CBlockIndex*>& entry : m_blockman.m_block_index) {\n-        forward.insert(std::make_pair(entry.second->pprev, entry.second));\n+    for (CBlockIndex* pindex : m_blockman.m_block_index) {\n+        forward.insert(std::make_pair(pindex->pprev, pindex));\n     }\n \n     assert(forward.size() == m_blockman.m_block_index.size());\n@@ -4672,8 +4825,25 @@ double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex *pin\n \n std::optional<uint256> ChainstateManager::SnapshotBlockhash() const\n {\n+//<<<<<<< HEAD\n     LOCK(::cs_main);\n     if (m_active_chainstate && m_active_chainstate->m_from_snapshot_blockhash) {\n+/* =======\n+public:\n+    CMainCleanup() {}\n+    ~CMainCleanup() {\n+        // block headers\n+        BlockMap::iterator it1 = g_chainman.BlockIndex().begin();\n+        for (; it1 != g_chainman.BlockIndex().end(); it1++)\n+            delete *it1;\n+        g_chainman.BlockIndex().clear();\n+    }\n+};\n+static CMainCleanup instance_of_cmaincleanup;\n+\n+Optional<uint256> ChainstateManager::SnapshotBlockhash() const {\n+    if (m_active_chainstate != nullptr) { */\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         // If a snapshot chainstate exists, it will always be our active.\n         return m_active_chainstate->m_from_snapshot_blockhash;\n     }"
      },
      {
        "sha": "cf41293ee7f9f5625837e128859213264f5449e2",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -97,6 +97,33 @@ static const unsigned int DEFAULT_CHECKLEVEL = 3;\n // one 128MB block file + added 15% undo data = 147MB greater for a total of 545MB\n // Setting the target to >= 550 MiB will make it likely we can respect the target.\n static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n+/* <<<<<<< HEAD\n+======= */\n+/** Minimum size of a witness commitment structure. Defined in BIP 141. **/\n+//static constexpr size_t MINIMUM_WITNESS_COMMITMENT{38};\n+\n+struct BlockHasher\n+{\n+    // this used to call `GetCheapHash()` in uint256, which was later moved; the\n+    // cheap hash function simply calls ReadLE64() however, so the end result is\n+    // identical\n+    mutable CBlockIndex mock;\n+    BlockHasher() : mock() {};\n+    size_t operator()(CBlockIndex* const& ptr) const { return ReadLE64(ptr->GetBlockHash().begin()); }\n+    // Helper for querying by hash\n+    // e.g., map.find(map.hash_function()(h))\n+    CBlockIndex* operator()(const uint256& hash) {\n+        mock.m_hash_block = hash;\n+        return &mock;\n+    }\n+};\n+\n+\n+struct BlockEqual\n+{\n+    bool operator()(CBlockIndex* const& ptr, CBlockIndex* const& ptr2) const { return ptr->GetBlockHash() == ptr2->GetBlockHash(); }\n+};\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n \n /** Current sync state passed to tip changed callbacks. */\n enum class SynchronizationState {\n@@ -106,7 +133,13 @@ enum class SynchronizationState {\n };\n \n extern RecursiveMutex cs_main;\n+/* <<<<<<< HEAD\n typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n+======= */\n+extern CBlockPolicyEstimator feeEstimator;\n+extern CTxMemPool mempool;\n+typedef std::unordered_set<CBlockIndex*, BlockHasher, BlockEqual> BlockMap;\n+//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n extern uint256 g_best_block;"
      },
      {
        "sha": "3eb31e03baca60c5c3726ec98a321e22723f592a",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "patch": "@@ -339,13 +339,13 @@ static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lock\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n         LOCK(cs_main);\n-        auto inserted = chainman.BlockIndex().emplace(GetRandHash(), new CBlockIndex);\n+        auto pblock = new CBlockIndex;\n+        pblock->m_hash_block = GetRandHash();\n+        auto inserted = chainman.BlockIndex().emplace(pblock);\n         assert(inserted.second);\n-        const uint256& hash = inserted.first->first;\n-        block = inserted.first->second;\n+        block = *inserted.first;\n         block->nTime = blockTime;\n-        block->phashBlock = &hash;\n-        confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, hash, 0};\n+        confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, block->GetBlockHash(), 0};\n     }\n \n     // If transaction is already in map, to avoid inconsistencies, unconfirmation"
      }
    ]
  },
  {
    "sha": "3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNjE0ODY5ZTUzZjg1YjBmNTAzM2NhNGMzZjFkNmQzOGE1ZDIwOTFl",
    "commit": {
      "author": {
        "name": "Shorya",
        "email": "shoryak@iitk.ac.in",
        "date": "2021-07-28T19:01:59Z"
      },
      "committer": {
        "name": "Shorya",
        "email": "shoryak@iitk.ac.in",
        "date": "2021-07-28T19:01:59Z"
      },
      "message": "rebase complete",
      "tree": {
        "sha": "7eeaca828d39d65b1339360d29915c4759111526",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7eeaca828d39d65b1339360d29915c4759111526"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/comments",
    "author": {
      "login": "shoryak",
      "id": 60062252,
      "node_id": "MDQ6VXNlcjYwMDYyMjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60062252?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoryak",
      "html_url": "https://github.com/shoryak",
      "followers_url": "https://api.github.com/users/shoryak/followers",
      "following_url": "https://api.github.com/users/shoryak/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoryak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoryak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoryak/subscriptions",
      "organizations_url": "https://api.github.com/users/shoryak/orgs",
      "repos_url": "https://api.github.com/users/shoryak/repos",
      "events_url": "https://api.github.com/users/shoryak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoryak/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "shoryak",
      "id": 60062252,
      "node_id": "MDQ6VXNlcjYwMDYyMjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60062252?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoryak",
      "html_url": "https://github.com/shoryak",
      "followers_url": "https://api.github.com/users/shoryak/followers",
      "following_url": "https://api.github.com/users/shoryak/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoryak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoryak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoryak/subscriptions",
      "organizations_url": "https://api.github.com/users/shoryak/orgs",
      "repos_url": "https://api.github.com/users/shoryak/repos",
      "events_url": "https://api.github.com/users/shoryak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoryak/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/445b3cb5d7df25b877e06b4788ad0ac2cf2a0709"
      }
    ],
    "stats": {
      "total": 227,
      "additions": 15,
      "deletions": 212
    },
    "files": [
      {
        "sha": "f49520abe191fbf657c8c51828bdc2e7b1c4d2ab",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 10,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "patch": "@@ -28,21 +28,12 @@ struct TestBlockAndIndex {\n \n         stream >> block;\n \n-//<<<<<<< HEAD\n-       /*  blockHash = block.GetHash();\n-        blockindex.phashBlock = &blockHash;\n-        blockindex.nBits = 403014710; */\n          CBlockIndex blockindex;\n         blockindex.m_hash_block = block.GetHash();\n         blockindex.nBits = 403014710;\n     }\n };\n-/* =======\n-    CBlockIndex blockindex;\n-    blockindex.m_hash_block = block.GetHash();\n-    blockindex.nBits = 403014710;\n->>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n- */\n+\n } // namespace\n \n static void BlockToJsonVerbose(benchmark::Bench& bench)"
      },
      {
        "sha": "d9df0450fd2e5467825cfa131b9768f9964708f6",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "patch": "@@ -1578,17 +1578,11 @@ static RPCHelpMan getchaintips()\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n-/* <<<<<<< HEAD\n-    for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {\n-        if (!active_chain.Contains(item.second)) {\n-            setOrphans.insert(item.second);\n-            setPrevs.insert(item.second->pprev);\n-======= */\n+\n     for (CBlockIndex* pindex : chainman.BlockIndex()) {\n         if (!chainman.ActiveChain().Contains(pindex)) {\n             setOrphans.insert(pindex);\n             setPrevs.insert(pindex->pprev);\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         }\n     }\n "
      },
      {
        "sha": "90161430145079cf56ae4ac178c080b7f0b909a1",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 24,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "patch": "@@ -369,14 +369,8 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (m_node.chainman->ActiveChain().Tip()->nHeight < 209999) {\n         CBlockIndex* prev = m_node.chainman->ActiveChain().Tip();\n         CBlockIndex* next = new CBlockIndex();\n-/* <<<<<<< HEAD\n-        next->phashBlock = new uint256(InsecureRand256());\n-        m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n-======= */\n         next->m_hash_block = uint256(InsecureRand256());\n         m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n-        //::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -387,14 +381,11 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (m_node.chainman->ActiveChain().Tip()->nHeight < 210000) {\n         CBlockIndex* prev = m_node.chainman->ActiveChain().Tip();\n         CBlockIndex* next = new CBlockIndex();\n-/* <<<<<<< HEAD\n-        next->phashBlock = new uint256(InsecureRand256());\n-        m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n-======= */\n+\n         next->m_hash_block = uint256(InsecureRand256());\n-        //::ChainstateActive().CoinsTip().SetBestBlock(next->GetBlockHash());\n+      \n         m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(next->GetBlockHash());\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n+\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n         next->BuildSkip();\n@@ -421,22 +412,11 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     m_node.mempool->clear();\n \n     // Delete the dummy blocks again.\n-/* <<<<<<< HEAD\n-    while (m_node.chainman->ActiveChain().Tip()->nHeight > nHeight) {\n-        CBlockIndex* del = m_node.chainman->ActiveChain().Tip();\n-        m_node.chainman->ActiveChain().SetTip(del->pprev);\n-        m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n-        delete del->phashBlock;\n-=======\n-    while (::ChainActive().Tip()->nHeight > nHeight) {\n-        CBlockIndex* del = ::ChainActive().Tip();\n-        ::ChainActive().SetTip(del->pprev); */\n-        //::ChainstateActive().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n+\n     while (m_node.chainman->ActiveChain().Tip()->nHeight > nHeight) {\n         CBlockIndex* del = m_node.chainman->ActiveChain().Tip();\n         m_node.chainman->ActiveChain().SetTip(del->pprev);\n         m_node.chainman->ActiveChainstate().CoinsTip().SetBestBlock(del->pprev->GetBlockHash());\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         delete del;\n     }\n "
      },
      {
        "sha": "f47c3f9e916bace670147ca8b05eeb3ab84374f8",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 168,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "patch": "@@ -148,15 +148,10 @@ void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);\n CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const\n {\n     AssertLockHeld(cs_main);\n-/* <<<<<<< HEAD\n-    BlockMap::const_iterator it = m_block_index.find(hash);\n-    return it == m_block_index.end() ? nullptr : it->second;\n-======= */\n-    //auto& idx = g_chainman.BlockIndex();\n-    //BlockMap::const_iterator it = idx.find(idx.hash_function()(hash));\n+\n     BlockMap::const_iterator it = m_block_index.find( m_block_index.hash_function()(hash));\n     return it ==  m_block_index.end() ? nullptr : *it;\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n+\n }\n \n CBlockIndex* BlockManager::FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -1302,40 +1297,6 @@ void CChainState::CheckForkWarningConditions()\n     // (we assume we don't get stuck on a fork before finishing our initial sync)\n     if (IsInitialBlockDownload()) {\n         return;\n-/* <<<<<<< HEAD\n-=======\n-\n-    // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n-    // of our head, drop it\n-    if (pindexBestForkTip && ::ChainActive().Height() - pindexBestForkTip->nHeight >= 72)\n-        pindexBestForkTip = nullptr;\n-\n-    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > ::ChainActive().Tip()->nChainWork + (GetBlockProof(*::ChainActive().Tip()) * 6)))\n-    {\n-        if (!GetfLargeWorkForkFound() && pindexBestForkBase)\n-        {\n-            std::string warning = std::string(\"'Warning: Large-work fork detected, forking after block \") +\n-                pindexBestForkBase->m_hash_block.ToString() + std::string(\"'\");\n-            AlertNotify(warning);\n-        }\n-        if (pindexBestForkTip && pindexBestForkBase)\n-        {\n-            LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,\n-                   pindexBestForkBase->nHeight, pindexBestForkBase->m_hash_block.ToString(),\n-                   pindexBestForkTip->nHeight, pindexBestForkTip->m_hash_block.ToString());\n-            SetfLargeWorkForkFound(true);\n-        }\n-        else\n-        {\n-            LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__);\n-            SetfLargeWorkInvalidChainFound(true);\n-        }\n-    }\n-    else\n-    {\n-        SetfLargeWorkForkFound(false);\n-        SetfLargeWorkInvalidChainFound(false);\n->>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map */\n     }\n \n     if (pindexBestInvalid && pindexBestInvalid->nChainWork > m_chain.Tip()->nChainWork + (GetBlockProof(*m_chain.Tip()) * 6)) {\n@@ -3334,20 +3295,12 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-/* <<<<<<< HEAD\n-    BlockMap::iterator miSelf = m_block_index.find(hash);\n-    if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n-        if (miSelf != m_block_index.end()) {\n-            // Block header is already known.\n-            CBlockIndex* pindex = miSelf->second;\n-======= */\n     BlockMap::iterator miSelf = m_block_index.find(m_block_index.hash_function()(hash));\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n         if (miSelf != m_block_index.end()) {\n             // Block header is already known.\n             pindex = *miSelf;\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n@@ -3615,13 +3568,9 @@ void BlockManager::PruneOneBlockFile(const int fileNumber)\n     AssertLockHeld(cs_main);\n     LOCK(cs_LastBlockFile);\n \n-/* <<<<<<< HEAD\n-    for (const auto& entry : m_block_index) {\n-        CBlockIndex* pindex = entry.second;\n-======= */\n-    //for (CBlockIndex* pindex : m_blockman.m_block_index) {\n+\n+    \n     for (CBlockIndex* pindex : m_block_index) {\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n             pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n@@ -3854,13 +3803,8 @@ bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-/* <<<<<<< HEAD\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n-        CBlockIndex* pindex = item.second;\n-======= */\n-    //for (CBlockIndex* pindex : chainman.BlockIndex()) {\n     for (CBlockIndex* pindex : m_block_index) {\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n+\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n@@ -4136,92 +4080,7 @@ bool CChainState::ReplayBlocks()\n bool CChainState::NeedsRedownload() const\n {\n     AssertLockHeld(cs_main);\n-/* <<<<<<< HEAD\n-=======\n-    assert(!m_chain.Contains(index)); // Make sure this block isn't active\n-\n-    // Reduce validity\n-    index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n-    // Remove have-data flags.\n-    index->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n-    // Remove storage location.\n-    index->nFile = 0;\n-    index->nDataPos = 0;\n-    index->nUndoPos = 0;\n-    // Remove various other things\n-    index->nTx = 0;\n-    index->nChainTx = 0;\n-    index->nSequenceId = 0;\n-    // Make sure it gets written.\n-    setDirtyBlockIndex.insert(index);\n-    // Update indexes\n-    setBlockIndexCandidates.erase(index);\n-    auto ret = m_blockman.m_blocks_unlinked.equal_range(index->pprev);\n-    while (ret.first != ret.second) {\n-        if (ret.first->second == index) {\n-            m_blockman.m_blocks_unlinked.erase(ret.first++);\n-        } else {\n-            ++ret.first;\n-        }\n-    }\n-    // Mark parent as eligible for main chain again\n-    if (index->pprev && index->pprev->IsValid(BLOCK_VALID_TRANSACTIONS) && index->pprev->HaveTxsDownloaded()) {\n-        setBlockIndexCandidates.insert(index->pprev);\n-    }\n-}\n \n-bool CChainState::RewindBlockIndex(const CChainParams& params)\n-{\n-    // Note that during -reindex-chainstate we are called with an empty m_chain!\n-\n-    // First erase all post-segwit blocks without witness not in the main chain,\n-    // as this can we done without costly DisconnectTip calls. Active\n-    // blocks will be dealt with below (releasing cs_main in between).\n-    {\n-        LOCK(cs_main);\n-        for (CBlockIndex* pindex : m_blockman.m_block_index) {\n-            if (IsWitnessEnabled(pindex->pprev, params.GetConsensus()) && !(pindex->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(pindex)) {\n-                EraseBlockData(pindex);\n-            }\n-        }\n-    }\n-\n-    // Find what height we need to reorganize to.\n-    CBlockIndex *tip;\n-    int nHeight = 1;\n-    {\n-        LOCK(cs_main);\n-        while (nHeight <= m_chain.Height()) {\n-            // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n-            // blocks in ConnectBlock, we don't need to go back and\n-            // re-download/re-verify blocks from before segwit actually activated.\n-            if (IsWitnessEnabled(m_chain[nHeight - 1], params.GetConsensus()) && !(m_chain[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n-                break;\n-            }\n-            nHeight++;\n-        }\n-\n-        tip = m_chain.Tip();\n-    }\n-    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n-\n-    BlockValidationState state;\n-    // Loop until the tip is below nHeight, or we reach a pruned block.\n-    while (!ShutdownRequested()) {\n-        {\n-            LOCK2(cs_main, ::mempool.cs);\n-            // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n-            assert(tip == m_chain.Tip());\n-            if (tip == nullptr || tip->nHeight < nHeight) break;\n-            if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n-                // If pruning, don't try rewinding past the HAVE_DATA point;\n-                // since older blocks can't be served anyway, there's\n-                // no need to walk further, and trying to DisconnectTip()\n-                // will fail (and require a needless reindex/redownload\n-                // of the blockchain).\n-                break;\n-            } */\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n \n     // At and above m_params.SegwitHeight, segwit consensus rules must be validated\n     CBlockIndex* block{m_chain.Tip()};\n@@ -4294,12 +4153,10 @@ bool CChainState::LoadGenesisBlock()\n     // m_blockman.m_block_index. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n-/* <<<<<<< HEAD\n-    if (m_blockman.m_block_index.count(m_params.GenesisBlock().GetHash()))\n-======= */\n-    //if (m_blockman.m_block_index.count(m_blockman.m_block_index.hash_function()(chainparams.GenesisBlock().GetHash())))\n+\n+    \n     if (m_blockman.m_block_index.count(m_blockman.m_block_index.hash_function()(m_params.GenesisBlock().GetHash())))\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n+\n         return true;\n \n     try {\n@@ -4825,26 +4682,9 @@ double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex *pin\n \n std::optional<uint256> ChainstateManager::SnapshotBlockhash() const\n {\n-//<<<<<<< HEAD\n     LOCK(::cs_main);\n     if (m_active_chainstate && m_active_chainstate->m_from_snapshot_blockhash) {\n-/* =======\n-public:\n-    CMainCleanup() {}\n-    ~CMainCleanup() {\n-        // block headers\n-        BlockMap::iterator it1 = g_chainman.BlockIndex().begin();\n-        for (; it1 != g_chainman.BlockIndex().end(); it1++)\n-            delete *it1;\n-        g_chainman.BlockIndex().clear();\n-    }\n-};\n-static CMainCleanup instance_of_cmaincleanup;\n \n-Optional<uint256> ChainstateManager::SnapshotBlockhash() const {\n-    if (m_active_chainstate != nullptr) { */\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n-        // If a snapshot chainstate exists, it will always be our active.\n         return m_active_chainstate->m_from_snapshot_blockhash;\n     }\n     return std::nullopt;"
      },
      {
        "sha": "e6590f581ea012ebf869909fa119da42ae743276",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "patch": "@@ -97,8 +97,7 @@ static const unsigned int DEFAULT_CHECKLEVEL = 3;\n // one 128MB block file + added 15% undo data = 147MB greater for a total of 545MB\n // Setting the target to >= 550 MiB will make it likely we can respect the target.\n static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n-/* <<<<<<< HEAD\n-======= */\n+\n /** Minimum size of a witness commitment structure. Defined in BIP 141. **/\n //static constexpr size_t MINIMUM_WITNESS_COMMITMENT{38};\n \n@@ -123,7 +122,6 @@ struct BlockEqual\n {\n     bool operator()(CBlockIndex* const& ptr, CBlockIndex* const& ptr2) const { return ptr->GetBlockHash() == ptr2->GetBlockHash(); }\n };\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n \n /** Current sync state passed to tip changed callbacks. */\n enum class SynchronizationState {"
      }
    ]
  },
  {
    "sha": "aefb58c0fdd22fc5dd78c28df47504e29483f91d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZWZiNThjMGZkZDIyZmM1ZGQ3OGMyOGRmNDc1MDRlMjk0ODNmOTFk",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-08-07T05:03:40Z"
      },
      "committer": {
        "name": "Shorya",
        "email": "shoryak@iitk.ac.in",
        "date": "2021-07-28T20:24:16Z"
      },
      "message": "Refactor BlockMap to use an unordered_set instead of an unordered_map",
      "tree": {
        "sha": "0f7195ef9f1278f10f6d9c201476e5f64e63e2f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f7195ef9f1278f10f6d9c201476e5f64e63e2f1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aefb58c0fdd22fc5dd78c28df47504e29483f91d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aefb58c0fdd22fc5dd78c28df47504e29483f91d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aefb58c0fdd22fc5dd78c28df47504e29483f91d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aefb58c0fdd22fc5dd78c28df47504e29483f91d/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "shoryak",
      "id": 60062252,
      "node_id": "MDQ6VXNlcjYwMDYyMjUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/60062252?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoryak",
      "html_url": "https://github.com/shoryak",
      "followers_url": "https://api.github.com/users/shoryak/followers",
      "following_url": "https://api.github.com/users/shoryak/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoryak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoryak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoryak/subscriptions",
      "organizations_url": "https://api.github.com/users/shoryak/orgs",
      "repos_url": "https://api.github.com/users/shoryak/repos",
      "events_url": "https://api.github.com/users/shoryak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoryak/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3614869e53f85b0f5033ca4c3f1d6d38a5d2091e"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 1,
      "deletions": 5
    },
    "files": [
      {
        "sha": "b6ff4dfb63cc1357a67eef27a9ac76d37e293c1f",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aefb58c0fdd22fc5dd78c28df47504e29483f91d/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aefb58c0fdd22fc5dd78c28df47504e29483f91d/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=aefb58c0fdd22fc5dd78c28df47504e29483f91d",
        "patch": "@@ -1578,7 +1578,6 @@ static RPCHelpMan getchaintips()\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n-\n     for (CBlockIndex* pindex : chainman.BlockIndex()) {\n         if (!chainman.ActiveChain().Contains(pindex)) {\n             setOrphans.insert(pindex);"
      },
      {
        "sha": "f475e30fd6d2f7f60b765c2f60c88de2ac8c8b01",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aefb58c0fdd22fc5dd78c28df47504e29483f91d/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aefb58c0fdd22fc5dd78c28df47504e29483f91d/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=aefb58c0fdd22fc5dd78c28df47504e29483f91d",
        "patch": "@@ -131,13 +131,10 @@ enum class SynchronizationState {\n };\n \n extern RecursiveMutex cs_main;\n-/* <<<<<<< HEAD\n-typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n-======= */\n+\n extern CBlockPolicyEstimator feeEstimator;\n extern CTxMemPool mempool;\n typedef std::unordered_set<CBlockIndex*, BlockHasher, BlockEqual> BlockMap;\n-//>>>>>>> Refactor BlockMap to use an unordered_set instead of an unordered_map\n extern Mutex g_best_block_mutex;\n extern std::condition_variable g_best_block_cv;\n extern uint256 g_best_block;"
      }
    ]
  }
]