[
  {
    "sha": "a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMmJlM2I2NmI1NmJjY2MwMWRmYTJmYjk5MjUxNWFlNTZiYmVkZDQ5",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-08-22T21:09:04Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-10-03T17:28:00Z"
      },
      "message": "[net] Ignore getheaders requests for very old side blocks\n\nSending a getheaders message with an empty locator and a stop hash\nis a request for a single header by hash. The node will respond with\nheaders for blocks not in the main chain as well as those in the main\nchain. To avoid fingerprinting, the node should, however, ignore\nrequests for headers on side branches that are too old.",
      "tree": {
        "sha": "23d54afb4683e9d27f6106940fbdb949346be700",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23d54afb4683e9d27f6106940fbdb949346be700"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2be3b66b56bccc01dfa2fb992515ae56bbedd49/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dbc4ae03963014ab4b7957d62ba59dbd8f938c33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dbc4ae03963014ab4b7957d62ba59dbd8f938c33",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dbc4ae03963014ab4b7957d62ba59dbd8f938c33"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 28,
      "deletions": 9
    },
    "files": [
      {
        "sha": "b5e37722df1e3443109cea8a991ed94a158c4a64",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 9,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2be3b66b56bccc01dfa2fb992515ae56bbedd49/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2be3b66b56bccc01dfa2fb992515ae56bbedd49/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
        "patch": "@@ -61,6 +61,14 @@ static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUAR\n \n static const uint64_t RANDOMIZER_ID_ADDRESS_RELAY = 0x3cac0035b5866b90ULL; // SHA256(\"main address relay\")[0:8]\n \n+/// Age after which a stale block will no longer be served if requested as\n+/// protection against fingerprinting. Set to one month, denominated in seconds.\n+static const int STALE_RELAY_AGE_LIMIT = 30 * 24 * 60 * 60;\n+\n+/// Age after which a block is considered historical for purposes of rate\n+/// limiting block relay. Set to one week, denominated in seconds.\n+static const int HISTORICAL_BLOCK_AGE = 7 * 24 * 60 * 60;\n+\n // Internal stuff\n namespace {\n     /** Number of nodes with fSyncStarted. */\n@@ -706,6 +714,17 @@ void Misbehaving(NodeId pnode, int howmuch)\n // blockchain -> download logic notification\n //\n \n+// To prevent fingerprinting attacks, only send blocks/headers outside of the\n+// active chain if they are no more than a month older (both in time, and in\n+// best equivalent proof of work) than the best header chain we know about.\n+static bool StaleBlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n+{\n+    AssertLockHeld(cs_main);\n+    return (pindexBestHeader != nullptr) &&\n+        (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n+        (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n+}\n+\n PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn) : connman(connmanIn) {\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n@@ -983,22 +1002,16 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     if (chainActive.Contains(mi->second)) {\n                         send = true;\n                     } else {\n-                        static const int nOneMonth = 30 * 24 * 60 * 60;\n-                        // To prevent fingerprinting attacks, only send blocks outside of the active\n-                        // chain if they are valid, and no more than a month older (both in time, and in\n-                        // best equivalent proof of work) than the best header chain we know about.\n-                        send = mi->second->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n-                            (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() < nOneMonth) &&\n-                            (GetBlockProofEquivalentTime(*pindexBestHeader, *mi->second, *pindexBestHeader, consensusParams) < nOneMonth);\n+                        send = mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                            StaleBlockRequestAllowed(mi->second, consensusParams);\n                         if (!send) {\n                             LogPrintf(\"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n                         }\n                     }\n                 }\n                 // disconnect node in case we have reached the outbound limit for serving historical blocks\n                 // never disconnect whitelisted nodes\n-                static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n-                if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+                if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n                 {\n                     LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1723,6 +1736,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (mi == mapBlockIndex.end())\n                 return true;\n             pindex = (*mi).second;\n+\n+            if (!chainActive.Contains(pindex) &&\n+                !StaleBlockRequestAllowed(pindex, chainparams.GetConsensus())) {\n+                LogPrintf(\"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+                return true;\n+            }\n         }\n         else\n         {"
      }
    ]
  },
  {
    "sha": "eff4bd8ab257a553ca8898ccd803630b4d44a771",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZmY0YmQ4YWIyNTdhNTUzY2E4ODk4Y2NkODAzNjMwYjRkNDRhNzcx",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-08-25T00:06:42Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2017-10-03T17:28:00Z"
      },
      "message": "[test] P2P functional test for certain fingerprinting protections",
      "tree": {
        "sha": "d55da0a01a7cde16c0ae189bbf690044b10eae27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d55da0a01a7cde16c0ae189bbf690044b10eae27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eff4bd8ab257a553ca8898ccd803630b4d44a771",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eff4bd8ab257a553ca8898ccd803630b4d44a771",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eff4bd8ab257a553ca8898ccd803630b4d44a771",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eff4bd8ab257a553ca8898ccd803630b4d44a771/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2be3b66b56bccc01dfa2fb992515ae56bbedd49",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a2be3b66b56bccc01dfa2fb992515ae56bbedd49"
      }
    ],
    "stats": {
      "total": 163,
      "additions": 161,
      "deletions": 2
    },
    "files": [
      {
        "sha": "fe60c6cd46dca11adc46778615a850b036f1fd60",
        "filename": "test/functional/p2p-fingerprint.py",
        "status": "added",
        "additions": 158,
        "deletions": 0,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eff4bd8ab257a553ca8898ccd803630b4d44a771/test/functional/p2p-fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eff4bd8ab257a553ca8898ccd803630b4d44a771/test/functional/p2p-fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-fingerprint.py?ref=eff4bd8ab257a553ca8898ccd803630b4d44a771",
        "patch": "@@ -0,0 +1,158 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test various fingerprinting protections.\n+\n+If an stale block more than a month old or its header are requested by a peer,\n+the node should pretend that it does not have it to avoid fingerprinting.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.mininode import (\n+    CInv,\n+    NetworkThread,\n+    NodeConn,\n+    NodeConnCB,\n+    msg_headers,\n+    msg_block,\n+    msg_getdata,\n+    msg_getheaders,\n+    wait_until,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    p2p_port,\n+)\n+\n+class P2PFingerprintTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    # Build a chain of blocks on top of given one\n+    def build_chain(self, nblocks, prev_hash, prev_height, prev_median_time):\n+        blocks = []\n+        for _ in range(nblocks):\n+            coinbase = create_coinbase(prev_height + 1)\n+            block_time = prev_median_time + 1\n+            block = create_block(int(prev_hash, 16), coinbase, block_time)\n+            block.solve()\n+\n+            blocks.append(block)\n+            prev_hash = block.hash\n+            prev_height += 1\n+            prev_median_time = block_time\n+        return blocks\n+\n+    # Send a getdata request for a given block hash\n+    def send_block_request(self, block_hash, node):\n+        msg = msg_getdata()\n+        msg.inv.append(CInv(2, block_hash))  # 2 == \"Block\"\n+        node.send_message(msg)\n+\n+    # Send a getheaders request for a given single block hash\n+    def send_header_request(self, block_hash, node):\n+        msg = msg_getheaders()\n+        msg.hashstop = block_hash\n+        node.send_message(msg)\n+\n+    # Check whether last block received from node has a given hash\n+    def last_block_equals(self, expected_hash, node):\n+        block_msg = node.last_message.get(\"block\")\n+        return block_msg and block_msg.block.rehash() == expected_hash\n+\n+    # Check whether last block header received from node has a given hash\n+    def last_header_equals(self, expected_hash, node):\n+        headers_msg = node.last_message.get(\"headers\")\n+        return (headers_msg and\n+                headers_msg.headers and\n+                headers_msg.headers[0].rehash() == expected_hash)\n+\n+    # Checks that stale blocks timestamped more than a month ago are not served\n+    # by the node while recent stale blocks and old active chain blocks are.\n+    # This does not currently test that stale blocks timestamped within the\n+    # last month but that have over a month's worth of work are also withheld.\n+    def run_test(self):\n+        node0 = NodeConnCB()\n+\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n+        node0.add_connection(connections[0])\n+\n+        NetworkThread().start()\n+        node0.wait_for_verack()\n+\n+        # Set node time to 60 days ago\n+        self.nodes[0].setmocktime(int(time.time()) - 60 * 24 * 60 * 60)\n+\n+        # Generating a chain of 10 blocks\n+        block_hashes = self.nodes[0].generate(nblocks=10)\n+\n+        # Create longer chain starting 2 blocks before current tip\n+        height = len(block_hashes) - 2\n+        block_hash = block_hashes[height - 1]\n+        block_time = self.nodes[0].getblockheader(block_hash)[\"mediantime\"] + 1\n+        new_blocks = self.build_chain(5, block_hash, height, block_time)\n+\n+        # Force reorg to a longer chain\n+        node0.send_message(msg_headers(new_blocks))\n+        node0.wait_for_getdata()\n+        for block in new_blocks:\n+            node0.send_and_ping(msg_block(block))\n+\n+        # Check that reorg succeeded\n+        assert_equal(self.nodes[0].getblockcount(), 13)\n+\n+        stale_hash = int(block_hashes[-1], 16)\n+\n+        # Check that getdata request for stale block succeeds\n+        self.send_block_request(stale_hash, node0)\n+        test_function = lambda: self.last_block_equals(stale_hash, node0)\n+        wait_until(test_function, timeout=3)\n+\n+        # Check that getheader request for stale block header succeeds\n+        self.send_header_request(stale_hash, node0)\n+        test_function = lambda: self.last_header_equals(stale_hash, node0)\n+        wait_until(test_function, timeout=3)\n+\n+        # Longest chain is extended so stale is much older than chain tip\n+        self.nodes[0].setmocktime(0)\n+        tip = self.nodes[0].generate(nblocks=1)[0]\n+        assert_equal(self.nodes[0].getblockcount(), 14)\n+\n+        # Send getdata & getheaders to refresh last received getheader message\n+        block_hash = int(tip, 16)\n+        self.send_block_request(block_hash, node0)\n+        self.send_header_request(block_hash, node0)\n+        node0.sync_with_ping()\n+\n+        # Request for very old stale block should now fail\n+        self.send_block_request(stale_hash, node0)\n+        time.sleep(3)\n+        assert not self.last_block_equals(stale_hash, node0)\n+\n+        # Request for very old stale block header should now fail\n+        self.send_header_request(stale_hash, node0)\n+        time.sleep(3)\n+        assert not self.last_header_equals(stale_hash, node0)\n+\n+        # Verify we can fetch very old blocks and headers on the active chain\n+        block_hash = int(block_hashes[2], 16)\n+        self.send_block_request(block_hash, node0)\n+        self.send_header_request(block_hash, node0)\n+        node0.sync_with_ping()\n+\n+        self.send_block_request(block_hash, node0)\n+        test_function = lambda: self.last_block_equals(block_hash, node0)\n+        wait_until(test_function, timeout=3)\n+\n+        self.send_header_request(block_hash, node0)\n+        test_function = lambda: self.last_header_equals(block_hash, node0)\n+        wait_until(test_function, timeout=3)\n+\n+if __name__ == '__main__':\n+    P2PFingerprintTest().main()"
      },
      {
        "sha": "c6f596156a777259bcf3f2ccf48a553d44be985a",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eff4bd8ab257a553ca8898ccd803630b4d44a771/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eff4bd8ab257a553ca8898ccd803630b4d44a771/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=eff4bd8ab257a553ca8898ccd803630b4d44a771",
        "patch": "@@ -1310,8 +1310,8 @@ def __repr__(self):\n class msg_headers(object):\n     command = b\"headers\"\n \n-    def __init__(self):\n-        self.headers = []\n+    def __init__(self, headers=None):\n+        self.headers = headers if headers is not None else []\n \n     def deserialize(self, f):\n         # comment in bitcoind indicates these should be deserialized as blocks"
      },
      {
        "sha": "434ba23b3b3963a08bf22a532611fc62b9e27020",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eff4bd8ab257a553ca8898ccd803630b4d44a771/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eff4bd8ab257a553ca8898ccd803630b4d44a771/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=eff4bd8ab257a553ca8898ccd803630b4d44a771",
        "patch": "@@ -123,6 +123,7 @@\n     'uptime.py',\n     'resendwallettransactions.py',\n     'minchainwork.py',\n+    'p2p-fingerprint.py',\n ]\n \n EXTENDED_SCRIPTS = ["
      }
    ]
  }
]