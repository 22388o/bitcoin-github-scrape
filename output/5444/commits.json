[
  {
    "sha": "f676c80f437e15ab0ee190e93baea733a88db0f2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNjc2YzgwZjQzN2UxNWFiMGVlMTkwZTkzYmFlYTczM2E4OGRiMGYy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-12-08T12:44:49Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-12-12T15:37:00Z"
      },
      "message": "Add /rest/headers",
      "tree": {
        "sha": "f141f7d0aa48ffead398bcf82de92d4ddaf3f510",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f141f7d0aa48ffead398bcf82de92d4ddaf3f510"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f676c80f437e15ab0ee190e93baea733a88db0f2",
      "comment_count": 2,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f676c80f437e15ab0ee190e93baea733a88db0f2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f676c80f437e15ab0ee190e93baea733a88db0f2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f676c80f437e15ab0ee190e93baea733a88db0f2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5f7279ac70b755d3aac9582d36e08bdf0e3f4fc6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5f7279ac70b755d3aac9582d36e08bdf0e3f4fc6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5f7279ac70b755d3aac9582d36e08bdf0e3f4fc6"
      }
    ],
    "stats": {
      "total": 113,
      "additions": 99,
      "deletions": 14
    },
    "files": [
      {
        "sha": "704d889739faf56a42e96c2dcc49ea8f953ca8ed",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 35,
        "deletions": 14,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f676c80f437e15ab0ee190e93baea733a88db0f2/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f676c80f437e15ab0ee190e93baea733a88db0f2/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=f676c80f437e15ab0ee190e93baea733a88db0f2",
        "patch": "@@ -23,67 +23,88 @@\n def http_get_call(host, port, path, response_object = 0):\n     conn = httplib.HTTPConnection(host, port)\n     conn.request('GET', path)\n-    \n+\n     if response_object:\n         return conn.getresponse()\n-        \n+\n     return conn.getresponse().read()\n \n \n class RESTTest (BitcoinTestFramework):\n     FORMAT_SEPARATOR = \".\"\n-    \n+\n     def run_test(self):\n         url = urlparse.urlparse(self.nodes[0].url)\n         bb_hash = self.nodes[0].getbestblockhash()\n-        \n+\n         # check binary format\n         response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n         assert_equal(response.status, 200)\n-        assert_greater_than(int(response.getheader('content-length')), 10)\n-        \n+        assert_greater_than(int(response.getheader('content-length')), 80)\n+        response_str = response.read()\n+\n+        # compare with block header\n+        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n+        assert_equal(response_header.status, 200)\n+        assert_equal(int(response_header.getheader('content-length')), 80)\n+        response_header_str = response_header.read()\n+        assert_equal(response_str[0:80], response_header_str)\n+\n+        # check block hex format\n+        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        assert_equal(response_hex.status, 200)\n+        assert_greater_than(int(response_hex.getheader('content-length')), 160)\n+        response_hex_str = response_hex.read()\n+        assert_equal(response_str.encode(\"hex\")[0:160], response_hex_str[0:160])\n+\n+        # compare with hex block header\n+        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        assert_equal(response_header_hex.status, 200)\n+        assert_greater_than(int(response_header_hex.getheader('content-length')), 160)\n+        response_header_hex_str = response_header_hex.read()\n+        assert_equal(response_hex_str[0:160], response_header_hex_str[0:160])\n+        assert_equal(response_header_str.encode(\"hex\")[0:160], response_header_hex_str[0:160])\n+\n         # check json format\n         json_string = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n         assert_equal(json_obj['hash'], bb_hash)\n-        \n+\n         # do tx test\n         tx_hash = json_obj['tx'][0]['txid'];\n         json_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"json\")\n         json_obj = json.loads(json_string)\n         assert_equal(json_obj['txid'], tx_hash)\n-        \n+\n         # check hex format response\n         hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n         assert_equal(response.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 10)\n-        \n+\n         # check block tx details\n         # let's make 3 tx and mine them on node 1\n         txs = []\n         txs.append(self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 11))\n         txs.append(self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 11))\n         txs.append(self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 11))\n         self.sync_all()\n-        \n+\n         # now mine the transactions\n         newblockhash = self.nodes[1].setgenerate(True, 1)\n         self.sync_all()\n-        \n+\n         #check if the 3 tx show up in the new block\n         json_string = http_get_call(url.hostname, url.port, '/rest/block/'+newblockhash[0]+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n         for tx in json_obj['tx']:\n             if not 'coinbase' in tx['vin'][0]: #exclude coinbase\n                 assert_equal(tx['txid'] in txs, True)\n-        \n+\n         #check the same but without tx details\n         json_string = http_get_call(url.hostname, url.port, '/rest/block/notxdetails/'+newblockhash[0]+self.FORMAT_SEPARATOR+'json')\n         json_obj = json.loads(json_string)\n         for tx in txs:\n             assert_equal(tx in json_obj['tx'], True)\n-                \n-        \n \n if __name__ == '__main__':\n     RESTTest ().main ()"
      },
      {
        "sha": "c52dbb3cd24cb858c0f6a4ee609b0e535ffaa47d",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f676c80f437e15ab0ee190e93baea733a88db0f2/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f676c80f437e15ab0ee190e93baea733a88db0f2/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=f676c80f437e15ab0ee190e93baea733a88db0f2",
        "patch": "@@ -89,6 +89,69 @@ static bool ParseHashStr(const string& strReq, uint256& v)\n     return true;\n }\n \n+static bool rest_headers(AcceptedConnection* conn,\n+                         string& strReq,\n+                         map<string, string>& mapHeaders,\n+                         bool fRun)\n+{\n+    vector<string> params;\n+    enum RetFormat rf = ParseDataFormat(params, strReq);\n+    vector<string> path;\n+    boost::split(path, params[0], boost::is_any_of(\"/\"));\n+\n+    if (path.size() != 2)\n+        throw RESTERR(HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\n+\n+    long count = strtol(path[0].c_str(), NULL, 10);\n+    if (count < 1 || count > 2000)\n+        throw RESTERR(HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n+\n+    string hashStr = path[1];\n+    uint256 hash;\n+    if (!ParseHashStr(hashStr, hash))\n+        throw RESTERR(HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n+\n+    std::vector<CBlockHeader> headers;\n+    headers.reserve(count);\n+    {\n+        LOCK(cs_main);\n+        BlockMap::const_iterator it = mapBlockIndex.find(hash);\n+        const CBlockIndex *pindex = (it != mapBlockIndex.end()) ? it->second : NULL;\n+        while (pindex != NULL && chainActive.Contains(pindex)) {\n+            headers.push_back(pindex->GetBlockHeader());\n+            if (headers.size() == (unsigned long)count)\n+                break;\n+            pindex = chainActive.Next(pindex);\n+        }\n+    }\n+\n+    CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);\n+    BOOST_FOREACH(const CBlockHeader &header, headers) {\n+        ssHeader << header;\n+    }\n+\n+    switch (rf) {\n+    case RF_BINARY: {\n+        string binaryHeader = ssHeader.str();\n+        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, binaryHeader.size(), \"application/octet-stream\") << binaryHeader << std::flush;\n+        return true;\n+    }\n+\n+    case RF_HEX: {\n+        string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n+        conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n+        return true;\n+    }\n+\n+    default: {\n+        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: .bin, .hex)\");\n+    }\n+    }\n+\n+    // not reached\n+    return true; // continue to process further HTTP reqs on this cxn\n+}\n+\n static bool rest_block(AcceptedConnection* conn,\n                        string& strReq,\n                        map<string, string>& mapHeaders,\n@@ -224,6 +287,7 @@ static const struct {\n       {\"/rest/tx/\", rest_tx},\n       {\"/rest/block/notxdetails/\", rest_block_notxdetails},\n       {\"/rest/block/\", rest_block_extended},\n+      {\"/rest/headers/\", rest_headers},\n };\n \n bool HTTPReq_REST(AcceptedConnection* conn,"
      }
    ]
  }
]