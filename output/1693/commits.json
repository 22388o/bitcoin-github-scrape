[
  {
    "sha": "e3bc56986508b40f894c7c707d39ea1bb437ebb5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2JjNTY5ODY1MDhiNDBmODk0YzdjNzA3ZDM5ZWExYmI0MzdlYmI1",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@exmulti.com",
        "date": "2012-08-21T14:38:57Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@redhat.com",
        "date": "2012-08-21T14:38:57Z"
      },
      "message": "RPC, cosmetic: move wallet-related RPCs to new rpcwallet.cpp module",
      "tree": {
        "sha": "e157830e4256453c4c7ef84faf56511de42f4de8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e157830e4256453c4c7ef84faf56511de42f4de8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3bc56986508b40f894c7c707d39ea1bb437ebb5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3bc56986508b40f894c7c707d39ea1bb437ebb5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3bc56986508b40f894c7c707d39ea1bb437ebb5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3bc56986508b40f894c7c707d39ea1bb437ebb5/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "a483c27704fb22ddd3dce50db69cfca110d23b0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a483c27704fb22ddd3dce50db69cfca110d23b0f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a483c27704fb22ddd3dce50db69cfca110d23b0f"
      }
    ],
    "stats": {
      "total": 2926,
      "additions": 1489,
      "deletions": 1437
    },
    "files": [
      {
        "sha": "2770f66509c2514a08fdcbb809dbf9a8dc9f809d",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -210,6 +210,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/rpcdump.cpp \\\n     src/rpcnet.cpp \\\n     src/rpcmining.cpp \\\n+    src/rpcwallet.cpp \\\n     src/rpcrawtransaction.cpp \\\n     src/qt/overviewpage.cpp \\\n     src/qt/csvmodelwriter.cpp \\"
      },
      {
        "sha": "903d66e33e4685e202760c1331acf795b1455357",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1437,
        "changes": 1439,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -4,10 +4,10 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"main.h\"\n-#include \"wallet.h\"\n-#include \"walletdb.h\"\n #include \"net.h\"\n #include \"init.h\"\n+#include \"util.h\"\n+#include \"sync.h\"\n #include \"ui_interface.h\"\n #include \"base58.h\"\n #include \"bitcoinrpc.h\"\n@@ -38,29 +38,6 @@ void ThreadRPCServer2(void* parg);\n \n static std::string strRPCUserColonPass;\n \n-static int64 nWalletUnlockTime;\n-static CCriticalSection cs_nWalletUnlockTime;\n-\n-extern Value getconnectioncount(const Array& params, bool fHelp); // in rpcnet.cpp\n-extern Value getpeerinfo(const Array& params, bool fHelp);\n-extern Value dumpprivkey(const Array& params, bool fHelp); // in rpcdump.cpp\n-extern Value importprivkey(const Array& params, bool fHelp);\n-\n-extern Value getgenerate(const Array& params, bool fHelp); // in rpcmining.cpp\n-extern Value setgenerate(const Array& params, bool fHelp);\n-extern Value gethashespersec(const Array& params, bool fHelp);\n-extern Value getmininginfo(const Array& params, bool fHelp);\n-extern Value getwork(const Array& params, bool fHelp);\n-extern Value getblocktemplate(const Array& params, bool fHelp);\n-extern Value submitblock(const Array& params, bool fHelp);\n-\n-extern Value getrawtransaction(const Array& params, bool fHelp); // in rcprawtransaction.cpp\n-extern Value listunspent(const Array& params, bool fHelp);\n-extern Value createrawtransaction(const Array& params, bool fHelp);\n-extern Value decoderawtransaction(const Array& params, bool fHelp);\n-extern Value signrawtransaction(const Array& params, bool fHelp);\n-extern Value sendrawtransaction(const Array& params, bool fHelp);\n-\n const Object emptyobj;\n \n void ThreadRPCServer3(void* parg);\n@@ -169,44 +146,6 @@ HexBits(unsigned int nBits)\n     return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n }\n \n-std::string\n-HelpRequiringPassphrase()\n-{\n-    return pwalletMain->IsCrypted()\n-        ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\"\n-        : \"\";\n-}\n-\n-void\n-EnsureWalletIsUnlocked()\n-{\n-    if (pwalletMain->IsLocked())\n-        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n-}\n-\n-void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n-{\n-    int confirms = wtx.GetDepthInMainChain();\n-    entry.push_back(Pair(\"confirmations\", confirms));\n-    if (confirms)\n-    {\n-        entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n-        entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n-    }\n-    entry.push_back(Pair(\"txid\", wtx.GetHash().GetHex()));\n-    entry.push_back(Pair(\"time\", (boost::int64_t)wtx.GetTxTime()));\n-    BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n-        entry.push_back(Pair(item.first, item.second));\n-}\n-\n-string AccountFromValue(const Value& value)\n-{\n-    string strAccount = value.get_str();\n-    if (strAccount == \"*\")\n-        throw JSONRPCError(-11, \"Invalid account name\");\n-    return strAccount;\n-}\n-\n Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n {\n     Object result;\n@@ -356,162 +295,6 @@ Value getinfo(const Array& params, bool fHelp)\n }\n \n \n-Value getnewaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 1)\n-        throw runtime_error(\n-            \"getnewaddress [account]\\n\"\n-            \"Returns a new Bitcoin address for receiving payments.  \"\n-            \"If [account] is specified (recommended), it is added to the address book \"\n-            \"so payments received with the address will be credited to [account].\");\n-\n-    // Parse the account first so we don't generate a key if there's an error\n-    string strAccount;\n-    if (params.size() > 0)\n-        strAccount = AccountFromValue(params[0]);\n-\n-    if (!pwalletMain->IsLocked())\n-        pwalletMain->TopUpKeyPool();\n-\n-    // Generate a new key that is added to wallet\n-    CPubKey newKey;\n-    if (!pwalletMain->GetKeyFromPool(newKey, false))\n-        throw JSONRPCError(-12, \"Error: Keypool ran out, please call keypoolrefill first\");\n-    CKeyID keyID = newKey.GetID();\n-\n-    pwalletMain->SetAddressBookName(keyID, strAccount);\n-\n-    return CBitcoinAddress(keyID).ToString();\n-}\n-\n-\n-CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n-{\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-\n-    CAccount account;\n-    walletdb.ReadAccount(strAccount, account);\n-\n-    bool bKeyUsed = false;\n-\n-    // Check if the current key has been used\n-    if (account.vchPubKey.IsValid())\n-    {\n-        CScript scriptPubKey;\n-        scriptPubKey.SetDestination(account.vchPubKey.GetID());\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n-             it != pwalletMain->mapWallet.end() && account.vchPubKey.IsValid();\n-             ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-                if (txout.scriptPubKey == scriptPubKey)\n-                    bKeyUsed = true;\n-        }\n-    }\n-\n-    // Generate a new key\n-    if (!account.vchPubKey.IsValid() || bForceNew || bKeyUsed)\n-    {\n-        if (!pwalletMain->GetKeyFromPool(account.vchPubKey, false))\n-            throw JSONRPCError(-12, \"Error: Keypool ran out, please call keypoolrefill first\");\n-\n-        pwalletMain->SetAddressBookName(account.vchPubKey.GetID(), strAccount);\n-        walletdb.WriteAccount(strAccount, account);\n-    }\n-\n-    return CBitcoinAddress(account.vchPubKey.GetID());\n-}\n-\n-Value getaccountaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaccountaddress <account>\\n\"\n-            \"Returns the current Bitcoin address for receiving payments to this account.\");\n-\n-    // Parse the account first so we don't generate a key if there's an error\n-    string strAccount = AccountFromValue(params[0]);\n-\n-    Value ret;\n-\n-    ret = GetAccountAddress(strAccount).ToString();\n-\n-    return ret;\n-}\n-\n-\n-\n-Value setaccount(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 1 || params.size() > 2)\n-        throw runtime_error(\n-            \"setaccount <bitcoinaddress> <account>\\n\"\n-            \"Sets the account associated with the given address.\");\n-\n-    CBitcoinAddress address(params[0].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n-\n-\n-    string strAccount;\n-    if (params.size() > 1)\n-        strAccount = AccountFromValue(params[1]);\n-\n-    // Detect when changing the account of an address that is the 'unused current key' of another account:\n-    if (pwalletMain->mapAddressBook.count(address.Get()))\n-    {\n-        string strOldAccount = pwalletMain->mapAddressBook[address.Get()];\n-        if (address == GetAccountAddress(strOldAccount))\n-            GetAccountAddress(strOldAccount, true);\n-    }\n-\n-    pwalletMain->SetAddressBookName(address.Get(), strAccount);\n-\n-    return Value::null;\n-}\n-\n-\n-Value getaccount(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaccount <bitcoinaddress>\\n\"\n-            \"Returns the account associated with the given address.\");\n-\n-    CBitcoinAddress address(params[0].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n-\n-    string strAccount;\n-    map<CTxDestination, string>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n-    if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.empty())\n-        strAccount = (*mi).second;\n-    return strAccount;\n-}\n-\n-\n-Value getaddressesbyaccount(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaddressesbyaccount <account>\\n\"\n-            \"Returns the list of addresses for the given account.\");\n-\n-    string strAccount = AccountFromValue(params[0]);\n-\n-    // Find all addresses that have the given account\n-    Array ret;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n-    {\n-        const CBitcoinAddress& address = item.first;\n-        const string& strName = item.second;\n-        if (strName == strAccount)\n-            ret.push_back(address.ToString());\n-    }\n-    return ret;\n-}\n-\n Value settxfee(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 1)\n@@ -528,1224 +311,6 @@ Value settxfee(const Array& params, bool fHelp)\n     return true;\n }\n \n-Value sendtoaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 2 || params.size() > 4)\n-        throw runtime_error(\n-            \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\"\n-            + HelpRequiringPassphrase());\n-\n-    CBitcoinAddress address(params[0].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n-\n-    // Amount\n-    int64 nAmount = AmountFromValue(params[1]);\n-\n-    // Wallet comments\n-    CWalletTx wtx;\n-    if (params.size() > 2 && params[2].type() != null_type && !params[2].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[2].get_str();\n-    if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[3].get_str();\n-\n-    if (pwalletMain->IsLocked())\n-        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n-\n-    string strError = pwalletMain->SendMoneyToDestination(address.Get(), nAmount, wtx);\n-    if (strError != \"\")\n-        throw JSONRPCError(-4, strError);\n-\n-    return wtx.GetHash().GetHex();\n-}\n-\n-Value signmessage(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 2)\n-        throw runtime_error(\n-            \"signmessage <bitcoinaddress> <message>\\n\"\n-            \"Sign a message with the private key of an address\");\n-\n-    EnsureWalletIsUnlocked();\n-\n-    string strAddress = params[0].get_str();\n-    string strMessage = params[1].get_str();\n-\n-    CBitcoinAddress addr(strAddress);\n-    if (!addr.IsValid())\n-        throw JSONRPCError(-3, \"Invalid address\");\n-\n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n-        throw JSONRPCError(-3, \"Address does not refer to key\");\n-\n-    CKey key;\n-    if (!pwalletMain->GetKey(keyID, key))\n-        throw JSONRPCError(-4, \"Private key not available\");\n-\n-    CDataStream ss(SER_GETHASH, 0);\n-    ss << strMessageMagic;\n-    ss << strMessage;\n-\n-    vector<unsigned char> vchSig;\n-    if (!key.SignCompact(Hash(ss.begin(), ss.end()), vchSig))\n-        throw JSONRPCError(-5, \"Sign failed\");\n-\n-    return EncodeBase64(&vchSig[0], vchSig.size());\n-}\n-\n-Value verifymessage(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 3)\n-        throw runtime_error(\n-            \"verifymessage <bitcoinaddress> <signature> <message>\\n\"\n-            \"Verify a signed message\");\n-\n-    string strAddress  = params[0].get_str();\n-    string strSign     = params[1].get_str();\n-    string strMessage  = params[2].get_str();\n-\n-    CBitcoinAddress addr(strAddress);\n-    if (!addr.IsValid())\n-        throw JSONRPCError(-3, \"Invalid address\");\n-\n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n-        throw JSONRPCError(-3, \"Address does not refer to key\");\n-\n-    bool fInvalid = false;\n-    vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n-\n-    if (fInvalid)\n-        throw JSONRPCError(-5, \"Malformed base64 encoding\");\n-\n-    CDataStream ss(SER_GETHASH, 0);\n-    ss << strMessageMagic;\n-    ss << strMessage;\n-\n-    CKey key;\n-    if (!key.SetCompactSignature(Hash(ss.begin(), ss.end()), vchSig))\n-        return false;\n-\n-    return (key.GetPubKey().GetID() == keyID);\n-}\n-\n-\n-Value getreceivedbyaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 1 || params.size() > 2)\n-        throw runtime_error(\n-            \"getreceivedbyaddress <bitcoinaddress> [minconf=1]\\n\"\n-            \"Returns the total amount received by <bitcoinaddress> in transactions with at least [minconf] confirmations.\");\n-\n-    // Bitcoin address\n-    CBitcoinAddress address = CBitcoinAddress(params[0].get_str());\n-    CScript scriptPubKey;\n-    if (!address.IsValid())\n-        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n-    scriptPubKey.SetDestination(address.Get());\n-    if (!IsMine(*pwalletMain,scriptPubKey))\n-        return (double)0.0;\n-\n-    // Minimum confirmations\n-    int nMinDepth = 1;\n-    if (params.size() > 1)\n-        nMinDepth = params[1].get_int();\n-\n-    // Tally\n-    int64 nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        if (wtx.IsCoinBase() || !wtx.IsFinal())\n-            continue;\n-\n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            if (txout.scriptPubKey == scriptPubKey)\n-                if (wtx.GetDepthInMainChain() >= nMinDepth)\n-                    nAmount += txout.nValue;\n-    }\n-\n-    return  ValueFromAmount(nAmount);\n-}\n-\n-\n-void GetAccountAddresses(string strAccount, set<CTxDestination>& setAddress)\n-{\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)& item, pwalletMain->mapAddressBook)\n-    {\n-        const CTxDestination& address = item.first;\n-        const string& strName = item.second;\n-        if (strName == strAccount)\n-            setAddress.insert(address);\n-    }\n-}\n-\n-Value getreceivedbyaccount(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 1 || params.size() > 2)\n-        throw runtime_error(\n-            \"getreceivedbyaccount <account> [minconf=1]\\n\"\n-            \"Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\");\n-\n-    // Minimum confirmations\n-    int nMinDepth = 1;\n-    if (params.size() > 1)\n-        nMinDepth = params[1].get_int();\n-\n-    // Get the set of pub keys assigned to account\n-    string strAccount = AccountFromValue(params[0]);\n-    set<CTxDestination> setAddress;\n-    GetAccountAddresses(strAccount, setAddress);\n-\n-    // Tally\n-    int64 nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        if (wtx.IsCoinBase() || !wtx.IsFinal())\n-            continue;\n-\n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-        {\n-            CTxDestination address;\n-            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwalletMain, address) && setAddress.count(address))\n-                if (wtx.GetDepthInMainChain() >= nMinDepth)\n-                    nAmount += txout.nValue;\n-        }\n-    }\n-\n-    return (double)nAmount / (double)COIN;\n-}\n-\n-\n-int64 GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n-{\n-    int64 nBalance = 0;\n-\n-    // Tally wallet transactions\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        if (!wtx.IsFinal())\n-            continue;\n-\n-        int64 nGenerated, nReceived, nSent, nFee;\n-        wtx.GetAccountAmounts(strAccount, nGenerated, nReceived, nSent, nFee);\n-\n-        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-            nBalance += nReceived;\n-        nBalance += nGenerated - nSent - nFee;\n-    }\n-\n-    // Tally internal accounting entries\n-    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n-\n-    return nBalance;\n-}\n-\n-int64 GetAccountBalance(const string& strAccount, int nMinDepth)\n-{\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-    return GetAccountBalance(walletdb, strAccount, nMinDepth);\n-}\n-\n-\n-Value getbalance(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 2)\n-        throw runtime_error(\n-            \"getbalance [account] [minconf=1]\\n\"\n-            \"If [account] is not specified, returns the server's total available balance.\\n\"\n-            \"If [account] is specified, returns the balance in the account.\");\n-\n-    if (params.size() == 0)\n-        return  ValueFromAmount(pwalletMain->GetBalance());\n-\n-    int nMinDepth = 1;\n-    if (params.size() > 1)\n-        nMinDepth = params[1].get_int();\n-\n-    if (params[0].get_str() == \"*\") {\n-        // Calculate total balance a different way from GetBalance()\n-        // (GetBalance() sums up all unspent TxOuts)\n-        // getbalance and getbalance '*' should always return the same number.\n-        int64 nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-        {\n-            const CWalletTx& wtx = (*it).second;\n-            if (!wtx.IsFinal())\n-                continue;\n-\n-            int64 allGeneratedImmature, allGeneratedMature, allFee;\n-            allGeneratedImmature = allGeneratedMature = allFee = 0;\n-            string strSentAccount;\n-            list<pair<CTxDestination, int64> > listReceived;\n-            list<pair<CTxDestination, int64> > listSent;\n-            wtx.GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n-            if (wtx.GetDepthInMainChain() >= nMinDepth)\n-            {\n-                BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& r, listReceived)\n-                    nBalance += r.second;\n-            }\n-            BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& r, listSent)\n-                nBalance -= r.second;\n-            nBalance -= allFee;\n-            nBalance += allGeneratedMature;\n-        }\n-        return  ValueFromAmount(nBalance);\n-    }\n-\n-    string strAccount = AccountFromValue(params[0]);\n-\n-    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-\n-    return ValueFromAmount(nBalance);\n-}\n-\n-\n-Value movecmd(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 3 || params.size() > 5)\n-        throw runtime_error(\n-            \"move <fromaccount> <toaccount> <amount> [minconf=1] [comment]\\n\"\n-            \"Move from one account in your wallet to another.\");\n-\n-    string strFrom = AccountFromValue(params[0]);\n-    string strTo = AccountFromValue(params[1]);\n-    int64 nAmount = AmountFromValue(params[2]);\n-    if (params.size() > 3)\n-        // unused parameter, used to be nMinDepth, keep type-checking it though\n-        (void)params[3].get_int();\n-    string strComment;\n-    if (params.size() > 4)\n-        strComment = params[4].get_str();\n-\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-    if (!walletdb.TxnBegin())\n-        throw JSONRPCError(-20, \"database error\");\n-\n-    int64 nNow = GetAdjustedTime();\n-\n-    // Debit\n-    CAccountingEntry debit;\n-    debit.strAccount = strFrom;\n-    debit.nCreditDebit = -nAmount;\n-    debit.nTime = nNow;\n-    debit.strOtherAccount = strTo;\n-    debit.strComment = strComment;\n-    walletdb.WriteAccountingEntry(debit);\n-\n-    // Credit\n-    CAccountingEntry credit;\n-    credit.strAccount = strTo;\n-    credit.nCreditDebit = nAmount;\n-    credit.nTime = nNow;\n-    credit.strOtherAccount = strFrom;\n-    credit.strComment = strComment;\n-    walletdb.WriteAccountingEntry(credit);\n-\n-    if (!walletdb.TxnCommit())\n-        throw JSONRPCError(-20, \"database error\");\n-\n-    return true;\n-}\n-\n-\n-Value sendfrom(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 3 || params.size() > 6)\n-        throw runtime_error(\n-            \"sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\"\n-            + HelpRequiringPassphrase());\n-\n-    string strAccount = AccountFromValue(params[0]);\n-    CBitcoinAddress address(params[1].get_str());\n-    if (!address.IsValid())\n-        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n-    int64 nAmount = AmountFromValue(params[2]);\n-    int nMinDepth = 1;\n-    if (params.size() > 3)\n-        nMinDepth = params[3].get_int();\n-\n-    CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n-    if (params.size() > 4 && params[4].type() != null_type && !params[4].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[4].get_str();\n-    if (params.size() > 5 && params[5].type() != null_type && !params[5].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[5].get_str();\n-\n-    EnsureWalletIsUnlocked();\n-\n-    // Check funds\n-    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-    if (nAmount > nBalance)\n-        throw JSONRPCError(-6, \"Account has insufficient funds\");\n-\n-    // Send\n-    string strError = pwalletMain->SendMoneyToDestination(address.Get(), nAmount, wtx);\n-    if (strError != \"\")\n-        throw JSONRPCError(-4, strError);\n-\n-    return wtx.GetHash().GetHex();\n-}\n-\n-\n-Value sendmany(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 2 || params.size() > 4)\n-        throw runtime_error(\n-            \"sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]\\n\"\n-            \"amounts are double-precision floating point numbers\"\n-            + HelpRequiringPassphrase());\n-\n-    string strAccount = AccountFromValue(params[0]);\n-    Object sendTo = params[1].get_obj();\n-    int nMinDepth = 1;\n-    if (params.size() > 2)\n-        nMinDepth = params[2].get_int();\n-\n-    CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n-    if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[3].get_str();\n-\n-    set<CBitcoinAddress> setAddress;\n-    vector<pair<CScript, int64> > vecSend;\n-\n-    int64 totalAmount = 0;\n-    BOOST_FOREACH(const Pair& s, sendTo)\n-    {\n-        CBitcoinAddress address(s.name_);\n-        if (!address.IsValid())\n-            throw JSONRPCError(-5, string(\"Invalid Bitcoin address:\")+s.name_);\n-\n-        if (setAddress.count(address))\n-            throw JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+s.name_);\n-        setAddress.insert(address);\n-\n-        CScript scriptPubKey;\n-        scriptPubKey.SetDestination(address.Get());\n-        int64 nAmount = AmountFromValue(s.value_);\n-        totalAmount += nAmount;\n-\n-        vecSend.push_back(make_pair(scriptPubKey, nAmount));\n-    }\n-\n-    EnsureWalletIsUnlocked();\n-\n-    // Check funds\n-    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-    if (totalAmount > nBalance)\n-        throw JSONRPCError(-6, \"Account has insufficient funds\");\n-\n-    // Send\n-    CReserveKey keyChange(pwalletMain);\n-    int64 nFeeRequired = 0;\n-    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n-    if (!fCreated)\n-    {\n-        if (totalAmount + nFeeRequired > pwalletMain->GetBalance())\n-            throw JSONRPCError(-6, \"Insufficient funds\");\n-        throw JSONRPCError(-4, \"Transaction creation failed\");\n-    }\n-    if (!pwalletMain->CommitTransaction(wtx, keyChange))\n-        throw JSONRPCError(-4, \"Transaction commit failed\");\n-\n-    return wtx.GetHash().GetHex();\n-}\n-\n-Value addmultisigaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 2 || params.size() > 3)\n-    {\n-        string msg = \"addmultisigaddress <nrequired> <'[\\\"key\\\",\\\"key\\\"]'> [account]\\n\"\n-            \"Add a nrequired-to-sign multisignature address to the wallet\\\"\\n\"\n-            \"each key is a Bitcoin address or hex-encoded public key\\n\"\n-            \"If [account] is specified, assign address to [account].\";\n-        throw runtime_error(msg);\n-    }\n-\n-    int nRequired = params[0].get_int();\n-    const Array& keys = params[1].get_array();\n-    string strAccount;\n-    if (params.size() > 2)\n-        strAccount = AccountFromValue(params[2]);\n-\n-    // Gather public keys\n-    if (nRequired < 1)\n-        throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n-    if ((int)keys.size() < nRequired)\n-        throw runtime_error(\n-            strprintf(\"not enough keys supplied \"\n-                      \"(got %d keys, but need at least %d to redeem)\", keys.size(), nRequired));\n-    std::vector<CKey> pubkeys;\n-    pubkeys.resize(keys.size());\n-    for (unsigned int i = 0; i < keys.size(); i++)\n-    {\n-        const std::string& ks = keys[i].get_str();\n-\n-        // Case 1: Bitcoin address and we have full public key:\n-        CBitcoinAddress address(ks);\n-        if (address.IsValid())\n-        {\n-            CKeyID keyID;\n-            if (!address.GetKeyID(keyID))\n-                throw runtime_error(\n-                    strprintf(\"%s does not refer to a key\",ks.c_str()));\n-            CPubKey vchPubKey;\n-            if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n-                throw runtime_error(\n-                    strprintf(\"no full public key for address %s\",ks.c_str()));\n-            if (!vchPubKey.IsValid() || !pubkeys[i].SetPubKey(vchPubKey))\n-                throw runtime_error(\" Invalid public key: \"+ks);\n-        }\n-\n-        // Case 2: hex public key\n-        else if (IsHex(ks))\n-        {\n-            CPubKey vchPubKey(ParseHex(ks));\n-            if (!vchPubKey.IsValid() || !pubkeys[i].SetPubKey(vchPubKey))\n-                throw runtime_error(\" Invalid public key: \"+ks);\n-        }\n-        else\n-        {\n-            throw runtime_error(\" Invalid public key: \"+ks);\n-        }\n-    }\n-\n-    // Construct using pay-to-script-hash:\n-    CScript inner;\n-    inner.SetMultisig(nRequired, pubkeys);\n-    CScriptID innerID = inner.GetID();\n-    pwalletMain->AddCScript(inner);\n-\n-    pwalletMain->SetAddressBookName(innerID, strAccount);\n-    return CBitcoinAddress(innerID).ToString();\n-}\n-\n-\n-struct tallyitem\n-{\n-    int64 nAmount;\n-    int nConf;\n-    tallyitem()\n-    {\n-        nAmount = 0;\n-        nConf = std::numeric_limits<int>::max();\n-    }\n-};\n-\n-Value ListReceived(const Array& params, bool fByAccounts)\n-{\n-    // Minimum confirmations\n-    int nMinDepth = 1;\n-    if (params.size() > 0)\n-        nMinDepth = params[0].get_int();\n-\n-    // Whether to include empty accounts\n-    bool fIncludeEmpty = false;\n-    if (params.size() > 1)\n-        fIncludeEmpty = params[1].get_bool();\n-\n-    // Tally\n-    map<CBitcoinAddress, tallyitem> mapTally;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-\n-        if (wtx.IsCoinBase() || !wtx.IsFinal())\n-            continue;\n-\n-        int nDepth = wtx.GetDepthInMainChain();\n-        if (nDepth < nMinDepth)\n-            continue;\n-\n-        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-        {\n-            CTxDestination address;\n-            if (!ExtractDestination(txout.scriptPubKey, address) || !IsMine(*pwalletMain, address))\n-                continue;\n-\n-            tallyitem& item = mapTally[address];\n-            item.nAmount += txout.nValue;\n-            item.nConf = min(item.nConf, nDepth);\n-        }\n-    }\n-\n-    // Reply\n-    Array ret;\n-    map<string, tallyitem> mapAccountTally;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n-    {\n-        const CBitcoinAddress& address = item.first;\n-        const string& strAccount = item.second;\n-        map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n-        if (it == mapTally.end() && !fIncludeEmpty)\n-            continue;\n-\n-        int64 nAmount = 0;\n-        int nConf = std::numeric_limits<int>::max();\n-        if (it != mapTally.end())\n-        {\n-            nAmount = (*it).second.nAmount;\n-            nConf = (*it).second.nConf;\n-        }\n-\n-        if (fByAccounts)\n-        {\n-            tallyitem& item = mapAccountTally[strAccount];\n-            item.nAmount += nAmount;\n-            item.nConf = min(item.nConf, nConf);\n-        }\n-        else\n-        {\n-            Object obj;\n-            obj.push_back(Pair(\"address\",       address.ToString()));\n-            obj.push_back(Pair(\"account\",       strAccount));\n-            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n-            ret.push_back(obj);\n-        }\n-    }\n-\n-    if (fByAccounts)\n-    {\n-        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n-        {\n-            int64 nAmount = (*it).second.nAmount;\n-            int nConf = (*it).second.nConf;\n-            Object obj;\n-            obj.push_back(Pair(\"account\",       (*it).first));\n-            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n-            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n-            ret.push_back(obj);\n-        }\n-    }\n-\n-    return ret;\n-}\n-\n-Value listreceivedbyaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 2)\n-        throw runtime_error(\n-            \"listreceivedbyaddress [minconf=1] [includeempty=false]\\n\"\n-            \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n-            \"[includeempty] whether to include addresses that haven't received any payments.\\n\"\n-            \"Returns an array of objects containing:\\n\"\n-            \"  \\\"address\\\" : receiving address\\n\"\n-            \"  \\\"account\\\" : the account of the receiving address\\n\"\n-            \"  \\\"amount\\\" : total amount received by the address\\n\"\n-            \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n-\n-    return ListReceived(params, false);\n-}\n-\n-Value listreceivedbyaccount(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 2)\n-        throw runtime_error(\n-            \"listreceivedbyaccount [minconf=1] [includeempty=false]\\n\"\n-            \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n-            \"[includeempty] whether to include accounts that haven't received any payments.\\n\"\n-            \"Returns an array of objects containing:\\n\"\n-            \"  \\\"account\\\" : the account of the receiving addresses\\n\"\n-            \"  \\\"amount\\\" : total amount received by addresses with this account\\n\"\n-            \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n-\n-    return ListReceived(params, true);\n-}\n-\n-void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, Array& ret)\n-{\n-    int64 nGeneratedImmature, nGeneratedMature, nFee;\n-    string strSentAccount;\n-    list<pair<CTxDestination, int64> > listReceived;\n-    list<pair<CTxDestination, int64> > listSent;\n-\n-    wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n-\n-    bool fAllAccounts = (strAccount == string(\"*\"));\n-\n-    // Generated blocks assigned to account \"\"\n-    if ((nGeneratedMature+nGeneratedImmature) != 0 && (fAllAccounts || strAccount == \"\"))\n-    {\n-        Object entry;\n-        entry.push_back(Pair(\"account\", string(\"\")));\n-        if (nGeneratedImmature)\n-        {\n-            entry.push_back(Pair(\"category\", wtx.GetDepthInMainChain() ? \"immature\" : \"orphan\"));\n-            entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedImmature)));\n-        }\n-        else\n-        {\n-            entry.push_back(Pair(\"category\", \"generate\"));\n-            entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedMature)));\n-        }\n-        if (fLong)\n-            WalletTxToJSON(wtx, entry);\n-        ret.push_back(entry);\n-    }\n-\n-    // Sent\n-    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n-    {\n-        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& s, listSent)\n-        {\n-            Object entry;\n-            entry.push_back(Pair(\"account\", strSentAccount));\n-            entry.push_back(Pair(\"address\", CBitcoinAddress(s.first).ToString()));\n-            entry.push_back(Pair(\"category\", \"send\"));\n-            entry.push_back(Pair(\"amount\", ValueFromAmount(-s.second)));\n-            entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n-            if (fLong)\n-                WalletTxToJSON(wtx, entry);\n-            ret.push_back(entry);\n-        }\n-    }\n-\n-    // Received\n-    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n-    {\n-        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& r, listReceived)\n-        {\n-            string account;\n-            if (pwalletMain->mapAddressBook.count(r.first))\n-                account = pwalletMain->mapAddressBook[r.first];\n-            if (fAllAccounts || (account == strAccount))\n-            {\n-                Object entry;\n-                entry.push_back(Pair(\"account\", account));\n-                entry.push_back(Pair(\"address\", CBitcoinAddress(r.first).ToString()));\n-                entry.push_back(Pair(\"category\", \"receive\"));\n-                entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n-                if (fLong)\n-                    WalletTxToJSON(wtx, entry);\n-                ret.push_back(entry);\n-            }\n-        }\n-    }\n-}\n-\n-void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, Array& ret)\n-{\n-    bool fAllAccounts = (strAccount == string(\"*\"));\n-\n-    if (fAllAccounts || acentry.strAccount == strAccount)\n-    {\n-        Object entry;\n-        entry.push_back(Pair(\"account\", acentry.strAccount));\n-        entry.push_back(Pair(\"category\", \"move\"));\n-        entry.push_back(Pair(\"time\", (boost::int64_t)acentry.nTime));\n-        entry.push_back(Pair(\"amount\", ValueFromAmount(acentry.nCreditDebit)));\n-        entry.push_back(Pair(\"otheraccount\", acentry.strOtherAccount));\n-        entry.push_back(Pair(\"comment\", acentry.strComment));\n-        ret.push_back(entry);\n-    }\n-}\n-\n-Value listtransactions(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 3)\n-        throw runtime_error(\n-            \"listtransactions [account] [count=10] [from=0]\\n\"\n-            \"Returns up to [count] most recent transactions skipping the first [from] transactions for account [account].\");\n-\n-    string strAccount = \"*\";\n-    if (params.size() > 0)\n-        strAccount = params[0].get_str();\n-    int nCount = 10;\n-    if (params.size() > 1)\n-        nCount = params[1].get_int();\n-    int nFrom = 0;\n-    if (params.size() > 2)\n-        nFrom = params[2].get_int();\n-\n-    if (nCount < 0)\n-        throw JSONRPCError(-8, \"Negative count\");\n-    if (nFrom < 0)\n-        throw JSONRPCError(-8, \"Negative from\");\n-\n-    Array ret;\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-\n-    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n-    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n-    typedef multimap<int64, TxPair > TxItems;\n-    TxItems txByTime;\n-\n-    // Note: maintaining indices in the database of (account,time) --> txid and (account, time) --> acentry\n-    // would make this much faster for applications that do this a lot.\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n-        CWalletTx* wtx = &((*it).second);\n-        txByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n-    }\n-    list<CAccountingEntry> acentries;\n-    walletdb.ListAccountCreditDebit(strAccount, acentries);\n-    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n-    {\n-        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n-    }\n-\n-    // iterate backwards until we have nCount items to return:\n-    for (TxItems::reverse_iterator it = txByTime.rbegin(); it != txByTime.rend(); ++it)\n-    {\n-        CWalletTx *const pwtx = (*it).second.first;\n-        if (pwtx != 0)\n-            ListTransactions(*pwtx, strAccount, 0, true, ret);\n-        CAccountingEntry *const pacentry = (*it).second.second;\n-        if (pacentry != 0)\n-            AcentryToJSON(*pacentry, strAccount, ret);\n-\n-        if ((int)ret.size() >= (nCount+nFrom)) break;\n-    }\n-    // ret is newest to oldest\n-\n-    if (nFrom > (int)ret.size())\n-        nFrom = ret.size();\n-    if ((nFrom + nCount) > (int)ret.size())\n-        nCount = ret.size() - nFrom;\n-    Array::iterator first = ret.begin();\n-    std::advance(first, nFrom);\n-    Array::iterator last = ret.begin();\n-    std::advance(last, nFrom+nCount);\n-\n-    if (last != ret.end()) ret.erase(last, ret.end());\n-    if (first != ret.begin()) ret.erase(ret.begin(), first);\n-\n-    std::reverse(ret.begin(), ret.end()); // Return oldest to newest\n-\n-    return ret;\n-}\n-\n-Value listaccounts(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 1)\n-        throw runtime_error(\n-            \"listaccounts [minconf=1]\\n\"\n-            \"Returns Object that has account names as keys, account balances as values.\");\n-\n-    int nMinDepth = 1;\n-    if (params.size() > 0)\n-        nMinDepth = params[0].get_int();\n-\n-    map<string, int64> mapAccountBalances;\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)& entry, pwalletMain->mapAddressBook) {\n-        if (IsMine(*pwalletMain, entry.first)) // This address belongs to me\n-            mapAccountBalances[entry.second] = 0;\n-    }\n-\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n-    {\n-        const CWalletTx& wtx = (*it).second;\n-        int64 nGeneratedImmature, nGeneratedMature, nFee;\n-        string strSentAccount;\n-        list<pair<CTxDestination, int64> > listReceived;\n-        list<pair<CTxDestination, int64> > listSent;\n-        wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n-        mapAccountBalances[strSentAccount] -= nFee;\n-        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& s, listSent)\n-            mapAccountBalances[strSentAccount] -= s.second;\n-        if (wtx.GetDepthInMainChain() >= nMinDepth)\n-        {\n-            mapAccountBalances[\"\"] += nGeneratedMature;\n-            BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& r, listReceived)\n-                if (pwalletMain->mapAddressBook.count(r.first))\n-                    mapAccountBalances[pwalletMain->mapAddressBook[r.first]] += r.second;\n-                else\n-                    mapAccountBalances[\"\"] += r.second;\n-        }\n-    }\n-\n-    list<CAccountingEntry> acentries;\n-    CWalletDB(pwalletMain->strWalletFile).ListAccountCreditDebit(\"*\", acentries);\n-    BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n-        mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n-\n-    Object ret;\n-    BOOST_FOREACH(const PAIRTYPE(string, int64)& accountBalance, mapAccountBalances) {\n-        ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n-    }\n-    return ret;\n-}\n-\n-Value listsinceblock(const Array& params, bool fHelp)\n-{\n-    if (fHelp)\n-        throw runtime_error(\n-            \"listsinceblock [blockhash] [target-confirmations]\\n\"\n-            \"Get all transactions in blocks since block [blockhash], or all transactions if omitted\");\n-\n-    CBlockIndex *pindex = NULL;\n-    int target_confirms = 1;\n-\n-    if (params.size() > 0)\n-    {\n-        uint256 blockId = 0;\n-\n-        blockId.SetHex(params[0].get_str());\n-        pindex = CBlockLocator(blockId).GetBlockIndex();\n-    }\n-\n-    if (params.size() > 1)\n-    {\n-        target_confirms = params[1].get_int();\n-\n-        if (target_confirms < 1)\n-            throw JSONRPCError(-8, \"Invalid parameter\");\n-    }\n-\n-    int depth = pindex ? (1 + nBestHeight - pindex->nHeight) : -1;\n-\n-    Array transactions;\n-\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n-    {\n-        CWalletTx tx = (*it).second;\n-\n-        if (depth == -1 || tx.GetDepthInMainChain() < depth)\n-            ListTransactions(tx, \"*\", 0, true, transactions);\n-    }\n-\n-    uint256 lastblock;\n-\n-    if (target_confirms == 1)\n-    {\n-        lastblock = hashBestChain;\n-    }\n-    else\n-    {\n-        int target_height = pindexBest->nHeight + 1 - target_confirms;\n-\n-        CBlockIndex *block;\n-        for (block = pindexBest;\n-             block && block->nHeight > target_height;\n-             block = block->pprev)  { }\n-\n-        lastblock = block ? block->GetBlockHash() : 0;\n-    }\n-\n-    Object ret;\n-    ret.push_back(Pair(\"transactions\", transactions));\n-    ret.push_back(Pair(\"lastblock\", lastblock.GetHex()));\n-\n-    return ret;\n-}\n-\n-Value gettransaction(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"gettransaction <txid>\\n\"\n-            \"Get detailed information about in-wallet transaction <txid>\");\n-\n-    uint256 hash;\n-    hash.SetHex(params[0].get_str());\n-\n-    Object entry;\n-    if (!pwalletMain->mapWallet.count(hash))\n-        throw JSONRPCError(-5, \"Invalid or non-wallet transaction id\");\n-    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n-\n-    int64 nCredit = wtx.GetCredit();\n-    int64 nDebit = wtx.GetDebit();\n-    int64 nNet = nCredit - nDebit;\n-    int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n-\n-    entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n-    if (wtx.IsFromMe())\n-        entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n-\n-    WalletTxToJSON(wtx, entry);\n-\n-    Array details;\n-    ListTransactions(wtx, \"*\", 0, false, details);\n-    entry.push_back(Pair(\"details\", details));\n-\n-    return entry;\n-}\n-\n-\n-Value backupwallet(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"backupwallet <destination>\\n\"\n-            \"Safely copies wallet.dat to destination, which can be a directory or a path with filename.\");\n-\n-    string strDest = params[0].get_str();\n-    BackupWallet(*pwalletMain, strDest);\n-\n-    return Value::null;\n-}\n-\n-\n-Value keypoolrefill(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() > 0)\n-        throw runtime_error(\n-            \"keypoolrefill\\n\"\n-            \"Fills the keypool.\"\n-            + HelpRequiringPassphrase());\n-\n-    EnsureWalletIsUnlocked();\n-\n-    pwalletMain->TopUpKeyPool();\n-\n-    if (pwalletMain->GetKeyPoolSize() < GetArg(\"-keypool\", 100))\n-        throw JSONRPCError(-4, \"Error refreshing keypool.\");\n-\n-    return Value::null;\n-}\n-\n-\n-void ThreadTopUpKeyPool(void* parg)\n-{\n-    // Make this thread recognisable as the key-topping-up thread\n-    RenameThread(\"bitcoin-key-top\");\n-\n-    pwalletMain->TopUpKeyPool();\n-}\n-\n-void ThreadCleanWalletPassphrase(void* parg)\n-{\n-    // Make this thread recognisable as the wallet relocking thread\n-    RenameThread(\"bitcoin-lock-wa\");\n-\n-    int64 nMyWakeTime = GetTimeMillis() + *((int64*)parg) * 1000;\n-\n-    ENTER_CRITICAL_SECTION(cs_nWalletUnlockTime);\n-\n-    if (nWalletUnlockTime == 0)\n-    {\n-        nWalletUnlockTime = nMyWakeTime;\n-\n-        do\n-        {\n-            if (nWalletUnlockTime==0)\n-                break;\n-            int64 nToSleep = nWalletUnlockTime - GetTimeMillis();\n-            if (nToSleep <= 0)\n-                break;\n-\n-            LEAVE_CRITICAL_SECTION(cs_nWalletUnlockTime);\n-            Sleep(nToSleep);\n-            ENTER_CRITICAL_SECTION(cs_nWalletUnlockTime);\n-\n-        } while(1);\n-\n-        if (nWalletUnlockTime)\n-        {\n-            nWalletUnlockTime = 0;\n-            pwalletMain->Lock();\n-        }\n-    }\n-    else\n-    {\n-        if (nWalletUnlockTime < nMyWakeTime)\n-            nWalletUnlockTime = nMyWakeTime;\n-    }\n-\n-    LEAVE_CRITICAL_SECTION(cs_nWalletUnlockTime);\n-\n-    delete (int64*)parg;\n-}\n-\n-Value walletpassphrase(const Array& params, bool fHelp)\n-{\n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n-        throw runtime_error(\n-            \"walletpassphrase <passphrase> <timeout>\\n\"\n-            \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n-    if (fHelp)\n-        return true;\n-    if (!pwalletMain->IsCrypted())\n-        throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n-\n-    if (!pwalletMain->IsLocked())\n-        throw JSONRPCError(-17, \"Error: Wallet is already unlocked.\");\n-\n-    // Note that the walletpassphrase is stored in params[0] which is not mlock()ed\n-    SecureString strWalletPass;\n-    strWalletPass.reserve(100);\n-    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n-    // Alternately, find a way to make params[0] mlock()'d to begin with.\n-    strWalletPass = params[0].get_str().c_str();\n-\n-    if (strWalletPass.length() > 0)\n-    {\n-        if (!pwalletMain->Unlock(strWalletPass))\n-            throw JSONRPCError(-14, \"Error: The wallet passphrase entered was incorrect.\");\n-    }\n-    else\n-        throw runtime_error(\n-            \"walletpassphrase <passphrase> <timeout>\\n\"\n-            \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n-\n-    CreateThread(ThreadTopUpKeyPool, NULL);\n-    int64* pnSleepTime = new int64(params[1].get_int64());\n-    CreateThread(ThreadCleanWalletPassphrase, pnSleepTime);\n-\n-    return Value::null;\n-}\n-\n-\n-Value walletpassphrasechange(const Array& params, bool fHelp)\n-{\n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n-        throw runtime_error(\n-            \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n-            \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n-    if (fHelp)\n-        return true;\n-    if (!pwalletMain->IsCrypted())\n-        throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n-\n-    // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n-    // Alternately, find a way to make params[0] mlock()'d to begin with.\n-    SecureString strOldWalletPass;\n-    strOldWalletPass.reserve(100);\n-    strOldWalletPass = params[0].get_str().c_str();\n-\n-    SecureString strNewWalletPass;\n-    strNewWalletPass.reserve(100);\n-    strNewWalletPass = params[1].get_str().c_str();\n-\n-    if (strOldWalletPass.length() < 1 || strNewWalletPass.length() < 1)\n-        throw runtime_error(\n-            \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n-            \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n-\n-    if (!pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n-        throw JSONRPCError(-14, \"Error: The wallet passphrase entered was incorrect.\");\n-\n-    return Value::null;\n-}\n-\n-\n-Value walletlock(const Array& params, bool fHelp)\n-{\n-    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 0))\n-        throw runtime_error(\n-            \"walletlock\\n\"\n-            \"Removes the wallet encryption key from memory, locking the wallet.\\n\"\n-            \"After calling this method, you will need to call walletpassphrase again\\n\"\n-            \"before being able to call any methods which require the wallet to be unlocked.\");\n-    if (fHelp)\n-        return true;\n-    if (!pwalletMain->IsCrypted())\n-        throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n-\n-    {\n-        LOCK(cs_nWalletUnlockTime);\n-        pwalletMain->Lock();\n-        nWalletUnlockTime = 0;\n-    }\n-\n-    return Value::null;\n-}\n-\n-\n-Value encryptwallet(const Array& params, bool fHelp)\n-{\n-    if (!pwalletMain->IsCrypted() && (fHelp || params.size() != 1))\n-        throw runtime_error(\n-            \"encryptwallet <passphrase>\\n\"\n-            \"Encrypts the wallet with <passphrase>.\");\n-    if (fHelp)\n-        return true;\n-    if (pwalletMain->IsCrypted())\n-        throw JSONRPCError(-15, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n-\n-    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n-    // Alternately, find a way to make params[0] mlock()'d to begin with.\n-    SecureString strWalletPass;\n-    strWalletPass.reserve(100);\n-    strWalletPass = params[0].get_str().c_str();\n-\n-    if (strWalletPass.length() < 1)\n-        throw runtime_error(\n-            \"encryptwallet <passphrase>\\n\"\n-            \"Encrypts the wallet with <passphrase>.\");\n-\n-    if (!pwalletMain->EncryptWallet(strWalletPass))\n-        throw JSONRPCError(-16, \"Error: Failed to encrypt the wallet.\");\n-\n-    // BDB seems to have a bad habit of writing old data into\n-    // slack space in .dat files; that is bad if the old data is\n-    // unencrypted private keys.  So:\n-    StartShutdown();\n-    return \"wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet\";\n-}\n-\n-class DescribeAddressVisitor : public boost::static_visitor<Object>\n-{\n-public:\n-    Object operator()(const CNoDestination &dest) const { return Object(); }\n-\n-    Object operator()(const CKeyID &keyID) const {\n-        Object obj;\n-        CPubKey vchPubKey;\n-        pwalletMain->GetPubKey(keyID, vchPubKey);\n-        obj.push_back(Pair(\"isscript\", false));\n-        obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey.Raw())));\n-        obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n-        return obj;\n-    }\n-\n-    Object operator()(const CScriptID &scriptID) const {\n-        Object obj;\n-        obj.push_back(Pair(\"isscript\", true));\n-        CScript subscript;\n-        pwalletMain->GetCScript(scriptID, subscript);\n-        std::vector<CTxDestination> addresses;\n-        txnouttype whichType;\n-        int nRequired;\n-        ExtractDestinations(subscript, whichType, addresses, nRequired);\n-        obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n-        Array a;\n-        BOOST_FOREACH(const CTxDestination& addr, addresses)\n-            a.push_back(CBitcoinAddress(addr).ToString());\n-        obj.push_back(Pair(\"addresses\", a));\n-        if (whichType == TX_MULTISIG)\n-            obj.push_back(Pair(\"sigsrequired\", nRequired));\n-        return obj;\n-    }\n-};\n-\n-Value validateaddress(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"validateaddress <bitcoinaddress>\\n\"\n-            \"Return information about <bitcoinaddress>.\");\n-\n-    CBitcoinAddress address(params[0].get_str());\n-    bool isValid = address.IsValid();\n-\n-    Object ret;\n-    ret.push_back(Pair(\"isvalid\", isValid));\n-    if (isValid)\n-    {\n-        CTxDestination dest = address.Get();\n-        string currentAddress = address.ToString();\n-        ret.push_back(Pair(\"address\", currentAddress));\n-        bool fMine = IsMine(*pwalletMain, dest);\n-        ret.push_back(Pair(\"ismine\", fMine));\n-        if (fMine) {\n-            Object detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n-            ret.insert(ret.end(), detail.begin(), detail.end());\n-        }\n-        if (pwalletMain->mapAddressBook.count(dest))\n-            ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[dest]));\n-    }\n-    return ret;\n-}\n-\n Value getrawmempool(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)"
      },
      {
        "sha": "5120b71a2d88cc500b27f12abdd259f8fd5b72be",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -70,4 +70,57 @@ class CRPCTable\n \n extern const CRPCTable tableRPC;\n \n+extern int64 nWalletUnlockTime;\n+extern int64 AmountFromValue(const json_spirit::Value& value);\n+extern json_spirit::Value ValueFromAmount(int64 amount);\n+\n+extern json_spirit::Value getconnectioncount(const json_spirit::Array& params, bool fHelp); // in rpcnet.cpp\n+extern json_spirit::Value getpeerinfo(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value dumpprivkey(const json_spirit::Array& params, bool fHelp); // in rpcdump.cpp\n+extern json_spirit::Value importprivkey(const json_spirit::Array& params, bool fHelp);\n+\n+extern json_spirit::Value getgenerate(const json_spirit::Array& params, bool fHelp); // in rpcmining.cpp\n+extern json_spirit::Value setgenerate(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value gethashespersec(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getmininginfo(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getwork(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getblocktemplate(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value submitblock(const json_spirit::Array& params, bool fHelp);\n+\n+extern json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp); // in rpcwallet.cpp\n+extern json_spirit::Value getaccountaddress(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value setaccount(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getaccount(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getaddressesbyaccount(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value sendtoaddress(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value signmessage(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value verifymessage(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getreceivedbyaddress(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getreceivedbyaccount(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getbalance(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value movecmd(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value sendfrom(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value sendmany(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value addmultisigaddress(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value listreceivedbyaddress(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value listreceivedbyaccount(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value listtransactions(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value listaccounts(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value listsinceblock(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value gettransaction(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value backupwallet(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value keypoolrefill(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value walletpassphrase(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value walletpassphrasechange(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value walletlock(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value encryptwallet(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value validateaddress(const json_spirit::Array& params, bool fHelp);\n+\n+extern json_spirit::Value getrawtransaction(const json_spirit::Array& params, bool fHelp); // in rcprawtransaction.cpp\n+extern json_spirit::Value listunspent(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value createrawtransaction(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value decoderawtransaction(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value signrawtransaction(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value sendrawtransaction(const json_spirit::Array& params, bool fHelp);\n+\n #endif"
      },
      {
        "sha": "86db4ee167531681539ecdb6487aaac6c1ceb57d",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -63,6 +63,7 @@ OBJS= \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n+    obj/rpcwallet.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "84543df2ff28bf909279985c51685cd3d1f06f48",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -59,6 +59,7 @@ OBJS= \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n+    obj/rpcwallet.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "fec1c6cb2facaabba6ebbc1a5fe30aac8e54a87b",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -86,6 +86,7 @@ OBJS= \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n+    obj/rpcwallet.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "e9200ac4d9476ef6f66ef9cdc4d379765df312e4",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -111,6 +111,7 @@ OBJS= \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n+    obj/rpcwallet.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "b9b3f52f0eca1039f7268122e90a3f79b4f7a363",
        "filename": "src/rpcwallet.cpp",
        "status": "added",
        "additions": 1429,
        "deletions": 0,
        "changes": 1429,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3bc56986508b40f894c7c707d39ea1bb437ebb5/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "patch": "@@ -0,0 +1,1429 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet.h\"\n+#include \"walletdb.h\"\n+#include \"bitcoinrpc.h\"\n+#include \"init.h\"\n+#include \"base58.h\"\n+\n+using namespace json_spirit;\n+using namespace std;\n+\n+int64 nWalletUnlockTime;\n+static CCriticalSection cs_nWalletUnlockTime;\n+\n+std::string\n+HelpRequiringPassphrase()\n+{\n+    return pwalletMain->IsCrypted()\n+        ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\"\n+        : \"\";\n+}\n+\n+void\n+EnsureWalletIsUnlocked()\n+{\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+}\n+\n+void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n+{\n+    int confirms = wtx.GetDepthInMainChain();\n+    entry.push_back(Pair(\"confirmations\", confirms));\n+    if (confirms)\n+    {\n+        entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n+        entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n+    }\n+    entry.push_back(Pair(\"txid\", wtx.GetHash().GetHex()));\n+    entry.push_back(Pair(\"time\", (boost::int64_t)wtx.GetTxTime()));\n+    BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n+        entry.push_back(Pair(item.first, item.second));\n+}\n+\n+string AccountFromValue(const Value& value)\n+{\n+    string strAccount = value.get_str();\n+    if (strAccount == \"*\")\n+        throw JSONRPCError(-11, \"Invalid account name\");\n+    return strAccount;\n+}\n+\n+Value getnewaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw runtime_error(\n+            \"getnewaddress [account]\\n\"\n+            \"Returns a new Bitcoin address for receiving payments.  \"\n+            \"If [account] is specified (recommended), it is added to the address book \"\n+            \"so payments received with the address will be credited to [account].\");\n+\n+    // Parse the account first so we don't generate a key if there's an error\n+    string strAccount;\n+    if (params.size() > 0)\n+        strAccount = AccountFromValue(params[0]);\n+\n+    if (!pwalletMain->IsLocked())\n+        pwalletMain->TopUpKeyPool();\n+\n+    // Generate a new key that is added to wallet\n+    CPubKey newKey;\n+    if (!pwalletMain->GetKeyFromPool(newKey, false))\n+        throw JSONRPCError(-12, \"Error: Keypool ran out, please call keypoolrefill first\");\n+    CKeyID keyID = newKey.GetID();\n+\n+    pwalletMain->SetAddressBookName(keyID, strAccount);\n+\n+    return CBitcoinAddress(keyID).ToString();\n+}\n+\n+\n+CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n+{\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n+\n+    CAccount account;\n+    walletdb.ReadAccount(strAccount, account);\n+\n+    bool bKeyUsed = false;\n+\n+    // Check if the current key has been used\n+    if (account.vchPubKey.IsValid())\n+    {\n+        CScript scriptPubKey;\n+        scriptPubKey.SetDestination(account.vchPubKey.GetID());\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin();\n+             it != pwalletMain->mapWallet.end() && account.vchPubKey.IsValid();\n+             ++it)\n+        {\n+            const CWalletTx& wtx = (*it).second;\n+            BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+                if (txout.scriptPubKey == scriptPubKey)\n+                    bKeyUsed = true;\n+        }\n+    }\n+\n+    // Generate a new key\n+    if (!account.vchPubKey.IsValid() || bForceNew || bKeyUsed)\n+    {\n+        if (!pwalletMain->GetKeyFromPool(account.vchPubKey, false))\n+            throw JSONRPCError(-12, \"Error: Keypool ran out, please call keypoolrefill first\");\n+\n+        pwalletMain->SetAddressBookName(account.vchPubKey.GetID(), strAccount);\n+        walletdb.WriteAccount(strAccount, account);\n+    }\n+\n+    return CBitcoinAddress(account.vchPubKey.GetID());\n+}\n+\n+Value getaccountaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaccountaddress <account>\\n\"\n+            \"Returns the current Bitcoin address for receiving payments to this account.\");\n+\n+    // Parse the account first so we don't generate a key if there's an error\n+    string strAccount = AccountFromValue(params[0]);\n+\n+    Value ret;\n+\n+    ret = GetAccountAddress(strAccount).ToString();\n+\n+    return ret;\n+}\n+\n+\n+\n+Value setaccount(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"setaccount <bitcoinaddress> <account>\\n\"\n+            \"Sets the account associated with the given address.\");\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    if (!address.IsValid())\n+        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n+\n+\n+    string strAccount;\n+    if (params.size() > 1)\n+        strAccount = AccountFromValue(params[1]);\n+\n+    // Detect when changing the account of an address that is the 'unused current key' of another account:\n+    if (pwalletMain->mapAddressBook.count(address.Get()))\n+    {\n+        string strOldAccount = pwalletMain->mapAddressBook[address.Get()];\n+        if (address == GetAccountAddress(strOldAccount))\n+            GetAccountAddress(strOldAccount, true);\n+    }\n+\n+    pwalletMain->SetAddressBookName(address.Get(), strAccount);\n+\n+    return Value::null;\n+}\n+\n+\n+Value getaccount(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaccount <bitcoinaddress>\\n\"\n+            \"Returns the account associated with the given address.\");\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    if (!address.IsValid())\n+        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n+\n+    string strAccount;\n+    map<CTxDestination, string>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n+    if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.empty())\n+        strAccount = (*mi).second;\n+    return strAccount;\n+}\n+\n+\n+Value getaddressesbyaccount(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressesbyaccount <account>\\n\"\n+            \"Returns the list of addresses for the given account.\");\n+\n+    string strAccount = AccountFromValue(params[0]);\n+\n+    // Find all addresses that have the given account\n+    Array ret;\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n+    {\n+        const CBitcoinAddress& address = item.first;\n+        const string& strName = item.second;\n+        if (strName == strAccount)\n+            ret.push_back(address.ToString());\n+    }\n+    return ret;\n+}\n+\n+Value sendtoaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 4)\n+        throw runtime_error(\n+            \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\"\n+            + HelpRequiringPassphrase());\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    if (!address.IsValid())\n+        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n+\n+    // Amount\n+    int64 nAmount = AmountFromValue(params[1]);\n+\n+    // Wallet comments\n+    CWalletTx wtx;\n+    if (params.size() > 2 && params[2].type() != null_type && !params[2].get_str().empty())\n+        wtx.mapValue[\"comment\"] = params[2].get_str();\n+    if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n+        wtx.mapValue[\"to\"]      = params[3].get_str();\n+\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+\n+    string strError = pwalletMain->SendMoneyToDestination(address.Get(), nAmount, wtx);\n+    if (strError != \"\")\n+        throw JSONRPCError(-4, strError);\n+\n+    return wtx.GetHash().GetHex();\n+}\n+\n+Value signmessage(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 2)\n+        throw runtime_error(\n+            \"signmessage <bitcoinaddress> <message>\\n\"\n+            \"Sign a message with the private key of an address\");\n+\n+    EnsureWalletIsUnlocked();\n+\n+    string strAddress = params[0].get_str();\n+    string strMessage = params[1].get_str();\n+\n+    CBitcoinAddress addr(strAddress);\n+    if (!addr.IsValid())\n+        throw JSONRPCError(-3, \"Invalid address\");\n+\n+    CKeyID keyID;\n+    if (!addr.GetKeyID(keyID))\n+        throw JSONRPCError(-3, \"Address does not refer to key\");\n+\n+    CKey key;\n+    if (!pwalletMain->GetKey(keyID, key))\n+        throw JSONRPCError(-4, \"Private key not available\");\n+\n+    CDataStream ss(SER_GETHASH, 0);\n+    ss << strMessageMagic;\n+    ss << strMessage;\n+\n+    vector<unsigned char> vchSig;\n+    if (!key.SignCompact(Hash(ss.begin(), ss.end()), vchSig))\n+        throw JSONRPCError(-5, \"Sign failed\");\n+\n+    return EncodeBase64(&vchSig[0], vchSig.size());\n+}\n+\n+Value verifymessage(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 3)\n+        throw runtime_error(\n+            \"verifymessage <bitcoinaddress> <signature> <message>\\n\"\n+            \"Verify a signed message\");\n+\n+    string strAddress  = params[0].get_str();\n+    string strSign     = params[1].get_str();\n+    string strMessage  = params[2].get_str();\n+\n+    CBitcoinAddress addr(strAddress);\n+    if (!addr.IsValid())\n+        throw JSONRPCError(-3, \"Invalid address\");\n+\n+    CKeyID keyID;\n+    if (!addr.GetKeyID(keyID))\n+        throw JSONRPCError(-3, \"Address does not refer to key\");\n+\n+    bool fInvalid = false;\n+    vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n+\n+    if (fInvalid)\n+        throw JSONRPCError(-5, \"Malformed base64 encoding\");\n+\n+    CDataStream ss(SER_GETHASH, 0);\n+    ss << strMessageMagic;\n+    ss << strMessage;\n+\n+    CKey key;\n+    if (!key.SetCompactSignature(Hash(ss.begin(), ss.end()), vchSig))\n+        return false;\n+\n+    return (key.GetPubKey().GetID() == keyID);\n+}\n+\n+\n+Value getreceivedbyaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"getreceivedbyaddress <bitcoinaddress> [minconf=1]\\n\"\n+            \"Returns the total amount received by <bitcoinaddress> in transactions with at least [minconf] confirmations.\");\n+\n+    // Bitcoin address\n+    CBitcoinAddress address = CBitcoinAddress(params[0].get_str());\n+    CScript scriptPubKey;\n+    if (!address.IsValid())\n+        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n+    scriptPubKey.SetDestination(address.Get());\n+    if (!IsMine(*pwalletMain,scriptPubKey))\n+        return (double)0.0;\n+\n+    // Minimum confirmations\n+    int nMinDepth = 1;\n+    if (params.size() > 1)\n+        nMinDepth = params[1].get_int();\n+\n+    // Tally\n+    int64 nAmount = 0;\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        if (wtx.IsCoinBase() || !wtx.IsFinal())\n+            continue;\n+\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+            if (txout.scriptPubKey == scriptPubKey)\n+                if (wtx.GetDepthInMainChain() >= nMinDepth)\n+                    nAmount += txout.nValue;\n+    }\n+\n+    return  ValueFromAmount(nAmount);\n+}\n+\n+\n+void GetAccountAddresses(string strAccount, set<CTxDestination>& setAddress)\n+{\n+    BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)& item, pwalletMain->mapAddressBook)\n+    {\n+        const CTxDestination& address = item.first;\n+        const string& strName = item.second;\n+        if (strName == strAccount)\n+            setAddress.insert(address);\n+    }\n+}\n+\n+Value getreceivedbyaccount(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"getreceivedbyaccount <account> [minconf=1]\\n\"\n+            \"Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\");\n+\n+    // Minimum confirmations\n+    int nMinDepth = 1;\n+    if (params.size() > 1)\n+        nMinDepth = params[1].get_int();\n+\n+    // Get the set of pub keys assigned to account\n+    string strAccount = AccountFromValue(params[0]);\n+    set<CTxDestination> setAddress;\n+    GetAccountAddresses(strAccount, setAddress);\n+\n+    // Tally\n+    int64 nAmount = 0;\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        if (wtx.IsCoinBase() || !wtx.IsFinal())\n+            continue;\n+\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+        {\n+            CTxDestination address;\n+            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwalletMain, address) && setAddress.count(address))\n+                if (wtx.GetDepthInMainChain() >= nMinDepth)\n+                    nAmount += txout.nValue;\n+        }\n+    }\n+\n+    return (double)nAmount / (double)COIN;\n+}\n+\n+\n+int64 GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n+{\n+    int64 nBalance = 0;\n+\n+    // Tally wallet transactions\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        if (!wtx.IsFinal())\n+            continue;\n+\n+        int64 nGenerated, nReceived, nSent, nFee;\n+        wtx.GetAccountAmounts(strAccount, nGenerated, nReceived, nSent, nFee);\n+\n+        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n+            nBalance += nReceived;\n+        nBalance += nGenerated - nSent - nFee;\n+    }\n+\n+    // Tally internal accounting entries\n+    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n+\n+    return nBalance;\n+}\n+\n+int64 GetAccountBalance(const string& strAccount, int nMinDepth)\n+{\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n+    return GetAccountBalance(walletdb, strAccount, nMinDepth);\n+}\n+\n+\n+Value getbalance(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 2)\n+        throw runtime_error(\n+            \"getbalance [account] [minconf=1]\\n\"\n+            \"If [account] is not specified, returns the server's total available balance.\\n\"\n+            \"If [account] is specified, returns the balance in the account.\");\n+\n+    if (params.size() == 0)\n+        return  ValueFromAmount(pwalletMain->GetBalance());\n+\n+    int nMinDepth = 1;\n+    if (params.size() > 1)\n+        nMinDepth = params[1].get_int();\n+\n+    if (params[0].get_str() == \"*\") {\n+        // Calculate total balance a different way from GetBalance()\n+        // (GetBalance() sums up all unspent TxOuts)\n+        // getbalance and getbalance '*' should always return the same number.\n+        int64 nBalance = 0;\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+        {\n+            const CWalletTx& wtx = (*it).second;\n+            if (!wtx.IsFinal())\n+                continue;\n+\n+            int64 allGeneratedImmature, allGeneratedMature, allFee;\n+            allGeneratedImmature = allGeneratedMature = allFee = 0;\n+            string strSentAccount;\n+            list<pair<CTxDestination, int64> > listReceived;\n+            list<pair<CTxDestination, int64> > listSent;\n+            wtx.GetAmounts(allGeneratedImmature, allGeneratedMature, listReceived, listSent, allFee, strSentAccount);\n+            if (wtx.GetDepthInMainChain() >= nMinDepth)\n+            {\n+                BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& r, listReceived)\n+                    nBalance += r.second;\n+            }\n+            BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)& r, listSent)\n+                nBalance -= r.second;\n+            nBalance -= allFee;\n+            nBalance += allGeneratedMature;\n+        }\n+        return  ValueFromAmount(nBalance);\n+    }\n+\n+    string strAccount = AccountFromValue(params[0]);\n+\n+    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+\n+    return ValueFromAmount(nBalance);\n+}\n+\n+\n+Value movecmd(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 3 || params.size() > 5)\n+        throw runtime_error(\n+            \"move <fromaccount> <toaccount> <amount> [minconf=1] [comment]\\n\"\n+            \"Move from one account in your wallet to another.\");\n+\n+    string strFrom = AccountFromValue(params[0]);\n+    string strTo = AccountFromValue(params[1]);\n+    int64 nAmount = AmountFromValue(params[2]);\n+    if (params.size() > 3)\n+        // unused parameter, used to be nMinDepth, keep type-checking it though\n+        (void)params[3].get_int();\n+    string strComment;\n+    if (params.size() > 4)\n+        strComment = params[4].get_str();\n+\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n+    if (!walletdb.TxnBegin())\n+        throw JSONRPCError(-20, \"database error\");\n+\n+    int64 nNow = GetAdjustedTime();\n+\n+    // Debit\n+    CAccountingEntry debit;\n+    debit.strAccount = strFrom;\n+    debit.nCreditDebit = -nAmount;\n+    debit.nTime = nNow;\n+    debit.strOtherAccount = strTo;\n+    debit.strComment = strComment;\n+    walletdb.WriteAccountingEntry(debit);\n+\n+    // Credit\n+    CAccountingEntry credit;\n+    credit.strAccount = strTo;\n+    credit.nCreditDebit = nAmount;\n+    credit.nTime = nNow;\n+    credit.strOtherAccount = strFrom;\n+    credit.strComment = strComment;\n+    walletdb.WriteAccountingEntry(credit);\n+\n+    if (!walletdb.TxnCommit())\n+        throw JSONRPCError(-20, \"database error\");\n+\n+    return true;\n+}\n+\n+\n+Value sendfrom(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 3 || params.size() > 6)\n+        throw runtime_error(\n+            \"sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\"\n+            + HelpRequiringPassphrase());\n+\n+    string strAccount = AccountFromValue(params[0]);\n+    CBitcoinAddress address(params[1].get_str());\n+    if (!address.IsValid())\n+        throw JSONRPCError(-5, \"Invalid Bitcoin address\");\n+    int64 nAmount = AmountFromValue(params[2]);\n+    int nMinDepth = 1;\n+    if (params.size() > 3)\n+        nMinDepth = params[3].get_int();\n+\n+    CWalletTx wtx;\n+    wtx.strFromAccount = strAccount;\n+    if (params.size() > 4 && params[4].type() != null_type && !params[4].get_str().empty())\n+        wtx.mapValue[\"comment\"] = params[4].get_str();\n+    if (params.size() > 5 && params[5].type() != null_type && !params[5].get_str().empty())\n+        wtx.mapValue[\"to\"]      = params[5].get_str();\n+\n+    EnsureWalletIsUnlocked();\n+\n+    // Check funds\n+    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    if (nAmount > nBalance)\n+        throw JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+    // Send\n+    string strError = pwalletMain->SendMoneyToDestination(address.Get(), nAmount, wtx);\n+    if (strError != \"\")\n+        throw JSONRPCError(-4, strError);\n+\n+    return wtx.GetHash().GetHex();\n+}\n+\n+\n+Value sendmany(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 4)\n+        throw runtime_error(\n+            \"sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]\\n\"\n+            \"amounts are double-precision floating point numbers\"\n+            + HelpRequiringPassphrase());\n+\n+    string strAccount = AccountFromValue(params[0]);\n+    Object sendTo = params[1].get_obj();\n+    int nMinDepth = 1;\n+    if (params.size() > 2)\n+        nMinDepth = params[2].get_int();\n+\n+    CWalletTx wtx;\n+    wtx.strFromAccount = strAccount;\n+    if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())\n+        wtx.mapValue[\"comment\"] = params[3].get_str();\n+\n+    set<CBitcoinAddress> setAddress;\n+    vector<pair<CScript, int64> > vecSend;\n+\n+    int64 totalAmount = 0;\n+    BOOST_FOREACH(const Pair& s, sendTo)\n+    {\n+        CBitcoinAddress address(s.name_);\n+        if (!address.IsValid())\n+            throw JSONRPCError(-5, string(\"Invalid Bitcoin address:\")+s.name_);\n+\n+        if (setAddress.count(address))\n+            throw JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+s.name_);\n+        setAddress.insert(address);\n+\n+        CScript scriptPubKey;\n+        scriptPubKey.SetDestination(address.Get());\n+        int64 nAmount = AmountFromValue(s.value_);\n+        totalAmount += nAmount;\n+\n+        vecSend.push_back(make_pair(scriptPubKey, nAmount));\n+    }\n+\n+    EnsureWalletIsUnlocked();\n+\n+    // Check funds\n+    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    if (totalAmount > nBalance)\n+        throw JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+    // Send\n+    CReserveKey keyChange(pwalletMain);\n+    int64 nFeeRequired = 0;\n+    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired);\n+    if (!fCreated)\n+    {\n+        if (totalAmount + nFeeRequired > pwalletMain->GetBalance())\n+            throw JSONRPCError(-6, \"Insufficient funds\");\n+        throw JSONRPCError(-4, \"Transaction creation failed\");\n+    }\n+    if (!pwalletMain->CommitTransaction(wtx, keyChange))\n+        throw JSONRPCError(-4, \"Transaction commit failed\");\n+\n+    return wtx.GetHash().GetHex();\n+}\n+\n+Value addmultisigaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+    {\n+        string msg = \"addmultisigaddress <nrequired> <'[\\\"key\\\",\\\"key\\\"]'> [account]\\n\"\n+            \"Add a nrequired-to-sign multisignature address to the wallet\\\"\\n\"\n+            \"each key is a Bitcoin address or hex-encoded public key\\n\"\n+            \"If [account] is specified, assign address to [account].\";\n+        throw runtime_error(msg);\n+    }\n+\n+    int nRequired = params[0].get_int();\n+    const Array& keys = params[1].get_array();\n+    string strAccount;\n+    if (params.size() > 2)\n+        strAccount = AccountFromValue(params[2]);\n+\n+    // Gather public keys\n+    if (nRequired < 1)\n+        throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n+    if ((int)keys.size() < nRequired)\n+        throw runtime_error(\n+            strprintf(\"not enough keys supplied \"\n+                      \"(got %d keys, but need at least %d to redeem)\", keys.size(), nRequired));\n+    std::vector<CKey> pubkeys;\n+    pubkeys.resize(keys.size());\n+    for (unsigned int i = 0; i < keys.size(); i++)\n+    {\n+        const std::string& ks = keys[i].get_str();\n+\n+        // Case 1: Bitcoin address and we have full public key:\n+        CBitcoinAddress address(ks);\n+        if (address.IsValid())\n+        {\n+            CKeyID keyID;\n+            if (!address.GetKeyID(keyID))\n+                throw runtime_error(\n+                    strprintf(\"%s does not refer to a key\",ks.c_str()));\n+            CPubKey vchPubKey;\n+            if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n+                throw runtime_error(\n+                    strprintf(\"no full public key for address %s\",ks.c_str()));\n+            if (!vchPubKey.IsValid() || !pubkeys[i].SetPubKey(vchPubKey))\n+                throw runtime_error(\" Invalid public key: \"+ks);\n+        }\n+\n+        // Case 2: hex public key\n+        else if (IsHex(ks))\n+        {\n+            CPubKey vchPubKey(ParseHex(ks));\n+            if (!vchPubKey.IsValid() || !pubkeys[i].SetPubKey(vchPubKey))\n+                throw runtime_error(\" Invalid public key: \"+ks);\n+        }\n+        else\n+        {\n+            throw runtime_error(\" Invalid public key: \"+ks);\n+        }\n+    }\n+\n+    // Construct using pay-to-script-hash:\n+    CScript inner;\n+    inner.SetMultisig(nRequired, pubkeys);\n+    CScriptID innerID = inner.GetID();\n+    pwalletMain->AddCScript(inner);\n+\n+    pwalletMain->SetAddressBookName(innerID, strAccount);\n+    return CBitcoinAddress(innerID).ToString();\n+}\n+\n+\n+struct tallyitem\n+{\n+    int64 nAmount;\n+    int nConf;\n+    tallyitem()\n+    {\n+        nAmount = 0;\n+        nConf = std::numeric_limits<int>::max();\n+    }\n+};\n+\n+Value ListReceived(const Array& params, bool fByAccounts)\n+{\n+    // Minimum confirmations\n+    int nMinDepth = 1;\n+    if (params.size() > 0)\n+        nMinDepth = params[0].get_int();\n+\n+    // Whether to include empty accounts\n+    bool fIncludeEmpty = false;\n+    if (params.size() > 1)\n+        fIncludeEmpty = params[1].get_bool();\n+\n+    // Tally\n+    map<CBitcoinAddress, tallyitem> mapTally;\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+\n+        if (wtx.IsCoinBase() || !wtx.IsFinal())\n+            continue;\n+\n+        int nDepth = wtx.GetDepthInMainChain();\n+        if (nDepth < nMinDepth)\n+            continue;\n+\n+        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n+        {\n+            CTxDestination address;\n+            if (!ExtractDestination(txout.scriptPubKey, address) || !IsMine(*pwalletMain, address))\n+                continue;\n+\n+            tallyitem& item = mapTally[address];\n+            item.nAmount += txout.nValue;\n+            item.nConf = min(item.nConf, nDepth);\n+        }\n+    }\n+\n+    // Reply\n+    Array ret;\n+    map<string, tallyitem> mapAccountTally;\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)& item, pwalletMain->mapAddressBook)\n+    {\n+        const CBitcoinAddress& address = item.first;\n+        const string& strAccount = item.second;\n+        map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n+        if (it == mapTally.end() && !fIncludeEmpty)\n+            continue;\n+\n+        int64 nAmount = 0;\n+        int nConf = std::numeric_limits<int>::max();\n+        if (it != mapTally.end())\n+        {\n+            nAmount = (*it).second.nAmount;\n+            nConf = (*it).second.nConf;\n+        }\n+\n+        if (fByAccounts)\n+        {\n+            tallyitem& item = mapAccountTally[strAccount];\n+            item.nAmount += nAmount;\n+            item.nConf = min(item.nConf, nConf);\n+        }\n+        else\n+        {\n+            Object obj;\n+            obj.push_back(Pair(\"address\",       address.ToString()));\n+            obj.push_back(Pair(\"account\",       strAccount));\n+            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n+            ret.push_back(obj);\n+        }\n+    }\n+\n+    if (fByAccounts)\n+    {\n+        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n+        {\n+            int64 nAmount = (*it).second.nAmount;\n+            int nConf = (*it).second.nConf;\n+            Object obj;\n+            obj.push_back(Pair(\"account\",       (*it).first));\n+            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n+            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n+            ret.push_back(obj);\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n+Value listreceivedbyaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 2)\n+        throw runtime_error(\n+            \"listreceivedbyaddress [minconf=1] [includeempty=false]\\n\"\n+            \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n+            \"[includeempty] whether to include addresses that haven't received any payments.\\n\"\n+            \"Returns an array of objects containing:\\n\"\n+            \"  \\\"address\\\" : receiving address\\n\"\n+            \"  \\\"account\\\" : the account of the receiving address\\n\"\n+            \"  \\\"amount\\\" : total amount received by the address\\n\"\n+            \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n+\n+    return ListReceived(params, false);\n+}\n+\n+Value listreceivedbyaccount(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 2)\n+        throw runtime_error(\n+            \"listreceivedbyaccount [minconf=1] [includeempty=false]\\n\"\n+            \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n+            \"[includeempty] whether to include accounts that haven't received any payments.\\n\"\n+            \"Returns an array of objects containing:\\n\"\n+            \"  \\\"account\\\" : the account of the receiving addresses\\n\"\n+            \"  \\\"amount\\\" : total amount received by addresses with this account\\n\"\n+            \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n+\n+    return ListReceived(params, true);\n+}\n+\n+void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, Array& ret)\n+{\n+    int64 nGeneratedImmature, nGeneratedMature, nFee;\n+    string strSentAccount;\n+    list<pair<CTxDestination, int64> > listReceived;\n+    list<pair<CTxDestination, int64> > listSent;\n+\n+    wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n+\n+    bool fAllAccounts = (strAccount == string(\"*\"));\n+\n+    // Generated blocks assigned to account \"\"\n+    if ((nGeneratedMature+nGeneratedImmature) != 0 && (fAllAccounts || strAccount == \"\"))\n+    {\n+        Object entry;\n+        entry.push_back(Pair(\"account\", string(\"\")));\n+        if (nGeneratedImmature)\n+        {\n+            entry.push_back(Pair(\"category\", wtx.GetDepthInMainChain() ? \"immature\" : \"orphan\"));\n+            entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedImmature)));\n+        }\n+        else\n+        {\n+            entry.push_back(Pair(\"category\", \"generate\"));\n+            entry.push_back(Pair(\"amount\", ValueFromAmount(nGeneratedMature)));\n+        }\n+        if (fLong)\n+            WalletTxToJSON(wtx, entry);\n+        ret.push_back(entry);\n+    }\n+\n+    // Sent\n+    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n+    {\n+        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& s, listSent)\n+        {\n+            Object entry;\n+            entry.push_back(Pair(\"account\", strSentAccount));\n+            entry.push_back(Pair(\"address\", CBitcoinAddress(s.first).ToString()));\n+            entry.push_back(Pair(\"category\", \"send\"));\n+            entry.push_back(Pair(\"amount\", ValueFromAmount(-s.second)));\n+            entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n+            if (fLong)\n+                WalletTxToJSON(wtx, entry);\n+            ret.push_back(entry);\n+        }\n+    }\n+\n+    // Received\n+    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n+    {\n+        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& r, listReceived)\n+        {\n+            string account;\n+            if (pwalletMain->mapAddressBook.count(r.first))\n+                account = pwalletMain->mapAddressBook[r.first];\n+            if (fAllAccounts || (account == strAccount))\n+            {\n+                Object entry;\n+                entry.push_back(Pair(\"account\", account));\n+                entry.push_back(Pair(\"address\", CBitcoinAddress(r.first).ToString()));\n+                entry.push_back(Pair(\"category\", \"receive\"));\n+                entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n+                if (fLong)\n+                    WalletTxToJSON(wtx, entry);\n+                ret.push_back(entry);\n+            }\n+        }\n+    }\n+}\n+\n+void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, Array& ret)\n+{\n+    bool fAllAccounts = (strAccount == string(\"*\"));\n+\n+    if (fAllAccounts || acentry.strAccount == strAccount)\n+    {\n+        Object entry;\n+        entry.push_back(Pair(\"account\", acentry.strAccount));\n+        entry.push_back(Pair(\"category\", \"move\"));\n+        entry.push_back(Pair(\"time\", (boost::int64_t)acentry.nTime));\n+        entry.push_back(Pair(\"amount\", ValueFromAmount(acentry.nCreditDebit)));\n+        entry.push_back(Pair(\"otheraccount\", acentry.strOtherAccount));\n+        entry.push_back(Pair(\"comment\", acentry.strComment));\n+        ret.push_back(entry);\n+    }\n+}\n+\n+Value listtransactions(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 3)\n+        throw runtime_error(\n+            \"listtransactions [account] [count=10] [from=0]\\n\"\n+            \"Returns up to [count] most recent transactions skipping the first [from] transactions for account [account].\");\n+\n+    string strAccount = \"*\";\n+    if (params.size() > 0)\n+        strAccount = params[0].get_str();\n+    int nCount = 10;\n+    if (params.size() > 1)\n+        nCount = params[1].get_int();\n+    int nFrom = 0;\n+    if (params.size() > 2)\n+        nFrom = params[2].get_int();\n+\n+    if (nCount < 0)\n+        throw JSONRPCError(-8, \"Negative count\");\n+    if (nFrom < 0)\n+        throw JSONRPCError(-8, \"Negative from\");\n+\n+    Array ret;\n+    CWalletDB walletdb(pwalletMain->strWalletFile);\n+\n+    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n+    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n+    typedef multimap<int64, TxPair > TxItems;\n+    TxItems txByTime;\n+\n+    // Note: maintaining indices in the database of (account,time) --> txid and (account, time) --> acentry\n+    // would make this much faster for applications that do this a lot.\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        CWalletTx* wtx = &((*it).second);\n+        txByTime.insert(make_pair(wtx->GetTxTime(), TxPair(wtx, (CAccountingEntry*)0)));\n+    }\n+    list<CAccountingEntry> acentries;\n+    walletdb.ListAccountCreditDebit(strAccount, acentries);\n+    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n+    {\n+        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+    }\n+\n+    // iterate backwards until we have nCount items to return:\n+    for (TxItems::reverse_iterator it = txByTime.rbegin(); it != txByTime.rend(); ++it)\n+    {\n+        CWalletTx *const pwtx = (*it).second.first;\n+        if (pwtx != 0)\n+            ListTransactions(*pwtx, strAccount, 0, true, ret);\n+        CAccountingEntry *const pacentry = (*it).second.second;\n+        if (pacentry != 0)\n+            AcentryToJSON(*pacentry, strAccount, ret);\n+\n+        if ((int)ret.size() >= (nCount+nFrom)) break;\n+    }\n+    // ret is newest to oldest\n+\n+    if (nFrom > (int)ret.size())\n+        nFrom = ret.size();\n+    if ((nFrom + nCount) > (int)ret.size())\n+        nCount = ret.size() - nFrom;\n+    Array::iterator first = ret.begin();\n+    std::advance(first, nFrom);\n+    Array::iterator last = ret.begin();\n+    std::advance(last, nFrom+nCount);\n+\n+    if (last != ret.end()) ret.erase(last, ret.end());\n+    if (first != ret.begin()) ret.erase(ret.begin(), first);\n+\n+    std::reverse(ret.begin(), ret.end()); // Return oldest to newest\n+\n+    return ret;\n+}\n+\n+Value listaccounts(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw runtime_error(\n+            \"listaccounts [minconf=1]\\n\"\n+            \"Returns Object that has account names as keys, account balances as values.\");\n+\n+    int nMinDepth = 1;\n+    if (params.size() > 0)\n+        nMinDepth = params[0].get_int();\n+\n+    map<string, int64> mapAccountBalances;\n+    BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)& entry, pwalletMain->mapAddressBook) {\n+        if (IsMine(*pwalletMain, entry.first)) // This address belongs to me\n+            mapAccountBalances[entry.second] = 0;\n+    }\n+\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    {\n+        const CWalletTx& wtx = (*it).second;\n+        int64 nGeneratedImmature, nGeneratedMature, nFee;\n+        string strSentAccount;\n+        list<pair<CTxDestination, int64> > listReceived;\n+        list<pair<CTxDestination, int64> > listSent;\n+        wtx.GetAmounts(nGeneratedImmature, nGeneratedMature, listReceived, listSent, nFee, strSentAccount);\n+        mapAccountBalances[strSentAccount] -= nFee;\n+        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& s, listSent)\n+            mapAccountBalances[strSentAccount] -= s.second;\n+        if (wtx.GetDepthInMainChain() >= nMinDepth)\n+        {\n+            mapAccountBalances[\"\"] += nGeneratedMature;\n+            BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)& r, listReceived)\n+                if (pwalletMain->mapAddressBook.count(r.first))\n+                    mapAccountBalances[pwalletMain->mapAddressBook[r.first]] += r.second;\n+                else\n+                    mapAccountBalances[\"\"] += r.second;\n+        }\n+    }\n+\n+    list<CAccountingEntry> acentries;\n+    CWalletDB(pwalletMain->strWalletFile).ListAccountCreditDebit(\"*\", acentries);\n+    BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n+        mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n+\n+    Object ret;\n+    BOOST_FOREACH(const PAIRTYPE(string, int64)& accountBalance, mapAccountBalances) {\n+        ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n+    }\n+    return ret;\n+}\n+\n+Value listsinceblock(const Array& params, bool fHelp)\n+{\n+    if (fHelp)\n+        throw runtime_error(\n+            \"listsinceblock [blockhash] [target-confirmations]\\n\"\n+            \"Get all transactions in blocks since block [blockhash], or all transactions if omitted\");\n+\n+    CBlockIndex *pindex = NULL;\n+    int target_confirms = 1;\n+\n+    if (params.size() > 0)\n+    {\n+        uint256 blockId = 0;\n+\n+        blockId.SetHex(params[0].get_str());\n+        pindex = CBlockLocator(blockId).GetBlockIndex();\n+    }\n+\n+    if (params.size() > 1)\n+    {\n+        target_confirms = params[1].get_int();\n+\n+        if (target_confirms < 1)\n+            throw JSONRPCError(-8, \"Invalid parameter\");\n+    }\n+\n+    int depth = pindex ? (1 + nBestHeight - pindex->nHeight) : -1;\n+\n+    Array transactions;\n+\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n+    {\n+        CWalletTx tx = (*it).second;\n+\n+        if (depth == -1 || tx.GetDepthInMainChain() < depth)\n+            ListTransactions(tx, \"*\", 0, true, transactions);\n+    }\n+\n+    uint256 lastblock;\n+\n+    if (target_confirms == 1)\n+    {\n+        lastblock = hashBestChain;\n+    }\n+    else\n+    {\n+        int target_height = pindexBest->nHeight + 1 - target_confirms;\n+\n+        CBlockIndex *block;\n+        for (block = pindexBest;\n+             block && block->nHeight > target_height;\n+             block = block->pprev)  { }\n+\n+        lastblock = block ? block->GetBlockHash() : 0;\n+    }\n+\n+    Object ret;\n+    ret.push_back(Pair(\"transactions\", transactions));\n+    ret.push_back(Pair(\"lastblock\", lastblock.GetHex()));\n+\n+    return ret;\n+}\n+\n+Value gettransaction(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"gettransaction <txid>\\n\"\n+            \"Get detailed information about in-wallet transaction <txid>\");\n+\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+\n+    Object entry;\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(-5, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    int64 nCredit = wtx.GetCredit();\n+    int64 nDebit = wtx.GetDebit();\n+    int64 nNet = nCredit - nDebit;\n+    int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n+\n+    entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n+    if (wtx.IsFromMe())\n+        entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n+\n+    WalletTxToJSON(wtx, entry);\n+\n+    Array details;\n+    ListTransactions(wtx, \"*\", 0, false, details);\n+    entry.push_back(Pair(\"details\", details));\n+\n+    return entry;\n+}\n+\n+\n+Value backupwallet(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"backupwallet <destination>\\n\"\n+            \"Safely copies wallet.dat to destination, which can be a directory or a path with filename.\");\n+\n+    string strDest = params[0].get_str();\n+    BackupWallet(*pwalletMain, strDest);\n+\n+    return Value::null;\n+}\n+\n+\n+Value keypoolrefill(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 0)\n+        throw runtime_error(\n+            \"keypoolrefill\\n\"\n+            \"Fills the keypool.\"\n+            + HelpRequiringPassphrase());\n+\n+    EnsureWalletIsUnlocked();\n+\n+    pwalletMain->TopUpKeyPool();\n+\n+    if (pwalletMain->GetKeyPoolSize() < GetArg(\"-keypool\", 100))\n+        throw JSONRPCError(-4, \"Error refreshing keypool.\");\n+\n+    return Value::null;\n+}\n+\n+\n+void ThreadTopUpKeyPool(void* parg)\n+{\n+    // Make this thread recognisable as the key-topping-up thread\n+    RenameThread(\"bitcoin-key-top\");\n+\n+    pwalletMain->TopUpKeyPool();\n+}\n+\n+void ThreadCleanWalletPassphrase(void* parg)\n+{\n+    // Make this thread recognisable as the wallet relocking thread\n+    RenameThread(\"bitcoin-lock-wa\");\n+\n+    int64 nMyWakeTime = GetTimeMillis() + *((int64*)parg) * 1000;\n+\n+    ENTER_CRITICAL_SECTION(cs_nWalletUnlockTime);\n+\n+    if (nWalletUnlockTime == 0)\n+    {\n+        nWalletUnlockTime = nMyWakeTime;\n+\n+        do\n+        {\n+            if (nWalletUnlockTime==0)\n+                break;\n+            int64 nToSleep = nWalletUnlockTime - GetTimeMillis();\n+            if (nToSleep <= 0)\n+                break;\n+\n+            LEAVE_CRITICAL_SECTION(cs_nWalletUnlockTime);\n+            Sleep(nToSleep);\n+            ENTER_CRITICAL_SECTION(cs_nWalletUnlockTime);\n+\n+        } while(1);\n+\n+        if (nWalletUnlockTime)\n+        {\n+            nWalletUnlockTime = 0;\n+            pwalletMain->Lock();\n+        }\n+    }\n+    else\n+    {\n+        if (nWalletUnlockTime < nMyWakeTime)\n+            nWalletUnlockTime = nMyWakeTime;\n+    }\n+\n+    LEAVE_CRITICAL_SECTION(cs_nWalletUnlockTime);\n+\n+    delete (int64*)parg;\n+}\n+\n+Value walletpassphrase(const Array& params, bool fHelp)\n+{\n+    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n+        throw runtime_error(\n+            \"walletpassphrase <passphrase> <timeout>\\n\"\n+            \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+    if (fHelp)\n+        return true;\n+    if (!pwalletMain->IsCrypted())\n+        throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n+\n+    if (!pwalletMain->IsLocked())\n+        throw JSONRPCError(-17, \"Error: Wallet is already unlocked.\");\n+\n+    // Note that the walletpassphrase is stored in params[0] which is not mlock()ed\n+    SecureString strWalletPass;\n+    strWalletPass.reserve(100);\n+    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n+    // Alternately, find a way to make params[0] mlock()'d to begin with.\n+    strWalletPass = params[0].get_str().c_str();\n+\n+    if (strWalletPass.length() > 0)\n+    {\n+        if (!pwalletMain->Unlock(strWalletPass))\n+            throw JSONRPCError(-14, \"Error: The wallet passphrase entered was incorrect.\");\n+    }\n+    else\n+        throw runtime_error(\n+            \"walletpassphrase <passphrase> <timeout>\\n\"\n+            \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+\n+    CreateThread(ThreadTopUpKeyPool, NULL);\n+    int64* pnSleepTime = new int64(params[1].get_int64());\n+    CreateThread(ThreadCleanWalletPassphrase, pnSleepTime);\n+\n+    return Value::null;\n+}\n+\n+\n+Value walletpassphrasechange(const Array& params, bool fHelp)\n+{\n+    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 2))\n+        throw runtime_error(\n+            \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n+            \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n+    if (fHelp)\n+        return true;\n+    if (!pwalletMain->IsCrypted())\n+        throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n+\n+    // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n+    // Alternately, find a way to make params[0] mlock()'d to begin with.\n+    SecureString strOldWalletPass;\n+    strOldWalletPass.reserve(100);\n+    strOldWalletPass = params[0].get_str().c_str();\n+\n+    SecureString strNewWalletPass;\n+    strNewWalletPass.reserve(100);\n+    strNewWalletPass = params[1].get_str().c_str();\n+\n+    if (strOldWalletPass.length() < 1 || strNewWalletPass.length() < 1)\n+        throw runtime_error(\n+            \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n+            \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n+\n+    if (!pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n+        throw JSONRPCError(-14, \"Error: The wallet passphrase entered was incorrect.\");\n+\n+    return Value::null;\n+}\n+\n+\n+Value walletlock(const Array& params, bool fHelp)\n+{\n+    if (pwalletMain->IsCrypted() && (fHelp || params.size() != 0))\n+        throw runtime_error(\n+            \"walletlock\\n\"\n+            \"Removes the wallet encryption key from memory, locking the wallet.\\n\"\n+            \"After calling this method, you will need to call walletpassphrase again\\n\"\n+            \"before being able to call any methods which require the wallet to be unlocked.\");\n+    if (fHelp)\n+        return true;\n+    if (!pwalletMain->IsCrypted())\n+        throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n+\n+    {\n+        LOCK(cs_nWalletUnlockTime);\n+        pwalletMain->Lock();\n+        nWalletUnlockTime = 0;\n+    }\n+\n+    return Value::null;\n+}\n+\n+\n+Value encryptwallet(const Array& params, bool fHelp)\n+{\n+    if (!pwalletMain->IsCrypted() && (fHelp || params.size() != 1))\n+        throw runtime_error(\n+            \"encryptwallet <passphrase>\\n\"\n+            \"Encrypts the wallet with <passphrase>.\");\n+    if (fHelp)\n+        return true;\n+    if (pwalletMain->IsCrypted())\n+        throw JSONRPCError(-15, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n+\n+    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n+    // Alternately, find a way to make params[0] mlock()'d to begin with.\n+    SecureString strWalletPass;\n+    strWalletPass.reserve(100);\n+    strWalletPass = params[0].get_str().c_str();\n+\n+    if (strWalletPass.length() < 1)\n+        throw runtime_error(\n+            \"encryptwallet <passphrase>\\n\"\n+            \"Encrypts the wallet with <passphrase>.\");\n+\n+    if (!pwalletMain->EncryptWallet(strWalletPass))\n+        throw JSONRPCError(-16, \"Error: Failed to encrypt the wallet.\");\n+\n+    // BDB seems to have a bad habit of writing old data into\n+    // slack space in .dat files; that is bad if the old data is\n+    // unencrypted private keys.  So:\n+    StartShutdown();\n+    return \"wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet\";\n+}\n+\n+class DescribeAddressVisitor : public boost::static_visitor<Object>\n+{\n+public:\n+    Object operator()(const CNoDestination &dest) const { return Object(); }\n+\n+    Object operator()(const CKeyID &keyID) const {\n+        Object obj;\n+        CPubKey vchPubKey;\n+        pwalletMain->GetPubKey(keyID, vchPubKey);\n+        obj.push_back(Pair(\"isscript\", false));\n+        obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey.Raw())));\n+        obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n+        return obj;\n+    }\n+\n+    Object operator()(const CScriptID &scriptID) const {\n+        Object obj;\n+        obj.push_back(Pair(\"isscript\", true));\n+        CScript subscript;\n+        pwalletMain->GetCScript(scriptID, subscript);\n+        std::vector<CTxDestination> addresses;\n+        txnouttype whichType;\n+        int nRequired;\n+        ExtractDestinations(subscript, whichType, addresses, nRequired);\n+        obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n+        Array a;\n+        BOOST_FOREACH(const CTxDestination& addr, addresses)\n+            a.push_back(CBitcoinAddress(addr).ToString());\n+        obj.push_back(Pair(\"addresses\", a));\n+        if (whichType == TX_MULTISIG)\n+            obj.push_back(Pair(\"sigsrequired\", nRequired));\n+        return obj;\n+    }\n+};\n+\n+Value validateaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"validateaddress <bitcoinaddress>\\n\"\n+            \"Return information about <bitcoinaddress>.\");\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    bool isValid = address.IsValid();\n+\n+    Object ret;\n+    ret.push_back(Pair(\"isvalid\", isValid));\n+    if (isValid)\n+    {\n+        CTxDestination dest = address.Get();\n+        string currentAddress = address.ToString();\n+        ret.push_back(Pair(\"address\", currentAddress));\n+        bool fMine = IsMine(*pwalletMain, dest);\n+        ret.push_back(Pair(\"ismine\", fMine));\n+        if (fMine) {\n+            Object detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n+            ret.insert(ret.end(), detail.begin(), detail.end());\n+        }\n+        if (pwalletMain->mapAddressBook.count(dest))\n+            ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[dest]));\n+    }\n+    return ret;\n+}\n+"
      }
    ]
  },
  {
    "sha": "c625ae04d2fc8f55f282afafbcabfe5185bf0969",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjI1YWUwNGQyZmM4ZjU1ZjI4MmFmYWZiY2FiZmU1MTg1YmYwOTY5",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@exmulti.com",
        "date": "2012-08-21T15:03:38Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@redhat.com",
        "date": "2012-08-21T15:03:38Z"
      },
      "message": "RPC, cosmetic: move more RPC code to new rpcblockchain.cpp module",
      "tree": {
        "sha": "4ac5ac117e719697d1ef7ef19d845d7db9a8ae3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ac5ac117e719697d1ef7ef19d845d7db9a8ae3a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c625ae04d2fc8f55f282afafbcabfe5185bf0969",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c625ae04d2fc8f55f282afafbcabfe5185bf0969",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c625ae04d2fc8f55f282afafbcabfe5185bf0969",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c625ae04d2fc8f55f282afafbcabfe5185bf0969/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3bc56986508b40f894c7c707d39ea1bb437ebb5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3bc56986508b40f894c7c707d39ea1bb437ebb5"
      }
    ],
    "stats": {
      "total": 412,
      "additions": 215,
      "deletions": 197
    },
    "files": [
      {
        "sha": "ed84cbd03ca4cabfc80af3f0bf86f917774693a3",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -211,6 +211,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/rpcnet.cpp \\\n     src/rpcmining.cpp \\\n     src/rpcwallet.cpp \\\n+    src/rpcblockchain.cpp \\\n     src/rpcrawtransaction.cpp \\\n     src/qt/overviewpage.cpp \\\n     src/qt/csvmodelwriter.cpp \\"
      },
      {
        "sha": "d59deacd864dc9bf488a3dd00e468e4aea2fcc18",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 187,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -3,8 +3,6 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"main.h\"\n-#include \"net.h\"\n #include \"init.h\"\n #include \"util.h\"\n #include \"sync.h\"\n@@ -87,38 +85,6 @@ void RPCTypeCheck(const Object& o,\n     }\n }\n \n-double GetDifficulty(const CBlockIndex* blockindex = NULL)\n-{\n-    // Floating point number that is a multiple of the minimum difficulty,\n-    // minimum difficulty = 1.0.\n-    if (blockindex == NULL)\n-    {\n-        if (pindexBest == NULL)\n-            return 1.0;\n-        else\n-            blockindex = pindexBest;\n-    }\n-\n-    int nShift = (blockindex->nBits >> 24) & 0xff;\n-\n-    double dDiff =\n-        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n-\n-    while (nShift < 29)\n-    {\n-        dDiff *= 256.0;\n-        nShift++;\n-    }\n-    while (nShift > 29)\n-    {\n-        dDiff /= 256.0;\n-        nShift--;\n-    }\n-\n-    return dDiff;\n-}\n-\n-\n int64 AmountFromValue(const Value& value)\n {\n     double dAmount = value.get_real();\n@@ -146,34 +112,6 @@ HexBits(unsigned int nBits)\n     return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n }\n \n-Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n-{\n-    Object result;\n-    result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n-    CMerkleTx txGen(block.vtx[0]);\n-    txGen.SetMerkleBranch(&block);\n-    result.push_back(Pair(\"confirmations\", (int)txGen.GetDepthInMainChain()));\n-    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n-    result.push_back(Pair(\"height\", blockindex->nHeight));\n-    result.push_back(Pair(\"version\", block.nVersion));\n-    result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n-    Array txs;\n-    BOOST_FOREACH(const CTransaction&tx, block.vtx)\n-        txs.push_back(tx.GetHash().GetHex());\n-    result.push_back(Pair(\"tx\", txs));\n-    result.push_back(Pair(\"time\", (boost::int64_t)block.GetBlockTime()));\n-    result.push_back(Pair(\"nonce\", (boost::uint64_t)block.nNonce));\n-    result.push_back(Pair(\"bits\", HexBits(block.nBits)));\n-    result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n-\n-    if (blockindex->pprev)\n-        result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n-    if (blockindex->pnext)\n-        result.push_back(Pair(\"nextblockhash\", blockindex->pnext->GetBlockHash().GetHex()));\n-    return result;\n-}\n-\n-\n \n \n ///\n@@ -243,131 +181,6 @@ Value stop(const Array& params, bool fHelp)\n }\n \n \n-Value getblockcount(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"getblockcount\\n\"\n-            \"Returns the number of blocks in the longest block chain.\");\n-\n-    return nBestHeight;\n-}\n-\n-\n-Value getdifficulty(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"getdifficulty\\n\"\n-            \"Returns the proof-of-work difficulty as a multiple of the minimum difficulty.\");\n-\n-    return GetDifficulty();\n-}\n-\n-\n-Value getinfo(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"getinfo\\n\"\n-            \"Returns an object containing various state info.\");\n-\n-    CService addrProxy;\n-    GetProxy(NET_IPV4, addrProxy);\n-\n-    Object obj;\n-    obj.push_back(Pair(\"version\",       (int)CLIENT_VERSION));\n-    obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n-    obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n-    obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n-    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n-    obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"proxy\",         (addrProxy.IsValid() ? addrProxy.ToStringIPPort() : string())));\n-    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n-    obj.push_back(Pair(\"testnet\",       fTestNet));\n-    obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)pwalletMain->GetOldestKeyPoolTime()));\n-    obj.push_back(Pair(\"keypoolsize\",   pwalletMain->GetKeyPoolSize()));\n-    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(nTransactionFee)));\n-    if (pwalletMain->IsCrypted())\n-        obj.push_back(Pair(\"unlocked_until\", (boost::int64_t)nWalletUnlockTime / 1000));\n-    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n-    return obj;\n-}\n-\n-\n-Value settxfee(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 1 || params.size() > 1)\n-        throw runtime_error(\n-            \"settxfee <amount>\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\");\n-\n-    // Amount\n-    int64 nAmount = 0;\n-    if (params[0].get_real() != 0.0)\n-        nAmount = AmountFromValue(params[0]);        // rejects 0.0 amounts\n-\n-    nTransactionFee = nAmount;\n-    return true;\n-}\n-\n-Value getrawmempool(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"getrawmempool\\n\"\n-            \"Returns all transaction ids in memory pool.\");\n-\n-    vector<uint256> vtxid;\n-    mempool.queryHashes(vtxid);\n-\n-    Array a;\n-    BOOST_FOREACH(const uint256& hash, vtxid)\n-        a.push_back(hash.ToString());\n-\n-    return a;\n-}\n-\n-Value getblockhash(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getblockhash <index>\\n\"\n-            \"Returns hash of block in best-block-chain at <index>.\");\n-\n-    int nHeight = params[0].get_int();\n-    if (nHeight < 0 || nHeight > nBestHeight)\n-        throw runtime_error(\"Block number out of range.\");\n-\n-    CBlockIndex* pblockindex = FindBlockByHeight(nHeight);\n-    return pblockindex->phashBlock->GetHex();\n-}\n-\n-Value getblock(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getblock <hash>\\n\"\n-            \"Returns details of a block with given block-hash.\");\n-\n-    std::string strHash = params[0].get_str();\n-    uint256 hash(strHash);\n-\n-    if (mapBlockIndex.count(hash) == 0)\n-        throw JSONRPCError(-5, \"Block not found\");\n-\n-    CBlock block;\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n-    block.ReadFromDisk(pblockindex, true);\n-\n-    return blockToJSON(block, pblockindex);\n-}\n-\n-\n-\n-\n-\n-\n \n //\n // Call Table"
      },
      {
        "sha": "c845f1bc16e59089c2c5baf76eeec1959de0ae1f",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -10,6 +10,8 @@\n #include <list>\n #include <map>\n \n+class CBlockIndex;\n+\n #include \"json/json_spirit_reader_template.h\"\n #include \"json/json_spirit_writer_template.h\"\n #include \"json/json_spirit_utils.h\"\n@@ -73,6 +75,10 @@ extern const CRPCTable tableRPC;\n extern int64 nWalletUnlockTime;\n extern int64 AmountFromValue(const json_spirit::Value& value);\n extern json_spirit::Value ValueFromAmount(int64 amount);\n+extern double GetDifficulty(const CBlockIndex* blockindex = NULL);\n+extern std::string HexBits(unsigned int nBits);\n+extern std::string HelpRequiringPassphrase();\n+extern void EnsureWalletIsUnlocked();\n \n extern json_spirit::Value getconnectioncount(const json_spirit::Array& params, bool fHelp); // in rpcnet.cpp\n extern json_spirit::Value getpeerinfo(const json_spirit::Array& params, bool fHelp);\n@@ -115,6 +121,7 @@ extern json_spirit::Value walletpassphrasechange(const json_spirit::Array& param\n extern json_spirit::Value walletlock(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value encryptwallet(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value validateaddress(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getinfo(const json_spirit::Array& params, bool fHelp);\n \n extern json_spirit::Value getrawtransaction(const json_spirit::Array& params, bool fHelp); // in rcprawtransaction.cpp\n extern json_spirit::Value listunspent(const json_spirit::Array& params, bool fHelp);\n@@ -123,4 +130,11 @@ extern json_spirit::Value decoderawtransaction(const json_spirit::Array& params,\n extern json_spirit::Value signrawtransaction(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value sendrawtransaction(const json_spirit::Array& params, bool fHelp);\n \n+extern json_spirit::Value getblockcount(const json_spirit::Array& params, bool fHelp); // in rpcblockchain.cpp\n+extern json_spirit::Value getdifficulty(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value settxfee(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getrawmempool(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getblockhash(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp);\n+\n #endif"
      },
      {
        "sha": "e22a9f38eac95472002320dfbe105b1375442d6c",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -64,6 +64,7 @@ OBJS= \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n     obj/rpcwallet.o \\\n+    obj/rpcblockchain.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "74897656a969f3040a464c5a303887d564fdc3ec",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -60,6 +60,7 @@ OBJS= \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n     obj/rpcwallet.o \\\n+    obj/rpcblockchain.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "977878398cbd2a1e8509c23bde93005e3cc9cdd6",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -87,6 +87,7 @@ OBJS= \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n     obj/rpcwallet.o \\\n+    obj/rpcblockchain.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "de067f4ebba5dca719ef3ec1c39660e433959f31",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -112,6 +112,7 @@ OBJS= \\\n     obj/rpcnet.o \\\n     obj/rpcmining.o \\\n     obj/rpcwallet.o \\\n+    obj/rpcblockchain.o \\\n     obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\"
      },
      {
        "sha": "5469dd29521ea26821f9807fa059f8803c9894f7",
        "filename": "src/rpcblockchain.cpp",
        "status": "added",
        "additions": 165,
        "deletions": 0,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -0,0 +1,165 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"main.h\"\n+#include \"bitcoinrpc.h\"\n+\n+using namespace json_spirit;\n+using namespace std;\n+\n+double GetDifficulty(const CBlockIndex* blockindex)\n+{\n+    // Floating point number that is a multiple of the minimum difficulty,\n+    // minimum difficulty = 1.0.\n+    if (blockindex == NULL)\n+    {\n+        if (pindexBest == NULL)\n+            return 1.0;\n+        else\n+            blockindex = pindexBest;\n+    }\n+\n+    int nShift = (blockindex->nBits >> 24) & 0xff;\n+\n+    double dDiff =\n+        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n+\n+    while (nShift < 29)\n+    {\n+        dDiff *= 256.0;\n+        nShift++;\n+    }\n+    while (nShift > 29)\n+    {\n+        dDiff /= 256.0;\n+        nShift--;\n+    }\n+\n+    return dDiff;\n+}\n+\n+\n+Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n+{\n+    Object result;\n+    result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n+    CMerkleTx txGen(block.vtx[0]);\n+    txGen.SetMerkleBranch(&block);\n+    result.push_back(Pair(\"confirmations\", (int)txGen.GetDepthInMainChain()));\n+    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+    result.push_back(Pair(\"height\", blockindex->nHeight));\n+    result.push_back(Pair(\"version\", block.nVersion));\n+    result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n+    Array txs;\n+    BOOST_FOREACH(const CTransaction&tx, block.vtx)\n+        txs.push_back(tx.GetHash().GetHex());\n+    result.push_back(Pair(\"tx\", txs));\n+    result.push_back(Pair(\"time\", (boost::int64_t)block.GetBlockTime()));\n+    result.push_back(Pair(\"nonce\", (boost::uint64_t)block.nNonce));\n+    result.push_back(Pair(\"bits\", HexBits(block.nBits)));\n+    result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n+\n+    if (blockindex->pprev)\n+        result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n+    if (blockindex->pnext)\n+        result.push_back(Pair(\"nextblockhash\", blockindex->pnext->GetBlockHash().GetHex()));\n+    return result;\n+}\n+\n+\n+Value getblockcount(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw runtime_error(\n+            \"getblockcount\\n\"\n+            \"Returns the number of blocks in the longest block chain.\");\n+\n+    return nBestHeight;\n+}\n+\n+\n+Value getdifficulty(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw runtime_error(\n+            \"getdifficulty\\n\"\n+            \"Returns the proof-of-work difficulty as a multiple of the minimum difficulty.\");\n+\n+    return GetDifficulty();\n+}\n+\n+\n+Value settxfee(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+        throw runtime_error(\n+            \"settxfee <amount>\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\");\n+\n+    // Amount\n+    int64 nAmount = 0;\n+    if (params[0].get_real() != 0.0)\n+        nAmount = AmountFromValue(params[0]);        // rejects 0.0 amounts\n+\n+    nTransactionFee = nAmount;\n+    return true;\n+}\n+\n+Value getrawmempool(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw runtime_error(\n+            \"getrawmempool\\n\"\n+            \"Returns all transaction ids in memory pool.\");\n+\n+    vector<uint256> vtxid;\n+    mempool.queryHashes(vtxid);\n+\n+    Array a;\n+    BOOST_FOREACH(const uint256& hash, vtxid)\n+        a.push_back(hash.ToString());\n+\n+    return a;\n+}\n+\n+Value getblockhash(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getblockhash <index>\\n\"\n+            \"Returns hash of block in best-block-chain at <index>.\");\n+\n+    int nHeight = params[0].get_int();\n+    if (nHeight < 0 || nHeight > nBestHeight)\n+        throw runtime_error(\"Block number out of range.\");\n+\n+    CBlockIndex* pblockindex = FindBlockByHeight(nHeight);\n+    return pblockindex->phashBlock->GetHex();\n+}\n+\n+Value getblock(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getblock <hash>\\n\"\n+            \"Returns details of a block with given block-hash.\");\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(strHash);\n+\n+    if (mapBlockIndex.count(hash) == 0)\n+        throw JSONRPCError(-5, \"Block not found\");\n+\n+    CBlock block;\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+    block.ReadFromDisk(pblockindex, true);\n+\n+    return blockToJSON(block, pblockindex);\n+}\n+\n+\n+\n+\n+"
      },
      {
        "sha": "d2cb31f51dcee84ae9be0311c57f849a8f636945",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -11,9 +11,6 @@\n using namespace json_spirit;\n using namespace std;\n \n-extern double GetDifficulty(const CBlockIndex* blockindex = NULL);\n-extern std::string HexBits(unsigned int nBits);\n-\n Value getgenerate(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)"
      },
      {
        "sha": "a6b8553896e6dec70433fc03bde9a46da19a26c8",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -18,13 +18,6 @@ using namespace boost;\n using namespace boost::assign;\n using namespace json_spirit;\n \n-// These are all in bitcoinrpc.cpp:\n-extern Object JSONRPCError(int code, const string& message);\n-extern int64 AmountFromValue(const Value& value);\n-extern Value ValueFromAmount(int64 amount);\n-extern std::string HelpRequiringPassphrase();\n-extern void EnsureWalletIsUnlocked();\n-\n void\n ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out)\n {"
      },
      {
        "sha": "f74f3cb3ad9a30fc10c6039e09ed17d0d564e400",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c625ae04d2fc8f55f282afafbcabfe5185bf0969/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=c625ae04d2fc8f55f282afafbcabfe5185bf0969",
        "patch": "@@ -53,6 +53,37 @@ string AccountFromValue(const Value& value)\n     return strAccount;\n }\n \n+Value getinfo(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw runtime_error(\n+            \"getinfo\\n\"\n+            \"Returns an object containing various state info.\");\n+\n+    CService addrProxy;\n+    GetProxy(NET_IPV4, addrProxy);\n+\n+    Object obj;\n+    obj.push_back(Pair(\"version\",       (int)CLIENT_VERSION));\n+    obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n+    obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n+    obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n+    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n+    obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n+    obj.push_back(Pair(\"proxy\",         (addrProxy.IsValid() ? addrProxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n+    obj.push_back(Pair(\"testnet\",       fTestNet));\n+    obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)pwalletMain->GetOldestKeyPoolTime()));\n+    obj.push_back(Pair(\"keypoolsize\",   pwalletMain->GetKeyPoolSize()));\n+    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(nTransactionFee)));\n+    if (pwalletMain->IsCrypted())\n+        obj.push_back(Pair(\"unlocked_until\", (boost::int64_t)nWalletUnlockTime / 1000));\n+    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n+    return obj;\n+}\n+\n+\n+\n Value getnewaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 1)"
      }
    ]
  }
]