[
  {
    "sha": "b28916429203fb1122c8d12aa350c42587ba6274",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjg5MTY0MjkyMDNmYjExMjJjOGQxMmFhMzUwYzQyNTg3YmE2Mjc0",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2020-07-10T23:04:05Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2020-07-29T22:02:02Z"
      },
      "message": "Refactor {Dump,Load}Mempool to be more extensible",
      "tree": {
        "sha": "41e8836751fe58726f684551c2a4896906ff3e41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/41e8836751fe58726f684551c2a4896906ff3e41"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b28916429203fb1122c8d12aa350c42587ba6274",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b28916429203fb1122c8d12aa350c42587ba6274",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b28916429203fb1122c8d12aa350c42587ba6274",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b28916429203fb1122c8d12aa350c42587ba6274/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8db23349fe9b512e6801d59d17052c5a7a1c64df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8db23349fe9b512e6801d59d17052c5a7a1c64df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8db23349fe9b512e6801d59d17052c5a7a1c64df"
      }
    ],
    "stats": {
      "total": 175,
      "additions": 109,
      "deletions": 66
    },
    "files": [
      {
        "sha": "b7f1967fa047ac58370d4762465b6d1f6a815981",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 66,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b28916429203fb1122c8d12aa350c42587ba6274/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b28916429203fb1122c8d12aa350c42587ba6274/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b28916429203fb1122c8d12aa350c42587ba6274",
        "patch": "@@ -5032,7 +5032,7 @@ int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::D\n     return VersionBitsStateSinceHeight(::ChainActive().Tip(), params, pos, versionbitscache);\n }\n \n-static const uint64_t MEMPOOL_DUMP_VERSION = 1;\n+static const uint64_t MEMPOOL_DUMP_VERSION = 2;\n \n bool LoadMempool(CTxMemPool& pool)\n {\n@@ -5058,69 +5058,101 @@ bool LoadMempool(CTxMemPool& pool)\n         if (version != MEMPOOL_DUMP_VERSION) {\n             return false;\n         }\n-        uint64_t num;\n-        file >> num;\n-        while (num--) {\n-            CTransactionRef tx;\n-            int64_t nTime;\n-            int64_t nFeeDelta;\n-            file >> tx;\n-            file >> nTime;\n-            file >> nFeeDelta;\n-\n-            CAmount amountdelta = nFeeDelta;\n-            if (amountdelta) {\n-                pool.PrioritiseTransaction(tx->GetHash(), amountdelta);\n+        std::map<std::string, std::vector<unsigned char>> mapData;\n+        file >> mapData;\n+\n+        auto it = mapData.find(\"deltas\");\n+        if (it != mapData.end()) {\n+            try {\n+                CDataStream ss(it->second, SER_DISK, CLIENT_VERSION);\n+                std::map<uint256, std::pair<double, CAmount>> mapDeltas;\n+                ss >> mapDeltas;\n+                LOCK(pool.cs);\n+                for (const auto& it : mapDeltas) {\n+                    const uint256& txid = it.first;\n+                    const CAmount& amountdelta = it.second.second;\n+                    pool.PrioritiseTransaction(txid, amountdelta);\n+                }\n+            } catch (const std::exception& e) {\n+                LogPrintf(\"Failed to deserialize mempool %s from disk: %s. Continuing anyway.\\n\", \"deltas\", e.what());\n             }\n-            TxValidationState state;\n-            if (nTime + nExpiryTimeout > nNow) {\n-                LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nTime,\n-                                           nullptr /* plTxnReplaced */, false /* bypass_limits */, 0 /* nAbsurdFee */,\n-                                           false /* test_accept */);\n-                if (state.IsValid()) {\n-                    ++count;\n-                } else {\n+        }\n+\n+        it = mapData.find(\"unbroadcast_txids\");\n+        if (it != mapData.end()) {\n+            std::map<uint256, uint256> unbroadcast_txids;\n+            try {\n+                CDataStream ss(it->second, SER_DISK, CLIENT_VERSION);\n+                ss >> unbroadcast_txids;\n+                unbroadcast = unbroadcast_txids.size();\n+            } catch (const std::exception& e) {\n+                LogPrintf(\"Failed to deserialize mempool %s from disk: %s. Continuing anyway.\\n\", \"unbroadcast txids\", e.what());\n+            }\n+            for (const auto& elem : unbroadcast_txids) {\n+                // Don't add unbroadcast transactions that didn't get back into the\n+                // mempool.\n+                const CTransactionRef& added_tx = pool.get(elem.first);\n+                if (added_tx != nullptr) {\n+                    pool.AddUnbroadcastTx(elem.first, added_tx->GetWitnessHash());\n+                }\n+            }\n+        }\n+\n+        it = mapData.find(\"txs\");\n+        if (it != mapData.end()) {\n+            std::vector<std::map<std::string, std::vector<unsigned char>>> txMapDatas;\n+            try {\n+                CDataStream(it->second, SER_DISK, CLIENT_VERSION) >> txMapDatas;\n+            } catch (const std::exception& e) {\n+                LogPrintf(\"Failed to deserialize mempool %s from disk: %s. Continuing anyway.\\n\", \"transactions\", e.what());\n+            }\n+            for (auto mapTxData : txMapDatas) {\n+                try {\n+                    it = mapTxData.find(\"t\");\n+                    if (it == mapTxData.end()) {\n+                        throw std::runtime_error(\"mapTxData \\\"t\\\" key missing\");\n+                    }\n+                    int64_t nTime;\n+                    CDataStream(it->second, SER_DISK, CLIENT_VERSION) >> nTime;\n+                    if (nTime + nExpiryTimeout <= nNow) {\n+                        ++expired;\n+                        continue;\n+                    }\n+\n+                    it = mapTxData.find(\"\");\n+                    if (it == mapTxData.end()) {\n+                        throw std::runtime_error(\"mapTxData null key missing\");\n+                    }\n+                    CDataStream ssTx(it->second, SER_DISK, CLIENT_VERSION);\n+                    CTransactionRef tx;\n+                    ssTx >> tx;\n+\n                     // mempool may contain the transaction already, e.g. from\n                     // wallet(s) having loaded it while we were processing\n                     // mempool transactions; consider these as valid, instead of\n-                    // failed, but mark them as 'already there'\n+                    // failing, but mark them as 'already there'\n                     if (pool.exists(tx->GetHash())) {\n+                        ++count;\n                         ++already_there;\n-                    } else {\n-                        ++failed;\n+                        continue;\n+                    }\n+\n+                    TxValidationState state;\n+                    LOCK(cs_main);\n+                    AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nTime,\n+                                               nullptr /* plTxnReplaced */, false /* bypass_limits */, 0 /* nAbsurdFee */,\n+                                               false /* test_accept */);\n+                    if (!state.IsValid()) {\n+                        throw std::runtime_error(state.GetRejectReason());\n                     }\n+                    ++count;\n+                } catch (const std::exception& e) {\n+                    ++failed;\n                 }\n-            } else {\n-                ++expired;\n             }\n             if (ShutdownRequested())\n                 return false;\n         }\n-        std::map<uint256, CAmount> mapDeltas;\n-        file >> mapDeltas;\n-\n-        for (const auto& i : mapDeltas) {\n-            pool.PrioritiseTransaction(i.first, i.second);\n-        }\n-\n-        // TODO: remove this try except in v0.22\n-        std::map<uint256, uint256> unbroadcast_txids;\n-        try {\n-          file >> unbroadcast_txids;\n-          unbroadcast = unbroadcast_txids.size();\n-        } catch (const std::exception&) {\n-          // mempool.dat files created prior to v0.21 will not have an\n-          // unbroadcast set. No need to log a failure if parsing fails here.\n-        }\n-        for (const auto& elem : unbroadcast_txids) {\n-            // Don't add unbroadcast transactions that didn't get back into the\n-            // mempool.\n-            const CTransactionRef& added_tx = pool.get(elem.first);\n-            if (added_tx != nullptr) {\n-                pool.AddUnbroadcastTx(elem.first, added_tx->GetWitnessHash());\n-            }\n-        }\n     } catch (const std::exception& e) {\n         LogPrintf(\"Failed to deserialize mempool data on disk: %s. Continuing anyway.\\n\", e.what());\n         return false;\n@@ -5130,12 +5162,19 @@ bool LoadMempool(CTxMemPool& pool)\n     return true;\n }\n \n+template <class T>\n+std::vector<unsigned char> SerializeToVector(T o) {\n+    CDataStream ss(SER_DISK, CLIENT_VERSION);\n+    ss << o;\n+    return std::vector<unsigned char>(ss.begin(), ss.end());\n+}\n+\n bool DumpMempool(const CTxMemPool& pool)\n {\n     int64_t start = GetTimeMicros();\n \n-    std::map<uint256, CAmount> mapDeltas;\n     std::vector<TxMempoolInfo> vinfo;\n+    std::map<uint256, std::pair<double, CAmount>> mapDeltas;\n     std::map<uint256, uint256> unbroadcast_txids;\n \n     static Mutex dump_mutex;\n@@ -5144,7 +5183,7 @@ bool DumpMempool(const CTxMemPool& pool)\n     {\n         LOCK(pool.cs);\n         for (const auto &i : pool.mapDeltas) {\n-            mapDeltas[i.first] = i.second;\n+            mapDeltas[i.first] = std::make_pair(0.0, i.second);\n         }\n         vinfo = pool.infoAll();\n         unbroadcast_txids = pool.GetUnbroadcastTxs();\n@@ -5153,6 +5192,21 @@ bool DumpMempool(const CTxMemPool& pool)\n     int64_t mid = GetTimeMicros();\n \n     try {\n+        std::map<std::string, std::vector<unsigned char>> mapData;\n+        mapData[\"deltas\"] = SerializeToVector(mapDeltas);\n+        {\n+            std::vector<std::map<std::string, std::vector<unsigned char>>> txMapDatas;\n+            for (TxMempoolInfo info : vinfo) {\n+                std::map<std::string, std::vector<unsigned char>> mapTxData;\n+                mapTxData[\"\"] = SerializeToVector(*(info.tx));\n+                mapTxData[\"t\"] = SerializeToVector(count_seconds(info.m_time));\n+                txMapDatas.push_back(std::move(mapTxData));\n+            }\n+\n+            mapData[\"txs\"] = SerializeToVector(txMapDatas);\n+        }\n+        mapData[\"unbroadcast_txids\"] = SerializeToVector(unbroadcast_txids);\n+\n         FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat.new\", \"wb\");\n         if (!filestr) {\n             return false;\n@@ -5163,18 +5217,7 @@ bool DumpMempool(const CTxMemPool& pool)\n         uint64_t version = MEMPOOL_DUMP_VERSION;\n         file << version;\n \n-        file << (uint64_t)vinfo.size();\n-        for (const auto& i : vinfo) {\n-            file << *(i.tx);\n-            file << int64_t{count_seconds(i.m_time)};\n-            file << int64_t{i.nFeeDelta};\n-            mapDeltas.erase(i.tx->GetHash());\n-        }\n-\n-        file << mapDeltas;\n-\n-        LogPrintf(\"Writing %d unbroadcast transactions to disk.\\n\", unbroadcast_txids.size());\n-        file << unbroadcast_txids;\n+        file << mapData;\n \n         if (!FileCommit(file.Get()))\n             throw std::runtime_error(\"FileCommit failed\");"
      }
    ]
  },
  {
    "sha": "1befffc0b4863b435c89d7f4a658f0a6407cb728",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYmVmZmZjMGI0ODYzYjQzNWM4OWQ3ZjRhNjU4ZjBhNjQwN2NiNzI4",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2016-12-25T06:04:55Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2020-07-29T22:02:03Z"
      },
      "message": "Store mempool min fee state in mempool.dat",
      "tree": {
        "sha": "bd7c35036881fc799484e2d026579a6f0ffeb7fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd7c35036881fc799484e2d026579a6f0ffeb7fb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1befffc0b4863b435c89d7f4a658f0a6407cb728",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1befffc0b4863b435c89d7f4a658f0a6407cb728",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1befffc0b4863b435c89d7f4a658f0a6407cb728",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1befffc0b4863b435c89d7f4a658f0a6407cb728/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b28916429203fb1122c8d12aa350c42587ba6274",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b28916429203fb1122c8d12aa350c42587ba6274",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b28916429203fb1122c8d12aa350c42587ba6274"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 32,
      "deletions": 1
    },
    "files": [
      {
        "sha": "c9fb2c9cb484e56a9fba223ff5509fa8e3d96860",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1befffc0b4863b435c89d7f4a658f0a6407cb728/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1befffc0b4863b435c89d7f4a658f0a6407cb728/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=1befffc0b4863b435c89d7f4a658f0a6407cb728",
        "patch": "@@ -675,6 +675,22 @@ class CTxMemPool\n      *  already in it.  */\n     void CalculateDescendants(txiter it, setEntries& setDescendants) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    template<typename Stream>\n+    void DumpMinFeeInternal(Stream& s) const {\n+        LOCK(cs);\n+        s << rollingMinimumFeeRate;\n+        s << blockSinceLastRollingFeeBump;\n+        s << lastRollingFeeUpdate;\n+    }\n+\n+    template<typename Stream>\n+    void LoadMinFeeInternal(Stream& s) {\n+        LOCK(cs);\n+        s >> rollingMinimumFeeRate;\n+        s >> blockSinceLastRollingFeeBump;\n+        s >> lastRollingFeeUpdate;\n+    }\n+\n     /** The minimum fee to get into the mempool, which may itself not be enough\n       *  for larger-sized transactions.\n       *  The incrementalRelayFee policy variable is used to bound the time it"
      },
      {
        "sha": "9ce6f63c1358e42e1775b055ebc5756072d08ceb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1befffc0b4863b435c89d7f4a658f0a6407cb728/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1befffc0b4863b435c89d7f4a658f0a6407cb728/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1befffc0b4863b435c89d7f4a658f0a6407cb728",
        "patch": "@@ -5061,7 +5061,17 @@ bool LoadMempool(CTxMemPool& pool)\n         std::map<std::string, std::vector<unsigned char>> mapData;\n         file >> mapData;\n \n-        auto it = mapData.find(\"deltas\");\n+        auto it = mapData.find(\"minfee\");\n+        if (it != mapData.end()) {\n+            try {\n+                CDataStream ss(it->second, SER_DISK, CLIENT_VERSION);\n+                mempool.LoadMinFeeInternal(ss);\n+            } catch (const std::exception& e) {\n+                LogPrintf(\"Failed to deserialize mempool %s from disk: %s. Continuing anyway.\\n\", \"minfee\", e.what());\n+            }\n+        }\n+\n+        it = mapData.find(\"deltas\");\n         if (it != mapData.end()) {\n             try {\n                 CDataStream ss(it->second, SER_DISK, CLIENT_VERSION);\n@@ -5206,6 +5216,11 @@ bool DumpMempool(const CTxMemPool& pool)\n             mapData[\"txs\"] = SerializeToVector(txMapDatas);\n         }\n         mapData[\"unbroadcast_txids\"] = SerializeToVector(unbroadcast_txids);\n+        {\n+            CDataStream ss(SER_DISK, CLIENT_VERSION);\n+            mempool.DumpMinFeeInternal(ss);\n+            mapData[\"minfee\"] = std::vector<unsigned char>(ss.begin(), ss.end());\n+        }\n \n         FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat.new\", \"wb\");\n         if (!filestr) {"
      }
    ]
  }
]