[
  {
    "sha": "e95568b78ddead0173339ca98df6cd92131ceb62",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTU1NjhiNzhkZGVhZDAxNzMzMzljYTk4ZGY2Y2Q5MjEzMWNlYjYy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2012-08-22T09:34:32Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2012-08-23T04:55:35Z"
      },
      "message": "Handle locked pages more robustly (Fixes issue #1462)\n\nMemory locks do not stack, that is, pages which have been locked several times by calls to mlock()\nwill be unlocked by a single call to munlock(). This can result in keying material ending up in swap when\nthose functions are used naively. In this commit a class \"LockedPageManager\" is added\nthat simulates stacking memory locks by keeping a counter per page.",
      "tree": {
        "sha": "3860dc256f0c80a4764ef79bb1fa6fa3ec814392",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3860dc256f0c80a4764ef79bb1fa6fa3ec814392"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e95568b78ddead0173339ca98df6cd92131ceb62",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e95568b78ddead0173339ca98df6cd92131ceb62",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e95568b78ddead0173339ca98df6cd92131ceb62",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e95568b78ddead0173339ca98df6cd92131ceb62/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fedd060d819e671388e9996f55af7a70f270f0b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fedd060d819e671388e9996f55af7a70f270f0b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fedd060d819e671388e9996f55af7a70f270f0b9"
      }
    ],
    "stats": {
      "total": 282,
      "additions": 267,
      "deletions": 15
    },
    "files": [
      {
        "sha": "99afa10c255829a2769dcbf7233c5943549aac3c",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 150,
        "deletions": 15,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e95568b78ddead0173339ca98df6cd92131ceb62/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e95568b78ddead0173339ca98df6cd92131ceb62/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=e95568b78ddead0173339ca98df6cd92131ceb62",
        "patch": "@@ -7,6 +7,8 @@\n \n #include <string.h>\n #include <string>\n+#include <boost/thread/mutex.hpp>\n+#include <map>\n \n #ifdef WIN32\n #ifdef _WIN32_WINNT\n@@ -22,23 +24,156 @@\n // Note that VirtualLock does not provide this as a guarantee on Windows,\n // but, in practice, memory that has been VirtualLock'd almost never gets written to\n // the pagefile except in rare circumstances where memory is extremely low.\n-#define mlock(p, n) VirtualLock((p), (n));\n-#define munlock(p, n) VirtualUnlock((p), (n));\n #else\n #include <sys/mman.h>\n-#include <limits.h>\n-/* This comes from limits.h if it's not defined there set a sane default */\n-#ifndef PAGESIZE\n-#include <unistd.h>\n-#define PAGESIZE sysconf(_SC_PAGESIZE)\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n #endif\n-#define mlock(a,b) \\\n-  mlock(((void *)(((size_t)(a)) & (~((PAGESIZE)-1)))),\\\n-  (((((size_t)(a)) + (b) - 1) | ((PAGESIZE) - 1)) + 1) - (((size_t)(a)) & (~((PAGESIZE) - 1))))\n-#define munlock(a,b) \\\n-  munlock(((void *)(((size_t)(a)) & (~((PAGESIZE)-1)))),\\\n-  (((((size_t)(a)) + (b) - 1) | ((PAGESIZE) - 1)) + 1) - (((size_t)(a)) & (~((PAGESIZE) - 1))))\n+\n+/**\n+ * Thread-safe class to keep track of locked (ie, non-swappable) memory pages.\n+ *\n+ * Memory locks do not stack, that is, pages which have been locked several times by calls to mlock()\n+ * will be unlocked by a single call to munlock(). This can result in keying material ending up in swap when\n+ * those functions are used naively. This class simulates stacking memory locks by keeping a counter per page.\n+ *\n+ * @note By using a map from each page base address to lock count, this class is optimized for\n+ * small objects that span up to a few pages, mostly smaller than a page. To support large allocations,\n+ * something like an interval tree would be the preferred data structure.\n+ */\n+template <class Locker> class LockedPageManagerBase\n+{\n+public:\n+    LockedPageManagerBase(size_t page_size):\n+        page_size(page_size)\n+    {\n+        // Determine bitmask for extracting page from address\n+        assert(!(page_size & (page_size-1))); // size must be power of two\n+        page_mask = ~(page_size - 1);\n+    }\n+\n+    // For all pages in affected range, increase lock count\n+    void LockRange(void *p, size_t size)\n+    {\n+        boost::mutex::scoped_lock lock(mutex);\n+        if(!size) return;\n+        const size_t base_addr = reinterpret_cast<size_t>(p);\n+        const size_t start_page = base_addr & page_mask;\n+        const size_t end_page = (base_addr + size - 1) & page_mask;\n+        for(size_t page = start_page; page <= end_page; page += page_size)\n+        {\n+            Histogram::iterator it = histogram.find(page);\n+            if(it == histogram.end()) // Newly locked page\n+            {\n+                locker.Lock(reinterpret_cast<void*>(page), page_size);\n+                histogram.insert(std::make_pair(page, 1));\n+            }\n+            else // Page was already locked; increase counter\n+            {\n+                it->second += 1;\n+            }\n+        }\n+    }\n+\n+    // For all pages in affected range, decrease lock count\n+    void UnlockRange(void *p, size_t size)\n+    {\n+        boost::mutex::scoped_lock lock(mutex);\n+        if(!size) return;\n+        const size_t base_addr = reinterpret_cast<size_t>(p);\n+        const size_t start_page = base_addr & page_mask;\n+        const size_t end_page = (base_addr + size - 1) & page_mask;\n+        for(size_t page = start_page; page <= end_page; page += page_size)\n+        {\n+            Histogram::iterator it = histogram.find(page);\n+            assert(it != histogram.end()); // Cannot unlock an area that was not locked\n+            // Decrease counter for page, when it is zero, the page will be unlocked\n+            it->second -= 1;\n+            if(it->second == 0) // Nothing on the page anymore that keeps it locked\n+            {\n+                // Unlock page and remove the count from histogram\n+                locker.Unlock(reinterpret_cast<void*>(page), page_size);\n+                histogram.erase(it);\n+            }\n+        }\n+    }\n+\n+    // Get number of locked pages for diagnostics\n+    int GetLockedPageCount()\n+    {\n+        boost::mutex::scoped_lock lock(mutex);\n+        return histogram.size();\n+    }\n+\n+private:\n+    Locker locker;\n+    boost::mutex mutex;\n+    size_t page_size, page_mask;\n+    // map of page base address to lock count\n+    typedef std::map<size_t,int> Histogram;\n+    Histogram histogram;\n+};\n+\n+/** Determine system page size in bytes */\n+static inline size_t GetSystemPageSize()\n+{\n+    size_t page_size;\n+#if defined(WIN32)\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+#elif defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+    return page_size;\n+}\n+\n+/**\n+ * OS-dependent memory page locking/unlocking.\n+ * Defined as policy class to make stubbing for test possible.\n+ */\n+class MemoryPageLocker\n+{\n+public:\n+    /** Lock memory pages.\n+     * addr and len must be a multiple of the system page size\n+     */\n+    bool Lock(const void *addr, size_t len)\n+    {\n+#ifdef WIN32\n+        return VirtualLock(const_cast<void*>(addr), len);\n+#else\n+        return mlock(addr, len) == 0;\n+#endif\n+    }\n+    /** Unlock memory pages.\n+     * addr and len must be a multiple of the system page size\n+     */\n+    bool Unlock(const void *addr, size_t len)\n+    {\n+#ifdef WIN32\n+        return VirtualUnlock(const_cast<void*>(addr), len);\n+#else\n+        return munlock(addr, len) == 0;\n #endif\n+    }\n+};\n+\n+/**\n+ * Singleton class to keep track of locked (ie, non-swappable) memory pages, for use in\n+ * std::allocator templates.\n+ */\n+class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n+{\n+public:\n+    static LockedPageManager instance; // instantiated in util.cpp\n+private:\n+    LockedPageManager():\n+        LockedPageManagerBase<MemoryPageLocker>(GetSystemPageSize())\n+    {}\n+};\n \n //\n // Allocator that locks its contents from being paged\n@@ -69,7 +204,7 @@ struct secure_allocator : public std::allocator<T>\n         T *p;\n         p = std::allocator<T>::allocate(n, hint);\n         if (p != NULL)\n-            mlock(p, sizeof(T) * n);\n+            LockedPageManager::instance.LockRange(p, sizeof(T) * n);\n         return p;\n     }\n \n@@ -78,7 +213,7 @@ struct secure_allocator : public std::allocator<T>\n         if (p != NULL)\n         {\n             memset(p, 0, sizeof(T) * n);\n-            munlock(p, sizeof(T) * n);\n+            LockedPageManager::instance.UnlockRange(p, sizeof(T) * n);\n         }\n         std::allocator<T>::deallocate(p, n);\n     }"
      },
      {
        "sha": "d5cb8e81019ea585f75151343a8d1181ee2d2ccc",
        "filename": "src/test/allocator_tests.cpp",
        "status": "added",
        "additions": 115,
        "deletions": 0,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e95568b78ddead0173339ca98df6cd92131ceb62/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e95568b78ddead0173339ca98df6cd92131ceb62/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=e95568b78ddead0173339ca98df6cd92131ceb62",
        "patch": "@@ -0,0 +1,115 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"init.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+BOOST_AUTO_TEST_SUITE(allocator_tests)\n+\n+// Dummy memory page locker for platform independent tests\n+static const void *last_lock_addr, *last_unlock_addr;\n+static size_t last_lock_len, last_unlock_len;\n+class TestLocker\n+{\n+public:\n+    bool Lock(const void *addr, size_t len)\n+    {\n+        last_lock_addr = addr;\n+        last_lock_len = len;\n+        return true;\n+    }\n+    bool Unlock(const void *addr, size_t len)\n+    {\n+        last_unlock_addr = addr;\n+        last_unlock_len = len;\n+        return true;\n+    }\n+};\n+\n+BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n+{\n+    const size_t test_page_size = 4096;\n+    LockedPageManagerBase<TestLocker> lpm(test_page_size);\n+    size_t addr;\n+    last_lock_addr = last_unlock_addr = 0;\n+    last_lock_len = last_unlock_len = 0;\n+\n+    /* Try large number of small objects */\n+    addr = 0;\n+    for(int i=0; i<1000; ++i)\n+    {\n+        lpm.LockRange(reinterpret_cast<void*>(addr), 33);\n+        addr += 33;\n+    }\n+    /* Try small number of page-sized objects, straddling two pages */\n+    addr = test_page_size*100 + 53;\n+    for(int i=0; i<100; ++i)\n+    {\n+        lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n+        addr += test_page_size;\n+    }\n+    /* Try small number of page-sized objects aligned to exactly one page */\n+    addr = test_page_size*300;\n+    for(int i=0; i<100; ++i)\n+    {\n+        lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n+        addr += test_page_size;\n+    }\n+    /* one very large object, straddling pages */\n+    lpm.LockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n+    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(600+500)));\n+    /* one very large object, page aligned */\n+    lpm.LockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n+    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(1200+500-1)));\n+\n+    BOOST_CHECK(lpm.GetLockedPageCount() == (\n+        (1000*33+test_page_size-1)/test_page_size + // small objects\n+        101 + 100 +  // page-sized objects\n+        501 + 500)); // large objects\n+    BOOST_CHECK((last_lock_len & (test_page_size-1)) == 0); // always lock entire pages\n+    BOOST_CHECK(last_unlock_len == 0); // nothing unlocked yet\n+\n+    /* And unlock again */\n+    addr = 0;\n+    for(int i=0; i<1000; ++i)\n+    {\n+        lpm.UnlockRange(reinterpret_cast<void*>(addr), 33);\n+        addr += 33;\n+    }\n+    addr = test_page_size*100 + 53;\n+    for(int i=0; i<100; ++i)\n+    {\n+        lpm.UnlockRange(reinterpret_cast<void*>(addr), test_page_size);\n+        addr += test_page_size;\n+    }\n+    addr = test_page_size*300;\n+    for(int i=0; i<100; ++i)\n+    {\n+        lpm.UnlockRange(reinterpret_cast<void*>(addr), test_page_size);\n+        addr += test_page_size;\n+    }\n+    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n+    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n+\n+    /* Check that everything is released */\n+    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n+\n+    /* A few and unlocks of size zero (should have no effect) */\n+    addr = 0;\n+    for(int i=0; i<1000; ++i)\n+    {\n+        lpm.LockRange(reinterpret_cast<void*>(addr), 0);\n+        addr += 1;\n+    }\n+    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n+    addr = 0;\n+    for(int i=0; i<1000; ++i)\n+    {\n+        lpm.UnlockRange(reinterpret_cast<void*>(addr), 0);\n+        addr += 1;\n+    }\n+    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n+    BOOST_CHECK((last_unlock_len & (test_page_size-1)) == 0); // always unlock entire pages\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "461f42d1774f6288d6f027ad7c03d4cd07acd1a7",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e95568b78ddead0173339ca98df6cd92131ceb62/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e95568b78ddead0173339ca98df6cd92131ceb62/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=e95568b78ddead0173339ca98df6cd92131ceb62",
        "patch": "@@ -86,6 +86,8 @@ void locking_callback(int mode, int i, const char* file, int line)\n     }\n }\n \n+LockedPageManager LockedPageManager::instance;\n+\n // Init\n class CInit\n {"
      }
    ]
  },
  {
    "sha": "0b886ad1bda23c01a68d0ebeac9ec480ca5690fd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYjg4NmFkMWJkYTIzYzAxYTY4ZDBlYmVhYzllYzQ4MGNhNTY5MGZk",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2012-08-22T11:39:21Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2012-08-23T04:55:35Z"
      },
      "message": "Make CCrypter use LockedPageManager to manage locked pages\n\nReplace direct calls to mlock.\n\nAlso, change the class to lock the memory areas in the constructor and unlock them again in the destructor. This makes sure that locked pages won't leak.",
      "tree": {
        "sha": "91ab9f3d614af27d73e6e8266bd2249495a7ed62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91ab9f3d614af27d73e6e8266bd2249495a7ed62"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e95568b78ddead0173339ca98df6cd92131ceb62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e95568b78ddead0173339ca98df6cd92131ceb62",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e95568b78ddead0173339ca98df6cd92131ceb62"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 9,
      "deletions": 14
    },
    "files": [
      {
        "sha": "181b8fa00a9ce50b4f6a138cd3f14a3f00aa6916",
        "filename": "src/crypter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=0b886ad1bda23c01a68d0ebeac9ec480ca5690fd",
        "patch": "@@ -17,12 +17,6 @@ bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::v\n     if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n         return false;\n \n-    // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n-    // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n-    // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.  \n-    mlock(&chKey[0], sizeof chKey);\n-    mlock(&chIV[0], sizeof chIV);\n-\n     int i = 0;\n     if (nDerivationMethod == 0)\n         i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n@@ -44,12 +38,6 @@ bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigne\n     if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n         return false;\n \n-    // Try to keep the key data out of swap\n-    // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n-    // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.  \n-    mlock(&chKey[0], sizeof chKey);\n-    mlock(&chIV[0], sizeof chIV);\n-\n     memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n     memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n "
      },
      {
        "sha": "04538a3fa51539451df971725a0bf647fdbf4f22",
        "filename": "src/crypter.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b886ad1bda23c01a68d0ebeac9ec480ca5690fd/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=0b886ad1bda23c01a68d0ebeac9ec480ca5690fd",
        "patch": "@@ -78,19 +78,26 @@ class CCrypter\n     {\n         memset(&chKey, 0, sizeof chKey);\n         memset(&chIV, 0, sizeof chIV);\n-        munlock(&chKey, sizeof chKey);\n-        munlock(&chIV, sizeof chIV);\n         fKeySet = false;\n     }\n \n     CCrypter()\n     {\n         fKeySet = false;\n+\n+        // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n+        // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n+        // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.\n+        LockedPageManager::instance.LockRange(&chKey[0], sizeof chKey);\n+        LockedPageManager::instance.LockRange(&chIV[0], sizeof chIV);\n     }\n \n     ~CCrypter()\n     {\n         CleanKey();\n+\n+        LockedPageManager::instance.UnlockRange(&chKey[0], sizeof chKey);\n+        LockedPageManager::instance.UnlockRange(&chIV[0], sizeof chIV);\n     }\n };\n "
      }
    ]
  }
]