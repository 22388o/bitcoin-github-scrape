[
  {
    "sha": "e2073424fd5a185781750347fbfbb0c108ef66fd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMjA3MzQyNGZkNWExODU3ODE3NTAzNDdmYmZiYjBjMTA4ZWY2NmZk",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-09T16:13:37Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-20T23:18:59Z"
      },
      "message": "Fix CCheckQueue IsIdle (potential) race condition and remove dangerous constructors.",
      "tree": {
        "sha": "a5946f8ef62e3545b9e10edef17d3d56b2a0b4eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5946f8ef62e3545b9e10edef17d3d56b2a0b4eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2073424fd5a185781750347fbfbb0c108ef66fd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2073424fd5a185781750347fbfbb0c108ef66fd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e2073424fd5a185781750347fbfbb0c108ef66fd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2073424fd5a185781750347fbfbb0c108ef66fd/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25720fc394e27a951bcad26095fb5a711bfacb8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25720fc394e27a951bcad26095fb5a711bfacb8f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25720fc394e27a951bcad26095fb5a711bfacb8f"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 12,
      "deletions": 10
    },
    "files": [
      {
        "sha": "ea12df66dd0e5caf8f021b1a9271eab606bd94d3",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 12,
        "deletions": 10,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e2073424fd5a185781750347fbfbb0c108ef66fd/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e2073424fd5a185781750347fbfbb0c108ef66fd/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=e2073424fd5a185781750347fbfbb0c108ef66fd",
        "patch": "@@ -127,6 +127,9 @@ class CCheckQueue\n     }\n \n public:\n+    //! Mutex to ensure only one concurrent CCheckQueueControl\n+    boost::mutex ControlMutex;\n+\n     //! Create a new check queue\n     CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n \n@@ -161,12 +164,6 @@ class CCheckQueue\n     {\n     }\n \n-    bool IsIdle()\n-    {\n-        boost::unique_lock<boost::mutex> lock(mutex);\n-        return (nTotal == nIdle && nTodo == 0 && fAllOk == true);\n-    }\n-\n };\n \n /** \n@@ -177,16 +174,18 @@ template <typename T>\n class CCheckQueueControl\n {\n private:\n-    CCheckQueue<T>* pqueue;\n+    CCheckQueue<T> * const pqueue;\n     bool fDone;\n \n public:\n-    CCheckQueueControl(CCheckQueue<T>* pqueueIn) : pqueue(pqueueIn), fDone(false)\n+    CCheckQueueControl() = delete;\n+    CCheckQueueControl(const CCheckQueueControl&) = delete;\n+    CCheckQueueControl& operator=(const CCheckQueueControl&) = delete;\n+    explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn) : pqueue(pqueueIn), fDone(false)\n     {\n         // passed queue is supposed to be unused, or NULL\n         if (pqueue != NULL) {\n-            bool isIdle = pqueue->IsIdle();\n-            assert(isIdle);\n+            ENTER_CRITICAL_SECTION(pqueue->ControlMutex);\n         }\n     }\n \n@@ -209,6 +208,9 @@ class CCheckQueueControl\n     {\n         if (!fDone)\n             Wait();\n+        if (pqueue != NULL) {\n+            LEAVE_CRITICAL_SECTION(pqueue->ControlMutex);\n+        }\n     }\n };\n "
      }
    ]
  },
  {
    "sha": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NmM3ZjJjMzQ1ODk1MDA2MWIwNTdmY2QzZGFhZjQ3YjU3ZTZiYWM3",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-08T00:51:23Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-02-16T06:37:53Z"
      },
      "message": "Add CheckQueue Tests",
      "tree": {
        "sha": "750bdc0c450e7427c74ab6be39c9afd84d66d534",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/750bdc0c450e7427c74ab6be39c9afd84d66d534"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96c7f2c3458950061b057fcd3daaf47b57e6bac7/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e2073424fd5a185781750347fbfbb0c108ef66fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2073424fd5a185781750347fbfbb0c108ef66fd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e2073424fd5a185781750347fbfbb0c108ef66fd"
      }
    ],
    "stats": {
      "total": 443,
      "additions": 443,
      "deletions": 0
    },
    "files": [
      {
        "sha": "26b1b1067f771b00059d1d6b8f7d0f0242c92fa9",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96c7f2c3458950061b057fcd3daaf47b57e6bac7/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96c7f2c3458950061b057fcd3daaf47b57e6bac7/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=96c7f2c3458950061b057fcd3daaf47b57e6bac7",
        "patch": "@@ -67,6 +67,7 @@ BITCOIN_TESTS =\\\n   test/blockencodings_tests.cpp \\\n   test/bloom_tests.cpp \\\n   test/bswap_tests.cpp \\\n+  test/checkqueue_tests.cpp \\\n   test/coins_tests.cpp \\\n   test/compress_tests.cpp \\\n   test/crypto_tests.cpp \\"
      },
      {
        "sha": "d89f9b770bce360012aefbbf667e7aa5840ae41c",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "added",
        "additions": 442,
        "deletions": 0,
        "changes": 442,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96c7f2c3458950061b057fcd3daaf47b57e6bac7/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96c7f2c3458950061b057fcd3daaf47b57e6bac7/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=96c7f2c3458950061b057fcd3daaf47b57e6bac7",
        "patch": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE_EQUAL(UniqueCheck::results.size(), COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 0; i < 1000; ++i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100 && !fails; ++x) {\n+            fails = queue->ControlMutex.try_lock();\n+        }\n+        // Unfreeze\n+        FrozenCleanupCheck::nFrozen = 0;\n+    }\n+    // Awaken frozen destructor\n+    FrozenCleanupCheck::cv.notify_one();\n+    // Wait for control to finish\n+    t0.join();\n+    tg.interrupt_all();\n+    tg.join_all();\n+    BOOST_REQUIRE(!fails);\n+}\n+\n+\n+/** Test that CCheckQueueControl is threadsafe */\n+BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n+{\n+    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});\n+    {\n+        boost::thread_group tg;\n+        std::atomic<int> nThreads {0};\n+        std::atomic<int> fails {0};\n+        for (size_t i = 0; i < 3; ++i) {\n+            tg.create_thread(\n+                    [&]{\n+                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    // While sleeping, no other thread should execute to this point\n+                    auto observed = ++nThreads;\n+                    MilliSleep(10);\n+                    fails += observed  != nThreads;\n+                    });\n+        }\n+        tg.join_all();\n+        BOOST_REQUIRE_EQUAL(fails, 0);\n+    }\n+    {\n+        boost::thread_group tg;\n+        std::mutex m;\n+        bool has_lock {false};\n+        bool has_tried {false};\n+        bool done {false};\n+        bool done_ack {false};\n+        std::condition_variable cv;\n+        {\n+            std::unique_lock<std::mutex> l(m);\n+            tg.create_thread([&]{\n+                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    std::unique_lock<std::mutex> l(m);\n+                    has_lock = true;\n+                    cv.notify_one();\n+                    cv.wait(l, [&]{return has_tried;});\n+                    done = true;\n+                    cv.notify_one();\n+                    // Wait until the done is acknowledged\n+                    //\n+                    cv.wait(l, [&]{return done_ack;});\n+                    });\n+            // Wait for thread to get the lock\n+            cv.wait(l, [&](){return has_lock;});\n+            bool fails = false;\n+            for (auto x = 0; x < 100 && !fails; ++x) {\n+                fails = queue->ControlMutex.try_lock();\n+            }\n+            has_tried = true;\n+            cv.notify_one();\n+            cv.wait(l, [&](){return done;});\n+            // Acknowledge the done\n+            done_ack = true;\n+            cv.notify_one();\n+            BOOST_REQUIRE(!fails);\n+        }\n+        tg.join_all();\n+    }\n+}\n+BOOST_AUTO_TEST_SUITE_END()\n+"
      }
    ]
  }
]