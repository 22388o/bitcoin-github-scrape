[
  {
    "sha": "a533834d502ef72aa14216828ae0ff5c7fc5625e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTMzODM0ZDUwMmVmNzJhYTE0MjE2ODI4YWUwZmY1YzdmYzU2MjVl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-04-24T19:55:53Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-05-01T15:30:03Z"
      },
      "message": "[tests] Fix flake8 warnings in several wallet functional tests\n\nThis commit fixes flake8 warnings in the following functional tests:\n\n- wallet_listreceivedby.py\n- wallet_basic.py\n- wallet_txn_clone.py\n- wallet_listsinceblock.py\n- wallet_import_rescan.py\n- wallet_listtransactions.py\n- wallet_importprunedfunds.py\n- wallet_txn_doublspend.py",
      "tree": {
        "sha": "ef5c92f7f463c0bcb5a93131e9de55b226827b94",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef5c92f7f463c0bcb5a93131e9de55b226827b94"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a533834d502ef72aa14216828ae0ff5c7fc5625e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a533834d502ef72aa14216828ae0ff5c7fc5625e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a533834d502ef72aa14216828ae0ff5c7fc5625e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a533834d502ef72aa14216828ae0ff5c7fc5625e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3186ad4a81a48a195df6626dc9994d34af09a0f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3186ad4a81a48a195df6626dc9994d34af09a0f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3186ad4a81a48a195df6626dc9994d34af09a0f9"
      }
    ],
    "stats": {
      "total": 442,
      "additions": 231,
      "deletions": 211
    },
    "files": [
      {
        "sha": "0e095a613211264b54155af6a4de8c443195917b",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 88,
        "deletions": 77,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -3,8 +3,20 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet.\"\"\"\n+from decimal import Decimal\n+import time\n+\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n+from test_framework.util import (\n+    assert_array_result,\n+    assert_equal,\n+    assert_fee_amount,\n+    assert_raises_rpc_error,\n+    connect_nodes_bi,\n+    sync_blocks,\n+    sync_mempools,\n+    wait_until,\n+)\n \n class WalletTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -17,9 +29,9 @@ def setup_network(self):\n         self.start_node(0)\n         self.start_node(1)\n         self.start_node(2)\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         self.sync_all([self.nodes[0:3]])\n \n     def check_fee_amount(self, curr_balance, balance_with_fee, fee_per_byte, tx_size):\n@@ -112,19 +124,19 @@ def run_test(self):\n         self.nodes[2].lockunspent(True, [unspent_0])\n         assert_equal(len(self.nodes[2].listlockunspent()), 0)\n         assert_raises_rpc_error(-8, \"Invalid parameter, unknown transaction\",\n-                              self.nodes[2].lockunspent, False,\n-                              [{\"txid\": \"0000000000000000000000000000000000\", \"vout\": 0}])\n+                                self.nodes[2].lockunspent, False,\n+                                [{\"txid\": \"0000000000000000000000000000000000\", \"vout\": 0}])\n         assert_raises_rpc_error(-8, \"Invalid parameter, vout index out of bounds\",\n-                              self.nodes[2].lockunspent, False,\n-                              [{\"txid\": unspent_0[\"txid\"], \"vout\": 999}])\n+                                self.nodes[2].lockunspent, False,\n+                                [{\"txid\": unspent_0[\"txid\"], \"vout\": 999}])\n \n         # Have node1 generate 100 blocks (so node0 can recover the fee)\n         self.nodes[1].generate(100)\n         self.sync_all([self.nodes[0:3]])\n \n         # node0 should end up with 100 btc in block rewards plus fees, but\n         # minus the 21 plus fees sent to node2\n-        assert_equal(self.nodes[0].getbalance(), 100-21)\n+        assert_equal(self.nodes[0].getbalance(), 100 - 21)\n         assert_equal(self.nodes[2].getbalance(), 21)\n \n         # Node0 should have two unspent outputs.\n@@ -138,7 +150,7 @@ def run_test(self):\n         for utxo in node0utxos:\n             inputs = []\n             outputs = {}\n-            inputs.append({ \"txid\" : utxo[\"txid\"], \"vout\" : utxo[\"vout\"]})\n+            inputs.append({\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]})\n             outputs[self.nodes[2].getnewaddress(\"from1\")] = utxo[\"amount\"] - 3\n             raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n             txns_to_send.append(self.nodes[0].signrawtransactionwithwallet(raw_tx))\n@@ -153,7 +165,7 @@ def run_test(self):\n \n         assert_equal(self.nodes[0].getbalance(), 0)\n         assert_equal(self.nodes[2].getbalance(), 94)\n-        assert_equal(self.nodes[2].getbalance(\"from1\"), 94-21)\n+        assert_equal(self.nodes[2].getbalance(\"from1\"), 94 - 21)\n \n         # Verify that a spent output cannot be locked anymore\n         spent_0 = {\"txid\": node0utxos[0][\"txid\"], \"vout\": node0utxos[0][\"vout\"]}\n@@ -215,91 +227,90 @@ def run_test(self):\n         assert_equal(self.nodes[0].getwalletinfo()[\"unconfirmed_balance\"], 1)\n         assert_equal(self.nodes[0].getunconfirmedbalance(), 1)\n \n-        #check if we can list zero value tx as available coins\n-        #1. create rawtx\n-        #2. hex-changed one output to 0.0\n-        #3. sign and send\n-        #4. check if recipient (node0) can list the zero value tx\n+        # check if we can list zero value tx as available coins\n+        # 1. create raw_tx\n+        # 2. hex-changed one output to 0.0\n+        # 3. sign and send\n+        # 4. check if recipient (node0) can list the zero value tx\n         usp = self.nodes[1].listunspent()\n-        inputs = [{\"txid\":usp[0]['txid'], \"vout\":usp[0]['vout']}]\n+        inputs = [{\"txid\": usp[0]['txid'], \"vout\": usp[0]['vout']}]\n         outputs = {self.nodes[1].getnewaddress(): 49.998, self.nodes[0].getnewaddress(): 11.11}\n \n-        rawTx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\") #replace 11.11 with 0.0 (int32)\n-        decRawTx = self.nodes[1].decoderawtransaction(rawTx)\n-        signedRawTx = self.nodes[1].signrawtransactionwithwallet(rawTx)\n-        decRawTx = self.nodes[1].decoderawtransaction(signedRawTx['hex'])\n-        zeroValueTxid= decRawTx['txid']\n-        self.nodes[1].sendrawtransaction(signedRawTx['hex'])\n+        raw_tx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\")  # replace 11.11 with 0.0 (int32)\n+        signed_raw_tx = self.nodes[1].signrawtransactionwithwallet(raw_tx)\n+        decoded_raw_tx = self.nodes[1].decoderawtransaction(signed_raw_tx['hex'])\n+        zero_value_txid = decoded_raw_tx['txid']\n+        self.nodes[1].sendrawtransaction(signed_raw_tx['hex'])\n \n         self.sync_all()\n-        self.nodes[1].generate(1) #mine a block\n+        self.nodes[1].generate(1)  # mine a block\n         self.sync_all()\n \n-        unspentTxs = self.nodes[0].listunspent() #zero value tx must be in listunspents output\n+        unspent_txs = self.nodes[0].listunspent()  # zero value tx must be in listunspents output\n         found = False\n-        for uTx in unspentTxs:\n-            if uTx['txid'] == zeroValueTxid:\n+        for uTx in unspent_txs:\n+            if uTx['txid'] == zero_value_txid:\n                 found = True\n                 assert_equal(uTx['amount'], Decimal('0'))\n         assert(found)\n \n-        #do some -walletbroadcast tests\n+        # do some -walletbroadcast tests\n         self.stop_nodes()\n         self.start_node(0, [\"-walletbroadcast=0\"])\n         self.start_node(1, [\"-walletbroadcast=0\"])\n         self.start_node(2, [\"-walletbroadcast=0\"])\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         self.sync_all([self.nodes[0:3]])\n \n-        txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n-        txObjNotBroadcasted = self.nodes[0].gettransaction(txIdNotBroadcasted)\n-        self.nodes[1].generate(1) #mine a block, tx should not be in there\n+        txid_not_broadcast = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n+        tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n+        self.nodes[1].generate(1)  # mine a block, tx should not be in there\n         self.sync_all([self.nodes[0:3]])\n-        assert_equal(self.nodes[2].getbalance(), node_2_bal) #should not be changed because tx was not broadcasted\n+        assert_equal(self.nodes[2].getbalance(), node_2_bal)  # should not be changed because tx was not broadcasted\n \n-        #now broadcast from another node, mine a block, sync, and check the balance\n-        self.nodes[1].sendrawtransaction(txObjNotBroadcasted['hex'])\n+        # now broadcast from another node, mine a block, sync, and check the balance\n+        self.nodes[1].sendrawtransaction(tx_obj_not_broadcast['hex'])\n         self.nodes[1].generate(1)\n         self.sync_all([self.nodes[0:3]])\n         node_2_bal += 2\n-        txObjNotBroadcasted = self.nodes[0].gettransaction(txIdNotBroadcasted)\n+        tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n \n-        #create another tx\n-        txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n+        # create another tx\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n \n-        #restart the nodes with -walletbroadcast=1\n+        # restart the nodes with -walletbroadcast=1\n         self.stop_nodes()\n         self.start_node(0)\n         self.start_node(1)\n         self.start_node(2)\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         sync_blocks(self.nodes[0:3])\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes[0:3])\n         node_2_bal += 2\n \n-        #tx should be added to balance because after restarting the nodes tx should be broadcast\n+        # tx should be added to balance because after restarting the nodes tx should be broadcast\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n \n-        #send a tx with value in a string (PR#6380 +)\n-        txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"2\")\n-        txObj = self.nodes[0].gettransaction(txId)\n-        assert_equal(txObj['amount'], Decimal('-2'))\n+        # send a tx with value in a string (PR#6380 +)\n+        txid = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"2\")\n+        tx_obj = self.nodes[0].gettransaction(txid)\n+        assert_equal(tx_obj['amount'], Decimal('-2'))\n \n-        txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"0.0001\")\n-        txObj = self.nodes[0].gettransaction(txId)\n-        assert_equal(txObj['amount'], Decimal('-0.0001'))\n+        txid = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"0.0001\")\n+        tx_obj = self.nodes[0].gettransaction(txid)\n+        assert_equal(tx_obj['amount'], Decimal('-0.0001'))\n \n-        #check if JSON parser can handle scientific notation in strings\n-        txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"1e-4\")\n-        txObj = self.nodes[0].gettransaction(txId)\n-        assert_equal(txObj['amount'], Decimal('-0.0001'))\n+        # check if JSON parser can handle scientific notation in strings\n+        txid = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"1e-4\")\n+        tx_obj = self.nodes[0].gettransaction(txid)\n+        assert_equal(tx_obj['amount'], Decimal('-0.0001'))\n \n         # This will raise an exception because the amount type is wrong\n         assert_raises_rpc_error(-3, \"Invalid amount\", self.nodes[0].sendtoaddress, self.nodes[2].getnewaddress(), \"1f-4\")\n@@ -322,26 +333,26 @@ def run_test(self):\n \n         # 4. Check that the unspents after import are not spendable\n         assert_array_result(self.nodes[1].listunspent(),\n-                           {\"address\": address_to_import},\n-                           {\"spendable\": False})\n+                            {\"address\": address_to_import},\n+                            {\"spendable\": False})\n \n         # 5. Import private key of the previously imported address on node1\n         priv_key = self.nodes[2].dumpprivkey(address_to_import)\n         self.nodes[1].importprivkey(priv_key)\n \n         # 6. Check that the unspents are now spendable on node1\n         assert_array_result(self.nodes[1].listunspent(),\n-                           {\"address\": address_to_import},\n-                           {\"spendable\": True})\n+                            {\"address\": address_to_import},\n+                            {\"spendable\": True})\n \n         # Mine a block from node0 to an address from node1\n-        cbAddr = self.nodes[1].getnewaddress()\n-        blkHash = self.nodes[0].generatetoaddress(1, cbAddr)[0]\n-        cbTxId = self.nodes[0].getblock(blkHash)['tx'][0]\n+        coinbase_addr = self.nodes[1].getnewaddress()\n+        block_hash = self.nodes[0].generatetoaddress(1, coinbase_addr)[0]\n+        coinbase_txid = self.nodes[0].getblock(block_hash)['tx'][0]\n         self.sync_all([self.nodes[0:3]])\n \n         # Check that the txid and balance is found by node1\n-        self.nodes[1].gettransaction(cbTxId)\n+        self.nodes[1].gettransaction(coinbase_txid)\n \n         # check if wallet or blockchain maintenance changes the balance\n         self.sync_all([self.nodes[0:3]])\n@@ -361,7 +372,7 @@ def run_test(self):\n                 label = self.nodes[0].getaccount(addr)\n                 assert_equal(label, s)\n                 assert(s in self.nodes[0].listaccounts().keys())\n-        self.nodes[0].ensure_ascii = True # restore to default\n+        self.nodes[0].ensure_ascii = True  # restore to default\n \n         # maintenance tests\n         maintenance = [\n@@ -377,9 +388,9 @@ def run_test(self):\n             self.log.info(\"check \" + m)\n             self.stop_nodes()\n             # set lower ancestor limit for later\n-            self.start_node(0, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\"+str(chainlimit)])\n-            self.start_node(1, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\"+str(chainlimit)])\n-            self.start_node(2, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\"+str(chainlimit)])\n+            self.start_node(0, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\" + str(chainlimit)])\n+            self.start_node(1, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\" + str(chainlimit)])\n+            self.start_node(2, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\" + str(chainlimit)])\n             if m == '-reindex':\n                 # reindex will leave rpc warm up \"early\"; Wait for it to finish\n                 wait_until(lambda: [block_count] * 3 == [self.nodes[i].getblockcount() for i in range(3)])\n@@ -400,7 +411,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         node0_balance = self.nodes[0].getbalance()\n         # Split into two chains\n-        rawtx = self.nodes[0].createrawtransaction([{\"txid\":singletxid, \"vout\":0}], {chain_addrs[0]:node0_balance/2-Decimal('0.01'), chain_addrs[1]:node0_balance/2-Decimal('0.01')})\n+        rawtx = self.nodes[0].createrawtransaction([{\"txid\": singletxid, \"vout\": 0}], {chain_addrs[0]: node0_balance / 2 - Decimal('0.01'), chain_addrs[1]: node0_balance / 2 - Decimal('0.01')})\n         signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx)\n         singletxid = self.nodes[0].sendrawtransaction(signedtx[\"hex\"])\n         self.nodes[0].generate(1)\n@@ -411,37 +422,37 @@ def run_test(self):\n         # So we should be able to generate exactly chainlimit txs for each original output\n         sending_addr = self.nodes[1].getnewaddress()\n         txid_list = []\n-        for i in range(chainlimit*2):\n+        for i in range(chainlimit * 2):\n             txid_list.append(self.nodes[0].sendtoaddress(sending_addr, Decimal('0.0001')))\n-        assert_equal(self.nodes[0].getmempoolinfo()['size'], chainlimit*2)\n-        assert_equal(len(txid_list), chainlimit*2)\n+        assert_equal(self.nodes[0].getmempoolinfo()['size'], chainlimit * 2)\n+        assert_equal(len(txid_list), chainlimit * 2)\n \n         # Without walletrejectlongchains, we will still generate a txid\n         # The tx will be stored in the wallet but not accepted to the mempool\n         extra_txid = self.nodes[0].sendtoaddress(sending_addr, Decimal('0.0001'))\n         assert(extra_txid not in self.nodes[0].getrawmempool())\n         assert(extra_txid in [tx[\"txid\"] for tx in self.nodes[0].listtransactions()])\n         self.nodes[0].abandontransaction(extra_txid)\n-        total_txs = len(self.nodes[0].listtransactions(\"*\",99999))\n+        total_txs = len(self.nodes[0].listtransactions(\"*\", 99999))\n \n         # Try with walletrejectlongchains\n         # Double chain limit but require combining inputs, so we pass SelectCoinsMinConf\n         self.stop_node(0)\n-        self.start_node(0, extra_args=[\"-deprecatedrpc=accounts\", \"-walletrejectlongchains\", \"-limitancestorcount=\"+str(2*chainlimit)])\n+        self.start_node(0, extra_args=[\"-deprecatedrpc=accounts\", \"-walletrejectlongchains\", \"-limitancestorcount=\" + str(2 * chainlimit)])\n \n         # wait for loadmempool\n         timeout = 10\n-        while (timeout > 0 and len(self.nodes[0].getrawmempool()) < chainlimit*2):\n+        while (timeout > 0 and len(self.nodes[0].getrawmempool()) < chainlimit * 2):\n             time.sleep(0.5)\n             timeout -= 0.5\n-        assert_equal(len(self.nodes[0].getrawmempool()), chainlimit*2)\n+        assert_equal(len(self.nodes[0].getrawmempool()), chainlimit * 2)\n \n         node0_balance = self.nodes[0].getbalance()\n         # With walletrejectlongchains we will not create the tx and store it in our wallet.\n         assert_raises_rpc_error(-4, \"Transaction has too long of a mempool chain\", self.nodes[0].sendtoaddress, sending_addr, node0_balance - Decimal('0.01'))\n \n         # Verify nothing new in wallet\n-        assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\",99999)))\n+        assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\", 99999)))\n \n         # Test getaddressinfo. Note that these addresses are taken from disablewallet.py\n         assert_raises_rpc_error(-5, \"Invalid address\", self.nodes[0].getaddressinfo, \"3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\")"
      },
      {
        "sha": "baf933f0793caad8eebafc8902853d676c4efd49",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -46,10 +46,10 @@ def do_import(self, timestamp):\n         if self.call == Call.single:\n             if self.data == Data.address:\n                 response = self.try_rpc(self.node.importaddress, self.address[\"address\"], self.label,\n-                                               self.rescan == Rescan.yes)\n+                                        self.rescan == Rescan.yes)\n             elif self.data == Data.pub:\n                 response = self.try_rpc(self.node.importpubkey, self.address[\"pubkey\"], self.label,\n-                                               self.rescan == Rescan.yes)\n+                                        self.rescan == Rescan.yes)\n             elif self.data == Data.priv:\n                 response = self.try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n             assert_equal(response, None)"
      },
      {
        "sha": "9cee9aa49a0a56d2447fb51aca7cde7cdbfe538a",
        "filename": "test/functional/wallet_importprunedfunds.py",
        "status": "modified",
        "additions": 17,
        "deletions": 12,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importprunedfunds.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -3,8 +3,13 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the importprunedfunds and removeprunedfunds RPCs.\"\"\"\n+from decimal import Decimal\n+\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n \n class ImportPrunedFundsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -24,18 +29,18 @@ def run_test(self):\n         address2 = self.nodes[0].getnewaddress()\n         # privkey\n         address3 = self.nodes[0].getnewaddress()\n-        address3_privkey = self.nodes[0].dumpprivkey(address3)                              # Using privkey\n+        address3_privkey = self.nodes[0].dumpprivkey(address3)  # Using privkey\n \n-        #Check only one address\n+        # Check only one address\n         address_info = self.nodes[0].getaddressinfo(address1)\n         assert_equal(address_info['ismine'], True)\n \n         self.sync_all()\n \n-        #Node 1 sync test\n-        assert_equal(self.nodes[1].getblockcount(),101)\n+        # Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(), 101)\n \n-        #Address Test - before import\n+        # Address Test - before import\n         address_info = self.nodes[1].getaddressinfo(address1)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n@@ -48,7 +53,7 @@ def run_test(self):\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n-        #Send funds to self\n+        # Send funds to self\n         txnid1 = self.nodes[0].sendtoaddress(address1, 0.1)\n         self.nodes[0].generate(1)\n         rawtxn1 = self.nodes[0].gettransaction(txnid1)['hex']\n@@ -66,27 +71,27 @@ def run_test(self):\n \n         self.sync_all()\n \n-        #Import with no affiliated address\n+        # Import with no affiliated address\n         assert_raises_rpc_error(-5, \"No addresses\", self.nodes[1].importprunedfunds, rawtxn1, proof1)\n \n         balance1 = self.nodes[1].getbalance(\"\", 0, True)\n         assert_equal(balance1, Decimal(0))\n \n-        #Import with affiliated address with no rescan\n+        # Import with affiliated address with no rescan\n         self.nodes[1].importaddress(address2, \"add2\", False)\n         self.nodes[1].importprunedfunds(rawtxn2, proof2)\n         balance2 = self.nodes[1].getbalance(\"add2\", 0, True)\n         assert_equal(balance2, Decimal('0.05'))\n \n-        #Import with private key with no rescan\n+        # Import with private key with no rescan\n         self.nodes[1].importprivkey(privkey=address3_privkey, label=\"add3\", rescan=False)\n         self.nodes[1].importprunedfunds(rawtxn3, proof3)\n         balance3 = self.nodes[1].getbalance(\"add3\", 0, False)\n         assert_equal(balance3, Decimal('0.025'))\n         balance3 = self.nodes[1].getbalance(\"*\", 0, True)\n         assert_equal(balance3, Decimal('0.075'))\n \n-        #Addresses Test - after import\n+        # Addresses Test - after import\n         address_info = self.nodes[1].getaddressinfo(address1)\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n@@ -97,7 +102,7 @@ def run_test(self):\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], True)\n \n-        #Remove transactions\n+        # Remove transactions\n         assert_raises_rpc_error(-8, \"Transaction does not exist in wallet.\", self.nodes[1].removeprunedfunds, txnid1)\n \n         balance1 = self.nodes[1].getbalance(\"*\", 0, True)"
      },
      {
        "sha": "e0e20cc9a3f2b1973d38b5b7345141af3a669066",
        "filename": "test/functional/wallet_listreceivedby.py",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_listreceivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_listreceivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listreceivedby.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -51,37 +51,37 @@ def run_test(self):\n                             {\"address\": empty_addr},\n                             {\"address\": empty_addr, \"label\": \"\", \"amount\": 0, \"confirmations\": 0, \"txids\": []})\n \n-        #Test Address filtering\n-        #Only on addr\n-        expected = {\"address\":addr, \"label\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]}\n+        # Test Address filtering\n+        # Only on addr\n+        expected = {\"address\": addr, \"label\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 10, \"txids\": [txid, ]}\n         res = self.nodes[1].listreceivedbyaddress(minconf=0, include_empty=True, include_watchonly=True, address_filter=addr)\n-        assert_array_result(res, {\"address\":addr}, expected)\n+        assert_array_result(res, {\"address\": addr}, expected)\n         assert_equal(len(res), 1)\n-        #Error on invalid address\n+        # Error on invalid address\n         assert_raises_rpc_error(-4, \"address_filter parameter was invalid\", self.nodes[1].listreceivedbyaddress, minconf=0, include_empty=True, include_watchonly=True, address_filter=\"bamboozling\")\n-        #Another address receive money\n+        # Another address receive money\n         res = self.nodes[1].listreceivedbyaddress(0, True, True)\n-        assert_equal(len(res), 2) #Right now 2 entries\n+        assert_equal(len(res), 2)  # Right now 2 entries\n         other_addr = self.nodes[1].getnewaddress()\n         txid2 = self.nodes[0].sendtoaddress(other_addr, 0.1)\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        #Same test as above should still pass\n-        expected = {\"address\":addr, \"label\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":11, \"txids\":[txid,]}\n+        # Same test as above should still pass\n+        expected = {\"address\": addr, \"label\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 11, \"txids\": [txid, ]}\n         res = self.nodes[1].listreceivedbyaddress(0, True, True, addr)\n-        assert_array_result(res, {\"address\":addr}, expected)\n+        assert_array_result(res, {\"address\": addr}, expected)\n         assert_equal(len(res), 1)\n-        #Same test as above but with other_addr should still pass\n-        expected = {\"address\":other_addr, \"label\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":1, \"txids\":[txid2,]}\n+        # Same test as above but with other_addr should still pass\n+        expected = {\"address\": other_addr, \"label\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 1, \"txids\": [txid2, ]}\n         res = self.nodes[1].listreceivedbyaddress(0, True, True, other_addr)\n-        assert_array_result(res, {\"address\":other_addr}, expected)\n+        assert_array_result(res, {\"address\": other_addr}, expected)\n         assert_equal(len(res), 1)\n-        #Should be two entries though without filter\n+        # Should be two entries though without filter\n         res = self.nodes[1].listreceivedbyaddress(0, True, True)\n-        assert_equal(len(res), 3) #Became 3 entries\n+        assert_equal(len(res), 3)  # Became 3 entries\n \n-        #Not on random addr\n-        other_addr = self.nodes[0].getnewaddress() # note on node[0]! just a random addr\n+        # Not on random addr\n+        other_addr = self.nodes[0].getnewaddress()  # note on node[0]! just a random addr\n         res = self.nodes[1].listreceivedbyaddress(0, True, True, other_addr)\n         assert_equal(len(res), 0)\n \n@@ -112,8 +112,8 @@ def run_test(self):\n         self.log.info(\"listreceivedbylabel + getreceivedbylabel Test\")\n \n         # set pre-state\n-        addrArr = self.nodes[1].getnewaddress()\n-        label = self.nodes[1].getaccount(addrArr)\n+        address = self.nodes[1].getnewaddress()\n+        label = self.nodes[1].getaccount(address)\n         received_by_label_json = [r for r in self.nodes[1].listreceivedbylabel() if r[\"label\"] == label][0]\n         balance_by_label = self.nodes[1].getreceivedbylabel(label)\n "
      },
      {
        "sha": "50a3313e2f72ad2f200eb57ad9a0ea114a3535a7",
        "filename": "test/functional/wallet_listsinceblock.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listsinceblock.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -150,26 +150,26 @@ def test_double_spend(self):\n \n         # send from nodes[1] using utxo to nodes[0]\n         change = '%.8f' % (float(utxo['amount']) - 1.0003)\n-        recipientDict = {\n+        recipient_dict = {\n             self.nodes[0].getnewaddress(): 1,\n             self.nodes[1].getnewaddress(): change,\n         }\n-        utxoDicts = [{\n+        utxo_dicts = [{\n             'txid': utxo['txid'],\n             'vout': utxo['vout'],\n         }]\n         txid1 = self.nodes[1].sendrawtransaction(\n             self.nodes[1].signrawtransactionwithwallet(\n-                self.nodes[1].createrawtransaction(utxoDicts, recipientDict))['hex'])\n+                self.nodes[1].createrawtransaction(utxo_dicts, recipient_dict))['hex'])\n \n         # send from nodes[2] using utxo to nodes[3]\n-        recipientDict2 = {\n+        recipient_dict2 = {\n             self.nodes[3].getnewaddress(): 1,\n             self.nodes[2].getnewaddress(): change,\n         }\n         self.nodes[2].sendrawtransaction(\n             self.nodes[2].signrawtransactionwithwallet(\n-                self.nodes[2].createrawtransaction(utxoDicts, recipientDict2))['hex'])\n+                self.nodes[2].createrawtransaction(utxo_dicts, recipient_dict2))['hex'])\n \n         # generate on both sides\n         lastblockhash = self.nodes[1].generate(3)[2]\n@@ -225,16 +225,16 @@ def test_double_send(self):\n         utxos = self.nodes[2].listunspent()\n         utxo = utxos[0]\n         change = '%.8f' % (float(utxo['amount']) - 1.0003)\n-        recipientDict = {\n+        recipient_dict = {\n             self.nodes[0].getnewaddress(): 1,\n             self.nodes[2].getnewaddress(): change,\n         }\n-        utxoDicts = [{\n+        utxo_dicts = [{\n             'txid': utxo['txid'],\n             'vout': utxo['vout'],\n         }]\n         signedtxres = self.nodes[2].signrawtransactionwithwallet(\n-                self.nodes[2].createrawtransaction(utxoDicts, recipientDict))\n+            self.nodes[2].createrawtransaction(utxo_dicts, recipient_dict))\n         assert signedtxres['complete']\n \n         signedtx = signedtxres['hex']"
      },
      {
        "sha": "883942cc19d9e883f8dab6f61b159432660df025",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 61,
        "deletions": 56,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -3,13 +3,20 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the listtransactions API.\"\"\"\n-\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n-from test_framework.mininode import CTransaction, COIN\n+from decimal import Decimal\n from io import BytesIO\n \n-def txFromHex(hexstring):\n+from test_framework.mininode import CTransaction, COIN\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_array_result,\n+    assert_equal,\n+    bytes_to_hex_str,\n+    hex_str_to_bytes,\n+    sync_mempools,\n+)\n+\n+def tx_from_hex(hexstring):\n     tx = CTransaction()\n     f = BytesIO(hex_str_to_bytes(hexstring))\n     tx.deserialize(f)\n@@ -26,61 +33,61 @@ def run_test(self):\n         txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n-                           {\"txid\":txid},\n-                           {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":0})\n+                            {\"txid\": txid},\n+                            {\"category\": \"send\", \"account\": \"\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 0})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"txid\":txid},\n-                           {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":0})\n+                            {\"txid\": txid},\n+                            {\"category\": \"receive\", \"account\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n         # mine a block, confirmations should change:\n         self.nodes[0].generate(1)\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n-                           {\"txid\":txid},\n-                           {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":1})\n+                            {\"txid\": txid},\n+                            {\"category\": \"send\", \"account\": \"\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 1})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"txid\":txid},\n-                           {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":1})\n+                            {\"txid\": txid},\n+                            {\"category\": \"receive\", \"account\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 1})\n \n         # send-to-self:\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n         assert_array_result(self.nodes[0].listtransactions(),\n-                           {\"txid\":txid, \"category\":\"send\"},\n-                           {\"amount\":Decimal(\"-0.2\")})\n+                            {\"txid\": txid, \"category\": \"send\"},\n+                            {\"amount\": Decimal(\"-0.2\")})\n         assert_array_result(self.nodes[0].listtransactions(),\n-                           {\"txid\":txid, \"category\":\"receive\"},\n-                           {\"amount\":Decimal(\"0.2\")})\n+                            {\"txid\": txid, \"category\": \"receive\"},\n+                            {\"amount\": Decimal(\"0.2\")})\n \n         # sendmany from node1: twice to self, twice to node2:\n-        send_to = { self.nodes[0].getnewaddress() : 0.11,\n-                    self.nodes[1].getnewaddress() : 0.22,\n-                    self.nodes[0].getaccountaddress(\"from1\") : 0.33,\n-                    self.nodes[1].getaccountaddress(\"toself\") : 0.44 }\n+        send_to = {self.nodes[0].getnewaddress(): 0.11,\n+                   self.nodes[1].getnewaddress(): 0.22,\n+                   self.nodes[0].getaccountaddress(\"from1\"): 0.33,\n+                   self.nodes[1].getaccountaddress(\"toself\"): 0.44}\n         txid = self.nodes[1].sendmany(\"\", send_to)\n         self.sync_all()\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"category\":\"send\",\"amount\":Decimal(\"-0.11\")},\n-                           {\"txid\":txid} )\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.11\")},\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[0].listtransactions(),\n-                           {\"category\":\"receive\",\"amount\":Decimal(\"0.11\")},\n-                           {\"txid\":txid} )\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.11\")},\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"category\":\"send\",\"amount\":Decimal(\"-0.22\")},\n-                           {\"txid\":txid} )\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.22\")},\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"category\":\"receive\",\"amount\":Decimal(\"0.22\")},\n-                           {\"txid\":txid} )\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.22\")},\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"category\":\"send\",\"amount\":Decimal(\"-0.33\")},\n-                           {\"txid\":txid} )\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.33\")},\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[0].listtransactions(),\n-                           {\"category\":\"receive\",\"amount\":Decimal(\"0.33\")},\n-                           {\"txid\":txid, \"account\" : \"from1\"} )\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.33\")},\n+                            {\"txid\": txid, \"account\": \"from1\"})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"category\":\"send\",\"amount\":Decimal(\"-0.44\")},\n-                           {\"txid\":txid, \"account\" : \"\"} )\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.44\")},\n+                            {\"txid\": txid, \"account\": \"\"})\n         assert_array_result(self.nodes[1].listtransactions(),\n-                           {\"category\":\"receive\",\"amount\":Decimal(\"0.44\")},\n-                           {\"txid\":txid, \"account\" : \"toself\"} )\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.44\")},\n+                            {\"txid\": txid, \"account\": \"toself\"})\n \n         pubkey = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n         multisig = self.nodes[1].createmultisig(1, [pubkey])\n@@ -90,8 +97,8 @@ def run_test(self):\n         self.sync_all()\n         assert(len(self.nodes[0].listtransactions(\"watchonly\", 100, 0, False)) == 0)\n         assert_array_result(self.nodes[0].listtransactions(\"watchonly\", 100, 0, True),\n-                           {\"category\":\"receive\",\"amount\":Decimal(\"0.1\")},\n-                           {\"txid\":txid, \"account\" : \"watchonly\"} )\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.1\")},\n+                            {\"txid\": txid, \"account\": \"watchonly\"})\n \n         self.run_rbf_opt_in_test()\n \n@@ -117,9 +124,9 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         # 1. Chain a few transactions that don't opt-in.\n         txid_1 = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n         assert(not is_opt_in(self.nodes[0], txid_1))\n-        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\":\"no\"})\n+        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\": \"no\"})\n         sync_mempools(self.nodes)\n-        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\":\"no\"})\n+        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\": \"no\"})\n \n         # Tx2 will build off txid_1, still not opting in to RBF.\n         utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[0], txid_1)\n@@ -129,59 +136,59 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         assert_equal(utxo_to_use[\"safe\"], False)\n \n         # Create tx2 using createrawtransaction\n-        inputs = [{\"txid\":utxo_to_use[\"txid\"], \"vout\":utxo_to_use[\"vout\"]}]\n+        inputs = [{\"txid\": utxo_to_use[\"txid\"], \"vout\": utxo_to_use[\"vout\"]}]\n         outputs = {self.nodes[0].getnewaddress(): 0.999}\n         tx2 = self.nodes[1].createrawtransaction(inputs, outputs)\n         tx2_signed = self.nodes[1].signrawtransactionwithwallet(tx2)[\"hex\"]\n         txid_2 = self.nodes[1].sendrawtransaction(tx2_signed)\n \n         # ...and check the result\n         assert(not is_opt_in(self.nodes[1], txid_2))\n-        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\":\"no\"})\n+        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\": \"no\"})\n         sync_mempools(self.nodes)\n-        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\":\"no\"})\n+        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\": \"no\"})\n \n         # Tx3 will opt-in to RBF\n         utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[0], txid_2)\n-        inputs = [{\"txid\": txid_2, \"vout\":utxo_to_use[\"vout\"]}]\n+        inputs = [{\"txid\": txid_2, \"vout\": utxo_to_use[\"vout\"]}]\n         outputs = {self.nodes[1].getnewaddress(): 0.998}\n         tx3 = self.nodes[0].createrawtransaction(inputs, outputs)\n-        tx3_modified = txFromHex(tx3)\n+        tx3_modified = tx_from_hex(tx3)\n         tx3_modified.vin[0].nSequence = 0\n         tx3 = bytes_to_hex_str(tx3_modified.serialize())\n         tx3_signed = self.nodes[0].signrawtransactionwithwallet(tx3)['hex']\n         txid_3 = self.nodes[0].sendrawtransaction(tx3_signed)\n \n         assert(is_opt_in(self.nodes[0], txid_3))\n-        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_3}, {\"bip125-replaceable\":\"yes\"})\n+        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_3}, {\"bip125-replaceable\": \"yes\"})\n         sync_mempools(self.nodes)\n-        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_3}, {\"bip125-replaceable\":\"yes\"})\n+        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_3}, {\"bip125-replaceable\": \"yes\"})\n \n         # Tx4 will chain off tx3.  Doesn't signal itself, but depends on one\n         # that does.\n         utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[1], txid_3)\n-        inputs = [{\"txid\": txid_3, \"vout\":utxo_to_use[\"vout\"]}]\n+        inputs = [{\"txid\": txid_3, \"vout\": utxo_to_use[\"vout\"]}]\n         outputs = {self.nodes[0].getnewaddress(): 0.997}\n         tx4 = self.nodes[1].createrawtransaction(inputs, outputs)\n         tx4_signed = self.nodes[1].signrawtransactionwithwallet(tx4)[\"hex\"]\n         txid_4 = self.nodes[1].sendrawtransaction(tx4_signed)\n \n         assert(not is_opt_in(self.nodes[1], txid_4))\n-        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\":\"yes\"})\n+        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"yes\"})\n         sync_mempools(self.nodes)\n-        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\":\"yes\"})\n+        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"yes\"})\n \n         # Replace tx3, and check that tx4 becomes unknown\n         tx3_b = tx3_modified\n-        tx3_b.vout[0].nValue -= int(Decimal(\"0.004\") * COIN) # bump the fee\n+        tx3_b.vout[0].nValue -= int(Decimal(\"0.004\") * COIN)  # bump the fee\n         tx3_b = bytes_to_hex_str(tx3_b.serialize())\n         tx3_b_signed = self.nodes[0].signrawtransactionwithwallet(tx3_b)['hex']\n         txid_3b = self.nodes[0].sendrawtransaction(tx3_b_signed, True)\n         assert(is_opt_in(self.nodes[0], txid_3b))\n \n-        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\":\"unknown\"})\n+        assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"unknown\"})\n         sync_mempools(self.nodes)\n-        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\":\"unknown\"})\n+        assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"unknown\"})\n \n         # Check gettransaction as well:\n         for n in self.nodes[0:2]:\n@@ -197,7 +204,5 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         assert_equal(self.nodes[0].gettransaction(txid_3b)[\"bip125-replaceable\"], \"no\")\n         assert_equal(self.nodes[0].gettransaction(txid_4)[\"bip125-replaceable\"], \"unknown\")\n \n-\n if __name__ == '__main__':\n     ListTransactionsTest().main()\n-"
      },
      {
        "sha": "b4e4cb1686d8199864a15ad4ed855ddf81532c69",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 22,
        "deletions": 23,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -5,7 +5,12 @@\n \"\"\"Test the wallet accounts properly when there are cloned transactions with malleated scriptsigs.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    disconnect_nodes,\n+    sync_blocks,\n+)\n \n class TxnMallTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -26,9 +31,9 @@ def setup_network(self):\n \n     def run_test(self):\n         if self.options.segwit:\n-            output_type=\"p2sh-segwit\"\n+            output_type = \"p2sh-segwit\"\n         else:\n-            output_type=\"legacy\"\n+            output_type = \"legacy\"\n \n         # All nodes should start with 1,250 BTC:\n         starting_balance = 1250\n@@ -53,28 +58,27 @@ def run_test(self):\n         # Coins are sent to node1_address\n         node1_address = self.nodes[1].getnewaddress(\"from0\")\n \n-        # Send tx1, and another transaction tx2 that won't be cloned \n+        # Send tx1, and another transaction tx2 that won't be cloned\n         txid1 = self.nodes[0].sendfrom(\"foo\", node1_address, 40, 0)\n         txid2 = self.nodes[0].sendfrom(\"bar\", node1_address, 20, 0)\n \n-        # Construct a clone of tx1, to be malleated \n-        rawtx1 = self.nodes[0].getrawtransaction(txid1,1)\n-        clone_inputs = [{\"txid\":rawtx1[\"vin\"][0][\"txid\"],\"vout\":rawtx1[\"vin\"][0][\"vout\"]}]\n-        clone_outputs = {rawtx1[\"vout\"][0][\"scriptPubKey\"][\"addresses\"][0]:rawtx1[\"vout\"][0][\"value\"],\n-                         rawtx1[\"vout\"][1][\"scriptPubKey\"][\"addresses\"][0]:rawtx1[\"vout\"][1][\"value\"]}\n+        # Construct a clone of tx1, to be malleated\n+        rawtx1 = self.nodes[0].getrawtransaction(txid1, 1)\n+        clone_inputs = [{\"txid\": rawtx1[\"vin\"][0][\"txid\"], \"vout\": rawtx1[\"vin\"][0][\"vout\"]}]\n+        clone_outputs = {rawtx1[\"vout\"][0][\"scriptPubKey\"][\"addresses\"][0]: rawtx1[\"vout\"][0][\"value\"],\n+                         rawtx1[\"vout\"][1][\"scriptPubKey\"][\"addresses\"][0]: rawtx1[\"vout\"][1][\"value\"]}\n         clone_locktime = rawtx1[\"locktime\"]\n         clone_raw = self.nodes[0].createrawtransaction(clone_inputs, clone_outputs, clone_locktime)\n \n         # createrawtransaction randomizes the order of its outputs, so swap them if necessary.\n         # output 0 is at version+#inputs+input+sigstub+sequence+#outputs\n         # 40 BTC serialized is 00286bee00000000\n-        pos0 = 2*(4+1+36+1+4+1)\n+        pos0 = 2 * (4 + 1 + 36 + 1 + 4 + 1)\n         hex40 = \"00286bee00000000\"\n-        output_len = 16 + 2 + 2 * int(\"0x\" + clone_raw[pos0 + 16 : pos0 + 16 + 2], 0)\n-        if (rawtx1[\"vout\"][0][\"value\"] == 40 and clone_raw[pos0 : pos0 + 16] != hex40 or\n-            rawtx1[\"vout\"][0][\"value\"] != 40 and clone_raw[pos0 : pos0 + 16] == hex40):\n-            output0 = clone_raw[pos0 : pos0 + output_len]\n-            output1 = clone_raw[pos0 + output_len : pos0 + 2 * output_len]\n+        output_len = 16 + 2 + 2 * int(\"0x\" + clone_raw[pos0 + 16:pos0 + 16 + 2], 0)\n+        if (rawtx1[\"vout\"][0][\"value\"] == 40 and clone_raw[pos0:pos0 + 16] != hex40 or rawtx1[\"vout\"][0][\"value\"] != 40 and clone_raw[pos0:pos0 + 16] == hex40):\n+            output0 = clone_raw[pos0:pos0 + output_len]\n+            output1 = clone_raw[pos0 + output_len:pos0 + 2 * output_len]\n             clone_raw = clone_raw[:pos0] + output1 + output0 + clone_raw[pos0 + 2 * output_len:]\n \n         # Use a different signature hash type to sign.  This creates an equivalent but malleated clone.\n@@ -142,7 +146,7 @@ def run_test(self):\n         # Check node0's total balance; should be same as before the clone, + 100 BTC for 2 matured,\n         # less possible orphaned matured subsidy\n         expected += 100\n-        if (self.options.mine_block): \n+        if (self.options.mine_block):\n             expected -= 50\n         assert_equal(self.nodes[0].getbalance(), expected)\n         assert_equal(self.nodes[0].getbalance(\"*\", 0), expected)\n@@ -153,16 +157,11 @@ def run_test(self):\n         # \"bar\" should have been debited by (possibly unconfirmed) tx2\n         assert_equal(self.nodes[0].getbalance(\"bar\", 0), 29 + tx2[\"amount\"] + tx2[\"fee\"])\n         # \"\" should have starting balance, less funding txes, plus subsidies\n-        assert_equal(self.nodes[0].getbalance(\"\", 0), starting_balance\n-                                                                - 1219\n-                                                                + fund_foo_tx[\"fee\"]\n-                                                                -   29\n-                                                                + fund_bar_tx[\"fee\"]\n-                                                                +  100)\n+        assert_equal(self.nodes[0].getbalance(\"\", 0),\n+                     starting_balance - 1219 + fund_foo_tx[\"fee\"] - 29 + fund_bar_tx[\"fee\"] + 100)\n \n         # Node1's \"from0\" account balance\n         assert_equal(self.nodes[1].getbalance(\"from0\", 0), -(tx1[\"amount\"] + tx2[\"amount\"]))\n \n if __name__ == '__main__':\n     TxnMallTest().main()\n-"
      },
      {
        "sha": "d8d91132d12734c086ed397cca7eb42da8ecaadc",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a533834d502ef72aa14216828ae0ff5c7fc5625e/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=a533834d502ef72aa14216828ae0ff5c7fc5625e",
        "patch": "@@ -3,9 +3,16 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet accounts properly when there is a double-spend conflict.\"\"\"\n+from decimal import Decimal\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n+from test_framework.util import (\n+    assert_equal,\n+    connect_nodes,\n+    disconnect_nodes,\n+    find_output,\n+    sync_blocks,\n+)\n \n class TxnMallTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -84,14 +91,14 @@ def run_test(self):\n         assert_equal(self.nodes[0].getbalance(), expected)\n \n         # foo and bar accounts should be debited:\n-        assert_equal(self.nodes[0].getbalance(\"foo\", 0), 1219+tx1[\"amount\"]+tx1[\"fee\"])\n-        assert_equal(self.nodes[0].getbalance(\"bar\", 0), 29+tx2[\"amount\"]+tx2[\"fee\"])\n+        assert_equal(self.nodes[0].getbalance(\"foo\", 0), 1219 + tx1[\"amount\"] + tx1[\"fee\"])\n+        assert_equal(self.nodes[0].getbalance(\"bar\", 0), 29 + tx2[\"amount\"] + tx2[\"fee\"])\n \n         if self.options.mine_block:\n             assert_equal(tx1[\"confirmations\"], 1)\n             assert_equal(tx2[\"confirmations\"], 1)\n             # Node1's \"from0\" balance should be both transaction amounts:\n-            assert_equal(self.nodes[1].getbalance(\"from0\"), -(tx1[\"amount\"]+tx2[\"amount\"]))\n+            assert_equal(self.nodes[1].getbalance(\"from0\"), -(tx1[\"amount\"] + tx2[\"amount\"]))\n         else:\n             assert_equal(tx1[\"confirmations\"], 0)\n             assert_equal(tx2[\"confirmations\"], 0)\n@@ -117,7 +124,7 @@ def run_test(self):\n         assert_equal(tx1[\"confirmations\"], -2)\n         assert_equal(tx2[\"confirmations\"], -2)\n \n-        # Node0's total balance should be starting balance, plus 100BTC for \n+        # Node0's total balance should be starting balance, plus 100BTC for\n         # two more matured blocks, minus 1240 for the double-spend, plus fees (which are\n         # negative):\n         expected = starting_balance + 100 - 1240 + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"] + doublespend_fee\n@@ -128,18 +135,11 @@ def run_test(self):\n         # fees (which are negative)\n         assert_equal(self.nodes[0].getbalance(\"foo\"), 1219)\n         assert_equal(self.nodes[0].getbalance(\"bar\"), 29)\n-        assert_equal(self.nodes[0].getbalance(\"\"), starting_balance\n-                                                              -1219\n-                                                              -  29\n-                                                              -1240\n-                                                              + 100\n-                                                              + fund_foo_tx[\"fee\"]\n-                                                              + fund_bar_tx[\"fee\"]\n-                                                              + doublespend_fee)\n+        assert_equal(self.nodes[0].getbalance(\"\"),\n+                     starting_balance - 1219 - 29 - 1240 + 100 + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"] + doublespend_fee)\n \n         # Node1's \"from0\" account balance should be just the doublespend:\n         assert_equal(self.nodes[1].getbalance(\"from0\"), 1240)\n \n if __name__ == '__main__':\n     TxnMallTest().main()\n-"
      }
    ]
  }
]