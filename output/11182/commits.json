[
  {
    "sha": "b86c1cd20837ae459b7c11c1defb5336e41509d2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiODZjMWNkMjA4MzdhZTQ1OWI3YzExYzFkZWZiNTMzNmU0MTUwOWQy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-20T13:27:55Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-08T14:04:02Z"
      },
      "message": "[tests] fix TestNode.__getattr__() method",
      "tree": {
        "sha": "9bdd69be172427f23aebe864362550db497eb64f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9bdd69be172427f23aebe864362550db497eb64f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b86c1cd20837ae459b7c11c1defb5336e41509d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b86c1cd20837ae459b7c11c1defb5336e41509d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b86c1cd20837ae459b7c11c1defb5336e41509d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b86c1cd20837ae459b7c11c1defb5336e41509d2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "77546a3182e5df622aa99446fc4ba8118db58351",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77546a3182e5df622aa99446fc4ba8118db58351",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/77546a3182e5df622aa99446fc4ba8118db58351"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "41c31c2d3d4400e3cd20a7314d0c920c19669bc8",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b86c1cd20837ae459b7c11c1defb5336e41509d2/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b86c1cd20837ae459b7c11c1defb5336e41509d2/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=b86c1cd20837ae459b7c11c1defb5336e41509d2",
        "patch": "@@ -63,10 +63,10 @@ def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mo\n         self.url = None\n         self.log = logging.getLogger('TestFramework.node%d' % i)\n \n-    def __getattr__(self, *args, **kwargs):\n+    def __getattr__(self, name):\n         \"\"\"Dispatches any unrecognised messages to the RPC connection.\"\"\"\n         assert self.rpc_connected and self.rpc is not None, \"Error: no RPC connection\"\n-        return self.rpc.__getattr__(*args, **kwargs)\n+        return getattr(self.rpc, name)\n \n     def start(self, extra_args=None, stderr=None):\n         \"\"\"Start the node.\"\"\""
      }
    ]
  },
  {
    "sha": "5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTU3MjVjYzJiNTZkNjY1MTBmZDg1ZDdlZTM4MjJlNmRmNDNjZDI0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-27T13:42:17Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-08T14:04:02Z"
      },
      "message": "[tests] Add p2p connection to TestNode\n\np2p connections can now be added to TestNode instances.\n\nThis commit also updates the example test to use the new\np2p interface in TestNode to demonstrate usage.\n\nA future commit will update the existing tests to use p2p through the\nTestNode.",
      "tree": {
        "sha": "7db35ff6d7149484cbe738c164ce47d7c78dbf95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7db35ff6d7149484cbe738c164ce47d7c78dbf95"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e5725cc2b56d66510fd85d7ee3822e6df43cd24/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b86c1cd20837ae459b7c11c1defb5336e41509d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b86c1cd20837ae459b7c11c1defb5336e41509d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b86c1cd20837ae459b7c11c1defb5336e41509d2"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 50,
      "deletions": 18
    },
    "files": [
      {
        "sha": "ba40f33016fb5d98475a12ec3522219b0f1b93fd",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 8,
        "deletions": 15,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e5725cc2b56d66510fd85d7ee3822e6df43cd24/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e5725cc2b56d66510fd85d7ee3822e6df43cd24/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
        "patch": "@@ -18,7 +18,6 @@\n from test_framework.mininode import (\n     CInv,\n     NetworkThread,\n-    NodeConn,\n     NodeConnCB,\n     mininode_lock,\n     msg_block,\n@@ -28,7 +27,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n-    p2p_port,\n     wait_until,\n )\n \n@@ -134,16 +132,13 @@ def run_test(self):\n         \"\"\"Main test logic\"\"\"\n \n         # Create a P2P connection to one of the nodes\n-        node0 = BaseNode()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(BaseNode())\n \n         # Start up network handling in another thread. This needs to be called\n         # after the P2P connections have been created.\n         NetworkThread().start()\n         # wait_for_verack ensures that the P2P connection is fully up.\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # Generating a block on one of the nodes will get us out of IBD\n         blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n@@ -180,7 +175,7 @@ def run_test(self):\n             block.solve()\n             block_message = msg_block(block)\n             # Send message is used to send a P2P message to the node over our NodeConn connection\n-            node0.send_message(block_message)\n+            self.nodes[0].p2p.send_message(block_message)\n             self.tip = block.sha256\n             blocks.append(self.tip)\n             self.block_time += 1\n@@ -193,28 +188,26 @@ def run_test(self):\n         connect_nodes(self.nodes[1], 2)\n \n         self.log.info(\"Add P2P connection to node2\")\n-        node2 = BaseNode()\n-        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n-        node2.add_connection(connections[1])\n-        node2.wait_for_verack()\n+        self.nodes[2].add_p2p_connection(BaseNode())\n+        self.nodes[2].p2p.wait_for_verack()\n \n         self.log.info(\"Wait for node2 reach current tip. Test that it has propagated all the blocks to us\")\n \n         getdata_request = msg_getdata()\n         for block in blocks:\n             getdata_request.inv.append(CInv(2, block))\n-        node2.send_message(getdata_request)\n+        self.nodes[2].p2p.send_message(getdata_request)\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n         # NodeConnCB objects.\n-        wait_until(lambda: sorted(blocks) == sorted(list(node2.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+        wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n \n         self.log.info(\"Check that each block was received only once\")\n         # The network thread uses a global lock on data access to the NodeConn objects when sending and receiving\n         # messages. The test thread should acquire the global lock before accessing any NodeConn data to avoid locking\n         # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.\n         with mininode_lock:\n-            for block in node2.block_receive_map.values():\n+            for block in self.nodes[2].p2p.block_receive_map.values():\n                 assert_equal(block, 1)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "8b28064c462b71f57e5b045556cacbb8a7dd9a8b",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 42,
        "deletions": 3,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e5725cc2b56d66510fd85d7ee3822e6df43cd24/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e5725cc2b56d66510fd85d7ee3822e6df43cd24/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
        "patch": "@@ -13,13 +13,15 @@\n import subprocess\n import time\n \n+from .authproxy import JSONRPCException\n+from .mininode import NodeConn\n from .util import (\n     assert_equal,\n     get_rpc_proxy,\n     rpc_url,\n     wait_until,\n+    p2p_port,\n )\n-from .authproxy import JSONRPCException\n \n BITCOIND_PROC_WAIT_TIMEOUT = 60\n \n@@ -31,9 +33,11 @@ class TestNode():\n     - state about the node (whether it's running, etc)\n     - a Python subprocess.Popen object representing the running process\n     - an RPC connection to the node\n+    - one or more P2P connections to the node\n+\n \n-    To make things easier for the test writer, a bit of magic is happening under the covers.\n-    Any unrecognised messages will be dispatched to the RPC connection.\"\"\"\n+    To make things easier for the test writer, any unrecognised messages will\n+    be dispatched to the RPC connection.\"\"\"\n \n     def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mocktime, coverage_dir):\n         self.index = i\n@@ -63,6 +67,8 @@ def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mo\n         self.url = None\n         self.log = logging.getLogger('TestFramework.node%d' % i)\n \n+        self.p2ps = []\n+\n     def __getattr__(self, name):\n         \"\"\"Dispatches any unrecognised messages to the RPC connection.\"\"\"\n         assert self.rpc_connected and self.rpc is not None, \"Error: no RPC connection\"\n@@ -119,6 +125,7 @@ def stop_node(self):\n             self.stop()\n         except http.client.CannotSendRequest:\n             self.log.exception(\"Unable to stop node.\")\n+        del self.p2ps[:]\n \n     def is_node_stopped(self):\n         \"\"\"Checks whether the node has stopped.\n@@ -151,6 +158,38 @@ def node_encrypt_wallet(self, passphrase):\n         self.encryptwallet(passphrase)\n         self.wait_until_stopped()\n \n+    def add_p2p_connection(self, p2p_conn, **kwargs):\n+        \"\"\"Add a p2p connection to the node.\n+\n+        This method adds the p2p connection to the self.p2ps list and also\n+        returns the connection to the caller.\"\"\"\n+        if 'dstport' not in kwargs:\n+            kwargs['dstport'] = p2p_port(self.index)\n+        if 'dstaddr' not in kwargs:\n+            kwargs['dstaddr'] = '127.0.0.1'\n+        self.p2ps.append(p2p_conn)\n+        kwargs.update({'rpc': self.rpc, 'callback': p2p_conn})\n+        p2p_conn.add_connection(NodeConn(**kwargs))\n+\n+        return p2p_conn\n+\n+    @property\n+    def p2p(self):\n+        \"\"\"Return the first p2p connection\n+\n+        Convenience property - most tests only use a single p2p connection to each\n+        node, so this saves having to write node.p2ps[0] many times.\"\"\"\n+        assert self.p2ps, \"No p2p connection\"\n+        return self.p2ps[0]\n+\n+    def disconnect_p2p(self, index=0):\n+        \"\"\"Close the p2p connection to the node.\"\"\"\n+        # Connection could have already been closed by other end. Calling disconnect_p2p()\n+        # on an already disconnected p2p connection is not an error.\n+        if self.p2ps[index].connection is not None:\n+            self.p2ps[index].connection.disconnect_node()\n+        del self.p2ps[index]\n+\n class TestNodeCLI():\n     \"\"\"Interface to bitcoin-cli for an individual node\"\"\"\n "
      }
    ]
  },
  {
    "sha": "32ae82f5c3d51a66ad4deb84819809b890664245",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMmFlODJmNWMzZDUxYTY2YWQ0ZGViODQ4MTk4MDliODkwNjY0MjQ1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-08-24T19:36:02Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-08T14:32:04Z"
      },
      "message": "[tests] use TestNode p2p connection in tests",
      "tree": {
        "sha": "23e83cfed1f974a3a21df022ec1f207eeb645dae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23e83cfed1f974a3a21df022ec1f207eeb645dae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32ae82f5c3d51a66ad4deb84819809b890664245",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ae82f5c3d51a66ad4deb84819809b890664245",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32ae82f5c3d51a66ad4deb84819809b890664245",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ae82f5c3d51a66ad4deb84819809b890664245/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e5725cc2b56d66510fd85d7ee3822e6df43cd24",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e5725cc2b56d66510fd85d7ee3822e6df43cd24"
      }
    ],
    "stats": {
      "total": 409,
      "additions": 160,
      "deletions": 249
    },
    "files": [
      {
        "sha": "36761d359e291eca5d413b58bbe65eecadc316a6",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 19,
        "deletions": 27,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -39,13 +39,12 @@\n                                      CTxIn,\n                                      CTxOut,\n                                      NetworkThread,\n-                                     NodeConn,\n                                      NodeConnCB,\n                                      msg_block,\n                                      msg_headers)\n from test_framework.script import (CScript, OP_TRUE)\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (p2p_port, assert_equal)\n+from test_framework.util import assert_equal\n \n class BaseNode(NodeConnCB):\n     def send_header_for_blocks(self, new_blocks):\n@@ -65,13 +64,13 @@ def setup_network(self):\n         # signature so we can pass in the block hash as assumevalid.\n         self.start_node(0)\n \n-    def send_blocks_until_disconnected(self, node):\n+    def send_blocks_until_disconnected(self, p2p_conn):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n         for i in range(len(self.blocks)):\n-            if not node.connection:\n+            if not p2p_conn.connection:\n                 break\n             try:\n-                node.send_message(msg_block(self.blocks[i]))\n+                p2p_conn.send_message(msg_block(self.blocks[i]))\n             except IOError as e:\n                 assert str(e) == 'Not connected, no pushbuf'\n                 break\n@@ -97,13 +96,10 @@ def assert_blockchain_height(self, node, height):\n     def run_test(self):\n \n         # Connect to node0\n-        node0 = BaseNode()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        p2p0 = self.nodes[0].add_p2p_connection(BaseNode())\n \n         NetworkThread().start()  # Start up network handling in another thread\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # Build the blockchain\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n@@ -165,37 +161,33 @@ def run_test(self):\n \n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n         self.start_node(1, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n-        node1 = BaseNode()  # connects to node1\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], node1))\n-        node1.add_connection(connections[1])\n-        node1.wait_for_verack()\n+        p2p1 = self.nodes[1].add_p2p_connection(BaseNode())\n+        p2p1.wait_for_verack()\n \n         self.start_node(2, extra_args=[\"-assumevalid=\" + hex(block102.sha256)])\n-        node2 = BaseNode()  # connects to node2\n-        connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n-        node2.add_connection(connections[2])\n-        node2.wait_for_verack()\n+        p2p2 = self.nodes[2].add_p2p_connection(BaseNode())\n+        p2p2.wait_for_verack()\n \n         # send header lists to all three nodes\n-        node0.send_header_for_blocks(self.blocks[0:2000])\n-        node0.send_header_for_blocks(self.blocks[2000:])\n-        node1.send_header_for_blocks(self.blocks[0:2000])\n-        node1.send_header_for_blocks(self.blocks[2000:])\n-        node2.send_header_for_blocks(self.blocks[0:200])\n+        p2p0.send_header_for_blocks(self.blocks[0:2000])\n+        p2p0.send_header_for_blocks(self.blocks[2000:])\n+        p2p1.send_header_for_blocks(self.blocks[0:2000])\n+        p2p1.send_header_for_blocks(self.blocks[2000:])\n+        p2p2.send_header_for_blocks(self.blocks[0:200])\n \n         # Send blocks to node0. Block 102 will be rejected.\n-        self.send_blocks_until_disconnected(node0)\n+        self.send_blocks_until_disconnected(p2p0)\n         self.assert_blockchain_height(self.nodes[0], 101)\n \n         # Send all blocks to node1. All blocks will be accepted.\n         for i in range(2202):\n-            node1.send_message(msg_block(self.blocks[i]))\n+            p2p1.send_message(msg_block(self.blocks[i]))\n         # Syncing 2200 blocks can take a while on slow systems. Give it plenty of time to sync.\n-        node1.sync_with_ping(120)\n+        p2p1.sync_with_ping(120)\n         assert_equal(self.nodes[1].getblock(self.nodes[1].getbestblockhash())['height'], 2202)\n \n         # Send blocks to node2. Block 102 will be rejected.\n-        self.send_blocks_until_disconnected(node2)\n+        self.send_blocks_until_disconnected(p2p2)\n         self.assert_blockchain_height(self.nodes[2], 101)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "30733247984a3d5f24acf70bf3eebdd4f3c66a09",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 18,
        "deletions": 21,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -66,15 +66,12 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n-        node0 = NodeConnCB()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(NodeConnCB())\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # wait_for_verack ensures that the P2P connection is fully up.\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)\n         self.coinbase_blocks = self.nodes[0].generate(CLTV_HEIGHT - 2)\n@@ -95,7 +92,7 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         self.log.info(\"Test that blocks must now be at least version 4\")\n@@ -104,15 +101,15 @@ def run_test(self):\n         block = create_block(tip, create_coinbase(CLTV_HEIGHT), block_time)\n         block.nVersion = 3\n         block.solve()\n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            del node0.last_message[\"reject\"]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            del self.nodes[0].p2p.last_message[\"reject\"]\n \n         self.log.info(\"Test that invalid-according-to-cltv transactions cannot appear in a block\")\n         block.nVersion = 4\n@@ -125,26 +122,26 @@ def run_test(self):\n         # First we show that this tx is valid except for CLTV by getting it\n         # accepted to the mempool (which we can achieve with\n         # -promiscuousmempoolflags).\n-        node0.send_and_ping(msg_tx(spendtx))\n+        self.nodes[0].p2p.send_and_ping(msg_tx(spendtx))\n         assert spendtx.hash in self.nodes[0].getrawmempool()\n \n         # Now we verify that a block with this transaction is invalid.\n         block.vtx.append(spendtx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            if node0.last_message[\"reject\"].code == REJECT_INVALID:\n+            assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n                 # Generic rejection when a block is invalid\n-                assert_equal(node0.last_message[\"reject\"].reason, b'block-validation-failed')\n+                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n             else:\n-                assert b'Negative locktime' in node0.last_message[\"reject\"].reason\n+                assert b'Negative locktime' in self.nodes[0].p2p.last_message[\"reject\"].reason\n \n         self.log.info(\"Test that a version 4 block with a valid-according-to-CLTV transaction is accepted\")\n         spendtx = cltv_validate(self.nodes[0], spendtx, CLTV_HEIGHT - 1)\n@@ -155,7 +152,7 @@ def run_test(self):\n         block.hashMerkleRoot = block.calc_merkle_root()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n \n "
      },
      {
        "sha": "e5febde42da7e8f75437ee5c50af92870279e33a",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 19,
        "deletions": 21,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -54,14 +54,12 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n-        node0 = NodeConnCB()\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(NodeConnCB())\n+\n         NetworkThread().start() # Start up network handling in another thread\n \n         # wait_for_verack ensures that the P2P connection is fully up.\n-        node0.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         self.log.info(\"Mining %d blocks\", DERSIG_HEIGHT - 2)\n         self.coinbase_blocks = self.nodes[0].generate(DERSIG_HEIGHT - 2)\n@@ -83,7 +81,7 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n         self.log.info(\"Test that blocks must now be at least version 3\")\n@@ -93,15 +91,15 @@ def run_test(self):\n         block.nVersion = 2\n         block.rehash()\n         block.solve()\n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n-            assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n-            assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            del node0.last_message[\"reject\"]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].code, REJECT_OBSOLETE)\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            del self.nodes[0].p2p.last_message[\"reject\"]\n \n         self.log.info(\"Test that transactions with non-DER signatures cannot appear in a block\")\n         block.nVersion = 3\n@@ -114,7 +112,7 @@ def run_test(self):\n         # First we show that this tx is valid except for DERSIG by getting it\n         # accepted to the mempool (which we can achieve with\n         # -promiscuousmempoolflags).\n-        node0.send_and_ping(msg_tx(spendtx))\n+        self.nodes[0].p2p.send_and_ping(msg_tx(spendtx))\n         assert spendtx.hash in self.nodes[0].getrawmempool()\n \n         # Now we verify that a block with this transaction is invalid.\n@@ -123,23 +121,23 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n+        wait_until(lambda: \"reject\" in self.nodes[0].p2p.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n             # We can receive different reject messages depending on whether\n             # bitcoind is running with multiple script check threads. If script\n             # check threads are not in use, then transaction script validation\n             # happens sequentially, and bitcoind produces more specific reject\n             # reasons.\n-            assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n-            assert_equal(node0.last_message[\"reject\"].data, block.sha256)\n-            if node0.last_message[\"reject\"].code == REJECT_INVALID:\n+            assert self.nodes[0].p2p.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n+            assert_equal(self.nodes[0].p2p.last_message[\"reject\"].data, block.sha256)\n+            if self.nodes[0].p2p.last_message[\"reject\"].code == REJECT_INVALID:\n                 # Generic rejection when a block is invalid\n-                assert_equal(node0.last_message[\"reject\"].reason, b'block-validation-failed')\n+                assert_equal(self.nodes[0].p2p.last_message[\"reject\"].reason, b'block-validation-failed')\n             else:\n-                assert b'Non-canonical DER signature' in node0.last_message[\"reject\"].reason\n+                assert b'Non-canonical DER signature' in self.nodes[0].p2p.last_message[\"reject\"].reason\n \n         self.log.info(\"Test that a version 3 block with a DERSIG-compliant transaction is accepted\")\n         block.vtx[1] = create_transaction(self.nodes[0],\n@@ -148,7 +146,7 @@ def run_test(self):\n         block.rehash()\n         block.solve()\n \n-        node0.send_and_ping(msg_block(block))\n+        self.nodes[0].p2p.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "9c92aa1dc0652dbeac37a985797e8e1e58463cbd",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 34,
        "deletions": 37,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -49,19 +49,17 @@ def run_test(self):\n         # Generate some old blocks\n         self.nodes[0].generate(130)\n \n-        # test_nodes[0] will only request old blocks\n-        # test_nodes[1] will only request new blocks\n-        # test_nodes[2] will test resetting the counters\n-        test_nodes = []\n-        connections = []\n+        # p2p_conns[0] will only request old blocks\n+        # p2p_conns[1] will only request new blocks\n+        # p2p_conns[2] will test resetting the counters\n+        p2p_conns = []\n \n         for i in range(3):\n-            test_nodes.append(TestNode())\n-            connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[i]))\n-            test_nodes[i].add_connection(connections[i])\n+            p2p_conns.append(self.nodes[0].add_p2p_connection(TestNode()))\n \n         NetworkThread().start() # Start up network handling in another thread\n-        [x.wait_for_verack() for x in test_nodes]\n+        for p2pc in p2p_conns:\n+            p2pc.wait_for_verack()\n \n         # Test logic begins here\n \n@@ -83,7 +81,7 @@ def run_test(self):\n         big_new_block = self.nodes[0].getbestblockhash()\n         big_new_block = int(big_new_block, 16)\n \n-        # test_nodes[0] will test what happens if we just keep requesting the\n+        # p2p_conns[0] will test what happens if we just keep requesting the\n         # the same big old block too many times (expect: disconnect)\n \n         getdata_request = msg_getdata()\n@@ -97,74 +95,73 @@ def run_test(self):\n         # 576MB will be reserved for relaying new blocks, so expect this to\n         # succeed for ~235 tries.\n         for i in range(success_count):\n-            test_nodes[0].send_message(getdata_request)\n-            test_nodes[0].sync_with_ping()\n-            assert_equal(test_nodes[0].block_receive_map[big_old_block], i+1)\n+            p2p_conns[0].send_message(getdata_request)\n+            p2p_conns[0].sync_with_ping()\n+            assert_equal(p2p_conns[0].block_receive_map[big_old_block], i+1)\n \n         assert_equal(len(self.nodes[0].getpeerinfo()), 3)\n         # At most a couple more tries should succeed (depending on how long \n         # the test has been running so far).\n         for i in range(3):\n-            test_nodes[0].send_message(getdata_request)\n-        test_nodes[0].wait_for_disconnect()\n+            p2p_conns[0].send_message(getdata_request)\n+        p2p_conns[0].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 2)\n         self.log.info(\"Peer 0 disconnected after downloading old block too many times\")\n \n-        # Requesting the current block on test_nodes[1] should succeed indefinitely,\n+        # Requesting the current block on p2p_conns[1] should succeed indefinitely,\n         # even when over the max upload target.\n         # We'll try 800 times\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(800):\n-            test_nodes[1].send_message(getdata_request)\n-            test_nodes[1].sync_with_ping()\n-            assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)\n+            p2p_conns[1].send_message(getdata_request)\n+            p2p_conns[1].sync_with_ping()\n+            assert_equal(p2p_conns[1].block_receive_map[big_new_block], i+1)\n \n         self.log.info(\"Peer 1 able to repeatedly download new block\")\n \n-        # But if test_nodes[1] tries for an old block, it gets disconnected too.\n+        # But if p2p_conns[1] tries for an old block, it gets disconnected too.\n         getdata_request.inv = [CInv(2, big_old_block)]\n-        test_nodes[1].send_message(getdata_request)\n-        test_nodes[1].wait_for_disconnect()\n+        p2p_conns[1].send_message(getdata_request)\n+        p2p_conns[1].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 1)\n \n         self.log.info(\"Peer 1 disconnected after trying to download old block\")\n \n         self.log.info(\"Advancing system time on node to clear counters...\")\n \n         # If we advance the time by 24 hours, then the counters should reset,\n-        # and test_nodes[2] should be able to retrieve the old block.\n+        # and p2p_conns[2] should be able to retrieve the old block.\n         self.nodes[0].setmocktime(int(time.time()))\n-        test_nodes[2].sync_with_ping()\n-        test_nodes[2].send_message(getdata_request)\n-        test_nodes[2].sync_with_ping()\n-        assert_equal(test_nodes[2].block_receive_map[big_old_block], 1)\n+        p2p_conns[2].sync_with_ping()\n+        p2p_conns[2].send_message(getdata_request)\n+        p2p_conns[2].sync_with_ping()\n+        assert_equal(p2p_conns[2].block_receive_map[big_old_block], 1)\n \n         self.log.info(\"Peer 2 able to download old block\")\n \n-        [c.disconnect_node() for c in connections]\n+        for i in range(3):\n+            self.nodes[0].disconnect_p2p()\n \n         #stop and start node 0 with 1MB maxuploadtarget, whitelist 127.0.0.1\n         self.log.info(\"Restarting nodes with -whitelist=127.0.0.1\")\n         self.stop_node(0)\n         self.start_node(0, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n-        #recreate/reconnect a test node\n-        test_nodes = [TestNode()]\n-        connections = [NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_nodes[0])]\n-        test_nodes[0].add_connection(connections[0])\n+        # Reconnect to self.nodes[0]\n+        self.nodes[0].add_p2p_connection(TestNode())\n \n         NetworkThread().start() # Start up network handling in another thread\n-        test_nodes[0].wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         #retrieve 20 blocks which should be enough to break the 1MB limit\n         getdata_request.inv = [CInv(2, big_new_block)]\n         for i in range(20):\n-            test_nodes[0].send_message(getdata_request)\n-            test_nodes[0].sync_with_ping()\n-            assert_equal(test_nodes[0].block_receive_map[big_new_block], i+1)\n+            self.nodes[0].p2p.send_message(getdata_request)\n+            self.nodes[0].p2p.sync_with_ping()\n+            assert_equal(self.nodes[0].p2p.block_receive_map[big_new_block], i+1)\n \n         getdata_request.inv = [CInv(2, big_old_block)]\n-        test_nodes[0].send_and_ping(getdata_request)\n+        self.nodes[0].p2p.send_and_ping(getdata_request)\n         assert_equal(len(self.nodes[0].getpeerinfo()), 1) #node is still connected because of the whitelist\n \n         self.log.info(\"Peer still connected after trying to download old block (whitelisted)\")"
      },
      {
        "sha": "fbe5a78029215f7f68782d5c1242de7394636c8c",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 8,
        "deletions": 18,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -78,14 +78,10 @@ def setup_network(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        test_node = NodeConnCB()   # connects to node0\n-        min_work_node = NodeConnCB()  # connects to node1\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], min_work_node))\n-        test_node.add_connection(connections[0])\n-        min_work_node.add_connection(connections[1])\n+        # test_node connects to node0 (not whitelisted)\n+        test_node = self.nodes[0].add_p2p_connection(NodeConnCB())\n+        # min_work_node connects to node1\n+        min_work_node = self.nodes[1].add_p2p_connection(NodeConnCB())\n \n         NetworkThread().start() # Start up network handling in another thread\n \n@@ -209,12 +205,9 @@ def run_test(self):\n \n         # The node should have requested the blocks at some point, so\n         # disconnect/reconnect first\n-        connections[0].disconnect_node()\n-        test_node.wait_for_disconnect()\n \n-        test_node = NodeConnCB()   # connects to node (not whitelisted)\n-        connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n-        test_node.add_connection(connections[0])\n+        self.nodes[0].disconnect_p2p()\n+        test_node = self.nodes[0].add_p2p_connection(NodeConnCB())\n \n         test_node.wait_for_verack()\n         test_node.send_message(msg_block(block_h1f))\n@@ -298,9 +291,8 @@ def run_test(self):\n         except AssertionError:\n             test_node.wait_for_disconnect()\n \n-            test_node = NodeConnCB()   # connects to node (not whitelisted)\n-            connections[0] = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n-            test_node.add_connection(connections[0])\n+            self.nodes[0].disconnect_p2p()\n+            test_node = self.nodes[0].add_p2p_connection(NodeConnCB())\n \n             NetworkThread().start() # Start up network handling in another thread\n             test_node.wait_for_verack()\n@@ -323,7 +315,5 @@ def run_test(self):\n         sync_blocks([self.nodes[0], self.nodes[1]])\n         self.log.info(\"Successfully synced nodes 1 and 0\")\n \n-        [ c.disconnect_node() for c in connections ]\n-\n if __name__ == '__main__':\n     AcceptBlockTest().main()"
      },
      {
        "sha": "d2c4d39305be6595e2905d9d80d6ed4bfa3d2a67",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 3,
        "deletions": 14,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -788,23 +788,12 @@ def announce_cmpct_block(node, peer):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        self.test_node = TestNode()\n-        self.segwit_node = TestNode()\n-        self.old_node = TestNode()  # version 1 peer <--> segwit node\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n-                    self.segwit_node, services=NODE_NETWORK|NODE_WITNESS))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n-                    self.old_node, services=NODE_NETWORK))\n-        self.test_node.add_connection(connections[0])\n-        self.segwit_node.add_connection(connections[1])\n-        self.old_node.add_connection(connections[2])\n+        self.test_node = self.nodes[0].add_p2p_connection(TestNode())\n+        self.segwit_node = self.nodes[1].add_p2p_connection(TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n+        self.old_node = self.nodes[1].add_p2p_connection(TestNode(), services=NODE_NETWORK)\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n-        # Test logic begins here\n         self.test_node.wait_for_verack()\n \n         # We will need UTXOs to construct transactions in later tests."
      },
      {
        "sha": "624278df40db723344ca2fbdb268c319c34df06d",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -48,25 +48,23 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # Setup the p2p connections and start up the network thread.\n-        test_node = TestNode()\n-        connection = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node)\n-        test_node.add_connection(connection)\n+        self.nodes[0].add_p2p_connection(TestNode())\n         NetworkThread().start()\n-        test_node.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # Test that invs are received for all txs at feerate of 20 sat/byte\n         node1.settxfee(Decimal(\"0.00020000\"))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n         # Set a filter of 15 sat/byte\n-        test_node.send_and_ping(msg_feefilter(15000))\n+        self.nodes[0].p2p.send_and_ping(msg_feefilter(15000))\n \n         # Test that txs are still being received (paying 20 sat/byte)\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n         # Change tx fee rate to 10 sat/byte and test they are no longer received\n         node1.settxfee(Decimal(\"0.00010000\"))\n@@ -82,14 +80,14 @@ def run_test(self):\n         # as well.\n         node0.settxfee(Decimal(\"0.00020000\"))\n         txids = [node0.sendtoaddress(node0.getnewaddress(), 1)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n         # Remove fee filter and check that txs are received again\n-        test_node.send_and_ping(msg_feefilter(0))\n+        self.nodes[0].p2p.send_and_ping(msg_feefilter(0))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert(allInvsMatch(txids, test_node))\n-        test_node.clear_invs()\n+        assert(allInvsMatch(txids, self.nodes[0].p2p))\n+        self.nodes[0].p2p.clear_invs()\n \n if __name__ == '__main__':\n     FeeFilterTest().main()"
      },
      {
        "sha": "4b6446fc5bed37ee0f04a35fc451ab866fbb9b8d",
        "filename": "test/functional/p2p-fingerprint.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-fingerprint.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -14,7 +14,6 @@\n from test_framework.mininode import (\n     CInv,\n     NetworkThread,\n-    NodeConn,\n     NodeConnCB,\n     msg_headers,\n     msg_block,\n@@ -77,11 +76,7 @@ def last_header_equals(self, expected_hash, node):\n     # This does not currently test that stale blocks timestamped within the\n     # last month but that have over a month's worth of work are also withheld.\n     def run_test(self):\n-        node0 = NodeConnCB()\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], node0))\n-        node0.add_connection(connections[0])\n+        node0 = self.nodes[0].add_p2p_connection(NodeConnCB())\n \n         NetworkThread().start()\n         node0.wait_for_verack()"
      },
      {
        "sha": "2499624f2db59d1dfb795b9da281b2f073a80795",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 10,
        "deletions": 25,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -97,24 +97,13 @@ def set_test_params(self):\n         self.extra_args = [['-banscore='+str(banscore)]]\n \n     def run_test(self):\n-        no_version_bannode = CNodeNoVersionBan()\n-        no_version_idlenode = CNodeNoVersionIdle()\n-        no_verack_idlenode = CNodeNoVerackIdle()\n-        unsupported_service_bit5_node = CLazyNode()\n-        unsupported_service_bit7_node = CLazyNode()\n-\n         self.nodes[0].setmocktime(1501545600)  # August 1st 2017\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_version_bannode, send_version=False))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_version_idlenode, send_version=False))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], no_verack_idlenode))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], unsupported_service_bit5_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], unsupported_service_bit7_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7))\n-        no_version_bannode.add_connection(connections[0])\n-        no_version_idlenode.add_connection(connections[1])\n-        no_verack_idlenode.add_connection(connections[2])\n-        unsupported_service_bit5_node.add_connection(connections[3])\n-        unsupported_service_bit7_node.add_connection(connections[4])\n+\n+        no_version_bannode = self.nodes[0].add_p2p_connection(CNodeNoVersionBan(), send_version=False)\n+        no_version_idlenode = self.nodes[0].add_p2p_connection(CNodeNoVersionIdle(), send_version=False)\n+        no_verack_idlenode = self.nodes[0].add_p2p_connection(CNodeNoVerackIdle())\n+        unsupported_service_bit5_node = self.nodes[0].add_p2p_connection(CLazyNode(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n+        unsupported_service_bit7_node = self.nodes[0].add_p2p_connection(CLazyNode(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n@@ -137,7 +126,8 @@ def run_test(self):\n         assert not unsupported_service_bit5_node.connected\n         assert not unsupported_service_bit7_node.connected\n \n-        [conn.disconnect_node() for conn in connections]\n+        for _ in range(5):\n+            self.nodes[0].disconnect_p2p()\n \n         # Wait until all connections are closed\n         wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0)\n@@ -152,13 +142,8 @@ def run_test(self):\n         self.log.info(\"Service bits 5 and 7 are allowed after August 1st 2018\")\n         self.nodes[0].setmocktime(1533168000)  # August 2nd 2018\n \n-        allowed_service_bit5_node = NodeConnCB()\n-        allowed_service_bit7_node = NodeConnCB()\n-\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], allowed_service_bit5_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], allowed_service_bit7_node, services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7))\n-        allowed_service_bit5_node.add_connection(connections[5])\n-        allowed_service_bit7_node.add_connection(connections[6])\n+        allowed_service_bit5_node = self.nodes[0].add_p2p_connection(NodeConnCB(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_5)\n+        allowed_service_bit7_node = self.nodes[0].add_p2p_connection(NodeConnCB(), services=NODE_NETWORK|NODE_UNSUPPORTED_SERVICE_BIT_7)\n \n         NetworkThread().start()  # Network thread stopped when all previous NodeConnCBs disconnected. Restart it\n "
      },
      {
        "sha": "be467c42232b4cb0497ea274f0c8a767e77f98ab",
        "filename": "test/functional/p2p-mempool.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-mempool.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -19,16 +19,14 @@ def set_test_params(self):\n         self.extra_args = [[\"-peerbloomfilters=0\"]]\n \n     def run_test(self):\n-        #connect a mininode\n-        aTestNode = NodeConnCB()\n-        node = NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], aTestNode)\n-        aTestNode.add_connection(node)\n+        # Add a p2p connection\n+        self.nodes[0].add_p2p_connection(NodeConnCB())\n         NetworkThread().start()\n-        aTestNode.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         #request mempool\n-        aTestNode.send_message(msg_mempool())\n-        aTestNode.wait_for_disconnect()\n+        self.nodes[0].p2p.send_message(msg_mempool())\n+        self.nodes[0].p2p.wait_for_disconnect()\n \n         #mininode must be disconnected at this point\n         assert_equal(len(self.nodes[0].getpeerinfo()), 0)"
      },
      {
        "sha": "22da7f2db123b6e7383d4904ee39dd2b07549bb2",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 6,
        "deletions": 13,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -1868,19 +1868,12 @@ def test_non_standard_witness(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        self.test_node = TestNode() # sets NODE_WITNESS|NODE_NETWORK\n-        self.old_node = TestNode()  # only NODE_NETWORK\n-        self.std_node = TestNode() # for testing node1 (fRequireStandard=true)\n-\n-        self.p2p_connections = [self.test_node, self.old_node]\n-\n-        self.connections = []\n-        self.connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=NODE_NETWORK|NODE_WITNESS))\n-        self.connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.old_node, services=NODE_NETWORK))\n-        self.connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], self.std_node, services=NODE_NETWORK|NODE_WITNESS))\n-        self.test_node.add_connection(self.connections[0])\n-        self.old_node.add_connection(self.connections[1])\n-        self.std_node.add_connection(self.connections[2])\n+        # self.test_node sets NODE_WITNESS|NODE_NETWORK\n+        self.test_node = self.nodes[0].add_p2p_connection(TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n+        # self.old_node sets only NODE_NETWORK\n+        self.old_node = self.nodes[0].add_p2p_connection(TestNode(), services=NODE_NETWORK)\n+        # self.std_node is for testing node1 (fRequireStandard=true)\n+        self.std_node = self.nodes[1].add_p2p_connection(TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      },
      {
        "sha": "14a3bf48fbc99766e31a836c86d3b157797ea728",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 17,
        "deletions": 26,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -39,46 +39,37 @@ def set_test_params(self):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        self.no_verack_node = TestNode() # never send verack\n-        self.no_version_node = TestNode() # never send version (just ping)\n-        self.no_send_node = TestNode() # never send anything\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_verack_node))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_version_node, send_version=False))\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.no_send_node, send_version=False))\n-        self.no_verack_node.add_connection(connections[0])\n-        self.no_version_node.add_connection(connections[1])\n-        self.no_send_node.add_connection(connections[2])\n+        no_verack_node = self.nodes[0].add_p2p_connection(TestNode())\n+        no_version_node = self.nodes[0].add_p2p_connection(TestNode(), send_version=False)\n+        no_send_node = self.nodes[0].add_p2p_connection(TestNode(), send_version=False)\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n         sleep(1)\n \n-        assert(self.no_verack_node.connected)\n-        assert(self.no_version_node.connected)\n-        assert(self.no_send_node.connected)\n+        assert no_verack_node.connected\n+        assert no_version_node.connected\n+        assert no_send_node.connected\n \n-        ping_msg = msg_ping()\n-        connections[0].send_message(ping_msg)\n-        connections[1].send_message(ping_msg)\n+        no_verack_node.send_message(msg_ping())\n+        no_version_node.send_message(msg_ping())\n \n         sleep(30)\n \n-        assert \"version\" in self.no_verack_node.last_message\n+        assert \"version\" in no_verack_node.last_message\n \n-        assert(self.no_verack_node.connected)\n-        assert(self.no_version_node.connected)\n-        assert(self.no_send_node.connected)\n+        assert no_verack_node.connected\n+        assert no_version_node.connected\n+        assert no_send_node.connected\n \n-        connections[0].send_message(ping_msg)\n-        connections[1].send_message(ping_msg)\n+        no_verack_node.send_message(msg_ping())\n+        no_version_node.send_message(msg_ping())\n \n         sleep(31)\n \n-        assert(not self.no_verack_node.connected)\n-        assert(not self.no_version_node.connected)\n-        assert(not self.no_send_node.connected)\n+        assert not no_verack_node.connected\n+        assert not no_version_node.connected\n+        assert not no_send_node.connected\n \n if __name__ == '__main__':\n     TimeoutsTest().main()"
      },
      {
        "sha": "464ca5a3125404bf3168141bdf3a6ed76da7f8fa",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -64,24 +64,20 @@ def test_versionbits_in_alert_file(self):\n \n     def run_test(self):\n         # Setup the p2p connection and start up the network thread.\n-        test_node = TestNode()\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node))\n-        test_node.add_connection(connections[0])\n+        self.nodes[0].add_p2p_connection(TestNode())\n \n         NetworkThread().start() # Start up network handling in another thread\n \n         # Test logic begins here\n-        test_node.wait_for_verack()\n+        self.nodes[0].p2p.wait_for_verack()\n \n         # 1. Have the node mine one period worth of blocks\n         self.nodes[0].generate(VB_PERIOD)\n \n         # 2. Now build one period of blocks on the tip, with < VB_THRESHOLD\n         # blocks signaling some unknown bit.\n         nVersion = VB_TOP_BITS | (1<<VB_UNKNOWN_BIT)\n-        self.send_blocks_with_version(test_node, VB_THRESHOLD-1, nVersion)\n+        self.send_blocks_with_version(self.nodes[0].p2p, VB_THRESHOLD-1, nVersion)\n \n         # Fill rest of period with regular version blocks\n         self.nodes[0].generate(VB_PERIOD - VB_THRESHOLD + 1)\n@@ -92,7 +88,7 @@ def run_test(self):\n \n         # 3. Now build one period of blocks with >= VB_THRESHOLD blocks signaling\n         # some unknown bit\n-        self.send_blocks_with_version(test_node, VB_THRESHOLD, nVersion)\n+        self.send_blocks_with_version(self.nodes[0].p2p, VB_THRESHOLD, nVersion)\n         self.nodes[0].generate(VB_PERIOD - VB_THRESHOLD)\n         # Might not get a versionbits-related alert yet, as we should\n         # have gotten a different alert due to more than 51/100 blocks"
      },
      {
        "sha": "82cbc5a110a092cb0ffb0c0ee1c68e24d3d6c3fc",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 4,
        "deletions": 12,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ae82f5c3d51a66ad4deb84819809b890664245/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=32ae82f5c3d51a66ad4deb84819809b890664245",
        "patch": "@@ -181,7 +181,7 @@ def set_test_params(self):\n     # mine count blocks and return the new tip\n     def mine_blocks(self, count):\n         # Clear out last block announcement from each p2p listener\n-        [ x.clear_last_announcement() for x in self.p2p_connections ]\n+        [x.clear_last_announcement() for x in self.nodes[0].p2ps]\n         self.nodes[0].generate(count)\n         return int(self.nodes[0].getbestblockhash(), 16)\n \n@@ -193,7 +193,7 @@ def mine_blocks(self, count):\n     def mine_reorg(self, length):\n         self.nodes[0].generate(length) # make sure all invalidated blocks are node0's\n         sync_blocks(self.nodes, wait=0.1)\n-        for x in self.p2p_connections:\n+        for x in self.nodes[0].p2ps:\n             x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n             x.clear_last_announcement()\n \n@@ -206,18 +206,10 @@ def mine_reorg(self, length):\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n-        inv_node = TestNode()\n-        test_node = TestNode()\n-\n-        self.p2p_connections = [inv_node, test_node]\n-\n-        connections = []\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], inv_node))\n+        inv_node = self.nodes[0].add_p2p_connection(TestNode())\n         # Set nServices to 0 for test_node, so no block download will occur outside of\n         # direct fetching\n-        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test_node, services=NODE_WITNESS))\n-        inv_node.add_connection(connections[0])\n-        test_node.add_connection(connections[1])\n+        test_node = self.nodes[0].add_p2p_connection(TestNode(), services=NODE_WITNESS)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      }
    ]
  }
]