[
  {
    "sha": "7c4f0091957d305679546fde592ffa2de2d186fe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YzRmMDA5MTk1N2QzMDU2Nzk1NDZmZGU1OTJmZmEyZGUyZDE4NmZl",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-09-20T20:04:05Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-10T22:01:41Z"
      },
      "message": "[trivial] Rename feebumper variables according to project code style\n\nFuture PRs will completely refactor this translation unit and touch all\nthis code so we rename the variables to follow project stlye guidelines\nin this preparation commit.\n\nDon't use m_ prefixes for member variables since we're going to remove\nthe class entirely in the next commits.",
      "tree": {
        "sha": "ad385520edd3d7ce8daf449d4d6e2558f6959997",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad385520edd3d7ce8daf449d4d6e2558f6959997"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c4f0091957d305679546fde592ffa2de2d186fe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c4f0091957d305679546fde592ffa2de2d186fe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c4f0091957d305679546fde592ffa2de2d186fe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c4f0091957d305679546fde592ffa2de2d186fe/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05a761932edd05cf94ffe938908baf058f38632a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05a761932edd05cf94ffe938908baf058f38632a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05a761932edd05cf94ffe938908baf058f38632a"
      }
    ],
    "stats": {
      "total": 204,
      "additions": 102,
      "deletions": 102
    },
    "files": [
      {
        "sha": "d850c5e55bbc3870148d44bba10e532b56f36ec3",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c4f0091957d305679546fde592ffa2de2d186fe/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c4f0091957d305679546fde592ffa2de2d186fe/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=7c4f0091957d305679546fde592ffa2de2d186fe",
        "patch": "@@ -666,12 +666,12 @@ bool WalletModel::transactionCanBeBumped(uint256 hash) const\n \n bool WalletModel::bumpFee(uint256 hash)\n {\n-    std::unique_ptr<CFeeBumper> feeBump;\n+    std::unique_ptr<FeeBumper> feeBump;\n     {\n         CCoinControl coin_control;\n         coin_control.signalRbf = true;\n         LOCK2(cs_main, wallet->cs_wallet);\n-        feeBump.reset(new CFeeBumper(wallet, hash, coin_control, 0));\n+        feeBump.reset(new FeeBumper(wallet, hash, coin_control, 0));\n     }\n     if (feeBump->getResult() != BumpFeeResult::OK)\n     {"
      },
      {
        "sha": "fa64c215459040c9aaa967d8ef1379aae5cb6083",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 83,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c4f0091957d305679546fde592ffa2de2d186fe/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c4f0091957d305679546fde592ffa2de2d186fe/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=7c4f0091957d305679546fde592ffa2de2d186fe",
        "patch": "@@ -23,123 +23,123 @@\n // calculation, but we should be able to refactor after priority is removed).\n // NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n // be IsAllFromMe).\n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWallet)\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n {\n     CMutableTransaction txNew(tx);\n     std::vector<CInputCoin> vCoins;\n     // Look up the inputs.  We should have already checked that this transaction\n     // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n     // wallet, with a valid index into the vout array.\n     for (auto& input : tx.vin) {\n-        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n-        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != wallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n         vCoins.emplace_back(CInputCoin(&(mi->second), input.prevout.n));\n     }\n-    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+    if (!wallet->DummySignTx(txNew, vCoins)) {\n         // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n         // implies that we can sign for every input.\n         return -1;\n     }\n     return GetVirtualTransactionSize(txNew);\n }\n \n-bool CFeeBumper::preconditionChecks(const CWallet *pWallet, const CWalletTx& wtx) {\n-    if (pWallet->HasWalletSpend(wtx.GetHash())) {\n-        vErrors.push_back(\"Transaction has descendants in the wallet\");\n-        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+bool FeeBumper::preconditionChecks(const CWallet *wallet, const CWalletTx& wtx) {\n+    if (wallet->HasWalletSpend(wtx.GetHash())) {\n+        errors.push_back(\"Transaction has descendants in the wallet\");\n+        current_result = BumpFeeResult::INVALID_PARAMETER;\n         return false;\n     }\n \n     {\n         LOCK(mempool.cs);\n         auto it_mp = mempool.mapTx.find(wtx.GetHash());\n         if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n-            vErrors.push_back(\"Transaction has descendants in the mempool\");\n-            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            errors.push_back(\"Transaction has descendants in the mempool\");\n+            current_result = BumpFeeResult::INVALID_PARAMETER;\n             return false;\n         }\n     }\n \n     if (wtx.GetDepthInMainChain() != 0) {\n-        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+        errors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return false;\n     }\n     return true;\n }\n \n-CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, const CCoinControl& coin_control, CAmount totalFee)\n+FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinControl& coin_control, CAmount total_fee)\n     :\n-    txid(std::move(txidIn)),\n-    nOldFee(0),\n-    nNewFee(0)\n+    txid(std::move(txid_in)),\n+    old_fee(0),\n+    new_fee(0)\n {\n-    vErrors.clear();\n-    bumpedTxid.SetNull();\n-    AssertLockHeld(pWallet->cs_wallet);\n-    auto it = pWallet->mapWallet.find(txid);\n-    if (it == pWallet->mapWallet.end()) {\n-        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n-        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+    errors.clear();\n+    bumped_txid.SetNull();\n+    AssertLockHeld(wallet->cs_wallet);\n+    auto it = wallet->mapWallet.find(txid);\n+    if (it == wallet->mapWallet.end()) {\n+        errors.push_back(\"Invalid or non-wallet transaction id\");\n+        current_result = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n         return;\n     }\n     const CWalletTx& wtx = it->second;\n \n-    if (!preconditionChecks(pWallet, wtx)) {\n+    if (!preconditionChecks(wallet, wtx)) {\n         return;\n     }\n \n     if (!SignalsOptInRBF(*wtx.tx)) {\n-        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+        errors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return;\n     }\n \n     if (wtx.mapValue.count(\"replaced_by_txid\")) {\n-        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+        errors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return;\n     }\n \n     // check that original tx consists entirely of our inputs\n     // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n-    if (!pWallet->IsAllFromMe(*wtx.tx, ISMINE_SPENDABLE)) {\n-        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+    if (!wallet->IsAllFromMe(*wtx.tx, ISMINE_SPENDABLE)) {\n+        errors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return;\n     }\n \n     // figure out which output was change\n     // if there was no change output or multiple change outputs, fail\n     int nOutput = -1;\n     for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n-        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+        if (wallet->IsChange(wtx.tx->vout[i])) {\n             if (nOutput != -1) {\n-                vErrors.push_back(\"Transaction has multiple change outputs\");\n-                currentResult = BumpFeeResult::WALLET_ERROR;\n+                errors.push_back(\"Transaction has multiple change outputs\");\n+                current_result = BumpFeeResult::WALLET_ERROR;\n                 return;\n             }\n             nOutput = i;\n         }\n     }\n     if (nOutput == -1) {\n-        vErrors.push_back(\"Transaction does not have a change output\");\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+        errors.push_back(\"Transaction does not have a change output\");\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return;\n     }\n \n     // Calculate the expected size of the new transaction.\n     int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n-    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx, pWallet);\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx, wallet);\n     if (maxNewTxSize < 0) {\n-        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n-        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        errors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        current_result = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n         return;\n     }\n \n     // calculate the old fee and fee-rate\n-    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n-    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    old_fee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(old_fee, txSize);\n     CFeeRate nNewFeeRate;\n     // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n     // future proof against changes to network wide policy for incremental relay\n@@ -149,26 +149,26 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, const CCoin\n         walletIncrementalRelayFee = ::incrementalRelayFee;\n     }\n \n-    if (totalFee > 0) {\n+    if (total_fee > 0) {\n         CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n-        if (totalFee < minTotalFee) {\n-            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+        if (total_fee < minTotalFee) {\n+            errors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n                                                                 FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n-            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            current_result = BumpFeeResult::INVALID_PARAMETER;\n             return;\n         }\n         CAmount requiredFee = GetRequiredFee(maxNewTxSize);\n-        if (totalFee < requiredFee) {\n-            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+        if (total_fee < requiredFee) {\n+            errors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n                                                                 FormatMoney(requiredFee)));\n-            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            current_result = BumpFeeResult::INVALID_PARAMETER;\n             return;\n         }\n-        nNewFee = totalFee;\n-        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+        new_fee = total_fee;\n+        nNewFeeRate = CFeeRate(total_fee, maxNewTxSize);\n     } else {\n-        nNewFee = GetMinimumFee(maxNewTxSize, coin_control, mempool, ::feeEstimator, nullptr /* FeeCalculation */);\n-        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+        new_fee = GetMinimumFee(maxNewTxSize, coin_control, mempool, ::feeEstimator, nullptr /* FeeCalculation */);\n+        nNewFeeRate = CFeeRate(new_fee, maxNewTxSize);\n \n         // New fee rate must be at least old rate + minimum incremental relay rate\n         // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n@@ -177,53 +177,53 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, const CCoin\n         // add 1 satoshi to the result, because it may have been rounded down.\n         if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n             nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n-            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+            new_fee = nNewFeeRate.GetFee(maxNewTxSize);\n         }\n     }\n \n     // Check that in all cases the new fee doesn't violate maxTxFee\n-     if (nNewFee > maxTxFee) {\n-         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n-                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n-         currentResult = BumpFeeResult::WALLET_ERROR;\n+     if (new_fee > maxTxFee) {\n+         errors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(new_fee), FormatMoney(maxTxFee)));\n+         current_result = BumpFeeResult::WALLET_ERROR;\n          return;\n      }\n \n     // check that fee rate is higher than mempool's minimum fee\n     // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n     // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n     // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n-    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    // moment earlier. In this case, we report an error to the user, who may use total_fee to make an adjustment.\n     CFeeRate minMempoolFeeRate = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n     if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n-        vErrors.push_back(strprintf(\n+        errors.push_back(strprintf(\n             \"New fee rate (%s) is lower than the minimum fee rate (%s) to get into the mempool -- \"\n             \"the totalFee value should be at least %s or the settxfee value should be at least %s to add transaction\",\n             FormatMoney(nNewFeeRate.GetFeePerK()),\n             FormatMoney(minMempoolFeeRate.GetFeePerK()),\n             FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)),\n             FormatMoney(minMempoolFeeRate.GetFeePerK())));\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return;\n     }\n \n     // Now modify the output to increase the fee.\n     // If the output is not large enough to pay the fee, fail.\n-    CAmount nDelta = nNewFee - nOldFee;\n+    CAmount nDelta = new_fee - old_fee;\n     assert(nDelta > 0);\n     mtx =  *wtx.tx;\n     CTxOut* poutput = &(mtx.vout[nOutput]);\n     if (poutput->nValue < nDelta) {\n-        vErrors.push_back(\"Change output is too small to bump the fee\");\n-        currentResult = BumpFeeResult::WALLET_ERROR;\n+        errors.push_back(\"Change output is too small to bump the fee\");\n+        current_result = BumpFeeResult::WALLET_ERROR;\n         return;\n     }\n \n     // If the output would become dust, discard it (converting the dust to fee)\n     poutput->nValue -= nDelta;\n     if (poutput->nValue <= GetDustThreshold(*poutput, ::dustRelayFee)) {\n         LogPrint(BCLog::RPC, \"Bumping fee and discarding dust output\\n\");\n-        nNewFee += poutput->nValue;\n+        new_fee += poutput->nValue;\n         mtx.vout.erase(mtx.vout.begin() + nOutput);\n     }\n \n@@ -234,63 +234,63 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, const CCoin\n         }\n     }\n \n-    currentResult = BumpFeeResult::OK;\n+    current_result = BumpFeeResult::OK;\n }\n \n-bool CFeeBumper::signTransaction(CWallet *pWallet)\n+bool FeeBumper::signTransaction(CWallet *wallet)\n {\n-     return pWallet->SignTransaction(mtx);\n+     return wallet->SignTransaction(mtx);\n }\n \n-bool CFeeBumper::commit(CWallet *pWallet)\n+bool FeeBumper::commit(CWallet *wallet)\n {\n-    AssertLockHeld(pWallet->cs_wallet);\n-    if (!vErrors.empty() || currentResult != BumpFeeResult::OK) {\n+    AssertLockHeld(wallet->cs_wallet);\n+    if (!errors.empty() || current_result != BumpFeeResult::OK) {\n         return false;\n     }\n-    auto it = txid.IsNull() ? pWallet->mapWallet.end() : pWallet->mapWallet.find(txid);\n-    if (it == pWallet->mapWallet.end()) {\n-        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n-        currentResult = BumpFeeResult::MISC_ERROR;\n+    auto it = txid.IsNull() ? wallet->mapWallet.end() : wallet->mapWallet.find(txid);\n+    if (it == wallet->mapWallet.end()) {\n+        errors.push_back(\"Invalid or non-wallet transaction id\");\n+        current_result = BumpFeeResult::MISC_ERROR;\n         return false;\n     }\n     CWalletTx& oldWtx = it->second;\n \n     // make sure the transaction still has no descendants and hasn't been mined in the meantime\n-    if (!preconditionChecks(pWallet, oldWtx)) {\n+    if (!preconditionChecks(wallet, oldWtx)) {\n         return false;\n     }\n \n-    CWalletTx wtxBumped(pWallet, MakeTransactionRef(std::move(mtx)));\n+    CWalletTx wtxBumped(wallet, MakeTransactionRef(std::move(mtx)));\n     // commit/broadcast the tx\n-    CReserveKey reservekey(pWallet);\n+    CReserveKey reservekey(wallet);\n     wtxBumped.mapValue = oldWtx.mapValue;\n     wtxBumped.mapValue[\"replaces_txid\"] = oldWtx.GetHash().ToString();\n     wtxBumped.vOrderForm = oldWtx.vOrderForm;\n     wtxBumped.strFromAccount = oldWtx.strFromAccount;\n     wtxBumped.fTimeReceivedIsTxTime = true;\n     wtxBumped.fFromMe = true;\n     CValidationState state;\n-    if (!pWallet->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+    if (!wallet->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n         // NOTE: CommitTransaction never returns false, so this should never happen.\n-        vErrors.push_back(strprintf(\"The transaction was rejected: %s\", state.GetRejectReason()));\n+        errors.push_back(strprintf(\"The transaction was rejected: %s\", state.GetRejectReason()));\n         return false;\n     }\n \n-    bumpedTxid = wtxBumped.GetHash();\n+    bumped_txid = wtxBumped.GetHash();\n     if (state.IsInvalid()) {\n         // This can happen if the mempool rejected the transaction.  Report\n         // what happened in the \"errors\" response.\n-        vErrors.push_back(strprintf(\"The transaction was rejected: %s\", FormatStateMessage(state)));\n+        errors.push_back(strprintf(\"The transaction was rejected: %s\", FormatStateMessage(state)));\n     }\n \n     // mark the original tx as bumped\n-    if (!pWallet->MarkReplaced(oldWtx.GetHash(), wtxBumped.GetHash())) {\n+    if (!wallet->MarkReplaced(oldWtx.GetHash(), wtxBumped.GetHash())) {\n         // TODO: see if JSON-RPC has a standard way of returning a response\n         // along with an exception. It would be good to return information about\n         // wtxBumped to the caller even if marking the original transaction\n         // replaced does not succeed for some reason.\n-        vErrors.push_back(\"Created new bumpfee transaction but could not mark the original transaction as replaced\");\n+        errors.push_back(\"Created new bumpfee transaction but could not mark the original transaction as replaced\");\n     }\n     return true;\n }"
      },
      {
        "sha": "8daf80367f212544efb59ce60d3b58d938397321",
        "filename": "src/wallet/feebumper.h",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c4f0091957d305679546fde592ffa2de2d186fe/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c4f0091957d305679546fde592ffa2de2d186fe/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=7c4f0091957d305679546fde592ffa2de2d186fe",
        "patch": "@@ -23,39 +23,39 @@ enum class BumpFeeResult\n     MISC_ERROR,\n };\n \n-class CFeeBumper\n+class FeeBumper\n {\n public:\n-    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, const CCoinControl& coin_control, CAmount totalFee);\n-    BumpFeeResult getResult() const { return currentResult; }\n-    const std::vector<std::string>& getErrors() const { return vErrors; }\n-    CAmount getOldFee() const { return nOldFee; }\n-    CAmount getNewFee() const { return nNewFee; }\n-    uint256 getBumpedTxId() const { return bumpedTxid; }\n+    FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinControl& coin_control, CAmount total_fee);\n+    BumpFeeResult getResult() const { return current_result; }\n+    const std::vector<std::string>& getErrors() const { return errors; }\n+    CAmount getOldFee() const { return old_fee; }\n+    CAmount getNewFee() const { return new_fee; }\n+    uint256 getBumpedTxId() const { return bumped_txid; }\n \n     /* signs the new transaction,\n      * returns false if the tx couldn't be found or if it was\n      * impossible to create the signature(s)\n      */\n-    bool signTransaction(CWallet *pWallet);\n+    bool signTransaction(CWallet *wallet);\n \n     /* commits the fee bump,\n      * returns true, in case of CWallet::CommitTransaction was successful\n-     * but, eventually sets vErrors if the tx could not be added to the mempool (will try later)\n+     * but, eventually sets errors if the tx could not be added to the mempool (will try later)\n      * or if the old transaction could not be marked as replaced\n      */\n-    bool commit(CWallet *pWalletNonConst);\n+    bool commit(CWallet *wallet);\n \n private:\n-    bool preconditionChecks(const CWallet *pWallet, const CWalletTx& wtx);\n+    bool preconditionChecks(const CWallet *wallet, const CWalletTx& wtx);\n \n     const uint256 txid;\n-    uint256 bumpedTxid;\n+    uint256 bumped_txid;\n     CMutableTransaction mtx;\n-    std::vector<std::string> vErrors;\n-    BumpFeeResult currentResult;\n-    CAmount nOldFee;\n-    CAmount nNewFee;\n+    std::vector<std::string> errors;\n+    BumpFeeResult current_result;\n+    CAmount old_fee;\n+    CAmount new_fee;\n };\n \n #endif // BITCOIN_WALLET_FEEBUMPER_H"
      },
      {
        "sha": "e9fd15aa08397aa65cde0a7083d40f7147a8e4b5",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c4f0091957d305679546fde592ffa2de2d186fe/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c4f0091957d305679546fde592ffa2de2d186fe/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=7c4f0091957d305679546fde592ffa2de2d186fe",
        "patch": "@@ -3125,7 +3125,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n-    CFeeBumper feeBump(pwallet, hash, coin_control, totalFee);\n+    FeeBumper feeBump(pwallet, hash, coin_control, totalFee);\n     BumpFeeResult res = feeBump.getResult();\n     if (res != BumpFeeResult::OK)\n     {"
      }
    ]
  },
  {
    "sha": "37bdcca3c363cf08ad68e044b493e24e89f2d158",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozN2JkY2NhM2MzNjNjZjA4YWQ2OGUwNDRiNDkzZTI0ZTg5ZjJkMTU4",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-09-20T20:19:30Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-10T22:03:15Z"
      },
      "message": "[refactor] Make feebumper namespace\n\nFuture commit will remove the FeeBumper class. This commit simply places\neverything into a feebumper namespace, and changes the enum class name\nfrom BumpeFeeResult to feebumper::Result.",
      "tree": {
        "sha": "3cd231f87723acb010191a6b7581cb592672da13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3cd231f87723acb010191a6b7581cb592672da13"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37bdcca3c363cf08ad68e044b493e24e89f2d158",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37bdcca3c363cf08ad68e044b493e24e89f2d158",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37bdcca3c363cf08ad68e044b493e24e89f2d158",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37bdcca3c363cf08ad68e044b493e24e89f2d158/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7c4f0091957d305679546fde592ffa2de2d186fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c4f0091957d305679546fde592ffa2de2d186fe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7c4f0091957d305679546fde592ffa2de2d186fe"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 40,
      "deletions": 32
    },
    "files": [
      {
        "sha": "50d375c8dc7abbcbc89ababd3b77ad8c03beb326",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=37bdcca3c363cf08ad68e044b493e24e89f2d158",
        "patch": "@@ -666,14 +666,14 @@ bool WalletModel::transactionCanBeBumped(uint256 hash) const\n \n bool WalletModel::bumpFee(uint256 hash)\n {\n-    std::unique_ptr<FeeBumper> feeBump;\n+    std::unique_ptr<feebumper::FeeBumper> feeBump;\n     {\n         CCoinControl coin_control;\n         coin_control.signalRbf = true;\n         LOCK2(cs_main, wallet->cs_wallet);\n-        feeBump.reset(new FeeBumper(wallet, hash, coin_control, 0));\n+        feeBump.reset(new feebumper::FeeBumper(wallet, hash, coin_control, 0));\n     }\n-    if (feeBump->getResult() != BumpFeeResult::OK)\n+    if (feeBump->getResult() != feebumper::Result::OK)\n     {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Increasing transaction fee failed\") + \"<br />(\" +\n             (feeBump->getErrors().size() ? QString::fromStdString(feeBump->getErrors()[0]) : \"\") +\")\");"
      },
      {
        "sha": "1e6f8329fd745d739756e2b97a8c1df08d341dbb",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 19,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=37bdcca3c363cf08ad68e044b493e24e89f2d158",
        "patch": "@@ -23,7 +23,7 @@\n // calculation, but we should be able to refactor after priority is removed).\n // NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n // be IsAllFromMe).\n-int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n+static int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n {\n     CMutableTransaction txNew(tx);\n     std::vector<CInputCoin> vCoins;\n@@ -43,10 +43,12 @@ int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wall\n     return GetVirtualTransactionSize(txNew);\n }\n \n+namespace feebumper {\n+\n bool FeeBumper::preconditionChecks(const CWallet *wallet, const CWalletTx& wtx) {\n     if (wallet->HasWalletSpend(wtx.GetHash())) {\n         errors.push_back(\"Transaction has descendants in the wallet\");\n-        current_result = BumpFeeResult::INVALID_PARAMETER;\n+        current_result = Result::INVALID_PARAMETER;\n         return false;\n     }\n \n@@ -55,14 +57,14 @@ bool FeeBumper::preconditionChecks(const CWallet *wallet, const CWalletTx& wtx)\n         auto it_mp = mempool.mapTx.find(wtx.GetHash());\n         if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n             errors.push_back(\"Transaction has descendants in the mempool\");\n-            current_result = BumpFeeResult::INVALID_PARAMETER;\n+            current_result = Result::INVALID_PARAMETER;\n             return false;\n         }\n     }\n \n     if (wtx.GetDepthInMainChain() != 0) {\n         errors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return false;\n     }\n     return true;\n@@ -80,7 +82,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n     auto it = wallet->mapWallet.find(txid);\n     if (it == wallet->mapWallet.end()) {\n         errors.push_back(\"Invalid or non-wallet transaction id\");\n-        current_result = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        current_result = Result::INVALID_ADDRESS_OR_KEY;\n         return;\n     }\n     const CWalletTx& wtx = it->second;\n@@ -91,21 +93,21 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n \n     if (!SignalsOptInRBF(*wtx.tx)) {\n         errors.push_back(\"Transaction is not BIP 125 replaceable\");\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return;\n     }\n \n     if (wtx.mapValue.count(\"replaced_by_txid\")) {\n         errors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return;\n     }\n \n     // check that original tx consists entirely of our inputs\n     // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n     if (!wallet->IsAllFromMe(*wtx.tx, ISMINE_SPENDABLE)) {\n         errors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return;\n     }\n \n@@ -116,15 +118,15 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n         if (wallet->IsChange(wtx.tx->vout[i])) {\n             if (nOutput != -1) {\n                 errors.push_back(\"Transaction has multiple change outputs\");\n-                current_result = BumpFeeResult::WALLET_ERROR;\n+                current_result = Result::WALLET_ERROR;\n                 return;\n             }\n             nOutput = i;\n         }\n     }\n     if (nOutput == -1) {\n         errors.push_back(\"Transaction does not have a change output\");\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return;\n     }\n \n@@ -133,7 +135,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n     const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx, wallet);\n     if (maxNewTxSize < 0) {\n         errors.push_back(\"Transaction contains inputs that cannot be signed\");\n-        current_result = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        current_result = Result::INVALID_ADDRESS_OR_KEY;\n         return;\n     }\n \n@@ -154,14 +156,14 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n         if (total_fee < minTotalFee) {\n             errors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n                                                                 FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n-            current_result = BumpFeeResult::INVALID_PARAMETER;\n+            current_result = Result::INVALID_PARAMETER;\n             return;\n         }\n         CAmount requiredFee = GetRequiredFee(maxNewTxSize);\n         if (total_fee < requiredFee) {\n             errors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n                                                                 FormatMoney(requiredFee)));\n-            current_result = BumpFeeResult::INVALID_PARAMETER;\n+            current_result = Result::INVALID_PARAMETER;\n             return;\n         }\n         new_fee = total_fee;\n@@ -185,7 +187,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n      if (new_fee > maxTxFee) {\n          errors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n                                FormatMoney(new_fee), FormatMoney(maxTxFee)));\n-         current_result = BumpFeeResult::WALLET_ERROR;\n+         current_result = Result::WALLET_ERROR;\n          return;\n      }\n \n@@ -203,7 +205,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n             FormatMoney(minMempoolFeeRate.GetFeePerK()),\n             FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)),\n             FormatMoney(minMempoolFeeRate.GetFeePerK())));\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return;\n     }\n \n@@ -215,7 +217,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n     CTxOut* poutput = &(mtx.vout[nOutput]);\n     if (poutput->nValue < nDelta) {\n         errors.push_back(\"Change output is too small to bump the fee\");\n-        current_result = BumpFeeResult::WALLET_ERROR;\n+        current_result = Result::WALLET_ERROR;\n         return;\n     }\n \n@@ -234,7 +236,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n         }\n     }\n \n-    current_result = BumpFeeResult::OK;\n+    current_result = Result::OK;\n }\n \n bool FeeBumper::signTransaction(CWallet *wallet)\n@@ -245,13 +247,13 @@ bool FeeBumper::signTransaction(CWallet *wallet)\n bool FeeBumper::commit(CWallet *wallet)\n {\n     AssertLockHeld(wallet->cs_wallet);\n-    if (!errors.empty() || current_result != BumpFeeResult::OK) {\n+    if (!errors.empty() || current_result != Result::OK) {\n         return false;\n     }\n     auto it = txid.IsNull() ? wallet->mapWallet.end() : wallet->mapWallet.find(txid);\n     if (it == wallet->mapWallet.end()) {\n         errors.push_back(\"Invalid or non-wallet transaction id\");\n-        current_result = BumpFeeResult::MISC_ERROR;\n+        current_result = Result::MISC_ERROR;\n         return false;\n     }\n     CWalletTx& oldWtx = it->second;\n@@ -295,3 +297,5 @@ bool FeeBumper::commit(CWallet *wallet)\n     return true;\n }\n \n+} // namespace feebumper\n+"
      },
      {
        "sha": "046bd5600182df1bfde220bd02d80f0143485e4d",
        "filename": "src/wallet/feebumper.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=37bdcca3c363cf08ad68e044b493e24e89f2d158",
        "patch": "@@ -13,7 +13,9 @@ class uint256;\n class CCoinControl;\n enum class FeeEstimateMode;\n \n-enum class BumpFeeResult\n+namespace feebumper {\n+\n+enum class Result\n {\n     OK,\n     INVALID_ADDRESS_OR_KEY,\n@@ -27,7 +29,7 @@ class FeeBumper\n {\n public:\n     FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinControl& coin_control, CAmount total_fee);\n-    BumpFeeResult getResult() const { return current_result; }\n+    Result getResult() const { return current_result; }\n     const std::vector<std::string>& getErrors() const { return errors; }\n     CAmount getOldFee() const { return old_fee; }\n     CAmount getNewFee() const { return new_fee; }\n@@ -53,9 +55,11 @@ class FeeBumper\n     uint256 bumped_txid;\n     CMutableTransaction mtx;\n     std::vector<std::string> errors;\n-    BumpFeeResult current_result;\n+    Result current_result;\n     CAmount old_fee;\n     CAmount new_fee;\n };\n \n+} // namespace feebumper\n+\n #endif // BITCOIN_WALLET_FEEBUMPER_H"
      },
      {
        "sha": "8738952bf1dacbf5347f7ba2d43c880b70444a19",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37bdcca3c363cf08ad68e044b493e24e89f2d158/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=37bdcca3c363cf08ad68e044b493e24e89f2d158",
        "patch": "@@ -3125,21 +3125,21 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n-    FeeBumper feeBump(pwallet, hash, coin_control, totalFee);\n-    BumpFeeResult res = feeBump.getResult();\n-    if (res != BumpFeeResult::OK)\n+    feebumper::FeeBumper feeBump(pwallet, hash, coin_control, totalFee);\n+    feebumper::Result res = feeBump.getResult();\n+    if (res != feebumper::Result::OK)\n     {\n         switch(res) {\n-            case BumpFeeResult::INVALID_ADDRESS_OR_KEY:\n+            case feebumper::Result::INVALID_ADDRESS_OR_KEY:\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, feeBump.getErrors()[0]);\n                 break;\n-            case BumpFeeResult::INVALID_REQUEST:\n+            case feebumper::Result::INVALID_REQUEST:\n                 throw JSONRPCError(RPC_INVALID_REQUEST, feeBump.getErrors()[0]);\n                 break;\n-            case BumpFeeResult::INVALID_PARAMETER:\n+            case feebumper::Result::INVALID_PARAMETER:\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, feeBump.getErrors()[0]);\n                 break;\n-            case BumpFeeResult::WALLET_ERROR:\n+            case feebumper::Result::WALLET_ERROR:\n                 throw JSONRPCError(RPC_WALLET_ERROR, feeBump.getErrors()[0]);\n                 break;\n             default:"
      }
    ]
  },
  {
    "sha": "aed1d90aca81c20c6e982ad567291f3812d47c8f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZWQxZDkwYWNhODFjMjBjNmU5ODJhZDU2NzI5MWYzODEyZDQ3Yzhm",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-06-15T14:34:17Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-10T22:16:46Z"
      },
      "message": "[wallet] Change feebumper from class to functions\n\nChange feebumper from a stateful class into a namespace of stateless\nfunctions.\n\nHaving the results of feebumper calls persist in an object makes process\nseparation between Qt and wallet awkward, because it means the feebumper object\neither has to be serialized back and forth between Qt and wallet processes\nbetween fee bump calls, or that the feebumper object needs to stay alive in the\nwallet process with an object reference passed back to Qt. It's simpler just to\nhave fee bumper calls return their results immediately instead of storing them\nin an object with an extended lifetime.\n\nIn addition to making feebumper stateless, also:\n\n- Move LOCK calls from Qt code to feebumper\n- Move TransactionCanBeBumped implementation from Qt code to feebumper",
      "tree": {
        "sha": "ef3b76c918d57be87fa069cb01078b65b3cb191d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef3b76c918d57be87fa069cb01078b65b3cb191d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aed1d90aca81c20c6e982ad567291f3812d47c8f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aed1d90aca81c20c6e982ad567291f3812d47c8f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aed1d90aca81c20c6e982ad567291f3812d47c8f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aed1d90aca81c20c6e982ad567291f3812d47c8f/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "37bdcca3c363cf08ad68e044b493e24e89f2d158",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37bdcca3c363cf08ad68e044b493e24e89f2d158",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/37bdcca3c363cf08ad68e044b493e24e89f2d158"
      }
    ],
    "stats": {
      "total": 258,
      "additions": 117,
      "deletions": 141
    },
    "files": [
      {
        "sha": "c5cca0bff286019ab0116d167347c8376d9e15b0",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 30,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=aed1d90aca81c20c6e982ad567291f3812d47c8f",
        "patch": "@@ -659,45 +659,39 @@ bool WalletModel::abandonTransaction(uint256 hash) const\n \n bool WalletModel::transactionCanBeBumped(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    return wtx && SignalsOptInRBF(*(wtx->tx)) && !wtx->mapValue.count(\"replaced_by_txid\");\n+    return feebumper::TransactionCanBeBumped(wallet, hash);\n }\n \n bool WalletModel::bumpFee(uint256 hash)\n {\n-    std::unique_ptr<feebumper::FeeBumper> feeBump;\n-    {\n-        CCoinControl coin_control;\n-        coin_control.signalRbf = true;\n-        LOCK2(cs_main, wallet->cs_wallet);\n-        feeBump.reset(new feebumper::FeeBumper(wallet, hash, coin_control, 0));\n-    }\n-    if (feeBump->getResult() != feebumper::Result::OK)\n-    {\n+    CCoinControl coin_control;\n+    coin_control.signalRbf = true;\n+    std::vector<std::string> errors;\n+    CAmount old_fee;\n+    CAmount new_fee;\n+    CMutableTransaction mtx;\n+    if (feebumper::CreateTransaction(wallet, hash, coin_control, 0 /* totalFee */, errors, old_fee, new_fee, mtx) != feebumper::Result::OK) {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Increasing transaction fee failed\") + \"<br />(\" +\n-            (feeBump->getErrors().size() ? QString::fromStdString(feeBump->getErrors()[0]) : \"\") +\")\");\n+            (errors.size() ? QString::fromStdString(errors[0]) : \"\") +\")\");\n          return false;\n     }\n \n     // allow a user based fee verification\n     QString questionString = tr(\"Do you want to increase the fee?\");\n     questionString.append(\"<br />\");\n-    CAmount oldFee = feeBump->getOldFee();\n-    CAmount newFee = feeBump->getNewFee();\n     questionString.append(\"<table style=\\\"text-align: left;\\\">\");\n     questionString.append(\"<tr><td>\");\n     questionString.append(tr(\"Current fee:\"));\n     questionString.append(\"</td><td>\");\n-    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), oldFee));\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), old_fee));\n     questionString.append(\"</td></tr><tr><td>\");\n     questionString.append(tr(\"Increase:\"));\n     questionString.append(\"</td><td>\");\n-    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), newFee - oldFee));\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), new_fee - old_fee));\n     questionString.append(\"</td></tr><tr><td>\");\n     questionString.append(tr(\"New fee:\"));\n     questionString.append(\"</td><td>\");\n-    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), newFee));\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), new_fee));\n     questionString.append(\"</td></tr></table>\");\n     SendConfirmationDialog confirmationDialog(tr(\"Confirm fee bump\"), questionString);\n     confirmationDialog.exec();\n@@ -715,23 +709,15 @@ bool WalletModel::bumpFee(uint256 hash)\n     }\n \n     // sign bumped transaction\n-    bool res = false;\n-    {\n-        LOCK2(cs_main, wallet->cs_wallet);\n-        res = feeBump->signTransaction(wallet);\n-    }\n-    if (!res) {\n+    if (!feebumper::SignTransaction(wallet, mtx)) {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Can't sign transaction.\"));\n         return false;\n     }\n     // commit the bumped transaction\n-    {\n-        LOCK2(cs_main, wallet->cs_wallet);\n-        res = feeBump->commit(wallet);\n-    }\n-    if(!res) {\n+    uint256 txid;\n+    if (feebumper::CommitTransaction(wallet, hash, std::move(mtx), errors, txid) != feebumper::Result::OK) {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Could not commit transaction\") + \"<br />(\" +\n-            QString::fromStdString(feeBump->getErrors()[0])+\")\");\n+            QString::fromStdString(errors[0])+\")\");\n          return false;\n     }\n     return true;"
      },
      {
        "sha": "aaddd47de8b031daaa9eb05046f390ff4982f217",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 58,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=aed1d90aca81c20c6e982ad567291f3812d47c8f",
        "patch": "@@ -43,72 +43,72 @@ static int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWalle\n     return GetVirtualTransactionSize(txNew);\n }\n \n-namespace feebumper {\n-\n-bool FeeBumper::preconditionChecks(const CWallet *wallet, const CWalletTx& wtx) {\n+//! Check whether transaction has descendant in wallet or mempool, or has been\n+//! mined, or conflicts with a mined transaction. Return a feebumper::Result.\n+static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors)\n+{\n     if (wallet->HasWalletSpend(wtx.GetHash())) {\n         errors.push_back(\"Transaction has descendants in the wallet\");\n-        current_result = Result::INVALID_PARAMETER;\n-        return false;\n+        return feebumper::Result::INVALID_PARAMETER;\n     }\n \n     {\n         LOCK(mempool.cs);\n         auto it_mp = mempool.mapTx.find(wtx.GetHash());\n         if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n             errors.push_back(\"Transaction has descendants in the mempool\");\n-            current_result = Result::INVALID_PARAMETER;\n-            return false;\n+            return feebumper::Result::INVALID_PARAMETER;\n         }\n     }\n \n     if (wtx.GetDepthInMainChain() != 0) {\n         errors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n-        current_result = Result::WALLET_ERROR;\n-        return false;\n+        return feebumper::Result::WALLET_ERROR;\n     }\n-    return true;\n+    return feebumper::Result::OK;\n }\n \n-FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinControl& coin_control, CAmount total_fee)\n-    :\n-    txid(std::move(txid_in)),\n-    old_fee(0),\n-    new_fee(0)\n+namespace feebumper {\n+\n+bool TransactionCanBeBumped(CWallet* wallet, const uint256& txid)\n {\n+    LOCK2(cs_main, wallet->cs_wallet);\n+    const CWalletTx* wtx = wallet->GetWalletTx(txid);\n+    return wtx && SignalsOptInRBF(*wtx->tx) && !wtx->mapValue.count(\"replaced_by_txid\");\n+}\n+\n+Result CreateTransaction(const CWallet* wallet, const uint256& txid, const CCoinControl& coin_control, CAmount total_fee, std::vector<std::string>& errors,\n+                         CAmount& old_fee, CAmount& new_fee, CMutableTransaction& mtx)\n+{\n+    LOCK2(cs_main, wallet->cs_wallet);\n     errors.clear();\n-    bumped_txid.SetNull();\n-    AssertLockHeld(wallet->cs_wallet);\n     auto it = wallet->mapWallet.find(txid);\n     if (it == wallet->mapWallet.end()) {\n         errors.push_back(\"Invalid or non-wallet transaction id\");\n-        current_result = Result::INVALID_ADDRESS_OR_KEY;\n-        return;\n+        return Result::INVALID_ADDRESS_OR_KEY;\n     }\n     const CWalletTx& wtx = it->second;\n \n-    if (!preconditionChecks(wallet, wtx)) {\n-        return;\n+    Result result = PreconditionChecks(wallet, wtx, errors);\n+    if (result != Result::OK) {\n+        return result;\n     }\n \n     if (!SignalsOptInRBF(*wtx.tx)) {\n         errors.push_back(\"Transaction is not BIP 125 replaceable\");\n-        current_result = Result::WALLET_ERROR;\n-        return;\n+        return Result::WALLET_ERROR;\n     }\n \n     if (wtx.mapValue.count(\"replaced_by_txid\")) {\n         errors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n-        current_result = Result::WALLET_ERROR;\n-        return;\n+        return Result::WALLET_ERROR;\n     }\n \n     // check that original tx consists entirely of our inputs\n     // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n     if (!wallet->IsAllFromMe(*wtx.tx, ISMINE_SPENDABLE)) {\n         errors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n-        current_result = Result::WALLET_ERROR;\n-        return;\n+        return Result::WALLET_ERROR;\n     }\n \n     // figure out which output was change\n@@ -118,25 +118,22 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n         if (wallet->IsChange(wtx.tx->vout[i])) {\n             if (nOutput != -1) {\n                 errors.push_back(\"Transaction has multiple change outputs\");\n-                current_result = Result::WALLET_ERROR;\n-                return;\n+                return Result::WALLET_ERROR;\n             }\n             nOutput = i;\n         }\n     }\n     if (nOutput == -1) {\n         errors.push_back(\"Transaction does not have a change output\");\n-        current_result = Result::WALLET_ERROR;\n-        return;\n+        return Result::WALLET_ERROR;\n     }\n \n     // Calculate the expected size of the new transaction.\n     int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n     const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx, wallet);\n     if (maxNewTxSize < 0) {\n         errors.push_back(\"Transaction contains inputs that cannot be signed\");\n-        current_result = Result::INVALID_ADDRESS_OR_KEY;\n-        return;\n+        return Result::INVALID_ADDRESS_OR_KEY;\n     }\n \n     // calculate the old fee and fee-rate\n@@ -156,15 +153,13 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n         if (total_fee < minTotalFee) {\n             errors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n                                                                 FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n-            current_result = Result::INVALID_PARAMETER;\n-            return;\n+            return Result::INVALID_PARAMETER;\n         }\n         CAmount requiredFee = GetRequiredFee(maxNewTxSize);\n         if (total_fee < requiredFee) {\n             errors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n                                                                 FormatMoney(requiredFee)));\n-            current_result = Result::INVALID_PARAMETER;\n-            return;\n+            return Result::INVALID_PARAMETER;\n         }\n         new_fee = total_fee;\n         nNewFeeRate = CFeeRate(total_fee, maxNewTxSize);\n@@ -187,8 +182,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n      if (new_fee > maxTxFee) {\n          errors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n                                FormatMoney(new_fee), FormatMoney(maxTxFee)));\n-         current_result = Result::WALLET_ERROR;\n-         return;\n+         return Result::WALLET_ERROR;\n      }\n \n     // check that fee rate is higher than mempool's minimum fee\n@@ -205,8 +199,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n             FormatMoney(minMempoolFeeRate.GetFeePerK()),\n             FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)),\n             FormatMoney(minMempoolFeeRate.GetFeePerK())));\n-        current_result = Result::WALLET_ERROR;\n-        return;\n+        return Result::WALLET_ERROR;\n     }\n \n     // Now modify the output to increase the fee.\n@@ -217,8 +210,7 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n     CTxOut* poutput = &(mtx.vout[nOutput]);\n     if (poutput->nValue < nDelta) {\n         errors.push_back(\"Change output is too small to bump the fee\");\n-        current_result = Result::WALLET_ERROR;\n-        return;\n+        return Result::WALLET_ERROR;\n     }\n \n     // If the output would become dust, discard it (converting the dust to fee)\n@@ -236,31 +228,31 @@ FeeBumper::FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinCo\n         }\n     }\n \n-    current_result = Result::OK;\n+    return Result::OK;\n }\n \n-bool FeeBumper::signTransaction(CWallet *wallet)\n-{\n-     return wallet->SignTransaction(mtx);\n+bool SignTransaction(CWallet* wallet, CMutableTransaction& mtx) {\n+    LOCK2(cs_main, wallet->cs_wallet);\n+    return wallet->SignTransaction(mtx);\n }\n \n-bool FeeBumper::commit(CWallet *wallet)\n+Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransaction&& mtx, std::vector<std::string>& errors, uint256& bumped_txid)\n {\n-    AssertLockHeld(wallet->cs_wallet);\n-    if (!errors.empty() || current_result != Result::OK) {\n-        return false;\n+    LOCK2(cs_main, wallet->cs_wallet);\n+    if (!errors.empty()) {\n+        return Result::MISC_ERROR;\n     }\n     auto it = txid.IsNull() ? wallet->mapWallet.end() : wallet->mapWallet.find(txid);\n     if (it == wallet->mapWallet.end()) {\n         errors.push_back(\"Invalid or non-wallet transaction id\");\n-        current_result = Result::MISC_ERROR;\n-        return false;\n+        return Result::MISC_ERROR;\n     }\n     CWalletTx& oldWtx = it->second;\n \n     // make sure the transaction still has no descendants and hasn't been mined in the meantime\n-    if (!preconditionChecks(wallet, oldWtx)) {\n-        return false;\n+    Result result = PreconditionChecks(wallet, oldWtx, errors);\n+    if (result != Result::OK) {\n+        return result;\n     }\n \n     CWalletTx wtxBumped(wallet, MakeTransactionRef(std::move(mtx)));\n@@ -276,14 +268,14 @@ bool FeeBumper::commit(CWallet *wallet)\n     if (!wallet->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n         // NOTE: CommitTransaction never returns false, so this should never happen.\n         errors.push_back(strprintf(\"The transaction was rejected: %s\", state.GetRejectReason()));\n-        return false;\n+        return Result::WALLET_ERROR;\n     }\n \n     bumped_txid = wtxBumped.GetHash();\n     if (state.IsInvalid()) {\n         // This can happen if the mempool rejected the transaction.  Report\n         // what happened in the \"errors\" response.\n-        errors.push_back(strprintf(\"The transaction was rejected: %s\", FormatStateMessage(state)));\n+        errors.push_back(strprintf(\"Error: The transaction was rejected: %s\", FormatStateMessage(state)));\n     }\n \n     // mark the original tx as bumped\n@@ -294,7 +286,7 @@ bool FeeBumper::commit(CWallet *wallet)\n         // replaced does not succeed for some reason.\n         errors.push_back(\"Created new bumpfee transaction but could not mark the original transaction as replaced\");\n     }\n-    return true;\n+    return Result::OK;\n }\n \n } // namespace feebumper"
      },
      {
        "sha": "8eec30440cc7d5b83364ef3e39216c0483f853f6",
        "filename": "src/wallet/feebumper.h",
        "status": "modified",
        "additions": 27,
        "deletions": 34,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=aed1d90aca81c20c6e982ad567291f3812d47c8f",
        "patch": "@@ -25,40 +25,33 @@ enum class Result\n     MISC_ERROR,\n };\n \n-class FeeBumper\n-{\n-public:\n-    FeeBumper(const CWallet *wallet, const uint256 txid_in, const CCoinControl& coin_control, CAmount total_fee);\n-    Result getResult() const { return current_result; }\n-    const std::vector<std::string>& getErrors() const { return errors; }\n-    CAmount getOldFee() const { return old_fee; }\n-    CAmount getNewFee() const { return new_fee; }\n-    uint256 getBumpedTxId() const { return bumped_txid; }\n-\n-    /* signs the new transaction,\n-     * returns false if the tx couldn't be found or if it was\n-     * impossible to create the signature(s)\n-     */\n-    bool signTransaction(CWallet *wallet);\n-\n-    /* commits the fee bump,\n-     * returns true, in case of CWallet::CommitTransaction was successful\n-     * but, eventually sets errors if the tx could not be added to the mempool (will try later)\n-     * or if the old transaction could not be marked as replaced\n-     */\n-    bool commit(CWallet *wallet);\n-\n-private:\n-    bool preconditionChecks(const CWallet *wallet, const CWalletTx& wtx);\n-\n-    const uint256 txid;\n-    uint256 bumped_txid;\n-    CMutableTransaction mtx;\n-    std::vector<std::string> errors;\n-    Result current_result;\n-    CAmount old_fee;\n-    CAmount new_fee;\n-};\n+//! Return whether transaction can be bumped.\n+bool TransactionCanBeBumped(CWallet* wallet, const uint256& txid);\n+\n+//! Create bumpfee transaction.\n+Result CreateTransaction(const CWallet* wallet,\n+                         const uint256& txid,\n+                         const CCoinControl& coin_control,\n+                         CAmount total_fee,\n+                         std::vector<std::string>& errors,\n+                         CAmount& old_fee,\n+                         CAmount& new_fee,\n+                         CMutableTransaction& mtx);\n+\n+//! Sign the new transaction,\n+//! @return false if the tx couldn't be found or if it was\n+//! impossible to create the signature(s)\n+bool SignTransaction(CWallet* wallet, CMutableTransaction& mtx);\n+\n+//! Commit the bumpfee transaction.\n+//! @return success in case of CWallet::CommitTransaction was successful,\n+//! but sets errors if the tx could not be added to the mempool (will try later)\n+//! or if the old transaction could not be marked as replaced.\n+Result CommitTransaction(CWallet* wallet,\n+                         const uint256& txid,\n+                         CMutableTransaction&& mtx,\n+                         std::vector<std::string>& errors,\n+                         uint256& bumped_txid);\n \n } // namespace feebumper\n "
      },
      {
        "sha": "2d2eb4b6d3864075c0bc89bc9011c2c1da6513e1",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 19,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aed1d90aca81c20c6e982ad567291f3812d47c8f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=aed1d90aca81c20c6e982ad567291f3812d47c8f",
        "patch": "@@ -3125,45 +3125,50 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n-    feebumper::FeeBumper feeBump(pwallet, hash, coin_control, totalFee);\n-    feebumper::Result res = feeBump.getResult();\n-    if (res != feebumper::Result::OK)\n-    {\n+\n+    std::vector<std::string> errors;\n+    CAmount old_fee;\n+    CAmount new_fee;\n+    CMutableTransaction mtx;\n+    feebumper::Result res = feebumper::CreateTransaction(pwallet, hash, coin_control, totalFee, errors, old_fee, new_fee, mtx);\n+    if (res != feebumper::Result::OK) {\n         switch(res) {\n             case feebumper::Result::INVALID_ADDRESS_OR_KEY:\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, feeBump.getErrors()[0]);\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, errors[0]);\n                 break;\n             case feebumper::Result::INVALID_REQUEST:\n-                throw JSONRPCError(RPC_INVALID_REQUEST, feeBump.getErrors()[0]);\n+                throw JSONRPCError(RPC_INVALID_REQUEST, errors[0]);\n                 break;\n             case feebumper::Result::INVALID_PARAMETER:\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, feeBump.getErrors()[0]);\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, errors[0]);\n                 break;\n             case feebumper::Result::WALLET_ERROR:\n-                throw JSONRPCError(RPC_WALLET_ERROR, feeBump.getErrors()[0]);\n+                throw JSONRPCError(RPC_WALLET_ERROR, errors[0]);\n                 break;\n             default:\n-                throw JSONRPCError(RPC_MISC_ERROR, feeBump.getErrors()[0]);\n+                throw JSONRPCError(RPC_MISC_ERROR, errors[0]);\n                 break;\n         }\n     }\n \n     // sign bumped transaction\n-    if (!feeBump.signTransaction(pwallet)) {\n+    if (!feebumper::SignTransaction(pwallet, mtx)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n     }\n     // commit the bumped transaction\n-    if(!feeBump.commit(pwallet)) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, feeBump.getErrors()[0]);\n+    uint256 txid;\n+    if (feebumper::CommitTransaction(pwallet, hash, std::move(mtx), errors, txid) != feebumper::Result::OK) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, errors[0]);\n     }\n     UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"txid\", feeBump.getBumpedTxId().GetHex()));\n-    result.push_back(Pair(\"origfee\", ValueFromAmount(feeBump.getOldFee())));\n-    result.push_back(Pair(\"fee\", ValueFromAmount(feeBump.getNewFee())));\n-    UniValue errors(UniValue::VARR);\n-    for (const std::string& err: feeBump.getErrors())\n-        errors.push_back(err);\n-    result.push_back(Pair(\"errors\", errors));\n+    result.push_back(Pair(\"txid\", txid.GetHex()));\n+    result.push_back(Pair(\"origfee\", ValueFromAmount(old_fee)));\n+    result.push_back(Pair(\"fee\", ValueFromAmount(new_fee)));\n+    UniValue result_errors(UniValue::VARR);\n+    for (const std::string& error : errors) {\n+        result_errors.push_back(error);\n+    }\n+    result.push_back(Pair(\"errors\", result_errors));\n \n     return result;\n }"
      }
    ]
  }
]