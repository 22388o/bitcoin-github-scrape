[
  {
    "sha": "8f4e67f152a9625a1c66c20de00679286b2c187c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjRlNjdmMTUyYTk2MjVhMWM2NmMyMGRlMDA2NzkyODZiMmMxODdj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-08-25T18:12:08Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-10T16:29:56Z"
      },
      "message": "net: Automatically create hidden service, listen on Tor\n\nStarting with Tor version 0.2.7.1 it is possible, through Tor's control socket\nAPI, to create and destroy 'ephemeral' hidden services programmatically.\nhttps://stem.torproject.org/api/control.html#stem.control.Controller.create_ephemeral_hidden_service\n\nThis means that if Tor is running (and proper authorization is available),\nbitcoin automatically creates a hidden service to listen on, without user\nmanual configuration. This will positively affect the number of available\n.onion nodes.\n\n- When the node is started, connect to Tor through control socket\n- Send `ADD_ONION` command\n- First time:\n    - Make it create a hidden service key\n    - Save the key in the data directory for later usage\n- Make it redirect port 8333 to the local port 8333 (or whatever port we're listening on).\n- Keep control socket connection open for as long node is running. The hidden service will\n  (by default) automatically go away when the connection is closed.",
      "tree": {
        "sha": "69a6b3f08d8dc830139ed169858be5f75dd20206",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69a6b3f08d8dc830139ed169858be5f75dd20206"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f4e67f152a9625a1c66c20de00679286b2c187c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f4e67f152a9625a1c66c20de00679286b2c187c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f4e67f152a9625a1c66c20de00679286b2c187c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f4e67f152a9625a1c66c20de00679286b2c187c/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b56953e9bb5a32bc35365d1f0c5de5528c0650dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b56953e9bb5a32bc35365d1f0c5de5528c0650dd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b56953e9bb5a32bc35365d1f0c5de5528c0650dd"
      }
    ],
    "stats": {
      "total": 615,
      "additions": 611,
      "deletions": 4
    },
    "files": [
      {
        "sha": "c96541d22edb8c33ed2bc90c9a09fed51f54df00",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -149,6 +149,7 @@ BITCOIN_CORE_H = \\\n   threadsafety.h \\\n   timedata.h \\\n   tinyformat.h \\\n+  torcontrol.h \\\n   txdb.h \\\n   txmempool.h \\\n   ui_interface.h \\\n@@ -206,6 +207,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpcserver.cpp \\\n   script/sigcache.cpp \\\n   timedata.cpp \\\n+  torcontrol.cpp \\\n   txdb.cpp \\\n   txmempool.cpp \\\n   validationinterface.cpp \\"
      },
      {
        "sha": "77837f85c39d0cbf0b73dfab68c1011817b17764",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -28,6 +28,7 @@\n #include \"scheduler.h\"\n #include \"txdb.h\"\n #include \"txmempool.h\"\n+#include \"torcontrol.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n@@ -187,6 +188,7 @@ void Shutdown()\n #endif\n     GenerateBitcoins(false, 0, Params());\n     StopNode();\n+    StopTorControl();\n     UnregisterNodeSignals(GetNodeSignals());\n \n     if (fFeeEstimatesInitialized)\n@@ -347,6 +349,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-externalip=<ip>\", _(\"Specify your own public address\"));\n     strUsage += HelpMessageOpt(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), 0));\n     strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n+    strUsage += HelpMessageOpt(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION));\n     strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS));\n     strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), 5000));\n     strUsage += HelpMessageOpt(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), 1000));\n@@ -358,6 +361,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), 1));\n     strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n     strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n+    strUsage += HelpMessageOpt(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL));\n #ifdef USE_UPNP\n #if USE_UPNP\n     strUsage += HelpMessageOpt(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"));\n@@ -777,6 +781,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n         if (SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -discover=0\\n\", __func__);\n+        if (SoftSetBoolArg(\"-listenonion\", false))\n+            LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -listenonion=0\\n\", __func__);\n     }\n \n     if (mapArgs.count(\"-externalip\")) {\n@@ -1567,6 +1573,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"mapAddressBook.size() = %u\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n #endif\n \n+    if (GetBoolArg(\"-listenonion\", DEFAULT_LISTEN_ONION))\n+        StartTorControl(threadGroup, scheduler);\n+\n     StartNode(threadGroup, scheduler);\n \n     // Monitor the chain, and alert if we get blocks much quicker or slower than expected"
      },
      {
        "sha": "8afb7ddcddc83ca0f86dfb0e2d039f840907b27c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -4038,9 +4038,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 CAddress addr = GetLocalAddress(&pfrom->addr);\n                 if (addr.IsRoutable())\n                 {\n+                    LogPrintf(\"ProcessMessages: advertizing address %s\\n\", addr.ToString());\n                     pfrom->PushAddress(addr);\n                 } else if (IsPeerAddrLocalGood(pfrom)) {\n                     addr.SetIP(pfrom->addrLocal);\n+                    LogPrintf(\"ProcessMessages: advertizing address %s\\n\", addr.ToString());\n                     pfrom->PushAddress(addr);\n                 }\n             }"
      },
      {
        "sha": "9d01f2557edecb9ab5c111c21962069ab863f525",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -216,6 +216,7 @@ void AdvertizeLocal(CNode *pnode)\n         }\n         if (addrLocal.IsRoutable())\n         {\n+            LogPrintf(\"AdvertizeLocal: advertizing address %s\\n\", addrLocal.ToString());\n             pnode->PushAddress(addrLocal);\n         }\n     }"
      },
      {
        "sha": "83cedfb620e1a4feeaaa20320f1a88e2d05f322f",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -227,10 +227,7 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n     return Lookup(pszName, addr, portDefault, false);\n }\n \n-/**\n- * Convert milliseconds to a struct timeval for select.\n- */\n-struct timeval static MillisToTimeval(int64_t nTimeout)\n+struct timeval MillisToTimeval(int64_t nTimeout)\n {\n     struct timeval timeout;\n     timeout.tv_sec  = nTimeout / 1000;"
      },
      {
        "sha": "2a79f82d72eca6705210fb70deb406ae14bc8740",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -215,5 +215,9 @@ std::string NetworkErrorString(int err);\n bool CloseSocket(SOCKET& hSocket);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking);\n+/**\n+ * Convert milliseconds to a struct timeval for e.g. select.\n+ */\n+struct timeval MillisToTimeval(int64_t nTimeout);\n \n #endif // BITCOIN_NETBASE_H"
      },
      {
        "sha": "bb72315c8ed32b544323988f61139f97b3b2327f",
        "filename": "src/torcontrol.cpp",
        "status": "added",
        "additions": 573,
        "deletions": 0,
        "changes": 573,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -0,0 +1,573 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrintf(\"[tor] Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrintf(\"[tor] Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrintf(\"[tor] Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrintf(\"[tor] End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        perror(\"evutil_parse_sockaddr_port\\n\");\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+        perror(\"bufferevent_socket_connect\");\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool TorControlConnection::Disconnect()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+    b_conn = 0;\n+    return true;\n+}\n+\n+bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB& reply_handler)\n+{\n+    if (!b_conn)\n+        return false;\n+    struct evbuffer *buf = bufferevent_get_output(b_conn);\n+    if (!buf)\n+        return false;\n+    evbuffer_add(buf, cmd.data(), cmd.size());\n+    evbuffer_add(buf, \"\\r\\n\", 2);\n+    reply_handlers.push_back(reply_handler);\n+    return true;\n+}\n+\n+/****** General parsing utilities ********/\n+\n+/* Split reply line in the form 'AUTH METHODS=...' into a type\n+ * 'AUTH' and arguments 'METHODS=...'.\n+ */\n+static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n+{\n+    size_t ptr=0;\n+    std::string type;\n+    while (ptr < s.size() && s[ptr] != ' ') {\n+        type.push_back(s[ptr]);\n+        ++ptr;\n+    }\n+    if (ptr < s.size())\n+        ++ptr; // skip ' '\n+    return make_pair(type, s.substr(ptr));\n+}\n+\n+/** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ */\n+static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n+{\n+    std::map<std::string,std::string> mapping;\n+    size_t ptr=0;\n+    while (ptr < s.size()) {\n+        std::string key, value;\n+        while (ptr < s.size() && s[ptr] != '=') {\n+            key.push_back(s[ptr]);\n+            ++ptr;\n+        }\n+        if (ptr == s.size()) // unexpected end of line\n+            return std::map<std::string,std::string>();\n+        ++ptr; // skip '='\n+        if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n+            ++ptr; // skip '='\n+            bool escape_next = false;\n+            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n+                escape_next = (s[ptr] == '\\\\');\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+            if (ptr == s.size()) // unexpected end of line\n+                return std::map<std::string,std::string>();\n+            ++ptr; // skip closing '\"'\n+            /* TODO: unescape value - according to the spec this depends on the\n+             * context, some strings use C-LogPrintf style escape codes, some\n+             * don't. So may be better handled at the call site.\n+             */\n+        } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n+            while (ptr < s.size() && s[ptr] != ' ') {\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+        }\n+        if (ptr < s.size() && s[ptr] == ' ')\n+            ++ptr; // skip ' ' after key=value\n+        mapping[key] = value;\n+    }\n+    return mapping;\n+}\n+\n+/** Read full contents of a file and return them in a std::string. */\n+static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename)\n+{\n+    FILE *f = fopen(filename.c_str(), \"rb\");\n+    if (f == NULL)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    size_t n;\n+    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0)\n+        retval.append(buffer, buffer+n);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+/** Write contents of std::string to a file.\n+ * @return true on success.\n+ */\n+static bool WriteBinaryFile(const std::string &filename, const std::string &data)\n+{\n+    FILE *f = fopen(filename.c_str(), \"wb\");\n+    if (f == NULL)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size())\n+        return false;\n+    fclose(f);\n+    return true;\n+}\n+\n+/****** Bitcoin specific TorController implementation ********/\n+\n+/** Controller that connects to Tor control socket, authenticate, then create\n+ * and maintain a ephemeral hidden service.\n+ */\n+class TorController\n+{\n+public:\n+    TorController(struct event_base* base, const std::string& target);\n+    ~TorController();\n+\n+    /** Get name fo file to store private key in */\n+    std::string GetPrivateKeyFile();\n+\n+    /** Reconnect, after getting disconnected */\n+    void Reconnect();\n+private:\n+    struct event_base* base;\n+    std::string target;\n+    TorControlConnection conn;\n+    std::string private_key;\n+    std::string service_id;\n+    bool reconnect;\n+    struct event *shutdown_poll_ev;\n+    struct event *reconnect_ev;\n+    float reconnect_timeout;\n+\n+    /** Callback for ADD_ONION result */\n+    void add_onion_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for AUTHENTICATE result */\n+    void auth_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for PROTOCOLINFO result */\n+    void protocolinfo_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback after succesful connection */\n+    void connected_cb(TorControlConnection& conn);\n+    /** Callback after connection lost or failed connection attempt */\n+    void disconnected_cb(TorControlConnection& conn);\n+\n+    /** Callback for shutdown poll timer */\n+    static void shutdown_poll_cb(evutil_socket_t fd, short what, void *arg);\n+    /** Callback for reconnect timer */\n+    static void reconnect_cb(evutil_socket_t fd, short what, void *arg);\n+};\n+\n+/** Exponential backoff configuration - initial timeout in seconds */\n+static const float RECONNECT_TIMEOUT_START = 1.0;\n+/** Exponential backoff configuration - growth factor */\n+static const float RECONNECT_TIMEOUT_EXP = 1.5;\n+\n+TorController::TorController(struct event_base* base, const std::string& target):\n+    base(base),\n+    target(target), conn(base), reconnect(true), shutdown_poll_ev(0), reconnect_ev(0),\n+    reconnect_timeout(RECONNECT_TIMEOUT_START)\n+{\n+    // Start connection attempts immediately\n+    if (!conn.Connect(target, boost::bind(&TorController::connected_cb, this, _1),\n+         boost::bind(&TorController::disconnected_cb, this, _1) )) {\n+        LogPrintf(\"[tor] Initiating connection to Tor control port %s failed\\n\", target);\n+    }\n+    // Read service private key if cached\n+    std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\n+    if (pkf.first) {\n+        LogPrintf(\"[tor] Reading cached private key from %s\\n\", GetPrivateKeyFile());\n+        private_key = pkf.second;\n+    }\n+    // Periodic timer event to poll for shutdown\n+    // The same 200ms as in bitcoind. This is not the nicest solution, but we cannot exactly use\n+    // boost::interrupt here.\n+    struct timeval time;\n+    time.tv_usec = 200000;\n+    time.tv_sec = 0;\n+    shutdown_poll_ev = event_new(base, -1, EV_PERSIST, shutdown_poll_cb, this);\n+    event_add(shutdown_poll_ev, &time);\n+}\n+\n+TorController::~TorController()\n+{\n+    if (shutdown_poll_ev)\n+        event_del(shutdown_poll_ev);\n+    if (reconnect_ev)\n+        event_del(reconnect_ev);\n+}\n+\n+void TorController::add_onion_cb(TorControlConnection& conn, const TorControlReply& reply)\n+{\n+    if (reply.code == 250) {\n+        LogPrintf(\"[tor] ADD_ONION succesful\\n\");\n+        BOOST_FOREACH(const std::string &s, reply.lines) {\n+            std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n+            std::map<std::string,std::string>::iterator i;\n+            if ((i = m.find(\"ServiceID\")) != m.end())\n+                service_id = i->second;\n+            if ((i = m.find(\"PrivateKey\")) != m.end())\n+                private_key = i->second;\n+        }\n+\n+        CService service(service_id+\".onion\", GetListenPort(), false);\n+        LogPrintf(\"[tor] Got service ID %s, advertizing service %s\\n\", service_id, service.ToString());\n+        if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n+            LogPrintf(\"[tor] Cached service private key to %s\\n\", GetPrivateKeyFile());\n+        } else {\n+            LogPrintf(\"[tor] Error writing service private key to %s\\n\", GetPrivateKeyFile());\n+        }\n+        AddLocal(service, LOCAL_MANUAL);\n+        // ... onion requested - keep connection open\n+    } else {\n+        LogPrintf(\"[tor] Add onion failed\\n\");\n+    }\n+}\n+\n+void TorController::auth_cb(TorControlConnection& conn, const TorControlReply& reply)\n+{\n+    if (reply.code == 250) {\n+        LogPrintf(\"[tor] Authentication succesful\\n\");\n+        // Finally - now create the service\n+        if (private_key.empty()) // No private key, generate one\n+            private_key = \"NEW:BEST\";\n+        // Request hidden service, redirect port.\n+        // Note that the 'virtual' port doesn't have to be the same as our internal port, but this is just a convenient\n+        // choice.  TODO; refactor the shutdown sequence some day.\n+        conn.Command(strprintf(\"ADD_ONION %s Port=%i,127.0.0.1:%i\", private_key, GetListenPort(), GetListenPort()),\n+            boost::bind(&TorController::add_onion_cb, this, _1, _2));\n+    } else {\n+        LogPrintf(\"[tor] Authentication failed\\n\");\n+    }\n+}\n+\n+void TorController::protocolinfo_cb(TorControlConnection& conn, const TorControlReply& reply)\n+{\n+    if (reply.code == 250) {\n+        std::set<std::string> methods;\n+        std::string cookiefile;\n+        /*\n+         * 250-AUTH METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\"/home/x/.tor/control_auth_cookie\"\n+         * 250-AUTH METHODS=NULL\n+         * 250-AUTH METHODS=HASHEDPASSWORD\n+         */\n+        BOOST_FOREACH(const std::string &s, reply.lines) {\n+            std::pair<std::string,std::string> l = SplitTorReplyLine(s);\n+            if (l.first == \"AUTH\") {\n+                std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n+                std::map<std::string,std::string>::iterator i;\n+                if ((i = m.find(\"METHODS\")) != m.end())\n+                    boost::split(methods, i->second, boost::is_any_of(\",\"));\n+                if ((i = m.find(\"COOKIEFILE\")) != m.end())\n+                    cookiefile = i->second;\n+            } else if (l.first == \"VERSION\") {\n+                std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n+                std::map<std::string,std::string>::iterator i;\n+                if ((i = m.find(\"Tor\")) != m.end()) {\n+                    LogPrintf(\"[tor] Connected to Tor version %s\\n\", i->second);\n+                }\n+            }\n+        }\n+        BOOST_FOREACH(const std::string &s, methods) {\n+            LogPrintf(\"[tor] Supported authentication method: %s\\n\", s);\n+        }\n+        // Prefer NULL, otherwise COOKIE. If a password is provided, use HASHEDPASSWORD\n+        // We do not support SAFECOOKIE\n+        /* Authentication:\n+         *   cookie:   hex-encoded ~/.tor/control_auth_cookie\n+         *   password: \"password\"\n+         */\n+        if (methods.count(\"NULL\")) {\n+            LogPrintf(\"[tor] Using NULL authentication\\n\");\n+            conn.Command(\"AUTHENTICATE\", boost::bind(&TorController::auth_cb, this, _1, _2));\n+        } else if (methods.count(\"COOKIE\")) {\n+            // Cookie: hexdump -e '32/1 \"%02x\"\"\\n\"'  ~/.tor/control_auth_cookie\n+            LogPrintf(\"[tor] Using COOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n+            std::string cookie = ReadBinaryFile(cookiefile).second;\n+            if (!cookie.empty()) {\n+                conn.Command(\"AUTHENTICATE \" + HexStr(cookie), boost::bind(&TorController::auth_cb, this, _1, _2));\n+            } else {\n+                LogPrintf(\"[tor] Authentication cookie not found\\n\");\n+            }\n+        } else {\n+            /* TODO HASHEDPASSWORD w/ manual auth */\n+            LogPrintf(\"[tor] No supported authentication method\\n\");\n+        }\n+    } else {\n+        LogPrintf(\"[tor] Requesting protocol info failed\\n\");\n+    }\n+}\n+\n+void TorController::connected_cb(TorControlConnection& conn)\n+{\n+    reconnect_timeout = RECONNECT_TIMEOUT_START;\n+    // First send a PROTOCOLINFO command to figure out what authentication is expected\n+    if (!conn.Command(\"PROTOCOLINFO 1\", boost::bind(&TorController::protocolinfo_cb, this, _1, _2)))\n+        LogPrintf(\"[tor] Error sending initial protocolinfo command\\n\");\n+}\n+\n+void TorController::disconnected_cb(TorControlConnection& conn)\n+{\n+    if (!reconnect)\n+        return;\n+    LogPrintf(\"[tor] Disconnected from Tor control port %s, trying to reconnect\\n\", target);\n+    // Single-shot timer for reconnect. Use exponential backoff.\n+    struct timeval time = MillisToTimeval(int64_t(reconnect_timeout * 1000.0));\n+    reconnect_ev = event_new(base, -1, 0, reconnect_cb, this);\n+    event_add(reconnect_ev, &time);\n+    reconnect_timeout *= RECONNECT_TIMEOUT_EXP;\n+}\n+\n+void TorController::Reconnect()\n+{\n+    /* Try to reconnect and reestablish if we get booted - for example, Tor\n+     * may be restarting.\n+     */\n+    if (!conn.Connect(target, boost::bind(&TorController::connected_cb, this, _1),\n+         boost::bind(&TorController::disconnected_cb, this, _1) )) {\n+        LogPrintf(\"[tor] Re-initiating connection to Tor control port %s failed\\n\", target);\n+    }\n+}\n+\n+std::string TorController::GetPrivateKeyFile()\n+{\n+    return (GetDataDir() / \"onion_private_key\").string();\n+}\n+\n+void TorController::shutdown_poll_cb(evutil_socket_t fd, short what, void *arg)\n+{\n+    TorController *self = (TorController*)arg;\n+    if (ShutdownRequested()) {\n+        // Shutdown was requested. Stop timers, and request control connection to terminate\n+        LogPrintf(\"[tor] Thread interrupt\\n\");\n+        if (self->shutdown_poll_ev)\n+            event_del(self->shutdown_poll_ev);\n+        self->shutdown_poll_ev = 0;\n+        if (self->reconnect_ev)\n+            event_del(self->reconnect_ev);\n+        self->reconnect_ev = 0;\n+        self->reconnect = false;\n+        self->conn.Disconnect();\n+    }\n+}\n+\n+void TorController::reconnect_cb(evutil_socket_t fd, short what, void *arg)\n+{\n+    TorController *self = (TorController*)arg;\n+    self->Reconnect();\n+}\n+\n+/****** Thread ********/\n+\n+static void TorControlThread()\n+{\n+    struct event_base *base = event_base_new();\n+    if (!base) {\n+        LogPrintf(\"[tor] Unable to create event_base_new\");\n+        return;\n+    }\n+    TorController ctrl(base, GetArg(\"-torcontrol\", DEFAULT_TOR_CONTROL));\n+\n+    event_base_dispatch(base);\n+    event_base_free(base);\n+}\n+\n+void StartTorControl(boost::thread_group& threadGroup, CScheduler& scheduler)\n+{\n+    threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"torcontrol\", &TorControlThread));\n+}\n+\n+void StopTorControl()\n+{\n+    /* Nothing to do actually. Everything is cleaned up when thread exits */\n+}\n+"
      },
      {
        "sha": "fa55f6b030a794ca6fc95fe78978da6c3fea1f1b",
        "filename": "src/torcontrol.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f4e67f152a9625a1c66c20de00679286b2c187c/src/torcontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f4e67f152a9625a1c66c20de00679286b2c187c/src/torcontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.h?ref=8f4e67f152a9625a1c66c20de00679286b2c187c",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+/**\n+ * Functionality for communicating with Tor.\n+ */\n+#ifndef BITCOIN_TORCONTROL_H\n+#define BITCOIN_TORCONTROL_H\n+\n+#include \"scheduler.h\"\n+\n+extern const std::string DEFAULT_TOR_CONTROL;\n+static const bool DEFAULT_LISTEN_ONION = true;\n+\n+void StartTorControl(boost::thread_group& threadGroup, CScheduler& scheduler);\n+void StopTorControl();\n+\n+#endif /* BITCOIN_TORCONTROL_H */"
      }
    ]
  },
  {
    "sha": "2f796e5fe7a51e4636600b320dc1995e048b4ba2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjc5NmU1ZmU3YTUxZTQ2MzY2MDBiMzIwZGMxOTk1ZTA0OGI0YmEy",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-08-27T04:43:18Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-10T16:29:56Z"
      },
      "message": "Better error message if Tor version too old",
      "tree": {
        "sha": "601c38fed5b020d97b8df73bd310e8a803b3e174",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/601c38fed5b020d97b8df73bd310e8a803b3e174"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f796e5fe7a51e4636600b320dc1995e048b4ba2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f796e5fe7a51e4636600b320dc1995e048b4ba2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f796e5fe7a51e4636600b320dc1995e048b4ba2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f796e5fe7a51e4636600b320dc1995e048b4ba2/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f4e67f152a9625a1c66c20de00679286b2c187c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f4e67f152a9625a1c66c20de00679286b2c187c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f4e67f152a9625a1c66c20de00679286b2c187c"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "40ffbe61b1609df27c81ee847109443eae78cdd2",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f796e5fe7a51e4636600b320dc1995e048b4ba2/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f796e5fe7a51e4636600b320dc1995e048b4ba2/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=2f796e5fe7a51e4636600b320dc1995e048b4ba2",
        "patch": "@@ -408,8 +408,10 @@ void TorController::add_onion_cb(TorControlConnection& conn, const TorControlRep\n         }\n         AddLocal(service, LOCAL_MANUAL);\n         // ... onion requested - keep connection open\n+    } else if (reply.code == 510) { // 510 Unrecognized command\n+        LogPrintf(\"[tor] Add onion failed with unrecognized command (You probably need to upgrade Tor)\\n\");\n     } else {\n-        LogPrintf(\"[tor] Add onion failed\\n\");\n+        LogPrintf(\"[tor] Add onion failed; error code %d\\n\", reply.code);\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "09c1ae1c01076f64fe0654f371200668306e5e18",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOWMxYWUxYzAxMDc2ZjY0ZmUwNjU0ZjM3MTIwMDY2ODMwNmU1ZTE4",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-08T15:48:45Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-12T16:58:15Z"
      },
      "message": "torcontrol improvements and fixes\n\n- Force AUTHCOOKIE size to be 32 bytes: This provides protection against\n  an attack where a process pretends to be Tor and uses the cookie\n  authentication method to nab arbitrary files such as the\n  wallet\n- torcontrol logging\n- fix cookie auth\n- add HASHEDPASSWORD auth, fix fd leak when fwrite() fails\n- better error reporting when cookie file is not ok\n- better init/shutdown flow\n- stop advertizing service when disconnected from tor control port\n- COOKIE->SAFECOOKIE auth",
      "tree": {
        "sha": "ca15b563a5b6e39b53edafda7818c986cc7e7f4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ca15b563a5b6e39b53edafda7818c986cc7e7f4b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/09c1ae1c01076f64fe0654f371200668306e5e18",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09c1ae1c01076f64fe0654f371200668306e5e18",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/09c1ae1c01076f64fe0654f371200668306e5e18",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09c1ae1c01076f64fe0654f371200668306e5e18/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f796e5fe7a51e4636600b320dc1995e048b4ba2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f796e5fe7a51e4636600b320dc1995e048b4ba2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f796e5fe7a51e4636600b320dc1995e048b4ba2"
      }
    ],
    "stats": {
      "total": 290,
      "additions": 206,
      "deletions": 84
    },
    "files": [
      {
        "sha": "024355f7c169857ab501f27c0569a7af09138f68",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09c1ae1c01076f64fe0654f371200668306e5e18/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09c1ae1c01076f64fe0654f371200668306e5e18/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=09c1ae1c01076f64fe0654f371200668306e5e18",
        "patch": "@@ -160,6 +160,7 @@ void Interrupt(boost::thread_group& threadGroup)\n     InterruptHTTPRPC();\n     InterruptRPC();\n     InterruptREST();\n+    InterruptTorControl();\n     threadGroup.interrupt_all();\n }\n \n@@ -362,6 +363,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n     strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n     strUsage += HelpMessageOpt(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL));\n+    strUsage += HelpMessageOpt(\"-torpassword=<pass>\", _(\"Tor control port password (default: empty)\"));\n #ifdef USE_UPNP\n #if USE_UPNP\n     strUsage += HelpMessageOpt(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"));"
      },
      {
        "sha": "ada4a1bb6214c4ec6a568cfc1f0a0037eeee6a67",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09c1ae1c01076f64fe0654f371200668306e5e18/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09c1ae1c01076f64fe0654f371200668306e5e18/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=09c1ae1c01076f64fe0654f371200668306e5e18",
        "patch": "@@ -263,6 +263,14 @@ bool AddLocal(const CNetAddr &addr, int nScore)\n     return AddLocal(CService(addr, GetListenPort()), nScore);\n }\n \n+bool RemoveLocal(const CService& addr)\n+{\n+    LOCK(cs_mapLocalHost);\n+    LogPrintf(\"RemoveLocal(%s)\\n\", addr.ToString());\n+    mapLocalHost.erase(addr);\n+    return true;\n+}\n+\n /** Make a particular network entirely off-limits (no automatic connects to it) */\n void SetLimited(enum Network net, bool fLimited)\n {"
      },
      {
        "sha": "d89244523eb3e05a38a7a789179ce43ef8092451",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09c1ae1c01076f64fe0654f371200668306e5e18/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09c1ae1c01076f64fe0654f371200668306e5e18/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=09c1ae1c01076f64fe0654f371200668306e5e18",
        "patch": "@@ -128,6 +128,7 @@ bool IsLimited(enum Network net);\n bool IsLimited(const CNetAddr& addr);\n bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+bool RemoveLocal(const CService& addr);\n bool SeenLocal(const CService& addr);\n bool IsLocal(const CService& addr);\n bool GetLocal(CService &addr, const CNetAddr *paddrPeer = NULL);"
      },
      {
        "sha": "08644f29684f685bd7e209c46bc7d14119fa4258",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 194,
        "deletions": 84,
        "changes": 278,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09c1ae1c01076f64fe0654f371200668306e5e18/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09c1ae1c01076f64fe0654f371200668306e5e18/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=09c1ae1c01076f64fe0654f371200668306e5e18",
        "patch": "@@ -2,7 +2,7 @@\n #include \"utilstrencodings.h\"\n #include \"net.h\"\n #include \"util.h\"\n-#include \"init.h\" // Just for ShutdownRequested\n+#include \"crypto/hmac_sha256.h\"\n \n #include <vector>\n #include <deque>\n@@ -16,13 +16,33 @@\n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n \n #include <event2/bufferevent.h>\n #include <event2/buffer.h>\n #include <event2/util.h>\n #include <event2/event.h>\n+#include <event2/thread.h>\n \n+/** Default control port */\n const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+/** Tor cookie size (from control-spec.txt) */\n+static const int TOR_COOKIE_SIZE = 32;\n+/** Size of client/server nonce for SAFECOOKIE */\n+static const int TOR_NONCE_SIZE = 32;\n+/** For computing serverHash in SAFECOOKIE */\n+static const std::string TOR_SAFE_SERVERKEY = \"Tor safe cookie authentication server-to-controller hash\";\n+/** For computing clientHash in SAFECOOKIE */\n+static const std::string TOR_SAFE_CLIENTKEY = \"Tor safe cookie authentication controller-to-server hash\";\n+/** Exponential backoff configuration - initial timeout in seconds */\n+static const float RECONNECT_TIMEOUT_START = 1.0;\n+/** Exponential backoff configuration - growth factor */\n+static const float RECONNECT_TIMEOUT_EXP = 1.5;\n+/** Maximum length for lines received on TorControlConnection.\n+ * tor-control-spec.txt mentions that there is explicitly no limit defined to line length,\n+ * this is belt-and-suspenders sanity limit to prevent memory exhaustion.\n+ */\n+static const int MAX_LINE_LENGTH = 100000;\n \n /****** Low-level TorControlConnection ********/\n \n@@ -123,7 +143,7 @@ void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n         if (s.size() < 4) // Short line\n             continue;\n         // <status>(-|+| )<data><CRLF>\n-        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.code = atoi(s.substr(0,3));\n         self->message.lines.push_back(s.substr(4));\n         char ch = s[3]; // '-','+' or ' '\n         if (ch == ' ') {\n@@ -138,25 +158,32 @@ void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n                     self->reply_handlers.front()(*self, self->message);\n                     self->reply_handlers.pop_front();\n                 } else {\n-                    LogPrintf(\"[tor] Received unexpected sync reply %i\\n\", self->message.code);\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n                 }\n             }\n             self->message.Clear();\n         }\n     }\n+    //  Check for size of buffer - protect against memory exhaustion with very long lines\n+    //  Do this after evbuffer_readln to make sure all full lines have been\n+    //  removed from the buffer. Everything left is an incomplete line.\n+    if (evbuffer_get_length(input) > MAX_LINE_LENGTH) {\n+        LogPrintf(\"tor: Disconnecting because MAX_LINE_LENGTH exceeded\\n\");\n+        self->Disconnect();\n+    }\n }\n \n void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n {\n     TorControlConnection *self = (TorControlConnection*)ctx;\n     if (what & BEV_EVENT_CONNECTED) {\n-        LogPrintf(\"[tor] Succesfully connected!\\n\");\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n         self->connected(*self);\n     } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n         if (what & BEV_EVENT_ERROR)\n-            LogPrintf(\"[tor] Error connecting to Tor control socket\\n\");\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n         else\n-            LogPrintf(\"[tor] End of stream\\n\");\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n         self->Disconnect();\n         self->disconnected(*self);\n     }\n@@ -171,7 +198,7 @@ bool TorControlConnection::Connect(const std::string &target, const ConnectionCB\n     int connect_to_addrlen = sizeof(connect_to_addr);\n     if (evutil_parse_sockaddr_port(target.c_str(),\n         (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n-        perror(\"evutil_parse_sockaddr_port\\n\");\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n         return false;\n     }\n \n@@ -186,7 +213,7 @@ bool TorControlConnection::Connect(const std::string &target, const ConnectionCB\n \n     // Finally, connect to target\n     if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n-        perror(\"bufferevent_socket_connect\");\n+        LogPrintf(\"tor: Error connecting to address %s\\n\", target);\n         return false;\n     }\n     return true;\n@@ -274,17 +301,26 @@ static std::map<std::string,std::string> ParseTorReplyMapping(const std::string\n     return mapping;\n }\n \n-/** Read full contents of a file and return them in a std::string. */\n-static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename)\n+/** Read full contents of a file and return them in a std::string.\n+ * Returns a pair <status, string>.\n+ * If an error occured, status will be false, otherwise status will be true and the data will be returned in string.\n+ *\n+ * @param maxsize Puts a maximum size limit on the file that is read. If the file is larger than this, truncated data\n+ *         (with len > maxsize) will be returned.\n+ */\n+static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n {\n     FILE *f = fopen(filename.c_str(), \"rb\");\n     if (f == NULL)\n         return std::make_pair(false,\"\");\n     std::string retval;\n     char buffer[128];\n     size_t n;\n-    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0)\n+    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n         retval.append(buffer, buffer+n);\n+        if (retval.size() > maxsize)\n+            break;\n+    }\n     fclose(f);\n     return std::make_pair(true,retval);\n }\n@@ -297,8 +333,10 @@ static bool WriteBinaryFile(const std::string &filename, const std::string &data\n     FILE *f = fopen(filename.c_str(), \"wb\");\n     if (f == NULL)\n         return false;\n-    if (fwrite(data.data(), 1, data.size(), f) != data.size())\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n         return false;\n+    }\n     fclose(f);\n     return true;\n }\n@@ -326,70 +364,62 @@ class TorController\n     std::string private_key;\n     std::string service_id;\n     bool reconnect;\n-    struct event *shutdown_poll_ev;\n     struct event *reconnect_ev;\n     float reconnect_timeout;\n+    CService service;\n+    /** Cooie for SAFECOOKIE auth */\n+    std::vector<uint8_t> cookie;\n+    /** ClientNonce for SAFECOOKIE auth */\n+    std::vector<uint8_t> clientNonce;\n \n     /** Callback for ADD_ONION result */\n     void add_onion_cb(TorControlConnection& conn, const TorControlReply& reply);\n     /** Callback for AUTHENTICATE result */\n     void auth_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for AUTHCHALLENGE result */\n+    void authchallenge_cb(TorControlConnection& conn, const TorControlReply& reply);\n     /** Callback for PROTOCOLINFO result */\n     void protocolinfo_cb(TorControlConnection& conn, const TorControlReply& reply);\n     /** Callback after succesful connection */\n     void connected_cb(TorControlConnection& conn);\n     /** Callback after connection lost or failed connection attempt */\n     void disconnected_cb(TorControlConnection& conn);\n \n-    /** Callback for shutdown poll timer */\n-    static void shutdown_poll_cb(evutil_socket_t fd, short what, void *arg);\n     /** Callback for reconnect timer */\n     static void reconnect_cb(evutil_socket_t fd, short what, void *arg);\n };\n \n-/** Exponential backoff configuration - initial timeout in seconds */\n-static const float RECONNECT_TIMEOUT_START = 1.0;\n-/** Exponential backoff configuration - growth factor */\n-static const float RECONNECT_TIMEOUT_EXP = 1.5;\n-\n TorController::TorController(struct event_base* base, const std::string& target):\n     base(base),\n-    target(target), conn(base), reconnect(true), shutdown_poll_ev(0), reconnect_ev(0),\n+    target(target), conn(base), reconnect(true), reconnect_ev(0),\n     reconnect_timeout(RECONNECT_TIMEOUT_START)\n {\n     // Start connection attempts immediately\n     if (!conn.Connect(target, boost::bind(&TorController::connected_cb, this, _1),\n          boost::bind(&TorController::disconnected_cb, this, _1) )) {\n-        LogPrintf(\"[tor] Initiating connection to Tor control port %s failed\\n\", target);\n+        LogPrintf(\"tor: Initiating connection to Tor control port %s failed\\n\", target);\n     }\n     // Read service private key if cached\n     std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\n     if (pkf.first) {\n-        LogPrintf(\"[tor] Reading cached private key from %s\\n\", GetPrivateKeyFile());\n+        LogPrint(\"tor\", \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile());\n         private_key = pkf.second;\n     }\n-    // Periodic timer event to poll for shutdown\n-    // The same 200ms as in bitcoind. This is not the nicest solution, but we cannot exactly use\n-    // boost::interrupt here.\n-    struct timeval time;\n-    time.tv_usec = 200000;\n-    time.tv_sec = 0;\n-    shutdown_poll_ev = event_new(base, -1, EV_PERSIST, shutdown_poll_cb, this);\n-    event_add(shutdown_poll_ev, &time);\n }\n \n TorController::~TorController()\n {\n-    if (shutdown_poll_ev)\n-        event_del(shutdown_poll_ev);\n     if (reconnect_ev)\n         event_del(reconnect_ev);\n+    if (service.IsValid()) {\n+        RemoveLocal(service);\n+    }\n }\n \n void TorController::add_onion_cb(TorControlConnection& conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrintf(\"[tor] ADD_ONION succesful\\n\");\n+        LogPrint(\"tor\", \"tor: ADD_ONION succesful\\n\");\n         BOOST_FOREACH(const std::string &s, reply.lines) {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n             std::map<std::string,std::string>::iterator i;\n@@ -399,26 +429,26 @@ void TorController::add_onion_cb(TorControlConnection& conn, const TorControlRep\n                 private_key = i->second;\n         }\n \n-        CService service(service_id+\".onion\", GetListenPort(), false);\n-        LogPrintf(\"[tor] Got service ID %s, advertizing service %s\\n\", service_id, service.ToString());\n+        service = CService(service_id+\".onion\", GetListenPort(), false);\n+        LogPrintf(\"tor: Got service ID %s, advertizing service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n-            LogPrintf(\"[tor] Cached service private key to %s\\n\", GetPrivateKeyFile());\n+            LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n         } else {\n-            LogPrintf(\"[tor] Error writing service private key to %s\\n\", GetPrivateKeyFile());\n+            LogPrintf(\"tor: Error writing service private key to %s\\n\", GetPrivateKeyFile());\n         }\n         AddLocal(service, LOCAL_MANUAL);\n         // ... onion requested - keep connection open\n     } else if (reply.code == 510) { // 510 Unrecognized command\n-        LogPrintf(\"[tor] Add onion failed with unrecognized command (You probably need to upgrade Tor)\\n\");\n+        LogPrintf(\"tor: Add onion failed with unrecognized command (You probably need to upgrade Tor)\\n\");\n     } else {\n-        LogPrintf(\"[tor] Add onion failed; error code %d\\n\", reply.code);\n+        LogPrintf(\"tor: Add onion failed; error code %d\\n\", reply.code);\n     }\n }\n \n void TorController::auth_cb(TorControlConnection& conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrintf(\"[tor] Authentication succesful\\n\");\n+        LogPrint(\"tor\", \"tor: Authentication succesful\\n\");\n         // Finally - now create the service\n         if (private_key.empty()) // No private key, generate one\n             private_key = \"NEW:BEST\";\n@@ -428,7 +458,65 @@ void TorController::auth_cb(TorControlConnection& conn, const TorControlReply& r\n         conn.Command(strprintf(\"ADD_ONION %s Port=%i,127.0.0.1:%i\", private_key, GetListenPort(), GetListenPort()),\n             boost::bind(&TorController::add_onion_cb, this, _1, _2));\n     } else {\n-        LogPrintf(\"[tor] Authentication failed\\n\");\n+        LogPrintf(\"tor: Authentication failed\\n\");\n+    }\n+}\n+\n+/** Compute Tor SAFECOOKIE response.\n+ *\n+ *    ServerHash is computed as:\n+ *      HMAC-SHA256(\"Tor safe cookie authentication server-to-controller hash\",\n+ *                  CookieString | ClientNonce | ServerNonce)\n+ *    (with the HMAC key as its first argument)\n+ *\n+ *    After a controller sends a successful AUTHCHALLENGE command, the\n+ *    next command sent on the connection must be an AUTHENTICATE command,\n+ *    and the only authentication string which that AUTHENTICATE command\n+ *    will accept is:\n+ *\n+ *      HMAC-SHA256(\"Tor safe cookie authentication controller-to-server hash\",\n+ *                  CookieString | ClientNonce | ServerNonce)\n+ *\n+ */\n+static std::vector<uint8_t> ComputeResponse(const std::string &key, const std::vector<uint8_t> &cookie,  const std::vector<uint8_t> &clientNonce, const std::vector<uint8_t> &serverNonce)\n+{\n+    CHMAC_SHA256 computeHash((const uint8_t*)key.data(), key.size());\n+    std::vector<uint8_t> computedHash(CHMAC_SHA256::OUTPUT_SIZE, 0);\n+    computeHash.Write(begin_ptr(cookie), cookie.size());\n+    computeHash.Write(begin_ptr(clientNonce), clientNonce.size());\n+    computeHash.Write(begin_ptr(serverNonce), serverNonce.size());\n+    computeHash.Finalize(begin_ptr(computedHash));\n+    return computedHash;\n+}\n+\n+void TorController::authchallenge_cb(TorControlConnection& conn, const TorControlReply& reply)\n+{\n+    if (reply.code == 250) {\n+        LogPrint(\"tor\", \"tor: SAFECOOKIE authentication challenge succesful\\n\");\n+        std::pair<std::string,std::string> l = SplitTorReplyLine(reply.lines[0]);\n+        if (l.first == \"AUTHCHALLENGE\") {\n+            std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n+            std::vector<uint8_t> serverHash = ParseHex(m[\"SERVERHASH\"]);\n+            std::vector<uint8_t> serverNonce = ParseHex(m[\"SERVERNONCE\"]);\n+            LogPrint(\"tor\", \"tor: AUTHCHALLENGE ServerHash %s ServerNonce %s\\n\", HexStr(serverHash), HexStr(serverNonce));\n+            if (serverNonce.size() != 32) {\n+                LogPrintf(\"tor: ServerNonce is not 32 bytes, as required by spec\\n\");\n+                return;\n+            }\n+\n+            std::vector<uint8_t> computedServerHash = ComputeResponse(TOR_SAFE_SERVERKEY, cookie, clientNonce, serverNonce);\n+            if (computedServerHash != serverHash) {\n+                LogPrintf(\"tor: ServerHash %s does not match expected ServerHash %s\\n\", HexStr(serverHash), HexStr(computedServerHash));\n+                return;\n+            }\n+\n+            std::vector<uint8_t> computedClientHash = ComputeResponse(TOR_SAFE_CLIENTKEY, cookie, clientNonce, serverNonce);\n+            conn.Command(\"AUTHENTICATE \" + HexStr(computedClientHash), boost::bind(&TorController::auth_cb, this, _1, _2));\n+        } else {\n+            LogPrintf(\"tor: Invalid reply to AUTHCHALLENGE\\n\");\n+        }\n+    } else {\n+        LogPrintf(\"tor: SAFECOOKIE authentication challenge failed\\n\");\n     }\n }\n \n@@ -455,37 +543,52 @@ void TorController::protocolinfo_cb(TorControlConnection& conn, const TorControl\n                 std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n                 std::map<std::string,std::string>::iterator i;\n                 if ((i = m.find(\"Tor\")) != m.end()) {\n-                    LogPrintf(\"[tor] Connected to Tor version %s\\n\", i->second);\n+                    LogPrint(\"tor\", \"tor: Connected to Tor version %s\\n\", i->second);\n                 }\n             }\n         }\n         BOOST_FOREACH(const std::string &s, methods) {\n-            LogPrintf(\"[tor] Supported authentication method: %s\\n\", s);\n+            LogPrint(\"tor\", \"tor: Supported authentication method: %s\\n\", s);\n         }\n-        // Prefer NULL, otherwise COOKIE. If a password is provided, use HASHEDPASSWORD\n-        // We do not support SAFECOOKIE\n+        // Prefer NULL, otherwise SAFECOOKIE. If a password is provided, use HASHEDPASSWORD\n         /* Authentication:\n          *   cookie:   hex-encoded ~/.tor/control_auth_cookie\n          *   password: \"password\"\n          */\n+        std::string torpassword = GetArg(\"-torpassword\", \"\");\n         if (methods.count(\"NULL\")) {\n-            LogPrintf(\"[tor] Using NULL authentication\\n\");\n+            LogPrint(\"tor\", \"tor: Using NULL authentication\\n\");\n             conn.Command(\"AUTHENTICATE\", boost::bind(&TorController::auth_cb, this, _1, _2));\n-        } else if (methods.count(\"COOKIE\")) {\n+        } else if (methods.count(\"SAFECOOKIE\")) {\n             // Cookie: hexdump -e '32/1 \"%02x\"\"\\n\"'  ~/.tor/control_auth_cookie\n-            LogPrintf(\"[tor] Using COOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n-            std::string cookie = ReadBinaryFile(cookiefile).second;\n-            if (!cookie.empty()) {\n-                conn.Command(\"AUTHENTICATE \" + HexStr(cookie), boost::bind(&TorController::auth_cb, this, _1, _2));\n+            LogPrint(\"tor\", \"tor: Using SAFECOOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n+            std::pair<bool,std::string> status_cookie = ReadBinaryFile(cookiefile, TOR_COOKIE_SIZE);\n+            if (status_cookie.first && status_cookie.second.size() == TOR_COOKIE_SIZE) {\n+                // conn.Command(\"AUTHENTICATE \" + HexStr(status_cookie.second), boost::bind(&TorController::auth_cb, this, _1, _2));\n+                cookie = std::vector<uint8_t>(status_cookie.second.begin(), status_cookie.second.end());\n+                clientNonce = std::vector<uint8_t>(TOR_NONCE_SIZE, 0);\n+                GetRandBytes(&clientNonce[0], TOR_NONCE_SIZE);\n+                conn.Command(\"AUTHCHALLENGE SAFECOOKIE \" + HexStr(clientNonce), boost::bind(&TorController::authchallenge_cb, this, _1, _2));\n             } else {\n-                LogPrintf(\"[tor] Authentication cookie not found\\n\");\n+                if (status_cookie.first) {\n+                    LogPrintf(\"tor: Authentication cookie %s is not exactly %i bytes, as is required by the spec\\n\", cookiefile, TOR_COOKIE_SIZE);\n+                } else {\n+                    LogPrintf(\"tor: Authentication cookie %s could not be opened (check permissions)\\n\", cookiefile);\n+                }\n+            }\n+        } else if (methods.count(\"HASHEDPASSWORD\")) {\n+            if (!torpassword.empty()) {\n+                LogPrint(\"tor\", \"tor: Using HASHEDPASSWORD authentication\\n\");\n+                boost::replace_all(torpassword, \"\\\"\", \"\\\\\\\"\");\n+                conn.Command(\"AUTHENTICATE \\\"\" + torpassword + \"\\\"\", boost::bind(&TorController::auth_cb, this, _1, _2));\n+            } else {\n+                LogPrintf(\"tor: Password authentication required, but no password provided with -torpassword\\n\");\n             }\n         } else {\n-            /* TODO HASHEDPASSWORD w/ manual auth */\n-            LogPrintf(\"[tor] No supported authentication method\\n\");\n+            LogPrintf(\"tor: No supported authentication method\\n\");\n         }\n     } else {\n-        LogPrintf(\"[tor] Requesting protocol info failed\\n\");\n+        LogPrintf(\"tor: Requesting protocol info failed\\n\");\n     }\n }\n \n@@ -494,14 +597,18 @@ void TorController::connected_cb(TorControlConnection& conn)\n     reconnect_timeout = RECONNECT_TIMEOUT_START;\n     // First send a PROTOCOLINFO command to figure out what authentication is expected\n     if (!conn.Command(\"PROTOCOLINFO 1\", boost::bind(&TorController::protocolinfo_cb, this, _1, _2)))\n-        LogPrintf(\"[tor] Error sending initial protocolinfo command\\n\");\n+        LogPrintf(\"tor: Error sending initial protocolinfo command\\n\");\n }\n \n void TorController::disconnected_cb(TorControlConnection& conn)\n {\n+    // Stop advertizing service when disconnected\n+    if (service.IsValid())\n+        RemoveLocal(service);\n+    service = CService();\n     if (!reconnect)\n         return;\n-    LogPrintf(\"[tor] Disconnected from Tor control port %s, trying to reconnect\\n\", target);\n+    LogPrintf(\"tor: Disconnected from Tor control port %s, trying to reconnect\\n\", target);\n     // Single-shot timer for reconnect. Use exponential backoff.\n     struct timeval time = MillisToTimeval(int64_t(reconnect_timeout * 1000.0));\n     reconnect_ev = event_new(base, -1, 0, reconnect_cb, this);\n@@ -516,7 +623,7 @@ void TorController::Reconnect()\n      */\n     if (!conn.Connect(target, boost::bind(&TorController::connected_cb, this, _1),\n          boost::bind(&TorController::disconnected_cb, this, _1) )) {\n-        LogPrintf(\"[tor] Re-initiating connection to Tor control port %s failed\\n\", target);\n+        LogPrintf(\"tor: Re-initiating connection to Tor control port %s failed\\n\", target);\n     }\n }\n \n@@ -525,51 +632,54 @@ std::string TorController::GetPrivateKeyFile()\n     return (GetDataDir() / \"onion_private_key\").string();\n }\n \n-void TorController::shutdown_poll_cb(evutil_socket_t fd, short what, void *arg)\n-{\n-    TorController *self = (TorController*)arg;\n-    if (ShutdownRequested()) {\n-        // Shutdown was requested. Stop timers, and request control connection to terminate\n-        LogPrintf(\"[tor] Thread interrupt\\n\");\n-        if (self->shutdown_poll_ev)\n-            event_del(self->shutdown_poll_ev);\n-        self->shutdown_poll_ev = 0;\n-        if (self->reconnect_ev)\n-            event_del(self->reconnect_ev);\n-        self->reconnect_ev = 0;\n-        self->reconnect = false;\n-        self->conn.Disconnect();\n-    }\n-}\n-\n void TorController::reconnect_cb(evutil_socket_t fd, short what, void *arg)\n {\n     TorController *self = (TorController*)arg;\n     self->Reconnect();\n }\n \n /****** Thread ********/\n+struct event_base *base;\n+boost::thread torControlThread;\n \n static void TorControlThread()\n {\n-    struct event_base *base = event_base_new();\n-    if (!base) {\n-        LogPrintf(\"[tor] Unable to create event_base_new\");\n-        return;\n-    }\n     TorController ctrl(base, GetArg(\"-torcontrol\", DEFAULT_TOR_CONTROL));\n \n     event_base_dispatch(base);\n-    event_base_free(base);\n }\n \n void StartTorControl(boost::thread_group& threadGroup, CScheduler& scheduler)\n {\n-    threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"torcontrol\", &TorControlThread));\n+    assert(!base);\n+#ifdef WIN32\n+    evthread_use_windows_threads();\n+#else\n+    evthread_use_pthreads();\n+#endif\n+    base = event_base_new();\n+    if (!base) {\n+        LogPrintf(\"tor: Unable to create event_base\\n\");\n+        return;\n+    }\n+\n+    torControlThread = boost::thread(boost::bind(&TraceThread<void (*)()>, \"torcontrol\", &TorControlThread));\n+}\n+\n+void InterruptTorControl()\n+{\n+    if (base) {\n+        LogPrintf(\"tor: Thread interrupt\\n\");\n+        event_base_loopbreak(base);\n+    }\n }\n \n void StopTorControl()\n {\n-    /* Nothing to do actually. Everything is cleaned up when thread exits */\n+    if (base) {\n+        torControlThread.join();\n+        event_base_free(base);\n+        base = 0;\n+    }\n }\n "
      },
      {
        "sha": "72dc82c5b17a97102d6f881e1d209ab26a26dc7e",
        "filename": "src/torcontrol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09c1ae1c01076f64fe0654f371200668306e5e18/src/torcontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09c1ae1c01076f64fe0654f371200668306e5e18/src/torcontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.h?ref=09c1ae1c01076f64fe0654f371200668306e5e18",
        "patch": "@@ -14,6 +14,7 @@ extern const std::string DEFAULT_TOR_CONTROL;\n static const bool DEFAULT_LISTEN_ONION = true;\n \n void StartTorControl(boost::thread_group& threadGroup, CScheduler& scheduler);\n+void InterruptTorControl();\n void StopTorControl();\n \n #endif /* BITCOIN_TORCONTROL_H */"
      }
    ]
  },
  {
    "sha": "68ccdc4696cceade91ff0a78bd011a8437f15e8f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OGNjZGM0Njk2Y2NlYWRlOTFmZjBhNzhiZDAxMWE4NDM3ZjE1ZThm",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-10T16:40:36Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-12T16:58:15Z"
      },
      "message": "doc: Mention Tor listening in release notes",
      "tree": {
        "sha": "398ed09497aace66016f249171acab0d55df9ea3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/398ed09497aace66016f249171acab0d55df9ea3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/68ccdc4696cceade91ff0a78bd011a8437f15e8f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68ccdc4696cceade91ff0a78bd011a8437f15e8f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/68ccdc4696cceade91ff0a78bd011a8437f15e8f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68ccdc4696cceade91ff0a78bd011a8437f15e8f/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "09c1ae1c01076f64fe0654f371200668306e5e18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09c1ae1c01076f64fe0654f371200668306e5e18",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/09c1ae1c01076f64fe0654f371200668306e5e18"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 17,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3d10a079128ca78ecef040d5715edaf45b2f6189",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68ccdc4696cceade91ff0a78bd011a8437f15e8f/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68ccdc4696cceade91ff0a78bd011a8437f15e8f/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=68ccdc4696cceade91ff0a78bd011a8437f15e8f",
        "patch": "@@ -151,6 +151,23 @@ mining with the getblocktemplate protocol to a pool: this will affect you at\n the pool operator's discretion, which must be no later than BIP65 achieving its\n 951/1001 status.\n \n+Automatically listen on Tor\n+----------------------------\n+\n+Starting with Tor version 0.2.7.1 it is possible, through Tor's control socket\n+API, to create and destroy 'ephemeral' hidden services programmatically.\n+Bitcoin Core has been updated to make use of this.\n+\n+This means that if Tor is running (and proper authorization is available),\n+Bitcoin Core automatically creates a hidden service to listen on, without\n+manual configuration. This will positively affect the number of available\n+.onion nodes.\n+\n+This new feature is enabled by default if Bitcoin Core is listening, and\n+a connection to Tor can be made. It can be configured with the `-listenonion`,\n+`-torcontrol` and `-torpassword` settings. To show verbose debugging\n+information, pass `-debug=tor`.\n+\n 0.12.0 Change log\n =================\n "
      }
    ]
  },
  {
    "sha": "58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OGVmMGZmYTllZjljNmVjZDM4MzA0MGVkYmQ1YzViNmUwYTYzZmVm",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-11T14:08:38Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-11-12T17:08:50Z"
      },
      "message": "doc: update docs for Tor listening\n\n- add new data directory files for 0.12 to doc/files.md\n- mention torcontrol in doc/tor.md",
      "tree": {
        "sha": "9899998dbde3d1da4a6910f5f8f33a240769f60a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9899998dbde3d1da4a6910f5f8f33a240769f60a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "68ccdc4696cceade91ff0a78bd011a8437f15e8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68ccdc4696cceade91ff0a78bd011a8437f15e8f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/68ccdc4696cceade91ff0a78bd011a8437f15e8f"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 19,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f7eca57dcb08fb3ea3e4e4d7dc274c0a33fa7431",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef",
        "patch": "@@ -12,6 +12,8 @@\n * fee_estimates.dat: stores statistics used to estimate minimum transaction fees and priorities required for confirmation; since 0.10.0\n * peers.dat: peer IP address database (custom format); since 0.7.0\n * wallet.dat: personal wallet (BDB) with keys and transactions\n+* .cookie: session RPC authentication cookie (written at start when cookie authentication is used, deleted on shutdown): since 0.12.0\n+* onion_private_key: cached Tor hidden service private key for `-listenonion`: since 0.12.0\n \n Only used in pre-0.8.0\n ---------------------"
      },
      {
        "sha": "1d35a658bc42e4aaa34f2982357f9d1a20197c92",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=58ef0ffa9ef9c6ecd383040edbd5c5b6e0a63fef",
        "patch": "@@ -87,3 +87,20 @@ If you only want to use Tor to reach onion addresses, but not use it as a proxy\n for normal IPv4/IPv6 communication, use:\n \n \t./bitcoin -onion=127.0.0.1:9050 -externalip=57qr3yd1nyntf5k.onion -discover\n+\n+3. Automatically listen on Tor\n+--------------------------------\n+\n+Starting with Tor version 0.2.7.1 it is possible, through Tor's control socket\n+API, to create and destroy 'ephemeral' hidden services programmatically.\n+Bitcoin Core has been updated to make use of this.\n+\n+This means that if Tor is running (and proper authorization is available),\n+Bitcoin Core automatically creates a hidden service to listen on, without\n+manual configuration. This will positively affect the number of available\n+.onion nodes.\n+\n+This new feature is enabled by default if Bitcoin Core is listening, and\n+a connection to Tor can be made. It can be configured with the `-listenonion`,\n+`-torcontrol` and `-torpassword` settings. To show verbose debugging\n+information, pass `-debug=tor`."
      }
    ]
  }
]