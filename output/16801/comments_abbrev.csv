DrahtBot,2019-09-04 07:45:49,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16910](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16910.html) (wallet: reduce loading time by using unorde",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-527784726,527784726,
MarcoFalke,2019-09-04 11:26:27,re-run ci,https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-527859568,527859568,
jamesob,2019-09-04 13:52:18,"Concept ACK. Thanks for working on this. I did a cursory skim over the code and it looks very readable. The tests are nice too.\n\nI'll do a more thorough review and some benchmark runs in the next few days. ",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-527910427,527910427,
martinus,2019-09-11 18:37:21,"Here is a graph of another comparison run of the indexing progress over time that I get on my machine (Intel i7-8700 @ 3.20GHz, 32GB of RAM)\n\n![out](https://user-images.githubusercontent.com/14386/64724584-09da4c00-d4d3-11e9-8888-6586ad5829ba.png)\n\n* 3432sec for 2019-08-bulkpoolallocator, 4135 sec for master.\n* 6.973.488 kbyte max RSS for 2019-08-bulkpoolallocator, 7.643.956 kbyte for ma",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-530510425,530510425,
ktprime,2019-09-12 15:16:45,I want to how to migrate your good bulk pool to my project.,https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-530874101,530874101,
martinus,2019-09-12 16:55:26,"> I want to how to migrate your good bulk pool to my project.\n\nFeel free to copy the bulk_pool.h to your project. It's under the MIT license. I might extract the file into a standalone project with more benchmarks, but thats not high on my priority list.\n\nI am interested though in any improvements you see with this allocator!",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-530913306,530913306,
promag,2019-09-15 23:05:13,Looks like the improvement grows over time/progress? Have you checked with a greater `-stopatheight`?,https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-531607115,531607115,
martinus,2019-09-16 05:25:30,"I've also made a graph with `-stopatheight 594000`: ![out](https://user-images.githubusercontent.com/14386/64935718-fd4b5000-d852-11e9-8c3c-44d0b1171560.png)\n",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-531645046,531645046,
jamesob,2019-09-27 14:44:01,"After running benchmarks across a few different machines, I'm pretty confused.\n\nThe raw results are below, but the headline is that I'm consistently seeing branches using this allocator outperform master but also *vice versa* depending upon the host. It's about half and half, and when master wins it's by a pretty dramatic margin.\n\nE.g. master is reliably faster than this branch and #16718 ",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-535969850,535969850,
martinus,2019-09-28 10:14:03,"It's really strange that the difference is so dramatic. Do you have the debug.log files, or some graphs with the progresss? It would be interesting to see where it's slowing down: e.g. if it's in the DB sync, or continuously, or right *before* a sync.\n\nI think since your host only has 7.7GB memory the slowdown might come from the host swapping. Maybe the problem is the way bitcoin is handling ",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-536172801,536172801,
martinus,2019-10-05 17:08:33,rebased & squashed in 329754d4c33656b0d526aa456077f4667c6ecb11,https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-538669067,538669067,
ryanofsky,2019-11-01 17:32:02,"James walked me through the benchmarks, and I guess a summary is that the benchmarks do generally look good and show expected decreases in runtime and memory usage at varying dbcache sizes.\n\nThe problem is that in some benchmark setups, reindexing reliably but for no explicable reason takes a lot longer (9 hours vs 2 hours) on the bulk allocator and robinhood branches than it does on the maste",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-548879236,548879236,
jamesob,2019-11-01 18:17:30,"Just as an update, I've got a plan for diagnosing the benching weirdness I've seen thus far. With any luck I'll be posting an analysis (or at least additional information) in the next few days.",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-548896153,548896153,
martinus,2019-11-01 18:25:58,"Is it possible that this weirdness can be explained by different assumedvalid points? Either in the branches, or on the disk. It was a surprise to me: https://github.com/bitcoin/bitcoin/pull/17060#issuecomment-547674256\n\nAs @MarcoFalke wrote in https://github.com/bitcoin/bitcoin/pull/17060#issuecomment-547687821, it is probably best to either use `-noassumevalid` or use the same block hash, an",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-548899136,548899136,
jamesob,2019-11-08 15:58:01,"Okay, I'm back with good news and bad(ish) news. The good news is that the bench weirdness has been resolved by comparing master (6a7c40bee4, [`bench/master.1`](https://github.com/jamesob/bitcoin/tree/bench/master.1)) to a version of this branch rebased on top of that same commit ([`bench/alloc.1`](https://github.com/jamesob/bitcoin/tree/bench/alloc.1)). So I'm guessing the weirdness before may ha",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-551883348,551883348,
martinus,2019-11-08 16:29:51,"Thanks for getting to the bottom of this @jamesob! It's good to see that the allocator actually seems to do it's job as it's supposed to be, even when the benefit is small. It's probably bigger when validation doesn't have be be redone, but the additional code complexity is probably not worth it. ",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-551896168,551896168,
ryanofsky,2019-11-18 20:44:29,"> It's probably bigger when validation doesn't have be be redone, but the additional code complexity is probably not worth it.\n\nIt seems like a pool allocator could be a basic building block for a lot of future optimizations. It might also be useful for testing overhead of allocations even in places where we wouldn't want to enable it in released code. So I could see the effort here being usef",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-555200787,555200787,
martinus,2019-11-19 07:24:34,"> One thing I'm not clear on is the difference between 3% performance improvement last measured and 16% initially measured. If there are theories about this, I'd be curious.\n\nI'm pretty sure the difference is due to to additional validation due to `-noassumevalid`. With validation, validation is the bottleneck so the improvement is not as pronounced. When no validation needs to happen, you see",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-555370503,555370503,
MarcoFalke,2019-11-19 14:09:22,"Oh, I didn't want to imply in https://github.com/bitcoin/bitcoin/pull/17060#issuecomment-547687821 that `-noassumevalid` is the only setting that makes sense for benchmarking. Every release has a different assumed valid block set by default. So when looking at total IBD time, it makes sense to consider the setting where no validation happens because it is skipped by default. If there is a more tha",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-555523561,555523561,
jamesob,2021-08-09 16:06:50,"I've benchmarked @martinus' rebased version of this branch (per https://github.com/bitcoin/bitcoin/pull/22640#issuecomment-894506145) and I'm happy to report that I'm seeing a roughly 9% speedup along with an 8% reduction in memory usage (with a very high dbcache setting). A pull request for this branch should probably be reopened, though due to the rebase I think @martinus may have to open a sepa",https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-895348607,895348607,
martinus,2021-08-09 16:39:25,Thanks for the thorough benchmark! I'll try to clean up the code a bit and then open another PR with the pool allocator. ,https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-895372039,895372039,
practicalswift,2019-09-07 10:17:08,"&lt;language lawyer hat on&gt;\n\nIs this really defined behaviour? :-)\n\n&lt;/language lawyer hat on&gt;",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321963843,321963843,src/support/allocators/bulk_pool.h
martinus,2019-09-07 11:54:27,"hm, I could add a \n```cpp\nstruct Node {\n    Node* next;\n};\n```\nAnd then use `Node*` instead of `void*`. Then instead of \n```cpp\n// put it into the linked list\n*reinterpret_cast<void**>(p) = m_free_chunks;\nm_free_chunks = p;\n```\nI could write \n```cpp\nauto n = reinterpret_cast<Node*>(p);\nn->next = m_free_chunks;\nm_free_chunks = n;\n```\nI guess the code is a bit bet",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321966253,321966253,src/support/allocators/bulk_pool.h
martinus,2019-09-08 09:04:09,I got rid of the `void**` casts in in https://github.com/bitcoin/bitcoin/pull/16801/commits/52ee5735304cb8be342e264a19274afc0f422fa8,https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321999022,321999022,src/support/allocators/bulk_pool.h
ryanofsky,2019-10-31 17:18:22,"Would it be better to drop these methods or to use a static assert, so it could be a compile time error when `sizeof(T) < sizeof(ChunkNode)` instead of a runtime error?",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341266452,341266452,src/support/allocators/bulk_pool.h
ryanofsky,2019-10-31 17:30:06,More information on this? A quick web search didn't turn up anything for me. Could say more in comment.,https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341272476,341272476,src/support/allocators/bulk_pool.h
martinus,2019-10-31 18:08:54,"Thanks for having a look at the code! In that case I think it it better to return `nullptr`, because of how it's used in `bulk_pool::Allocator<T>::allocate(size_t n)`. There `bulk_pool::Pool::Allocate()` is called, and if `nullptr` is returned I fall back to `::operator new`\n\nI could probably rewrite it to be a compile error, but then I need to rewrite `bulk_pool::Allocator<T>::allocate(size_t",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341292248,341292248,src/support/allocators/bulk_pool.h
martinus,2019-10-31 18:10:19,"It seems only g++4.8 requires that this method is present, otherwise I get a compile error. It's deprecated in C++17 and removed in C++20. I'll add a comment for that.",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341292940,341292940,src/support/allocators/bulk_pool.h
ryanofsky,2019-10-31 18:12:35,"Oh, I see. I didn't realize it would fall back to default operator new. Could mention that explicitly, but this is also fine.",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341293993,341293993,src/support/allocators/bulk_pool.h
ryanofsky,2019-11-01 14:54:43,"Given that the pool only grows and uses increasing memory over time, and that its lifetime is effectively the lifetime of the entire node, would it make sense to add some kind of garbage collection method for `CCoinsViewCache` that would free unneeded memory (maybe after finishing syncing, or after flushing, or on an interval, or from an RPC a user could call)?",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341607795,341607795,src/coins.h
JeremyRubin,2019-11-01 19:16:23,"I have the following code for something i'm working on. It should be amortized cheap to call after every erase; you could also make it have different parameters during sync or after (e.g, always compact after sync, only compact if it's above 50MB free during sync).\n```c++\n static void resize_if_savings(CTxMemPoolEntry::relatives& relatives) {\n       assert(relatives.max_load_factor() == 1)\",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341716163,341716163,src/coins.h
martinus,2019-11-02 12:06:34,"@JeremyRubin that looks interesting. I think the `if (relatives.size() > full_size/2) return;` is a bit too aggressive though. For a hashmap uses doubling as resize strategy: if it has e.g. 256 elements and you add one it will double its size, and when you remove one element again it would already trigger the rehashing to decrease its size.",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341808938,341808938,src/coins.h
JeremyRubin,2019-11-02 21:34:04,"On my system the rehash policy is the  prime less than double policy, which ensures that we have a growth factor < 2 for all resizes. So in the case of 256, we would first ""double"" to 503. Then we would be at 257/503 ""fullness"", where half would be 251. So we can remove up to 6 elements before triggering a re-hash. So the pathological cases are a bit more precise, see below:\n\n\nIf you're at e",https://github.com/bitcoin/bitcoin/pull/16801#discussion_r341826698,341826698,src/coins.h
