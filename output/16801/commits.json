[
  {
    "sha": "54ada87348dbaa963490547b342ce57b4249987e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NGFkYTg3MzQ4ZGJhYTk2MzQ5MDU0N2IzNDJjZTU3YjQyNDk5ODdl",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-08-30T17:59:57Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-11-01T07:20:08Z"
      },
      "message": "Add bulk pool allocator for node based containers.\n\nIn my benchmarks, using this pool allocator for CCoinsMap gives about\n16% faster `-reindex-chainstate`, and decreases memory usage by 8%.\nThe allocator is potentially useful for all node-based containers like\n`std::list`, `std::map`, `std::unordered_map`.",
      "tree": {
        "sha": "146974ed8a482ab543e3d300cc107d76de36c5b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/146974ed8a482ab543e3d300cc107d76de36c5b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54ada87348dbaa963490547b342ce57b4249987e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54ada87348dbaa963490547b342ce57b4249987e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54ada87348dbaa963490547b342ce57b4249987e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54ada87348dbaa963490547b342ce57b4249987e/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "222b7d0ca795c7306cd2103473c1c54c60e701f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/222b7d0ca795c7306cd2103473c1c54c60e701f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/222b7d0ca795c7306cd2103473c1c54c60e701f9"
      }
    ],
    "stats": {
      "total": 565,
      "additions": 558,
      "deletions": 7
    },
    "files": [
      {
        "sha": "5f16d9e4dcdfc1b6a5636641fe1d475e9ef3e543",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -191,6 +191,7 @@ BITCOIN_CORE_H = \\\n   script/standard.h \\\n   shutdown.h \\\n   streams.h \\\n+  support/allocators/bulk_pool.h \\\n   support/allocators/secure.h \\\n   support/allocators/zeroafterfree.h \\\n   support/cleanse.h \\"
      },
      {
        "sha": "169c3d32814dbb049993ff5383d38cd5e1077b57",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -16,6 +16,7 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/bench.cpp \\\n   bench/bench.h \\\n   bench/block_assemble.cpp \\\n+  bench/bulk_pool.cpp \\\n   bench/checkblock.cpp \\\n   bench/checkqueue.cpp \\\n   bench/data.h \\"
      },
      {
        "sha": "f8ace48a8bf4bb16dffabd5fac950d2d36c97510",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -102,6 +102,7 @@ BITCOIN_TESTS =\\\n   test/blockfilter_tests.cpp \\\n   test/blockfilter_index_tests.cpp \\\n   test/bloom_tests.cpp \\\n+  test/bulk_pool_tests.cpp \\\n   test/bswap_tests.cpp \\\n   test/checkqueue_tests.cpp \\\n   test/coins_tests.cpp \\"
      },
      {
        "sha": "653919055a53ff04eb7d5d96929e3c67f68d012a",
        "filename": "src/bench/bulk_pool.cpp",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/bench/bulk_pool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/bench/bulk_pool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bulk_pool.cpp?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <support/allocators/bulk_pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::State& state, Map& map)\n+{\n+    COutPoint p;\n+    while (state.KeepRunning()) {\n+        // modify hash. We don't need to check if big/little endian, just modify.\n+        ++*reinterpret_cast<uint64_t*>(p.hash.begin());\n+        map[p];\n+        if (map.size() > 50000) {\n+            map.clear();\n+        }\n+    }\n+}\n+\n+static void BulkPool_StdUnorderedMap(benchmark::State& state)\n+{\n+    using Map = std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher>;\n+    Map map;\n+    BenchFillClearMap(state, map);\n+}\n+\n+static void BulkPool_StdMap(benchmark::State& state)\n+{\n+    using Map = std::map<COutPoint, CCoinsCacheEntry>;\n+    Map map;\n+    BenchFillClearMap(state, map);\n+}\n+\n+static void BulkPool_StdUnorderedMap_Enabled(benchmark::State& state)\n+{\n+    using Map = std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher, std::equal_to<COutPoint>, bulk_pool::Allocator<std::pair<const COutPoint, CCoinsCacheEntry>>>;\n+    bulk_pool::Pool pool;\n+    Map map(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&pool});\n+    BenchFillClearMap(state, map);\n+}\n+\n+static void BulkPool_StdMap_Enabled(benchmark::State& state)\n+{\n+    using Map = std::map<COutPoint, CCoinsCacheEntry, std::less<COutPoint>, bulk_pool::Allocator<std::pair<const COutPoint, CCoinsCacheEntry>>>;\n+    bulk_pool::Pool pool;\n+    Map map(Map::key_compare{}, Map::allocator_type{&pool});\n+    BenchFillClearMap(state, map);\n+}\n+\n+BENCHMARK(BulkPool_StdUnorderedMap, 5000000);\n+BENCHMARK(BulkPool_StdMap, 5000000);\n+BENCHMARK(BulkPool_StdUnorderedMap_Enabled, 5000000);\n+BENCHMARK(BulkPool_StdMap_Enabled, 5000000);"
      },
      {
        "sha": "69d3d9c3223f62d68e09194ad19adc520f70e6be",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -33,7 +33,7 @@ size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn) {}\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;"
      },
      {
        "sha": "390aa41d79c4afc0a9480743a44c760f2cf9ac7e",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_COINS_H\n #define BITCOIN_COINS_H\n \n+#include <support/allocators/bulk_pool.h>\n #include <primitives/transaction.h>\n #include <compressor.h>\n #include <core_memusage.h>\n@@ -128,7 +129,7 @@ struct CCoinsCacheEntry\n     explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher, std::equal_to<COutPoint>, bulk_pool::Allocator<std::pair<const COutPoint, CCoinsCacheEntry>>> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n@@ -215,10 +216,11 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable bulk_pool::Pool cacheCoinsPool{};\n+    mutable CCoinsMap cacheCoins{0, CCoinsMap::hasher{}, CCoinsMap::key_equal{}, CCoinsMap::allocator_type{&cacheCoinsPool}};\n \n     /* Cached dynamic memory usage for the inner Coin objects. */\n-    mutable size_t cachedCoinsUsage;\n+    mutable size_t cachedCoinsUsage{0};\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);"
      },
      {
        "sha": "38ad0b5e54b7554b8957ed5be541c909fcdd5aa2",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -159,8 +159,8 @@ static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n     return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template<typename X, typename Y, typename Z, typename E, typename A>\n+static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z, E, A>& m)\n {\n     return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }"
      },
      {
        "sha": "7b0a1181cc6a6e3f6c760ac4594834bde7c3ce3d",
        "filename": "src/support/allocators/bulk_pool.h",
        "status": "added",
        "additions": 351,
        "deletions": 0,
        "changes": 351,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/support/allocators/bulk_pool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/support/allocators/bulk_pool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/bulk_pool.h?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -0,0 +1,351 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace bulk_pool {\n+\n+/// This pool allocates one object (memory block) at a time. The first call to allocate determine\n+/// the size of chunks in the pool. Subsequent calls with other types of different size will\n+/// return nullptr. It is designed for use in node-based container like std::unordered_map or\n+/// std::list, where most allocations are for 1 element. It allocates increasingly large blocks\n+/// of memory, and only deallocates at destruction.\n+///\n+/// The size of the allocated blocks are doubled until NUM_CHUNKS_ALLOC_MAX is reached. This way we\n+/// don't have too large an overhead for small pool usage, and still get efficiency for lots of\n+/// elements since number of mallocs() are very reduced. Also, less bookkeeping is necessary, so\n+/// it's more space efficient than allocating one chunk at a time.\n+///\n+/// Deallocate() does not actually free memory, but puts the data into a linked list which can then\n+/// be used for allocate() calls when 1 element is requested. The linked list is in place, reusing\n+/// the memory of the chunks.\n+///\n+/// Memory layout\n+///\n+///  m_blocks\n+///        v\n+///    [ BlockNode, chunk0, chunk1, ... chunk3] // block 0\n+///        v\n+///    [ BlockNode, chunk0, chunk1, ... chunk7] // block 1\n+///        :\n+///    [ BlockNode, chunk0, chunk1, ... chunk16383] // block 12\n+///        v\n+///    [ BlockNode, chunk0, chunk1, ... chunk16383] // block 13\n+///        v\n+///      nullptr\n+///\n+/// m_free_chunks represents a singly linked list of all T's that have been deallocated.\n+class Pool\n+{\n+public:\n+    // Inplace linked list of all allocated blocks. Make sure it is aligned in such a way that whatever comes\n+    // after a BlockNode is correctly aligned.\n+    struct alignas(alignof(::max_align_t)) BlockNode {\n+        // make sure to align\n+        BlockNode* next;\n+    };\n+\n+    // Inplace linked list of the allocation chunks\n+    struct ChunkNode {\n+        ChunkNode* next;\n+    };\n+\n+    /// Explicitly specify the Pool's chunk size. It will only allocate chunks of this size, returning\n+    /// nullptr if a type of different size is specified. If set to 0, the first Allocate() call will\n+    /// determine the chunk size of the pool.\n+    explicit Pool(size_t chunk_size) noexcept\n+        : m_chunk_size(chunk_size)\n+    {\n+    }\n+\n+    /// Doesn't specify the chunk size, so it's determined by the first call to Allocate.\n+    Pool() = default;\n+\n+    // Don't allow moving/copying a pool, it's dangerous\n+    Pool(Pool&&) = delete;\n+    Pool& operator=(Pool&&) = delete;\n+    Pool(const Pool&) = delete;\n+    Pool& operator=(const Pool&) = delete;\n+\n+    /// Deallocates all allocated memory, even when Deallocate() was not yet called.\n+    ~Pool() noexcept\n+    {\n+        Destroy();\n+    }\n+\n+    /// Don't allow allocation for types that are smaller than a Node. This does not make sense\n+    /// because we need to fit a pointer into the memory.\n+    /// We return nullptr instead of producing a compile error so bulk_pool::Allocator<T>::allocate(size_t n)\n+    /// does not need any special handling.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(ChunkNode), int>::type = 0>\n+    T* Allocate() noexcept\n+    {\n+        return nullptr;\n+    }\n+\n+    /// As with Allocate(), don't allow for types that are smaller than a Node.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(ChunkNode), int>::type = 0>\n+    bool Deallocate() noexcept\n+    {\n+        return false;\n+    }\n+\n+    /// Tries to allocate one T. If allocation is not possible, returns nullptr and the callee\n+    /// has to do something else to get memory. First caller decides the size of the pool's data.\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(ChunkNode), int>::type = 0>\n+    T* Allocate()\n+    {\n+        if (m_chunk_size == 0) {\n+            // allocator not yet used, so this type determines the size.\n+            m_chunk_size = sizeof(T);\n+        } else if (m_chunk_size != sizeof(T)) {\n+            // allocator's size does not match sizeof(T), don't allocate.\n+            return nullptr;\n+        }\n+\n+        // Make sure we have memory available\n+        if (m_free_chunks == nullptr) {\n+            AllocateAndCreateFreelist();\n+        }\n+\n+        // pop one element from the linked list, returning previous head\n+        auto old_head = m_free_chunks;\n+        m_free_chunks = old_head->next;\n+        return reinterpret_cast<T*>(old_head);\n+    }\n+\n+    /// Puts p back into the freelist, if it was the correct size. Only allowed with objects\n+    /// that were allocated with this pool!\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(ChunkNode), int>::type = 0>\n+    bool Deallocate(T* p) noexcept\n+    {\n+        if (m_chunk_size != sizeof(T)) {\n+            // allocation didn't happen with this allocator\n+            return false;\n+        }\n+\n+        // put it into the linked list\n+        auto n = reinterpret_cast<ChunkNode*>(p);\n+        n->next = m_free_chunks;\n+        m_free_chunks = n;\n+        return true;\n+    }\n+\n+    /// Deallocates all allocated memory, even when Deallocate() was not yet called. Use with care!\n+    void Destroy() noexcept\n+    {\n+        while (m_blocks != nullptr) {\n+            auto old_head = m_blocks;\n+            m_blocks = m_blocks->next;\n+            ::operator delete(old_head);\n+        }\n+        m_free_chunks = nullptr;\n+    }\n+\n+    /// Counts number of free entries in the freelist. This is an O(n) operation. Mostly for debugging / logging / testing.\n+    size_t NumFreeChunks() const\n+    {\n+        return CountNodes(m_free_chunks);\n+    }\n+\n+    /// Counts number of allocated blocks. This is an O(n) operation. Mostly for debugging / logging / testing.\n+    size_t NumBlocks() const\n+    {\n+        return CountNodes(m_blocks);\n+    }\n+\n+    /// Size per chunk\n+    size_t ChunkSize() const\n+    {\n+        return m_chunk_size;\n+    }\n+\n+private:\n+    //! Minimum number of chunks to allocate for the first block\n+    static constexpr size_t NUM_CHUNKS_ALLOC_MIN = 4;\n+\n+    //! Maximum number of chunks to allocate in one block\n+    static constexpr size_t NUM_CHUNKS_ALLOC_MAX = 16384;\n+\n+    // Counts list length by iterating until nullptr is reached.\n+    template <typename N>\n+    size_t CountNodes(N* node) const\n+    {\n+        size_t length = 0;\n+        while (node != nullptr) {\n+            node = node->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /// Called when no memory is available (m_free_chunks == nullptr).\n+    void AllocateAndCreateFreelist()\n+    {\n+        auto num_chunks = CalcNumChunksToAlloc();\n+        auto data = ::operator new(sizeof(BlockNode) + m_chunk_size * num_chunks);\n+\n+        // link block into blocklist\n+        auto block = reinterpret_cast<BlockNode*>(data);\n+        block->next = m_blocks;\n+        m_blocks = block;\n+\n+        m_free_chunks = MakeFreelist(block, num_chunks);\n+    }\n+\n+    /// Doubles number of elements to alloc until max is reached.\n+    size_t CalcNumChunksToAlloc() noexcept\n+    {\n+        if (m_num_chunks_alloc >= NUM_CHUNKS_ALLOC_MAX) {\n+            return NUM_CHUNKS_ALLOC_MAX;\n+        }\n+        auto prev = m_num_chunks_alloc;\n+        m_num_chunks_alloc *= 2;\n+        return prev;\n+    }\n+\n+    /// Integrates a previously allocated block of memory (where n > 1) into the linked list\n+    ChunkNode* MakeFreelist(BlockNode* block, const size_t num_elements) noexcept\n+    {\n+        // skip BlockNode to get to the chunks\n+        auto const data = reinterpret_cast<char*>(block + 1);\n+\n+        // interlink all chunks\n+        for (size_t i = 0; i < num_elements; ++i) {\n+            reinterpret_cast<ChunkNode*>(data + i * m_chunk_size)->next = reinterpret_cast<ChunkNode*>(data + (i + 1) * m_chunk_size);\n+        }\n+\n+        // last one points nullptr\n+        reinterpret_cast<ChunkNode*>(data + (num_elements - 1) * m_chunk_size)->next = nullptr;\n+        return reinterpret_cast<ChunkNode*>(data);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    ChunkNode* m_free_chunks{nullptr};\n+\n+    //! A single linked list of all allocated blocks of memory, used to free the data in the destructor.\n+    BlockNode* m_blocks{nullptr};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.\n+    size_t m_chunk_size{0};\n+\n+    //! Number of elements to allocate in bulk. Doubles each time, until m_max_num_allocs is reached.\n+    size_t m_num_chunks_alloc{NUM_CHUNKS_ALLOC_MIN};\n+};\n+\n+/// Allocator that's usable for node-based containers like std::unorderd_map or std::list. It requires a Pool\n+/// which will be used for allocations of n==1. The pool's memory is only actually freed when the pool's\n+/// destructor is called, otherwise previously allocated memory will be put back into the pool for further use.\n+///\n+/// Be aware that this allocator assumes that the containers will call allocate(1) to allocate nodes, otherwise\n+/// the pool won't be used. Also, it assumes that the *first* call to allocate(1) is done with the actual node\n+/// size. Only subsequent allocate(1) calls with the same sizeof(T) will make use of the allocator.\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    //! Note: when two containers a and b have different pools and a=b is called, we replace a's allocator with b's.\n+    using propagate_on_container_copy_assignment = std::true_type;\n+    using propagate_on_container_move_assignment = std::true_type;\n+    using propagate_on_container_swap = std::true_type;\n+    using pointer = T*;\n+    using const_pointer = const T*;\n+    using reference = T&;\n+    using const_reference = const T&;\n+    using size_type = size_t;\n+    using difference_type = std::ptrdiff_t;\n+\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U>;\n+    };\n+\n+    explicit Allocator(Pool* pool) noexcept\n+        : m_pool(pool)\n+    {\n+    }\n+\n+    /// Conversion constructor, all Allocators use the same pool.\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_pool(other.m_pool)\n+    {\n+    }\n+\n+    /// Allocates n entries. When n==1, the pool is used. The pool might return nullptr if sizeof(T)\n+    /// does not match the pool's chunk size. In that case, we fall back to new().\n+    /// This method should be kept short so it's easily inlineable.\n+    T* allocate(size_t n)\n+    {\n+        if (n == 1) {\n+            auto r = m_pool->Allocate<T>();\n+            if (r != nullptr) {\n+                return r;\n+            }\n+        }\n+        return reinterpret_cast<T*>(::operator new(n * sizeof(T)));\n+    }\n+\n+    /// If n==1, we might have gotten the object from the pool. This is not the case when sizeof(T) does\n+    /// not match the pool's chunk size. In that case, we fall back to delete().\n+    void deallocate(T* p, std::size_t n)\n+    {\n+        if (n == 1 && m_pool->Deallocate(p)) {\n+            return;\n+        }\n+        ::operator delete(p);\n+    }\n+\n+    /// According to the standard, destroy() is an optional Allocator requirement since C++11.\n+    /// It seems only g++4.8 requires that this method is present, that's why it is here. It\n+    /// is deprecated in C++17 and removed in C++20.\n+    ///\n+    /// Calls p->~U().\n+    /// see https://en.cppreference.com/w/cpp/memory/allocator/destroy\n+    template <typename U>\n+    void destroy(U* p)\n+    {\n+        p->~U();\n+    }\n+\n+    template <class U, class... Args>\n+    void construct(U* p, Args&&... args)\n+    {\n+        ::new ((void*)p) U(std::forward<Args>(args)...);\n+    }\n+\n+private:\n+    Pool* m_pool;\n+};\n+\n+/// Since Allocator is stateful, comparison with another one only returns true if it uses the same pool.\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return a.m_pool == b.m_pool;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+} // namespace bulk_pool\n+\n+#endif // BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H"
      },
      {
        "sha": "ab8d7bb247aa6d76e9cfddc15e9af2e92e5146e7",
        "filename": "src/test/bulk_pool_tests.cpp",
        "status": "added",
        "additions": 136,
        "deletions": 0,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/test/bulk_pool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/test/bulk_pool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bulk_pool_tests.cpp?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -0,0 +1,136 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/bulk_pool.h>\n+\n+#include <test/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(bulk_pool_tests, BasicTestingSetup)\n+\n+void check(const bulk_pool::Pool& pool, size_t chunk_size, size_t num_free_chunks, size_t num_blocks)\n+{\n+    BOOST_CHECK_EQUAL(chunk_size, pool.ChunkSize());\n+    BOOST_CHECK_EQUAL(num_free_chunks, pool.NumFreeChunks());\n+    BOOST_CHECK_EQUAL(num_blocks, pool.NumBlocks());\n+}\n+\n+BOOST_AUTO_TEST_CASE(specified_size)\n+{\n+    auto constexpr s = sizeof(std::string);\n+    bulk_pool::Pool pool(s);\n+    check(pool, s, 0, 0);\n+\n+    // can't allocate something of the wrong size\n+    BOOST_CHECK(nullptr == pool.Allocate<int>());\n+    check(pool, s, 0, 0);\n+\n+    std::string* data = pool.Allocate<std::string>();\n+    BOOST_CHECK(nullptr != data);\n+    // Block of 4 chunks allocated, one is returned => 3 remaining free\n+    check(pool, s, 3, 1);\n+\n+    pool.Deallocate(data);\n+    check(pool, s, 4, 1);\n+\n+    BOOST_CHECK(nullptr != pool.Allocate<std::string>());\n+    check(pool, s, 3, 1);\n+    BOOST_CHECK(nullptr != pool.Allocate<std::string>());\n+    check(pool, s, 2, 1);\n+    BOOST_CHECK(nullptr != pool.Allocate<std::string>());\n+    check(pool, s, 1, 1);\n+    BOOST_CHECK(nullptr != pool.Allocate<std::string>());\n+    check(pool, s, 0, 1);\n+    // another block of 8 chunks is allocated, and one returned\n+    BOOST_CHECK(nullptr != pool.Allocate<std::string>());\n+    check(pool, s, 7, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    bulk_pool::Pool pool;\n+    BOOST_CHECK(nullptr == pool.Allocate<char>());\n+    check(pool, 0, 0, 0);\n+\n+    BOOST_CHECK(nullptr != pool.Allocate<void*>());\n+    check(pool, sizeof(void*), 3, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, bulk_pool::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    bulk_pool::Pool pool;\n+    Map m(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&pool});\n+    size_t num_free_chunks = 0;\n+    {\n+        Map a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&pool});\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = pool.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            Map b = a;\n+        }\n+\n+        BOOST_CHECK(pool.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = pool.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            Map b = a;\n+        }\n+        BOOST_CHECK_EQUAL(pool.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(pool.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(pool.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Map(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&pool});\n+\n+    // now we got everything free\n+    BOOST_CHECK(pool.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map_different_pool)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, bulk_pool::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    bulk_pool::Pool pool_a;\n+    bulk_pool::Pool pool_b;\n+\n+    Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&pool_a});\n+    Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&pool_b});\n+\n+    for (int i = 0; i < 100; ++i) {\n+        map_a[i] = i;\n+        map_b[i] = i;\n+    }\n+\n+    // all the same, so far.\n+    BOOST_CHECK_EQUAL(pool_a.NumFreeChunks(), pool_b.NumFreeChunks());\n+    map_a = map_b;\n+    // note that map_a now uses pool_b, since propagate_on_container_copy_assignment is std::true_type!\n+    // pool_a is not needed any more and can be destroyed.\n+    pool_a.Destroy();\n+\n+    // add some more data to a, should be fine\n+    for (int i = 100; i < 200; ++i) {\n+        map_a[i] = i;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "170e9d7554f5ef291e155de15863f980b1d3ff1b",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ada87348dbaa963490547b342ce57b4249987e/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ada87348dbaa963490547b342ce57b4249987e/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=54ada87348dbaa963490547b342ce57b4249987e",
        "patch": "@@ -592,7 +592,8 @@ void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n \n void WriteCoinsViewEntry(CCoinsView& view, CAmount value, char flags)\n {\n-    CCoinsMap map;\n+    bulk_pool::Pool pool;\n+    CCoinsMap map(0, CCoinsMap::hasher{}, CCoinsMap::key_equal{}, CCoinsMap::allocator_type{&pool});\n     InsertCoinsMapEntry(map, value, flags);\n     BOOST_CHECK(view.BatchWrite(map, {}));\n }"
      }
    ]
  }
]