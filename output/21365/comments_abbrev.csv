DrahtBot,2021-03-04 23:19:30,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #22166 (Add support for inferring tr() descriptors by sipa)\n* #21702 (Implement BIP-119 Validation (CheckTemplateVerify) ",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-791023366,791023366,
sipa,2021-03-06 03:17:10,"Rebased on top of #21246, renamed ""inner key"" everywhere in this PR to ""internal key"" as well, and added very basic PSBT support (you can have a watchonly tr(KEY) wallet now, and get it signed by an offline version that has the private key).",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-791851695,791851695,
Sjors,2021-03-07 18:34:01,Concept ACK üéâ,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-792330093,792330093,
roconnor-blockstream,2021-03-08 14:32:08,"TBH, I find your ""must be specified in depth-first search order"" somewhat confusing.  As an alternative syntax I suggest simply using some notation for a binary or.  For example.\n\n*  `tr(KEY)`: only taproot output key known (or is it an internal pubkey with common NUMS tweak??)\n*  `tr(KEY,A)`: internal pubkey with a single script `A` at level 0.\n*  `tr(KEY,[A|B])`: internal pubkey with a t",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-792794101,792794101,
sipa,2021-03-08 18:17:31,"@roconnor-blockstream Yeah, I considered something like that, and am open to it. Both notations are equivalent in that you can fairly easily convert in both directions between them (counting bracing level in yours corresponds to the depth specified explicitly in mine, with leaves ultimately listed in the same order). The advantage I see to the current one is that I think it's a bit more readable, ",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-792966574,792966574,
roconnor-blockstream,2021-03-08 18:25:57,"Right.  My concern with explicit levels is that it is so easy to violate the invariant that the sum of the weights has to add up to 1, and you cannot really splice together subexpressions to compose a descriptor from fragments without going through and globally adjusting all the levels to be sane.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-792972451,792972451,
roconnor-blockstream,2021-03-08 19:44:37,Additionally I understand that it is the case that checking that the weights add up to 1 is not a sufficient condition to check that a string is a well-formed descriptor as it doesn't imply that the arrangement is in some DFS order. Thus I argue that my proposed scheme is better because the well-formedness of the descriptor format is a relatively simple syntactic check (that would pass [LANGSEC](h,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-793024177,793024177,
JeremyRubin,2021-03-08 19:50:10,"+1 @roconnor-blockstream  a bracketed version seems superior to me.\n\nSome BIP-level (assuming this would eventually become a BIP) thoughts on things that might be useful in a descriptor:\n\n1. it might make sense to have a node that's a Need-To-Know-Basis Subtree. N2KBS have some danger -- e.g., could be hiding a backdoor key -- but also can be used to simplify a descriptor for e.g. inter-op",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-793027851,793027851,
sipa,2021-03-08 20:01:31,"@JeremyRubin I agree that there is a potential use for omitted subtrees, but I don't think there is much of a difference between the two approaches there? In the current approach you'd just specify the Merkle root of the omitted subtree as a ""leaf"" at the depth that root exists at.\n\nAll the other things you mention seem to be things for a policy language that get compiled to descriptors rather",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-793035079,793035079,
JeremyRubin,2021-03-08 20:49:25,"I think it just depends on what descriptors are for v.s. what people end up using them for. Of that I am unsure, but it's worthwhile to note that this is a human readable format so presumably at some point a human may look at it or want to edit it.\n\nw.r.t. annotations for ""descriptor blinding"", I actually think this is somewhat relevant. One could imagine a scenario where a branch is used both",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-793066597,793066597,
sipa,2021-03-09 02:55:19,"@JeremyRubin @roconnor-blockstream Added a commit to switch to ""tr(KEY,{S,{{S,S},S}})"" notation. I prefer {} over [] because the latter is already in use for key origin information.\n\n",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-793300643,793300643,
JeremyRubin,2021-03-09 18:57:38,"Thanks!\n\nIs there any reason not to use parens ()? NEWICK compatibility would be fun.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-794307878,794307878,
sipa,2021-03-12 00:27:31,"Switched to the `tr(KEY,{{S1,S2},{{...)` style descriptors.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-797147204,797147204,
Sjors,2021-03-12 08:24:33,"> Switched to the `tr(KEY,{{S1,S2},{{...)` style descriptors.\n\nCan you clarify this, maybe with a simple example, in the PR description or in [descriptors.md](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)?",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-797321617,797321617,
sipa,2021-03-12 09:23:18,"@Sjors Rebased, and\n\n> Can you clarify this, maybe with a simple example, in the PR description or in descriptors.md?\n\ndone.\n",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-797357641,797357641,
DrahtBot,2021-03-15 16:49:10,<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nüïµÔ∏è @achow101 @harding have been requested to review this pull request as specified in the REVIEWERS file.,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-799573948,799573948,
sipa,2021-03-30 01:20:13,Rebased.,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-809832324,809832324,
Sjors,2021-04-01 15:24:38,"I created a descriptor like so, to test scriptpath spending: `tr(tpub1/0/*,pk(tprv2/0/*))`. This way the wallet won't have private keys for the keypath spend (`tpub1`), so it has to use the script `pk(tprv2/0*)`.\n\nThis seems to work on Signet, but the transaction does not enter the mempool. `testmempoolaccept` complains `min relay fee not met`, so perhaps there's a fee calculation bug? Once I ",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-811983881,811983881,
sipa,2021-04-01 17:05:10,"@Sjors That's expected, and I don't really know how to deal with this. The problem is that we determine the fee for spending an output by using the dummy signer, but the dummy signer can't know which private keys will and won't be available. Since tr spending cost differs based on what is available, this will give an inaccurate result (it'll always just use the key path).\n\nA possibility is ext",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-812045689,812045689,
Sjors,2021-04-01 20:43:15,"This is definitely a new can of worms that will need some thought, but I agree it can wait (if documented).\n\nThe main point of having leaves is to be able to spend when the main keypath key material isn't available. But we currently have no way of indicating that.\n\nI don't think descriptors are the right place for this. Let's say I have 3 hardware wallets. The keypath is a 3-of-3 musig, an",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-812161062,812161062,
fjahr,2021-04-02 11:43:55,Concept ACK üöÄ ,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-812495291,812495291,
Sjors,2021-04-20 16:52:42,All prerequisites have been merged! Needs rebase.,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-823442160,823442160,
sipa,2021-05-21 20:41:57,"Rebased, and addressed comments.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-846248695,846248695,
MarcoFalke,2021-05-22 05:32:40,"```\n node0 stderr bitcoin-node: script/interpreter.cpp:1714: virtual bool GenericTransactionSignatureChecker<CMutableTransaction>::CheckSchnorrSignature(Span<const unsigned char>, Span<const unsigned char>, SigVersion, const ScriptExecutionData &, ScriptError *) const [T = CMutableTransaction]: Assertion `this->txdata' failed. ",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-846353760,846353760,
sipa,2021-05-24 02:03:02,"Fixed the bug referred to [here](https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-846353760) by @MarcoFalke, and addressed most of @Sjors's comments.\n\nNote: if this is too much, it'd be totally reasonable to split this PR in two, splitting after ""Add tr() descriptor (derivation only, no signing)"". Everything up to there is preparation & descriptor derivation. Everything after is sign",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-846681079,846681079,
Sjors,2021-05-24 10:24:30,"Being able to make watch-only taproot wallet seems like a nice natural point to split this PR.\n\ntACK up to c08bb8badb8ab030590fe1bea160078785ecdafe\n\nIn order to test descriptors with script paths, without having signing code, it would be useful to expand `getaddressinfo` and have it show the TREE of scripts.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-846945215,846945215,
sipa,2021-05-24 22:09:45,I split off the derivation part in #22051.,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-847383955,847383955,
sipa,2021-06-03 20:36:54,Rebased after #22051 merge.,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-854161735,854161735,
achow101,2021-06-07 19:38:56,"Since #22166 uses ""Add TaprootSpendData data structure, equivalent to script map for P2[W]SH"" from here but with scripts as a multimap, in the interest of reducing future merge conflicts, I think this PR should use the same commit and use the multimap too. I expect that the change to using a multimap might cause some problems with the later commits in this PR.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-856204356,856204356,
sipa,2021-06-08 00:03:07,"Addressed most of your comments, and also updated the TaprootSpendData commit to use multiset semantics. Instead of using `multiset<key, control_block>`, I've changed it to `map<key, set<control_block>>`, which also has multiset semantics that should be compatible with #22166's inference code, but also with the signing logic in this PR (which should prefer the smallest control block for a given sc",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-856340686,856340686,
achow101,2021-06-08 16:23:58,ACK 4ad2a1d4adfcff715fed3ec37433ffd507c98b84,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-856913344,856913344,
achow101,2021-06-10 18:50:06,re-ACK c69ad7e8097fb6a6cfdd28f135e666ba40405b61,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-858905808,858905808,
sipa,2021-06-12 20:47:37,Rebased.,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-860106658,860106658,
achow101,2021-06-14 19:24:55,re-ACK 458a345b0590fd2fa04c7d8d70beb8d57e34bbc8,https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-860934199,860934199,
Sjors,2021-06-16 09:30:15,"I'll try to review this today. Having this feature in the signet / testnet wallet makes it easier for people to test taproot before it activates, and potentially find problems (bugs, many eyes, shallow, etc). So it seems worth merging even slightly after the feature freeze.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-862205352,862205352,
michaelfolkson,2021-06-16 14:38:28,"Concept ACK, Approach ACK. Updated syntax choice makes sense to me under the readability assumption that use cases that need more than say 2 levels will be rarer. Ignoring readability, the updated syntax choice seems superior due to arguments given.\n\nAgree with @Sjors on importance of getting this in for 22.0. Two weeks for any bug fixes from today should be ok and protections in place (e.g. h",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-862437201,862437201,
Sjors,2021-06-16 20:08:54,"Very light testing using this PR rebased onto #22260: I'm still able to spend from my `tr(xpub...)` and `tr(xpub1, pk(xpub2))` signet descriptor wallets in the GUI.",https://github.com/bitcoin/bitcoin/pull/21365#issuecomment-862678656,862678656,
JeremyRubin,2021-03-09 19:12:11,"don't we need to trace what type we are in if it is a paren or a {? \n\nE.g., `(}` would pass here no?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590646545,590646545,src/util/spanparsing.cpp
sipa,2021-03-09 19:13:36,"That doesn't matter. This function is just for finding the end of the current expression. If that expression is unbalanced, the actual parsing code will fail.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590647440,590647440,src/util/spanparsing.cpp
JeremyRubin,2021-03-09 20:22:57,"I see. \n\nbikeshed:\nI think something like this could be a little clearer:\n\n```c++\n// This function finds the end of the current expression and returns pair(expr_span, rest_span)\n// trailing comma is included in the expr_span, e.g.\n// `<expr A>,<expr B>` would return `<expr A>,` `<expr B>` \nstd::pair<Span<const char>, Span<const char>> Expr(const Span<const char>& sp)\n{\n    si",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590692235,590692235,src/util/spanparsing.cpp
JeremyRubin,2021-03-09 20:29:56,"you could directly emplace_back the subdesc and then nullcheck/return nullptr, rather than needing to std::move it.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590696727,590696727,src/script/descriptor.cpp
JeremyRubin,2021-03-09 20:36:30,"Behavior Note:\n\nI believe this would be more robust to go before the while loop -- it shouldn't come up, because we're in a binary tree maybe -- but it would be better to explicitly check:\n```c++\nif (counts.size() && counts.back() == false) \n```\nor something like\n```c++\nif (counts.size() && counts.back() <= 2)\n```\n\nif we want to limit how many terms in a nest are allowed.\n",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590700864,590700864,src/script/descriptor.cpp
JeremyRubin,2021-03-09 20:46:40,"given that this is just iterating in order, it seems like we should be able to directly feed the TaprootBuilder from the tr parsing code and do away with the intermediate vectors?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590707050,590707050,src/script/descriptor.cpp
sipa,2021-03-09 20:47:54,"No, unfortunately this happens at a different layers. TaprootBuilder can only be invoked with concrete keys; those don't exist yet at parsing time.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590707883,590707883,src/script/descriptor.cpp
JeremyRubin,2021-03-09 20:52:03,"I see :(\n\nI guess I'll mark it as a personal todo (no need to upset a working internal representation) to brainstorm if there's a more obvious way to represent the tree than the ordered depth annotations (even though it's equivalent and unambiguous, I still find it unintuitive)",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590710550,590710550,src/script/descriptor.cpp
sipa,2021-03-09 21:05:25,"I like linear data structures that don't need recursion to process, when unnecessary.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590718707,590718707,src/script/descriptor.cpp
JeremyRubin,2021-03-10 00:41:34,"Yeah, I agree with that 100%. What I was thinking was a vec<uint128> where each bit represents a left/right on the tree. That way you can do a de-duplicate check to make sure each node is only occupied once. Then the order of the vec itself is no longer significant; it should not need to be preserved because you can sort them by value (if I'm not wrong) to get the insertion order. Depth could be c",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590870801,590870801,src/script/descriptor.cpp
JeremyRubin,2021-03-10 01:08:42,"@roconnor-blockstream may also like that this format should be:\n1. concatenative, where concat has operations that are O(n)\n    - merge sort then either deduplicate check or run through and add an appropriate offset to branches\n 2.  ""normalizable"" (shifting things down to the smallest next number) and ""prefixable"" (adding a constant to all numbers to preserve structure.\n ",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590889090,590889090,src/script/descriptor.cpp
sipa,2021-03-10 01:14:59,"Why do the properties of this internal, temporary, data structure that purely used during the construction of a scriptPubKey matter? It does what it is supposed to do. If we ever need other operations on it, something else can be considered.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r590892912,590892912,src/script/descriptor.cpp
JeremyRubin,2021-03-10 06:54:15,"I find the code really hard to understand. Conceivably if we want people to review/audit it, a conceptually simpler representation & set of algorithms should be easier to understand? The above suggestion may or may not be it, but I haven't been able to fully work out how the algorithms this PR is currently using work even after staring at them for a bit.\n\nthe properties matter less.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r591123497,591123497,src/script/descriptor.cpp
sipa,2021-03-10 07:12:49,I'll try to add more comments.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r591138116,591138116,src/script/descriptor.cpp
fanquake,2021-03-11 05:48:46,nit: in d5a0dce8fe40153b07ec6e882e8b1568b05e3905: we can use `std::make_unique` in new code.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r592082640,592082640,src/script/descriptor.cpp
sipa,2021-03-11 21:34:35,That's how the current span-based parsing works. I think discussions about improvements to that are interesting but out of scope for this PR.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r592738143,592738143,src/util/spanparsing.cpp
sipa,2021-03-12 00:26:15,"I've restructured things a bit, and added a bunch of comments. Does this look better?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r592825162,592825162,src/script/descriptor.cpp
sipa,2021-03-12 00:26:42,Added a big comment explaining the data structure in script/standard.h. WDYT?,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r592825332,592825332,src/script/descriptor.cpp
sipa,2021-03-12 00:26:48,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r592825367,592825367,src/script/descriptor.cpp
sipa,2021-03-12 00:27:43,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r592825770,592825770,src/script/descriptor.cpp
Sjors,2021-03-12 09:49:27,"So this means you can do, `tr(KEY,{A})`, `tr(KEY,{A,B})`, `tr(KEY,{A,{B,C}})`, etc? So a `TREE` must have two elements, unless it's at the top?\n\nMaybe also point out that some taproot features have yet to be implemented, so the only script you can put in a `TREE` element is `pk(KEY)`.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r593043201,593043201,doc/descriptors.md
sipa,2021-03-12 16:46:05,"No, `{A}` is not a valid TREE. `A` is.\n\nSo you'd use `tr(KEY,A)` but `tr(KEY,{A,B})`. There is nothing special about the top level.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r593313134,593313134,doc/descriptors.md
achow101,2021-03-15 21:25:58,"In commit 8aaa61bfb7590e95eb7ca5106dfe3561f1c7a7c8 ""Add tr() descriptor (derivation only, no signing)""\n\nThis looks like the original syntax and not the syntax with the braces.\n\nSince this function is used as part of writing the descriptor to the wallet, any wallet containing a descriptor with scripts will currently have an invalid descriptor and cannot be loaded again.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r594694587,594694587,src/script/descriptor.cpp
achow101,2021-03-15 21:27:45,"In commit 8aaa61bfb7590e95eb7ca5106dfe3561f1c7a7c8 ""Add tr() descriptor (derivation only, no signing)""\n\nI think it would be better to default `xonly = false` so that existing callers don't need to change, and this is kind of what is expected for this descriptor. Then nested taproot things can set `xonly` as they need.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r594695684,594695684,src/script/descriptor.cpp
achow101,2021-03-15 22:11:14,"In 1d3cc29fb86b614b76b4d97a5adab7f903fc3020 ""Construct and use PrecomputedTransactionData in PSBT signing""\n\nWe should avoid iterating all of the PSBT inputs again when we are signing each input. Instead we should compute the `PrecomputedTransactionData` in the caller and pass that into `SignPSBTInput`.\n\nThis can be done in `CWallet::FillPSBT` where we are iterating the inputs anyways to ge",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r594718159,594718159,src/psbt.cpp
sipa,2021-03-16 06:02:20,"Nice catch. Fixed, and added tests for roundtrippability of the descriptors.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r594882760,594882760,src/script/descriptor.cpp
sipa,2021-03-16 18:29:21,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r595438349,595438349,src/script/descriptor.cpp
sipa,2021-03-16 22:48:03,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r595592405,595592405,src/psbt.cpp
S3RK,2021-04-19 07:45:37,"IIUC the key in the map is output key, but it's not immediately obvious. Maybe add a comment here and for `GetTaprootSpendData`?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r615614539,615614539,src/script/signingprovider.h
S3RK,2021-04-21 07:29:30,"Is this just an assignment? We don't need to merge here, do we? ",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r617269496,617269496,src/script/descriptor.cpp
S3RK,2021-04-21 07:30:40,What about the case with unspendable internal key?,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r617270330,617270330,src/script/descriptor.cpp
MarcoFalke,2021-04-22 14:35:56,"in commit b6f6c58ef7e64f699102beef063b3b9f91c71ecd:\n\nCould use `decltype(m_keydata)::size()` for self-documenting code?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r618460734,618460734,src/pubkey.h
fjahr,2021-05-02 20:39:12,"in 3f6aad2d687b5435e93bf6c99cbe1cabc9c1ff16:\n\nProbably should be `tr(KEY)` instead of `tr(XKEY)`.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r624751898,624751898,doc/descriptors.md
fjahr,2021-05-02 22:52:50,"in 474536660d:\n\nMay as well skip this `for` loop altogether if `force` is true, if I see that correctly.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r624793048,624793048,src/script/interpreter.cpp
sipa,2021-05-21 20:41:29,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637221548,637221548,src/pubkey.h
sipa,2021-05-21 20:41:37,Fixed.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637221616,637221616,doc/descriptors.md
sipa,2021-05-21 20:41:46,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637221704,637221704,src/script/interpreter.cpp
Sjors,2021-05-22 14:04:31,a2edabe43261ef2859742015a53c34ee8a5d1ee3  This along with the corresponding changes in `pubkey.h` might be worth a separate commit.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637407995,637407995,src/uint256.h
Sjors,2021-05-22 14:07:58,a2edabe43261ef2859742015a53c34ee8a5d1ee3 shouldn't we keep `WitnessUnknown` at the end? That would also keep it consistent with the ordering in e.g. `descriptor.cpp`.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637408318,637408318,src/script/standard.h
Sjors,2021-05-22 14:15:19,"This raises the question: why are we putting the witness version in `vSolutions`? That seems to have been copied from `WITNESS_UNKNOWN` handling, whereas we don't do it for SegWit v0.\n\nhttps://github.com/bitcoin/bitcoin/blob/be4171679b8eab8205e04ff86140329bd67878a0/src/script/standard.cpp#L161-L174\n\nI don't see an explanation in e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6 (I might have missed",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637409202,637409202,src/script/standard.cpp
Sjors,2021-05-22 17:20:21,"f86a68c0b1a6ed9e0c7e6f0ee81989a6129abe30: as an additional sanity check, you could generate the same same address in `feature_taproot.py`",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637428638,637428638,src/test/script_standard_tests.cpp
Sjors,2021-05-22 17:26:12,"f86a68c0b1a6ed9e0c7e6f0ee81989a6129abe30: note to other reviewers: this is used in d9d928198be28923d37434a924788b284a4e3760 to sanity check the descriptor parser (and made more sense to me after reviewing the {{A,B},C} parsing code).",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637429207,637429207,src/script/standard.h
Sjors,2021-05-22 18:30:19,"f86a68c0b1a6ed9e0c7e6f0ee81989a6129abe30: what do you mean by ""if desired - leaf information""?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637436352,637436352,src/script/standard.cpp
sipa,2021-05-24 01:42:09,"Done, added commit ""Make XOnlyPubKey act like byte container"".\n",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637638714,637638714,src/uint256.h
sipa,2021-05-24 01:43:12,"I didn't do that because the descriptor code's `GetOutputType` depended on the exact order of elements in this variant. I've addressed that in a new commit ""Avoid dependence on CTxDestination index order"", and then implemented your suggestion of placing WitnessUnknown last.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637638924,637638924,src/script/standard.h
sipa,2021-05-24 01:45:40,"The explanation is just that this was easier, because while `TxoutType` did have a separation between unknown and taproot, CTxDestination did not. Making them both produce {version, program} as `vSolutions` was easier because it allowed handling them identically in `ExtractDestination`.\n\nI've addressed this by first changing the Solver output for taproot outputs to be just {program}, like P2WP",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637639453,637639453,src/script/standard.cpp
sipa,2021-05-24 01:46:16,"That comment didn't make sense in the commit where it was in. I've moved it, and made it a bit clearer.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637639590,637639590,src/script/standard.cpp
sipa,2021-05-24 01:58:34,Marking this as resolved. Feel free to comment if the result still isn't clear.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r637642539,637642539,src/script/descriptor.cpp
sipa,2021-06-03 20:54:28,"`wallet_taproot.py` already tests address derivation against the python implementation (which is also used by `feature_taproot.py`, so I think that's unnecessary.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r645118943,645118943,src/test/script_standard_tests.cpp
achow101,2021-06-07 18:18:36,"In e4c8ae471d38e878a69fa8099d75d447319f4037 ""Add TaprootSpendData data structure, equivalent to script map for P2[W]SH""\n\nSince we are expecting that the `TaprootSpendData` being merged is for the same scriptPubKey, I think this should assert that the `internal_key` and `merkle_root` match if both have them.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646836512,646836512,src/script/standard.cpp
achow101,2021-06-07 18:19:26,"In e4c8ae471d38e878a69fa8099d75d447319f4037 ""Add TaprootSpendData data structure, equivalent to script map for P2[W]SH""\n\nShould this `merkle_root` be guarded with its own `if` instead being combined with the `internal_key`? It looks like in the current usage it doesn't matter, but perhaps in the future it might?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646837025,646837025,src/script/standard.cpp
achow101,2021-06-07 18:22:55,"In e4c8ae471d38e878a69fa8099d75d447319f4037 ""Add TaprootSpendData data structure, equivalent to script map for P2[W]SH""\n\nnit:, extra `*/`\n\n```suggestion\n    bool m_parity;            //!< The tweak parity, computed when finalizing. */\n    bool m_parity;            //!< The tweak parity, computed when finalizing.\n````",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646839157,646839157,src/script/standard.h
achow101,2021-06-07 18:39:23,"In ebf44e081ba0ef7b8810497dee47717bb661cbdb ""Add CKey::SignSchnorr function for BIP 340/341 signing""\n\nWhy not compare the pubkey against the pubkeys specified in the BIP 340 test vectors?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646849541,646849541,src/test/key_tests.cpp
achow101,2021-06-07 18:55:48,"In 8d073d0afe285bd04542907428298d377f49c8f9 ""Construct and use PrecomputedTransactionData in PSBT signing""\n\n`GetInputUTXO` does all of this already, so I think you can just use that instead of reimplementing the utxo fetching. If you need to do the hash checking, it would probably be worthwhile to implement that in `GetInputUTXO` too.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646859980,646859980,src/psbt.cpp
achow101,2021-06-07 18:56:49,"In 8d073d0afe285bd04542907428298d377f49c8f9 ""Construct and use PrecomputedTransactionData in PSBT signing""\n\nThis case shouldn't happen because every input in the tx must have a corresponding `PSBTInput`, even if it is empty. So I think this should be an assert as it would be a bug.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646860636,646860636,src/psbt.cpp
achow101,2021-06-07 19:17:34,"In ea07a01b0cf7256304b17508debf74d94cccdac7 ""Basic Taproot signing logic in script/sign.cpp""\n\nCan you explain what this is doing and why?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646873647,646873647,src/script/sign.cpp
sipa,2021-06-07 22:01:02,"Asserting sounds dangerous, as I'd expect TaprootSpendData to at some point be untrusted data (e.g. gathered from PSBT). I agree it's a bit ugly to just prefer one over the other in case of a contradiction, and I also don't have a better solution. Would you be ok with just a TODO here?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r646970084,646970084,src/script/standard.cpp
sipa,2021-06-07 23:55:49,"It's the equivalent of `SignatureData::signatures`, but for Taproot/Schnorr signatures. They're not indexed by CKeyId, but by full (untweaked) pubkey and leaf they occur in.\n\nThis is redundant for now, as there is no multiparty signing whatsoever, and no way of communicating partial signatures (needs PSBT extension), but this is pretty much what it would look like. I could drop it for this PR.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r647015477,647015477,src/script/sign.cpp
sipa,2021-06-07 23:58:42,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r647016600,647016600,src/script/standard.cpp
sipa,2021-06-07 23:58:51,Done. Also realigned.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r647016744,647016744,src/script/standard.h
sipa,2021-06-07 23:58:59,Done.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r647016857,647016857,src/test/key_tests.cpp
sipa,2021-06-07 23:59:50,Changed to use `GetInputUTXO`. I've added a commit to add the prevout hash check to `GetInputUTXO` itself.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r647017273,647017273,src/psbt.cpp
sipa,2021-06-08 00:03:41,Gone by rewriting.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r647018690,647018690,src/psbt.cpp
sipa,2021-06-09 15:07:31,"Well, not right now.\n\nBut like several things in this PR it's sort of written to accomodate future PSBT extensions that expose some of the TaprootSpendData. And one of the possbilities is only including information about a subset of leaves. In that case, you do want a merge operation when combining.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r648405030,648405030,src/script/descriptor.cpp
sipa,2021-06-09 15:08:28,There is no real difference. An unspendable internal pubkey is just a pubkey with no known private key. You still need to actually select one.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r648405868,648405868,src/script/descriptor.cpp
sipa,2021-06-09 18:54:40,"Done (here using a comment, and in function calls by changing the parameter name to `output_key`).",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r648592068,648592068,src/script/signingprovider.h
S3RK,2021-06-10 07:09:31,"```suggestion\n     * - Otherwise:                key + H_TapTweak(pubkey || *merkle_root)*G\n```",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r648908912,648908912,src/key.h
michaelfolkson,2021-06-10 16:53:24,@S3RK: More details here https://bitcoin.stackexchange.com/questions/99722/taproot-eliminating-key-path,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r649362572,649362572,src/script/descriptor.cpp
fjahr,2021-06-16 21:13:11,nit: this could go before the block with `sigdata.taproot_key_path_sig.size() == 0` to return early and then that other block would not need that other if statement,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653057926,653057926,src/script/sign.cpp
fjahr,2021-06-16 21:41:59,nit: `m_tr_spenddata`?,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653073598,653073598,src/script/signingprovider.h
fjahr,2021-06-16 21:54:53,"nit: reads a bit strange but maybe I am not reading it right. I would write it as ""The merkle_branch field of each are the partners to get to *this* node.""",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653081288,653081288,src/script/standard.h
fjahr,2021-06-16 22:41:44,Why isn't `SIGHASH_DEFAULT` the default here now as well?,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653102623,653102623,src/script/sign.h
fjahr,2021-06-16 23:46:14,"nit: I think this loop could be simplified a little\n\n```suggestion\n    for (CTxIn& txin : mtx.vin) {\n        auto coin = coins.find(txin.prevout);\n        if (coin == coins.end() || coin->second.IsSpent()) {\n            txdata.Init(txConst, {}, true);\n            break;\n        }\n        spent_outputs.emplace_back(CTxOut(coin->second.out.nValue, coin->second.out.scriptPubKey));\",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653125636,653125636,src/script/sign.cpp
fjahr,2021-06-17 00:04:44,As it *is* indexed by,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653131909,653131909,src/script/sign.cpp
Sjors,2021-06-17 15:23:48,"ce9353164bdb6215a62b2b6dcb2121d331796f60: suggest moving `if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.` up to the start of the loop instead.\n\nIn the commit message maybe replace ""just permit precomputing"" with ""just precompute"".",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653671909,653671909,src/script/interpreter.cpp
Sjors,2021-06-17 15:29:50,"Suggested comment:\n```\n// * @param[in]   force   Precompute data for both bip341 taproot and bip143 segwit signatures regardless of the actual inputs.\n```",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653678722,653678722,src/script/interpreter.cpp
S3RK,2021-06-17 20:20:34,"What's the use case for non-tweaked signatures?\n\nnit: The difference between `merkle_root == nullptr` and `merkel_root->IsNull()` is subtle enough that\none might be mistaken, especially when passing the `aux` parameter and not reading the comments closely. Could this be a potential problem in the future?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r653907350,653907350,src/key.h
sipa,2021-06-17 23:28:49,"I tried this for a bit, but I don't find the result cleaner.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654047138,654047138,src/script/sign.cpp
sipa,2021-06-17 23:30:26,"It's a `struct`, not a `class`, so the developer notes don't require that (it's inconsistently applied through the codebase, in some cases using `m_` prefixes for struct members too, but I don't think that's enough reason to do so here).",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654047671,654047671,src/script/signingprovider.h
sipa,2021-06-17 23:42:48,"It's referring to the operation applied to the private key, not the public one.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654051719,654051719,src/key.h
sipa,2021-06-17 23:44:09,"Signatures with OP_CHECKSIG and friends aren't tweaked; only key-path signatures are.\n\nSo we do need both a way to ask for untweaked, and for tweaked with nothing. I agree it's confusing, though we need a way to ask for both. Getting it wrong is exceedingly likely to cause validation failures, though.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654052096,654052096,src/key.h
sipa,2021-06-18 00:48:06,Fixed in https://github.com/bitcoin/bitcoin/pull/22275; just removed the default argument value.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654070835,654070835,src/script/sign.h
sipa,2021-06-18 00:48:16,Done in https://github.com/bitcoin/bitcoin/pull/22275.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654070887,654070887,src/script/sign.cpp
sipa,2021-06-18 00:48:25,Done in https://github.com/bitcoin/bitcoin/pull/22275.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654070937,654070937,src/script/interpreter.cpp
sipa,2021-06-18 00:48:40,Too late.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654071005,654071005,src/script/interpreter.cpp
sipa,2021-06-18 00:48:50,Done in https://github.com/bitcoin/bitcoin/pull/22275.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654071053,654071053,src/script/sign.cpp
sipa,2021-06-18 00:48:59,Done in https://github.com/bitcoin/bitcoin/pull/22275.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654071108,654071108,src/script/standard.h
Sjors,2021-06-18 15:51:37,"Yikes, I missed that subtlety too. In #22275 you could expand the comment bit, e.g.:\n```\n* When merkle_root is nullptr, as distinct from merkle_root->IsNull(), the signature is not tweaked.\n* This is the case for e.g. OP_CHECKSIG in a tapscript.\n* For key-path signatures on the other hand the signature is always tweaked (merkle_root is not nullptr) as follows:\n```",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654535020,654535020,src/key.h
sipa,2021-06-18 20:28:22,Added something like that to https://github.com/bitcoin/bitcoin/pull/22275.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654662347,654662347,src/key.h
sipa,2021-06-18 20:36:49,"Oh, so the the line before is wrong. I see. Added in https://github.com/bitcoin/bitcoin/pull/22275.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r654665547,654665547,src/key.h
hebasto,2021-06-23 10:24:13,"On macOS Mojave 10.14.6 (18G9216) system clang fails to compile this line due to the lack of `std::set::merge` support.\n\n```\n$ clang --version\nApple LLVM version 10.0.1 (clang-1001.0.46.4)\nTarget: x86_64-apple-darwin18.7.0\nThread model: posix\nInstalledDir: /Library/Developer/CommandLineTools/usr/bin\n```\n\nSee: https://stackoverflow.com/questions/50444908/clang-6-not-supporting-u",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r656962860,656962860,src/script/standard.cpp
MarcoFalke,2021-06-23 10:39:02,I presume this would also make it harder to compile on https://packages.debian.org/stretch/gcc,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r656972613,656972613,src/script/standard.cpp
hebasto,2021-06-23 10:48:39,"Since #20413 we support gcc 7+ only, right?",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r656978661,656978661,src/script/standard.cpp
MarcoFalke,2021-06-23 11:47:06,"In theory there is https://packages.debian.org/stretch/clang-7, but I don't think anyone was able to compile master with system packages on stretch recently.",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r657016241,657016241,src/script/standard.cpp
MarcoFalke,2021-06-23 12:23:57,"Confirmed (for fun) that the issue exists with libc++7. \n\n```\n# make V=1\nMaking all in src\nmake[1]: Entering directory '/bitcoin/src'\nmake[2]: Entering directory '/bitcoin/src'\nmake[3]: Entering directory '/bitcoin'\nmake[3]: Leaving directory '/bitcoin'\n/usr/bin/ccache clang++-7 -stdlib=libc++ -std=c++17 -DHAVE_CONFIG_H -I. -I../src/config   -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 ",https://github.com/bitcoin/bitcoin/pull/21365#discussion_r657041711,657041711,src/script/standard.cpp
hebasto,2021-06-25 04:24:23,See #22339.,https://github.com/bitcoin/bitcoin/pull/21365#discussion_r658464328,658464328,src/script/standard.cpp
