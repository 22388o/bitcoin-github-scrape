[
  {
    "sha": "c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMDc5OThjMGQxYTllNzE1ZDIxN2JmN2IzYWY3MzkyZjBiZTlkYmQz",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-16T16:26:25Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-16T16:26:25Z"
      },
      "message": "Add environment option to keep /tmp/ clean\n\nThis avoids the possibility of flooding /tmp during long fuzzing campaigns",
      "tree": {
        "sha": "96a046297483c2e7184748400635c13a4ee17fc8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96a046297483c2e7184748400635c13a4ee17fc8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8bMxCRBK7hj4Ov3rIwAACI0IAGoRbvLF4Z5FHNh4iqFISIx1\nUdoEjxZv1oAb8tTUGm0H6hd/Wjv1t8OCGp+poTrBRJ9YGT5PxM/KnmLlEEZqSs98\nodwH5st28tEDdH/6c11DrHrTYvNfJoJbD+JDCmQ0Ta8nqoPdefqIyuTqRjL2htUp\nx6kASpRA8L2wshUKwYS2LdNhLVZx8G+VD7uPwWoDgjBVKwZCHpwBnMKGwUrYQJrO\nOWFRA9E+JYw6M8HG2YXZ3sYEZGkVoqZob7PC1HjNYT2W+IxDjxNUpxzHdgGDzhnx\nFVvDCmj4mvm5pi0LstlwmAAu3ySaur3bm5EjPxuJBlFVZBu/OtpAjl6V7Cjkr+s=\n=1nZx\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 96a046297483c2e7184748400635c13a4ee17fc8\nparent f8b20fd35b0eb42d28afb302a070e5d9bc21a99f\nauthor Alex Groce <agroce@gmail.com> 1626452785 -0700\ncommitter GitHub <noreply@github.com> 1626452785 -0700\n\nAdd environment option to keep /tmp/ clean\n\nThis avoids the possibility of flooding /tmp during long fuzzing campaigns"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f8b20fd35b0eb42d28afb302a070e5d9bc21a99f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8b20fd35b0eb42d28afb302a070e5d9bc21a99f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f8b20fd35b0eb42d28afb302a070e5d9bc21a99f"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 7,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8e8a6f6887c4ef0e00b97db1cd03ec98ab618b2e",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
        "patch": "@@ -12,6 +12,7 @@\n \n #include <cstdint>\n #include <exception>\n+#include <filesystem>\n #include <memory>\n #include <string>\n #include <unistd.h>\n@@ -127,6 +128,12 @@ int main(int argc, char** argv)\n     }\n     test_one_input(buffer);\n #endif\n+    if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n+        std::error_code errorCode;\n+        if (!std::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", errorCode)) {\n+            std::cout << errorCode.message() << std::endl;\n+        }\n+    }\n     return 0;\n }\n #endif"
      }
    ]
  },
  {
    "sha": "8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZTAzYzQ4YTViZmNiMTEwOGRiMDBlNzQwYTRjMDFmNGU3YjQyOWUy",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-16T21:23:40Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-16T21:23:40Z"
      },
      "message": "Use boost to avoid adding new link",
      "tree": {
        "sha": "d24a344bf1f0f5d7e97edd75417a4a205ad8e565",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d24a344bf1f0f5d7e97edd75417a4a205ad8e565"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8fjcCRBK7hj4Ov3rIwAAQ7IIAIGvLb7dDplFJlczhX2n+1Zu\ngKTYPZ2qw/7NUA3vE+1ygvNHwSQTv+kfUhZswzI9gxDeKwippuoeEJU5f8lRXJZC\nHdzegl7g13MXHC1vm/OUr+g9ONA9Yhq0+cxjwSbcOHa5t9hC1ohFbPP3N1jfx5OG\nJqzT2RRjD7wvGAFu/nSaq6yWqW1zqk8LCExPXoZTwBHPtf3kIguaemYSytPSr9IM\npR6Bbxy7xW59kqvE/f8x9+g12MIDd0CzrZjW0viMow/gGC2e5DYp9YI3tcVRAfid\nTpH/0RcaOQ5QczIMOMlgjhyBPEej5AGzELys99jwy5L1KTcLgRDXXCINyQbzeHM=\n=G2ub\n-----END PGP SIGNATURE-----\n",
        "payload": "tree d24a344bf1f0f5d7e97edd75417a4a205ad8e565\nparent c07998c0d1a9e715d217bf7b3af7392f0be9dbd3\nauthor Alex Groce <agroce@gmail.com> 1626470620 -0700\ncommitter GitHub <noreply@github.com> 1626470620 -0700\n\nUse boost to avoid adding new link"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c07998c0d1a9e715d217bf7b3af7392f0be9dbd3"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "bc28fcce069ec26a0ac55972596b8a9cf3c11cb8",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <test/fuzz/fuzz.h>\n \n+#include <boost/filesystem.hpp>\n #include <netaddress.h>\n #include <netbase.h>\n #include <test/util/setup_common.h>\n@@ -12,7 +13,6 @@\n \n #include <cstdint>\n #include <exception>\n-#include <filesystem>\n #include <memory>\n #include <string>\n #include <unistd.h>\n@@ -130,7 +130,7 @@ int main(int argc, char** argv)\n #endif\n     if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n         std::error_code errorCode;\n-        if (!std::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", errorCode)) {\n+        if (!boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", errorCode)) {\n             std::cout << errorCode.message() << std::endl;\n         }\n     }"
      }
    ]
  },
  {
    "sha": "d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMTNjZTRlODFkOTc5Y2RjNjVmNGEyY2FhZGRjOTExZWZhM2UxYTgy",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-16T21:45:15Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-16T21:45:15Z"
      },
      "message": "Type for 2nd arg to boost::filesystem::remove_all",
      "tree": {
        "sha": "bcd28d9f74f206098b0236f4de3fae6f0285a801",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bcd28d9f74f206098b0236f4de3fae6f0285a801"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8f3rCRBK7hj4Ov3rIwAA5wEIADGnTvAFglFp4WwlohpIaEpK\nquB8FENZ+DSWCiUtVlWoJ1/aQ0IPaY8/qsVzTgPFT43ELphvpJp/aOsPdxbrNefB\nBtQdzLAFamCrP0qYaa3G5nMw3sj1UivfwfwEhqbs3mqVO+ySEhI4HYNpu4YMVPAk\nsxs52J/RRqcEdqFT9KUvWe4SX4rtlfIxnj828J62kzt+jp6kb7MeEQrA68hxaPsj\n7paCJO3xwzbB1PFbFBtHRZ9yGrm6UEhQa3a1paxczA90+HSbApv+1EUZMHLeqpy6\nGnIMGw+bg7KlfPCG5tcnWyr85JDqMLW8/YFWC0GiTpvv5cABiQDMMU3+iu39zoo=\n=pI0B\n-----END PGP SIGNATURE-----\n",
        "payload": "tree bcd28d9f74f206098b0236f4de3fae6f0285a801\nparent 8e03c48a5bfcb1108db00e740a4c01f4e7b429e2\nauthor Alex Groce <agroce@gmail.com> 1626471915 -0700\ncommitter GitHub <noreply@github.com> 1626471915 -0700\n\nType for 2nd arg to boost::filesystem::remove_all"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8e03c48a5bfcb1108db00e740a4c01f4e7b429e2"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "98e775849f349ab9d8eb6b99107c4d3b4add1ed1",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
        "patch": "@@ -129,9 +129,9 @@ int main(int argc, char** argv)\n     test_one_input(buffer);\n #endif\n     if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n-        std::error_code errorCode;\n-        if (!boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", errorCode)) {\n-            std::cout << errorCode.message() << std::endl;\n+        system::error_code ec;;\n+        if (!boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", ec)) {\n+            std::cout << ec << std::endl;\n         }\n     }\n     return 0;"
      }
    ]
  },
  {
    "sha": "35323b08d3a2b75a0e8481b6fc8de3817232b024",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTMyM2IwOGQzYTJiNzVhMGU4NDgxYjZmYzhkZTM4MTcyMzJiMDI0",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-16T21:48:28Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-16T21:48:28Z"
      },
      "message": "Remove extra semicolon",
      "tree": {
        "sha": "fd1064c6d50adaa10fa56a5dd1b1ef4054e99891",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fd1064c6d50adaa10fa56a5dd1b1ef4054e99891"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35323b08d3a2b75a0e8481b6fc8de3817232b024",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8f6sCRBK7hj4Ov3rIwAAJkMIAHS/GTYDREt19obFcTUfLJ3M\nbLd3/FDI+7nUyM5lYM90ViBVJdZRok/mN9j9eFRi8ZuC7uiqZEnxirPfSkQeYPEM\nsng0vwrLizo+tCO3C+M3va+wIflrUAMzXFksuuBm3TWp5Kd5TJnPbrxDqnz9ub+3\nBpmZokg4J7StiOcQli8JI/JioOxmB2qN8QRjfRdF4hGgny8cXuMrV9Hud6n75hwh\neEMFI+CYTi7WXvSUvgyonCwwaFRk960UuOuklRp+/EF73nROZlzZmSzehsulKeTj\nSCjITcExreEE1nZc+bFiNuPbmUuoawFyKont72Gb843fL9ZIkXSQgFUuwoJTqXM=\n=vHJu\n-----END PGP SIGNATURE-----\n",
        "payload": "tree fd1064c6d50adaa10fa56a5dd1b1ef4054e99891\nparent d13ce4e81d979cdc65f4a2caaddc911efa3e1a82\nauthor Alex Groce <agroce@gmail.com> 1626472108 -0700\ncommitter GitHub <noreply@github.com> 1626472108 -0700\n\nRemove extra semicolon"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35323b08d3a2b75a0e8481b6fc8de3817232b024",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/35323b08d3a2b75a0e8481b6fc8de3817232b024",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35323b08d3a2b75a0e8481b6fc8de3817232b024/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d13ce4e81d979cdc65f4a2caaddc911efa3e1a82"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "b650b375446f4dc78763cbbe05c767fa665f0ffc",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35323b08d3a2b75a0e8481b6fc8de3817232b024/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35323b08d3a2b75a0e8481b6fc8de3817232b024/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=35323b08d3a2b75a0e8481b6fc8de3817232b024",
        "patch": "@@ -129,7 +129,7 @@ int main(int argc, char** argv)\n     test_one_input(buffer);\n #endif\n     if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n-        system::error_code ec;;\n+        system::error_code ec;\n         if (!boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", ec)) {\n             std::cout << ec << std::endl;\n         }"
      }
    ]
  },
  {
    "sha": "5c31c137086f199cc17661031b0631e85ca9e054",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YzMxYzEzNzA4NmYxOTljYzE3NjYxMDMxYjA2MzFlODVjYTllMDU0",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-16T22:27:54Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-16T22:27:54Z"
      },
      "message": "Include boost error codes",
      "tree": {
        "sha": "fbf6cf6299e3aed994ccf38966cb6ebe7424ed51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fbf6cf6299e3aed994ccf38966cb6ebe7424ed51"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c31c137086f199cc17661031b0631e85ca9e054",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8gfqCRBK7hj4Ov3rIwAAFFcIAKVJz/6fBrJoi6/ec/2DQolS\nnA7JNI7890Buc5Sss/ONedGb0Ixz9/TcPINB/6b7ozhtuCvxvDYMSa1JPXmet35b\nMAhA7NgwrE5nWPgv7TrhC4UPNwgywYHHjyq/uosgkIBxH9/w5c+c1oJZfdkft7ZN\nNAE0mzQ1BEKcHaSO0B/PggupWIrfLSgiE2Nm4cGUUyUGbPKm0K5u7MbqTCutYnZx\nYeraLhV0ewDiHJduEqVyvy3FGNyQB0oynBJ5S9+/NArv9WfIWStGnscoACBR7bsz\nG3SUJJMmLrpbdraSNGEatMN0FNJ3M2/ed+A/xwcS9slfEUlC3VmBkqgRc1onmI8=\n=QKAg\n-----END PGP SIGNATURE-----\n",
        "payload": "tree fbf6cf6299e3aed994ccf38966cb6ebe7424ed51\nparent 35323b08d3a2b75a0e8481b6fc8de3817232b024\nauthor Alex Groce <agroce@gmail.com> 1626474474 -0700\ncommitter GitHub <noreply@github.com> 1626474474 -0700\n\nInclude boost error codes"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c31c137086f199cc17661031b0631e85ca9e054",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5c31c137086f199cc17661031b0631e85ca9e054",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c31c137086f199cc17661031b0631e85ca9e054/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "35323b08d3a2b75a0e8481b6fc8de3817232b024",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35323b08d3a2b75a0e8481b6fc8de3817232b024",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/35323b08d3a2b75a0e8481b6fc8de3817232b024"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 3,
      "deletions": 2
    },
    "files": [
      {
        "sha": "e25baf66df14df6564fa78c6ea54cd9536ea5a12",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c31c137086f199cc17661031b0631e85ca9e054/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c31c137086f199cc17661031b0631e85ca9e054/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=5c31c137086f199cc17661031b0631e85ca9e054",
        "patch": "@@ -5,6 +5,7 @@\n #include <test/fuzz/fuzz.h>\n \n #include <boost/filesystem.hpp>\n+#include <boost/system/error_code.hpp>\n #include <netaddress.h>\n #include <netbase.h>\n #include <test/util/setup_common.h>\n@@ -129,9 +130,9 @@ int main(int argc, char** argv)\n     test_one_input(buffer);\n #endif\n     if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n-        system::error_code ec;\n+        boost::system::error_code ec;\n         if (!boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", ec)) {\n-            std::cout << ec << std::endl;\n+            std::cout << ec.message() << std::endl;\n         }\n     }\n     return 0;"
      }
    ]
  },
  {
    "sha": "d0beba5ae2fbffce580f9ad6743793499a664722",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGJlYmE1YWUyZmJmZmNlNTgwZjlhZDY3NDM3OTM0OTlhNjY0NzIy",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-16T22:37:04Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-16T22:37:04Z"
      },
      "message": "Just call, don't add dependency",
      "tree": {
        "sha": "f181bd651c2091561d9111060cef563cd8308ef3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f181bd651c2091561d9111060cef563cd8308ef3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0beba5ae2fbffce580f9ad6743793499a664722",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8goQCRBK7hj4Ov3rIwAAcg0IAHiY4uCWnRB72ovQhdsqp94Y\nhKbT58JzSXDhFKFLLp41OZIdTt6veNkeSUiyyJHAjhAOpHygKFuCkJOOvAeeBT7I\nauoskTfmT3KGfxWlgXso02LKM9Ww6IbCcLY5AVVgcAZnxx/vLLXiz8jxnQJt2Y8s\n+kqhWsMh/uR1VKPWhr2v4EANn3ljvxgkKqBOOJwJtv7Fhh/pPhCDThC5RW0Hc17N\nLb4/tARYMiHVHTjBMni5aZMJSTPdjS3xwcYMF/GhqqmGt5Qlblc4v+ieyCWmjLyd\nmSlpHrRRuaX7xdpy3qWidxcGDub4YJbcBQlNdu6KcraWbbsp8R04oA403+XSaEY=\n=YH1j\n-----END PGP SIGNATURE-----\n",
        "payload": "tree f181bd651c2091561d9111060cef563cd8308ef3\nparent 5c31c137086f199cc17661031b0631e85ca9e054\nauthor Alex Groce <agroce@gmail.com> 1626475024 -0700\ncommitter GitHub <noreply@github.com> 1626475024 -0700\n\nJust call, don't add dependency"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0beba5ae2fbffce580f9ad6743793499a664722",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0beba5ae2fbffce580f9ad6743793499a664722",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0beba5ae2fbffce580f9ad6743793499a664722/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5c31c137086f199cc17661031b0631e85ca9e054",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c31c137086f199cc17661031b0631e85ca9e054",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5c31c137086f199cc17661031b0631e85ca9e054"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 1,
      "deletions": 5
    },
    "files": [
      {
        "sha": "36b563a5cca0fffb774b03481a2c99d2c37c5396",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0beba5ae2fbffce580f9ad6743793499a664722/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0beba5ae2fbffce580f9ad6743793499a664722/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=d0beba5ae2fbffce580f9ad6743793499a664722",
        "patch": "@@ -5,7 +5,6 @@\n #include <test/fuzz/fuzz.h>\n \n #include <boost/filesystem.hpp>\n-#include <boost/system/error_code.hpp>\n #include <netaddress.h>\n #include <netbase.h>\n #include <test/util/setup_common.h>\n@@ -130,10 +129,7 @@ int main(int argc, char** argv)\n     test_one_input(buffer);\n #endif\n     if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n-        boost::system::error_code ec;\n-        if (!boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\", ec)) {\n-            std::cout << ec.message() << std::endl;\n-        }\n+        boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n     }\n     return 0;\n }"
      }
    ]
  },
  {
    "sha": "24ad8174dab34c94bb3999124a99288f55f37d36",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNGFkODE3NGRhYjM0Yzk0YmIzOTk5MTI0YTk5Mjg4ZjU1ZjM3ZDM2",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-20T00:34:18Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-20T00:34:18Z"
      },
      "message": "Try to fix OSS-Fuzz issues also",
      "tree": {
        "sha": "8f56f66f8aafe3131778687e172855e6cb5d619b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f56f66f8aafe3131778687e172855e6cb5d619b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24ad8174dab34c94bb3999124a99288f55f37d36",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9hoKCRBK7hj4Ov3rIwAAaXEIACGAhUtWb99xuwl+VFs1p41z\nvq8RBLk/F+uREnAHBjJI2W1njvXEYk9QQNityUZnwHkz0DiOoE2pNeOUQ9sKNgOu\nNL6JLnHXhV9GHi5ST6hITHumMCNb+Jwx1cP5JPW4mtsW9Ha+YYqSwjS5EYsqG0ms\nptd/aput+Lpf8l67HZj0cv9zB9JCJBvk81MK2vbEEAoLi1jd1Q2vAAhv1sP/m3ta\nxVE3qr5Cjbv2RmEooIPG347osS8vlI6ok6RTU8R/Hv2Flu+RJSN52v4F6ulS7b5c\nb9JT0JOXkBru9oA9sjm02YP5a/+xT1C5hDJSifkIBUr+1aaO4+weGthPXEMhN5s=\n=loS2\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 8f56f66f8aafe3131778687e172855e6cb5d619b\nparent d0beba5ae2fbffce580f9ad6743793499a664722\nauthor Alex Groce <agroce@gmail.com> 1626741258 -0700\ncommitter GitHub <noreply@github.com> 1626741258 -0700\n\nTry to fix OSS-Fuzz issues also"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24ad8174dab34c94bb3999124a99288f55f37d36",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/24ad8174dab34c94bb3999124a99288f55f37d36",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24ad8174dab34c94bb3999124a99288f55f37d36/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0beba5ae2fbffce580f9ad6743793499a664722",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0beba5ae2fbffce580f9ad6743793499a664722",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0beba5ae2fbffce580f9ad6743793499a664722"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d562330f756d540d4ae1a63a43ed1d21567f0e8c",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/24ad8174dab34c94bb3999124a99288f55f37d36/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/24ad8174dab34c94bb3999124a99288f55f37d36/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=24ad8174dab34c94bb3999124a99288f55f37d36",
        "patch": "@@ -89,6 +89,11 @@ static bool read_stdin(std::vector<uint8_t>& data)\n extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n {\n     static const auto& test_one_input = *Assert(g_test_one_input);\n+    static bool clearedTmp = false;\n+    if (!clearedTmp) {\n+        boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n+        clearedTmp = true;\n+    }\n     test_one_input({data, size});\n     return 0;\n }"
      }
    ]
  },
  {
    "sha": "de32caef5bef4e2b884582aeea139df1b81e77d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTMyY2FlZjViZWY0ZTJiODg0NTgyYWVlYTEzOWRmMWI4MWU3N2Q2",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-20T02:29:05Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-20T02:29:05Z"
      },
      "message": "Just do the remove_all in the common initialize",
      "tree": {
        "sha": "ad5a6542648b366915087ef6f52d275dd6b2d7ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad5a6542648b366915087ef6f52d275dd6b2d7ac"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de32caef5bef4e2b884582aeea139df1b81e77d6",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9jTxCRBK7hj4Ov3rIwAAz2QIACEUBp0hNJCDKcEhvPZtCcmB\nTpkr4jinjwBGKjYkUwfhParhNml55mYVXr9y70kdXuMo+Fmct5gzazQDE5po7CM6\ncD8ZH6mYk39rnjYnpteMZCTJkdRt6AuYFg40hsuWrMYALspWTdAmeTzeWsBwB6Ai\nQdQL3QGHhMU8Upw0e6YFiCWj+KBLEvn0r5oTxMbDCde6Bkm1rlK0ulg/oUuw0WM3\nFT6mvy+EE/KokCQLSGwb/W2/jfMAHaWiBKEjY+gZrDYSj7bwxgza3l+4RuMKcnfH\nr7dQaG9wVg3eDtE6u1zXOmOyHmbX+ToWAfsh/QZ4UDmUafBicPmPacNqCtFBZoo=\n=BgR+\n-----END PGP SIGNATURE-----\n",
        "payload": "tree ad5a6542648b366915087ef6f52d275dd6b2d7ac\nparent 24ad8174dab34c94bb3999124a99288f55f37d36\nauthor Alex Groce <agroce@gmail.com> 1626748145 -0700\ncommitter GitHub <noreply@github.com> 1626748145 -0700\n\nJust do the remove_all in the common initialize"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de32caef5bef4e2b884582aeea139df1b81e77d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de32caef5bef4e2b884582aeea139df1b81e77d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de32caef5bef4e2b884582aeea139df1b81e77d6/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24ad8174dab34c94bb3999124a99288f55f37d36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24ad8174dab34c94bb3999124a99288f55f37d36",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24ad8174dab34c94bb3999124a99288f55f37d36"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 3,
      "deletions": 8
    },
    "files": [
      {
        "sha": "15dfc7d98c2c44e4d2dedaa92580351febe36382",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de32caef5bef4e2b884582aeea139df1b81e77d6/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de32caef5bef4e2b884582aeea139df1b81e77d6/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=de32caef5bef4e2b884582aeea139df1b81e77d6",
        "patch": "@@ -36,6 +36,9 @@ static TypeTestOneInput* g_test_one_input{nullptr};\n \n void initialize()\n {\n+    // In case we didn't clean up properly after last fuzz run.\n+    boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n+\n     // Terminate immediately if a fuzzing harness ever tries to create a TCP socket.\n     CreateSock = [](const CService&) -> std::unique_ptr<Sock> { std::terminate(); };\n \n@@ -89,11 +92,6 @@ static bool read_stdin(std::vector<uint8_t>& data)\n extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n {\n     static const auto& test_one_input = *Assert(g_test_one_input);\n-    static bool clearedTmp = false;\n-    if (!clearedTmp) {\n-        boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n-        clearedTmp = true;\n-    }\n     test_one_input({data, size});\n     return 0;\n }\n@@ -133,9 +131,6 @@ int main(int argc, char** argv)\n     }\n     test_one_input(buffer);\n #endif\n-    if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n-        boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n-    }\n     return 0;\n }\n #endif"
      }
    ]
  },
  {
    "sha": "6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MzQ0ZWI2OThjMWQzOGJkYjZmNjIzYTYwZmE3NmFlNGZjZjk4MDJl",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-20T03:25:18Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-20T03:25:18Z"
      },
      "message": "Fails banman, so back to last solution",
      "tree": {
        "sha": "f181bd651c2091561d9111060cef563cd8308ef3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f181bd651c2091561d9111060cef563cd8308ef3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9kIeCRBK7hj4Ov3rIwAA7LwIADg2S6VwRPPaVQr0efT6UQ/8\njMo3TClQxAHiu7QFt7zBark9CUNkI3sTVUzC0YRcxWfMODCBJJn8tn+EDihZK0XR\nC7RWH+UTKIG2NItp40ZZGXeQwbDptISJiRm8lD6fVOsAnktq8dfKGr6tzDHokriq\n9WBgOAtf1NVveW7+VOWLus4I4p4boJMynjUBVP5tCOfMBhjKBgzAzDIlspw1shEz\nDtra4F2dI1ejhKkszR5Pu2YRHJOJrh2302eSmWpg84FEDx8MzqGTS4tVhn09KZPW\nvAQgDlTuboq4HbniC+2nG5mgYWp6O0NBBnScz0QtFdrChq8YfkPV9zY8pgHF0TQ=\n=3w0i\n-----END PGP SIGNATURE-----\n",
        "payload": "tree f181bd651c2091561d9111060cef563cd8308ef3\nparent de32caef5bef4e2b884582aeea139df1b81e77d6\nauthor Alex Groce <agroce@gmail.com> 1626751518 -0700\ncommitter GitHub <noreply@github.com> 1626751518 -0700\n\nFails banman, so back to last solution"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de32caef5bef4e2b884582aeea139df1b81e77d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de32caef5bef4e2b884582aeea139df1b81e77d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de32caef5bef4e2b884582aeea139df1b81e77d6"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "36b563a5cca0fffb774b03481a2c99d2c37c5396",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
        "patch": "@@ -36,9 +36,6 @@ static TypeTestOneInput* g_test_one_input{nullptr};\n \n void initialize()\n {\n-    // In case we didn't clean up properly after last fuzz run.\n-    boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n-\n     // Terminate immediately if a fuzzing harness ever tries to create a TCP socket.\n     CreateSock = [](const CService&) -> std::unique_ptr<Sock> { std::terminate(); };\n \n@@ -131,6 +128,9 @@ int main(int argc, char** argv)\n     }\n     test_one_input(buffer);\n #endif\n+    if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n+        boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n+    }\n     return 0;\n }\n #endif"
      }
    ]
  },
  {
    "sha": "60afee48c306cf16a19ea1914f1bae96987f063a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MGFmZWU0OGMzMDZjZjE2YTE5ZWExOTE0ZjFiYWU5Njk4N2YwNjNh",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-07-20T18:31:31Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-07-20T18:31:31Z"
      },
      "message": "Clarify how much this fixes",
      "tree": {
        "sha": "d235ace4f980861461dd66a47d33925cbeb4d781",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d235ace4f980861461dd66a47d33925cbeb4d781"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/60afee48c306cf16a19ea1914f1bae96987f063a",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9xaDCRBK7hj4Ov3rIwAAGPQIAFWCEdhph/UoWtaz9EIdtjy9\nn665rL6CfsodJKVcWAH3Mvcast2B/Y6PdV2b7ChlysLO2XRhT92aeSJA2ateUgbS\nAt82NdQ9wdPqL320LG0LvD+r3B5klu9VkkmvQfj3OdKAsRkH+fZ0wZdp44CKCAKJ\nkRLWPZfPA/fPddKgB9Ek2mLGBDGpKmTsx2CzSRhhQn3GVKZO5DBqsaLeherf+Npr\nhjra3HXZmgrV3/bt3KzrjxNnBrsdDKUoWzLffu9AMVwDbeV10i8IINLvT9xPURvw\nW0ZJIU2ncK2eHedqft61mJznPsTrHuKF46Bzd4BnZIhcQvrMBMpzI6rlM3KokL8=\n=a+kr\n-----END PGP SIGNATURE-----\n",
        "payload": "tree d235ace4f980861461dd66a47d33925cbeb4d781\nparent 6344eb698c1d38bdb6f623a60fa76ae4fcf9802e\nauthor Alex Groce <agroce@gmail.com> 1626805891 -0700\ncommitter GitHub <noreply@github.com> 1626805891 -0700\n\nClarify how much this fixes"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60afee48c306cf16a19ea1914f1bae96987f063a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/60afee48c306cf16a19ea1914f1bae96987f063a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60afee48c306cf16a19ea1914f1bae96987f063a/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6344eb698c1d38bdb6f623a60fa76ae4fcf9802e"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d3ddd2a0999b0a7f842e86a6bca91a0a72357622",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60afee48c306cf16a19ea1914f1bae96987f063a/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60afee48c306cf16a19ea1914f1bae96987f063a/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=60afee48c306cf16a19ea1914f1bae96987f063a",
        "patch": "@@ -129,6 +129,8 @@ int main(int argc, char** argv)\n     test_one_input(buffer);\n #endif\n     if (std::getenv(\"CLEAN_TMP_AFTER_FUZZ\")) {\n+        // This is ONLY a solution for \"single-threaded\" runs not going through the libFuzzer interface.\n+        // E.g., one AFL process, driven by afl-fuzz, or Eclipser.\n         boost::filesystem::remove_all(\"/tmp/test_common_Bitcoin Core\");\n     }\n     return 0;"
      }
    ]
  },
  {
    "sha": "971aab70b008e608263840030f04bf67e67c9515",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzFhYWI3MGIwMDhlNjA4MjYzODQwMDMwZjA0YmY2N2U2N2M5NTE1",
    "commit": {
      "author": {
        "name": "Alex Groce",
        "email": "agroce@gmail.com",
        "date": "2021-08-05T20:03:57Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-05T20:03:57Z"
      },
      "message": "Merge branch 'bitcoin:master' into master",
      "tree": {
        "sha": "0221072d9e4b16e33d9f2e9399e11643ce906c7d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0221072d9e4b16e33d9f2e9399e11643ce906c7d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/971aab70b008e608263840030f04bf67e67c9515",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhDEQtCRBK7hj4Ov3rIwAAvh8IAArku+1kFu2yiKhTM8Nxlde7\npBE7uNQoQa1GIzxnQTTDUWVDIDIICHBOOc/CVL3AyPJw399lgPzPBOLjydjbiYmB\n9kidnR6BJ0NtBi+zjKYmMTU6TtsBZgjcmfWZREEVn1K1Aoyc17s1atxdVLqay0Pe\nxATKAcIncMmCHtVPC2YJ8HhoLHGQCVYVldTBn20YN/UpiSE/ada/oauX+I49st6n\nI/HQ/LNXWaBR2pKa0u/WAQRIxiqTNhZut3VrfhH4YzCEWrvnpYTKvUk7WLQ62n7G\nNbvl3aDOiBkc75E6kiOAmig5Bqg8ZGpuPlbZ2nIlBzKr+qvQYql5NtLH8R0470c=\n=aTDf\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 0221072d9e4b16e33d9f2e9399e11643ce906c7d\nparent 60afee48c306cf16a19ea1914f1bae96987f063a\nparent d67330d11245b11fbdd5e2dd5343ee451186931e\nauthor Alex Groce <agroce@gmail.com> 1628193837 -0700\ncommitter GitHub <noreply@github.com> 1628193837 -0700\n\nMerge branch 'bitcoin:master' into master\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/971aab70b008e608263840030f04bf67e67c9515",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/971aab70b008e608263840030f04bf67e67c9515",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/971aab70b008e608263840030f04bf67e67c9515/comments",
    "author": {
      "login": "agroce",
      "id": 967816,
      "node_id": "MDQ6VXNlcjk2NzgxNg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/967816?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/agroce",
      "html_url": "https://github.com/agroce",
      "followers_url": "https://api.github.com/users/agroce/followers",
      "following_url": "https://api.github.com/users/agroce/following{/other_user}",
      "gists_url": "https://api.github.com/users/agroce/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/agroce/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/agroce/subscriptions",
      "organizations_url": "https://api.github.com/users/agroce/orgs",
      "repos_url": "https://api.github.com/users/agroce/repos",
      "events_url": "https://api.github.com/users/agroce/events{/privacy}",
      "received_events_url": "https://api.github.com/users/agroce/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60afee48c306cf16a19ea1914f1bae96987f063a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60afee48c306cf16a19ea1914f1bae96987f063a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60afee48c306cf16a19ea1914f1bae96987f063a"
      },
      {
        "sha": "d67330d11245b11fbdd5e2dd5343ee451186931e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d67330d11245b11fbdd5e2dd5343ee451186931e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d67330d11245b11fbdd5e2dd5343ee451186931e"
      }
    ],
    "stats": {
      "total": 10678,
      "additions": 7312,
      "deletions": 3366
    },
    "files": [
      {
        "sha": "79c294fd15859d25238ba5c3b52daeea35ce86ba",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -3,7 +3,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n # Pattern rule to print variables, e.g. make print-top_srcdir\n-print-%:\n+print-%: FORCE\n \t@echo '$*'='$($*)'\n \n ACLOCAL_AMFLAGS = -I build-aux/m4"
      },
      {
        "sha": "1a6922deca485d466bc042f26bc351c960f12d8d",
        "filename": "build-aux/m4/bitcoin_runtime_lib.m4",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/build-aux/m4/bitcoin_runtime_lib.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/build-aux/m4/bitcoin_runtime_lib.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_runtime_lib.m4?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,42 @@\n+# On some platforms clang builtin implementations\n+# require compiler-rt as a runtime library to use.\n+#\n+# See:\n+# - https://bugs.llvm.org/show_bug.cgi?id=28629\n+\n+m4_define([_CHECK_RUNTIME_testbody], [[\n+  bool f(long long x, long long y, long long* p)\n+  {\n+    return __builtin_mul_overflow(x, y, p);\n+  }\n+  int main() { return 0; }\n+]])\n+\n+AC_DEFUN([CHECK_RUNTIME_LIB], [\n+\n+  AC_LANG_PUSH([C++])\n+\n+  AC_MSG_CHECKING([for __builtin_mul_overflow])\n+  AC_LINK_IFELSE(\n+    [AC_LANG_SOURCE([_CHECK_RUNTIME_testbody])],\n+    [\n+      AC_MSG_RESULT([yes])\n+      AC_DEFINE([HAVE_BUILTIN_MUL_OVERFLOW], [1], [Define if you have a working __builtin_mul_overflow])\n+    ],\n+    [\n+      ax_check_save_flags=\"$LDFLAGS\"\n+      LDFLAGS=\"$LDFLAGS --rtlib=compiler-rt -lgcc_s\"\n+      AC_LINK_IFELSE(\n+        [AC_LANG_SOURCE([_CHECK_RUNTIME_testbody])],\n+        [\n+          AC_MSG_RESULT([yes, with additional linker flags])\n+          RUNTIME_LDFLAGS=\"--rtlib=compiler-rt -lgcc_s\"\n+          AC_DEFINE([HAVE_BUILTIN_MUL_OVERFLOW], [1], [Define if you have a working __builtin_mul_overflow])\n+        ],\n+        [AC_MSG_RESULT([no])])\n+      LDFLAGS=\"$ax_check_save_flags\"\n+    ])\n+\n+  AC_LANG_POP\n+  AC_SUBST([RUNTIME_LDFLAGS])\n+])"
      },
      {
        "sha": "e987aa64cb29f92ef5e551d86496340e4f74ce1d",
        "filename": "build_msvc/bitcoin_config.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/build_msvc/bitcoin_config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/build_msvc/bitcoin_config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoin_config.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -15,7 +15,7 @@\n #define CLIENT_VERSION_IS_RELEASE false\n \n /* Major version */\n-#define CLIENT_VERSION_MAJOR 21\n+#define CLIENT_VERSION_MAJOR 22\n \n /* Minor version */\n #define CLIENT_VERSION_MINOR 99\n@@ -30,7 +30,7 @@\n #define COPYRIGHT_HOLDERS_SUBSTITUTION \"Bitcoin Core\"\n \n /* Copyright year */\n-#define COPYRIGHT_YEAR 2019\n+#define COPYRIGHT_YEAR 2021\n \n /* Define to 1 to enable wallet functions */\n #define ENABLE_WALLET 1\n@@ -254,7 +254,7 @@\n #define PACKAGE_NAME \"Bitcoin Core\"\n \n /* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \"Bitcoin Core 21.99.0\"\n+#define PACKAGE_STRING \"Bitcoin Core 22.99.0\"\n \n /* Define to the one symbol short name of this package. */\n #define PACKAGE_TARNAME \"bitcoin\"\n@@ -263,7 +263,7 @@\n #define PACKAGE_URL \"https://bitcoincore.org/\"\n \n /* Define to the version of this package. */\n-#define PACKAGE_VERSION \"21.99.0\"\n+#define PACKAGE_VERSION \"22.99.0\"\n \n /* Define to necessary symbol if this constant uses a non-standard name on\n    your system. */"
      },
      {
        "sha": "6c45d4dbd8a0f194c847196a4ad0740bf5ef4705",
        "filename": "build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -24,6 +24,7 @@\n     <ClCompile Include=\"..\\..\\src\\qt\\csvmodelwriter.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\editaddressdialog.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\guiutil.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\qt\\initexecutor.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\intro.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\modaloverlay.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\networkstyle.cpp\" />\n@@ -78,6 +79,7 @@\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_csvmodelwriter.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_editaddressdialog.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_guiutil.cpp\" />\n+    <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_initexecutor.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_intro.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_modaloverlay.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_networkstyle.cpp\" />"
      },
      {
        "sha": "bb1a780bfab12192ffb45c572fd60e36ca9db5d0",
        "filename": "build_msvc/test_bitcoin/test_bitcoin.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/build_msvc/test_bitcoin/test_bitcoin.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/build_msvc/test_bitcoin/test_bitcoin.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/test_bitcoin/test_bitcoin.vcxproj?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,6 +16,7 @@\n     <ClCompile Include=\"..\\..\\src\\test\\util\\*.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\wallet\\test\\*_fixture.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\wallet\\test\\*_tests.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\wallet\\test\\util.cpp\" />\n   </ItemGroup>\n   <ItemGroup>\n     <ProjectReference Include=\"..\\libbitcoinconsensus\\libbitcoinconsensus.vcxproj\">"
      },
      {
        "sha": "4ef3ae1ceb97dd8eae5dcb80cf239fe3cb06b302",
        "filename": "ci/test/00_setup_env_android.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/ci/test/00_setup_env_android.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/ci/test/00_setup_env_android.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_android.sh?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,7 +16,7 @@ export RUN_FUNCTIONAL_TESTS=false\n \n export ANDROID_API_LEVEL=28\n export ANDROID_BUILD_TOOLS_VERSION=28.0.3\n-export ANDROID_NDK_VERSION=21.1.6352462\n+export ANDROID_NDK_VERSION=22.1.7171670\n export ANDROID_TOOLS_URL=https://dl.google.com/android/repository/commandlinetools-linux-6609375_latest.zip\n export ANDROID_HOME=\"${DEPENDS_DIR}/SDKs/android\"\n export ANDROID_NDK_HOME=\"${ANDROID_HOME}/ndk/${ANDROID_NDK_VERSION}\""
      },
      {
        "sha": "753e716d03cca7880512ee3b2822eb54af28081e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,5 +1,5 @@\n AC_PREREQ([2.69])\n-define(_CLIENT_VERSION_MAJOR, 21)\n+define(_CLIENT_VERSION_MAJOR, 22)\n define(_CLIENT_VERSION_MINOR, 99)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_RC, 0)\n@@ -426,6 +426,7 @@ if test \"x$enable_werror\" = \"xyes\"; then\n                         [AC_LANG_SOURCE([[struct A { virtual void f(); }; struct B : A { void f() final; };]])])\n   AX_CHECK_COMPILE_FLAG([-Werror=unreachable-code-loop-increment],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=unreachable-code-loop-increment\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Werror=mismatched-tags], [ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=mismatched-tags\"], [], [$CXXFLAG_WERROR])\n+  AX_CHECK_COMPILE_FLAG([-Werror=implicit-fallthrough], [ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=implicit-fallthrough\"], [], [$CXXFLAG_WERROR])\n \n   if test x$suppress_external_warnings != xno ; then\n     AX_CHECK_COMPILE_FLAG([-Werror=documentation],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=documentation\"],,[[$CXXFLAG_WERROR]])\n@@ -456,6 +457,7 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wsuggest-override],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wsuggest-override\"],,[[$CXXFLAG_WERROR]],\n                         [AC_LANG_SOURCE([[struct A { virtual void f(); }; struct B : A { void f() final; };]])])\n   AX_CHECK_COMPILE_FLAG([-Wunreachable-code-loop-increment],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wunreachable-code-loop-increment\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough], [WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wimplicit-fallthrough\"], [], [$CXXFLAG_WERROR])\n \n   if test x$suppress_external_warnings != xno ; then\n     AX_CHECK_COMPILE_FLAG([-Wdocumentation],[WARN_CXXFLAGS=\"$WARN_CXXFLAGS -Wdocumentation\"],,[[$CXXFLAG_WERROR]])\n@@ -467,7 +469,6 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wunused-parameter],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-unused-parameter\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wself-assign],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-self-assign\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n   if test x$suppress_external_warnings != xyes ; then\n     AX_CHECK_COMPILE_FLAG([-Wdeprecated-copy],[NOWARN_CXXFLAGS=\"$NOWARN_CXXFLAGS -Wno-deprecated-copy\"],,[[$CXXFLAG_WERROR]])\n   fi\n@@ -1751,6 +1752,10 @@ if test x$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoin_\n   AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-libs --with-daemon --with-gui --enable-bench or --enable-tests])\n fi\n \n+if test x$enable_fuzz_binary = xyes; then\n+  CHECK_RUNTIME_LIB\n+fi\n+\n AM_CONDITIONAL([TARGET_DARWIN], [test x$TARGET_OS = xdarwin])\n AM_CONDITIONAL([BUILD_DARWIN], [test x$BUILD_OS = xdarwin])\n AM_CONDITIONAL([TARGET_LINUX], [test x$TARGET_OS = xlinux])"
      },
      {
        "sha": "a2612ab958458a312294b599ac88d802382d25b4",
        "filename": "contrib/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/README.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -29,8 +29,8 @@ All other packaging related files can be found in the [bitcoin-core/packaging](h\n ### [Gitian-descriptors](/contrib/gitian-descriptors) ###\n Files used during the gitian build process. For more information about gitian, see the [the Bitcoin Core documentation repository](https://github.com/bitcoin-core/docs).\n \n-### [Gitian-keys](/contrib/gitian-keys)\n-PGP keys used for signing Bitcoin Core [Gitian release](/doc/release-process.md) results.\n+### [Builder keys](/contrib/builder-keys)\n+PGP keys used for signing Bitcoin Core [release](/doc/release-process.md) results.\n \n ### [MacDeploy](/contrib/macdeploy) ###\n Scripts and notes for Mac builds."
      },
      {
        "sha": "a7c1d5ae0a75dd105416539a6ac0e985680057a8",
        "filename": "contrib/builder-keys/README.md",
        "status": "renamed",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/builder-keys/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/builder-keys/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/builder-keys/README.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,10 +1,10 @@\n-## PGP keys of Gitian builders and Developers\n+## PGP keys of builders and Developers\n \n-The file `keys.txt` contains fingerprints of the public keys of Gitian builders\n-and active developers.\n+The file `keys.txt` contains fingerprints of the public keys of builders and\n+active developers.\n \n The associated keys are mainly used to sign git commits or the build results\n-of Gitian builds.\n+of Guix builds.\n \n The most recent version of each pgp key can be found on most pgp key servers.\n \n@@ -16,12 +16,12 @@ To fetch the latest version of all pgp keys in your gpg homedir,\n gpg --refresh-keys\n ```\n \n-To fetch keys of Gitian builders and active developers, feed the list of\n-fingerprints of the primary keys into gpg:\n+To fetch keys of builders and active developers, feed the list of fingerprints\n+of the primary keys into gpg:\n \n ```sh\n while read fingerprint keyholder_name; do gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys ${fingerprint}; done < ./keys.txt\n ```\n \n-Add your key to the list if you provided Gitian signatures for two major or\n+Add your key to the list if you provided Guix attestations for two major or\n minor releases of Bitcoin Core.",
        "previous_filename": "contrib/gitian-keys/README.md"
      },
      {
        "sha": "db28cd07a0b02828a0caa2a6041563631caa02e0",
        "filename": "contrib/builder-keys/keys.txt",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/builder-keys/keys.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/builder-keys/keys.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/builder-keys/keys.txt?ref=971aab70b008e608263840030f04bf67e67c9515",
        "previous_filename": "contrib/gitian-keys/keys.txt"
      },
      {
        "sha": "63aa3e02b2cc0f00d30f648812587899894bd6dd",
        "filename": "contrib/guix/INSTALL.md",
        "status": "added",
        "additions": 801,
        "deletions": 0,
        "changes": 801,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/INSTALL.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/INSTALL.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/INSTALL.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,801 @@\n+# Guix Installation and Setup\n+\n+This only needs to be done once per machine. If you have already completed the\n+installation and setup, please proceed to [perform a build](./README.md).\n+\n+Otherwise, you may choose from one of the following options to install Guix:\n+\n+1. Using the official **shell installer script** [\u2913 skip to section][install-script]\n+   - Maintained by Guix developers\n+   - Easiest (automatically performs *most* setup)\n+   - Works on nearly all Linux distributions\n+   - Only installs latest release\n+   - Binary installation only, requires high level of trust\n+   - Note: The script needs to be run as root, so it should be inspected before it's run\n+2. Using the official **binary tarball** [\u2913 skip to section][install-bin-tarball]\n+   - Maintained by Guix developers\n+   - Normal difficulty (full manual setup required)\n+   - Works on nearly all Linux distributions\n+   - Installs any release\n+   - Binary installation only, requires high level of trust\n+3. Using fanquake's **Docker image** [\u2197\ufe0e external instructions][install-fanquake-docker]\n+   - Maintained by fanquake\n+   - Easy (automatically performs *some* setup)\n+   - Works wherever Docker images work\n+   - Installs any release\n+   - Binary installation only, requires high level of trust\n+4. Using a **distribution-maintained package** [\u2913 skip to section][install-distro-pkg]\n+   - Maintained by distribution's Guix package maintainer\n+   - Normal difficulty (manual setup required)\n+   - Works only on distributions with Guix packaged, see: https://repology.org/project/guix/versions\n+   - Installs a release decided on by package maintainer\n+   - Source or binary installation depending on the distribution\n+5. Building **from source** [\u2913 skip to section][install-source]\n+   - Maintained by you\n+   - Hard, but rewarding\n+   - Can be made to work on most Linux distributions\n+   - Installs any commit (more granular)\n+   - Source installation, requires lower level of trust\n+\n+## Options 1 and 2: Using the official shell installer script or binary tarball\n+\n+The installation instructions for both the official shell installer script and\n+the binary tarballs can be found in the GNU Guix Manual's [Binary Installation\n+section](https://guix.gnu.org/manual/en/html_node/Binary-Installation.html).\n+\n+Note that running through the binary tarball installation steps is largely\n+equivalent to manually performing what the shell installer script does.\n+\n+Note that at the time of writing (July 5th, 2021), the shell installer script\n+automatically creates an `/etc/profile.d` entry which the binary tarball\n+installation instructions do not ask you to create. However, you will likely\n+need this entry for better desktop integration. Please see [this\n+section](#add-an-etcprofiled-entry) for instructions on how to add a\n+`/etc/profile.d/guix.sh` entry.\n+\n+Regardless of which installation option you chose, the changes to\n+`/etc/profile.d` will not take effect until the next shell or desktop session,\n+so you should log out and log back in.\n+\n+## Option 3: Using fanquake's Docker image\n+\n+Please refer to fanquake's instructions\n+[here](https://github.com/fanquake/core-review/tree/master/guix).\n+\n+Note that the `Dockerfile` is largely equivalent to running through the binary\n+tarball installation steps.\n+\n+## Option 4: Using a distribution-maintained package\n+\n+Note that this section is based on the distro packaging situation at the time of\n+writing (July 2021). Guix is expected to be more widely packaged over time. For\n+an up-to-date view on Guix's package status/version across distros, please see:\n+https://repology.org/project/guix/versions\n+\n+### Debian 11 (Bullseye)/Ubuntu 21.04 (Hirsute Hippo)\n+\n+Guix v1.2.0 is available as a distribution package starting in [Debian\n+11](https://packages.debian.org/bullseye/guix) and [Ubuntu\n+21.04](https://packages.ubuntu.com/hirsute/guix).\n+\n+Note that if you intend on using Guix without using any substitutes (more\n+details [here][security-model]), v1.2.0 has a known problem when building GnuTLS\n+from source. Solutions and workarounds are documented\n+[here](#gnutls-test-suite-fail-status-request-revoked).\n+\n+\n+To install:\n+```sh\n+sudo apt install guix\n+```\n+\n+For up-to-date information on Debian and Ubuntu's release history:\n+- [Debian release history](https://www.debian.org/releases/)\n+- [Ubuntu release history](https://ubuntu.com/about/release-cycle)\n+\n+### Arch Linux\n+\n+Guix is available in the AUR as\n+[`guix`](https://aur.archlinux.org/packages/guix/), please follow the\n+installation instructions in the Arch Linux Wiki ([live\n+link](https://wiki.archlinux.org/index.php/Guix#AUR_Package_Installation),\n+[2021/03/30\n+permalink](https://wiki.archlinux.org/index.php?title=Guix&oldid=637559#AUR_Package_Installation))\n+to install Guix.\n+\n+At the time of writing (2021/03/30), the `check` phase will fail if the path to\n+guix's build directory is longer than 36 characters due to an anachronistic\n+character limit on the shebang line. Since the `check` phase happens after the\n+`build` phase, which may take quite a long time, it is recommended that users\n+either:\n+\n+1. Skip the `check` phase\n+    - For `makepkg`: `makepkg --nocheck ...`\n+    - For `yay`: `yay --mflags=\"--nocheck\" ...`\n+    - For `paru`: `paru --nocheck ...`\n+2. Or, check their build directory's length beforehand\n+    - For those building with `makepkg`: `pwd | wc -c`\n+\n+## Option 5: Building from source\n+\n+Building Guix from source is a rather involved process but a rewarding one for\n+those looking to minimize trust and maximize customizability (e.g. building a\n+particular commit of Guix). Previous experience with using autotools-style build\n+systems to build packages from source will be helpful. *hic sunt dracones.*\n+\n+I strongly urge you to at least skim through the entire section once before you\n+start issuing commands, as it will save you a lot of unnecessary pain and\n+anguish.\n+\n+### Installing common build tools\n+\n+There are a few basic build tools that are required for most things we'll build,\n+so let's install them now:\n+\n+Text transformation/i18n:\n+- `autopoint` (sometimes packaged in `gettext`)\n+- `help2man`\n+- `po4a`\n+- `texinfo`\n+\n+Build system tools:\n+- `g++` w/ C++11 support\n+- `libtool`\n+- `autoconf`\n+- `automake`\n+- `pkg-config` (sometimes packaged as `pkgconf`)\n+- `make`\n+- `cmake`\n+\n+Miscellaneous:\n+- `git`\n+- `gnupg`\n+- `python3`\n+\n+### Building and Installing Guix's dependencies\n+\n+In order to build Guix itself from source, we need to first make sure that the\n+necessary dependencies are installed and discoverable. The most up-to-date list\n+of Guix's dependencies is kept in the [\"Requirements\"\n+section](https://guix.gnu.org/manual/en/html_node/Requirements.html) of the Guix\n+Reference Manual.\n+\n+Depending on your distribution, most or all of these dependencies may already be\n+packaged and installable without manually building and installing.\n+\n+For reference, the graphic below outlines Guix v1.3.0's dependency graph:\n+\n+![bootstrap map](https://user-images.githubusercontent.com/6399679/125064185-a9a59880-e0b0-11eb-82c1-9b8e5dc9950d.png)\n+\n+#### Guile\n+\n+##### Choosing a Guile version and sticking to it\n+\n+One of the first things you need to decide is which Guile version you want to\n+use: Guile v2.2 or Guile v3.0. Unlike the python2 to python3 transition, Guile\n+v2.2 and Guile v3.0 are largely compatible, as evidenced by the fact that most\n+Guile packages and even [Guix\n+itself](https://guix.gnu.org/en/blog/2020/guile-3-and-guix/) support running on\n+both.\n+\n+What is important here is that you **choose one**, and you **remain consistent**\n+with your choice throughout **all Guile-related packages**, no matter if they\n+are installed via the distribution's package manager or installed from source.\n+This is because the files for Guile packages are installed to directories which\n+are separated based on the Guile version.\n+\n+###### Example: Checking that Ubuntu's `guile-git` is compatible with your chosen Guile version\n+\n+On Ubuntu Focal:\n+\n+```sh\n+$ apt show guile-git\n+Package: guile-git\n+...\n+Depends: guile-2.2, guile-bytestructures, libgit2-dev\n+...\n+```\n+\n+As you can see, the package `guile-git` depends on `guile-2.2`, meaning that it\n+was likely built for Guile v2.2. This means that if you decided to use Guile\n+v3.0 on Ubuntu Focal, you would need to build guile-git from source instead of\n+using the distribution package.\n+\n+On Ubuntu Hirsute:\n+\n+```sh\n+$ apt show guile-git\n+Package: guile-git\n+...\n+Depends: guile-3.0 | guile-2.2, guile-bytestructures (>= 1.0.7-3~), libgit2-dev (>= 1.0)\n+...\n+```\n+\n+In this case, `guile-git` depends on either `guile-3.0` or `guile-2.2`, meaning\n+that it would work no matter what Guile version you decided to use.\n+\n+###### Corner case: Multiple versions of Guile on one system\n+\n+It is recommended to only install one version of Guile, so that build systems do\n+not get confused about which Guile to use.\n+\n+However, if you insist on having both Guile v2.2 and Guile v3.0 installed on\n+your system, then you need to **consistently** specify one of\n+`GUILE_EFFECTIVE_VERSION=3.0` or `GUILE_EFFECTIVE_VERSION=2.2` to all\n+`./configure` invocations for Guix and its dependencies.\n+\n+##### Installing Guile\n+\n+Guile is most likely already packaged for your distribution, so after you have\n+[chosen a Guile version](#choosing-a-guile-version-and-sticking-to-it), install\n+it via your distribution's package manager.\n+\n+If your distribution splits packages into `-dev`-suffixed and\n+non-`-dev`-suffixed sub-packages (as is the case for Debian-derived\n+distributions), please make sure to install both. For example, to install Guile\n+v2.2 on Debian/Ubuntu:\n+\n+```sh\n+apt install guile-2.2 guile-2.2-dev\n+```\n+\n+#### Mixing distribution packages and source-built packages\n+\n+At the time of writing, most distributions have _some_ of Guix's dependencies\n+packaged, but not all. This means that you may want to install the distribution\n+package for some dependencies, and manually build-from-source for others.\n+\n+Distribution packages usually install to `/usr`, which is different from the\n+default `./configure` prefix of source-built packages: `/usr/local`.\n+\n+This means that if you mix-and-match distribution packages and source-built\n+packages and do not specify exactly `--prefix=/usr` to `./configure` for\n+source-built packages, you will need to augment the `GUILE_LOAD_PATH` and\n+`GUILE_LOAD_COMPILED_PATH` environment variables so that Guile will look\n+under the right prefix and find your source-built packages.\n+\n+For example, if you are using Guile v2.2, and have Guile packages in the\n+`/usr/local` prefix, either add the following lines to your `.profile` or\n+`.bash_profile` so that the environment variable is properly set for all future\n+shell logins, or paste the lines into a POSIX-style shell to temporarily modify\n+the environment variables of your current shell session.\n+\n+```sh\n+# Help Guile v2.2.x find packages in /usr/local\n+export GUILE_LOAD_PATH=\"/usr/local/share/guile/site/2.2${GUILE_LOAD_PATH:+:}$GUILE_LOAD_PATH\"\n+export GUILE_LOAD_COMPILED_PATH=\"/usr/local/lib/guile/2.2/site-ccache${GUILE_LOAD_COMPILED_PATH:+:}$GUILE_COMPILED_LOAD_PATH\"\n+```\n+\n+Note that these environment variables are used to check for packages during\n+`./configure`, so they should be set as soon as possible should you want to use\n+a prefix other than `/usr`.\n+\n+#### Building and installing source-built packages\n+\n+***IMPORTANT**: A few dependencies have non-obvious quirks/errata which are\n+documented in the sub-sections immediately below. Please read these sections\n+before proceeding to build and install these packages.*\n+\n+Although you should always refer to the README or INSTALL files for the most\n+accurate information, most of these dependencies use autoconf-style build\n+systems (check if there's a `configure.ac` file), and will likely do the right\n+thing with the following:\n+\n+Clone the repository and check out the latest release:\n+```sh\n+git clone <git-repo-of-dependency>/<dependency>.git\n+cd <dependency>\n+git tag -l  # check for the latest release\n+git checkout <latest-release>\n+```\n+\n+For autoconf-based build systems (if `./autogen.sh` or `configure.ac` exists at\n+the root of the repository):\n+\n+```sh\n+./autogen.sh || autoreconf -vfi\n+./configure --prefix=<prefix>\n+make\n+sudo make install\n+```\n+\n+For CMake-based build systems (if `CMakeLists.txt` exists at the root of the\n+repository):\n+\n+```sh\n+mkdir build && cd build\n+cmake .. -DCMAKE_INSTALL_PREFIX=<prefix>\n+sudo cmake --build . --target install\n+```\n+\n+If you choose not to specify exactly `--prefix=/usr` to `./configure`, please\n+make sure you've carefully read the [previous section] on mixing distribution\n+packages and source-built packages.\n+\n+##### Binding packages require `-dev`-suffixed packages\n+\n+Relevant for:\n+- Everyone\n+\n+When building bindings, the `-dev`-suffixed version of the original package\n+needs to be installed. For example, building `Guile-zlib` on Debian-derived\n+distributions requires that `zlib1g-dev` is installed.\n+\n+When using bindings, the `-dev`-suffixed version of the original package still\n+needs to be installed. This is particularly problematic when distribution\n+packages are mispackaged like `guile-sqlite3` is in Ubuntu Focal such that\n+installing `guile-sqlite3` does not automatically install `libsqlite3-dev` as a\n+dependency.\n+\n+Below is a list of relevant Guile bindings and their corresponding `-dev`\n+packages in Debian at the time of writing.\n+\n+| Guile binding package | -dev Debian package |\n+|-----------------------|---------------------|\n+| guile-gcrypt          | libgcrypt-dev       |\n+| guile-git             | libgit2-dev         |\n+| guile-lzlib           | liblz-dev           |\n+| guile-ssh             | libssh-dev          |\n+| guile-sqlite3         | libsqlite3-dev      |\n+| guile-zlib            | zlib1g-dev          |\n+\n+##### `guile-git` actually depends on `libgit2 >= 1.1`\n+\n+Relevant for:\n+- Those building `guile-git` from source against `libgit2 < 1.1`\n+- Those installing `guile-git` from their distribution where `guile-git` is\n+  built against `libgit2 < 1.1`\n+\n+As of v0.4.0, `guile-git` claims to only require `libgit2 >= 0.28.0`, however,\n+it actually requires `libgit2 >= 1.1`, otherwise, it will be confused by a\n+reference of `origin/keyring`: instead of interpreting the reference as \"the\n+'keyring' branch of the 'origin' remote\", the reference is interpreted as \"the\n+branch literally named 'origin/keyring'\"\n+\n+This is especially notable because Ubuntu Focal packages `libgit2 v0.28.4`, and\n+`guile-git` is built against it.\n+\n+Should you be in this situation, you need to build both `libgit2 v1.1.x` and\n+`guile-git` from source.\n+\n+Source: http://logs.guix.gnu.org/guix/2020-11-12.log#232527\n+\n+##### `{scheme,guile}-bytestructures` v1.0.8 and v1.0.9 are broken for Guile v2.2\n+\n+Relevant for:\n+- Those building `{scheme,guile}-bytestructures` from source against Guile v2.2\n+\n+Commit\n+[707eea3](https://github.com/TaylanUB/scheme-bytestructures/commit/707eea3a85e1e375e86702229ebf73d496377669)\n+introduced a regression for Guile v2.2 and was first included in v1.0.8, this\n+was later corrected in commit\n+[ec9a721](https://github.com/TaylanUB/scheme-bytestructures/commit/ec9a721957c17bcda13148f8faa5f06934431ff7)\n+and included in v1.1.0.\n+\n+TL;DR If you decided to use Guile v2.2, do not use `{scheme,guile}-bytestructures` v1.0.8 or v1.0.9.\n+\n+### Building and Installing Guix itself\n+\n+Start by cloning Guix:\n+\n+```\n+git clone https://git.savannah.gnu.org/git/guix.git\n+cd guix\n+```\n+\n+You will likely want to build the latest release, however, if the latest release\n+when you're reading this is still 1.2.0 then you may want to use 95aca29 instead\n+to avoid a problem in the GnuTLS test suite.\n+\n+```\n+git branch -a -l 'origin/version-*'  # check for the latest release\n+git checkout <latest-release>\n+```\n+\n+Bootstrap the build system:\n+```\n+./bootstrap\n+```\n+\n+Configure with the recommended `--localstatedir` flag:\n+```\n+./configure --localstatedir=/var\n+```\n+\n+Note: If you intend to hack on Guix in the future, you will need to supply the\n+same `--localstatedir=` flag for all future Guix `./configure` invocations. See\n+the last paragraph of this\n+[section](https://guix.gnu.org/manual/en/html_node/Requirements.html) for more\n+details.\n+\n+Build Guix (this will take a while):\n+```\n+make -j$(nproc)\n+```\n+\n+Install Guix:\n+\n+```\n+sudo make install\n+```\n+\n+### Post-\"build from source\" Setup\n+\n+#### Creating and starting a `guix-daemon-original` service with a fixed `argv[0]`\n+\n+At this point, guix will be installed to `${bindir}`, which is likely\n+`/usr/local/bin` if you did not override directory variables at\n+`./configure`-time. More information on standard Automake directory variables\n+can be found\n+[here](https://www.gnu.org/software/automake/manual/html_node/Standard-Directory-Variables.html).\n+\n+However, the Guix init scripts and service configurations for Upstart, systemd,\n+SysV, and OpenRC are installed (in `${libdir}`) to launch\n+`${localstatedir}/guix/profiles/per-user/root/current-guix/bin/guix-daemon`,\n+which does not yet exist, and will only exist after [`root` performs their first\n+`guix pull`](#guix-pull-as-root).\n+\n+We need to create a `-original` version of these init scripts that's pointed to\n+the binaries we just built and `make install`'ed in `${bindir}` (normally,\n+`/usr/local/bin`).\n+\n+Example for `systemd`, run as `root`:\n+\n+```sh\n+# Create guix-daemon-original.service by modifying guix-daemon.service\n+libdir=# set according to your PREFIX (default is /usr/local/lib)\n+bindir=\"$(dirname $(command -v guix-daemon))\"\n+sed -E -e \"s|/\\S*/guix/profiles/per-user/root/current-guix/bin/guix-daemon|${bindir}/guix-daemon|\" \"${libdir}\"/systemd/system/guix-daemon.service > /etc/systemd/system/guix-daemon-original.service\n+chmod 664 /etc/systemd/system/guix-daemon-original.service\n+\n+# Make systemd recognize the new service\n+systemctl daemon-reload\n+\n+# Make sure that the non-working guix-daemon.service is stopped and disabled\n+systemctl stop guix-daemon\n+systemctl disable guix-daemon\n+\n+# Make sure that the working guix-daemon-original.service is started and enabled\n+systemctl enable guix-daemon-original\n+systemctl start guix-daemon-original\n+```\n+\n+#### Creating `guix-daemon` users / groups\n+\n+Please see the [relevant\n+section](https://guix.gnu.org/manual/en/html_node/Build-Environment-Setup.html)\n+in the Guix Reference Manual for more details.\n+\n+## Optional setup\n+\n+At this point, you are set up to [use Guix to build Bitcoin\n+Core](./README.md#usage). However, if you want to polish your setup a bit and\n+make it \"what Guix intended\", then read the next few subsections.\n+\n+### Add an `/etc/profile.d` entry\n+\n+This section definitely does not apply to you if you installed Guix using:\n+1. The shell installer script\n+2. fanquake's Docker image\n+3. Debian's `guix` package\n+\n+#### Background\n+\n+Although Guix knows how to update itself and its packages, it does so in a\n+non-invasive way (it does not modify `/usr/local/bin/guix`).\n+\n+Instead, it does the following:\n+\n+- After a `guix pull`, it updates\n+  `/var/guix/profiles/per-user/$USER/current-guix`, and creates a symlink\n+  targeting this directory at `$HOME/.config/guix/current`\n+\n+- After a `guix install`, it updates\n+  `/var/guix/profiles/per-user/$USER/guix-profile`, and creates a symlink\n+  targeting this directory at `$HOME/.guix-profile`\n+\n+Therefore, in order for these operations to affect your shell/desktop sessions\n+(and for the principle of least astonishment to hold), their corresponding\n+directories have to be added to well-known environment variables like `$PATH`,\n+`$INFOPATH`, `$XDG_DATA_DIRS`, etc.\n+\n+In other words, if `$HOME/.config/guix/current/bin` does not exist in your\n+`$PATH`, a `guix pull` will have no effect on what `guix` you are using. Same\n+goes for `$HOME/.guix-profile/bin`, `guix install`, and installed packages.\n+\n+Helpfully, after a `guix pull` or `guix install`, a message will be printed like\n+so:\n+\n+```\n+hint: Consider setting the necessary environment variables by running:\n+\n+     GUIX_PROFILE=\"$HOME/.guix-profile\"\n+     . \"$GUIX_PROFILE/etc/profile\"\n+\n+Alternately, see `guix package --search-paths -p \"$HOME/.guix-profile\"'.\n+```\n+\n+However, this is somewhat tedious to do for both `guix pull` and `guix install`\n+for each user on the system that wants to properly use `guix`. I recommend that\n+you instead add an entry to `/etc/profile.d` instead. This is done by default\n+when installing the Debian package later than 1.2.0-4 and when using the shell\n+script installer.\n+\n+#### Instructions\n+\n+Create `/etc/profile.d/guix.sh` with the following content:\n+```sh\n+# _GUIX_PROFILE: `guix pull` profile\n+_GUIX_PROFILE=\"$HOME/.config/guix/current\"\n+if [ -L $_GUIX_PROFILE ]; then\n+  export PATH=\"$_GUIX_PROFILE/bin${PATH:+:}$PATH\"\n+  # Export INFOPATH so that the updated info pages can be found\n+  # and read by both /usr/bin/info and/or $GUIX_PROFILE/bin/info\n+  # When INFOPATH is unset, add a trailing colon so that Emacs\n+  # searches 'Info-default-directory-list'.\n+  export INFOPATH=\"$_GUIX_PROFILE/share/info:$INFOPATH\"\n+fi\n+\n+# GUIX_PROFILE: User's default profile\n+GUIX_PROFILE=\"$HOME/.guix-profile\"\n+[ -L $GUIX_PROFILE ] || return\n+GUIX_LOCPATH=\"$GUIX_PROFILE/lib/locale\"\n+export GUIX_PROFILE GUIX_LOCPATH\n+\n+[ -f \"$GUIX_PROFILE/etc/profile\" ] && . \"$GUIX_PROFILE/etc/profile\"\n+\n+# set XDG_DATA_DIRS to include Guix installations\n+export XDG_DATA_DIRS=\"$GUIX_PROFILE/share:${XDG_DATA_DIRS:-/usr/local/share/:/usr/share/}\"\n+```\n+\n+Please note that this will not take effect until the next shell or desktop\n+session (log out and log back in).\n+\n+### `guix pull` as root\n+\n+Before you do this, you need to read the section on [choosing your security\n+model][security-model] and adjust `guix` and `guix-daemon` flags according to\n+your choice, as invoking `guix pull` may pull substitutes from substitute\n+servers (which you may not want).\n+\n+As mentioned in a previous section, Guix expects\n+`${localstatedir}/guix/profiles/per-user/root/current-guix` to be populated with\n+`root`'s Guix profile, `guix pull`-ed and built by some former version of Guix.\n+However, this is not the case when we build from source. Therefore, we need to\n+perform a `guix pull` as `root`:\n+\n+```sh\n+sudo --login guix pull --branch=version-<latest-release-version>\n+# or\n+sudo --login guix pull --commit=<particular-commit>\n+```\n+\n+`guix pull` is quite a long process (especially if you're using\n+`--no-substitute`). If you encounter build problems, please refer to the\n+[troubleshooting section](#troubleshooting).\n+\n+Note that running a bare `guix pull` with no commit or branch specified will\n+pull the latest commit on Guix's master branch, which is likely fine, but not\n+recommended.\n+\n+If you installed Guix from source, you may get an error like the following:\n+```sh\n+error: while creating symlink '/root/.config/guix/current' No such file or directory\n+```\n+To resolve this, simply:\n+```\n+sudo mkdir -p /root/.config/guix\n+```\n+Then try the `guix pull` command again.\n+\n+After the `guix pull` finishes successfully,\n+`${localstatedir}/guix/profiles/per-user/root/current-guix` should be populated.\n+\n+#### Using the newly-pulled `guix` by restarting the daemon\n+\n+Depending on how you installed Guix, you should now make sure that your init\n+scripts and service configurations point to the newly-pulled `guix-daemon`.\n+\n+##### If you built Guix from source\n+\n+If you followed the instructions for [fixing argv\\[0\\]][fix-argv0], you can now\n+do the following:\n+\n+```sh\n+systemctl stop guix-daemon-original\n+systemctl disable guix-daemon-original\n+\n+systemctl enable guix-daemon\n+systemctl start guix-daemon\n+```\n+\n+##### If you installed Guix via the Debian/Ubuntu distribution packages\n+\n+You will need to create a `guix-daemon-latest` service which points to the new\n+`guix` rather than a pinned one.\n+\n+```sh\n+# Create guix-daemon-latest.service by modifying guix-daemon.service\n+sed -E -e \"s|/usr/bin/guix-daemon|/var/guix/profiles/per-user/root/current-guix/bin/guix-daemon|\" /etc/systemd/system/guix-daemon.service > /lib/systemd/system/guix-daemon-latest.service\n+chmod 664 /lib/systemd/system/guix-daemon-latest.service\n+\n+# Make systemd recognize the new service\n+systemctl daemon-reload\n+\n+# Make sure that the old guix-daemon.service is stopped and disabled\n+systemctl stop guix-daemon\n+systemctl disable guix-daemon\n+\n+# Make sure that the new guix-daemon-latest.service is started and enabled\n+systemctl enable guix-daemon-latest\n+systemctl start guix-daemon-latest\n+```\n+\n+##### If you installed Guix via lantw44's Arch Linux AUR package\n+\n+At the time of writing (July 5th, 2021) the systemd unit for \"updated Guix\" is\n+`guix-daemon-latest.service`, therefore, you should do the following:\n+\n+```sh\n+systemctl stop guix-daemon\n+systemctl disable guix-daemon\n+\n+systemctl enable guix-daemon-latest\n+systemctl start guix-daemon-latest\n+```\n+\n+##### Otherwise...\n+\n+Simply do:\n+\n+```sh\n+systemctl restart guix-daemon\n+```\n+\n+### Checking everything\n+\n+If you followed all the steps above to make your Guix setup \"prim and proper,\"\n+you can check that you did everything properly by running through this\n+checklist.\n+\n+1. `/etc/profile.d/guix.sh` should exist and be sourced at each shell login\n+\n+2. `guix describe` should not print `guix describe: error: failed to determine\n+   origin`, but rather something like:\n+\n+   ```\n+   Generation 38   Feb 22 2021 16:39:31    (current)\n+     guix f350df4\n+       repository URL: https://git.savannah.gnu.org/git/guix.git\n+       branch: version-1.2.0\n+       commit: f350df405fbcd5b9e27e6b6aa500da7f101f41e7\n+   ```\n+\n+3. `guix-daemon` should be running from `${localstatedir}/guix/profiles/per-user/root/current-guix`\n+\n+# Troubleshooting\n+\n+## Derivation failed to build\n+\n+When you see a build failure like below:\n+\n+```\n+building /gnu/store/...-foo-3.6.12.drv...\n+/ 'check' phasenote: keeping build directory `/tmp/guix-build-foo-3.6.12.drv-0'\n+builder for `/gnu/store/...-foo-3.6.12.drv' failed with exit code 1\n+build of /gnu/store/...-foo-3.6.12.drv failed\n+View build log at '/var/log/guix/drvs/../...-foo-3.6.12.drv.bz2'.\n+cannot build derivation `/gnu/store/...-qux-7.69.1.drv': 1 dependencies couldn't be built\n+cannot build derivation `/gnu/store/...-bar-3.16.5.drv': 1 dependencies couldn't be built\n+cannot build derivation `/gnu/store/...-baz-2.0.5.drv': 1 dependencies couldn't be built\n+guix time-machine: error: build of `/gnu/store/...-baz-2.0.5.drv' failed\n+```\n+\n+It means that `guix` failed to build a package named `foo`, which was a\n+dependency of `qux`, `bar`, and `baz`. Importantly, note that the last \"failed\"\n+line is not necessarily the root cause, the first \"failed\" line is.\n+\n+Most of the time, the build failure is due to a spurious test failure or the\n+package's build system/test suite breaking when running multi-threaded. To\n+rebuild _just_ this derivation in a single-threaded fashion (please don't forget\n+to add other `guix` flags like `--no-substitutes` as appropriate):\n+\n+```sh\n+$ guix build --cores=1 /gnu/store/...-foo-3.6.12.drv\n+```\n+\n+If the single-threaded rebuild did not succeed, you may need to dig deeper.\n+You may view `foo`'s build logs in `less` like so (please replace paths with the\n+path you see in the build failure output):\n+\n+```sh\n+$ bzcat /var/log/guix/drvs/../...-foo-3.6.12.drv.bz2 | less\n+```\n+\n+`foo`'s build directory is also preserved and available at\n+`/tmp/guix-build-foo-3.6.12.drv-0`. However, if you fail to build `foo` multiple\n+times, it may be `/tmp/...drv-1` or `/tmp/...drv-2`. Always consult the build\n+failure output for the most accurate, up-to-date information.\n+\n+### python(-minimal): [Errno 84] Invalid or incomplete multibyte or wide character\n+\n+This error occurs when your `$TMPDIR` (default: /tmp) exists on a filesystem\n+which rejects characters not present in the UTF-8 character code set. An example\n+is ZFS with the utf8only=on option set.\n+\n+More information: https://bugs.python.org/issue37584\n+\n+### GnuTLS: test-suite FAIL: status-request-revoked\n+\n+*The derivation is likely identified by: `/gnu/store/vhphki5sg9xkdhh2pbc8gi6vhpfzryf0-gnutls-3.6.12.drv`*\n+\n+This unfortunate error is most common for non-substitute builders who installed\n+Guix v1.2.0. The problem stems from the fact that one of GnuTLS's tests uses a\n+hardcoded certificate which expired on 2020-10-24.\n+\n+What's more unfortunate is that this GnuTLS derivation is somewhat special in\n+Guix's dependency graph and is not affected by the package transformation flags\n+like `--without-tests=`.\n+\n+The easiest solution for those encountering this problem is to install a newer\n+version of Guix. However, there are ways to work around this issue:\n+\n+#### Workaround 1: Using substitutes for this single derivation\n+\n+If you've authorized the official Guix build farm's key (more info\n+[here](./README.md#step-1-authorize-the-signing-keys)), then you can use\n+substitutes just for this single derivation by invoking the following:\n+\n+```sh\n+guix build --substitute-urls=\"https://ci.guix.gnu.org\" /gnu/store/vhphki5sg9xkdhh2pbc8gi6vhpfzryf0-gnutls-3.6.12.drv\n+```\n+\n+See [this section](./README.md#removing-authorized-keys) for instructions on how\n+to remove authorized keys if you don't want to keep the build farm's key\n+authorized.\n+\n+#### Workaround 2: Temporarily setting the system clock back\n+\n+This workaround was described [here](https://issues.guix.gnu.org/44559#5).\n+\n+Basically:\n+1. Turn off networking\n+2. Turn off NTP\n+3. Set system time to 2020-10-01\n+4. guix build --no-substitutes /gnu/store/vhphki5sg9xkdhh2pbc8gi6vhpfzryf0-gnutls-3.6.12.drv\n+5. Set system time back to accurate current time\n+6. Turn NTP back on\n+7. Turn networking back on\n+\n+### coreutils: FAIL: tests/tail-2/inotify-dir-recreate\n+\n+The inotify-dir-create test fails on \"remote\" filesystems such as overlayfs\n+(Docker's default filesystem) due to the filesystem being mistakenly recognized\n+as non-remote.\n+\n+A relatively easy workaround to this is to make sure that a somewhat traditional\n+filesystem is mounted at `/tmp` (where `guix-daemon` performs its builds). For\n+Docker users, this might mean [using a volume][docker/volumes], [binding\n+mounting][docker/bind-mnt] from host, or (for those with enough RAM and swap)\n+[mounting a tmpfs][docker/tmpfs] using the `--tmpfs` flag.\n+\n+Please see the following links for more details:\n+\n+- An upstream coreutils bug has been filed: [debbugs#47940](https://debbugs.gnu.org/cgi/bugreport.cgi?bug=47940)\n+- A Guix bug detailing the underlying problem has been filed: [guix-issues#47935](https://issues.guix.gnu.org/47935)\n+- A commit to skip this test in Guix has been merged into the core-updates branch:\n+[savannah/guix@6ba1058](https://git.savannah.gnu.org/cgit/guix.git/commit/?id=6ba1058df0c4ce5611c2367531ae5c3cdc729ab4)\n+\n+\n+[install-script]: #options-1-and-2-using-the-official-shell-installer-script-or-binary-tarball\n+[install-bin-tarball]: #options-1-and-2-using-the-official-shell-installer-script-or-binary-tarball\n+[install-fanquake-docker]: #option-3-using-fanquakes-docker-image\n+[install-distro-pkg]: #option-4-using-a-distribution-maintained-package\n+[install-source]: #option-5-building-from-source\n+\n+[fix-argv0]: #creating-and-starting-a-guix-daemon-original-service-with-a-fixed-argv0\n+[security-model]: ./README.md#choosing-your-security-model\n+\n+[docker/volumes]: https://docs.docker.com/storage/volumes/\n+[docker/bind-mnt]: https://docs.docker.com/storage/bind-mounts/\n+[docker/tmpfs]: https://docs.docker.com/storage/tmpfs/"
      },
      {
        "sha": "2bb464a40d45f0b8c70d5fca5ef1e3d9e82d3210",
        "filename": "contrib/guix/README.md",
        "status": "modified",
        "additions": 279,
        "deletions": 140,
        "changes": 419,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/README.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -9,83 +9,171 @@ downloads.\n \n We achieve bootstrappability by using Guix as a functional package manager.\n \n-## Requirements\n+# Requirements\n \n-Conservatively, a x86_64 machine with:\n+Conservatively, you will need an x86_64 machine with:\n \n - 16GB of free disk space on the partition that /gnu/store will reside in\n-- 8GB of free disk space per platform triple you're planning on building (see\n-  the `HOSTS` environment variable description)\n+- 8GB of free disk space **per platform triple** you're planning on building\n+  (see the `HOSTS` [environment variable description][env-vars-list])\n \n-## Setup\n+# Installation and Setup\n \n-### Installing Guix\n+If you don't have Guix installed and set up, please follow the instructions in\n+[INSTALL.md](./INSTALL.md)\n \n-If you're just testing this out, you can use the\n-[Dockerfile][fanquake/guix-docker] for convenience. It automatically speeds up\n-your builds by [using substitutes](#speeding-up-builds-with-substitute-servers).\n-If you don't want this behaviour, refer to the [next\n-section](#choosing-your-security-model).\n+# Usage\n \n-Otherwise, follow the [Guix installation guide][guix/bin-install].\n+If you haven't considered your security model yet, please read [the relevant\n+section](#choosing-your-security-model) before proceeding to perform a build.\n \n-> Note: For those who like to keep their filesystems clean, Guix is designed to\n-> be very standalone and _will not_ conflict with your system's package\n-> manager/existing setup. It _only_ touches `/var/guix`, `/gnu`, and\n-> `~/.config/guix`.\n+## Making the Xcode SDK available for macOS cross-compilation\n \n-### Choosing your security model\n+In order to perform a build for macOS (which is included in the default set of\n+platform triples to build), you'll need to extract the macOS SDK tarball using\n+tools found in the [`macdeploy` directory](../macdeploy/README.md).\n \n-Guix allows us to achieve better binary security by using our CPU time to build\n-everything from scratch. However, it doesn't sacrifice user choice in pursuit of\n-this: users can decide whether or not to bootstrap and to use substitutes\n-(pre-built packages).\n+You can then either point to the SDK using the `SDK_PATH` environment variable:\n \n-After installation, you may want to consider [adding substitute\n-servers](#speeding-up-builds-with-substitute-servers) from which to download\n-pre-built packages to speed up your build if that fits your security model (say,\n-if you're just testing that this works). Substitute servers are set up by\n-default if you're using the [Dockerfile][fanquake/guix-docker].\n+```sh\n+# Extract the SDK tarball to /path/to/parent/dir/of/extracted/SDK/Xcode-<foo>-<bar>-extracted-SDK-with-libcxx-headers\n+tar -C /path/to/parent/dir/of/extracted/SDK -xaf /path/to/Xcode-<foo>-<bar>-extracted-SDK-with-libcxx-headers.tar.gz\n \n-If you prefer not to use any substitutes, make sure to supply `--no-substitutes`\n-like in the following snippet. The first build will take a while, but the\n-resulting packages will be cached for future builds.\n+# Indicate where to locate the SDK tarball\n+export SDK_PATH=/path/to/parent/dir/of/extracted/SDK\n+```\n+\n+or extract it into `depends/SDKs`:\n \n ```sh\n-export ADDITIONAL_GUIX_COMMON_FLAGS='--no-substitutes'\n+mkdir -p depends/SDKs\n+tar -C depends/SDKs -xaf /path/to/SDK/tarball\n ```\n \n-Likewise, to perform a bootstrapped build (takes even longer):\n+## Building\n+\n+*The author highly recommends at least reading over the [common usage patterns\n+and examples](#common-guix-build-invocation-patterns-and-examples) section below\n+before starting a build. For a full list of customization options, see the\n+[recognized environment variables][env-vars-list] section.*\n+\n+To build Bitcoin Core reproducibly with all default options, invoke the\n+following from the top of a clean repository:\n \n ```sh\n-export ADDITIONAL_GUIX_COMMON_FLAGS='--no-substitutes' ADDITIONAL_GUIX_ENVIRONMENT_FLAGS='--bootstrap'\n+./contrib/guix/guix-build\n ```\n \n-### Using a version of Guix with `guix time-machine` capabilities\n+## Codesigning build outputs\n \n-> Note: This entire section can be skipped if you are already using a version of\n-> Guix that has [the `guix time-machine` command][guix/time-machine].\n+The `guix-codesign` command attaches codesignatures (produced by codesigners) to\n+existing non-codesigned outputs. Please see the [release process\n+documentation](/doc/release-process.md) for more context.\n \n-Once Guix is installed, if it doesn't have the `guix time-machine` command, pull\n-the latest `guix`.\n+It respects many of the same environment variable flags as `guix-build`, with 2\n+crucial differences:\n+\n+1. Since only Windows and macOS build outputs require codesigning, the `HOSTS`\n+   environment variable will have a sane default value of `x86_64-w64-mingw32\n+   x86_64-apple-darwin18` instead of all the platforms.\n+2. The `guix-codesign` command ***requires*** a `DETACHED_SIGS_REPO` flag.\n+    * _**DETACHED_SIGS_REPO**_\n+\n+      Set the directory where detached codesignatures can be found for the current\n+      Bitcoin Core version being built.\n+\n+      _REQUIRED environment variable_\n+\n+An invocation with all default options would look like:\n+\n+```\n+env DETACHED_SIGS_REPO=<path/to/bitcoin-detached-sigs> ./contrib/guix/guix-codesign\n+```\n+\n+## Cleaning intermediate work directories\n+\n+By default, `guix-build` leaves all intermediate files or \"work directories\"\n+(e.g. `depends/work`, `guix-build-*/distsrc-*`) intact at the end of a build so\n+that they are available to the user (to aid in debugging, etc.). However, these\n+directories usually take up a large amount of disk space. Therefore, a\n+`guix-clean` convenience script is provided which cleans the current `git`\n+worktree to save disk space:\n+\n+```\n+./contrib/guix/guix-clean\n+```\n+\n+\n+## Attesting to build outputs\n+\n+Much like how Gitian build outputs are attested to in a `gitian.sigs`\n+repository, Guix build outputs are attested to in the [`guix.sigs`\n+repository](https://github.com/bitcoin-core/guix.sigs).\n+\n+After you've cloned the `guix.sigs` repository, to attest to the current\n+worktree's commit/tag:\n+\n+```\n+env GUIX_SIGS_REPO=<path/to/guix.sigs> SIGNER=<gpg-key-name> ./contrib/guix/guix-attest\n+```\n+\n+See `./contrib/guix/guix-attest --help` for more information on the various ways\n+`guix-attest` can be invoked.\n+\n+## Verifying build output attestations\n+\n+After at least one other signer has uploaded their signatures to the `guix.sigs`\n+repository:\n+\n+```\n+git -C <path/to/guix.sigs> pull\n+env GUIX_SIGS_REPO=<path/to/guix.sigs> ./contrib/guix/guix-verify\n+```\n+\n+\n+## Common `guix-build` invocation patterns and examples\n+\n+### Keeping caches and SDKs outside of the worktree\n+\n+If you perform a lot of builds and have a bunch of worktrees, you may find it\n+more efficient to keep the depends tree's download cache, build cache, and SDKs\n+outside of the worktrees to avoid duplicate downloads and unnecessary builds. To\n+help with this situation, the `guix-build` script honours the `SOURCES_PATH`,\n+`BASE_CACHE`, and `SDK_PATH` environment variables and will pass them on to the\n+depends tree so that you can do something like:\n \n ```sh\n-guix pull --max-jobs=4 # change number of jobs accordingly\n+env SOURCES_PATH=\"$HOME/depends-SOURCES_PATH\" BASE_CACHE=\"$HOME/depends-BASE_CACHE\" SDK_PATH=\"$HOME/macOS-SDKs\" ./contrib/guix/guix-build\n ```\n \n-Make sure that you are using your current profile. (You are prompted to do this\n-at the end of the `guix pull`)\n+Note that the paths that these environment variables point to **must be\n+directories**, and **NOT symlinks to directories**.\n+\n+See the [recognized environment variables][env-vars-list] section for more\n+details.\n+\n+### Building a subset of platform triples\n \n-```bash\n-export PATH=\"${HOME}/.config/guix/current/bin${PATH:+:}$PATH\"\n+Sometimes you only want to build a subset of the supported platform triples, in\n+which case you can override the default list by setting the space-separated\n+`HOSTS` environment variable:\n+\n+```sh\n+env HOSTS='x86_64-w64-mingw32 x86_64-apple-darwin18' ./contrib/guix/guix-build\n ```\n \n+See the [recognized environment variables][env-vars-list] section for more\n+details.\n+\n ### Controlling the number of threads used by `guix` build commands\n \n+Depending on your system's RAM capacity, you may want to decrease the number of\n+threads used to decrease RAM usage or vice versa.\n+\n By default, the scripts under `./contrib/guix` will invoke all `guix` build\n commands with `--cores=\"$JOBS\"`. Note that `$JOBS` defaults to `$(nproc)` if not\n-specified. However, astute manual readers will also notice that there is a\n-`--max-jobs=` flag (which defaults to 1 if unspecified).\n+specified. However, astute manual readers will also notice that `guix` build\n+commands also accept a `--max-jobs=` flag (which defaults to 1 if unspecified).\n \n Here is the difference between `--cores=` and `--max-jobs=`:\n \n@@ -124,30 +212,18 @@ packages when the dependency graph allows for it, you may want to try:\n export JOBS=1 ADDITIONAL_GUIX_COMMON_FLAGS='--max-jobs=8'\n ```\n \n-## Usage\n-\n-### As a Tool for Deterministic Builds\n-\n-From the top of a clean Bitcoin Core repository:\n-\n-```sh\n-./contrib/guix/guix-build\n-```\n-\n-After the build finishes successfully (check the status code please), compare\n-hashes:\n-\n-```sh\n-find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n-```\n+See the [recognized environment variables][env-vars-list] section for more\n+details.\n \n-#### Recognized environment variables\n+## Recognized environment variables\n \n * _**HOSTS**_\n \n   Override the space-separated list of platform triples for which to perform a\n-  bootstrappable build. _(defaults to \"x86\\_64-linux-gnu arm-linux-gnueabihf\n-  aarch64-linux-gnu riscv64-linux-gnu powerpc64-linux-gnu powerpc64le-linux-gnu\n+  bootstrappable build.\n+\n+  _(defaults to \"x86\\_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu\n+  riscv64-linux-gnu powerpc64-linux-gnu powerpc64le-linux-gnu\n   x86\\_64-w64-mingw32 x86\\_64-apple-darwin18\")_\n \n * _**SOURCES_PATH**_\n@@ -156,18 +232,27 @@ find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n   depends tree. Setting this to the same directory across multiple builds of the\n   depends tree can eliminate unnecessary redownloading of package sources.\n \n+  The path that this environment variable points to **must be a directory**, and\n+  **NOT a symlink to a directory**.\n+\n * _**BASE_CACHE**_\n \n   Set the depends tree cache for built packages. This is passed through to the\n   depends tree. Setting this to the same directory across multiple builds of the\n   depends tree can eliminate unnecessary building of packages.\n \n+  The path that this environment variable points to **must be a directory**, and\n+  **NOT a symlink to a directory**.\n+\n * _**SDK_PATH**_\n \n   Set the path where _extracted_ SDKs can be found. This is passed through to\n   the depends tree. Note that this is should be set to the _parent_ directory of\n-  the actual SDK (e.g. SDK_PATH=$HOME/Downloads/macOS-SDKs instead of\n-  $HOME/Downloads/macOS-SDKs/Xcode-12.1-12A7403-extracted-SDK-with-libcxx-headers).\n+  the actual SDK (e.g. `SDK_PATH=$HOME/Downloads/macOS-SDKs` instead of\n+  `$HOME/Downloads/macOS-SDKs/Xcode-12.1-12A7403-extracted-SDK-with-libcxx-headers`).\n+\n+  The path that this environment variable points to **must be a directory**, and\n+  **NOT a symlink to a directory**.\n \n * _**JOBS**_\n \n@@ -178,13 +263,17 @@ find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n   - `make` as in `make --jobs=\"$JOBS\"`\n   - `xargs` as in `xargs -P\"$JOBS\"`\n \n+  See [here](#controlling-the-number-of-threads-used-by-guix-build-commands) for\n+  more details.\n+\n   _(defaults to the value of `nproc` outside the container)_\n \n * _**SOURCE_DATE_EPOCH**_\n \n   Override the reference UNIX timestamp used for bit-for-bit reproducibility,\n-  the variable name conforms to [standard][r12e/source-date-epoch]. _(defaults\n-  to the output of `$(git log --format=%at -1)`)_\n+  the variable name conforms to [standard][r12e/source-date-epoch].\n+\n+  _(defaults to the output of `$(git log --format=%at -1)`)_\n \n * _**V**_\n \n@@ -200,8 +289,7 @@ find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n \n   A whitespace-delimited list of URLs from which to download pre-built packages.\n   A URL is only used if its signing key is authorized (refer to the [substitute\n-  servers section](#speeding-up-builds-with-substitute-servers) for more\n-  details).\n+  servers section](#option-1-building-with-substitutes) for more details).\n \n * _**ADDITIONAL_GUIX_COMMON_FLAGS**_\n \n@@ -216,119 +304,168 @@ find output/ -type f -print0 | sort -z | xargs -r0 sha256sum\n   Additional flags to be passed to the invocation of `guix environment` inside\n   `guix time-machine`.\n \n-## Tips and Tricks\n-\n-### Speeding up builds with substitute servers\n+# Choosing your security model\n \n-_This whole section is automatically done in the convenience\n-[Dockerfiles][fanquake/guix-docker]_\n+No matter how you installed Guix, you need to decide on your security model for\n+building packages with Guix.\n \n-For those who are used to life in the fast _(and trustful)_ lane, you can\n-specify [substitute servers][guix/substitutes] from which to download pre-built\n-packages.\n+Guix allows us to achieve better binary security by using our CPU time to build\n+everything from scratch. However, it doesn't sacrifice user choice in pursuit of\n+this: users can decide whether or not to use **substitutes** (pre-built\n+packages).\n+\n+## Option 1: Building with substitutes\n+\n+### Step 1: Authorize the signing keys\n+\n+Depending on the installation procedure you followed, you may have already\n+authorized the Guix build farm key. In particular, the official shell installer\n+script asks you if you want the key installed, and the debian distribution\n+package authorized the key during installation.\n+\n+You can check the current list of authorized keys at `/etc/guix/acl`.\n+\n+At the time of writing, a `/etc/guix/acl` with just the Guix build farm key\n+authorized looks something like:\n+\n+```lisp\n+(acl\n+ (entry\n+  (public-key\n+   (ecc\n+    (curve Ed25519)\n+    (q #8D156F295D24B0D9A86FA5741A840FF2D24F60F7B6C4134814AD55625971B394#)\n+    )\n+   )\n+  (tag\n+   (guix import)\n+   )\n+  )\n+ )\n+```\n \n-> For those who only want to use substitutes from the official Guix build farm\n-> and have authorized the build farm's signing key during Guix's installation,\n-> you don't need to do anything.\n+If you've determined that the official Guix build farm key hasn't been\n+authorized, and you would like to authorize it, run the following as root:\n \n-#### Step 1: Authorize the signing keys\n+```\n+guix archive --authorize < /var/guix/profiles/per-user/root/current-guix/share/guix/ci.guix.gnu.org.pub\n+```\n \n-For the official Guix build farm at https://ci.guix.gnu.org, run as root:\n+If\n+`/var/guix/profiles/per-user/root/current-guix/share/guix/ci.guix.gnu.org.pub`\n+doesn't exist, try:\n \n+```sh\n+guix archive --authorize < <PREFIX>/share/guix/ci.guix.gnu.org.pub\n ```\n-guix archive --authorize < ~root/.config/guix/current/share/guix/ci.guix.gnu.org.pub\n-```\n+\n+Where `<PREFIX>` is likely:\n+- `/usr` if you installed from a distribution package\n+- `/usr/local` if you installed Guix from source and didn't supply any\n+  prefix-modifying flags to Guix's `./configure`\n \n For dongcarl's substitute server at https://guix.carldong.io, run as root:\n \n ```sh\n wget -qO- 'https://guix.carldong.io/signing-key.pub' | guix archive --authorize\n ```\n \n-#### Step 2: Specify the substitute servers\n+#### Removing authorized keys\n \n-The official Guix build farm at https://ci.guix.gnu.org is automatically used\n-unless the `--no-substitutes` flag is supplied.\n+To remove previously authorized keys, simply edit `/etc/guix/acl` and remove the\n+`(entry (public-key ...))` entry.\n \n-This can be overridden for all `guix` invocations by passing the\n-`--substitute-urls` option to your invocation of `guix-daemon`. This can also be\n-overridden on a call-by-call basis by passing the same `--substitute-urls`\n-option to client tools such at `guix environment`.\n+### Step 2: Specify the substitute servers\n \n-To use dongcarl's substitute server for Bitcoin Core builds after having\n-[authorized his signing key](#authorize-the-signing-keys):\n+Once its key is authorized, the official Guix build farm at\n+https://ci.guix.gnu.org is automatically used unless the `--no-substitutes` flag\n+is supplied. This default list of substitute servers is overridable both on a\n+`guix-daemon` level and when you invoke `guix` commands. See examples below for\n+the various ways of adding dongcarl's substitute server after having [authorized\n+his signing key](#authorize-the-signing-keys).\n \n-```\n-export SUBSTITUTE_URLS='https://guix.carldong.io https://ci.guix.gnu.org'\n+Change the **default list** of substitute servers by starting `guix-daemon` with\n+the `--substitute-urls` option (you will likely need to edit your init script):\n+\n+```sh\n+guix-daemon <cmd> --substitute-urls='https://guix.carldong.io https://ci.guix.gnu.org'\n ```\n \n-## Troubleshooting\n+Override the default list of substitute servers by passing the\n+`--substitute-urls` option for invocations of `guix` commands:\n \n-### Derivation failed to build\n+```sh\n+guix <cmd> --substitute-urls='https://guix.carldong.io https://ci.guix.gnu.org'\n+```\n \n-When you see a build failure like below:\n+For scripts under `./contrib/guix`, set the `SUBSTITUTE_URLS` environment\n+variable:\n \n-```\n-building /gnu/store/...-foo-3.6.12.drv...\n-/ 'check' phasenote: keeping build directory `/tmp/guix-build-foo-3.6.12.drv-0'\n-builder for `/gnu/store/...-foo-3.6.12.drv' failed with exit code 1\n-build of /gnu/store/...-foo-3.6.12.drv failed\n-View build log at '/var/log/guix/drvs/../...-foo-3.6.12.drv.bz2'.\n-cannot build derivation `/gnu/store/...-qux-7.69.1.drv': 1 dependencies couldn't be built\n-cannot build derivation `/gnu/store/...-bar-3.16.5.drv': 1 dependencies couldn't be built\n-cannot build derivation `/gnu/store/...-baz-2.0.5.drv': 1 dependencies couldn't be built\n-guix time-machine: error: build of `/gnu/store/...-baz-2.0.5.drv' failed\n+```sh\n+export SUBSTITUTE_URLS='https://guix.carldong.io https://ci.guix.gnu.org'\n ```\n \n-It means that `guix` failed to build a package named `foo`, which was a\n-dependency of `qux`, `bar`, and `baz`. Importantly, note that the last \"failed\"\n-line is not necessarily the root cause, the first \"failed\" line is.\n+## Option 2: Disabling substitutes on an ad-hoc basis\n \n-Most of the time, the build failure is due to a spurious test failure or the\n-package's build system/test suite breaking when running multi-threaded. To\n-rebuild _just_ this derivation in a single-threaded fashion:\n+If you prefer not to use any substitutes, make sure to supply `--no-substitutes`\n+like in the following snippet. The first build will take a while, but the\n+resulting packages will be cached for future builds.\n \n+For direct invocations of `guix`:\n ```sh\n-$ guix build --cores=1 /gnu/store/...-foo-3.6.12.drv\n+guix <cmd> --no-substitutes\n ```\n \n-If the single-threaded rebuild did not succeed, you may need to dig deeper.\n-You may view `foo`'s build logs in `less` like so (please replace paths with the\n-path you see in the build failure output):\n-\n+For the scripts under `./contrib/guix/`:\n ```sh\n-$ bzcat /var/log/guix/drvs/../...-foo-3.6.12.drv.bz2 | less\n+export ADDITIONAL_GUIX_COMMON_FLAGS='--no-substitutes'\n ```\n \n-`foo`'s build directory is also preserved and available at\n-`/tmp/guix-build-foo-3.6.12.drv-0`. However, if you fail to build `foo` multiple\n-times, it may be `/tmp/...drv-1` or `/tmp/...drv-2`. Always consult the build\n-failure output for the most accurate, up-to-date information.\n+## Option 3: Disabling substitutes by default\n+\n+`guix-daemon` accepts a `--no-substitutes` flag, which will make sure that,\n+unless otherwise overridden by a command line invocation, no substitutes will be\n+used.\n \n-#### python(-minimal): [Errno 84] Invalid or incomplete multibyte or wide character\n+If you start `guix-daemon` using an init script, you can edit said script to\n+supply this flag.\n \n-This error occurs when your `$TMPDIR` (default: /tmp) exists on a filesystem\n-which rejects characters not present in the UTF-8 character code set. An example\n-is ZFS with the utf8only=on option set.\n \n-More information: https://bugs.python.org/issue37584\n+# Purging/Uninstalling Guix\n \n-## FAQ\n+In the extraordinarily rare case where you messed up your Guix installation in\n+an irreversible way, you may want to completely purge Guix from your system and\n+start over.\n \n-### How can I trust the binary installation?\n+1. Uninstall Guix itself according to the way you installed it (e.g. `sudo apt\n+   purge guix` for Ubuntu packaging, `sudo make uninstall` for a build from source).\n+2. Remove all build users and groups\n \n-As mentioned at the bottom of [this manual page][guix/bin-install]:\n+   You may check for relevant users and groups using:\n \n-> The binary installation tarballs can be (re)produced and verified simply by\n-> running the following command in the Guix source tree:\n->\n->     make guix-binary.x86_64-linux.tar.xz\n+   ```\n+   getent passwd | grep guix\n+   getent group | grep guix\n+   ```\n \n-### Is Guix packaged in my operating system?\n+   Then, you may remove users and groups using:\n \n-Guix is shipped starting with [Debian Bullseye][debian/guix-bullseye] and\n-[Ubuntu 21.04 \"Hirsute Hippo\"][ubuntu/guix-hirsute]. Other operating systems\n-are working on packaging Guix as well.\n+   ```\n+   sudo userdel <user>\n+   sudo groupdel <group>\n+   ```\n+\n+3. Remove all possible Guix-related directories\n+    - `/var/guix/`\n+    - `/var/log/guix/`\n+    - `/gnu/`\n+    - `/etc/guix/`\n+    - `/home/*/.config/guix/`\n+    - `/home/*/.cache/guix/`\n+    - `/home/*/.guix-profile/`\n+    - `/root/.config/guix/`\n+    - `/root/.cache/guix/`\n+    - `/root/.guix-profile/`\n \n [b17e]: http://bootstrappable.org/\n [r12e/source-date-epoch]: https://reproducible-builds.org/docs/source-date-epoch/\n@@ -343,3 +480,5 @@ are working on packaging Guix as well.\n [debian/guix-bullseye]: https://packages.debian.org/bullseye/guix\n [ubuntu/guix-hirsute]: https://packages.ubuntu.com/hirsute/guix\n [fanquake/guix-docker]: https://github.com/fanquake/core-review/tree/master/guix\n+\n+[env-vars-list]: #recognized-environment-variables"
      },
      {
        "sha": "dcf709b542573ae819e95b8e8178b93cf6d1c6fc",
        "filename": "contrib/guix/guix-attest",
        "status": "modified",
        "additions": 25,
        "deletions": 8,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-attest",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-attest",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-attest?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -18,7 +18,7 @@ source \"$(dirname \"${BASH_SOURCE[0]}\")/libexec/prelude.bash\"\n # Required non-builtin commands should be invokable\n ################\n \n-check_tools cat env basename mkdir xargs find\n+check_tools cat env basename mkdir diff sort\n if [ -z \"$NO_SIGN\" ]; then\n     check_tools gpg\n fi\n@@ -159,6 +159,20 @@ Hint: You may wish to remove the existing attestations and their signatures by\n EOF\n }\n \n+# Given a document with unix line endings (just <LF>) in stdin, make all lines\n+# end in <CR><LF> and make sure there's no trailing <LF> at the end of the file.\n+#\n+# This is necessary as cleartext signatures are calculated on text after their\n+# line endings are canonicalized.\n+#\n+# For more information:\n+#     1. https://security.stackexchange.com/a/104261\n+#     2. https://datatracker.ietf.org/doc/html/rfc4880#section-7.1\n+#\n+rfc4880_normalize_document() {\n+    sed 's/$/\\r/' | head -c -2\n+}\n+\n echo \"Attesting to build outputs for version: '${VERSION}'\"\n echo \"\"\n \n@@ -174,7 +188,8 @@ mkdir -p \"$outsigdir\"\n         cat \"${noncodesigned_fragments[@]}\" \\\n             | sort -u \\\n             | sort -k2 \\\n-                   > \"$temp_noncodesigned\"\n+            | rfc4880_normalize_document \\\n+                > \"$temp_noncodesigned\"\n         if [ -e noncodesigned.SHA256SUMS ]; then\n             # The SHA256SUMS already exists, make sure it's exactly what we\n             # expect, error out if not\n@@ -192,27 +207,28 @@ mkdir -p \"$outsigdir\"\n         exit 1\n     fi\n \n-    temp_codesigned=\"$(mktemp)\"\n-    trap 'rm -rf -- \"$temp_codesigned\"' EXIT\n+    temp_all=\"$(mktemp)\"\n+    trap 'rm -rf -- \"$temp_all\"' EXIT\n \n     if (( ${#codesigned_fragments[@]} )); then\n         # Note: all.SHA256SUMS attests to all of $sha256sum_fragments, but is\n         #       not needed if there are no $codesigned_fragments\n         cat \"${sha256sum_fragments[@]}\" \\\n             | sort -u \\\n             | sort -k2 \\\n-                   > \"$temp_codesigned\"\n-        if [ -e codesigned.SHA256SUMS ]; then\n+            | rfc4880_normalize_document \\\n+                > \"$temp_all\"\n+        if [ -e all.SHA256SUMS ]; then\n             # The SHA256SUMS already exists, make sure it's exactly what we\n             # expect, error out if not\n-            if diff -u all.SHA256SUMS \"$temp_codesigned\"; then\n+            if diff -u all.SHA256SUMS \"$temp_all\"; then\n                 echo \"An all.SHA256SUMS file already exists for '${VERSION}' and is up-to-date.\"\n             else\n                 shasum_already_exists all.SHA256SUMS\n                 exit 1\n             fi\n         else\n-            mv \"$temp_codesigned\" codesigned.SHA256SUMS\n+            mv \"$temp_all\" all.SHA256SUMS\n         fi\n     else\n         # It is fine to have the codesigned outputs be missing (perhaps the\n@@ -226,6 +242,7 @@ mkdir -p \"$outsigdir\"\n         for i in *.SHA256SUMS; do\n             if [ ! -e \"$i\".asc ]; then\n                 gpg --detach-sign \\\n+                    --digest-algo sha256 \\\n                     --local-user \"$gpg_key_name\" \\\n                     --armor \\\n                     --output \"$i\".asc \"$i\""
      },
      {
        "sha": "dd7229b6fa6dc61dd882c218671db85074580bfa",
        "filename": "contrib/guix/guix-build",
        "status": "modified",
        "additions": 27,
        "deletions": 4,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-build",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-build",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-build?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -18,7 +18,7 @@ source \"$(dirname \"${BASH_SOURCE[0]}\")/libexec/prelude.bash\"\n # Required non-builtin commands should be invocable\n ################\n \n-check_tools cat mkdir make git guix\n+check_tools cat mkdir make getent curl git guix\n \n ################\n # GUIX_BUILD_OPTIONS should be empty\n@@ -186,6 +186,29 @@ fi\n #\n # However, the internal API is likely to change more than the CLI invocation\n \n+################\n+# Services database must have basic entries\n+################\n+\n+if ! getent services http https ftp > /dev/null 2>&1; then\n+cat << EOF\n+ERR: Your system's C library can not find service database entries for at least\n+     one of the following services: http, https, ftp.\n+\n+Hint: Most likely, /etc/services does not exist yet (common for docker images\n+      and minimal distros), or you don't have permissions to access it.\n+\n+      If /etc/services does not exist yet, you may want to install the\n+      appropriate package for your distro which provides it.\n+\n+          On Debian/Ubuntu: netbase\n+          On Arch Linux: iana-etc\n+\n+      For more information, see: getent(1), services(5)\n+\n+EOF\n+\n+fi\n \n #########\n # SETUP #\n@@ -209,14 +232,14 @@ host_to_commonname() {\n }\n \n # Determine the reference time used for determinism (overridable by environment)\n-SOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:-$(git log --format=%at -1)}\"\n+SOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:-$(git -c log.showSignature=false log --format=%at -1)}\"\n \n # Execute \"$@\" in a pinned, possibly older version of Guix, for reproducibility\n # across time.\n time-machine() {\n     # shellcheck disable=SC2086\n-    guix time-machine --url=https://github.com/dongcarl/guix.git \\\n-                      --commit=490e39ff303f4f6873a04bfb8253755bdae1b29c \\\n+    guix time-machine --url=https://git.savannah.gnu.org/git/guix.git \\\n+                      --commit=aa34d4d28dfe25ba47d5800d05000fb7221788c0 \\\n                       --cores=\"$JOBS\" \\\n                       --keep-failed \\\n                       --fallback \\"
      },
      {
        "sha": "3f464f89e61d0e223aae22a760d4b19d71d61cb9",
        "filename": "contrib/guix/guix-codesign",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-codesign",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-codesign",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-codesign?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -220,20 +220,20 @@ fi\n JOBS=\"${JOBS:-$(nproc)}\"\n \n # Determine the reference time used for determinism (overridable by environment)\n-SOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:-$(git log --format=%at -1)}\"\n+SOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:-$(git -c log.showSignature=false log --format=%at -1)}\"\n \n # Execute \"$@\" in a pinned, possibly older version of Guix, for reproducibility\n # across time.\n time-machine() {\n     # shellcheck disable=SC2086\n-    guix time-machine --url=https://github.com/dongcarl/guix.git \\\n-         --commit=490e39ff303f4f6873a04bfb8253755bdae1b29c \\\n-         --cores=\"$JOBS\" \\\n-         --keep-failed \\\n-         --fallback \\\n-         ${SUBSTITUTE_URLS:+--substitute-urls=\"$SUBSTITUTE_URLS\"} \\\n-         ${ADDITIONAL_GUIX_COMMON_FLAGS} ${ADDITIONAL_GUIX_TIMEMACHINE_FLAGS} \\\n-         -- \"$@\"\n+    guix time-machine --url=https://git.savannah.gnu.org/git/guix.git \\\n+                      --commit=aa34d4d28dfe25ba47d5800d05000fb7221788c0 \\\n+                      --cores=\"$JOBS\" \\\n+                      --keep-failed \\\n+                      --fallback \\\n+                      ${SUBSTITUTE_URLS:+--substitute-urls=\"$SUBSTITUTE_URLS\"} \\\n+                      ${ADDITIONAL_GUIX_COMMON_FLAGS} ${ADDITIONAL_GUIX_TIMEMACHINE_FLAGS} \\\n+                      -- \"$@\"\n }\n \n # Make sure an output directory exists for our builds"
      },
      {
        "sha": "e4863f115b94d624e8ac8f506612085f9c700c46",
        "filename": "contrib/guix/guix-verify",
        "status": "modified",
        "additions": 27,
        "deletions": 1,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-verify",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/guix-verify",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/guix-verify?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -28,7 +28,11 @@ cmd_usage() {\n cat <<EOF\n Synopsis:\n \n-    env GUIX_SIGS_REPO=<path/to/guix.sigs> ./contrib/guix/guix-verify\n+    env GUIX_SIGS_REPO=<path/to/guix.sigs> [ SIGNER=<signer> ] ./contrib/guix/guix-verify\n+\n+Example overriding signer's manifest to use as base\n+\n+    env GUIX_SIGS_REPO=/home/dongcarl/guix.sigs SIGNER=achow101 ./contrib/guix/guix-verify\n \n EOF\n }\n@@ -92,6 +96,17 @@ echo \"--------------------\"\n echo \"\"\n if (( ${#all_noncodesigned[@]} )); then\n     compare_noncodesigned=\"${all_noncodesigned[0]}\"\n+    if [[ -n \"$SIGNER\" ]]; then\n+        signer_noncodesigned=\"$OUTSIGDIR_BASE/$SIGNER/noncodesigned.SHA256SUMS\"\n+        if [[ -f \"$signer_noncodesigned\" ]]; then\n+            echo \"Using $SIGNER's manifest as the base to compare against\"\n+            compare_noncodesigned=\"$signer_noncodesigned\"\n+        else\n+            echo \"Unable to find $SIGNER's manifest, using the first one found\"\n+        fi\n+    else\n+        echo \"No SIGNER provided, using the first manifest found\"\n+    fi\n \n     for current_manifest in \"${all_noncodesigned[@]}\"; do\n         verify \"$compare_noncodesigned\" \"$current_manifest\"\n@@ -112,6 +127,17 @@ echo \"--------------------\"\n echo \"\"\n if (( ${#all_all[@]} )); then\n     compare_all=\"${all_all[0]}\"\n+    if [[ -n \"$SIGNER\" ]]; then\n+        signer_all=\"$OUTSIGDIR_BASE/$SIGNER/all.SHA256SUMS\"\n+        if [[ -f \"$signer_all\" ]]; then\n+            echo \"Using $SIGNER's manifest as the base to compare against\"\n+            compare_all=\"$signer_all\"\n+        else\n+            echo \"Unable to find $SIGNER's manifest, using the first one found\"\n+        fi\n+    else\n+        echo \"No SIGNER provided, using the first manifest found\"\n+    fi\n \n     for current_manifest in \"${all_all[@]}\"; do\n         verify \"$compare_all\" \"$current_manifest\""
      },
      {
        "sha": "356bd700701ed4f22d69cf66fb2749cad9645eb0",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -227,7 +227,6 @@ GIT_ARCHIVE=\"${DIST_ARCHIVE_BASE}/${DISTNAME}.tar.gz\"\n # Create the source tarball if not already there\n if [ ! -e \"$GIT_ARCHIVE\" ]; then\n     mkdir -p \"$(dirname \"$GIT_ARCHIVE\")\"\n-    touch \"${DIST_ARCHIVE_BASE}\"/SKIPATTEST.TAG\n     git archive --prefix=\"${DISTNAME}/\" --output=\"$GIT_ARCHIVE\" HEAD\n fi\n \n@@ -254,6 +253,10 @@ esac\n # CXXFLAGS\n HOST_CXXFLAGS=\"$HOST_CFLAGS\"\n \n+case \"$HOST\" in\n+    arm-linux-gnueabihf) HOST_CXXFLAGS=\"${HOST_CXXFLAGS} -Wno-psabi\" ;;\n+esac\n+\n # LDFLAGS\n case \"$HOST\" in\n     *linux*)  HOST_LDFLAGS=\"-Wl,--as-needed -Wl,--dynamic-linker=$glibc_dynamic_linker -static-libstdc++ -Wl,-O2\" ;;"
      },
      {
        "sha": "5805006053706a47c6b36e4e41b8494eabece7b0",
        "filename": "contrib/guix/manifest.scm",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/manifest.scm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/guix/manifest.scm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/manifest.scm?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -156,7 +156,7 @@ chain for \" target \" development.\"))\n (define* (make-bitcoin-cross-toolchain target\n                                        #:key\n                                        (base-gcc-for-libc gcc-7)\n-                                       (base-kernel-headers linux-libre-headers-5.4)\n+                                       (base-kernel-headers linux-libre-headers-4.9)\n                                        (base-libc (make-glibc-without-ssp glibc-2.24))\n                                        (base-gcc (make-gcc-rpath-link base-gcc)))\n   \"Convenience wrapper around MAKE-CROSS-TOOLCHAIN with default values\n@@ -647,7 +647,9 @@ inspecting signatures in Mach-O binaries.\")\n                  osslsigncode))\n           ((string-contains target \"-linux-\")\n            (list (cond ((string-contains target \"riscv64-\")\n-                        (make-bitcoin-cross-toolchain target #:base-libc glibc-2.27/bitcoin-patched))\n+                        (make-bitcoin-cross-toolchain target\n+                                                      #:base-libc glibc-2.27/bitcoin-patched\n+                                                      #:base-kernel-headers linux-libre-headers-4.19))\n                        (else\n                         (make-bitcoin-cross-toolchain target)))))\n           ((string-contains target \"darwin\")"
      },
      {
        "sha": "dd4d862dee504057659f82da9e2a19218b22df7d",
        "filename": "contrib/install_db4.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/install_db4.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/install_db4.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/install_db4.sh?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -221,10 +221,10 @@ EOF\n # The packaged config.guess and config.sub are ancient (2009) and can cause build issues.\n # Replace them with modern versions.\n # See https://github.com/bitcoin/bitcoin/issues/16064\n-CONFIG_GUESS_URL='https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=55eaf3e779455c4e5cc9f82efb5278be8f8f900b'\n-CONFIG_GUESS_HASH='2d1ff7bca773d2ec3c6217118129220fa72d8adda67c7d2bf79994b3129232c1'\n-CONFIG_SUB_URL='https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=55eaf3e779455c4e5cc9f82efb5278be8f8f900b'\n-CONFIG_SUB_HASH='3a4befde9bcdf0fdb2763fc1bfa74e8696df94e1ad7aac8042d133c8ff1d2e32'\n+CONFIG_GUESS_URL='https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=4550d2f15b3a7ce2451c1f29500b9339430c877f'\n+CONFIG_GUESS_HASH='c8f530e01840719871748a8071113435bdfdf75b74c57e78e47898edea8754ae'\n+CONFIG_SUB_URL='https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=4550d2f15b3a7ce2451c1f29500b9339430c877f'\n+CONFIG_SUB_HASH='3969f7d5f6967ccc6f792401b8ef3916a1d1b1d0f0de5a4e354c95addb8b800e'\n \n rm -f \"dist/config.guess\"\n rm -f \"dist/config.sub\""
      },
      {
        "sha": "1bb8b2aa17833892fd37bba4ca0797ae0f0150d3",
        "filename": "contrib/macdeploy/README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/macdeploy/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/macdeploy/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/README.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,7 +16,10 @@ Our current macOS SDK\n (`Xcode-12.1-12A7403-extracted-SDK-with-libcxx-headers.tar.gz`) can be\n extracted from\n [Xcode_12.1.xip](https://download.developer.apple.com/Developer_Tools/Xcode_12.1/Xcode_12.1.xip).\n-An Apple ID is needed to download this.\n+Alternatively, after logging in to your account go to 'Downloads', then 'More'\n+and look for [`Xcode_12.1`](https://download.developer.apple.com/Developer_Tools/Xcode_12.1/Xcode_12.1.xip).\n+An Apple ID and cookies enabled for the hostname are needed to download this.\n+The `sha256sum` of the archive should be `612443b1894b39368a596ea1607f30cbb0481ad44d5e29c75edb71a6d2cf050f`.\n \n After Xcode version 7.x, Apple started shipping the `Xcode.app` in a `.xip`\n archive. This makes the SDK less-trivial to extract on non-macOS machines. One\n@@ -76,7 +79,7 @@ and its `libLTO.so` rather than those from `llvmgcc`, as it was originally done\n \n To complicate things further, all builds must target an Apple SDK. These SDKs are free to\n download, but not redistributable. To obtain it, register for an Apple Developer Account,\n-then download [Xcode_11.3.1](https://download.developer.apple.com/Developer_Tools/Xcode_11.3.1/Xcode_11.3.1.xip).\n+then download [Xcode_12.1](https://download.developer.apple.com/Developer_Tools/Xcode_12.1/Xcode_12.1.xip).\n \n This file is many gigabytes in size, but most (but not all) of what we need is\n contained only in a single directory:"
      },
      {
        "sha": "055a932eee4939595a76527774cbd2422f094fc5",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 10,
        "deletions": 111,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,7 +16,6 @@\n # along with this program.  If not, see <http://www.gnu.org/licenses/>.\n #\n \n-import plistlib\n import sys, re, os, shutil, stat, os.path\n from argparse import ArgumentParser\n from ds_store import DSStore\n@@ -53,7 +52,7 @@ class FrameworkInfo(object):\n             return False\n     \n     def __str__(self):\n-        return f\"\"\" Framework name: {frameworkName}\n+        return f\"\"\" Framework name: {self.frameworkName}\n  Framework directory: {self.frameworkDirectory}\n  Framework path: {self.frameworkPath}\n  Binary name: {self.binaryName}\n@@ -85,8 +84,8 @@ class FrameworkInfo(object):\n         if line == \"\":\n             return None\n         \n-        # Don't deploy system libraries (exception for libQtuitools and libQtlucene).\n-        if line.startswith(\"/System/Library/\") or line.startswith(\"@executable_path\") or (line.startswith(\"/usr/lib/\") and \"libQt\" not in line):\n+        # Don't deploy system libraries\n+        if line.startswith(\"/System/Library/\") or line.startswith(\"@executable_path\") or line.startswith(\"/usr/lib/\"):\n             return None\n         \n         m = cls.reOLine.match(line)\n@@ -287,14 +286,6 @@ def copyFramework(framework: FrameworkInfo, path: str, verbose: int) -> Optional\n             if verbose:\n                 print(\"Copied Contents:\", fromContentsDir)\n                 print(\" to:\", toContentsDir)\n-    elif framework.frameworkName.startswith(\"libQtGui\"): # Copy qt_menu.nib (applies to non-framework layout)\n-        qtMenuNibSourcePath = os.path.join(framework.frameworkDirectory, \"Resources\", \"qt_menu.nib\")\n-        qtMenuNibDestinationPath = os.path.join(path, \"Contents\", \"Resources\", \"qt_menu.nib\")\n-        if os.path.exists(qtMenuNibSourcePath) and not os.path.exists(qtMenuNibDestinationPath):\n-            shutil.copytree(qtMenuNibSourcePath, qtMenuNibDestinationPath, symlinks=True)\n-            if verbose:\n-                print(\"Copied for libQtGui:\", qtMenuNibSourcePath)\n-                print(\" to:\", qtMenuNibDestinationPath)\n     \n     return toPath\n \n@@ -351,115 +342,20 @@ def deployFrameworksForAppBundle(applicationBundle: ApplicationBundleInfo, strip\n         return deployFrameworks(frameworks, applicationBundle.path, applicationBundle.binaryPath, strip, verbose)\n \n def deployPlugins(appBundleInfo: ApplicationBundleInfo, deploymentInfo: DeploymentInfo, strip: bool, verbose: int):\n-    # Lookup available plugins, exclude unneeded\n     plugins = []\n     if deploymentInfo.pluginPath is None:\n         return\n     for dirpath, dirnames, filenames in os.walk(deploymentInfo.pluginPath):\n         pluginDirectory = os.path.relpath(dirpath, deploymentInfo.pluginPath)\n-        if pluginDirectory == \"designer\":\n-            # Skip designer plugins\n-            continue\n-        elif pluginDirectory == \"printsupport\":\n-            # Skip printsupport plugins\n-            continue\n-        elif pluginDirectory == \"imageformats\":\n-            # Skip imageformats plugins\n+\n+        if pluginDirectory not in ['styles', 'platforms']:\n             continue\n-        elif pluginDirectory == \"sqldrivers\":\n-            # Deploy the sql plugins only if QtSql is in use\n-            if not deploymentInfo.usesFramework(\"QtSql\"):\n-                continue\n-        elif pluginDirectory == \"script\":\n-            # Deploy the script plugins only if QtScript is in use\n-            if not deploymentInfo.usesFramework(\"QtScript\"):\n-                continue\n-        elif pluginDirectory == \"qmltooling\" or pluginDirectory == \"qml1tooling\":\n-            # Deploy the qml plugins only if QtDeclarative is in use\n-            if not deploymentInfo.usesFramework(\"QtDeclarative\"):\n-                continue\n-        elif pluginDirectory == \"bearer\":\n-            # Deploy the bearer plugins only if QtNetwork is in use\n-            if not deploymentInfo.usesFramework(\"QtNetwork\"):\n-                continue\n-        elif pluginDirectory == \"position\":\n-            # Deploy the position plugins only if QtPositioning is in use\n-            if not deploymentInfo.usesFramework(\"QtPositioning\"):\n-                continue\n-        elif pluginDirectory == \"sensors\" or pluginDirectory == \"sensorgestures\":\n-            # Deploy the sensor plugins only if QtSensors is in use\n-            if not deploymentInfo.usesFramework(\"QtSensors\"):\n-                continue\n-        elif pluginDirectory == \"audio\" or pluginDirectory == \"playlistformats\":\n-            # Deploy the audio plugins only if QtMultimedia is in use\n-            if not deploymentInfo.usesFramework(\"QtMultimedia\"):\n-                continue\n-        elif pluginDirectory == \"mediaservice\":\n-            # Deploy the mediaservice plugins only if QtMultimediaWidgets is in use\n-            if not deploymentInfo.usesFramework(\"QtMultimediaWidgets\"):\n-                continue\n-        elif pluginDirectory == \"canbus\":\n-            # Deploy the canbus plugins only if QtSerialBus is in use\n-            if not deploymentInfo.usesFramework(\"QtSerialBus\"):\n-                continue\n-        elif pluginDirectory == \"webview\":\n-            # Deploy the webview plugins only if QtWebView is in use\n-            if not deploymentInfo.usesFramework(\"QtWebView\"):\n-                continue\n-        elif pluginDirectory == \"gamepads\":\n-            # Deploy the webview plugins only if QtGamepad is in use\n-            if not deploymentInfo.usesFramework(\"QtGamepad\"):\n-                continue\n-        elif pluginDirectory == \"geoservices\":\n-            # Deploy the webview plugins only if QtLocation is in use\n-            if not deploymentInfo.usesFramework(\"QtLocation\"):\n-                continue\n-        elif pluginDirectory == \"texttospeech\":\n-            # Deploy the texttospeech plugins only if QtTextToSpeech is in use\n-            if not deploymentInfo.usesFramework(\"QtTextToSpeech\"):\n-                continue\n-        elif pluginDirectory == \"virtualkeyboard\":\n-            # Deploy the virtualkeyboard plugins only if QtVirtualKeyboard is in use\n-            if not deploymentInfo.usesFramework(\"QtVirtualKeyboard\"):\n-                continue\n-        elif pluginDirectory == \"sceneparsers\":\n-            # Deploy the virtualkeyboard plugins only if Qt3DCore is in use\n-            if not deploymentInfo.usesFramework(\"Qt3DCore\"):\n-                continue\n-        elif pluginDirectory == \"renderplugins\":\n-            # Deploy the renderplugins plugins only if Qt3DCore is in use\n-            if not deploymentInfo.usesFramework(\"Qt3DCore\"):\n-                continue\n-        elif pluginDirectory == \"geometryloaders\":\n-            # Deploy the geometryloaders plugins only if Qt3DCore is in use\n-            if not deploymentInfo.usesFramework(\"Qt3DCore\"):\n-                continue\n \n         for pluginName in filenames:\n             pluginPath = os.path.join(pluginDirectory, pluginName)\n-            if pluginName.endswith(\"_debug.dylib\"):\n-                # Skip debug plugins\n+\n+            if pluginName.split('.')[0] not in ['libqminimal', 'libqcocoa', 'libqmacstyle']:\n                 continue\n-            elif pluginPath == \"imageformats/libqsvg.dylib\" or pluginPath == \"iconengines/libqsvgicon.dylib\":\n-                # Deploy the svg plugins only if QtSvg is in use\n-                if not deploymentInfo.usesFramework(\"QtSvg\"):\n-                    continue\n-            elif pluginPath == \"accessible/libqtaccessiblecompatwidgets.dylib\":\n-                # Deploy accessibility for Qt3Support only if the Qt3Support is in use\n-                if not deploymentInfo.usesFramework(\"Qt3Support\"):\n-                    continue\n-            elif pluginPath == \"graphicssystems/libqglgraphicssystem.dylib\":\n-                # Deploy the opengl graphicssystem plugin only if QtOpenGL is in use\n-                if not deploymentInfo.usesFramework(\"QtOpenGL\"):\n-                    continue\n-            elif pluginPath == \"accessible/libqtaccessiblequick.dylib\":\n-                # Deploy the accessible qtquick plugin only if QtQuick is in use\n-                if not deploymentInfo.usesFramework(\"QtQuick\"):\n-                    continue\n-            elif pluginPath == \"platforminputcontexts/libqtvirtualkeyboardplugin.dylib\":\n-                # Deploy the virtualkeyboardplugin plugin only if QtVirtualKeyboard is in use\n-                if not deploymentInfo.usesFramework(\"QtVirtualKeyboard\"):\n-                    continue\n \n             plugins.append((pluginDirectory, pluginName))\n     \n@@ -527,6 +423,9 @@ if os.path.exists(appname + \".dmg\"):\n     print(\"+ Removing existing DMG +\")\n     os.unlink(appname + \".dmg\")\n \n+if os.path.exists(appname + \".temp.dmg\"):\n+    os.unlink(appname + \".temp.dmg\")\n+\n # ------------------------------------------------\n \n target = os.path.join(\"dist\", \"Bitcoin-Qt.app\")"
      },
      {
        "sha": "b9dfdb4b0ab014b13a74616a5458e6ff8e67adb9",
        "filename": "contrib/seeds/nodes_main.txt",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/seeds/nodes_main.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/seeds/nodes_main.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/nodes_main.txt?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -677,12 +677,20 @@ tddeij4qigtjr6jfnrmq6btnirmq5msgwcsdpcdjr7atftm7cxlqztid.onion:8333\n vi5bnbxkleeqi6hfccjochnn65lcxlfqs4uwgmhudph554zibiusqnad.onion:8333\n xqt25cobm5zqucac3634zfght72he6u3eagfyej5ellbhcdgos7t2had.onion:8333\n \n-# manually added 2021-05 for minimal i2p bootstrap support\n-72l3ucjkuscrbiiepoehuwqgknyzgo7zuix5ty4puwrkyhtmnsga.b32.i2p:0\n+# manually added 2021-08 for minimal i2p bootstrap support\n+4hllr6w55mbtemb3ebvlzl4zj6qke4si7zcob5qdyg63mjgq624a.b32.i2p:0\n+6s33jtpvwzkiej3nff5qm72slgqljxhxn62hdt6m7nvynqsxqdda.b32.i2p:0\n+a5qsnv3maw77mlmmzlcglu6twje6ttctd3fhpbfwcbpmewx6fczq.b32.i2p:0\n+bitcornrd36coazsbzsz4pdebyzvaplmsalq4kpoljmn6cg6x5zq.b32.i2p:0\n c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\n+dhtq2p76tyhi442aidb3vd2bv7yxxjuddpb2jydnnrl2ons5bhha.b32.i2p:0\n gehtac45oaghz54ypyopim64mql7oad2bqclla74l6tfeolzmodq.b32.i2p:0\n h3r6bkn46qxftwja53pxiykntegfyfjqtnzbm6iv6r5mungmqgmq.b32.i2p:0\n hnbbyjpxx54623l555sta7pocy3se4sdgmuebi5k6reesz5rjp6q.b32.i2p:0\n-pjs7or2ctvteeo5tu4bwyrtydeuhqhvdprtujn4daxr75jpebjxa.b32.i2p:0\n+i3hcdakiz2tyvggkwefvdjoi7444kgvd2mbdfizjvv43q7zukezq.b32.i2p:0\n+jz3s4eurm5vzjresf4mwo7oni4bk36daolwxh4iqtewakylgkxmq.b32.i2p:0\n+kokkmpquqlkptu5hkmzqlttsmtwxicldr4so7wqsufk6bwf32nma.b32.i2p:0\n+kvrde7mcgjhz3xzeltwy4gs2rxdfbnbs2wc67mh2pt43wjmjnmbq.b32.i2p:0\n+shh2ewyegnuwnmdse5kl5toybdvzkvk2yj4zcowz6iwhhh3ykdfa.b32.i2p:0\n wwbw7nqr3ahkqv62cuqfwgtneekvvpnuc4i4f6yo7tpoqjswvcwa.b32.i2p:0\n zsxwyo6qcn3chqzwxnseusqgsnuw3maqnztkiypyfxtya4snkoka.b32.i2p:0"
      },
      {
        "sha": "047354cda17b10b31ada507698b4d372ec8ffc3f",
        "filename": "contrib/tracing/README.md",
        "status": "added",
        "additions": 241,
        "deletions": 0,
        "changes": 241,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/README.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,241 @@\n+Example scripts for User-space, Statically Defined Tracing (USDT)\n+=================================================================\n+\n+This directory contains scripts showcasing User-space, Statically Defined\n+Tracing (USDT) support for Bitcoin Core on Linux using. For more information on\n+USDT support in Bitcoin Core see the [USDT documentation].\n+\n+[USDT documentation]: ../../doc/tracing.md\n+\n+\n+Examples for the two main eBPF front-ends, [bpftrace] and\n+[BPF Compiler Collection (BCC)], with support for USDT, are listed. BCC is used\n+for complex tools and daemons and `bpftrace` is preferred for one-liners and\n+shorter scripts.\n+\n+[bpftrace]: https://github.com/iovisor/bpftrace\n+[BPF Compiler Collection (BCC)]: https://github.com/iovisor/bcc\n+\n+\n+To develop and run bpftrace and BCC scripts you need to install the\n+corresponding packages. See [installing bpftrace] and [installing BCC] for more\n+information. For development there exist a [bpftrace Reference Guide], a\n+[BCC Reference Guide], and a [bcc Python Developer Tutorial].\n+\n+[installing bpftrace]: https://github.com/iovisor/bpftrace/blob/master/INSTALL.md\n+[installing BCC]: https://github.com/iovisor/bcc/blob/master/INSTALL.md\n+[bpftrace Reference Guide]: https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md\n+[BCC Reference Guide]: https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md\n+[bcc Python Developer Tutorial]: https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md\n+\n+## Examples\n+\n+The bpftrace examples contain a relative path to the `bitcoind` binary. By\n+default, the scripts should be run from the repository-root and assume a\n+self-compiled `bitcoind` binary. The paths in the examples can be changed, for\n+example, to point to release builds if needed. See the\n+[Bitcoin Core USDT documentation] on how to list available tracepoints in your\n+`bitcoind` binary.\n+\n+[Bitcoin Core USDT documentation]: ../../doc/tracing.md#listing-available-tracepoints\n+\n+**WARNING: eBPF programs require root privileges to be loaded into a Linux\n+kernel VM. This means the bpftrace and BCC examples must be executed with root\n+privileges. Make sure to carefully review any scripts that you run with root\n+privileges first!**\n+\n+### log_p2p_traffic.bt\n+\n+A bpftrace script logging information about inbound and outbound P2P network\n+messages. Based on the `net:inbound_message` and `net:outbound_message`\n+tracepoints.\n+\n+By default, `bpftrace` limits strings to 64 bytes due to the limited stack size\n+in the eBPF VM. For example, Tor v3 addresses exceed the string size limit which\n+results in the port being cut off during logging. The string size limit can be\n+increased with the `BPFTRACE_STRLEN` environment variable (`BPFTRACE_STRLEN=70`\n+works fine).\n+\n+```\n+$ bpftrace contrib/tracing/log_p2p_traffic.bt\n+```\n+\n+Output\n+```\n+outbound 'ping' msg to peer 11 (outbound-full-relay, [2a02:b10c:f747:1:ef:fake:ipv6:addr]:8333) with 8 bytes\n+inbound 'pong' msg from peer 11 (outbound-full-relay, [2a02:b10c:f747:1:ef:fake:ipv6:addr]:8333) with 8 bytes\n+inbound 'inv' msg from peer 16 (outbound-full-relay, XX.XX.XXX.121:8333) with 37 bytes\n+outbound 'getdata' msg to peer 16 (outbound-full-relay, XX.XX.XXX.121:8333) with 37 bytes\n+inbound 'tx' msg from peer 16 (outbound-full-relay, XX.XX.XXX.121:8333) with 222 bytes\n+outbound 'inv' msg to peer 9 (outbound-full-relay, faketorv3addressa2ufa6odvoi3s77j4uegey0xb10csyfyve2t33curbyd.onion:8333) with 37 bytes\n+outbound 'inv' msg to peer 7 (outbound-full-relay, XX.XX.XXX.242:8333) with 37 bytes\n+\u2026\n+```\n+\n+### p2p_monitor.py\n+\n+A BCC Python script using curses for an interactive P2P message monitor. Based\n+on the `net:inbound_message` and `net:outbound_message` tracepoints.\n+\n+Inbound and outbound traffic is listed for each peer together with information\n+about the connection. Peers can be selected individually to view recent P2P\n+messages.\n+\n+```\n+$ python3 contrib/tracing/p2p_monitor.py ./src/bitcoind\n+```\n+\n+Lists selectable peers and traffic and connection information.\n+```\n+ P2P Message Monitor\n+ Navigate with UP/DOWN or J/K and select a peer with ENTER or SPACE to see individual P2P messages\n+\n+ PEER  OUTBOUND              INBOUND               TYPE                   ADDR\n+    0  46          398 byte  61      1407590 byte  block-relay-only       XX.XX.XXX.196:8333\n+   11  1156     253570 byte  3431    2394924 byte  outbound-full-relay    XXX.X.XX.179:8333\n+   13  3425    1809620 byte  1236     305458 byte  inbound                XXX.X.X.X:60380\n+   16  1046     241633 byte  1589    1199220 byte  outbound-full-relay    4faketorv2pbfu7x.onion:8333\n+   19  577      181679 byte  390      148951 byte  outbound-full-relay    kfake4vctorjv2o2.onion:8333\n+   20  11         1248 byte  13         1283 byte  block-relay-only       [2600:fake:64d9:b10c:4436:aaaa:fe:bb]:8333\n+   21  11         1248 byte  13         1299 byte  block-relay-only       XX.XXX.X.155:8333\n+   22  5           103 byte  1           102 byte  feeler                 XX.XX.XXX.173:8333\n+   23  11         1248 byte  12         1255 byte  block-relay-only       XX.XXX.XXX.220:8333\n+   24  3           103 byte  1           102 byte  feeler                 XXX.XXX.XXX.64:8333\n+\u2026\n+```\n+\n+Showing recent P2P messages between our node and a selected peer.\n+\n+```\n+    ----------------------------------------------------------------------\n+    |                PEER 16 (4faketorv2pbfu7x.onion:8333)               |\n+    | OUR NODE                outbound-full-relay                   PEER |\n+    |                                           <--- sendcmpct (9 bytes) |\n+    | inv (37 byte) --->                                                 |\n+    |                                                <--- ping (8 bytes) |\n+    | pong (8 byte) --->                                                 |\n+    | inv (37 byte) --->                                                 |\n+    |                                               <--- addr (31 bytes) |\n+    | inv (37 byte) --->                                                 |\n+    |                                       <--- getheaders (1029 bytes) |\n+    | headers (1 byte) --->                                              |\n+    |                                           <--- feefilter (8 bytes) |\n+    |                                                <--- pong (8 bytes) |\n+    |                                            <--- headers (82 bytes) |\n+    |                                            <--- addr (30003 bytes) |\n+    | inv (1261 byte) --->                                               |\n+    |                                 \u2026                                  |\n+\n+```\n+\n+### log_raw_p2p_msgs.py\n+\n+A BCC Python script showcasing eBPF and USDT limitations when passing data\n+larger than about 32kb. Based on the `net:inbound_message` and\n+`net:outbound_message` tracepoints.\n+\n+Bitcoin P2P messages can be larger than 32kb (e.g. `tx`, `block`, ...). The\n+eBPF VM's stack is limited to 512 bytes, and we can't allocate more than about\n+32kb for a P2P message in the eBPF VM. The **message data is cut off** when the\n+message is larger than MAX_MSG_DATA_LENGTH (see script). This can be detected\n+in user-space by comparing the data length to the message length variable. The\n+message is cut off when the data length is smaller than the message length.\n+A warning is included with the printed message data.\n+\n+Data is submitted to user-space (i.e. to this script) via a ring buffer. The\n+throughput of the ring buffer is limited. Each p2p_message is about 32kb in\n+size. In- or outbound messages submitted to the ring buffer in rapid\n+succession fill the ring buffer faster than it can be read. Some messages are\n+lost. BCC prints: `Possibly lost 2 samples` on lost messages.\n+\n+\n+```\n+$ python3 contrib/tracing/log_raw_p2p_msgs.py ./src/bitcoind\n+```\n+\n+```\n+Logging raw P2P messages.\n+Messages larger that about 32kb will be cut off!\n+Some messages might be lost!\n+ outbound msg 'inv' from peer 4 (outbound-full-relay, XX.XXX.XX.4:8333) with 253 bytes: 0705000000be2245c8f844c9f763748e1a7\u2026\n+\u2026\n+Warning: incomplete message (only 32568 out of 53552 bytes)! inbound msg 'tx' from peer 32 (outbound-full-relay, XX.XXX.XXX.43:8333) with 53552 bytes: 020000000001fd3c01939c85ad6756ed9fc\u2026\n+\u2026\n+Possibly lost 2 samples\n+```\n+\n+### connectblock_benchmark.bt\n+\n+A `bpftrace` script to benchmark the `ConnectBlock()` function during, for\n+example, a blockchain re-index. Based on the `validation:block_connected` USDT\n+tracepoint.\n+\n+The script takes three positional arguments. The first two arguments, the start,\n+and end height indicate between which blocks the benchmark should be run. The\n+third acts as a duration threshold in milliseconds. When the `ConnectBlock()`\n+function takes longer than the threshold, information about the block, is\n+printed. For more details, see the header comment in the script.\n+\n+By default, `bpftrace` limits strings to 64 bytes due to the limited stack size\n+in the kernel VM. Block hashes as zero-terminated hex strings are 65 bytes which\n+exceed the string limit. The string size limit can be set to 65 bytes with the\n+environment variable `BPFTRACE_STRLEN`.\n+\n+The following command can be used to benchmark, for example, `ConnectBlock()`\n+between height 20000 and 38000 on SigNet while logging all blocks that take\n+longer than 25ms to connect.\n+\n+```\n+$ BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt 20000 38000 25\n+```\n+\n+In a different terminal, starting Bitcoin Core in SigNet mode and with\n+re-indexing enabled.\n+\n+```\n+$ ./src/bitcoind -signet -reindex\n+```\n+\n+This produces the following output.\n+```\n+Attaching 5 probes...\n+ConnectBlock Benchmark between height 20000 and 38000 inclusive\n+Logging blocks taking longer than 25 ms to connect.\n+Starting Connect Block Benchmark between height 20000 and 38000.\n+BENCH   39 blk/s     59 tx/s      59 inputs/s       20 sigops/s (height 20038)\n+Block 20492 (000000f555653bb05e2f3c6e79925e01a20dd57033f4dc7c354b46e34735d32b)    20 tx   2319 ins   2318 sigops  took   38 ms\n+BENCH 1840 blk/s   2117 tx/s    4478 inputs/s     2471 sigops/s (height 21879)\n+BENCH 1816 blk/s   4972 tx/s    4982 inputs/s      125 sigops/s (height 23695)\n+BENCH 2095 blk/s   2890 tx/s    2910 inputs/s      152 sigops/s (height 25790)\n+BENCH 1684 blk/s   3979 tx/s    4053 inputs/s      288 sigops/s (height 27474)\n+BENCH 1155 blk/s   3216 tx/s    3252 inputs/s      115 sigops/s (height 28629)\n+BENCH 1797 blk/s   2488 tx/s    2503 inputs/s      111 sigops/s (height 30426)\n+BENCH 1849 blk/s   6318 tx/s    6569 inputs/s    12189 sigops/s (height 32275)\n+BENCH  946 blk/s  20209 tx/s   20775 inputs/s    83809 sigops/s (height 33221)\n+Block 33406 (0000002adfe4a15cfcd53bd890a89bbae836e5bb7f38bac566f61ad4548c87f6)    25 tx   2045 ins   2090 sigops  took   29 ms\n+Block 33687 (00000073231307a9828e5607ceb8156b402efe56747271a4442e75eb5b77cd36)    52 tx   1797 ins   1826 sigops  took   26 ms\n+BENCH  582 blk/s  21581 tx/s   27673 inputs/s    60345 sigops/s (height 33803)\n+BENCH 1035 blk/s  19735 tx/s   19776 inputs/s    51355 sigops/s (height 34838)\n+Block 35625 (0000006b00b347390c4768ea9df2655e9ff4b120f29d78594a2a702f8a02c997)    20 tx   3374 ins   3371 sigops  took   49 ms\n+BENCH  887 blk/s  17857 tx/s   22191 inputs/s    24404 sigops/s (height 35725)\n+Block 35937 (000000d816d13d6e39b471cd4368db60463a764ba1f29168606b04a22b81ea57)    75 tx   3943 ins   3940 sigops  took   61 ms\n+BENCH  823 blk/s  16298 tx/s   21031 inputs/s    18440 sigops/s (height 36548)\n+Block 36583 (000000c3e260556dbf42968aae3f904dba8b8c1ff96a6f6e3aa5365d2e3ad317)    24 tx   2198 ins   2194 sigops  took   34 ms\n+Block 36700 (000000b3b173de9e65a3cfa738d976af6347aaf83fa17ab3f2a4d2ede3ddfac4)    73 tx   1615 ins   1611 sigops  took   31 ms\n+Block 36832 (0000007859578c02c1ac37dabd1b9ec19b98f350b56935f5dd3a41e9f79f836e)    34 tx   1440 ins   1436 sigops  took   26 ms\n+BENCH  613 blk/s  16718 tx/s   25074 inputs/s    23022 sigops/s (height 37161)\n+Block 37870 (000000f5c1086291ba2d943fb0c3bc82e71c5ee341ee117681d1456fbf6c6c38)    25 tx   1517 ins   1514 sigops  took   29 ms\n+BENCH  811 blk/s  16031 tx/s   20921 inputs/s    18696 sigops/s (height 37972)\n+\n+Took 14055 ms to connect the blocks between height 20000 and 38000.\n+\n+Histogram of block connection times in milliseconds (ms).\n+@durations:\n+[0]                16838 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n+[1]                  882 |@@                                                  |\n+[2, 4)               236 |                                                    |\n+[4, 8)                23 |                                                    |\n+[8, 16)                9 |                                                    |\n+[16, 32)               9 |                                                    |\n+[32, 64)               4 |                                                    |\n+```"
      },
      {
        "sha": "d268eff7f8b8cf2fc1a19951ac60e09279ce7d17",
        "filename": "contrib/tracing/connectblock_benchmark.bt",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/connectblock_benchmark.bt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/connectblock_benchmark.bt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/connectblock_benchmark.bt?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,150 @@\n+#!/usr/bin/env bpftrace\n+\n+/*\n+\n+  USAGE:\n+\n+  BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt <start height> <end height> <logging threshold in ms>\n+\n+  - The environment variable BPFTRACE_STRLEN needs to be set to 65 chars as\n+    strings are limited to 64 chars by default. Hex strings with Bitcoin block\n+    hashes are 64 hex chars + 1 null-termination char.\n+  - <start height> sets the height at which the benchmark should start. Setting\n+    the start height to 0 starts the benchmark immediately, even before the\n+    first block is connected.\n+  - <end height> sets the height after which the benchmark should end. Setting\n+    the end height to 0 disables the benchmark. The script only logs blocks\n+    over <logging threshold in ms>.\n+  - Threshold <logging threshold in ms>\n+\n+  This script requires a 'bitcoind' binary compiled with eBPF support and the\n+  'validation:block_connected' USDT. By default, it's assumed that 'bitcoind' is\n+  located in './src/bitcoind'. This can be modified in the script below.\n+\n+  EXAMPLES:\n+\n+  BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt 300000 680000 1000\n+\n+  When run together 'bitcoind -reindex', this benchmarks the time it takes to\n+  connect the blocks between height 300.000 and 680.000 (inclusive) and prints\n+  details about all blocks that take longer than 1000ms to connect. Prints a\n+  histogram with block connection times when the benchmark is finished.\n+\n+\n+  BPFTRACE_STRLEN=65 bpftrace contrib/tracing/connectblock_benchmark.bt 0 0 500\n+\n+  When running together 'bitcoind', all newly connected blocks that\n+  take longer than 500ms to connect are logged. A histogram with block\n+  connection times is shown when the script is terminated.\n+\n+*/\n+\n+BEGIN\n+{\n+  $start_height = $1;\n+  $end_height = $2;\n+  $logging_threshold_ms = $3;\n+\n+  if ($end_height < $start_height) {\n+    printf(\"Error: start height (%d) larger than end height (%d)!\\n\", $start_height, $end_height);\n+    exit();\n+  }\n+\n+  if ($end_height > 0) {\n+    printf(\"ConnectBlock benchmark between height %d and %d inclusive\\n\", $start_height, $end_height);\n+  } else {\n+    printf(\"ConnectBlock logging starting at height %d\\n\", $start_height);\n+  }\n+\n+  if ($logging_threshold_ms > 0) {\n+    printf(\"Logging blocks taking longer than %d ms to connect.\\n\", $3);\n+  }\n+\n+  if ($start_height == 0) {\n+    @start = nsecs;\n+  }\n+}\n+\n+/*\n+  Attaches to the 'validation:block_connected' USDT and collects stats when the\n+  connected block is between the start and end height (or the end height is\n+  unset).\n+*/\n+usdt:./src/bitcoind:validation:block_connected /arg1 >= $1 && (arg1 <= $2 || $2 == 0 )/\n+{\n+  $height = arg1;\n+  $transactions = arg2;\n+  $inputs = arg3;\n+  $sigops =  arg4;\n+  $duration = (uint64) arg5;\n+\n+  @height = $height;\n+\n+  @blocks = @blocks + 1;\n+  @transactions = @transactions + $transactions;\n+  @inputs = @inputs + $inputs;\n+  @sigops = @sigops + $sigops;\n+\n+  @durations = hist($duration / 1000);\n+\n+  if ($height == $1 && $height != 0) {\n+    @start = nsecs;\n+    printf(\"Starting Connect Block Benchmark between height %d and %d.\\n\", $1, $2);\n+  }\n+\n+  if ($2 > 0 && $height >= $2) {\n+    @end = nsecs;\n+    $duration = @end - @start;\n+    printf(\"\\nTook %d ms to connect the blocks between height %d and %d.\\n\", $duration / 1000000, $1, $2);\n+    exit();\n+  }\n+}\n+\n+/*\n+  Attaches to the 'validation:block_connected' USDT and logs information about\n+  blocks where the time it took to connect the block is above the\n+  <logging threshold in ms>.\n+*/\n+usdt:./src/bitcoind:validation:block_connected / (uint64) arg5 / 1000> $3 /\n+{\n+  $hash_str = str(arg0);\n+  $height = (int32) arg1;\n+  $transactions = (uint64) arg2;\n+  $inputs = (int32) arg3;\n+  $sigops = (int64) arg4;\n+  $duration = (int64) arg5;\n+\n+  printf(\"Block %d (%s)  %4d tx  %5d ins  %5d sigops  took %4d ms\\n\", $height, $hash_str, $transactions, $inputs, $sigops, (uint64) $duration / 1000);\n+}\n+\n+\n+/*\n+  Prints stats about the blocks, transactions, inputs, and sigops processed in\n+  the last second (if any).\n+*/\n+interval:s:1 {\n+  if (@blocks > 0) {\n+    printf(\"BENCH %4d blk/s %6d tx/s %7d inputs/s %8d sigops/s (height %d)\\n\", @blocks, @transactions, @inputs, @sigops, @height);\n+\n+    zero(@blocks);\n+    zero(@transactions);\n+    zero(@inputs);\n+    zero(@sigops);\n+  }\n+}\n+\n+END\n+{\n+  printf(\"\\nHistogram of block connection times in milliseconds (ms).\\n\");\n+  print(@durations);\n+\n+  clear(@durations);\n+  clear(@blocks);\n+  clear(@transactions);\n+  clear(@inputs);\n+  clear(@sigops);\n+  clear(@height);\n+  clear(@start);\n+  clear(@end);\n+}\n+"
      },
      {
        "sha": "f62956aa5e1c3d36844c762b620ec4d43f9ee764",
        "filename": "contrib/tracing/log_p2p_traffic.bt",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/log_p2p_traffic.bt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/log_p2p_traffic.bt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/log_p2p_traffic.bt?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,28 @@\n+#!/usr/bin/env bpftrace\n+\n+BEGIN\n+{\n+  printf(\"Logging P2P traffic\\n\")\n+}\n+\n+usdt:./src/bitcoind:net:inbound_message\n+{\n+  $peer_id = (int64) arg0;\n+  $peer_addr = str(arg1);\n+  $peer_type = str(arg2);\n+  $msg_type = str(arg3);\n+  $msg_len = arg4;\n+  printf(\"inbound '%s' msg from peer %d (%s, %s) with %d bytes\\n\", $msg_type, $peer_id, $peer_type, $peer_addr, $msg_len);\n+}\n+\n+usdt:./src/bitcoind:net:outbound_message\n+{\n+  $peer_id = (int64) arg0;\n+  $peer_addr = str(arg1);\n+  $peer_type = str(arg2);\n+  $msg_type = str(arg3);\n+  $msg_len = arg4;\n+\n+  printf(\"outbound '%s' msg to peer %d (%s, %s) with %d bytes\\n\", $msg_type, $peer_id, $peer_type, $peer_addr, $msg_len);\n+}\n+"
      },
      {
        "sha": "b5b57556324e350b879bc60749338d442ea3f8b9",
        "filename": "contrib/tracing/log_raw_p2p_msgs.py",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/log_raw_p2p_msgs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/log_raw_p2p_msgs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/log_raw_p2p_msgs.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+\n+\"\"\" Demonstration of eBPF limitations and the effect on USDT with the\n+    net:inbound_message and net:outbound_message tracepoints. \"\"\"\n+\n+# This script shows a limitation of eBPF when data larger than 32kb is passed to\n+# user-space. It uses BCC (https://github.com/iovisor/bcc) to load a sandboxed\n+# eBPF program into the Linux kernel (root privileges are required). The eBPF\n+# program attaches to two statically defined tracepoints. The tracepoint\n+# 'net:inbound_message' is called when a new P2P message is received, and\n+# 'net:outbound_message' is called on outbound P2P messages. The eBPF program\n+# submits the P2P messages to this script via a BPF ring buffer. The submitted\n+# messages are printed.\n+\n+# eBPF Limitations:\n+#\n+# Bitcoin P2P messages can be larger than 32kb (e.g. tx, block, ...). The eBPF\n+# VM's stack is limited to 512 bytes, and we can't allocate more than about 32kb\n+# for a P2P message in the eBPF VM. The message data is cut off when the message\n+# is larger than MAX_MSG_DATA_LENGTH (see definition below). This can be detected\n+# in user-space by comparing the data length to the message length variable. The\n+# message is cut off when the data length is smaller than the message length.\n+# A warning is included with the printed message data.\n+#\n+# Data is submitted to user-space (i.e. to this script) via a ring buffer. The\n+# throughput of the ring buffer is limited. Each p2p_message is about 32kb in\n+# size. In- or outbound messages submitted to the ring buffer in rapid\n+# succession fill the ring buffer faster than it can be read. Some messages are\n+# lost.\n+#\n+# BCC prints: \"Possibly lost 2 samples\" on lost messages.\n+\n+import sys\n+from bcc import BPF, USDT\n+\n+# BCC: The C program to be compiled to an eBPF program (by BCC) and loaded into\n+# a sandboxed Linux kernel VM.\n+program = \"\"\"\n+#include <uapi/linux/ptrace.h>\n+\n+#define MIN(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b); _a < _b ? _a : _b; })\n+\n+// Maximum possible allocation size\n+// from include/linux/percpu.h in the Linux kernel\n+#define PCPU_MIN_UNIT_SIZE (32 << 10)\n+\n+// Tor v3 addresses are 62 chars + 6 chars for the port (':12345').\n+#define MAX_PEER_ADDR_LENGTH 62 + 6\n+#define MAX_PEER_CONN_TYPE_LENGTH 20\n+#define MAX_MSG_TYPE_LENGTH 20\n+#define MAX_MSG_DATA_LENGTH PCPU_MIN_UNIT_SIZE - 200\n+\n+struct p2p_message\n+{\n+    u64     peer_id;\n+    char    peer_addr[MAX_PEER_ADDR_LENGTH];\n+    char    peer_conn_type[MAX_PEER_CONN_TYPE_LENGTH];\n+    char    msg_type[MAX_MSG_TYPE_LENGTH];\n+    u64     msg_size;\n+    u8      msg[MAX_MSG_DATA_LENGTH];\n+};\n+\n+// We can't store the p2p_message struct on the eBPF stack as it is limited to\n+// 512 bytes and P2P message can be bigger than 512 bytes. However, we can use\n+// an BPF-array with a length of 1 to allocate up to 32768 bytes (this is\n+// defined by PCPU_MIN_UNIT_SIZE in include/linux/percpu.h in the Linux kernel).\n+// Also see https://github.com/iovisor/bcc/issues/2306\n+BPF_ARRAY(msg_arr, struct p2p_message, 1);\n+\n+// Two BPF perf buffers for pushing data (here P2P messages) to user-space.\n+BPF_PERF_OUTPUT(inbound_messages);\n+BPF_PERF_OUTPUT(outbound_messages);\n+\n+int trace_inbound_message(struct pt_regs *ctx) {\n+    int idx = 0;\n+    struct p2p_message *msg = msg_arr.lookup(&idx);\n+\n+    // lookup() does not return a NULL pointer. However, the BPF verifier\n+    // requires an explicit check that that the `msg` pointer isn't a NULL\n+    // pointer. See https://github.com/iovisor/bcc/issues/2595\n+    if (msg == NULL) return 1;\n+\n+    bpf_usdt_readarg(1, ctx, &msg->peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg->peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg->peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg->msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg->msg_size);\n+    bpf_usdt_readarg_p(6, ctx, &msg->msg, MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));\n+\n+    inbound_messages.perf_submit(ctx, msg, sizeof(*msg));\n+    return 0;\n+};\n+\n+int trace_outbound_message(struct pt_regs *ctx) {\n+    int idx = 0;\n+    struct p2p_message *msg = msg_arr.lookup(&idx);\n+\n+    // lookup() does not return a NULL pointer. However, the BPF verifier\n+    // requires an explicit check that that the `msg` pointer isn't a NULL\n+    // pointer. See https://github.com/iovisor/bcc/issues/2595\n+    if (msg == NULL) return 1;\n+\n+    bpf_usdt_readarg(1, ctx, &msg->peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg->peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg->peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg->msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg->msg_size);\n+    bpf_usdt_readarg_p(6, ctx, &msg->msg,  MIN(msg->msg_size, MAX_MSG_DATA_LENGTH));\n+\n+    outbound_messages.perf_submit(ctx, msg, sizeof(*msg));\n+    return 0;\n+};\n+\"\"\"\n+\n+\n+def print_message(event, inbound):\n+    print(f\"%s %s msg '%s' from peer %d (%s, %s) with %d bytes: %s\" %\n+          (\n+              f\"Warning: incomplete message (only %d out of %d bytes)!\" % (\n+                  len(event.msg), event.msg_size) if len(event.msg) < event.msg_size else \"\",\n+              \"inbound\" if inbound else \"outbound\",\n+              event.msg_type.decode(\"utf-8\"),\n+              event.peer_id,\n+              event.peer_conn_type.decode(\"utf-8\"),\n+              event.peer_addr.decode(\"utf-8\"),\n+              event.msg_size,\n+              bytes(event.msg[:event.msg_size]).hex(),\n+          )\n+          )\n+\n+\n+def main(bitcoind_path):\n+    bitcoind_with_usdts = USDT(path=str(bitcoind_path))\n+\n+    # attaching the trace functions defined in the BPF program to the tracepoints\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"inbound_message\", fn_name=\"trace_inbound_message\")\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"outbound_message\", fn_name=\"trace_outbound_message\")\n+    bpf = BPF(text=program, usdt_contexts=[bitcoind_with_usdts])\n+\n+    # BCC: perf buffer handle function for inbound_messages\n+    def handle_inbound(_, data, size):\n+        \"\"\" Inbound message handler.\n+\n+        Called each time a message is submitted to the inbound_messages BPF table.\"\"\"\n+\n+        event = bpf[\"inbound_messages\"].event(data)\n+        print_message(event, True)\n+\n+    # BCC: perf buffer handle function for outbound_messages\n+\n+    def handle_outbound(_, data, size):\n+        \"\"\" Outbound message handler.\n+\n+        Called each time a message is submitted to the outbound_messages BPF table.\"\"\"\n+\n+        event = bpf[\"outbound_messages\"].event(data)\n+        print_message(event, False)\n+\n+    # BCC: add handlers to the inbound and outbound perf buffers\n+    bpf[\"inbound_messages\"].open_perf_buffer(handle_inbound)\n+    bpf[\"outbound_messages\"].open_perf_buffer(handle_outbound)\n+\n+    print(\"Logging raw P2P messages.\")\n+    print(\"Messages larger that about 32kb will be cut off!\")\n+    print(\"Some messages might be lost!\")\n+    while True:\n+        try:\n+            bpf.perf_buffer_poll()\n+        except KeyboardInterrupt:\n+            exit()\n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) < 2:\n+        print(\"USAGE:\", sys.argv[0], \"path/to/bitcoind\")\n+        exit()\n+    path = sys.argv[1]\n+    main(path)"
      },
      {
        "sha": "14e3e3a80123ad163f35000fa27b62835e02c992",
        "filename": "contrib/tracing/p2p_monitor.py",
        "status": "added",
        "additions": 250,
        "deletions": 0,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/p2p_monitor.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/tracing/p2p_monitor.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tracing/p2p_monitor.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,250 @@\n+#!/usr/bin/env python3\n+\n+\"\"\" Interactive bitcoind P2P network traffic monitor utilizing USDT and the\n+    net:inbound_message and net:outbound_message tracepoints. \"\"\"\n+\n+# This script demonstrates what USDT for Bitcoin Core can enable. It uses BCC\n+# (https://github.com/iovisor/bcc) to load a sandboxed eBPF program into the\n+# Linux kernel (root privileges are required). The eBPF program attaches to two\n+# statically defined tracepoints. The tracepoint 'net:inbound_message' is called\n+# when a new P2P message is received, and 'net:outbound_message' is called on\n+# outbound P2P messages. The eBPF program submits the P2P messages to\n+# this script via a BPF ring buffer.\n+\n+import sys\n+import curses\n+from curses import wrapper, panel\n+from bcc import BPF, USDT\n+\n+# BCC: The C program to be compiled to an eBPF program (by BCC) and loaded into\n+# a sandboxed Linux kernel VM.\n+program = \"\"\"\n+#include <uapi/linux/ptrace.h>\n+\n+// Tor v3 addresses are 62 chars + 6 chars for the port (':12345').\n+// I2P addresses are 60 chars + 6 chars for the port (':12345').\n+#define MAX_PEER_ADDR_LENGTH 62 + 6\n+#define MAX_PEER_CONN_TYPE_LENGTH 20\n+#define MAX_MSG_TYPE_LENGTH 20\n+\n+struct p2p_message\n+{\n+    u64     peer_id;\n+    char    peer_addr[MAX_PEER_ADDR_LENGTH];\n+    char    peer_conn_type[MAX_PEER_CONN_TYPE_LENGTH];\n+    char    msg_type[MAX_MSG_TYPE_LENGTH];\n+    u64     msg_size;\n+};\n+\n+\n+// Two BPF perf buffers for pushing data (here P2P messages) to user space.\n+BPF_PERF_OUTPUT(inbound_messages);\n+BPF_PERF_OUTPUT(outbound_messages);\n+\n+int trace_inbound_message(struct pt_regs *ctx) {\n+    struct p2p_message msg = {};\n+\n+    bpf_usdt_readarg(1, ctx, &msg.peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg.peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg.peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg.msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg.msg_size);\n+\n+    inbound_messages.perf_submit(ctx, &msg, sizeof(msg));\n+    return 0;\n+};\n+\n+int trace_outbound_message(struct pt_regs *ctx) {\n+    struct p2p_message msg = {};\n+\n+    bpf_usdt_readarg(1, ctx, &msg.peer_id);\n+    bpf_usdt_readarg_p(2, ctx, &msg.peer_addr, MAX_PEER_ADDR_LENGTH);\n+    bpf_usdt_readarg_p(3, ctx, &msg.peer_conn_type, MAX_PEER_CONN_TYPE_LENGTH);\n+    bpf_usdt_readarg_p(4, ctx, &msg.msg_type, MAX_MSG_TYPE_LENGTH);\n+    bpf_usdt_readarg(5, ctx, &msg.msg_size);\n+\n+    outbound_messages.perf_submit(ctx, &msg, sizeof(msg));\n+    return 0;\n+};\n+\"\"\"\n+\n+\n+class Message:\n+    \"\"\" A P2P network message. \"\"\"\n+    msg_type = \"\"\n+    size = 0\n+    data = bytes()\n+    inbound = False\n+\n+    def __init__(self, msg_type, size, inbound):\n+        self.msg_type = msg_type\n+        self.size = size\n+        self.inbound = inbound\n+\n+\n+class Peer:\n+    \"\"\" A P2P network peer. \"\"\"\n+    id = 0\n+    address = \"\"\n+    connection_type = \"\"\n+    last_messages = list()\n+\n+    total_inbound_msgs = 0\n+    total_inbound_bytes = 0\n+    total_outbound_msgs = 0\n+    total_outbound_bytes = 0\n+\n+    def __init__(self, id, address, connection_type):\n+        self.id = id\n+        self.address = address\n+        self.connection_type = connection_type\n+        self.last_messages = list()\n+\n+    def add_message(self, message):\n+        self.last_messages.append(message)\n+        if len(self.last_messages) > 25:\n+            self.last_messages.pop(0)\n+        if message.inbound:\n+            self.total_inbound_bytes += message.size\n+            self.total_inbound_msgs += 1\n+        else:\n+            self.total_outbound_bytes += message.size\n+            self.total_outbound_msgs += 1\n+\n+\n+def main(bitcoind_path):\n+    peers = dict()\n+\n+    bitcoind_with_usdts = USDT(path=str(bitcoind_path))\n+\n+    # attaching the trace functions defined in the BPF program to the tracepoints\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"inbound_message\", fn_name=\"trace_inbound_message\")\n+    bitcoind_with_usdts.enable_probe(\n+        probe=\"outbound_message\", fn_name=\"trace_outbound_message\")\n+    bpf = BPF(text=program, usdt_contexts=[bitcoind_with_usdts])\n+\n+    # BCC: perf buffer handle function for inbound_messages\n+    def handle_inbound(_, data, size):\n+        \"\"\" Inbound message handler.\n+\n+        Called each time a message is submitted to the inbound_messages BPF table.\"\"\"\n+        event = bpf[\"inbound_messages\"].event(data)\n+        if event.peer_id not in peers:\n+            peer = Peer(event.peer_id, event.peer_addr.decode(\n+                \"utf-8\"), event.peer_conn_type.decode(\"utf-8\"))\n+            peers[peer.id] = peer\n+        peers[event.peer_id].add_message(\n+            Message(event.msg_type.decode(\"utf-8\"), event.msg_size, True))\n+\n+    # BCC: perf buffer handle function for outbound_messages\n+    def handle_outbound(_, data, size):\n+        \"\"\" Outbound message handler.\n+\n+        Called each time a message is submitted to the outbound_messages BPF table.\"\"\"\n+        event = bpf[\"outbound_messages\"].event(data)\n+        if event.peer_id not in peers:\n+            peer = Peer(event.peer_id, event.peer_addr.decode(\n+                \"utf-8\"), event.peer_conn_type.decode(\"utf-8\"))\n+            peers[peer.id] = peer\n+        peers[event.peer_id].add_message(\n+            Message(event.msg_type.decode(\"utf-8\"), event.msg_size, False))\n+\n+    # BCC: add handlers to the inbound and outbound perf buffers\n+    bpf[\"inbound_messages\"].open_perf_buffer(handle_inbound)\n+    bpf[\"outbound_messages\"].open_perf_buffer(handle_outbound)\n+\n+    wrapper(loop, bpf, peers)\n+\n+\n+def loop(screen, bpf, peers):\n+    screen.nodelay(1)\n+    cur_list_pos = 0\n+    win = curses.newwin(30, 70, 2, 7)\n+    win.erase()\n+    win.border(ord(\"|\"), ord(\"|\"), ord(\"-\"), ord(\"-\"),\n+               ord(\"-\"), ord(\"-\"), ord(\"-\"), ord(\"-\"))\n+    info_panel = panel.new_panel(win)\n+    info_panel.hide()\n+\n+    ROWS_AVALIABLE_FOR_LIST = curses.LINES - 5\n+    scroll = 0\n+\n+    while True:\n+        try:\n+            # BCC: poll the perf buffers for new events or timeout after 50ms\n+            bpf.perf_buffer_poll(timeout=50)\n+\n+            ch = screen.getch()\n+            if (ch == curses.KEY_DOWN or ch == ord(\"j\")) and cur_list_pos < len(\n+                    peers.keys()) -1 and info_panel.hidden():\n+                cur_list_pos += 1\n+                if cur_list_pos >= ROWS_AVALIABLE_FOR_LIST:\n+                    scroll += 1\n+            if (ch == curses.KEY_UP or ch == ord(\"k\")) and cur_list_pos > 0 and info_panel.hidden():\n+                cur_list_pos -= 1\n+                if scroll > 0:\n+                    scroll -= 1\n+            if ch == ord('\\n') or ch == ord(' '):\n+                if info_panel.hidden():\n+                    info_panel.show()\n+                else:\n+                    info_panel.hide()\n+            screen.erase()\n+            render(screen, peers, cur_list_pos, scroll, ROWS_AVALIABLE_FOR_LIST, info_panel)\n+            curses.panel.update_panels()\n+            screen.refresh()\n+        except KeyboardInterrupt:\n+            exit()\n+\n+\n+def render(screen, peers, cur_list_pos, scroll, ROWS_AVALIABLE_FOR_LIST, info_panel):\n+    \"\"\" renders the list of peers and details panel\n+\n+    This code is unrelated to USDT, BCC and BPF.\n+    \"\"\"\n+    header_format = \"%6s  %-20s  %-20s  %-22s  %-67s\"\n+    row_format = \"%6s  %-5d %9d byte  %-5d %9d byte  %-22s  %-67s\"\n+\n+    screen.addstr(0, 1, (\" P2P Message Monitor \"), curses.A_REVERSE)\n+    screen.addstr(\n+        1, 0, (\" Navigate with UP/DOWN or J/K and select a peer with ENTER or SPACE to see individual P2P messages\"), curses.A_NORMAL)\n+    screen.addstr(3, 0,\n+                  header_format % (\"PEER\", \"OUTBOUND\", \"INBOUND\", \"TYPE\", \"ADDR\"), curses.A_BOLD | curses.A_UNDERLINE)\n+    peer_list = sorted(peers.keys())[scroll:ROWS_AVALIABLE_FOR_LIST+scroll]\n+    for i, peer_id in enumerate(peer_list):\n+        peer = peers[peer_id]\n+        screen.addstr(i + 4, 0,\n+                      row_format % (peer.id, peer.total_outbound_msgs, peer.total_outbound_bytes,\n+                                    peer.total_inbound_msgs, peer.total_inbound_bytes,\n+                                    peer.connection_type, peer.address),\n+                      curses.A_REVERSE if i + scroll == cur_list_pos else curses.A_NORMAL)\n+        if i + scroll == cur_list_pos:\n+            info_window = info_panel.window()\n+            info_window.erase()\n+            info_window.border(\n+                ord(\"|\"), ord(\"|\"), ord(\"-\"), ord(\"-\"),\n+                ord(\"-\"), ord(\"-\"), ord(\"-\"), ord(\"-\"))\n+\n+            info_window.addstr(\n+                1, 1, f\"PEER {peer.id} ({peer.address})\".center(68), curses.A_REVERSE | curses.A_BOLD)\n+            info_window.addstr(\n+                2, 1, f\" OUR NODE{peer.connection_type:^54}PEER \",\n+                curses.A_BOLD)\n+            for i, msg in enumerate(peer.last_messages):\n+                if msg.inbound:\n+                    info_window.addstr(\n+                        i + 3, 1, \"%68s\" %\n+                        (f\"<--- {msg.msg_type} ({msg.size} bytes) \"), curses.A_NORMAL)\n+                else:\n+                    info_window.addstr(\n+                        i + 3, 1, \" %s (%d byte) --->\" %\n+                        (msg.msg_type, msg.size), curses.A_NORMAL)\n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) < 2:\n+        print(\"USAGE:\", sys.argv[0], \"path/to/bitcoind\")\n+        exit()\n+    path = sys.argv[1]\n+    main(path)"
      },
      {
        "sha": "51c151add826f186fee09dcde4b680b76c23f07a",
        "filename": "contrib/verifybinaries/verify.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/contrib/verifybinaries/verify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/contrib/verifybinaries/verify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/verify.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -2,7 +2,7 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitoin Core release binaries\n+\"\"\"Script for verifying Bitcoin Core release binaries\n \n This script attempts to download the signature file SHA256SUMS.asc from\n bitcoincore.org and bitcoin.org and compares them."
      },
      {
        "sha": "a3b9cd20991180dc760ee964b6403600be577658",
        "filename": "depends/Makefile",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/Makefile?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,7 +1,7 @@\n .NOTPARALLEL :\n \n # Pattern rule to print variables, e.g. make print-top_srcdir\n-print-%:\n+print-%: FORCE\n \t@echo '$*'='$($*)'\n \n # When invoking a sub-make, keep only the command line variable definitions\n@@ -284,3 +284,4 @@ download: download-osx download-linux download-win\n $(foreach package,$(all_packages),$(eval $(call ext_add_stages,$(package))))\n \n .PHONY: install cached clean clean-all download-one download-osx download-linux download-win download check-packages check-sources\n+.PHONY: FORCE"
      },
      {
        "sha": "0af5412d94c4e5bcef516b209a2f0b30ce05fa92",
        "filename": "depends/packages/libevent.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/packages/libevent.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/packages/libevent.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libevent.mk?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,6 +16,10 @@ define $(package)_set_vars\n   $(package)_cppflags_mingw32=-D_WIN32_WINNT=0x0601\n endef\n \n+define $(package)_preprocess_cmds\n+  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub build-aux\n+endef\n+\n define $(package)_config_cmds\n   $($(package)_autoconf)\n endef"
      },
      {
        "sha": "d169eb6723184e51ef7f512b0afeefb02e242194",
        "filename": "depends/packages/native_cctools.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/packages/native_cctools.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/packages/native_cctools.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_cctools.mk?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,6 +16,10 @@ define $(package)_set_vars\n   $(package)_cxx=$(clangxx_prog)\n endef\n \n+define $(package)_preprocess_cmds\n+  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub cctools\n+endef\n+\n define $(package)_config_cmds\n   $($(package)_autoconf)\n endef"
      },
      {
        "sha": "25ac77c1a34ad8350050a3563a205f950a5c13ae",
        "filename": "depends/packages/native_clang.mk",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/packages/native_clang.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/packages/native_clang.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_clang.mk?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,9 +1,15 @@\n package=native_clang\n $(package)_version=10.0.1\n $(package)_download_path=https://github.com/llvm/llvm-project/releases/download/llvmorg-$($(package)_version)\n+ifneq (,$(findstring aarch64,$(BUILD)))\n+$(package)_download_file=clang+llvm-$($(package)_version)-aarch64-linux-gnu.tar.xz\n+$(package)_file_name=clang+llvm-$($(package)_version)-aarch64-linux-gnu.tar.xz\n+$(package)_sha256_hash=90dc69a4758ca15cd0ffa45d07fbf5bf4309d47d2c7745a9f0735ecffde9c31f\n+else\n $(package)_download_file=clang+llvm-$($(package)_version)-x86_64-linux-gnu-ubuntu-16.04.tar.xz\n $(package)_file_name=clang+llvm-$($(package)_version)-x86_64-linux-gnu-ubuntu-16.04.tar.xz\n $(package)_sha256_hash=48b83ef827ac2c213d5b64f5ad7ed082c8bcb712b46644e0dc5045c6f462c231\n+endif\n \n define $(package)_preprocess_cmds\n   rm -f $($(package)_extract_dir)/lib/libc++abi.so*"
      },
      {
        "sha": "9004b064d6e9e71141e4339d5208dc6b4dacd959",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 21,
        "deletions": 35,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -6,9 +6,11 @@ $(package)_file_name=qtbase-$($(package)_suffix)\n $(package)_sha256_hash=1c1b4e33137ca77881074c140d54c3c9747e845a31338cfe8680f171f0bc3a39\n $(package)_linux_dependencies=freetype fontconfig libxcb libxkbcommon\n $(package)_qt_libs=corelib network widgets gui plugins testlib\n-$(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_no_printer.patch no-xlib.patch\n-$(package)_patches+= fix_android_qmake_conf.patch fix_android_jni_static.patch dont_hardcode_pwd.patch\n-$(package)_patches+= drop_lrelease_dependency.patch no_sdk_version_check.patch\n+$(package)_linguist_tools = lrelease lupdate lconvert\n+$(package)_patches = qt.pro qttools_src.pro\n+$(package)_patches += fix_qt_pkgconfig.patch mac-qmake.conf fix_no_printer.patch no-xlib.patch\n+$(package)_patches += support_new_android_ndks.patch fix_android_jni_static.patch dont_hardcode_pwd.patch\n+$(package)_patches+= no_sdk_version_check.patch\n $(package)_patches+= fix_lib_paths.patch fix_android_pch.patch\n $(package)_patches+= qtbase-moc-ignore-gcc-macro.patch fix_limits_header.patch\n \n@@ -64,6 +66,7 @@ $(package)_config_opts += -no-system-proxies\n $(package)_config_opts += -no-use-gold-linker\n $(package)_config_opts += -nomake examples\n $(package)_config_opts += -nomake tests\n+$(package)_config_opts += -nomake tools\n $(package)_config_opts += -opensource\n $(package)_config_opts += -pkg-config\n $(package)_config_opts += -prefix $(host_prefix)\n@@ -113,14 +116,13 @@ $(package)_config_opts_darwin = -no-dbus\n $(package)_config_opts_darwin += -no-opengl\n $(package)_config_opts_darwin += -pch\n $(package)_config_opts_darwin += -no-feature-corewlan\n-$(package)_config_opts_darwin += -device-option QMAKE_MACOSX_DEPLOYMENT_TARGET=$(OSX_MIN_VERSION)\n+$(package)_config_opts_darwin += QMAKE_MACOSX_DEPLOYMENT_TARGET=$(OSX_MIN_VERSION)\n \n ifneq ($(build_os),darwin)\n $(package)_config_opts_darwin += -xplatform macx-clang-linux\n $(package)_config_opts_darwin += -device-option MAC_SDK_PATH=$(OSX_SDK)\n $(package)_config_opts_darwin += -device-option MAC_SDK_VERSION=$(OSX_SDK_VERSION)\n $(package)_config_opts_darwin += -device-option CROSS_COMPILE=\"$(host)-\"\n-$(package)_config_opts_darwin += -device-option MAC_MIN_VERSION=$(OSX_MIN_VERSION)\n $(package)_config_opts_darwin += -device-option MAC_TARGET=$(host)\n $(package)_config_opts_darwin += -device-option XCODE_VERSION=$(XCODE_VERSION)\n endif\n@@ -201,38 +203,35 @@ endef\n #\n # 1. Apply our patches to the extracted source. See each patch for more info.\n #\n-# 2. Point to lrelease in qttools/bin/lrelease; otherwise Qt will look for it in\n-# $(host)/native/bin/lrelease and not find it.\n+# 2. Create a macOS-Clang-Linux mkspec using our mac-qmake.conf.\n #\n-# 3. Create a macOS-Clang-Linux mkspec using our mac-qmake.conf.\n-#\n-# 4. After making a copy of the mkspec for the linux-arm-gnueabi host, named\n+# 3. After making a copy of the mkspec for the linux-arm-gnueabi host, named\n # bitcoin-linux-g++, replace instances of linux-arm-gnueabi with $(host). This\n # way we can generically support hosts like riscv64-linux-gnu, which Qt doesn't\n # ship a mkspec for. See it's usage in config_opts_* above.\n #\n-# 5. Put our C, CXX and LD FLAGS into gcc-base.conf. Only used for non-host builds.\n+# 4. Put our C, CXX and LD FLAGS into gcc-base.conf. Only used for non-host builds.\n #\n-# 6. Do similar for the win32-g++ mkspec.\n+# 5. Do similar for the win32-g++ mkspec.\n #\n-# 7. In clang.conf, swap out clang & clang++, for our compiler + flags. See #17466.\n+# 6. In clang.conf, swap out clang & clang++, for our compiler + flags. See #17466.\n #\n-# 8. Adjust a regex in toolchain.prf, to accommodate Guix's usage of\n+# 7. Adjust a regex in toolchain.prf, to accommodate Guix's usage of\n # CROSS_LIBRARY_PATH. See #15277.\n define $(package)_preprocess_cmds\n-  patch -p1 -i $($(package)_patch_dir)/drop_lrelease_dependency.patch && \\\n+  cp $($(package)_patch_dir)/qt.pro qt.pro && \\\n+  cp $($(package)_patch_dir)/qttools_src.pro qttools/src/src.pro && \\\n   patch -p1 -i $($(package)_patch_dir)/dont_hardcode_pwd.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_qt_pkgconfig.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_no_printer.patch && \\\n-  patch -p1 -i $($(package)_patch_dir)/fix_android_qmake_conf.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/support_new_android_ndks.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_android_jni_static.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_android_pch.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/no-xlib.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/no_sdk_version_check.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_lib_paths.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/qtbase-moc-ignore-gcc-macro.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_limits_header.patch && \\\n-  sed -i.old \"s|updateqm.commands = \\$$$$\\$$$$LRELEASE|updateqm.commands = $($(package)_extract_dir)/qttools/bin/lrelease|\" qttranslations/translations/translations.pro && \\\n   mkdir -p qtbase/mkspecs/macx-clang-linux &&\\\n   cp -f qtbase/mkspecs/macx-clang/qplatformdefs.h qtbase/mkspecs/macx-clang-linux/ &&\\\n   cp -f $($(package)_patch_dir)/mac-qmake.conf qtbase/mkspecs/macx-clang-linux/qmake.conf && \\\n@@ -249,35 +248,22 @@ endef\n define $(package)_config_cmds\n   export PKG_CONFIG_SYSROOT_DIR=/ && \\\n   export PKG_CONFIG_LIBDIR=$(host_prefix)/lib/pkgconfig && \\\n-  export PKG_CONFIG_PATH=$(host_prefix)/share/pkgconfig  && \\\n+  export PKG_CONFIG_PATH=$(host_prefix)/share/pkgconfig && \\\n   cd qtbase && \\\n-  ./configure $($(package)_config_opts) && \\\n-  cd .. && \\\n-  $(MAKE) -C qtbase sub-src-clean && \\\n-  qtbase/bin/qmake -o qttranslations/Makefile qttranslations/qttranslations.pro && \\\n-  qtbase/bin/qmake -o qttranslations/translations/Makefile qttranslations/translations/translations.pro && \\\n-  qtbase/bin/qmake -o qttools/src/linguist/lrelease/Makefile qttools/src/linguist/lrelease/lrelease.pro && \\\n-  qtbase/bin/qmake -o qttools/src/linguist/lupdate/Makefile qttools/src/linguist/lupdate/lupdate.pro && \\\n-  qtbase/bin/qmake -o qttools/src/linguist/lconvert/Makefile qttools/src/linguist/lconvert/lconvert.pro\n+  ./configure -top-level $($(package)_config_opts)\n endef\n \n define $(package)_build_cmds\n-  $(MAKE) -C qtbase/src $(addprefix sub-,$($(package)_qt_libs)) && \\\n-  $(MAKE) -C qttools/src/linguist/lrelease && \\\n-  $(MAKE) -C qttools/src/linguist/lupdate && \\\n-  $(MAKE) -C qttools/src/linguist/lconvert && \\\n-  $(MAKE) -C qttranslations\n+  $(MAKE)\n endef\n \n define $(package)_stage_cmds\n   $(MAKE) -C qtbase/src INSTALL_ROOT=$($(package)_staging_dir) $(addsuffix -install_subtargets,$(addprefix sub-,$($(package)_qt_libs))) && \\\n-  $(MAKE) -C qttools/src/linguist/lrelease INSTALL_ROOT=$($(package)_staging_dir) install_target && \\\n-  $(MAKE) -C qttools/src/linguist/lupdate INSTALL_ROOT=$($(package)_staging_dir) install_target && \\\n-  $(MAKE) -C qttools/src/linguist/lconvert INSTALL_ROOT=$($(package)_staging_dir) install_target && \\\n+  $(MAKE) -C qttools/src/linguist INSTALL_ROOT=$($(package)_staging_dir) $(addsuffix -install_subtargets,$(addprefix sub-,$($(package)_linguist_tools))) && \\\n   $(MAKE) -C qttranslations INSTALL_ROOT=$($(package)_staging_dir) install_subtargets\n endef\n \n define $(package)_postprocess_cmds\n   rm -rf native/mkspecs/ native/lib/ lib/cmake/ && \\\n-  rm -f lib/lib*.la lib/*.prl plugins/*/*.prl\n+  rm -f lib/lib*.la\n endef"
      },
      {
        "sha": "af5e0d09c9dc8600908639df7a7da581b1d0bd77",
        "filename": "depends/packages/sqlite.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/packages/sqlite.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/packages/sqlite.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/sqlite.mk?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -9,6 +9,10 @@ $(package)_config_opts=--disable-shared --disable-readline --disable-dynamic-ext\n $(package)_config_opts_linux=--with-pic\n endef\n \n+define $(package)_preprocess_cmds\n+  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub .\n+endef\n+\n define $(package)_config_cmds\n   $($(package)_autoconf)\n endef"
      },
      {
        "sha": "9b918af77c464278eb796f20fcf7bc67d04e3dad",
        "filename": "depends/patches/qt/drop_lrelease_dependency.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60afee48c306cf16a19ea1914f1bae96987f063a/depends/patches/qt/drop_lrelease_dependency.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60afee48c306cf16a19ea1914f1bae96987f063a/depends/patches/qt/drop_lrelease_dependency.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/drop_lrelease_dependency.patch?ref=60afee48c306cf16a19ea1914f1bae96987f063a",
        "patch": "@@ -1,20 +0,0 @@\n-commit 67b3ed7406e1d0762188dbad2c44a06824ba0778\n-Author: fanquake <fanquake@gmail.com>\n-Date:   Tue Aug 18 15:24:01 2020 +0800\n-\n-    Drop dependency on lrelease\n-\n-    Qts buildsystem insists on using the installed lrelease, but gets\n-    confused about how to find it. Since we manually control the build\n-    order, just drop the dependency.\n-\n-    See #9469\n-\n-diff --git a/qttranslations/translations/translations.pro b/qttranslations/translations/translations.pro\n-index 694544c..eff339d 100644\n---- a/qttranslations/translations/translations.pro\n-+++ b/qttranslations/translations/translations.pro\n-@@ -107,3 +107,2 @@ updateqm.commands = $$LRELEASE ${QMAKE_FILE_IN} -qm ${QMAKE_FILE_OUT}\n- silent:updateqm.commands = @echo lrelease ${QMAKE_FILE_IN} && $$updateqm.commands\n--updateqm.depends = $$LRELEASE_EXE\n- updateqm.name = LRELEASE ${QMAKE_FILE_IN}"
      },
      {
        "sha": "195e1c5e592a15eeb20688a241aec245ea33e2f1",
        "filename": "depends/patches/qt/fix_android_pch.patch",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/fix_android_pch.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/fix_android_pch.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_android_pch.patch?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,6 +1,6 @@\n --- old/qtbase/mkspecs/common/android-base-head.conf\n +++ new/qtbase/mkspecs/common/android-base-head.conf\n-@@ -73,6 +73,6 @@ CROSS_COMPILE = $$NDK_TOOLCHAIN_PATH/bin/$$NDK_TOOLS_PREFIX-\n+@@ -72,6 +72,6 @@ CROSS_COMPILE = $$NDK_TOOLCHAIN_PATH/bin/$$NDK_TOOLS_PREFIX-\n  QMAKE_PCH_OUTPUT_EXT    = .gch\n \n  QMAKE_CFLAGS_PRECOMPILE       = -x c-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}"
      },
      {
        "sha": "3a8753fd1d74c88116e65ec019d70d8ed4772582",
        "filename": "depends/patches/qt/fix_android_qmake_conf.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60afee48c306cf16a19ea1914f1bae96987f063a/depends/patches/qt/fix_android_qmake_conf.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60afee48c306cf16a19ea1914f1bae96987f063a/depends/patches/qt/fix_android_qmake_conf.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_android_qmake_conf.patch?ref=60afee48c306cf16a19ea1914f1bae96987f063a",
        "patch": "@@ -1,10 +0,0 @@\n---- old/qtbase/mkspecs/android-clang/qmake.conf\n-+++ new/qtbase/mkspecs/android-clang/qmake.conf\n-@@ -47,7 +47,7 @@ ANDROID_STDCPP_PATH = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++_shared.so\n- ANDROID_USE_LLVM = true\n- \n- exists($$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++.so): \\\n--    ANDROID_CXX_STL_LIBS = -lc++\n-+    ANDROID_CXX_STL_LIBS = -lc++_shared\n- else: \\\n-     ANDROID_CXX_STL_LIBS = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++.so.$$replace(ANDROID_PLATFORM, \"android-\", \"\")"
      },
      {
        "sha": "190ab7a160e49bf135c6991e84edc4c27f6d15de",
        "filename": "depends/patches/qt/mac-qmake.conf",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/mac-qmake.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/mac-qmake.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/mac-qmake.conf?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,7 +8,6 @@ include(../common/clang-mac.conf)\n QMAKE_MAC_SDK_PATH=$${MAC_SDK_PATH}\n QMAKE_XCODE_VERSION = $${XCODE_VERSION}\n QMAKE_XCODE_DEVELOPER_PATH=/Developer\n-QMAKE_MACOSX_DEPLOYMENT_TARGET = $${MAC_MIN_VERSION}\n QMAKE_MAC_SDK=macosx\n QMAKE_MAC_SDK.macosx.Path = $${MAC_SDK_PATH}\n QMAKE_MAC_SDK.macosx.platform_name = macosx"
      },
      {
        "sha": "8f2e900a840fbd3f19dd77772d1157cdefbe1527",
        "filename": "depends/patches/qt/qt.pro",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/qt.pro?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,16 @@\n+# Create the super cache so modules will add themselves to it.\n+cache(, super)\n+\n+!QTDIR_build: cache(CONFIG, add, $$list(QTDIR_build))\n+\n+prl = no_install_prl\n+CONFIG += $$prl\n+cache(CONFIG, add stash, prl)\n+\n+TEMPLATE = subdirs\n+SUBDIRS = qtbase qttools qttranslations\n+\n+qttools.depends = qtbase\n+qttranslations.depends = qttools\n+\n+load(qt_configure)"
      },
      {
        "sha": "6ef71a094273503f3cdac2618e3877e428bfb52b",
        "filename": "depends/patches/qt/qttools_src.pro",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/qttools_src.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/qttools_src.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/qttools_src.pro?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,6 @@\n+TEMPLATE = subdirs\n+SUBDIRS = linguist\n+\n+fb = force_bootstrap\n+CONFIG += $$fb\n+cache(CONFIG, add, fb)"
      },
      {
        "sha": "85c8ae2132af5ffc84c2269b9201d37389a14014",
        "filename": "depends/patches/qt/support_new_android_ndks.patch",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/support_new_android_ndks.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/depends/patches/qt/support_new_android_ndks.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/support_new_android_ndks.patch?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,122 @@\n+Follow Google's BuildSystemMaintainers doc to support future NDK releases.\n+\n+Upstream commit:\n+ - Qt 5.14: 9b14950ff600a4ce5a8698b67ab38907c50417f1\n+\n+--- old/qtbase/mkspecs/android-clang/qmake.conf\n++++ new/qtbase/mkspecs/android-clang/qmake.conf\n+@@ -14,43 +14,29 @@\n+ QMAKE_CC      = $$NDK_LLVM_PATH/bin/clang\n+ QMAKE_CXX     = $$NDK_LLVM_PATH/bin/clang++\n+ \n++# Follow https://android.googlesource.com/platform/ndk/+/ndk-release-r20/docs/BuildSystemMaintainers.md\n++\n+ equals(ANDROID_TARGET_ARCH, armeabi-v7a): \\\n+-    QMAKE_CFLAGS += -target armv7-none-linux-androideabi\n+-else: equals(ANDROID_TARGET_ARCH, armeabi): \\\n+-    QMAKE_CFLAGS += -target armv5te-none-linux-androideabi\n++    QMAKE_CFLAGS = -target armv7a-linux-androideabi$$replace(ANDROID_PLATFORM, \"android-\", \"\")\n+ else: equals(ANDROID_TARGET_ARCH, arm64-v8a): \\\n+-    QMAKE_CFLAGS += -target aarch64-none-linux-android\n++    QMAKE_CFLAGS = -target aarch64-linux-android$$replace(ANDROID_PLATFORM, \"android-\", \"\")\n+ else: equals(ANDROID_TARGET_ARCH, x86): \\\n+-    QMAKE_CFLAGS += -target i686-none-linux-android -mstackrealign\n++    QMAKE_CFLAGS = -target i686-linux-android$$replace(ANDROID_PLATFORM, \"android-\", \"\") -mstackrealign\n+ else: equals(ANDROID_TARGET_ARCH, x86_64): \\\n+-    QMAKE_CFLAGS += -target x86_64-none-linux-android\n+-else: equals(ANDROID_TARGET_ARCH, mips): \\\n+-    QMAKE_CFLAGS += -target mipsel-none-linux-android\n+-else: equals(ANDROID_TARGET_ARCH, mips64): \\\n+-    QMAKE_CFLAGS += -target mips64el-none-linux-android\n+-\n+-QMAKE_CFLAGS += -gcc-toolchain $$NDK_TOOLCHAIN_PATH -fno-limit-debug-info\n+-\n+-QMAKE_LINK    = $$QMAKE_CXX $$QMAKE_CFLAGS -Wl,--exclude-libs,libgcc.a -Wl,--exclude-libs,libatomic.a -nostdlib++\n+-equals(ANDROID_TARGET_ARCH, armeabi-v7a): QMAKE_LINK += -Wl,--exclude-libs,libunwind.a\n+-\n+-QMAKE_CFLAGS += -DANDROID_HAS_WSTRING --sysroot=$$NDK_ROOT/sysroot \\\n+-                -isystem $$NDK_ROOT/sysroot/usr/include/$$NDK_TOOLS_PREFIX \\\n+-                -isystem $$NDK_ROOT/sources/cxx-stl/llvm-libc++/include \\\n+-                -isystem $$NDK_ROOT/sources/android/support/include \\\n+-                -isystem $$NDK_ROOT/sources/cxx-stl/llvm-libc++abi/include\n++    QMAKE_CFLAGS = -target x86_64-linux-android$$replace(ANDROID_PLATFORM, \"android-\", \"\")\n+ \n+-ANDROID_SOURCES_CXX_STL_LIBDIR = $$NDK_ROOT/sources/cxx-stl/llvm-libc++/libs/$$ANDROID_TARGET_ARCH\n++QMAKE_CFLAGS += -fno-limit-debug-info\n+ \n+-ANDROID_STDCPP_PATH = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++_shared.so\n++QMAKE_LINK    = $$QMAKE_CXX $$QMAKE_CFLAGS\n+ \n+-ANDROID_USE_LLVM = true\n++ANDROID_STDCPP_PATH = $$NDK_LLVM_PATH/sysroot/usr/lib/$$NDK_TOOLS_PREFIX/libc++_shared.so\n+ \n+-exists($$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++.so): \\\n+-    ANDROID_CXX_STL_LIBS = -lc++\n+-else: \\\n+-    ANDROID_CXX_STL_LIBS = $$ANDROID_SOURCES_CXX_STL_LIBDIR/libc++.so.$$replace(ANDROID_PLATFORM, \"android-\", \"\")\n++ANDROID_USE_LLVM = true\n+ \n+-QMAKE_CFLAGS_OPTIMIZE_SIZE = -Oz\n++QMAKE_CFLAGS_OPTIMIZE_SIZE  = -Oz\n++QMAKE_LIBDIR_POST           =\n++QMAKE_LFLAGS                =\n++QMAKE_LIBS_PRIVATE          =\n++ANDROID_CXX_STL_LIBS        =\n+ \n+ include(../common/android-base-tail.conf)\n+\n+--- old/qtbase/mkspecs/common/android-base-head.conf\n++++ new/qtbase/mkspecs/common/android-base-head.conf\n+@@ -64,7 +58,6 @@\n+ }\n+ \n+ CONFIG += $$ANDROID_PLATFORM\n+-QMAKE_CFLAGS = -D__ANDROID_API__=$$replace(ANDROID_PLATFORM, \"android-\", \"\")\n+ \n+ ANDROID_PLATFORM_ROOT_PATH  = $$NDK_ROOT/platforms/$$ANDROID_PLATFORM/arch-$$ANDROID_ARCHITECTURE/\n+ \n+--- old/qtbase/mkspecs/common/android-base-tail.conf\n++++ new/qtbase/mkspecs/common/android-base-tail.conf\n+@@ -6,22 +6,17 @@\n+ QMAKE_CFLAGS += -fstack-protector-strong -DANDROID\n+ \n+ equals(ANDROID_TARGET_ARCH, armeabi-v7a): \\\n+-    QMAKE_CFLAGS += -march=armv7-a -mfloat-abi=softfp -mfpu=vfp -fno-builtin-memmove\n++    QMAKE_CFLAGS += -march=armv7-a -mfloat-abi=softfp -mfpu=vfp\n+ else: equals(ANDROID_TARGET_ARCH, armeabi): \\\n+-    QMAKE_CFLAGS += -march=armv5te -mtune=xscale -msoft-float -fno-builtin-memmove\n+-# -fno-builtin-memmove is used to workaround https://code.google.com/p/android/issues/detail?id=81692\n++    QMAKE_CFLAGS += -march=armv5te -mtune=xscale -msoft-float\n+ \n+ QMAKE_CFLAGS_WARN_ON    = -Wall -W\n+ QMAKE_CFLAGS_WARN_OFF   =\n+ equals(ANDROID_TARGET_ARCH, armeabi-v7a) | equals(ANDROID_TARGET_ARCH, armeabi) {\n+     CONFIG += optimize_size\n+     QMAKE_CFLAGS_DEBUG                     = -g -marm -O0\n+-    equals(ANDROID_TARGET_ARCH, armeabi):if(equals(NDK_TOOLCHAIN_VERSION, 4.8)|equals(NDK_TOOLCHAIN_VERSION, 4.9)) {\n+-        DEFINES += QT_OS_ANDROID_GCC_48_WORKAROUND\n+-    } else {\n+-        QMAKE_CFLAGS_RELEASE += -mthumb\n+-        QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -mthumb\n+-    }\n++    QMAKE_CFLAGS_RELEASE += -mthumb\n++    QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -mthumb\n+ }\n+ \n+ QMAKE_CFLAGS_SHLIB      = -fPIC\n+@@ -61,15 +56,12 @@\n+ QMAKE_RANLIB            = $${CROSS_COMPILE}ranlib\n+ \n+ QMAKE_INCDIR_POST       =\n+-QMAKE_LIBDIR_POST       = $$ANDROID_SOURCES_CXX_STL_LIBDIR\n+ QMAKE_INCDIR_X11        =\n+ QMAKE_LIBDIR_X11        =\n+ QMAKE_INCDIR_OPENGL     =\n+ QMAKE_LIBDIR_OPENGL     =\n+ \n+ QMAKE_LINK_SHLIB        = $$QMAKE_LINK\n+-QMAKE_LFLAGS            = --sysroot=$$ANDROID_PLATFORM_ROOT_PATH\n+-equals(ANDROID_TARGET_ARCH, x86_64) QMAKE_LFLAGS += -L$$ANDROID_PLATFORM_ROOT_PATH/usr/lib64\n+ QMAKE_LFLAGS_APP        = -Wl,--no-undefined -Wl,-z,noexecstack -shared\n+ QMAKE_LFLAGS_SHLIB      = -Wl,--no-undefined -Wl,-z,noexecstack -shared\n+ QMAKE_LFLAGS_PLUGIN     = $$QMAKE_LFLAGS_SHLIB"
      },
      {
        "sha": "d8fd46d1c7d0b270fb4eba54ce171b3effd6c39b",
        "filename": "doc/Doxyfile.in",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/Doxyfile.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/Doxyfile.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/Doxyfile.in?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -863,9 +863,7 @@ RECURSIVE              = YES\n \n EXCLUDE                = src/crc32c \\\n                          src/leveldb \\\n-                         src/json \\\n-                         src/test \\\n-                         src/qt/test\n+                         src/json\n \n # The EXCLUDE_SYMLINKS tag can be used to select whether or not files or\n # directories that are symbolic links (a Unix file system feature) are excluded"
      },
      {
        "sha": "6e54f67edc7ad3d152a71d59d17874b07bfaf97a",
        "filename": "doc/build-openbsd.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/build-openbsd.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/build-openbsd.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-openbsd.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -68,7 +68,7 @@ export AUTOMAKE_VERSION=1.16\n Make sure `BDB_PREFIX` is set to the appropriate path from the above steps.\n \n Note that building with external signer support currently fails on OpenBSD,\n-hence you have to explicitely disable it by passing the parameter\n+hence you have to explicitly disable it by passing the parameter\n `--disable-external-signer` to the configure script.\n (Background: the feature requires the header-only library boost::process, which\n is available on OpenBSD 6.9 via Boost 1.72.0, but contains certain system calls"
      },
      {
        "sha": "4a56114109e49e2a80d8e7a1db260871a7b1f303",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -48,6 +48,7 @@ Optional dependencies:\n  univalue    | Utility          | JSON parsing and encoding (bundled version will be used unless --with-system-univalue passed to configure)\n  libzmq3     | ZMQ notification | Optional, allows generating ZMQ notifications (requires ZMQ version >= 4.0.0)\n  sqlite3     | SQLite DB        | Optional, wallet storage (only needed when wallet enabled)\n+ systemtap   | Tracing (USDT)   | Optional, statically defined tracepoints\n \n For the versions used, see [dependencies.md](dependencies.md)\n \n@@ -107,6 +108,10 @@ ZMQ dependencies (provides ZMQ API):\n \n     sudo apt-get install libzmq3-dev\n \n+User-Space, Statically Defined Tracing (USDT) dependencies:\n+\n+    sudo apt install systemtap-sdt-dev\n+\n GUI dependencies:\n \n If you want to build bitcoin-qt, make sure that the required packages for Qt development\n@@ -162,6 +167,10 @@ ZMQ dependencies (provides ZMQ API):\n \n     sudo dnf install zeromq-devel\n \n+User-Space, Statically Defined Tracing (USDT) dependencies:\n+\n+    sudo dnf install systemtap\n+\n GUI dependencies:\n \n If you want to build bitcoin-qt, make sure that the required packages for Qt development"
      },
      {
        "sha": "b7634718e8d61ae57593094308db27b6f95fb357",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -24,6 +24,7 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | Qt | [5.12.11](https://download.qt.io/official_releases/qt/) | [5.9.5](https://github.com/bitcoin/bitcoin/issues/20104) | No |  |  |\n | SQLite | [3.32.1](https://sqlite.org/download.html) | [3.7.17](https://github.com/bitcoin/bitcoin/pull/19077) |  |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Linux only) |\n+| systemtap ([tracing](tracing.md))|  |  |  |  | |\n | xkbcommon |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Linux only) |\n | ZeroMQ | [4.3.1](https://github.com/zeromq/libzmq/releases) | 4.0.0 | No |  |  |\n | zlib |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n@@ -41,6 +42,7 @@ Some dependencies are not needed in all configurations. The following are some f\n * SQLite is not needed with `--disable-wallet` or `--without-sqlite`.\n * Qt is not needed with `--without-gui`.\n * If the qrencode dependency is absent, QR support won't be added. To force an error when that happens, pass `--with-qrencode`.\n+* If the systemtap dependency is absent, USDT support won't compiled in.\n * ZeroMQ is needed only with the `--with-zmq` option.\n \n #### Other"
      },
      {
        "sha": "f88d3f91a1c166a6997872eacb295799a78f0338",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -56,7 +56,6 @@ Subdirectory       | File(s)               | Description\n `indexes/coinstats/db/` | LevelDB database | Coinstats index; *optional*, used if `-coinstatsindex=1`\n `wallets/`         |                       | [Contains wallets](#multi-wallet-environment); can be specified by `-walletdir` option; if `wallets/` subdirectory does not exist, wallets reside in the [data directory](#data-directory-location)\n `./`               | `anchors.dat`         | Anchor IP address database, created on shutdown and deleted at startup. Anchors are last known outgoing block-relay-only peers that are tried to re-connect to on startup\n-`./`               | `banlist.dat`         | Stores the addresses/subnets of banned nodes (deprecated). `bitcoind` or `bitcoin-qt` no longer save the banlist to this file, but read it on startup if `banlist.json` is not present.\n `./`               | `banlist.json`        | Stores the addresses/subnets of banned nodes.\n `./`               | `bitcoin.conf`        | User-defined [configuration settings](bitcoin-conf.md) for `bitcoind` or `bitcoin-qt`. File is not written to by the software and must be created manually. Path can be specified by `-conf` option\n `./`               | `bitcoind.pid`        | Stores the process ID (PID) of `bitcoind` or `bitcoin-qt` while running; created at start and deleted on shutdown; can be specified by `-pid` option\n@@ -114,6 +113,7 @@ These subdirectories and files are no longer used by Bitcoin Core:\n \n Path           | Description | Repository notes\n ---------------|-------------|-----------------\n+`banlist.dat`  | Stores the addresses/subnets of banned nodes; superseded by `banlist.json` in 22.0 and completely ignored in 23.0 | [PR #20966](https://github.com/bitcoin/bitcoin/pull/20966), [PR #22570](https://github.com/bitcoin/bitcoin/pull/22570)\n `blktree/`     | Blockchain index; replaced by `blocks/index/` in [0.8.0](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.8.0.md#improvements) | [PR #2231](https://github.com/bitcoin/bitcoin/pull/2231), [`8fdc94cc`](https://github.com/bitcoin/bitcoin/commit/8fdc94cc8f0341e96b1edb3a5b56811c0b20bd15)\n `coins/`       | Unspent transaction output database; replaced by `chainstate/` in 0.8.0 | [PR #2231](https://github.com/bitcoin/bitcoin/pull/2231), [`8fdc94cc`](https://github.com/bitcoin/bitcoin/commit/8fdc94cc8f0341e96b1edb3a5b56811c0b20bd15)\n `blkindex.dat` | Blockchain index BDB database; replaced by {`chainstate/`, `blocks/index/`, `blocks/revNNNNN.dat`<sup>[\\[2\\]](#note2)</sup>} in 0.8.0 | [PR #1677](https://github.com/bitcoin/bitcoin/pull/1677)"
      },
      {
        "sha": "66057495579db6134f51abfc8465f5aab2e5cc3c",
        "filename": "doc/fuzzing.md",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/fuzzing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/fuzzing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/fuzzing.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -83,6 +83,10 @@ INFO: seed corpus: files: 991 min: 1b max: 1858b total: 288291b rss: 150Mb\n \u2026\n ```\n \n+## Run without sanitizers for increased throughput\n+\n+Fuzzing on a harness compiled with `--with-sanitizers=address,fuzzer,undefined` is good for finding bugs. However, the very slow execution even under libFuzzer will limit the ability to find new coverage. A good approach is to perform occasional long runs without the additional bug-detectors (configure `--with-sanitizers=fuzzer`) and then merge new inputs into a corpus as described in the qa-assets repo (https://github.com/bitcoin-core/qa-assets/blob/main/.github/PULL_REQUEST_TEMPLATE.md).  Patience is useful; even with improved throughput, libFuzzer may need days and 10s of millions of executions to reach deep/hard targets.\n+\n ## Reproduce a fuzzer crash reported by the CI\n \n - `cd` into the `qa-assets` directory and update it with `git pull qa-assets`"
      },
      {
        "sha": "3a507a25abfd96d52a9a6ce182dce45070e7f593",
        "filename": "doc/i2p.md",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/i2p.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/i2p.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/i2p.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -47,13 +47,21 @@ information in the debug log about your I2P configuration and connections. Run\n `bitcoin-cli help logging` for more information.\n \n It is possible to restrict outgoing connections in the usual way with\n-`onlynet=i2p`. I2P support was added to Bitcoin Core in version 22.0 (mid 2021)\n+`onlynet=i2p`. I2P support was added to Bitcoin Core in version 22.0 (mid-2021)\n and there may be fewer I2P peers than Tor or IP ones. Therefore, using\n `onlynet=i2p` alone (without other `onlynet=`) may make a node more susceptible\n to [Sybil attacks](https://en.bitcoin.it/wiki/Weaknesses#Sybil_attack). Use\n `bitcoin-cli -addrinfo` to see the number of I2P addresses known to your node.\n \n-## I2P related information in Bitcoin Core\n+Another consideration with `onlynet=i2p` is that the initial blocks download\n+phase when syncing up a new node can be very slow. This phase can be sped up by\n+using other networks, for instance `onlynet=onion`, at the same time.\n+\n+In general, a node can be run with both onion and I2P hidden services (or\n+any/all of IPv4/IPv6/onion/I2P), which can provide a potential fallback if one\n+of the networks has issues.\n+\n+## I2P-related information in Bitcoin Core\n \n There are several ways to see your I2P address in Bitcoin Core:\n - in the debug log (grep for `AddLocal`, the I2P address ends in `.b32.i2p`)"
      },
      {
        "sha": "61c65d5a3eedf2608b7fb52cec57e0c7580ce57e",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 16,
        "deletions": 121,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,5 +1,3 @@\n-# Release notes now being edited on https://github.com/bitcoin-core/bitcoin-devwiki/wiki/22.0-Release-Notes-draft\n-\n *After branching off for a major version release of Bitcoin Core, use this\n template to create the initial release notes draft.*\n \n@@ -8,7 +6,7 @@ template to create the initial release notes draft.*\n for the process.*\n \n *Create the draft, named* \"*version* Release Notes Draft\"\n-*(e.g. \"0.20.0 Release Notes Draft\"), as a collaborative wiki in:*\n+*(e.g. \"22.0 Release Notes Draft\"), as a collaborative wiki in:*\n \n https://github.com/bitcoin-core/bitcoin-devwiki/wiki/\n \n@@ -53,141 +51,49 @@ Core should also work on most other Unix-like systems but is not as\n frequently tested on them.  It is not recommended to use Bitcoin Core on\n unsupported systems.\n \n-From Bitcoin Core 22.0 onwards, macOS versions earlier than 10.14 are no longer supported.\n-\n Notable changes\n ===============\n \n P2P and network changes\n -----------------------\n \n-- This release removes support for Tor version 2 hidden services in favor of Tor\n-  v3 only, as the Tor network [dropped support for Tor\n-  v2](https://blog.torproject.org/v2-deprecation-timeline) with the release of\n-  Tor version 0.4.6.  Henceforth, Bitcoin Core ignores Tor v2 addresses; it\n-  neither rumors them over the network to other peers, nor stores them in memory\n-  or to `peers.dat`.  (#22050)\n-\n-- Added NAT-PMP port mapping support via\n-  [`libnatpmp`](https://miniupnp.tuxfamily.org/libnatpmp.html). (#18077)\n+- A bitcoind node will no longer rumour addresses to inbound peers by default.\n+  They will become eligible for address gossip after sending an ADDR, ADDRV2,\n+  or GETADDR message. (#21528)\n \n Updated RPCs\n ------------\n \n-- Due to [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\n-  being implemented, behavior for all RPCs that accept addresses is changed when\n-  a native witness version 1 (or higher) is passed. These now require a Bech32m\n-  encoding instead of a Bech32 one, and Bech32m encoding will be used for such\n-  addresses in RPC output as well. No version 1 addresses should be created\n-  for mainnet until consensus rules are adopted that give them meaning\n-  (e.g. through [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)).\n-  Once that happens, Bech32m is expected to be used for them, so this shouldn't\n-  affect any production systems, but may be observed on other networks where such\n-  addresses already have meaning (like signet). (#20861)\n-\n-- The `getpeerinfo` RPC returns two new boolean fields, `bip152_hb_to` and\n-  `bip152_hb_from`, that respectively indicate whether we selected a peer to be\n-  in compact blocks high-bandwidth mode or whether a peer selected us as a\n-  compact blocks high-bandwidth peer. High-bandwidth peers send new block\n-  announcements via a `cmpctblock` message rather than the usual inv/headers\n-  announcements. See BIP 152 for more details. (#19776)\n-\n-- `getpeerinfo` no longer returns the following fields: `addnode`, `banscore`,\n-  and `whitelisted`, which were previously deprecated in 0.21. Instead of\n-  `addnode`, the `connection_type` field returns manual. Instead of\n-  `whitelisted`, the `permissions` field indicates if the peer has special\n-  privileges. The `banscore` field has simply been removed. (#20755)\n-\n-- The following RPCs:  `gettxout`, `getrawtransaction`, `decoderawtransaction`,\n-  `decodescript`, `gettransaction`, and REST endpoints: `/rest/tx`,\n-  `/rest/getutxos`, `/rest/block` deprecated the following fields (which are no\n-  longer returned in the responses by default): `addresses`, `reqSigs`.\n-  The `-deprecatedrpc=addresses` flag must be passed for these fields to be\n-  included in the RPC response. This flag/option will be available only for this major release, after which\n-  the deprecation will be removed entirely. Note that these fields are attributes of\n-  the `scriptPubKey` object returned in the RPC response. However, in the response\n-  of `decodescript` these fields are top-level attributes, and included again as attributes\n-  of the `scriptPubKey` object. (#20286)\n-\n-- When creating a hex-encoded bitcoin transaction using the `bitcoin-tx` utility\n-  with the `-json` option set, the following fields: `addresses`, `reqSigs` are no longer\n-  returned in the tx output of the response. (#20286)\n-\n-- The `listbanned` RPC now returns two new numeric fields: `ban_duration` and `time_remaining`.\n-  Respectively, these new fields indicate the duration of a ban and the time remaining until a ban expires,\n-  both in seconds. Additionally, the `ban_created` field is repositioned to come before `banned_until`. (#21602)\n-\n-- The `getnodeaddresses` RPC now returns a \"network\" field indicating the\n-  network type (ipv4, ipv6, onion, or i2p) for each address.  (#21594)\n-\n-- `getnodeaddresses` now also accepts a \"network\" argument (ipv4, ipv6, onion,\n-  or i2p) to return only addresses of the specified network.  (#21843)\n-\n-- The `testmempoolaccept` RPC now accepts multiple transactions (still experimental at the moment,\n-  API may be unstable). This is intended for testing transaction packages with dependency\n-  relationships; it is not recommended for batch-validating independent transactions. In addition to\n-  mempool policy, package policies apply: the list cannot contain more than 25 transactions or have a\n-  total size exceeding 101K virtual bytes, and cannot conflict with (spend the same inputs as) each other or\n-  the mempool, even if it would be a valid BIP125 replace-by-fee. There are some known limitations to\n-  the accuracy of the test accept: it's possible for `testmempoolaccept` to return \"allowed\"=True for a\n-  group of transactions, but \"too-long-mempool-chain\" if they are actually submitted. (#20833)\n-\n-- `addmultisigaddress` and `createmultisig` now support up to 20 keys for\n-  Segwit addresses. (#20867)\n-\n-Changes to Wallet or GUI related RPCs can be found in the GUI or Wallet section below.\n-\n New RPCs\n --------\n \n Build System\n ------------\n \n+Files\n+-----\n+\n+* On startup, the list of banned hosts and networks (via `setban` RPC) in\n+  `banlist.dat` is ignored and only `banlist.json` is considered. Bitcoin Core\n+  version 22.x is the only version that can read `banlist.dat` and also write\n+  it to `banlist.json`. If `banlist.json` already exists, version 22.x will not\n+  try to translate the `banlist.dat` into json. After an upgrade, `listbanned`\n+  can be used to double check the parsed entries. (#22570)\n+\n New settings\n ------------\n \n-- The `-natpmp` option has been added to use NAT-PMP to map the listening port.\n-  If both UPnP and NAT-PMP are enabled, a successful allocation from UPnP\n-  prevails over one from NAT-PMP. (#18077)\n-\n Updated settings\n ----------------\n \n-Changes to Wallet or GUI related settings can be found in the GUI or Wallet section below.\n-\n-- Passing an invalid `-rpcauth` argument now cause bitcoind to fail to start.  (#20461)\n-\n Tools and Utilities\n -------------------\n \n-- A new CLI `-addrinfo` command returns the number of addresses known to the\n-  node per network type (including Tor v2 versus v3) and total. This can be\n-  useful to see if the node knows enough addresses in a network to use options\n-  like `-onlynet=<network>` or to upgrade to this release of Bitcoin Core 22.0\n-  that supports Tor v3 only.  (#21595)\n-\n-- A new `-rpcwaittimeout` argument to `bitcoin-cli` sets the timeout\n-  in seconds to use with `-rpcwait`. If the timeout expires,\n-  `bitcoin-cli` will report a failure. (#21056)\n+- Update `-getinfo` to return data in a user-friendly format that also reduces vertical space. (#21832)\n \n Wallet\n ------\n \n-- A new `listdescriptors` RPC is available to inspect the contents of descriptor-enabled wallets.\n-  The RPC returns public versions of all imported descriptors, including their timestamp and flags.\n-  For ranged descriptors, it also returns the range boundaries and the next index to generate addresses from. (#20226)\n-\n-- The `bumpfee` RPC is not available with wallets that have private keys\n-  disabled. `psbtbumpfee` can be used instead. (#20891)\n-\n-- The `fundrawtransaction`, `send` and `walletcreatefundedpsbt` RPCs now support an `include_unsafe` option\n-  that when `true` allows using unsafe inputs to fund the transaction.\n-  Note that the resulting transaction may become invalid if one of the unsafe inputs disappears.\n-  If that happens, the transaction must be funded with different inputs and republished. (#21359)\n-\n-- We now support up to 20 keys in `multi()` and `sortedmulti()` descriptors\n-  under `wsh()`. (#20867)\n-\n GUI changes\n -----------\n \n@@ -197,18 +103,7 @@ Low-level changes\n RPC\n ---\n \n-- The RPC server can process a limited number of simultaneous RPC requests.\n-  Previously, if this limit was exceeded, the RPC server would respond with\n-  [status code 500 (`HTTP_INTERNAL_SERVER_ERROR`)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_server_errors).\n-  Now it returns status code 503 (`HTTP_SERVICE_UNAVAILABLE`). (#18335)\n-\n-- Error codes have been updated to be more accurate for the following error cases (#18466):\n-  - `signmessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n-    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n-  - `verifymessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n-    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n-  - `verifymessage` now returns RPC_TYPE_ERROR (-3) if the passed signature\n-    is malformed. Previously returned RPC_INVALID_ADDRESS_OR_KEY (-5).\n+- `getblockchaininfo` now returns a new `time` field, that provides the chain tip time. (#22407)\n \n Tests\n -----"
      },
      {
        "sha": "c57fa5b23a2f294005c70ae297fb3338078e8d40",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 106,
        "deletions": 166,
        "changes": 272,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -44,10 +44,6 @@ Release Process\n     - Make an announcement that translators can start translating for the new version. You can use one of the [previous announcements](https://www.transifex.com/bitcoin/bitcoin/announcements/) as a template.\n     - Change the auto-update URL for the resource to `master`, e.g. `https://raw.githubusercontent.com/bitcoin/bitcoin/master/src/qt/locale/bitcoin_en.xlf`. (Do this only after the previous steps, to prevent an auto-update from interfering.)\n \n-#### After branch-off (on master)\n-\n-- Update the version of `contrib/gitian-descriptors/*.yml`.\n-\n #### After branch-off (on the major release branch)\n \n - Update the versions.\n@@ -72,14 +68,14 @@ This will perform a few last-minute consistency checks in the build system files\n \n ### First time / New builders\n \n-If you're using the automated script (found in [contrib/gitian-build.py](/contrib/gitian-build.py)), then at this point you should run it with the \"--setup\" command. Otherwise ignore this.\n+Install Guix using one of the installation methods detailed in\n+[contrib/guix/INSTALL.md](/contrib/guix/INSTALL.md).\n \n Check out the source code in the following directory hierarchy.\n \n     cd /path/to/your/toplevel/build\n-    git clone https://github.com/bitcoin-core/gitian.sigs.git\n+    git clone https://github.com/bitcoin-core/guix.sigs.git\n     git clone https://github.com/bitcoin-core/bitcoin-detached-sigs.git\n-    git clone https://github.com/devrandom/gitian-builder.git\n     git clone https://github.com/bitcoin/bitcoin.git\n \n ### Write the release notes\n@@ -94,110 +90,56 @@ Generate list of authors:\n \n     git log --format='- %aN' v(current version, e.g. 0.20.0)..v(new version, e.g. 0.20.1) | sort -fiu\n \n-### Setup and perform Gitian builds\n-\n-If you're using the automated script (found in [contrib/gitian-build.py](/contrib/gitian-build.py)), then at this point you should run it with the \"--build\" command. Otherwise ignore this.\n-\n-Setup Gitian descriptors:\n-\n-    pushd ./bitcoin\n-    export SIGNER=\"(your Gitian key, ie bluematt, sipa, etc)\"\n-    export VERSION=(new version, e.g. 0.20.0)\n-    git fetch\n-    git checkout v${VERSION}\n-    popd\n-\n-Ensure your gitian.sigs are up-to-date if you wish to gverify your builds against other Gitian signatures.\n-\n-    pushd ./gitian.sigs\n-    git pull\n-    popd\n-\n-Ensure gitian-builder is up-to-date:\n-\n-    pushd ./gitian-builder\n-    git pull\n-    popd\n-\n-### Fetch and create inputs: (first time, or when dependency versions change)\n-\n-    pushd ./gitian-builder\n-    mkdir -p inputs\n-    wget -O inputs/osslsigncode-2.0.tar.gz https://github.com/mtrojnar/osslsigncode/archive/2.0.tar.gz\n-    echo '5a60e0a4b3e0b4d655317b2f12a810211c50242138322b16e7e01c6fbb89d92f inputs/osslsigncode-2.0.tar.gz' | sha256sum -c\n-    popd\n-\n-Create the macOS SDK tarball, see the [macdeploy instructions](/contrib/macdeploy/README.md#deterministic-macos-dmg-notes) for details, and copy it into the inputs directory.\n-\n-### Optional: Seed the Gitian sources cache and offline git repositories\n-\n-NOTE: Gitian is sometimes unable to download files. If you have errors, try the step below.\n-\n-By default, Gitian will fetch source files as needed. To cache them ahead of time, make sure you have checked out the tag you want to build in bitcoin, then:\n-\n-    pushd ./gitian-builder\n-    make -C ../bitcoin/depends download SOURCES_PATH=`pwd`/cache/common\n-    popd\n-\n-Only missing files will be fetched, so this is safe to re-run for each build.\n-\n-NOTE: Offline builds must use the --url flag to ensure Gitian fetches only from local URLs. For example:\n-\n-    pushd ./gitian-builder\n-    ./bin/gbuild --url bitcoin=/path/to/bitcoin,signature=/path/to/sigs {rest of arguments}\n-    popd\n+### Setup and perform Guix builds\n \n-The gbuild invocations below <b>DO NOT DO THIS</b> by default.\n+Checkout the Bitcoin Core version you'd like to build:\n \n-### Build and sign Bitcoin Core for Linux, Windows, and macOS:\n+```sh\n+pushd ./bitcoin\n+SIGNER='(your builder key, ie bluematt, sipa, etc)'\n+VERSION='(new version without v-prefix, e.g. 0.20.0)'\n+git fetch \"v${VERSION}\"\n+git checkout \"v${VERSION}\"\n+popd\n+```\n \n-    pushd ./gitian-builder\n-    ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n-    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n-    mv build/out/bitcoin-*.tar.gz build/out/src/bitcoin-*.tar.gz ../\n+Ensure your guix.sigs are up-to-date if you wish to `guix-verify` your builds\n+against other `guix-attest` signatures.\n \n-    ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n-    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-win-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n-    mv build/out/bitcoin-*-win-unsigned.tar.gz inputs/bitcoin-win-unsigned.tar.gz\n-    mv build/out/bitcoin-*.zip build/out/bitcoin-*.exe ../\n+```sh\n+git -C ./guix.sigs pull\n+```\n \n-    ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n-    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-osx-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n-    mv build/out/bitcoin-*-osx-unsigned.tar.gz inputs/bitcoin-osx-unsigned.tar.gz\n-    mv build/out/bitcoin-*.tar.gz build/out/bitcoin-*.dmg ../\n-    popd\n+### Create the macOS SDK tarball: (first time, or when SDK version changes)\n \n-Build output expected:\n+Create the macOS SDK tarball, see the [macdeploy\n+instructions](/contrib/macdeploy/README.md#deterministic-macos-dmg-notes) for\n+details.\n \n-  1. source tarball (`bitcoin-${VERSION}.tar.gz`)\n-  2. linux 32-bit and 64-bit dist tarballs (`bitcoin-${VERSION}-linux[32|64].tar.gz`)\n-  3. windows 32-bit and 64-bit unsigned installers and dist zips (`bitcoin-${VERSION}-win[32|64]-setup-unsigned.exe`, `bitcoin-${VERSION}-win[32|64].zip`)\n-  4. macOS unsigned installer and dist tarball (`bitcoin-${VERSION}-osx-unsigned.dmg`, `bitcoin-${VERSION}-osx64.tar.gz`)\n-  5. Gitian signatures (in `gitian.sigs/${VERSION}-<linux|{win,osx}-unsigned>/(your Gitian key)/`)\n+### Build and attest to build outputs:\n \n-### Verify other gitian builders signatures to your own. (Optional)\n+Follow the relevant Guix README.md sections:\n+- [Performing a build](/contrib/guix/README.md#performing-a-build)\n+- [Attesting to build outputs](/contrib/guix/README.md#attesting-to-build-outputs)\n \n-Add other gitian builders keys to your gpg keyring, and/or refresh keys: See `../bitcoin/contrib/gitian-keys/README.md`.\n+### Verify other builders' signatures to your own. (Optional)\n \n-Verify the signatures\n+Add other builders keys to your gpg keyring, and/or refresh keys: See `../bitcoin/contrib/builder-keys/README.md`.\n \n-    pushd ./gitian-builder\n-    ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-linux ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n-    ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-win-unsigned ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n-    ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-osx-unsigned ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n-    popd\n+Follow the relevant Guix README.md sections:\n+- [Verifying build output attestations](/contrib/guix/README.md#verifying-build-output-attestations)\n \n ### Next steps:\n \n-Commit your signature to gitian.sigs:\n+Commit your signature to guix.sigs:\n \n-    pushd gitian.sigs\n-    git add ${VERSION}-linux/\"${SIGNER}\"\n-    git add ${VERSION}-win-unsigned/\"${SIGNER}\"\n-    git add ${VERSION}-osx-unsigned/\"${SIGNER}\"\n-    git commit -m \"Add ${VERSION} unsigned sigs for ${SIGNER}\"\n-    git push  # Assuming you can push to the gitian.sigs tree\n-    popd\n+```sh\n+pushd ./guix.sigs\n+git add \"${VERSION}/${SIGNER}\"/noncodesigned.SHA256SUMS{,.asc}\n+git commit -m \"Add attestations by ${SIGNER} for ${VERSION} non-codesigned\"\n+git push  # Assuming you can push to the guix.sigs tree\n+popd\n+```\n \n Codesigner only: Create Windows/macOS detached signatures:\n - Only one person handles codesigning. Everyone else should skip to the next step.\n@@ -209,7 +151,7 @@ Codesigner only: Sign the macOS binary:\n     tar xf bitcoin-osx-unsigned.tar.gz\n     ./detached-sig-create.sh -s \"Key ID\"\n     Enter the keychain password and authorize the signature\n-    Move signature-osx.tar.gz back to the gitian host\n+    Move signature-osx.tar.gz back to the guix-build host\n \n Codesigner only: Sign the windows binaries:\n \n@@ -218,95 +160,93 @@ Codesigner only: Sign the windows binaries:\n     Enter the passphrase for the key when prompted\n     signature-win.tar.gz will be created\n \n+Code-signer only: It is advised to test that the code signature attaches properly prior to tagging by performing the `guix-codesign` step.\n+However if this is done, once the release has been tagged in the bitcoin-detached-sigs repo, the `guix-codesign` step must be performed again in order for the guix attestation to be valid when compared against the attestations of non-codesigner builds.\n+\n Codesigner only: Commit the detached codesign payloads:\n \n-    cd ~/bitcoin-detached-sigs\n-    checkout the appropriate branch for this release series\n-    rm -rf *\n-    tar xf signature-osx.tar.gz\n-    tar xf signature-win.tar.gz\n-    git add -A\n-    git commit -m \"point to ${VERSION}\"\n-    git tag -s v${VERSION} HEAD\n-    git push the current branch and new tag\n+```sh\n+pushd ./bitcoin-detached-sigs\n+# checkout the appropriate branch for this release series\n+rm -rf ./*\n+tar xf signature-osx.tar.gz\n+tar xf signature-win.tar.gz\n+git add -A\n+git commit -m \"point to ${VERSION}\"\n+git tag -s \"v${VERSION}\" HEAD\n+git push the current branch and new tag\n+popd\n+```\n \n Non-codesigners: wait for Windows/macOS detached signatures:\n \n - Once the Windows/macOS builds each have 3 matching signatures, they will be signed with their respective release keys.\n - Detached signatures will then be committed to the [bitcoin-detached-sigs](https://github.com/bitcoin-core/bitcoin-detached-sigs) repository, which can be combined with the unsigned apps to create signed binaries.\n \n-Create (and optionally verify) the signed macOS binary:\n+Create (and optionally verify) the codesigned outputs:\n \n-    pushd ./gitian-builder\n-    ./bin/gbuild -i --commit signature=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n-    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-osx-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n-    ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-osx-signed ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n-    mv build/out/bitcoin-osx-signed.dmg ../bitcoin-${VERSION}-osx.dmg\n-    popd\n+- [Codesigning](/contrib/guix/README.md#codesigning)\n \n-Create (and optionally verify) the signed Windows binaries:\n+Commit your signature for the signed macOS/Windows binaries:\n \n-    pushd ./gitian-builder\n-    ./bin/gbuild -i --commit signature=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n-    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-win-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n-    ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-win-signed ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n-    mv build/out/bitcoin-*win64-setup.exe ../bitcoin-${VERSION}-win64-setup.exe\n-    popd\n+```sh\n+pushd ./guix.sigs\n+git add \"${VERSION}/${SIGNER}\"/all.SHA256SUMS{,.asc}\n+git commit -m \"Add attestations by ${SIGNER} for ${VERSION} codesigned\"\n+git push  # Assuming you can push to the guix.sigs tree\n+popd\n+```\n \n-Commit your signature for the signed macOS/Windows binaries:\n+### After 3 or more people have guix-built and their results match:\n \n-    pushd gitian.sigs\n-    git add ${VERSION}-osx-signed/\"${SIGNER}\"\n-    git add ${VERSION}-win-signed/\"${SIGNER}\"\n-    git commit -m \"Add ${SIGNER} ${VERSION} signed binaries signatures\"\n-    git push  # Assuming you can push to the gitian.sigs tree\n-    popd\n+Combine `all.SHA256SUMS` and `all.SHA256SUMS.asc` into a clear-signed\n+`SHA256SUMS.asc` message:\n \n-### After 3 or more people have gitian-built and their results match:\n+```sh\n+echo -e \"-----BEGIN PGP SIGNED MESSAGE-----\\nHash: SHA256\\n\\n$(cat all.SHA256SUMS)\\n$(cat filename.txt.asc)\" > SHA256SUMS.asc\n+```\n \n-- Create `SHA256SUMS.asc` for the builds, and GPG-sign it:\n+Here's an equivalent, more readable command if you're confident that you won't\n+mess up whitespaces when copy-pasting:\n \n ```bash\n-sha256sum * > SHA256SUMS\n-```\n+cat << EOF > SHA256SUMS.asc\n+-----BEGIN PGP SIGNED MESSAGE-----\n+Hash: SHA256\n \n-The list of files should be:\n+$(cat all.SHA256SUMS)\n+$(cat all.SHA256SUMS.asc)\n+EOF\n ```\n-bitcoin-${VERSION}-aarch64-linux-gnu.tar.gz\n-bitcoin-${VERSION}-arm-linux-gnueabihf.tar.gz\n-bitcoin-${VERSION}-riscv64-linux-gnu.tar.gz\n-bitcoin-${VERSION}-x86_64-linux-gnu.tar.gz\n-bitcoin-${VERSION}-osx64.tar.gz\n-bitcoin-${VERSION}-osx.dmg\n-bitcoin-${VERSION}.tar.gz\n-bitcoin-${VERSION}-win64-setup.exe\n-bitcoin-${VERSION}-win64.zip\n-```\n-The `*-debug*` files generated by the gitian build contain debug symbols\n-for troubleshooting by developers. It is assumed that anyone that is interested\n-in debugging can run gitian to generate the files for themselves. To avoid\n-end-user confusion about which file to pick, as well as save storage\n-space *do not upload these to the bitcoincore.org server, nor put them in the torrent*.\n \n-- GPG-sign it, delete the unsigned file:\n-```\n-gpg --digest-algo sha256 --clearsign SHA256SUMS # outputs SHA256SUMS.asc\n-rm SHA256SUMS\n-```\n-(the digest algorithm is forced to sha256 to avoid confusion of the `Hash:` header that GPG adds with the SHA256 used for the files)\n-Note: check that SHA256SUMS itself doesn't end up in SHA256SUMS, which is a spurious/nonsensical entry.\n+- Upload to the bitcoincore.org server (`/var/www/bin/bitcoin-core-${VERSION}`):\n+    1. The contents of `./bitcoin/guix-build-${VERSION}/output`, except for\n+       `*-debug*` files.\n \n-- Upload zips and installers, as well as `SHA256SUMS.asc` from last step, to the bitcoincore.org server\n-  into `/var/www/bin/bitcoin-core-${VERSION}`\n+       The `*-debug*` files generated by the guix build contain debug symbols\n+       for troubleshooting by developers. It is assumed that anyone that is\n+       interested in debugging can run guix to generate the files for\n+       themselves. To avoid end-user confusion about which file to pick, as well\n+       as save storage space *do not upload these to the bitcoincore.org server,\n+       nor put them in the torrent*.\n \n-- A `.torrent` will appear in the directory after a few minutes. Optionally help seed this torrent. To get the `magnet:` URI use:\n-```bash\n-transmission-show -m <torrent file>\n-```\n-Insert the magnet URI into the announcement sent to mailing lists. This permits\n-people without access to `bitcoincore.org` to download the binary distribution.\n-Also put it into the `optional_magnetlink:` slot in the YAML file for\n-bitcoincore.org.\n+    2. The combined clear-signed message you just created `SHA256SUMS.asc`\n+\n+- Create a torrent of the `/var/www/bin/bitcoin-core-${VERSION}` directory such\n+  that at the top level there is only one file: the `bitcoin-core-${VERSION}`\n+  directory containing everything else. Name the torrent\n+  `bitcoin-${VERSION}.torrent` (note that there is no `-core-` in this name).\n+\n+  Optionally help seed this torrent. To get the `magnet:` URI use:\n+\n+  ```sh\n+  transmission-show -m <torrent file>\n+  ```\n+\n+  Insert the magnet URI into the announcement sent to mailing lists. This permits\n+  people without access to `bitcoincore.org` to download the binary distribution.\n+  Also put it into the `optional_magnetlink:` slot in the YAML file for\n+  bitcoincore.org.\n \n - Update other repositories and websites for new version\n \n@@ -344,14 +284,14 @@ bitcoincore.org.\n         - https://code.launchpad.net/~bitcoin-core/bitcoin-core-snap/+git/packaging/+ref/0.xx (Click \"Create snap package\")\n         - Name it \"bitcoin-core-snap-0.xx\"\n         - Leave owner and series as-is\n-        - Select architectures that are compiled via gitian\n+        - Select architectures that are compiled via guix\n         - Leave \"automatically build when branch changes\" unticked\n         - Tick \"automatically upload to store\"\n         - Put \"bitcoin-core\" in the registered store package name field\n         - Tick the \"edge\" box\n         - Put \"0.xx\" in the track field\n         - Click \"create snap package\"\n-        - Click \"Request builds\" for every new release on this branch (after updating the snapcraft.yml in the branch to reflect the latest gitian results)\n+        - Click \"Request builds\" for every new release on this branch (after updating the snapcraft.yml in the branch to reflect the latest guix results)\n         - Promote release on https://snapcraft.io/bitcoin-core/releases if it passes sanity checks\n \n   - This repo"
      },
      {
        "sha": "1242a0d25002b3f4c65e6673584e53cc1094b22b",
        "filename": "doc/tracing.md",
        "status": "added",
        "additions": 266,
        "deletions": 0,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/doc/tracing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/doc/tracing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tracing.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,266 @@\n+# User-space, Statically Defined Tracing (USDT) for Bitcoin Core\n+\n+Bitcoin Core includes statically defined tracepoints to allow for more\n+observability during development, debugging, code review, and production usage.\n+These tracepoints make it possible to keep track of custom statistics and\n+enable detailed monitoring of otherwise hidden internals. They have\n+little to no performance impact when unused.\n+\n+```\n+eBPF and USDT Overview\n+======================\n+\n+                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                \u2502 tracing script   \u2502            \u2502 bitcoind     \u2502\n+                \u2502==================\u2502      2.    \u2502==============\u2502\n+                \u2502  eBPF  \u2502 tracing \u2502      hooks \u2502              \u2502\n+                \u2502  code  \u2502 logic   \u2502      into\u250c\u2500\u2524\u25batracepoint 1\u2500\u253c\u2500\u2500\u2500\u2510 3.\n+                \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2534\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u251c\u2500\u2524\u25batracepoint 2 \u2502   \u2502 pass args\n+            1.       \u2502      \u2502 4.              \u2502 \u2502 ...          \u2502   \u2502 to eBPF\n+    User    compiles \u2502      \u2502 pass data to    \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502 program\n+    Space    & loads \u2502      \u2502 tracing script  \u2502                    \u2502\n+    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\n+    Kernel           \u2502      \u2502                 \u2502                    \u2502\n+    Space       \u250c\u2500\u2500\u252c\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                \u2502  \u2502  eBPF program                         \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+                \u2502 eBPF kernel Virtual Machine (sandboxed)  \u2502\n+                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+1. The tracing script compiles the eBPF code and loads the eBPF program into a kernel VM\n+2. The eBPF program hooks into one or more tracepoints\n+3. When the tracepoint is called, the arguments are passed to the eBPF program\n+4. The eBPF program processes the arguments and returns data to the tracing script\n+```\n+\n+The Linux kernel can hook into the tracepoints during runtime and pass data to\n+sandboxed [eBPF] programs running in the kernel. These eBPF programs can, for\n+example, collect statistics or pass data back to user-space scripts for further\n+processing.\n+\n+[eBPF]: https://ebpf.io/\n+\n+The two main eBPF front-ends with support for USDT are [bpftrace] and\n+[BPF Compiler Collection (BCC)]. BCC is used for complex tools and daemons and\n+`bpftrace` is preferred for one-liners and shorter scripts. Examples for both can\n+be found in [contrib/tracing].\n+\n+[bpftrace]: https://github.com/iovisor/bpftrace\n+[BPF Compiler Collection (BCC)]: https://github.com/iovisor/bcc\n+[contrib/tracing]: ../contrib/tracing/\n+\n+## Tracepoint documentation\n+\n+The currently available tracepoints are listed here.\n+\n+### Context `net`\n+\n+#### Tracepoint `net:inbound_message`\n+\n+Is called when a message is received from a peer over the P2P network. Passes\n+information about our peer, the connection and the message as arguments.\n+\n+Arguments passed:\n+1. Peer ID as `int64`\n+2. Peer Address and Port (IPv4, IPv6, Tor v3, I2P, ...) as `pointer to C-style String` (max. length 68 characters)\n+3. Connection Type (inbound, feeler, outbound-full-relay, ...) as `pointer to C-style String` (max. length 20 characters)\n+4. Message Type (inv, ping, getdata, addrv2, ...) as `pointer to C-style String` (max. length 20 characters)\n+5. Message Size in bytes as `uint64`\n+6. Message Bytes as `pointer to unsigned chars` (i.e. bytes)\n+\n+Note: The message is passed to the tracepoint in full, however, due to space\n+limitations in the eBPF kernel VM it might not be possible to pass the message\n+to user-space in full. Messages longer than a 32kb might be cut off. This can\n+be detected in tracing scripts by comparing the message size to the length of\n+the passed message.\n+\n+#### Tracepoint `net:outbound_message`\n+\n+Is called when a message is send to a peer over the P2P network. Passes\n+information about our peer, the connection and the message as arguments.\n+\n+Arguments passed:\n+1. Peer ID as `int64`\n+2. Peer Address and Port (IPv4, IPv6, Tor v3, I2P, ...) as `pointer to C-style String` (max. length 68 characters)\n+3. Connection Type (inbound, feeler, outbound-full-relay, ...) as `pointer to C-style String` (max. length 20 characters)\n+4. Message Type (inv, ping, getdata, addrv2, ...) as `pointer to C-style String` (max. length 20 characters)\n+5. Message Size in bytes as `uint64`\n+6. Message Bytes as `pointer to unsigned chars` (i.e. bytes)\n+\n+Note: The message is passed to the tracepoint in full, however, due to space\n+limitations in the eBPF kernel VM it might not be possible to pass the message\n+to user-space in full. Messages longer than a 32kb might be cut off. This can\n+be detected in tracing scripts by comparing the message size to the length of\n+the passed message.\n+\n+### Context `validation`\n+\n+#### Tracepoint `validation:block_connected`\n+\n+Is called *after* a block is connected to the chain. Can, for example, be used\n+to benchmark block connections together with `-reindex`.\n+\n+Arguments passed:\n+1. Block Header Hash as `pointer to C-style String` (64 characters)\n+2. Block Height as `int32`\n+3. Transactions in the Block as `uint64`\n+4. Inputs spend in the Block as `int32`\n+5. SigOps in the Block (excluding coinbase SigOps) `uint64`\n+6. Time it took to connect the Block in microseconds (\u00b5s) as `uint64`\n+7. Block Header Hash as `pointer to unsigned chars` (i.e. 32 bytes in little-endian)\n+\n+Note: The 7th argument can't be accessed by bpftrace and is purposefully chosen\n+to be the block header hash as bytes. See [bpftrace argument limit] for more\n+details.\n+\n+[bpftrace argument limit]: #bpftrace-argument-limit\n+\n+## Adding tracepoints to Bitcoin Core\n+\n+To add a new tracepoint, `#include <util/trace.h>` in the compilation unit where\n+the tracepoint is inserted. Use one of the `TRACEx` macros listed below\n+depending on the number of arguments passed to the tracepoint. Up to 12\n+arguments can be provided. The `context` and `event` specify the names by which\n+the tracepoint is referred to. Please use `snake_case` and try to make sure that\n+the tracepoint names make sense even without detailed knowledge of the\n+implementation details. Do not forget to update the tracepoint list in this\n+document.\n+\n+```c\n+#define TRACE(context, event)\n+#define TRACE1(context, event, a)\n+#define TRACE2(context, event, a, b)\n+#define TRACE3(context, event, a, b, c)\n+#define TRACE4(context, event, a, b, c, d)\n+#define TRACE5(context, event, a, b, c, d, e)\n+#define TRACE6(context, event, a, b, c, d, e, f)\n+#define TRACE7(context, event, a, b, c, d, e, f, g)\n+#define TRACE8(context, event, a, b, c, d, e, f, g, h)\n+#define TRACE9(context, event, a, b, c, d, e, f, g, h, i)\n+#define TRACE10(context, event, a, b, c, d, e, f, g, h, i, j)\n+#define TRACE11(context, event, a, b, c, d, e, f, g, h, i, j, k)\n+#define TRACE12(context, event, a, b, c, d, e, f, g, h, i, j, k, l)\n+```\n+\n+For example:\n+\n+```C++\n+TRACE6(net, inbound_message,\n+    pnode->GetId(),\n+    pnode->GetAddrName().c_str(),\n+    pnode->ConnectionTypeAsString().c_str(),\n+    sanitizedType.c_str(),\n+    msg.data.size(),\n+    msg.data.data()\n+);\n+```\n+\n+### Guidelines and best practices\n+\n+#### Clear motivation and use-case\n+Tracepoints need a clear motivation and use-case. The motivation should\n+outweigh the impact on, for example, code readability. There is no point in\n+adding tracepoints that don't end up being used.\n+\n+#### Provide an example\n+When adding a new tracepoint, provide an example. Examples can show the use case\n+and help reviewers testing that the tracepoint works as intended. The examples\n+can be kept simple but should give others a starting point when working with\n+the tracepoint. See existing examples in [contrib/tracing/].\n+\n+[contrib/tracing/]: ../contrib/tracing/\n+\n+#### No expensive computations for tracepoints\n+Data passed to the tracepoint should be inexpensive to compute. Although the\n+tracepoint itself only has overhead when enabled, the code to compute arguments\n+is always run - even if the tracepoint is not used. For example, avoid\n+serialization and parsing.\n+\n+#### Semi-stable API\n+Tracepoints should have a semi-stable API. Users should be able to rely on the\n+tracepoints for scripting. This means tracepoints need to be documented, and the\n+argument order ideally should not change. If there is an important reason to\n+change argument order, make sure to document the change and update the examples\n+using the tracepoint.\n+\n+#### eBPF Virtual Machine limits\n+Keep the eBPF Virtual Machine limits in mind. eBPF programs receiving data from\n+the tracepoints run in a sandboxed Linux kernel VM. This VM has a limited stack\n+size of 512 bytes. Check if it makes sense to pass larger amounts of data, for\n+example, with a tracing script that can handle the passed data.\n+\n+#### `bpftrace` argument limit\n+While tracepoints can have up to 12 arguments, bpftrace scripts currently only\n+support reading from the first six arguments (`arg0` till `arg5`) on `x86_64`.\n+bpftrace currently lacks real support for handling and printing binary data,\n+like block header hashes and txids. When a tracepoint passes more than six\n+arguments, then string and integer arguments should preferably be placed in the\n+first six argument fields. Binary data can be placed in later arguments. The BCC\n+supports reading from all 12 arguments.\n+\n+#### Strings as C-style String\n+Generally, strings should be passed into the `TRACEx` macros as pointers to\n+C-style strings (a null-terminated sequence of characters). For C++\n+`std::strings`, [`c_str()`]  can be used. It's recommended to document the\n+maximum expected string size if known.\n+\n+\n+[`c_str()`]: https://www.cplusplus.com/reference/string/string/c_str/\n+\n+\n+## Listing available tracepoints\n+\n+Multiple tools can list the available tracepoints in a `bitcoind` binary with\n+USDT support.\n+\n+### GDB - GNU Project Debugger\n+\n+To list probes in Bitcoin Core, use `info probes` in `gdb`:\n+\n+```\n+$ gdb ./src/bitcoind\n+\u2026\n+(gdb) info probes\n+Type Provider   Name             Where              Semaphore Object\n+stap net        inbound_message  0x000000000014419e /src/bitcoind\n+stap net        outbound_message 0x0000000000107c05 /src/bitcoind\n+stap validation block_connected  0x00000000002fb10c /src/bitcoind\n+\u2026\n+```\n+\n+### With `readelf`\n+\n+The `readelf` tool can be used to display the USDT tracepoints in Bitcoin Core.\n+Look for the notes with the description `NT_STAPSDT`.\n+\n+```\n+$ readelf -n ./src/bitcoind | grep NT_STAPSDT -A 4 -B 2\n+Displaying notes found in: .note.stapsdt\n+  Owner                 Data size\tDescription\n+  stapsdt              0x0000005d\tNT_STAPSDT (SystemTap probe descriptors)\n+    Provider: net\n+    Name: outbound_message\n+    Location: 0x0000000000107c05, Base: 0x0000000000579c90, Semaphore: 0x0000000000000000\n+    Arguments: -8@%r12 8@%rbx 8@%rdi 8@192(%rsp) 8@%rax 8@%rdx\n+\u2026\n+```\n+\n+### With `tplist`\n+\n+The `tplist` tool is provided by BCC (see [Installing BCC]). It displays kernel\n+tracepoints or USDT probes and their formats (for more information, see the\n+[`tplist` usage demonstration]). There are slight binary naming differences\n+between distributions. For example, on\n+[Ubuntu the binary is called `tplist-bpfcc`][ubuntu binary].\n+\n+[Installing BCC]: https://github.com/iovisor/bcc/blob/master/INSTALL.md\n+[`tplist` usage demonstration]: https://github.com/iovisor/bcc/blob/master/tools/tplist_example.txt\n+[ubuntu binary]: https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary\n+\n+```\n+$ tplist -l ./src/bitcoind -v\n+b'net':b'outbound_message' [sema 0x0]\n+  1 location(s)\n+  6 argument(s)\n+\u2026\n+```"
      },
      {
        "sha": "a8d6591e98b541718ebbdcdcf3459f0c4e0bbada",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -3,7 +3,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n # Pattern rule to print variables, e.g. make print-top_srcdir\n-print-%:\n+print-%: FORCE\n \t@echo '$*'='$($*)'\n \n DIST_SUBDIRS = secp256k1 univalue\n@@ -842,9 +842,11 @@ EXTRA_DIST += $(libbitcoin_ipc_mpgen_input)\n if BUILD_MULTIPROCESS\n LIBBITCOIN_IPC=libbitcoin_ipc.a\n libbitcoin_ipc_a_SOURCES = \\\n+  ipc/capnp/context.h \\\n   ipc/capnp/init-types.h \\\n   ipc/capnp/protocol.cpp \\\n   ipc/capnp/protocol.h \\\n+  ipc/context.h \\\n   ipc/exception.h \\\n   ipc/interfaces.cpp \\\n   ipc/process.cpp \\"
      },
      {
        "sha": "ce1f93f11f3b50d1e30f439b56767e7199205ff8",
        "filename": "src/Makefile.leveldb.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.leveldb.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.leveldb.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.leveldb.include?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -22,6 +22,7 @@ LEVELDB_CPPFLAGS_INT += -DHAVE_SNAPPY=0 -DHAVE_CRC32C=1\n LEVELDB_CPPFLAGS_INT += -DHAVE_FDATASYNC=@HAVE_FDATASYNC@\n LEVELDB_CPPFLAGS_INT += -DHAVE_FULLFSYNC=@HAVE_FULLFSYNC@\n LEVELDB_CPPFLAGS_INT += -DHAVE_O_CLOEXEC=@HAVE_O_CLOEXEC@\n+LEVELDB_CPPFLAGS_INT += -DFALLTHROUGH_INTENDED=[[fallthrough]]\n \n if WORDS_BIGENDIAN\n LEVELDB_CPPFLAGS_INT += -DLEVELDB_IS_BIG_ENDIAN=1"
      },
      {
        "sha": "6f450bbc74ee2185f559e6c87569c2a51677d270",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -40,9 +40,9 @@ QT_MOC_CPP = \\\n   qt/moc_askpassphrasedialog.cpp \\\n   qt/moc_createwalletdialog.cpp \\\n   qt/moc_bantablemodel.cpp \\\n+  qt/moc_bitcoin.cpp \\\n   qt/moc_bitcoinaddressvalidator.cpp \\\n   qt/moc_bitcoinamountfield.cpp \\\n-  qt/moc_bitcoin.cpp \\\n   qt/moc_bitcoingui.cpp \\\n   qt/moc_bitcoinunits.cpp \\\n   qt/moc_clientmodel.cpp \\\n@@ -51,6 +51,7 @@ QT_MOC_CPP = \\\n   qt/moc_csvmodelwriter.cpp \\\n   qt/moc_editaddressdialog.cpp \\\n   qt/moc_guiutil.cpp \\\n+  qt/moc_initexecutor.cpp \\\n   qt/moc_intro.cpp \\\n   qt/moc_macdockiconhandler.cpp \\\n   qt/moc_macnotificationhandler.cpp \\\n@@ -109,9 +110,9 @@ BITCOIN_QT_H = \\\n   qt/addresstablemodel.h \\\n   qt/askpassphrasedialog.h \\\n   qt/bantablemodel.h \\\n+  qt/bitcoin.h \\\n   qt/bitcoinaddressvalidator.h \\\n   qt/bitcoinamountfield.h \\\n-  qt/bitcoin.h \\\n   qt/bitcoingui.h \\\n   qt/bitcoinunits.h \\\n   qt/clientmodel.h \\\n@@ -122,6 +123,7 @@ BITCOIN_QT_H = \\\n   qt/editaddressdialog.h \\\n   qt/guiconstants.h \\\n   qt/guiutil.h \\\n+  qt/initexecutor.h \\\n   qt/intro.h \\\n   qt/macdockiconhandler.h \\\n   qt/macnotificationhandler.h \\\n@@ -227,6 +229,7 @@ BITCOIN_QT_BASE_CPP = \\\n   qt/clientmodel.cpp \\\n   qt/csvmodelwriter.cpp \\\n   qt/guiutil.cpp \\\n+  qt/initexecutor.cpp \\\n   qt/intro.cpp \\\n   qt/modaloverlay.cpp \\\n   qt/networkstyle.cpp \\"
      },
      {
        "sha": "40d44aaa2e20956dbe560770a2778335593542a1",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -152,6 +152,7 @@ BITCOIN_TESTS =\\\n if ENABLE_WALLET\n BITCOIN_TESTS += \\\n   wallet/test/psbt_wallet_tests.cpp \\\n+  wallet/test/spend_tests.cpp \\\n   wallet/test/wallet_tests.cpp \\\n   wallet/test/walletdb_tests.cpp \\\n   wallet/test/wallet_crypto_tests.cpp \\\n@@ -170,6 +171,8 @@ endif\n \n \n BITCOIN_TEST_SUITE += \\\n+  wallet/test/util.cpp \\\n+  wallet/test/util.h \\\n   wallet/test/wallet_test_fixture.cpp \\\n   wallet/test/wallet_test_fixture.h \\\n   wallet/test/init_test_fixture.cpp \\\n@@ -201,7 +204,7 @@ if ENABLE_FUZZ_BINARY\n test_fuzz_fuzz_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n test_fuzz_fuzz_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_fuzz_LDADD = $(FUZZ_SUITE_LD_COMMON)\n-test_fuzz_fuzz_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)\n+test_fuzz_fuzz_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON) $(RUNTIME_LDFLAGS)\n test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/addition_overflow.cpp \\\n  test/fuzz/addrdb.cpp \\"
      },
      {
        "sha": "c3e224ee83de84c5924bcd61f95ce9359e0bca70",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -197,17 +197,16 @@ bool CBanDB::Write(const banmap_t& banSet)\n     return false;\n }\n \n-bool CBanDB::Read(banmap_t& banSet, bool& dirty)\n+bool CBanDB::Read(banmap_t& banSet)\n {\n-    // If the JSON banlist does not exist, then try to read the non-upgraded banlist.dat.\n+    if (fs::exists(m_banlist_dat)) {\n+        LogPrintf(\"banlist.dat ignored because it can only be read by \" PACKAGE_NAME \" version 22.x. Remove %s to silence this warning.\\n\", m_banlist_dat);\n+    }\n+    // If the JSON banlist does not exist, then recreate it\n     if (!fs::exists(m_banlist_json)) {\n-        // If this succeeds then we need to flush to disk in order to create the JSON banlist.\n-        dirty = true;\n-        return DeserializeFileDB(m_banlist_dat, banSet, CLIENT_VERSION);\n+        return false;\n     }\n \n-    dirty = false;\n-\n     std::map<std::string, util::SettingsValue> settings;\n     std::vector<std::string> errors;\n "
      },
      {
        "sha": "1e0ccb1f60b7f1715a550e1f0e76eb45277f04ad",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -76,7 +76,7 @@ class CAddrDB\n     static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n };\n \n-/** Access to the banlist databases (banlist.json and banlist.dat) */\n+/** Access to the banlist database (banlist.json) */\n class CBanDB\n {\n private:\n@@ -95,11 +95,9 @@ class CBanDB\n      * Read the banlist from disk.\n      * @param[out] banSet The loaded list. Set if `true` is returned, otherwise it is left\n      * in an undefined state.\n-     * @param[out] dirty Indicates whether the loaded list needs flushing to disk. Set if\n-     * `true` is returned, otherwise it is left in an undefined state.\n      * @return true on success\n      */\n-    bool Read(banmap_t& banSet, bool& dirty);\n+    bool Read(banmap_t& banSet);\n };\n \n /**"
      },
      {
        "sha": "96139182d38bdc2db465b736912ab9e46dfe28c7",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 152,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -6,7 +6,6 @@\n #include <addrman.h>\n \n #include <hash.h>\n-#include <i2p.h>\n #include <logging.h>\n #include <netaddress.h>\n #include <serialize.h>\n@@ -78,38 +77,6 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-void CAddrMan::RemoveInvalid()\n-{\n-    for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n-        for (size_t i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-            const auto id = vvNew[bucket][i];\n-            if (id != -1 && !mapInfo[id].IsValid()) {\n-                ClearNew(bucket, i);\n-            }\n-        }\n-    }\n-\n-    for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; ++bucket) {\n-        for (size_t i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-            const auto id = vvTried[bucket][i];\n-            if (id == -1) {\n-                continue;\n-            }\n-            const auto& addr_info = mapInfo[id];\n-            if (addr_info.IsValid()) {\n-                continue;\n-            }\n-            vvTried[bucket][i] = -1;\n-            --nTried;\n-            SwapRandom(addr_info.nRandomPos, vRandom.size() - 1);\n-            vRandom.pop_back();\n-            mapAddr.erase(addr_info);\n-            mapInfo.erase(id);\n-            m_tried_collisions.erase(id);\n-        }\n-    }\n-}\n-\n CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n@@ -139,7 +106,7 @@ CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, in\n     return &mapInfo[nId];\n }\n \n-void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n+void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n {\n     AssertLockHeld(cs);\n \n@@ -151,11 +118,13 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n     int nId1 = vRandom[nRndPos1];\n     int nId2 = vRandom[nRndPos2];\n \n-    assert(mapInfo.count(nId1) == 1);\n-    assert(mapInfo.count(nId2) == 1);\n+    const auto it_1{mapInfo.find(nId1)};\n+    const auto it_2{mapInfo.find(nId2)};\n+    assert(it_1 != mapInfo.end());\n+    assert(it_2 != mapInfo.end());\n \n-    mapInfo[nId1].nRandomPos = nRndPos2;\n-    mapInfo[nId2].nRandomPos = nRndPos1;\n+    it_1->second.nRandomPos = nRndPos2;\n+    it_2->second.nRandomPos = nRndPos1;\n \n     vRandom[nRndPos1] = nId2;\n     vRandom[nRndPos2] = nId1;\n@@ -411,7 +380,7 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n     }\n }\n \n-CAddrInfo CAddrMan::Select_(bool newOnly)\n+CAddrInfo CAddrMan::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n@@ -434,8 +403,9 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n                 nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvTried[nKBucket][nKBucketPos];\n-            assert(mapInfo.count(nId) == 1);\n-            CAddrInfo& info = mapInfo[nId];\n+            const auto it_found{mapInfo.find(nId)};\n+            assert(it_found != mapInfo.end());\n+            const CAddrInfo& info{it_found->second};\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n@@ -451,8 +421,9 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n                 nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvNew[nUBucket][nUBucketPos];\n-            assert(mapInfo.count(nId) == 1);\n-            CAddrInfo& info = mapInfo[nId];\n+            const auto it_found{mapInfo.find(nId)};\n+            assert(it_found != mapInfo.end());\n+            const CAddrInfo& info{it_found->second};\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n@@ -504,15 +475,15 @@ int CAddrMan::Check_()\n \n     for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n         for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-             if (vvTried[n][i] != -1) {\n-                 if (!setTried.count(vvTried[n][i]))\n-                     return -11;\n-                 if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey, m_asmap) != n)\n-                     return -17;\n-                 if (mapInfo[vvTried[n][i]].GetBucketPosition(nKey, false, n) != i)\n-                     return -18;\n-                 setTried.erase(vvTried[n][i]);\n-             }\n+            if (vvTried[n][i] != -1) {\n+                if (!setTried.count(vvTried[n][i]))\n+                    return -11;\n+                if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey, m_asmap) != n)\n+                    return -17;\n+                if (mapInfo[vvTried[n][i]].GetBucketPosition(nKey, false, n) != i)\n+                    return -18;\n+                setTried.erase(vvTried[n][i]);\n+            }\n         }\n     }\n \n@@ -540,7 +511,7 @@ int CAddrMan::Check_()\n }\n #endif\n \n-void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network)\n+void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -560,9 +531,10 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size\n \n         int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);\n-        assert(mapInfo.count(vRandom[n]) == 1);\n+        const auto it{mapInfo.find(vRandom[n])};\n+        assert(it != mapInfo.end());\n \n-        const CAddrInfo& ai = mapInfo[vRandom[n]];\n+        const CAddrInfo& ai{it->second};\n \n         // Filter by network (optional)\n         if (network != std::nullopt && ai.GetNetClass() != network) continue;\n@@ -732,100 +704,3 @@ std::vector<bool> CAddrMan::DecodeAsmap(fs::path path)\n     }\n     return bits;\n }\n-\n-void CAddrMan::ResetI2PPorts()\n-{\n-    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-            const auto id = vvNew[bucket][i];\n-            if (id == -1) {\n-                continue;\n-            }\n-            auto it = mapInfo.find(id);\n-            if (it == mapInfo.end()) {\n-                return;\n-            }\n-            auto& addr_info = it->second;\n-            if (!addr_info.IsI2P() || addr_info.GetPort() == I2P_SAM31_PORT) {\n-                continue;\n-            }\n-\n-            auto addr_info_newport = addr_info;\n-            // The below changes addr_info_newport.GetKey(), which is used in finding a\n-            // bucket and a position within that bucket. So a re-bucketing may be necessary.\n-            addr_info_newport.port = I2P_SAM31_PORT;\n-\n-            // Reposition entries of vvNew within the same bucket because we don't know the source\n-            // address which led to the decision to store the entry in vvNew[bucket] so we can't\n-            // re-evaluate that decision, but even if we could, CAddrInfo::GetNewBucket() does not\n-            // use CAddrInfo::GetKey() so it would end up in the same bucket as before the port\n-            // change.\n-            const auto i_target = addr_info_newport.GetBucketPosition(nKey, true, bucket);\n-\n-            if (i_target == i) { // No need to re-position.\n-                addr_info = addr_info_newport;\n-                continue;\n-            }\n-\n-            // Reposition from i to i_target, removing the entry from i_target (if any).\n-            ClearNew(bucket, i_target);\n-            vvNew[bucket][i_target] = id;\n-            vvNew[bucket][i] = -1;\n-            addr_info = addr_info_newport;\n-        }\n-    }\n-\n-    for (int bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; ++bucket) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-            const auto id = vvTried[bucket][i];\n-            if (id == -1) {\n-                continue;\n-            }\n-            auto it = mapInfo.find(id);\n-            if (it == mapInfo.end()) {\n-                return;\n-            }\n-            auto& addr_info = it->second;\n-            if (!addr_info.IsI2P() || addr_info.GetPort() == I2P_SAM31_PORT) {\n-                continue;\n-            }\n-\n-            auto addr_info_newport = addr_info;\n-            // The below changes addr_info_newport.GetKey(), which is used in finding a\n-            // bucket and a position within that bucket. So a re-bucketing may be necessary.\n-            addr_info_newport.port = I2P_SAM31_PORT;\n-\n-            const auto bucket_target = addr_info_newport.GetTriedBucket(nKey, m_asmap);\n-            const auto i_target = addr_info_newport.GetBucketPosition(nKey, false, bucket_target);\n-\n-            if (bucket_target == bucket && i_target == i) { // No need to re-position.\n-                addr_info = addr_info_newport;\n-                continue;\n-            }\n-\n-            // Reposition from (bucket, i) to (bucket_target, i_target). If the latter is\n-            // occupied, then move the entry from there to vvNew.\n-\n-            const auto old_target_id = vvTried[bucket_target][i_target];\n-            if (old_target_id != -1) {\n-                CAddrInfo& old_target_info = mapInfo[old_target_id];\n-\n-                old_target_info.fInTried = false;\n-                vvTried[bucket_target][i_target] = -1;\n-                --nTried;\n-\n-                const auto new_bucket = old_target_info.GetNewBucket(nKey, m_asmap);\n-                const auto new_bucket_i = old_target_info.GetBucketPosition(nKey, true, new_bucket);\n-                ClearNew(new_bucket, new_bucket_i);\n-\n-                old_target_info.nRefCount = 1;\n-                vvNew[new_bucket][new_bucket_i] = old_target_id;\n-                ++nNew;\n-            }\n-\n-            vvTried[bucket_target][i_target] = id;\n-            vvTried[bucket][i] = -1;\n-            addr_info = addr_info_newport;\n-        }\n-    }\n-}"
      },
      {
        "sha": "1dd193242160c25336759986df6d0b6577ae5578",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 46,
        "deletions": 44,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -55,9 +55,10 @@ class CAddrInfo : public CAddress\n     bool fInTried{false};\n \n     //! position in vRandom\n-    int nRandomPos{-1};\n+    mutable int nRandomPos{-1};\n \n     friend class CAddrMan;\n+    friend class CAddrManDeterministic;\n \n public:\n \n@@ -104,19 +105,23 @@ class CAddrInfo : public CAddress\n  *  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.\n  *\n  * To that end:\n- *  * Addresses are organized into buckets.\n- *    * Addresses that have not yet been tried go into 1024 \"new\" buckets.\n- *      * Based on the address range (/16 for IPv4) of the source of information, 64 buckets are selected at random.\n+ *  * Addresses are organized into buckets that can each store up to 64 entries.\n+ *    * Addresses to which our node has not successfully connected go into 1024 \"new\" buckets.\n+ *      * Based on the address range (/16 for IPv4) of the source of information, or if an asmap is provided,\n+ *        the AS it belongs to (for IPv4/IPv6), 64 buckets are selected at random.\n  *      * The actual bucket is chosen from one of these, based on the range in which the address itself is located.\n+ *      * The position in the bucket is chosen based on the full address.\n  *      * One single address can occur in up to 8 different buckets to increase selection chances for addresses that\n  *        are seen frequently. The chance for increasing this multiplicity decreases exponentially.\n- *      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen\n- *        ones) is removed from it first.\n+ *      * When adding a new address to an occupied position of a bucket, it will not replace the existing entry\n+ *        unless that address is also stored in another bucket or it doesn't meet one of several quality criteria\n+ *        (see IsTerrible for exact criteria).\n  *    * Addresses of nodes that are known to be accessible go into 256 \"tried\" buckets.\n  *      * Each address range selects at random 8 of these buckets.\n  *      * The actual bucket is chosen from one of these, based on the full address.\n- *      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently\n- *        tried ones) is evicted from it, back to the \"new\" buckets.\n+ *      * When adding a new good address to an occupied position of a bucket, a FEELER connection to the\n+ *        old address is attempted. The old entry is only replaced and moved back to the \"new\" buckets if this\n+ *        attempt was unsuccessful.\n  *    * Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not\n  *      be observable by adversaries.\n  *    * Several indexes are kept for high performance. Defining DEBUG_ADDRMAN will introduce frequent (and expensive)\n@@ -334,12 +339,18 @@ class CAddrMan\n             nUBuckets ^= (1 << 30);\n         }\n \n-        if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) {\n-            throw std::ios_base::failure(\"Corrupt CAddrMan serialization, nNew exceeds limit.\");\n+        if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n+            throw std::ios_base::failure(\n+                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %u]\",\n+                          nNew,\n+                          ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n         }\n \n-        if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) {\n-            throw std::ios_base::failure(\"Corrupt CAddrMan serialization, nTried exceeds limit.\");\n+        if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n+            throw std::ios_base::failure(\n+                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %u]\",\n+                          nTried,\n+                          ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n         }\n \n         // Deserialize entries from the new table.\n@@ -359,7 +370,8 @@ class CAddrMan\n             s >> info;\n             int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n             int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n-            if (vvTried[nKBucket][nKBucketPos] == -1) {\n+            if (info.IsValid()\n+                && vvTried[nKBucket][nKBucketPos] == -1) {\n                 info.nRandomPos = vRandom.size();\n                 info.fInTried = true;\n                 vRandom.push_back(nIdCount);\n@@ -413,6 +425,9 @@ class CAddrMan\n             const int entry_index{bucket_entry.second};\n             CAddrInfo& info = mapInfo[entry_index];\n \n+            // Don't store the entry in the new bucket if it's not a valid address for our addrman\n+            if (!info.IsValid()) continue;\n+\n             // The entry shouldn't appear in more than\n             // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n             // this bucket_entry.\n@@ -435,7 +450,7 @@ class CAddrMan\n             }\n         }\n \n-        // Prune new entries with refcount 0 (as a result of collisions).\n+        // Prune new entries with refcount 0 (as a result of collisions or invalid address).\n         int nLostUnk = 0;\n         for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {\n             if (it->second.fInTried == false && it->second.nRefCount == 0) {\n@@ -447,13 +462,9 @@ class CAddrMan\n             }\n         }\n         if (nLost + nLostUnk > 0) {\n-            LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n+            LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions or invalid addresses\\n\", nLostUnk, nLost);\n         }\n \n-        RemoveInvalid();\n-\n-        ResetI2PPorts();\n-\n         Check();\n     }\n \n@@ -532,12 +543,12 @@ class CAddrMan\n     }\n \n     //! Mark an entry as accessible.\n-    void Good(const CService &addr, bool test_before_evict = true, int64_t nTime = GetAdjustedTime())\n+    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n         EXCLUSIVE_LOCKS_REQUIRED(!cs)\n     {\n         LOCK(cs);\n         Check();\n-        Good_(addr, test_before_evict, nTime);\n+        Good_(addr, /* test_before_evict */ true, nTime);\n         Check();\n     }\n \n@@ -575,7 +586,7 @@ class CAddrMan\n     /**\n      * Choose an address to connect to.\n      */\n-    CAddrInfo Select(bool newOnly = false)\n+    CAddrInfo Select(bool newOnly = false) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs)\n     {\n         LOCK(cs);\n@@ -592,7 +603,7 @@ class CAddrMan\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n      */\n-    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network)\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs)\n     {\n         LOCK(cs);\n@@ -627,12 +638,12 @@ class CAddrMan\n     uint256 nKey;\n \n     //! Source of random numbers for randomization in inner loops\n-    FastRandomContext insecure_rand;\n+    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n \n-private:\n     //! A mutex to protect the inner data structures.\n     mutable Mutex cs;\n \n+private:\n     //! Serialization versions.\n     enum Format : uint8_t {\n         V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n@@ -665,7 +676,9 @@ class CAddrMan\n     std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n \n     //! randomly-ordered vector of all nIds\n-    std::vector<int> vRandom GUARDED_BY(cs);\n+    //! This is mutable because it is unobservable outside the class, so any\n+    //! changes to it (even in const methods) are also unobservable.\n+    mutable std::vector<int> vRandom GUARDED_BY(cs);\n \n     // number of \"tried\" entries\n     int nTried GUARDED_BY(cs);\n@@ -688,12 +701,11 @@ class CAddrMan\n     //! Find an entry.\n     CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! find an entry, creating it if necessary.\n-    //! nTime and nServices of the found node are updated, if necessary.\n+    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n     CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Swap two elements in vRandom.\n-    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n     void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -714,7 +726,7 @@ class CAddrMan\n     void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -723,7 +735,7 @@ class CAddrMan\n     CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Consistency check\n-    void Check()\n+    void Check() const\n         EXCLUSIVE_LOCKS_REQUIRED(cs)\n     {\n #ifdef DEBUG_ADDRMAN\n@@ -737,7 +749,7 @@ class CAddrMan\n \n #ifdef DEBUG_ADDRMAN\n     //! Perform consistency check. Returns an error code or zero.\n-    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    int Check_() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n #endif\n \n     /**\n@@ -748,7 +760,7 @@ class CAddrMan\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n      */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** We have successfully connected to this peer. Calling this function\n      *  updates the CAddress's nTime, which is used in our IsTerrible()\n@@ -766,18 +778,8 @@ class CAddrMan\n     //! Update an entry's service bits.\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Remove invalid addresses.\n-    void RemoveInvalid() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    /**\n-     * Reset the ports of I2P peers to 0.\n-     * This is needed as a temporary measure because now we enforce port 0 and\n-     * only connect to I2P hosts if the port is 0, but in the early days some\n-     * I2P addresses with port 8333 were rumoured and persisted into addrmans.\n-     */\n-    void ResetI2PPorts() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     friend class CAddrManTest;\n+    friend class CAddrManDeterministic;\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "c64a48a05ac9d6db308d0974a0d69b85875356d8",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -18,7 +18,7 @@ BanMan::BanMan(fs::path ban_file, CClientUIInterface* client_interface, int64_t\n     if (m_client_interface) m_client_interface->InitMessage(_(\"Loading banlist\u2026\").translated);\n \n     int64_t n_start = GetTimeMillis();\n-    if (m_ban_db.Read(m_banned, m_is_dirty)) {\n+    if (m_ban_db.Read(m_banned)) {\n         SweepBanned(); // sweep out unused entries\n \n         LogPrint(BCLog::NET, \"Loaded %d banned node addresses/subnets  %dms\\n\", m_banned.size(),"
      },
      {
        "sha": "8a03a9e3fcbaef53c92b21c8dd394687290d39e4",
        "filename": "src/banman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/banman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/banman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -88,7 +88,7 @@ class BanMan\n \n     RecursiveMutex m_cs_banned;\n     banmap_t m_banned GUARDED_BY(m_cs_banned);\n-    bool m_is_dirty GUARDED_BY(m_cs_banned);\n+    bool m_is_dirty GUARDED_BY(m_cs_banned){false};\n     CClientUIInterface* m_client_interface = nullptr;\n     CBanDB m_ban_db;\n     const int64_t m_default_ban_time;"
      },
      {
        "sha": "928aa7573c7403d09c9cb9fe4e832dfaefc1d587",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -21,7 +21,7 @@ static void VerifyScriptBench(benchmark::Bench& bench)\n     const ECCVerifyHandle verify_handle;\n     ECC_Start();\n \n-    const int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n+    const uint32_t flags{SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH};\n     const int witnessversion = 0;\n \n     // Key pair."
      },
      {
        "sha": "1ec6411e32cd31b7459965d5299af5d7c1e5b761",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 2,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <chainparamsbase.h>\n #include <clientversion.h>\n+#include <policy/feerate.h>\n #include <rpc/client.h>\n #include <rpc/mining.h>\n #include <rpc/protocol.h>\n@@ -28,6 +29,10 @@\n #include <string>\n #include <tuple>\n \n+#ifndef WIN32\n+#include <unistd.h>\n+#endif\n+\n #include <event2/buffer.h>\n #include <event2/keyvalq_struct.h>\n #include <support/events.h>\n@@ -48,6 +53,9 @@ static constexpr int8_t UNKNOWN_NETWORK{-1};\n /** Default number of blocks to generate for RPC generatetoaddress. */\n static const std::string DEFAULT_NBLOCKS = \"1\";\n \n+/** Default -color setting. */\n+static const std::string DEFAULT_COLOR_SETTING{\"auto\"};\n+\n static void SetupCliArgs(ArgsManager& argsman)\n {\n     SetupHelpOptions(argsman);\n@@ -66,6 +74,7 @@ static void SetupCliArgs(ArgsManager& argsman)\n     argsman.AddArg(\"-netinfo\", \"Get network peer connection information from the remote server. An optional integer argument from 0 to 4 can be passed for different peers listings (default: 0). Pass \\\"help\\\" for detailed help documentation.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n \n     SetupChainParamsBaseOptions(argsman);\n+    argsman.AddArg(\"-color=<when>\", strprintf(\"Color setting for CLI output (default: %s). Valid values: always, auto (add color codes when standard output is connected to a terminal and OS is not WIN32), never.\", DEFAULT_COLOR_SETTING), ArgsManager::ALLOW_STRING, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-named\", strprintf(\"Pass named instead of positional arguments (default: %s)\", DEFAULT_NAMED), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-rpcclienttimeout=<n>\", strprintf(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\", DEFAULT_HTTP_CLIENT_TIMEOUT), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     argsman.AddArg(\"-rpcconnect=<ip>\", strprintf(\"Send commands to node running on <ip> (default: %s)\", DEFAULT_RPCCONNECT), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n@@ -338,7 +347,9 @@ class GetinfoRequestHandler: public BaseRequestHandler\n         result.pushKV(\"difficulty\", batch[ID_BLOCKCHAININFO][\"result\"][\"difficulty\"]);\n         result.pushKV(\"chain\", UniValue(batch[ID_BLOCKCHAININFO][\"result\"][\"chain\"]));\n         if (!batch[ID_WALLETINFO][\"result\"].isNull()) {\n+            result.pushKV(\"has_wallet\", true);\n             result.pushKV(\"keypoolsize\", batch[ID_WALLETINFO][\"result\"][\"keypoolsize\"]);\n+            result.pushKV(\"walletname\", batch[ID_WALLETINFO][\"result\"][\"walletname\"]);\n             if (!batch[ID_WALLETINFO][\"result\"][\"unlocked_until\"].isNull()) {\n                 result.pushKV(\"unlocked_until\", batch[ID_WALLETINFO][\"result\"][\"unlocked_until\"]);\n             }\n@@ -873,6 +884,100 @@ static void GetWalletBalances(UniValue& result)\n     result.pushKV(\"balances\", balances);\n }\n \n+/**\n+ * ParseGetInfoResult takes in -getinfo result in UniValue object and parses it\n+ * into a user friendly UniValue string to be printed on the console.\n+ * @param[out] result  Reference to UniValue result containing the -getinfo output.\n+ */\n+static void ParseGetInfoResult(UniValue& result)\n+{\n+    if (!find_value(result, \"error\").isNull()) return;\n+\n+    std::string RESET, GREEN, BLUE, YELLOW, MAGENTA, CYAN;\n+    bool should_colorize = false;\n+\n+#ifndef WIN32\n+    if (isatty(fileno(stdout))) {\n+        // By default, only print colored text if OS is not WIN32 and stdout is connected to a terminal.\n+        should_colorize = true;\n+    }\n+#endif\n+\n+    if (gArgs.IsArgSet(\"-color\")) {\n+        const std::string color{gArgs.GetArg(\"-color\", DEFAULT_COLOR_SETTING)};\n+        if (color == \"always\") {\n+            should_colorize = true;\n+        } else if (color == \"never\") {\n+            should_colorize = false;\n+        } else if (color != \"auto\") {\n+            throw std::runtime_error(\"Invalid value for -color option. Valid values: always, auto, never.\");\n+        }\n+    }\n+\n+    if (should_colorize) {\n+        RESET = \"\\x1B[0m\";\n+        GREEN = \"\\x1B[32m\";\n+        BLUE = \"\\x1B[34m\";\n+        YELLOW = \"\\x1B[33m\";\n+        MAGENTA = \"\\x1B[35m\";\n+        CYAN = \"\\x1B[36m\";\n+    }\n+\n+    std::string result_string = strprintf(\"%sChain: %s%s\\n\", BLUE, result[\"chain\"].getValStr(), RESET);\n+    result_string += strprintf(\"Blocks: %s\\n\", result[\"blocks\"].getValStr());\n+    result_string += strprintf(\"Headers: %s\\n\", result[\"headers\"].getValStr());\n+    result_string += strprintf(\"Verification progress: %.4f%%\\n\", result[\"verificationprogress\"].get_real() * 100);\n+    result_string += strprintf(\"Difficulty: %s\\n\\n\", result[\"difficulty\"].getValStr());\n+\n+    result_string += strprintf(\n+        \"%sNetwork: in %s, out %s, total %s%s\\n\",\n+        GREEN,\n+        result[\"connections\"][\"in\"].getValStr(),\n+        result[\"connections\"][\"out\"].getValStr(),\n+        result[\"connections\"][\"total\"].getValStr(),\n+        RESET);\n+    result_string += strprintf(\"Version: %s\\n\", result[\"version\"].getValStr());\n+    result_string += strprintf(\"Time offset (s): %s\\n\", result[\"timeoffset\"].getValStr());\n+    const std::string proxy = result[\"proxy\"].getValStr();\n+    result_string += strprintf(\"Proxy: %s\\n\", proxy.empty() ? \"N/A\" : proxy);\n+    result_string += strprintf(\"Min tx relay fee rate (%s/kvB): %s\\n\\n\", CURRENCY_UNIT, result[\"relayfee\"].getValStr());\n+\n+    if (!result[\"has_wallet\"].isNull()) {\n+        const std::string walletname = result[\"walletname\"].getValStr();\n+        result_string += strprintf(\"%sWallet: %s%s\\n\", MAGENTA, walletname.empty() ? \"\\\"\\\"\" : walletname, RESET);\n+\n+        result_string += strprintf(\"Keypool size: %s\\n\", result[\"keypoolsize\"].getValStr());\n+        if (!result[\"unlocked_until\"].isNull()) {\n+            result_string += strprintf(\"Unlocked until: %s\\n\", result[\"unlocked_until\"].getValStr());\n+        }\n+        result_string += strprintf(\"Transaction fee rate (-paytxfee) (%s/kvB): %s\\n\\n\", CURRENCY_UNIT, result[\"paytxfee\"].getValStr());\n+    }\n+    if (!result[\"balance\"].isNull()) {\n+        result_string += strprintf(\"%sBalance:%s %s\\n\\n\", CYAN, RESET, result[\"balance\"].getValStr());\n+    }\n+\n+    if (!result[\"balances\"].isNull()) {\n+        result_string += strprintf(\"%sBalances%s\\n\", CYAN, RESET);\n+\n+        size_t max_balance_length{10};\n+\n+        for (const std::string& wallet : result[\"balances\"].getKeys()) {\n+            max_balance_length = std::max(result[\"balances\"][wallet].getValStr().length(), max_balance_length);\n+        }\n+\n+        for (const std::string& wallet : result[\"balances\"].getKeys()) {\n+            result_string += strprintf(\"%*s %s\\n\",\n+                                       max_balance_length,\n+                                       result[\"balances\"][wallet].getValStr(),\n+                                       wallet.empty() ? \"\\\"\\\"\" : wallet);\n+        }\n+        result_string += \"\\n\";\n+    }\n+\n+    result_string += strprintf(\"%sWarnings:%s %s\", YELLOW, RESET, result[\"warnings\"].getValStr());\n+    result.setStr(result_string);\n+}\n+\n /**\n  * Call RPC getnewaddress.\n  * @returns getnewaddress response as a UniValue object.\n@@ -994,9 +1099,13 @@ static int CommandLineRPC(int argc, char *argv[])\n             UniValue result = find_value(reply, \"result\");\n             const UniValue& error = find_value(reply, \"error\");\n             if (error.isNull()) {\n-                if (gArgs.IsArgSet(\"-getinfo\") && !gArgs.IsArgSet(\"-rpcwallet\")) {\n-                    GetWalletBalances(result); // fetch multiwallet balances and append to result\n+                if (gArgs.GetBoolArg(\"-getinfo\", false)) {\n+                    if (!gArgs.IsArgSet(\"-rpcwallet\")) {\n+                        GetWalletBalances(result); // fetch multiwallet balances and append to result\n+                    }\n+                    ParseGetInfoResult(result);\n                 }\n+\n                 ParseResult(result, strPrint);\n             } else {\n                 ParseError(error, strPrint, nRet);"
      },
      {
        "sha": "0b3242b1aac9b83e2fd9019fa1307174b044998e",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 26,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -91,8 +91,8 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1628640000; // August 11th, 2021\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021\n \n-        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000001533efd8d716a517fe2c5008\");\n-        consensus.defaultAssumeValid = uint256S(\"0x0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72\"); // 654683\n+        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000001fa4663bbbe19f82de910280\");\n+        consensus.defaultAssumeValid = uint256S(\"0x00000000000000000008a89e854d57e5667df88f1cdef6fde2fbca1de5b639ad\"); // 691719\n \n         /**\n          * The message start string is designed to be unlikely to occur in normal data.\n@@ -105,7 +105,7 @@ class CMainParams : public CChainParams {\n         pchMessageStart[3] = 0xd9;\n         nDefaultPort = 8333;\n         nPruneAfterHeight = 100000;\n-        m_assumed_blockchain_size = 350;\n+        m_assumed_blockchain_size = 420;\n         m_assumed_chain_state_size = 6;\n \n         genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);\n@@ -166,10 +166,10 @@ class CMainParams : public CChainParams {\n         };\n \n         chainTxData = ChainTxData{\n-            // Data from RPC: getchaintxstats 4096 0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72\n-            /* nTime    */ 1603995752,\n-            /* nTxCount */ 582083445,\n-            /* dTxRate  */ 3.508976121410527,\n+            // Data from RPC: getchaintxstats 4096 00000000000000000008a89e854d57e5667df88f1cdef6fde2fbca1de5b639ad\n+            /* nTime    */ 1626697539,\n+            /* nTxCount */ 656509474,\n+            /* dTxRate  */ 2.424920418708139,\n         };\n     }\n };\n@@ -210,8 +210,8 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1628640000; // August 11th, 2021\n         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay\n \n-        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000000001db6ec4ac88cf2272c6\");\n-        consensus.defaultAssumeValid = uint256S(\"0x000000000000006433d1efec504c53ca332b64963c425395515b01977bd7b3b0\"); // 1864000\n+        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000000005180c3bd8290da33a1a\");\n+        consensus.defaultAssumeValid = uint256S(\"0x0000000000004ae2f3896ca8ecd41c460a35bf6184e145d91558cece1c688a76\"); // 2010000\n \n         pchMessageStart[0] = 0x0b;\n         pchMessageStart[1] = 0x11;\n@@ -261,10 +261,10 @@ class CTestNetParams : public CChainParams {\n         };\n \n         chainTxData = ChainTxData{\n-            // Data from RPC: getchaintxstats 4096 000000000000006433d1efec504c53ca332b64963c425395515b01977bd7b3b0\n-            /* nTime    */ 1603359686,\n-            /* nTxCount */ 58090238,\n-            /* dTxRate  */ 0.1232886622799463,\n+            // Data from RPC: getchaintxstats 4096 0000000000004ae2f3896ca8ecd41c460a35bf6184e145d91558cece1c688a76\n+            /* nTime    */ 1625727096,\n+            /* nTxCount */ 60408943,\n+            /* dTxRate  */ 0.08379062270367649,\n         };\n     }\n };\n@@ -284,15 +284,15 @@ class SigNetParams : public CChainParams {\n             vSeeds.emplace_back(\"2a01:7c8:d005:390::5\");\n             vSeeds.emplace_back(\"v7ajjeirttkbnt32wpy3c6w3emwnfr3fkla7hpxcfokr3ysd3kqtzmqd.onion:38333\");\n \n-            consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000000000000019fd16269a\");\n-            consensus.defaultAssumeValid = uint256S(\"0x0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020\"); // 9434\n+            consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000000000000000008546553c03\");\n+            consensus.defaultAssumeValid = uint256S(\"0x000000187d4440e5bff91488b700a140441e089a8aaea707414982460edbfe54\"); // 47200\n             m_assumed_blockchain_size = 1;\n             m_assumed_chain_state_size = 0;\n             chainTxData = ChainTxData{\n-                // Data from RPC: getchaintxstats 4096 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020\n-                /* nTime    */ 1603986000,\n-                /* nTxCount */ 9582,\n-                /* dTxRate  */ 0.00159272030651341,\n+                // Data from RPC: getchaintxstats 4096 000000187d4440e5bff91488b700a140441e089a8aaea707414982460edbfe54\n+                /* nTime    */ 1626696658,\n+                /* nTxCount */ 387761,\n+                /* dTxRate  */ 0.04035946932424404,\n             };\n         } else {\n             const auto signet_challenge = args.GetArgs(\"-signetchallenge\");\n@@ -390,7 +390,7 @@ class CRegTestParams : public CChainParams {\n         consensus.signet_challenge.clear();\n         consensus.nSubsidyHalvingInterval = 150;\n         consensus.BIP16Exception = uint256();\n-        consensus.BIP34Height = 500; // BIP34 activated on regtest (Used in functional tests)\n+        consensus.BIP34Height = 2; // BIP34 activated on regtest (Block at height 1 not enforced for testing purposes)\n         consensus.BIP34Hash = uint256();\n         consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in functional tests)\n         consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in functional tests)\n@@ -435,7 +435,8 @@ class CRegTestParams : public CChainParams {\n         assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n \n         vFixedSeeds.clear(); //!< Regtest mode doesn't have any fixed seeds.\n-        vSeeds.clear();      //!< Regtest mode doesn't have any DNS seeds.\n+        vSeeds.clear();\n+        vSeeds.emplace_back(\"dummySeed.invalid.\");\n \n         fDefaultConsistencyChecks = true;\n         fRequireStandard = true;\n@@ -490,11 +491,8 @@ void CRegTestParams::UpdateActivationParametersFromArgs(const ArgsManager& args)\n {\n     if (args.IsArgSet(\"-segwitheight\")) {\n         int64_t height = args.GetArg(\"-segwitheight\", consensus.SegwitHeight);\n-        if (height < -1 || height >= std::numeric_limits<int>::max()) {\n-            throw std::runtime_error(strprintf(\"Activation height %ld for segwit is out of valid range. Use -1 to disable segwit.\", height));\n-        } else if (height == -1) {\n-            LogPrintf(\"Segwit disabled for testing\\n\");\n-            height = std::numeric_limits<int>::max();\n+        if (height < 0 || height >= std::numeric_limits<int>::max()) {\n+            throw std::runtime_error(strprintf(\"Activation height %ld for segwit is out of valid range.\", height));\n         }\n         consensus.SegwitHeight = static_cast<int>(height);\n     }"
      },
      {
        "sha": "79c1bc25bc175bacced7717e9f63d5b1d91a223d",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -20,7 +20,7 @@ void SetupChainParamsBaseOptions(ArgsManager& argsman)\n     argsman.AddArg(\"-chain=<chain>\", \"Use the chain <chain> (default: main). Allowed values: main, test, signet, regtest\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n                  \"This is intended for regression testing tools and app development. Equivalent to -chain=regtest.\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n-    argsman.AddArg(\"-segwitheight=<n>\", \"Set the activation height of segwit. -1 to disable. (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-segwitheight=<n>\", \"Set the activation height of segwit. (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-testnet\", \"Use the test chain. Equivalent to -chain=test.\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-vbparams=deployment:start:end[:min_activation_height]\", \"Use given start/end times and min_activation_height for specified version bits deployment (regtest-only)\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::CHAINPARAMS);\n     argsman.AddArg(\"-signet\", \"Use the signet chain. Equivalent to -chain=signet. Note that the network is defined by the -signetchallenge parameter\", ArgsManager::ALLOW_ANY, OptionsCategory::CHAINPARAMS);"
      },
      {
        "sha": "953a09d5e7d4a1010cafd35d967d8a3a4a3965f6",
        "filename": "src/chainparamsseeds.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/chainparamsseeds.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/chainparamsseeds.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsseeds.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -683,12 +683,20 @@ static const uint8_t chainparams_seed_main[] = {\n     0x04,0x20,0x98,0xc6,0x44,0x27,0x90,0x41,0xa6,0x98,0xf9,0x25,0x6c,0x59,0x0f,0x06,0x6d,0x44,0x59,0x0e,0xb2,0x46,0xb0,0xa4,0x37,0x88,0x69,0x8f,0xc1,0x32,0xcd,0x9f,0x15,0xd7,0x20,0x8d,\n     0x04,0x20,0xaa,0x3a,0x16,0x86,0xea,0x59,0x09,0x04,0x78,0xe5,0x10,0x92,0xe1,0x1d,0xad,0xf7,0x56,0x2b,0xac,0xb0,0x97,0x29,0x63,0x30,0xf4,0x1b,0xcf,0xde,0xf3,0x28,0x0a,0x29,0x20,0x8d,\n     0x04,0x20,0xbc,0x27,0xae,0x89,0xc1,0x67,0x73,0x0a,0x08,0x02,0xdf,0xb7,0xcc,0x94,0xc7,0x9f,0xf4,0x72,0x7a,0x9b,0x20,0x0c,0x5c,0x11,0x3d,0x22,0xd6,0x13,0x88,0x66,0x74,0xbf,0x20,0x8d,\n-    0x05,0x20,0xfe,0x97,0xba,0x09,0x2a,0xa4,0x85,0x10,0xa1,0x04,0x7b,0x88,0x7a,0x5a,0x06,0x53,0x71,0x93,0x3b,0xf9,0xa2,0x2f,0xd9,0xe3,0x8f,0xa5,0xa2,0xac,0x1e,0x6c,0x6c,0x8c,0x00,0x00,\n+    0x05,0x20,0xe1,0xd6,0xb8,0xfa,0xdd,0xeb,0x03,0x32,0x30,0x3b,0x20,0x6a,0xbc,0xaf,0x99,0x4f,0xa0,0xa2,0x72,0x48,0xfe,0x44,0xe0,0xf6,0x03,0xc1,0xbd,0xb6,0x24,0xd0,0xf6,0xb8,0x00,0x00,\n+    0x05,0x20,0xf4,0xb7,0xb4,0xcd,0xf5,0xb6,0x54,0x82,0x27,0x6d,0x29,0x7b,0x06,0x7f,0x52,0x59,0xa0,0xb4,0xdc,0xf7,0x6f,0xb4,0x71,0xcf,0xcc,0xfb,0x6b,0x86,0xc2,0x57,0x80,0xc6,0x00,0x00,\n+    0x05,0x20,0x07,0x61,0x26,0xd7,0x6c,0x05,0xbf,0xf6,0x2d,0x8c,0xca,0xc4,0x65,0xd3,0xd3,0xb2,0x49,0xe9,0xcc,0x53,0x1e,0xca,0x77,0x84,0xb6,0x10,0x5e,0xc2,0x5a,0xfe,0x28,0xb3,0x00,0x00,\n+    0x05,0x20,0x0a,0x26,0x27,0x45,0xb1,0x1e,0xfc,0x27,0x03,0x32,0x0e,0x65,0x9e,0x3c,0x64,0x0e,0x33,0x50,0x3d,0x6c,0x90,0x17,0x0e,0x29,0xee,0x5a,0x58,0xdf,0x08,0xde,0xbf,0x73,0x00,0x00,\n     0x05,0x20,0x17,0x0c,0x56,0xce,0x72,0xa5,0xa0,0xe6,0x23,0x06,0xa3,0xc7,0x08,0x43,0x18,0xee,0x3a,0x46,0x35,0x5d,0x17,0xf6,0x78,0x96,0xa0,0x9c,0x51,0xef,0xbe,0x23,0xfd,0x71,0x00,0x00,\n+    0x05,0x20,0x19,0xe7,0x0d,0x3f,0xfe,0x9e,0x0e,0x8e,0x73,0x40,0x40,0xc3,0xba,0x8f,0x41,0xaf,0xf1,0x7b,0xa6,0x83,0x1b,0xc3,0xa4,0xe0,0x6d,0x6c,0x57,0xa7,0x36,0x5d,0x09,0xce,0x00,0x00,\n     0x05,0x20,0x31,0x0f,0x30,0x0b,0x9d,0x70,0x0c,0x7c,0xf7,0x98,0x7e,0x1c,0xf4,0x33,0xdc,0x64,0x17,0xf7,0x00,0x7a,0x0c,0x04,0xb5,0x83,0xfc,0x5f,0xa6,0x52,0x39,0x79,0x63,0x87,0x00,0x00,\n     0x05,0x20,0x3e,0xe3,0xe0,0xa9,0xbc,0xf4,0x2e,0x59,0xd9,0x20,0xee,0xdf,0x74,0x61,0x4d,0x99,0x0c,0x5c,0x15,0x30,0x9b,0x72,0x16,0x79,0x15,0xf4,0x7a,0xca,0x34,0xcc,0x81,0x99,0x00,0x00,\n     0x05,0x20,0x3b,0x42,0x1c,0x25,0xf7,0xbf,0x79,0xed,0x6d,0x7d,0xef,0x65,0x30,0x7d,0xee,0x16,0x37,0x22,0x72,0x43,0x33,0x28,0x40,0xa3,0xaa,0xf4,0x48,0x49,0x67,0xb1,0x4b,0xfd,0x00,0x00,\n-    0x05,0x20,0x7a,0x65,0xf7,0x47,0x42,0x9d,0x66,0x42,0x3b,0xb3,0xa7,0x03,0x6c,0x46,0x78,0x19,0x28,0x78,0x1e,0xa3,0x7c,0x67,0x44,0xb7,0x83,0x05,0xe3,0xfe,0xa5,0xe4,0x0a,0x6e,0x00,0x00,\n+    0x05,0x20,0x46,0xce,0x21,0x81,0x48,0xce,0xa7,0x8a,0x98,0xca,0xb1,0x0b,0x51,0xa5,0xc8,0xff,0x39,0xc5,0x1a,0xa3,0xd3,0x02,0x32,0xa3,0x29,0xad,0x79,0xb8,0x7f,0x34,0x51,0x33,0x00,0x00,\n+    0x05,0x20,0x4e,0x77,0x2e,0x12,0x91,0x67,0x6b,0x94,0xc4,0x92,0x2f,0x19,0x67,0x7d,0xcd,0x47,0x02,0xad,0xf8,0x60,0x72,0xed,0x73,0xf1,0x10,0x99,0x2c,0x05,0x61,0x66,0x55,0xd9,0x00,0x00,\n+    0x05,0x20,0x53,0x94,0xa6,0x3e,0x14,0x82,0xd4,0xf9,0xd3,0xa7,0x53,0x33,0x05,0xce,0x72,0x64,0xed,0x74,0x09,0x63,0x8f,0x24,0xef,0xda,0x12,0xa1,0x55,0xe0,0xd8,0xbb,0xd3,0x58,0x00,0x00,\n+    0x05,0x20,0x55,0x62,0x32,0x7d,0x82,0x32,0x4f,0x9d,0xdf,0x24,0x5c,0xed,0x8e,0x1a,0x5a,0x8d,0xc6,0x50,0xb4,0x32,0xd5,0x85,0xef,0xb0,0xfa,0x7c,0xf9,0xbb,0x25,0x89,0x6b,0x03,0x00,0x00,\n+    0x05,0x20,0x91,0xcf,0xa2,0x5b,0x04,0x33,0x69,0x66,0xb0,0x72,0x27,0x54,0xbe,0xcd,0xd8,0x08,0xeb,0x95,0x55,0x5a,0xc2,0x79,0x91,0x3a,0xd9,0xf2,0x2c,0x73,0x9f,0x78,0x50,0xca,0x00,0x00,\n     0x05,0x20,0xb5,0x83,0x6f,0xb6,0x11,0xd8,0x0e,0xa8,0x57,0xda,0x15,0x20,0x5b,0x1a,0x6d,0x21,0x15,0x5a,0xbd,0xb4,0x17,0x11,0xc2,0xfb,0x0e,0xfc,0xde,0xe8,0x26,0x56,0xa8,0xac,0x00,0x00,\n     0x05,0x20,0xcc,0xaf,0x6c,0x3b,0xd0,0x13,0x76,0x23,0xc3,0x36,0xbb,0x64,0x4a,0x4a,0x06,0x93,0x69,0x6d,0xb0,0x10,0x6e,0x66,0xa4,0x61,0xf8,0x2d,0xe7,0x80,0x72,0x4d,0x53,0x94,0x00,0x00,\n };"
      },
      {
        "sha": "77bf7fd0d8ba93b3470be25722c9dd0e184258fc",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -23,15 +23,15 @@ enum BuriedDeployment : int16_t {\n     DEPLOYMENT_CSV,\n     DEPLOYMENT_SEGWIT,\n };\n-constexpr bool ValidDeployment(BuriedDeployment dep) { return DEPLOYMENT_HEIGHTINCB <= dep && dep <= DEPLOYMENT_SEGWIT; }\n+constexpr bool ValidDeployment(BuriedDeployment dep) { return dep <= DEPLOYMENT_SEGWIT; }\n \n enum DeploymentPos : uint16_t {\n     DEPLOYMENT_TESTDUMMY,\n     DEPLOYMENT_TAPROOT, // Deployment of Schnorr/Taproot (BIPs 340-342)\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in deploymentinfo.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n };\n-constexpr bool ValidDeployment(DeploymentPos dep) { return DEPLOYMENT_TESTDUMMY <= dep && dep <= DEPLOYMENT_TAPROOT; }\n+constexpr bool ValidDeployment(DeploymentPos dep) { return dep < MAX_VERSION_BITS_DEPLOYMENTS; }\n \n /**\n  * Struct for each individual consensus rule change using BIP9."
      },
      {
        "sha": "0ab790ccdc40c3381fdb83717fd17cce59547693",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -144,7 +144,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     return nSigOps;\n }\n \n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, uint32_t flags)\n {\n     int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n "
      },
      {
        "sha": "264433c33d3c235c59e878cd15f63f28e6585a38",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -49,10 +49,10 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& ma\n  * Compute total signature operation cost of a transaction.\n  * @param[in] tx     Transaction for which we are computing the cost\n  * @param[in] inputs Map of previous transactions that have outputs we're spending\n- * @param[out] flags Script verification flags\n+ * @param[in] flags Script verification flags\n  * @return Total signature operation cost of tx\n  */\n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, uint32_t flags);\n \n /**\n  * Check if transaction is final and can be included in a block with the"
      },
      {
        "sha": "bba86639a3570a1170b1afdde1a9a3c83faa66f2",
        "filename": "src/deploymentstatus.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/deploymentstatus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/deploymentstatus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/deploymentstatus.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,6 +7,8 @@\n #include <consensus/params.h>\n #include <versionbits.h>\n \n+#include <type_traits>\n+\n VersionBitsCache g_versionbitscache;\n \n /* Basic sanity checking for BuriedDeployment/DeploymentPos enums and\n@@ -15,3 +17,18 @@ VersionBitsCache g_versionbitscache;\n static_assert(ValidDeployment(Consensus::DEPLOYMENT_TESTDUMMY), \"sanity check of DeploymentPos failed (TESTDUMMY not valid)\");\n static_assert(!ValidDeployment(Consensus::MAX_VERSION_BITS_DEPLOYMENTS), \"sanity check of DeploymentPos failed (MAX value considered valid)\");\n static_assert(!ValidDeployment(static_cast<Consensus::BuriedDeployment>(Consensus::DEPLOYMENT_TESTDUMMY)), \"sanity check of BuriedDeployment failed (overlaps with DeploymentPos)\");\n+\n+/* ValidDeployment only checks upper bounds for ensuring validity.\n+ * This checks that the lowest possible value or the type is also a\n+ * (specific) valid deployment so that lower bounds don't need to be checked.\n+ */\n+\n+template<typename T, T x>\n+static constexpr bool is_minimum()\n+{\n+    using U = typename std::underlying_type<T>::type;\n+    return x == std::numeric_limits<U>::min();\n+}\n+\n+static_assert(is_minimum<Consensus::BuriedDeployment, Consensus::DEPLOYMENT_HEIGHTINCB>(), \"heightincb is not minimum value for BuriedDeployment\");\n+static_assert(is_minimum<Consensus::DeploymentPos, Consensus::DEPLOYMENT_TESTDUMMY>(), \"testdummy is not minimum value for DeploymentPos\");"
      },
      {
        "sha": "3465caa3a937cad71670a06ae810c8a9af54bdb1",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -47,8 +47,10 @@ unsigned int MurmurHash3(unsigned int nHashSeed, Span<const unsigned char> vData\n     switch (vDataToHash.size() & 3) {\n         case 3:\n             k1 ^= tail[2] << 16;\n+            [[fallthrough]];\n         case 2:\n             k1 ^= tail[1] << 8;\n+            [[fallthrough]];\n         case 1:\n             k1 ^= tail[0];\n             k1 *= c1;"
      },
      {
        "sha": "9ab9209ca419098b1737abe9cab84129aabd0892",
        "filename": "src/index/coinstatsindex.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 90,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/index/coinstatsindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/index/coinstatsindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/coinstatsindex.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -24,14 +24,14 @@ struct DBVal {\n     uint64_t bogo_size;\n     CAmount total_amount;\n     CAmount total_subsidy;\n-    CAmount block_unspendable_amount;\n-    CAmount block_prevout_spent_amount;\n-    CAmount block_new_outputs_ex_coinbase_amount;\n-    CAmount block_coinbase_amount;\n-    CAmount unspendables_genesis_block;\n-    CAmount unspendables_bip30;\n-    CAmount unspendables_scripts;\n-    CAmount unspendables_unclaimed_rewards;\n+    CAmount total_unspendable_amount;\n+    CAmount total_prevout_spent_amount;\n+    CAmount total_new_outputs_ex_coinbase_amount;\n+    CAmount total_coinbase_amount;\n+    CAmount total_unspendables_genesis_block;\n+    CAmount total_unspendables_bip30;\n+    CAmount total_unspendables_scripts;\n+    CAmount total_unspendables_unclaimed_rewards;\n \n     SERIALIZE_METHODS(DBVal, obj)\n     {\n@@ -40,14 +40,14 @@ struct DBVal {\n         READWRITE(obj.bogo_size);\n         READWRITE(obj.total_amount);\n         READWRITE(obj.total_subsidy);\n-        READWRITE(obj.block_unspendable_amount);\n-        READWRITE(obj.block_prevout_spent_amount);\n-        READWRITE(obj.block_new_outputs_ex_coinbase_amount);\n-        READWRITE(obj.block_coinbase_amount);\n-        READWRITE(obj.unspendables_genesis_block);\n-        READWRITE(obj.unspendables_bip30);\n-        READWRITE(obj.unspendables_scripts);\n-        READWRITE(obj.unspendables_unclaimed_rewards);\n+        READWRITE(obj.total_unspendable_amount);\n+        READWRITE(obj.total_prevout_spent_amount);\n+        READWRITE(obj.total_new_outputs_ex_coinbase_amount);\n+        READWRITE(obj.total_coinbase_amount);\n+        READWRITE(obj.total_unspendables_genesis_block);\n+        READWRITE(obj.total_unspendables_bip30);\n+        READWRITE(obj.total_unspendables_scripts);\n+        READWRITE(obj.total_unspendables_unclaimed_rewards);\n     }\n };\n \n@@ -122,9 +122,12 @@ bool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n \n         uint256 expected_block_hash{pindex->pprev->GetBlockHash()};\n         if (read_out.first != expected_block_hash) {\n+            LogPrintf(\"WARNING: previous block header belongs to unexpected block %s; expected %s\\n\",\n+                      read_out.first.ToString(), expected_block_hash.ToString());\n+\n             if (!m_db->Read(DBHashKey(expected_block_hash), read_out)) {\n-                return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n-                             __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+                return error(\"%s: previous block header not found; expected %s\",\n+                             __func__, expected_block_hash.ToString());\n             }\n         }\n \n@@ -138,29 +141,29 @@ bool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n \n             // Skip duplicate txid coinbase transactions (BIP30).\n             if (is_bip30_block && tx->IsCoinBase()) {\n-                m_block_unspendable_amount += block_subsidy;\n-                m_unspendables_bip30 += block_subsidy;\n+                m_total_unspendable_amount += block_subsidy;\n+                m_total_unspendables_bip30 += block_subsidy;\n                 continue;\n             }\n \n-            for (size_t j = 0; j < tx->vout.size(); ++j) {\n+            for (uint32_t j = 0; j < tx->vout.size(); ++j) {\n                 const CTxOut& out{tx->vout[j]};\n                 Coin coin{out, pindex->nHeight, tx->IsCoinBase()};\n-                COutPoint outpoint{tx->GetHash(), static_cast<uint32_t>(j)};\n+                COutPoint outpoint{tx->GetHash(), j};\n \n                 // Skip unspendable coins\n                 if (coin.out.scriptPubKey.IsUnspendable()) {\n-                    m_block_unspendable_amount += coin.out.nValue;\n-                    m_unspendables_scripts += coin.out.nValue;\n+                    m_total_unspendable_amount += coin.out.nValue;\n+                    m_total_unspendables_scripts += coin.out.nValue;\n                     continue;\n                 }\n \n                 m_muhash.Insert(MakeUCharSpan(TxOutSer(outpoint, coin)));\n \n                 if (tx->IsCoinBase()) {\n-                    m_block_coinbase_amount += coin.out.nValue;\n+                    m_total_coinbase_amount += coin.out.nValue;\n                 } else {\n-                    m_block_new_outputs_ex_coinbase_amount += coin.out.nValue;\n+                    m_total_new_outputs_ex_coinbase_amount += coin.out.nValue;\n                 }\n \n                 ++m_transaction_output_count;\n@@ -178,7 +181,7 @@ bool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n \n                     m_muhash.Remove(MakeUCharSpan(TxOutSer(outpoint, coin)));\n \n-                    m_block_prevout_spent_amount += coin.out.nValue;\n+                    m_total_prevout_spent_amount += coin.out.nValue;\n \n                     --m_transaction_output_count;\n                     m_total_amount -= coin.out.nValue;\n@@ -188,38 +191,41 @@ bool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n         }\n     } else {\n         // genesis block\n-        m_block_unspendable_amount += block_subsidy;\n-        m_unspendables_genesis_block += block_subsidy;\n+        m_total_unspendable_amount += block_subsidy;\n+        m_total_unspendables_genesis_block += block_subsidy;\n     }\n \n     // If spent prevouts + block subsidy are still a higher amount than\n     // new outputs + coinbase + current unspendable amount this means\n     // the miner did not claim the full block reward. Unclaimed block\n     // rewards are also unspendable.\n-    const CAmount unclaimed_rewards{(m_block_prevout_spent_amount + m_total_subsidy) - (m_block_new_outputs_ex_coinbase_amount + m_block_coinbase_amount + m_block_unspendable_amount)};\n-    m_block_unspendable_amount += unclaimed_rewards;\n-    m_unspendables_unclaimed_rewards += unclaimed_rewards;\n+    const CAmount unclaimed_rewards{(m_total_prevout_spent_amount + m_total_subsidy) - (m_total_new_outputs_ex_coinbase_amount + m_total_coinbase_amount + m_total_unspendable_amount)};\n+    m_total_unspendable_amount += unclaimed_rewards;\n+    m_total_unspendables_unclaimed_rewards += unclaimed_rewards;\n \n     std::pair<uint256, DBVal> value;\n     value.first = pindex->GetBlockHash();\n     value.second.transaction_output_count = m_transaction_output_count;\n     value.second.bogo_size = m_bogo_size;\n     value.second.total_amount = m_total_amount;\n     value.second.total_subsidy = m_total_subsidy;\n-    value.second.block_unspendable_amount = m_block_unspendable_amount;\n-    value.second.block_prevout_spent_amount = m_block_prevout_spent_amount;\n-    value.second.block_new_outputs_ex_coinbase_amount = m_block_new_outputs_ex_coinbase_amount;\n-    value.second.block_coinbase_amount = m_block_coinbase_amount;\n-    value.second.unspendables_genesis_block = m_unspendables_genesis_block;\n-    value.second.unspendables_bip30 = m_unspendables_bip30;\n-    value.second.unspendables_scripts = m_unspendables_scripts;\n-    value.second.unspendables_unclaimed_rewards = m_unspendables_unclaimed_rewards;\n+    value.second.total_unspendable_amount = m_total_unspendable_amount;\n+    value.second.total_prevout_spent_amount = m_total_prevout_spent_amount;\n+    value.second.total_new_outputs_ex_coinbase_amount = m_total_new_outputs_ex_coinbase_amount;\n+    value.second.total_coinbase_amount = m_total_coinbase_amount;\n+    value.second.total_unspendables_genesis_block = m_total_unspendables_genesis_block;\n+    value.second.total_unspendables_bip30 = m_total_unspendables_bip30;\n+    value.second.total_unspendables_scripts = m_total_unspendables_scripts;\n+    value.second.total_unspendables_unclaimed_rewards = m_total_unspendables_unclaimed_rewards;\n \n     uint256 out;\n     m_muhash.Finalize(out);\n     value.second.muhash = out;\n \n-    return m_db->Write(DBHeightKey(pindex->nHeight), value) && m_db->Write(DB_MUHASH, m_muhash);\n+    CDBBatch batch(*m_db);\n+    batch.Write(DBHeightKey(pindex->nHeight), value);\n+    batch.Write(DB_MUHASH, m_muhash);\n+    return m_db->WriteBatch(batch);\n }\n \n static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n@@ -317,14 +323,14 @@ bool CoinStatsIndex::LookUpStats(const CBlockIndex* block_index, CCoinsStats& co\n     coins_stats.nBogoSize = entry.bogo_size;\n     coins_stats.nTotalAmount = entry.total_amount;\n     coins_stats.total_subsidy = entry.total_subsidy;\n-    coins_stats.block_unspendable_amount = entry.block_unspendable_amount;\n-    coins_stats.block_prevout_spent_amount = entry.block_prevout_spent_amount;\n-    coins_stats.block_new_outputs_ex_coinbase_amount = entry.block_new_outputs_ex_coinbase_amount;\n-    coins_stats.block_coinbase_amount = entry.block_coinbase_amount;\n-    coins_stats.unspendables_genesis_block = entry.unspendables_genesis_block;\n-    coins_stats.unspendables_bip30 = entry.unspendables_bip30;\n-    coins_stats.unspendables_scripts = entry.unspendables_scripts;\n-    coins_stats.unspendables_unclaimed_rewards = entry.unspendables_unclaimed_rewards;\n+    coins_stats.total_unspendable_amount = entry.total_unspendable_amount;\n+    coins_stats.total_prevout_spent_amount = entry.total_prevout_spent_amount;\n+    coins_stats.total_new_outputs_ex_coinbase_amount = entry.total_new_outputs_ex_coinbase_amount;\n+    coins_stats.total_coinbase_amount = entry.total_coinbase_amount;\n+    coins_stats.total_unspendables_genesis_block = entry.total_unspendables_genesis_block;\n+    coins_stats.total_unspendables_bip30 = entry.total_unspendables_bip30;\n+    coins_stats.total_unspendables_scripts = entry.total_unspendables_scripts;\n+    coins_stats.total_unspendables_unclaimed_rewards = entry.total_unspendables_unclaimed_rewards;\n \n     return true;\n }\n@@ -341,33 +347,31 @@ bool CoinStatsIndex::Init()\n         }\n     }\n \n-    if (BaseIndex::Init()) {\n-        const CBlockIndex* pindex{CurrentIndex()};\n+    if (!BaseIndex::Init()) return false;\n \n-        if (pindex) {\n-            DBVal entry;\n-            if (!LookUpOne(*m_db, pindex, entry)) {\n-                return false;\n-            }\n+    const CBlockIndex* pindex{CurrentIndex()};\n \n-            m_transaction_output_count = entry.transaction_output_count;\n-            m_bogo_size = entry.bogo_size;\n-            m_total_amount = entry.total_amount;\n-            m_total_subsidy = entry.total_subsidy;\n-            m_block_unspendable_amount = entry.block_unspendable_amount;\n-            m_block_prevout_spent_amount = entry.block_prevout_spent_amount;\n-            m_block_new_outputs_ex_coinbase_amount = entry.block_new_outputs_ex_coinbase_amount;\n-            m_block_coinbase_amount = entry.block_coinbase_amount;\n-            m_unspendables_genesis_block = entry.unspendables_genesis_block;\n-            m_unspendables_bip30 = entry.unspendables_bip30;\n-            m_unspendables_scripts = entry.unspendables_scripts;\n-            m_unspendables_unclaimed_rewards = entry.unspendables_unclaimed_rewards;\n+    if (pindex) {\n+        DBVal entry;\n+        if (!LookUpOne(*m_db, pindex, entry)) {\n+            return false;\n         }\n \n-        return true;\n+        m_transaction_output_count = entry.transaction_output_count;\n+        m_bogo_size = entry.bogo_size;\n+        m_total_amount = entry.total_amount;\n+        m_total_subsidy = entry.total_subsidy;\n+        m_total_unspendable_amount = entry.total_unspendable_amount;\n+        m_total_prevout_spent_amount = entry.total_prevout_spent_amount;\n+        m_total_new_outputs_ex_coinbase_amount = entry.total_new_outputs_ex_coinbase_amount;\n+        m_total_coinbase_amount = entry.total_coinbase_amount;\n+        m_total_unspendables_genesis_block = entry.total_unspendables_genesis_block;\n+        m_total_unspendables_bip30 = entry.total_unspendables_bip30;\n+        m_total_unspendables_scripts = entry.total_unspendables_scripts;\n+        m_total_unspendables_unclaimed_rewards = entry.total_unspendables_unclaimed_rewards;\n     }\n \n-    return false;\n+    return true;\n }\n \n // Reverse a single block as part of a reorg\n@@ -391,9 +395,12 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex\n \n         uint256 expected_block_hash{pindex->pprev->GetBlockHash()};\n         if (read_out.first != expected_block_hash) {\n+            LogPrintf(\"WARNING: previous block header belongs to unexpected block %s; expected %s\\n\",\n+                      read_out.first.ToString(), expected_block_hash.ToString());\n+\n             if (!m_db->Read(DBHashKey(expected_block_hash), read_out)) {\n-                return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n-                             __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+                return error(\"%s: previous block header not found; expected %s\",\n+                             __func__, expected_block_hash.ToString());\n             }\n         }\n     }\n@@ -402,24 +409,24 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex\n     for (size_t i = 0; i < block.vtx.size(); ++i) {\n         const auto& tx{block.vtx.at(i)};\n \n-        for (size_t j = 0; j < tx->vout.size(); ++j) {\n+        for (uint32_t j = 0; j < tx->vout.size(); ++j) {\n             const CTxOut& out{tx->vout[j]};\n-            COutPoint outpoint{tx->GetHash(), static_cast<uint32_t>(j)};\n+            COutPoint outpoint{tx->GetHash(), j};\n             Coin coin{out, pindex->nHeight, tx->IsCoinBase()};\n \n             // Skip unspendable coins\n             if (coin.out.scriptPubKey.IsUnspendable()) {\n-                m_block_unspendable_amount -= coin.out.nValue;\n-                m_unspendables_scripts -= coin.out.nValue;\n+                m_total_unspendable_amount -= coin.out.nValue;\n+                m_total_unspendables_scripts -= coin.out.nValue;\n                 continue;\n             }\n \n             m_muhash.Remove(MakeUCharSpan(TxOutSer(outpoint, coin)));\n \n             if (tx->IsCoinBase()) {\n-                m_block_coinbase_amount -= coin.out.nValue;\n+                m_total_coinbase_amount -= coin.out.nValue;\n             } else {\n-                m_block_new_outputs_ex_coinbase_amount -= coin.out.nValue;\n+                m_total_new_outputs_ex_coinbase_amount -= coin.out.nValue;\n             }\n \n             --m_transaction_output_count;\n@@ -437,7 +444,7 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex\n \n                 m_muhash.Insert(MakeUCharSpan(TxOutSer(outpoint, coin)));\n \n-                m_block_prevout_spent_amount -= coin.out.nValue;\n+                m_total_prevout_spent_amount -= coin.out.nValue;\n \n                 m_transaction_output_count++;\n                 m_total_amount += coin.out.nValue;\n@@ -446,9 +453,9 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex\n         }\n     }\n \n-    const CAmount unclaimed_rewards{(m_block_new_outputs_ex_coinbase_amount + m_block_coinbase_amount + m_block_unspendable_amount) - (m_block_prevout_spent_amount + m_total_subsidy)};\n-    m_block_unspendable_amount -= unclaimed_rewards;\n-    m_unspendables_unclaimed_rewards -= unclaimed_rewards;\n+    const CAmount unclaimed_rewards{(m_total_new_outputs_ex_coinbase_amount + m_total_coinbase_amount + m_total_unspendable_amount) - (m_total_prevout_spent_amount + m_total_subsidy)};\n+    m_total_unspendable_amount -= unclaimed_rewards;\n+    m_total_unspendables_unclaimed_rewards -= unclaimed_rewards;\n \n     // Check that the rolled back internal values are consistent with the DB read out\n     uint256 out;\n@@ -459,14 +466,14 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex\n     Assert(m_total_amount == read_out.second.total_amount);\n     Assert(m_bogo_size == read_out.second.bogo_size);\n     Assert(m_total_subsidy == read_out.second.total_subsidy);\n-    Assert(m_block_unspendable_amount == read_out.second.block_unspendable_amount);\n-    Assert(m_block_prevout_spent_amount == read_out.second.block_prevout_spent_amount);\n-    Assert(m_block_new_outputs_ex_coinbase_amount == read_out.second.block_new_outputs_ex_coinbase_amount);\n-    Assert(m_block_coinbase_amount == read_out.second.block_coinbase_amount);\n-    Assert(m_unspendables_genesis_block == read_out.second.unspendables_genesis_block);\n-    Assert(m_unspendables_bip30 == read_out.second.unspendables_bip30);\n-    Assert(m_unspendables_scripts == read_out.second.unspendables_scripts);\n-    Assert(m_unspendables_unclaimed_rewards == read_out.second.unspendables_unclaimed_rewards);\n+    Assert(m_total_unspendable_amount == read_out.second.total_unspendable_amount);\n+    Assert(m_total_prevout_spent_amount == read_out.second.total_prevout_spent_amount);\n+    Assert(m_total_new_outputs_ex_coinbase_amount == read_out.second.total_new_outputs_ex_coinbase_amount);\n+    Assert(m_total_coinbase_amount == read_out.second.total_coinbase_amount);\n+    Assert(m_total_unspendables_genesis_block == read_out.second.total_unspendables_genesis_block);\n+    Assert(m_total_unspendables_bip30 == read_out.second.total_unspendables_bip30);\n+    Assert(m_total_unspendables_scripts == read_out.second.total_unspendables_scripts);\n+    Assert(m_total_unspendables_unclaimed_rewards == read_out.second.total_unspendables_unclaimed_rewards);\n \n     return m_db->Write(DB_MUHASH, m_muhash);\n }"
      },
      {
        "sha": "a575b37c7c48f32a5b4076e773c9b667d18bd47f",
        "filename": "src/index/coinstatsindex.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/index/coinstatsindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/index/coinstatsindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/coinstatsindex.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -25,14 +25,14 @@ class CoinStatsIndex final : public BaseIndex\n     uint64_t m_bogo_size{0};\n     CAmount m_total_amount{0};\n     CAmount m_total_subsidy{0};\n-    CAmount m_block_unspendable_amount{0};\n-    CAmount m_block_prevout_spent_amount{0};\n-    CAmount m_block_new_outputs_ex_coinbase_amount{0};\n-    CAmount m_block_coinbase_amount{0};\n-    CAmount m_unspendables_genesis_block{0};\n-    CAmount m_unspendables_bip30{0};\n-    CAmount m_unspendables_scripts{0};\n-    CAmount m_unspendables_unclaimed_rewards{0};\n+    CAmount m_total_unspendable_amount{0};\n+    CAmount m_total_prevout_spent_amount{0};\n+    CAmount m_total_new_outputs_ex_coinbase_amount{0};\n+    CAmount m_total_coinbase_amount{0};\n+    CAmount m_total_unspendables_genesis_block{0};\n+    CAmount m_total_unspendables_bip30{0};\n+    CAmount m_total_unspendables_scripts{0};\n+    CAmount m_total_unspendables_unclaimed_rewards{0};\n \n     bool ReverseBlock(const CBlock& block, const CBlockIndex* pindex);\n "
      },
      {
        "sha": "cde9821f3de9ccc772312fe1d11dcc94a1d7de1c",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -204,7 +204,7 @@ bool TxIndex::Init()\n     // Attempt to migrate txindex from the old database to the new one. Even if\n     // chain_tip is null, the node could be reindexing and we still want to\n     // delete txindex records in the old database.\n-    if (!m_db->MigrateData(*pblocktree, m_chainstate->m_chain.GetLocator())) {\n+    if (!m_db->MigrateData(*m_chainstate->m_blockman.m_block_tree_db, m_chainstate->m_chain.GetLocator())) {\n         return false;\n     }\n "
      },
      {
        "sha": "1b406bed282966222bfcd71150a53c437c311b8f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -264,7 +264,6 @@ void Shutdown(NodeContext& node)\n                 chainstate->ResetCoinsViews();\n             }\n         }\n-        pblocktree.reset();\n     }\n     for (const auto& client : node.chain_clients) {\n         client->stop();\n@@ -427,7 +426,7 @@ void SetupServerArgs(ArgsManager& argsman)\n     argsman.AddArg(\"-dnsseed\", strprintf(\"Query for peer addresses via DNS lookup, if low on addresses (default: %u unless -connect used)\", DEFAULT_DNSSEED), ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-externalip=<ip>\", \"Specify your own public address\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-fixedseeds\", strprintf(\"Allow fixed seeds if DNS seeds don't provide peers (default: %u)\", DEFAULT_FIXEDSEEDS), ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-forcednsseed\", strprintf(\"Always query for peer addresses via DNS lookup (default: %u)\", DEFAULT_FORCEDNSSEED), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-forcednsseed\", strprintf(\"Always query for peer addresses via DNS lookup (default: %u)\", DEFAULT_FORCEDNSSEED), ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-listen\", \"Accept connections from outside (default: 1 if no -proxy or -connect)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-listenonion\", strprintf(\"Automatically create Tor onion service (default: %d)\", DEFAULT_LISTEN_ONION), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxconnections=<n>\", strprintf(\"Maintain at most <n> connections to peers (default: %u). This limit does not apply to connections manually added via -addnode or the addnode RPC, which have a separate limit of %u.\", DEFAULT_MAX_PEER_CONNECTIONS, MAX_ADDNODE_CONNECTIONS), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n@@ -716,7 +715,7 @@ namespace { // Variables internal to initialization process only\n int nMaxConnections;\n int nUserMaxConnections;\n int nFD;\n-ServiceFlags nLocalServices = ServiceFlags(NODE_NETWORK | NODE_NETWORK_LIMITED);\n+ServiceFlags nLocalServices = ServiceFlags(NODE_NETWORK | NODE_NETWORK_LIMITED | NODE_WITNESS);\n int64_t peer_connect_timeout;\n std::set<BlockFilterType> g_enabled_filter_types;\n \n@@ -849,6 +848,11 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n             return InitError(_(\"Prune mode is incompatible with -coinstatsindex.\"));\n     }\n \n+    // If -forcednsseed is set to true, ensure -dnsseed has not been set to false\n+    if (args.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED) && !args.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED)){\n+        return InitError(_(\"Cannot set -forcednsseed to true when setting -dnsseed to false.\"));\n+    }\n+\n     // -bind and -whitebind can't be set when not listening\n     size_t nUserBind = args.GetArgs(\"-bind\").size() + args.GetArgs(\"-whitebind\").size();\n     if (nUserBind != 0 && !args.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n@@ -1181,7 +1185,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n     assert(!node.peerman);\n     node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),\n-                                     *node.scheduler, chainman, *node.mempool, ignores_incoming_txs);\n+                                     chainman, *node.mempool, ignores_incoming_txs);\n     RegisterValidationInterface(node.peerman.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n@@ -1355,6 +1359,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n                 UnloadBlockIndex(node.mempool.get(), chainman);\n \n+                auto& pblocktree{chainman.m_blockman.m_block_tree_db};\n                 // new CBlockTreeDB tries to delete the existing file, which\n                 // fails if it's still open from the previous loop. Close it first:\n                 pblocktree.reset();\n@@ -1588,12 +1593,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n         }\n     }\n \n-    if (DeploymentEnabled(chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT)) {\n-        // Advertise witness capabilities.\n-        // The option to not set NODE_WITNESS is only used in the tests and should be removed.\n-        nLocalServices = ServiceFlags(nLocalServices | NODE_WITNESS);\n-    }\n-\n     // ********************************************************* Step 11: import blocks\n \n     if (!CheckDiskSpace(gArgs.GetDataDirNet())) {\n@@ -1795,6 +1794,8 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n         banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL);\n \n+    if (node.peerman) node.peerman->StartScheduledTasks(*node.scheduler);\n+\n #if HAVE_SYSTEM\n     StartupNotify(args);\n #endif"
      },
      {
        "sha": "963649fc9ab2e3152261a3b7275ffc4f24b2dffb",
        "filename": "src/interfaces/ipc.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/interfaces/ipc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/interfaces/ipc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/ipc.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -9,6 +9,10 @@\n #include <memory>\n #include <typeindex>\n \n+namespace ipc {\n+struct Context;\n+} // namespace ipc\n+\n namespace interfaces {\n class Init;\n \n@@ -58,6 +62,9 @@ class Ipc\n         addCleanup(typeid(Interface), &iface, std::move(cleanup));\n     }\n \n+    //! IPC context struct accessor (see struct definition for more description).\n+    virtual ipc::Context& context() = 0;\n+\n protected:\n     //! Internal implementation of public addCleanup method (above) as a\n     //! type-erased virtual function, since template functions can't be virtual."
      },
      {
        "sha": "06e16144941baec8dcc4dce7d371f023ff8a8056",
        "filename": "src/ipc/capnp/context.h",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/ipc/capnp/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/ipc/capnp/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/context.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,23 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_CAPNP_CONTEXT_H\n+#define BITCOIN_IPC_CAPNP_CONTEXT_H\n+\n+#include <ipc/context.h>\n+\n+namespace ipc {\n+namespace capnp {\n+//! Cap'n Proto context struct. Generally the parent ipc::Context struct should\n+//! be used instead of this struct to give all IPC protocols access to\n+//! application state, so there aren't unnecessary differences between IPC\n+//! protocols. But this specialized struct can be used to pass capnp-specific\n+//! function and object types to capnp hooks.\n+struct Context : ipc::Context\n+{\n+};\n+} // namespace capnp\n+} // namespace ipc\n+\n+#endif // BITCOIN_IPC_CAPNP_CONTEXT_H"
      },
      {
        "sha": "37b57a95251bd99092642e4868bd4c8d498a308c",
        "filename": "src/ipc/capnp/protocol.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/ipc/capnp/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/ipc/capnp/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/capnp/protocol.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <interfaces/init.h>\n+#include <ipc/capnp/context.h>\n #include <ipc/capnp/init.capnp.h>\n #include <ipc/capnp/init.capnp.proxy.h>\n #include <ipc/capnp/protocol.h>\n@@ -54,7 +55,7 @@ class CapnpProtocol : public Protocol\n     {\n         assert(!m_loop);\n         mp::g_thread_context.thread_name = mp::ThreadName(exe_name);\n-        m_loop.emplace(exe_name, &IpcLogFn, nullptr);\n+        m_loop.emplace(exe_name, &IpcLogFn, &m_context);\n         mp::ServeStream<messages::Init>(*m_loop, fd, init);\n         m_loop->loop();\n         m_loop.reset();\n@@ -63,13 +64,14 @@ class CapnpProtocol : public Protocol\n     {\n         mp::ProxyTypeRegister::types().at(type)(iface).cleanup.emplace_back(std::move(cleanup));\n     }\n+    Context& context() override { return m_context; }\n     void startLoop(const char* exe_name)\n     {\n         if (m_loop) return;\n         std::promise<void> promise;\n         m_loop_thread = std::thread([&] {\n             util::ThreadRename(\"capnp-loop\");\n-            m_loop.emplace(exe_name, &IpcLogFn, nullptr);\n+            m_loop.emplace(exe_name, &IpcLogFn, &m_context);\n             {\n                 std::unique_lock<std::mutex> lock(m_loop->m_mutex);\n                 m_loop->addClient(lock);\n@@ -80,6 +82,7 @@ class CapnpProtocol : public Protocol\n         });\n         promise.get_future().wait();\n     }\n+    Context m_context;\n     std::thread m_loop_thread;\n     std::optional<mp::EventLoop> m_loop;\n };"
      },
      {
        "sha": "924d7d7450f202de04986fd76ffa207149ee798c",
        "filename": "src/ipc/context.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/ipc/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/ipc/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/context.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_CONTEXT_H\n+#define BITCOIN_IPC_CONTEXT_H\n+\n+namespace ipc {\n+//! Context struct used to give IPC protocol implementations or implementation\n+//! hooks access to application state, in case they need to run extra code that\n+//! isn't needed within a single process, like code copying global state from an\n+//! existing process to a new process when it's initialized, or code dealing\n+//! with shared objects that are created or destroyed remotely.\n+struct Context\n+{\n+};\n+} // namespace ipc\n+\n+#endif // BITCOIN_IPC_CONTEXT_H"
      },
      {
        "sha": "580590fde93e1825d7068f83e9643303e0380bc6",
        "filename": "src/ipc/interfaces.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/ipc/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/ipc/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/interfaces.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -60,6 +60,7 @@ class IpcImpl : public interfaces::Ipc\n     {\n         m_protocol->addCleanup(type, iface, std::move(cleanup));\n     }\n+    Context& context() override { return m_protocol->context(); }\n     const char* m_exe_name;\n     const char* m_process_argv0;\n     interfaces::Init& m_init;"
      },
      {
        "sha": "4cd892e411786c87f65f59ebb3699de70bb09751",
        "filename": "src/ipc/protocol.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/ipc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/ipc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ipc/protocol.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -12,6 +12,8 @@\n #include <typeindex>\n \n namespace ipc {\n+struct Context;\n+\n //! IPC protocol interface for calling IPC methods over sockets.\n //!\n //! There may be different implementations of this interface for different IPC\n@@ -33,6 +35,9 @@ class Protocol\n     //! Add cleanup callback to interface that will run when the interface is\n     //! deleted.\n     virtual void addCleanup(std::type_index type, void* iface, std::function<void()> cleanup) = 0;\n+\n+    //! Context accessor.\n+    virtual Context& context() = 0;\n };\n } // namespace ipc\n "
      },
      {
        "sha": "7bef3d529b5f9e05674f76b7fed48d9d064ffe01",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -274,7 +274,7 @@ bool CKey::SignSchnorr(const uint256& hash, Span<unsigned char> sig, const uint2\n         uint256 tweak = XOnlyPubKey(pubkey_bytes).ComputeTapTweakHash(merkle_root->IsNull() ? nullptr : merkle_root);\n         if (!secp256k1_keypair_xonly_tweak_add(GetVerifyContext(), &keypair, tweak.data())) return false;\n     }\n-    bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, secp256k1_nonce_function_bip340, aux ? (void*)aux->data() : nullptr);\n+    bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, aux ? (unsigned char*)aux->data() : nullptr);\n     memory_cleanse(&keypair, sizeof(keypair));\n     return ret;\n }"
      },
      {
        "sha": "b456108b61c93ebbd4289b90d6644d6aece60c73",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 11,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,6 +8,8 @@\n #include <util/string.h>\n #include <util/time.h>\n \n+#include <algorithm>\n+#include <array>\n #include <mutex>\n \n const char * const DEFAULT_DEBUGLOGFILE = \"debug.log\";\n@@ -124,8 +126,7 @@ bool BCLog::Logger::DefaultShrinkDebugFile() const\n     return m_categories == BCLog::NONE;\n }\n \n-struct CLogCategoryDesc\n-{\n+struct CLogCategoryDesc {\n     BCLog::LogFlags flag;\n     std::string category;\n };\n@@ -179,15 +180,18 @@ bool GetLogCategory(BCLog::LogFlags& flag, const std::string& str)\n \n std::vector<LogCategory> BCLog::Logger::LogCategoriesList() const\n {\n+    // Sort log categories by alphabetical order.\n+    std::array<CLogCategoryDesc, std::size(LogCategories)> categories;\n+    std::copy(std::begin(LogCategories), std::end(LogCategories), categories.begin());\n+    std::sort(categories.begin(), categories.end(), [](auto a, auto b) { return a.category < b.category; });\n+\n     std::vector<LogCategory> ret;\n-    for (const CLogCategoryDesc& category_desc : LogCategories) {\n-        // Omit the special cases.\n-        if (category_desc.flag != BCLog::NONE && category_desc.flag != BCLog::ALL) {\n-            LogCategory catActive;\n-            catActive.category = category_desc.category;\n-            catActive.active = WillLogCategory(category_desc.flag);\n-            ret.push_back(catActive);\n-        }\n+    for (const CLogCategoryDesc& category_desc : categories) {\n+        if (category_desc.flag == BCLog::NONE || category_desc.flag == BCLog::ALL) continue;\n+        LogCategory catActive;\n+        catActive.category = category_desc.category;\n+        catActive.active = WillLogCategory(category_desc.flag);\n+        ret.push_back(catActive);\n     }\n     return ret;\n }\n@@ -237,7 +241,7 @@ namespace BCLog {\n         }\n         return ret;\n     }\n-}\n+} // namespace BCLog\n \n void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& logging_function, const std::string& source_file, const int source_line)\n {"
      },
      {
        "sha": "38d73863e76f565674a51e530b1ddbe71d33a9b3",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -138,9 +138,9 @@ namespace BCLog {\n         bool DisableCategory(const std::string& str);\n \n         bool WillLogCategory(LogFlags category) const;\n-        /** Returns a vector of the log categories */\n+        /** Returns a vector of the log categories in alphabetical order. */\n         std::vector<LogCategory> LogCategoriesList() const;\n-        /** Returns a string with the log categories */\n+        /** Returns a string with the log categories in alphabetical order. */\n         std::string LogCategoriesString() const\n         {\n             return Join(LogCategoriesList(), \", \", [&](const LogCategory& i) { return i.category; });"
      },
      {
        "sha": "8ef770ede22d16ecf6a41b0a8a8394684710e7d4",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 5,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -25,6 +25,7 @@\n #include <util/sock.h>\n #include <util/strencodings.h>\n #include <util/thread.h>\n+#include <util/trace.h>\n #include <util/translation.h>\n \n #ifdef WIN32\n@@ -1212,16 +1213,29 @@ void CConnman::CreateNodeFromAcceptedSocket(SOCKET hSocket,\n \n bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type)\n {\n-    if (conn_type != ConnectionType::OUTBOUND_FULL_RELAY && conn_type != ConnectionType::BLOCK_RELAY) return false;\n-\n-    const int max_connections = conn_type == ConnectionType::OUTBOUND_FULL_RELAY ? m_max_outbound_full_relay : m_max_outbound_block_relay;\n+    std::optional<int> max_connections;\n+    switch (conn_type) {\n+    case ConnectionType::INBOUND:\n+    case ConnectionType::MANUAL:\n+    case ConnectionType::FEELER:\n+        return false;\n+    case ConnectionType::OUTBOUND_FULL_RELAY:\n+        max_connections = m_max_outbound_full_relay;\n+        break;\n+    case ConnectionType::BLOCK_RELAY:\n+        max_connections = m_max_outbound_block_relay;\n+        break;\n+    // no limit for ADDR_FETCH because -seednode has no limit either\n+    case ConnectionType::ADDR_FETCH:\n+        break;\n+    } // no default case, so the compiler can warn about missing cases\n \n     // Count existing connections\n     int existing_connections = WITH_LOCK(cs_vNodes,\n                                          return std::count_if(vNodes.begin(), vNodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););\n \n     // Max connections of specified type already exist\n-    if (existing_connections >= max_connections) return false;\n+    if (max_connections != std::nullopt && existing_connections >= max_connections) return false;\n \n     // Max total outbound connections already exist\n     CSemaphoreGrant grant(*semOutbound, true);\n@@ -3004,11 +3018,20 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.m_type), nMessageSize, pnode->GetId());\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\", msg.m_type, nMessageSize, pnode->GetId());\n     if (gArgs.GetBoolArg(\"-capturemessages\", false)) {\n         CaptureMessage(pnode->addr, msg.m_type, msg.data, /* incoming */ false);\n     }\n \n+    TRACE6(net, outbound_message,\n+        pnode->GetId(),\n+        pnode->GetAddrName().c_str(),\n+        pnode->ConnectionTypeAsString().c_str(),\n+        msg.m_type.c_str(),\n+        msg.data.size(),\n+        msg.data.data()\n+    );\n+\n     // make sure we use the appropriate network transport format\n     std::vector<unsigned char> serializedHeader;\n     pnode->m_serializer->prepareForTransport(msg, serializedHeader);"
      },
      {
        "sha": "889d57b74c54ad04045e998f5bec3ba729689a0a",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -79,9 +79,9 @@ static const int64_t DEFAULT_PEER_CONNECT_TIMEOUT = 60;\n /** Number of file descriptors required for message capture **/\n static const int NUM_FDS_MESSAGE_CAPTURE = 1;\n \n-static const bool DEFAULT_FORCEDNSSEED = false;\n-static const bool DEFAULT_DNSSEED = true;\n-static const bool DEFAULT_FIXEDSEEDS = true;\n+static constexpr bool DEFAULT_FORCEDNSSEED{false};\n+static constexpr bool DEFAULT_DNSSEED{true};\n+static constexpr bool DEFAULT_FIXEDSEEDS{true};\n static const size_t DEFAULT_MAXRECEIVEBUFFER = 5 * 1000;\n static const size_t DEFAULT_MAXSENDBUFFER    = 1 * 1000;\n \n@@ -893,6 +893,7 @@ class CConnman\n      *\n      * @param[in]   address     Address of node to try connecting to\n      * @param[in]   conn_type   ConnectionType::OUTBOUND or ConnectionType::BLOCK_RELAY\n+     *                          or ConnectionType::ADDR_FETCH\n      * @return      bool        Returns false if there are no available\n      *                          slots for this connection:\n      *                          - conn_type not a supported ConnectionType"
      },
      {
        "sha": "bc979e3792c79f4d180d24b60014cfd8983bbc8e",
        "filename": "src/net_permissions.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/net_permissions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/net_permissions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_permissions.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -31,7 +31,8 @@ enum class NetPermissionFlags : uint32_t {\n     NoBan = (1U << 4) | Download,\n     // Can query the mempool\n     Mempool = (1U << 5),\n-    // Can request addrs without hitting a privacy-preserving cache\n+    // Can request addrs without hitting a privacy-preserving cache, and send us\n+    // unlimited amounts of addrs.\n     Addr = (1U << 7),\n \n     // True if the user did not specifically set fine grained permissions"
      },
      {
        "sha": "8243ef0f55cd5cc705df5a8727d54319fe77ff77",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 193,
        "deletions": 74,
        "changes": 267,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -34,6 +34,7 @@\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n #include <util/system.h>\n+#include <util/trace.h>\n #include <validation.h>\n \n #include <algorithm>\n@@ -155,6 +156,13 @@ static constexpr uint32_t MAX_GETCFHEADERS_SIZE = 2000;\n static constexpr size_t MAX_PCT_ADDR_TO_SEND = 23;\n /** The maximum number of address records permitted in an ADDR message. */\n static constexpr size_t MAX_ADDR_TO_SEND{1000};\n+/** The maximum rate of address records we're willing to process on average. Can be bypassed using\n+ *  the NetPermissionFlags::Addr permission. */\n+static constexpr double MAX_ADDR_RATE_PER_SECOND{0.1};\n+/** The soft limit of the address processing token bucket (the regular MAX_ADDR_RATE_PER_SECOND\n+ *  based increments won't go above this, but the MAX_ADDR_TO_SEND increment following GETADDR\n+ *  is exempt from this limit. */\n+static constexpr size_t MAX_ADDR_PROCESSING_TOKEN_BUCKET{MAX_ADDR_TO_SEND};\n \n // Internal stuff\n namespace {\n@@ -217,9 +225,31 @@ struct Peer {\n \n     /** A vector of addresses to send to the peer, limited to MAX_ADDR_TO_SEND. */\n     std::vector<CAddress> m_addrs_to_send;\n-    /** Probabilistic filter of addresses that this peer already knows.\n-     *  Used to avoid relaying addresses to this peer more than once. */\n-    const std::unique_ptr<CRollingBloomFilter> m_addr_known;\n+    /** Probabilistic filter to track recent addr messages relayed with this\n+     *  peer. Used to avoid relaying redundant addresses to this peer.\n+     *\n+     *  We initialize this filter for outbound peers (other than\n+     *  block-relay-only connections) or when an inbound peer sends us an\n+     *  address related message (ADDR, ADDRV2, GETADDR).\n+     *\n+     *  Presence of this filter must correlate with m_addr_relay_enabled.\n+     **/\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known;\n+    /** Whether we are participating in address relay with this connection.\n+     *\n+     *  We set this bool to true for outbound peers (other than\n+     *  block-relay-only connections), or when an inbound peer sends us an\n+     *  address related message (ADDR, ADDRV2, GETADDR).\n+     *\n+     *  We use this bool to decide whether a peer is eligible for gossiping\n+     *  addr messages. This avoids relaying to peers that are unlikely to\n+     *  forward them, effectively blackholing self announcements. Reasons\n+     *  peers might support addr relay on the link include that they connected\n+     *  to us as a block-relay-only peer or they are a light client.\n+     *\n+     *  This field must correlate with whether m_addr_known has been\n+     *  initialized.*/\n+    std::atomic_bool m_addr_relay_enabled{false};\n     /** Whether a getaddr request to this peer is outstanding. */\n     bool m_getaddr_sent{false};\n     /** Guards address sending timers. */\n@@ -233,6 +263,15 @@ struct Peer {\n     std::atomic_bool m_wants_addrv2{false};\n     /** Whether this peer has already sent us a getaddr message. */\n     bool m_getaddr_recvd{false};\n+    /** Number of addr messages that can be processed from this peer. Start at 1 to\n+     *  permit self-announcement. */\n+    double m_addr_token_bucket{1.0};\n+    /** When m_addr_token_bucket was last updated */\n+    std::chrono::microseconds m_addr_token_timestamp{GetTime<std::chrono::microseconds>()};\n+    /** Total number of addresses that were dropped due to rate limiting. */\n+    std::atomic<uint64_t> m_addr_rate_limited{0};\n+    /** Total number of addresses that were processed (excludes rate limited ones). */\n+    std::atomic<uint64_t> m_addr_processed{0};\n \n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n@@ -242,9 +281,8 @@ struct Peer {\n     /** Work queue of items requested by this peer **/\n     std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n \n-    explicit Peer(NodeId id, bool addr_relay)\n+    explicit Peer(NodeId id)\n         : m_id(id)\n-        , m_addr_known{addr_relay ? std::make_unique<CRollingBloomFilter>(5000, 0.001) : nullptr}\n     {}\n };\n \n@@ -254,7 +292,7 @@ class PeerManagerImpl final : public PeerManager\n {\n public:\n     PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n-                    BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                    BanMan* banman, ChainstateManager& chainman,\n                     CTxMemPool& pool, bool ignore_incoming_txs);\n \n     /** Overridden from CValidationInterface. */\n@@ -271,6 +309,7 @@ class PeerManagerImpl final : public PeerManager\n     bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n     /** Implement PeerManager */\n+    void StartScheduledTasks(CScheduler& scheduler) override;\n     void CheckForStaleTipAndEvictPeers() override;\n     bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const override;\n     bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n@@ -380,7 +419,8 @@ class PeerManagerImpl final : public PeerManager\n     /** The height of the best chain */\n     std::atomic<int> m_best_height{-1};\n \n-    int64_t m_stale_tip_check_time; //!< Next time to check for stale tip\n+    /** Next time to check for stale tip */\n+    int64_t m_stale_tip_check_time{0};\n \n     /** Whether this node is running in blocks only mode */\n     const bool m_ignore_incoming_txs;\n@@ -453,16 +493,26 @@ class PeerManagerImpl final : public PeerManager\n      *\n      * Memory used: 1.3 MB\n      */\n-    std::unique_ptr<CRollingBloomFilter> recentRejects GUARDED_BY(cs_main);\n+    CRollingBloomFilter m_recent_rejects GUARDED_BY(::cs_main){120'000, 0.000'001};\n     uint256 hashRecentRejectsChainTip GUARDED_BY(cs_main);\n \n     /*\n      * Filter for transactions that have been recently confirmed.\n      * We use this to avoid requesting transactions that have already been\n      * confirnmed.\n+     *\n+     * Blocks don't typically have more than 4000 transactions, so this should\n+     * be at least six blocks (~1 hr) worth of transactions that we can store,\n+     * inserting both a txid and wtxid for every observed transaction.\n+     * If the number of transactions appearing in a block goes up, or if we are\n+     * seeing getdata requests more than an hour after initial announcement, we\n+     * can increase this number.\n+     * The false positive rate of 1/1M should come out to less than 1\n+     * transaction per day that would be inadvertently ignored (which is the\n+     * same probability that we have in the reject filter).\n      */\n     Mutex m_recent_confirmed_transactions_mutex;\n-    std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n+    CRollingBloomFilter m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex){48'000, 0.000'001};\n \n     /** Have we requested this block from a peer */\n     bool IsBlockRequested(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -596,6 +646,14 @@ class PeerManagerImpl final : public PeerManager\n      * @param[in]   vRecv           The raw message received\n      */\n     void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv);\n+\n+    /** Checks if address relay is permitted with peer. If needed, initializes\n+     * the m_addr_known bloom filter and sets m_addr_relay_enabled to true.\n+     *\n+     *  @return   True if address relay is enabled with peer\n+     *            False if address relay is disallowed\n+     */\n+    bool SetupAddressRelay(const CNode& node, Peer& peer);\n };\n } // namespace\n \n@@ -716,11 +774,6 @@ static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return &it->second;\n }\n \n-static bool RelayAddrsWithPeer(const Peer& peer)\n-{\n-    return peer.m_addr_known != nullptr;\n-}\n-\n /**\n  * Whether the peer supports the address. For example, a peer that does not\n  * implement BIP155 cannot receive Tor v3 addresses because it requires\n@@ -861,7 +914,7 @@ void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid)\n         }\n         m_connman.ForNode(nodeid, [this](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n             AssertLockHeld(::cs_main);\n-            uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n+            uint64_t nCMPCTBLOCKVersion = 2;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n@@ -1101,9 +1154,7 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n     {\n-        // Addr relay is disabled for outbound block-relay-only peers to\n-        // prevent adversaries from inferring these links from addr traffic.\n-        PeerRef peer = std::make_shared<Peer>(nodeid, /* addr_relay = */ !pnode->IsBlockOnlyConn());\n+        PeerRef peer = std::make_shared<Peer>(nodeid);\n         LOCK(m_peer_mutex);\n         m_peer_map.emplace_hint(m_peer_map.end(), nodeid, std::move(peer));\n     }\n@@ -1178,6 +1229,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         assert(m_outbound_peers_with_protect_from_disconnect == 0);\n         assert(m_wtxid_relay_peers == 0);\n         assert(m_txrequest.Size() == 0);\n+        assert(m_orphanage.Size() == 0);\n     }\n     } // cs_main\n     if (node.fSuccessfullyConnected && misbehavior == 0 &&\n@@ -1239,6 +1291,9 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) c\n     }\n \n     stats.m_ping_wait = ping_wait;\n+    stats.m_addr_processed = peer->m_addr_processed.load();\n+    stats.m_addr_rate_limited = peer->m_addr_rate_limited.load();\n+    stats.m_addr_relay_enabled = peer->m_addr_relay_enabled.load();\n \n     return true;\n }\n@@ -1262,14 +1317,20 @@ void PeerManagerImpl::Misbehaving(const NodeId pnode, const int howmuch, const s\n     if (peer == nullptr) return;\n \n     LOCK(peer->m_misbehavior_mutex);\n+    const int score_before{peer->m_misbehavior_score};\n     peer->m_misbehavior_score += howmuch;\n+    const int score_now{peer->m_misbehavior_score};\n+\n     const std::string message_prefixed = message.empty() ? \"\" : (\": \" + message);\n-    if (peer->m_misbehavior_score >= DISCOURAGEMENT_THRESHOLD && peer->m_misbehavior_score - howmuch < DISCOURAGEMENT_THRESHOLD) {\n-        LogPrint(BCLog::NET, \"Misbehaving: peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\\n\", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);\n+    std::string warning;\n+\n+    if (score_now >= DISCOURAGEMENT_THRESHOLD && score_before < DISCOURAGEMENT_THRESHOLD) {\n+        warning = \" DISCOURAGE THRESHOLD EXCEEDED\";\n         peer->m_should_discourage = true;\n-    } else {\n-        LogPrint(BCLog::NET, \"Misbehaving: peer=%d (%d -> %d)%s\\n\", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);\n     }\n+\n+    LogPrint(BCLog::NET, \"Misbehaving: peer=%d (%d -> %d)%s%s\\n\",\n+             pnode, score_before, score_now, warning, message_prefixed);\n }\n \n bool PeerManagerImpl::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n@@ -1359,38 +1420,27 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n }\n \n std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n-                                               BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                                               BanMan* banman, ChainstateManager& chainman,\n                                                CTxMemPool& pool, bool ignore_incoming_txs)\n {\n-    return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, scheduler, chainman, pool, ignore_incoming_txs);\n+    return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, chainman, pool, ignore_incoming_txs);\n }\n \n PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n-                                 BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                                 BanMan* banman, ChainstateManager& chainman,\n                                  CTxMemPool& pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n       m_connman(connman),\n       m_addrman(addrman),\n       m_banman(banman),\n       m_chainman(chainman),\n       m_mempool(pool),\n-      m_stale_tip_check_time(0),\n       m_ignore_incoming_txs(ignore_incoming_txs)\n {\n-    // Initialize global variables that cannot be constructed at startup.\n-    recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n-\n-    // Blocks don't typically have more than 4000 transactions, so this should\n-    // be at least six blocks (~1 hr) worth of transactions that we can store,\n-    // inserting both a txid and wtxid for every observed transaction.\n-    // If the number of transactions appearing in a block goes up, or if we are\n-    // seeing getdata requests more than an hour after initial announcement, we\n-    // can increase this number.\n-    // The false positive rate of 1/1M should come out to less than 1\n-    // transaction per day that would be inadvertently ignored (which is the\n-    // same probability that we have in the reject filter).\n-    m_recent_confirmed_transactions.reset(new CRollingBloomFilter(48000, 0.000001));\n+}\n \n+void PeerManagerImpl::StartScheduledTasks(CScheduler& scheduler)\n+{\n     // Stale tip checking and peer eviction are on two different timers, but we\n     // don't want them to get out of sync due to drift in the scheduler, so we\n     // combine them in one function and schedule at the quicker (peer-eviction)\n@@ -1416,9 +1466,9 @@ void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock\n     {\n         LOCK(m_recent_confirmed_transactions_mutex);\n         for (const auto& ptx : pblock->vtx) {\n-            m_recent_confirmed_transactions->insert(ptx->GetHash());\n+            m_recent_confirmed_transactions.insert(ptx->GetHash());\n             if (ptx->GetHash() != ptx->GetWitnessHash()) {\n-                m_recent_confirmed_transactions->insert(ptx->GetWitnessHash());\n+                m_recent_confirmed_transactions.insert(ptx->GetWitnessHash());\n             }\n         }\n     }\n@@ -1442,7 +1492,7 @@ void PeerManagerImpl::BlockDisconnected(const std::shared_ptr<const CBlock> &blo\n     // presumably the most common case of relaying a confirmed transaction\n     // should be just after a new block containing it is found.\n     LOCK(m_recent_confirmed_transactions_mutex);\n-    m_recent_confirmed_transactions->reset();\n+    m_recent_confirmed_transactions.reset();\n }\n \n // All of the following cache a recent block, and are protected by cs_most_recent_block\n@@ -1582,14 +1632,13 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n \n bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n {\n-    assert(recentRejects);\n     if (m_chainman.ActiveChain().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n         // If the chain tip has changed previously rejected transactions\n         // might be now valid, e.g. due to a nLockTime'd tx becoming valid,\n         // or a double-spend. Reset the rejects filter and give those\n         // txs a second chance.\n         hashRecentRejectsChainTip = m_chainman.ActiveChain().Tip()->GetBlockHash();\n-        recentRejects->reset();\n+        m_recent_rejects.reset();\n     }\n \n     const uint256& hash = gtxid.GetHash();\n@@ -1598,10 +1647,10 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n \n     {\n         LOCK(m_recent_confirmed_transactions_mutex);\n-        if (m_recent_confirmed_transactions->contains(hash)) return true;\n+        if (m_recent_confirmed_transactions.contains(hash)) return true;\n     }\n \n-    return recentRejects->contains(hash) || m_mempool.exists(gtxid);\n+    return m_recent_rejects.contains(hash) || m_mempool.exists(gtxid);\n }\n \n bool PeerManagerImpl::AlreadyHaveBlock(const uint256& block_hash)\n@@ -1663,7 +1712,7 @@ void PeerManagerImpl::RelayAddress(NodeId originator,\n     LOCK(m_peer_mutex);\n \n     for (auto& [id, peer] : m_peer_map) {\n-        if (RelayAddrsWithPeer(*peer) && id != originator && IsAddrCompatible(*peer, addr)) {\n+        if (peer->m_addr_relay_enabled && id != originator && IsAddrCompatible(*peer, addr)) {\n             uint64_t hashKey = CSipHasher(hasher).Write(id).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n@@ -1955,7 +2004,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n \n static uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     uint32_t nFetchFlags = 0;\n-    if ((pfrom.GetLocalServices() & NODE_WITNESS) && State(pfrom.GetId())->fHaveWitness) {\n+    if (State(pfrom.GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n     }\n     return nFetchFlags;\n@@ -2220,8 +2269,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n                 // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n                 // for concerns around weakening security of unupgraded nodes\n                 // if we start doing this too early.\n-                assert(recentRejects);\n-                recentRejects->insert(porphanTx->GetWitnessHash());\n+                m_recent_rejects.insert(porphanTx->GetWitnessHash());\n                 // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n                 // then we know that the witness was irrelevant to the policy\n                 // failure, since this check depends only on the txid\n@@ -2233,7 +2281,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n                 if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && porphanTx->GetWitnessHash() != porphanTx->GetHash()) {\n                     // We only add the txid if it differs from the wtxid, to\n                     // avoid wasting entries in the rolling bloom filter.\n-                    recentRejects->insert(porphanTx->GetHash());\n+                    m_recent_rejects.insert(porphanTx->GetHash());\n                 }\n             }\n             m_orphanage.EraseTx(orphanHash);\n@@ -2554,7 +2602,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         UpdatePreferredDownload(pfrom, State(pfrom.GetId()));\n         }\n \n-        if (!pfrom.IsInboundConn() && !pfrom.IsBlockOnlyConn()) {\n+        // Self advertisement & GETADDR logic\n+        if (!pfrom.IsInboundConn() && SetupAddressRelay(pfrom, *peer)) {\n             // For outbound peers, we try to relay our address (so that other\n             // nodes can try to find us more quickly, as we have no guarantee\n             // that an outbound peer is even aware of how to reach us) and do a\n@@ -2563,8 +2612,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // empty and no one will know who we are, so these mechanisms are\n             // important to help us connect to the network.\n             //\n-            // We skip this for block-relay-only peers to avoid potentially leaking\n-            // information about our block-relay-only connections via address relay.\n+            // We skip this for block-relay-only peers. We want to avoid\n+            // potentially leaking addr information and we do not want to\n+            // indicate to the peer that we will participate in addr relay.\n             if (fListen && !m_chainman.ActiveChainstate().IsInitialBlockDownload())\n             {\n                 CAddress addr = GetLocalAddress(&pfrom.addr, pfrom.GetLocalServices());\n@@ -2583,6 +2633,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // Get recent addresses\n             m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::GETADDR));\n             peer->m_getaddr_sent = true;\n+            // When requesting a getaddr, accept an additional MAX_ADDR_TO_SEND addresses in response\n+            // (bypassing the MAX_ADDR_PROCESSING_TOKEN_BUCKET limit).\n+            peer->m_addr_token_bucket += MAX_ADDR_TO_SEND;\n         }\n \n         if (!pfrom.IsInboundConn()) {\n@@ -2667,8 +2720,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // they may wish to request compact blocks from us\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n-            if (pfrom.GetLocalServices() & NODE_WITNESS)\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n             m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n@@ -2686,7 +2738,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         bool fAnnounceUsingCMPCTBLOCK = false;\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n-        if (nCMPCTBLOCKVersion == 1 || ((pfrom.GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n+        if (nCMPCTBLOCKVersion == 1 || nCMPCTBLOCKVersion == 2) {\n             LOCK(cs_main);\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n             if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n@@ -2700,10 +2752,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n             }\n             if (!State(pfrom.GetId())->fSupportsDesiredCmpctVersion) {\n-                if (pfrom.GetLocalServices() & NODE_WITNESS)\n-                    State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n-                else\n-                    State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n+                State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n             }\n         }\n         return;\n@@ -2763,10 +2812,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         s >> vAddr;\n \n-        if (!RelayAddrsWithPeer(*peer)) {\n+        if (!SetupAddressRelay(pfrom, *peer)) {\n             LogPrint(BCLog::NET, \"ignoring %s message from %s peer=%d\\n\", msg_type, pfrom.ConnectionTypeAsString(), pfrom.GetId());\n             return;\n         }\n+\n         if (vAddr.size() > MAX_ADDR_TO_SEND)\n         {\n             Misbehaving(pfrom.GetId(), 20, strprintf(\"%s message size = %u\", msg_type, vAddr.size()));\n@@ -2777,11 +2827,34 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         std::vector<CAddress> vAddrOk;\n         int64_t nNow = GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n+\n+        // Update/increment addr rate limiting bucket.\n+        const auto current_time = GetTime<std::chrono::microseconds>();\n+        if (peer->m_addr_token_bucket < MAX_ADDR_PROCESSING_TOKEN_BUCKET) {\n+            // Don't increment bucket if it's already full\n+            const auto time_diff = std::max(current_time - peer->m_addr_token_timestamp, 0us);\n+            const double increment = CountSecondsDouble(time_diff) * MAX_ADDR_RATE_PER_SECOND;\n+            peer->m_addr_token_bucket = std::min<double>(peer->m_addr_token_bucket + increment, MAX_ADDR_PROCESSING_TOKEN_BUCKET);\n+        }\n+        peer->m_addr_token_timestamp = current_time;\n+\n+        const bool rate_limited = !pfrom.HasPermission(NetPermissionFlags::Addr);\n+        uint64_t num_proc = 0;\n+        uint64_t num_rate_limit = 0;\n+        Shuffle(vAddr.begin(), vAddr.end(), FastRandomContext());\n         for (CAddress& addr : vAddr)\n         {\n             if (interruptMsgProc)\n                 return;\n \n+            // Apply rate limiting.\n+            if (rate_limited) {\n+                if (peer->m_addr_token_bucket < 1.0) {\n+                    ++num_rate_limit;\n+                    continue;\n+                }\n+                peer->m_addr_token_bucket -= 1.0;\n+            }\n             // We only bother storing full nodes, though this may include\n             // things which we would not make an outbound connection to, in\n             // part because we may make feeler connections to them.\n@@ -2795,6 +2868,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // Do not process banned/discouraged addresses beyond remembering we received them\n                 continue;\n             }\n+            ++num_proc;\n             bool fReachable = IsReachable(addr);\n             if (addr.nTime > nSince && !peer->m_getaddr_sent && vAddr.size() <= 10 && addr.IsRoutable()) {\n                 // Relay to a limited number of other nodes\n@@ -2804,9 +2878,20 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n+        peer->m_addr_processed += num_proc;\n+        peer->m_addr_rate_limited += num_rate_limit;\n+        LogPrint(BCLog::NET, \"Received addr: %u addresses (%u processed, %u rate-limited) from peer=%d%s\\n\",\n+                 vAddr.size(),\n+                 num_proc,\n+                 num_rate_limit,\n+                 pfrom.GetId(),\n+                 fLogIPs ? \", peeraddr=\" + pfrom.addr.ToString() : \"\");\n+\n         m_addrman.Add(vAddrOk, pfrom.addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000) peer->m_getaddr_sent = false;\n-        if (pfrom.IsAddrFetchConn()) {\n+\n+        // AddrFetch: Require multiple addresses to avoid disconnecting on self-announcements\n+        if (pfrom.IsAddrFetchConn() && vAddr.size() > 1) {\n             LogPrint(BCLog::NET, \"addrfetch connection completed peer=%d; disconnecting\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n         }\n@@ -3200,7 +3285,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             std::sort(unique_parents.begin(), unique_parents.end());\n             unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n             for (const uint256& parent_txid : unique_parents) {\n-                if (recentRejects->contains(parent_txid)) {\n+                if (m_recent_rejects.contains(parent_txid)) {\n                     fRejectedParents = true;\n                     break;\n                 }\n@@ -3241,8 +3326,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // regardless of what witness is provided, we will not accept\n                 // this, so we don't need to allow for redownload of this txid\n                 // from any of our non-wtxidrelay peers.\n-                recentRejects->insert(tx.GetHash());\n-                recentRejects->insert(tx.GetWitnessHash());\n+                m_recent_rejects.insert(tx.GetHash());\n+                m_recent_rejects.insert(tx.GetWitnessHash());\n                 m_txrequest.ForgetTxHash(tx.GetHash());\n                 m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n             }\n@@ -3261,8 +3346,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n                 // for concerns around weakening security of unupgraded nodes\n                 // if we start doing this too early.\n-                assert(recentRejects);\n-                recentRejects->insert(tx.GetWitnessHash());\n+                m_recent_rejects.insert(tx.GetWitnessHash());\n                 m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n                 // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n                 // then we know that the witness was irrelevant to the policy\n@@ -3273,7 +3357,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // transactions are later received (resulting in\n                 // parent-fetching by txid via the orphan-handling logic).\n                 if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && tx.GetWitnessHash() != tx.GetHash()) {\n-                    recentRejects->insert(tx.GetHash());\n+                    m_recent_rejects.insert(tx.GetHash());\n                     m_txrequest.ForgetTxHash(tx.GetHash());\n                 }\n                 if (RecursiveDynamicUsage(*ptx) < 100000) {\n@@ -3282,21 +3366,21 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n         }\n \n-        // If a tx has been detected by recentRejects, we will have reached\n+        // If a tx has been detected by m_recent_rejects, we will have reached\n         // this point and the tx will have been ignored. Because we haven't run\n         // the tx through AcceptToMemoryPool, we won't have computed a DoS\n         // score for it or determined exactly why we consider it invalid.\n         //\n         // This means we won't penalize any peer subsequently relaying a DoSy\n         // tx (even if we penalized the first peer who gave it to us) because\n-        // we have to account for recentRejects showing false positives. In\n+        // we have to account for m_recent_rejects showing false positives. In\n         // other words, we shouldn't penalize a peer if we aren't *sure* they\n         // submitted a DoSy tx.\n         //\n-        // Note that recentRejects doesn't just record DoSy or invalid\n+        // Note that m_recent_rejects doesn't just record DoSy or invalid\n         // transactions, but any tx not accepted by the mempool, which may be\n         // due to node policy (vs. consensus). So we can't blanket penalize a\n-        // peer simply for relaying a tx that our recentRejects has caught,\n+        // peer simply for relaying a tx that our m_recent_rejects has caught,\n         // regardless of false positives.\n \n         if (state.IsInvalid()) {\n@@ -3665,6 +3749,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n+        // Since this must be an inbound connection, SetupAddressRelay will\n+        // never fail.\n+        Assume(SetupAddressRelay(pfrom, *peer));\n+\n         // Only send one GetAddr response per connection to reduce resource waste\n         // and discourage addr stamping of INV announcements.\n         if (peer->m_getaddr_recvd) {\n@@ -3994,6 +4082,15 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n     }\n     CNetMessage& msg(msgs.front());\n \n+    TRACE6(net, inbound_message,\n+        pfrom->GetId(),\n+        pfrom->GetAddrName().c_str(),\n+        pfrom->ConnectionTypeAsString().c_str(),\n+        msg.m_command.c_str(),\n+        msg.m_recv.size(),\n+        msg.m_recv.data()\n+    );\n+\n     if (gArgs.GetBoolArg(\"-capturemessages\", false)) {\n         CaptureMessage(pfrom->addr, msg.m_command, MakeUCharSpan(msg.m_recv), /* incoming */ true);\n     }\n@@ -4243,7 +4340,7 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer, std::chrono::mic\n void PeerManagerImpl::MaybeSendAddr(CNode& node, Peer& peer, std::chrono::microseconds current_time)\n {\n     // Nothing to do for non-address-relay peers\n-    if (!RelayAddrsWithPeer(peer)) return;\n+    if (!peer.m_addr_relay_enabled) return;\n \n     LOCK(peer.m_addr_send_times_mutex);\n     // Periodically advertise our local address to the peer.\n@@ -4371,6 +4468,22 @@ class CompareInvMempoolOrder\n };\n }\n \n+bool PeerManagerImpl::SetupAddressRelay(const CNode& node, Peer& peer)\n+{\n+    // We don't participate in addr relay with outbound block-relay-only\n+    // connections to prevent providing adversaries with the additional\n+    // information of addr traffic to infer the link.\n+    if (node.IsBlockOnlyConn()) return false;\n+\n+    if (!peer.m_addr_relay_enabled.exchange(true)) {\n+        // First addr message we have received from the peer, initialize\n+        // m_addr_known\n+        peer.m_addr_known = std::make_unique<CRollingBloomFilter>(5000, 0.001);\n+    }\n+\n+    return true;\n+}\n+\n bool PeerManagerImpl::SendMessages(CNode* pto)\n {\n     PeerRef peer = GetPeerRef(pto->GetId());\n@@ -4390,6 +4503,12 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n     const auto current_time = GetTime<std::chrono::microseconds>();\n \n+    if (pto->IsAddrFetchConn() && current_time - std::chrono::seconds(pto->nTimeConnected) > 10 * AVG_ADDRESS_BROADCAST_INTERVAL) {\n+        LogPrint(BCLog::NET, \"addrfetch connection timeout; disconnecting peer=%d\\n\", pto->GetId());\n+        pto->fDisconnect = true;\n+        return true;\n+    }\n+\n     MaybeSendPing(*pto, *peer, current_time);\n \n     // MaybeSendPing may have marked peer for disconnection"
      },
      {
        "sha": "9d8d78858371aa06697eebf1710f83ad406ec46a",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -29,16 +29,22 @@ struct CNodeStateStats {\n     int m_starting_height = -1;\n     std::chrono::microseconds m_ping_wait;\n     std::vector<int> vHeightInFlight;\n+    uint64_t m_addr_processed = 0;\n+    uint64_t m_addr_rate_limited = 0;\n+    bool m_addr_relay_enabled{false};\n };\n \n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:\n     static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n-                                             BanMan* banman, CScheduler& scheduler, ChainstateManager& chainman,\n+                                             BanMan* banman, ChainstateManager& chainman,\n                                              CTxMemPool& pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }\n \n+    /** Begin running background tasks, should only be called once */\n+    virtual void StartScheduledTasks(CScheduler& scheduler) = 0;\n+\n     /** Get statistics from node state */\n     virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) const = 0;\n "
      },
      {
        "sha": "eb35ed3fac722d135388b6a3a61db94f2d4b0ba3",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 404,
        "deletions": 425,
        "changes": 829,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -42,8 +42,7 @@ static constexpr int ADDRV2_FORMAT = 0x20000000;\n  * over all enum values and also `GetExtNetwork()` \"extends\" this enum by\n  * introducing standalone constants starting from `NET_MAX`.\n  */\n-enum Network\n-{\n+enum Network {\n     /// Addresses from these networks are not publicly routable on the global Internet.\n     NET_UNROUTABLE = 0,\n \n@@ -73,16 +72,14 @@ enum Network\n /// Prefix of an IPv6 address when it contains an embedded IPv4 address.\n /// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n static const std::array<uint8_t, 12> IPV4_IN_IPV6_PREFIX{\n-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF\n-};\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF};\n \n /// Prefix of an IPv6 address when it contains an embedded TORv2 address.\n /// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n /// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they\n /// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\n static const std::array<uint8_t, 6> TORV2_IN_IPV6_PREFIX{\n-    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43\n-};\n+    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43};\n \n /// Prefix of an IPv6 address when it contains an embedded \"internal\" address.\n /// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n@@ -120,354 +117,354 @@ static constexpr uint16_t I2P_SAM31_PORT{0};\n  */\n class CNetAddr\n {\n-    protected:\n-        /**\n-         * Raw representation of the network address.\n-         * In network byte order (big endian) for IPv4 and IPv6.\n-         */\n-        prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n-\n-        /**\n-         * Network to which this address belongs.\n-         */\n-        Network m_net{NET_IPV6};\n-\n-        /**\n-         * Scope id if scoped/link-local IPV6 address.\n-         * See https://tools.ietf.org/html/rfc4007\n-         */\n-        uint32_t m_scope_id{0};\n-\n-    public:\n-        CNetAddr();\n-        explicit CNetAddr(const struct in_addr& ipv4Addr);\n-        void SetIP(const CNetAddr& ip);\n-\n-        /**\n-         * Set from a legacy IPv6 address.\n-         * Legacy IPv6 address may be a normal IPv6 address, or another address\n-         * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n-         * `addr` encoding.\n-         */\n-        void SetLegacyIPv6(Span<const uint8_t> ipv6);\n-\n-        bool SetInternal(const std::string& name);\n-\n-        /**\n-         * Parse a Tor or I2P address and set this object to it.\n-         * @param[in] addr Address to parse, for example\n-         * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or\n-         * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n-         */\n-        bool SetSpecial(const std::string& addr);\n-\n-        bool IsBindAny() const; // INADDR_ANY equivalent\n-        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n-        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n-        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n-        bool IsRFC2544() const; // IPv4 inter-network communications (198.18.0.0/15)\n-        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n-        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n-        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n-        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n-        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n-        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n-        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n-        bool IsRFC4843() const; // IPv6 ORCHID (deprecated) (2001:10::/28)\n-        bool IsRFC7343() const; // IPv6 ORCHIDv2 (2001:20::/28)\n-        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n-        bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n-        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n-        bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n-        bool IsTor() const;\n-        bool IsI2P() const;\n-        bool IsCJDNS() const;\n-        bool IsLocal() const;\n-        bool IsRoutable() const;\n-        bool IsInternal() const;\n-        bool IsValid() const;\n-\n-        /**\n-         * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n-         */\n-        bool IsAddrV1Compatible() const;\n-\n-        enum Network GetNetwork() const;\n-        std::string ToString() const;\n-        std::string ToStringIP() const;\n-        uint64_t GetHash() const;\n-        bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        Network GetNetClass() const;\n-\n-        //! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32.\n-        uint32_t GetLinkedIPv4() const;\n-        //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n-        bool HasLinkedIPv4() const;\n-\n-        // The AS on the BGP path to the node we use to diversify\n-        // peers in AddrMan bucketing based on the AS infrastructure.\n-        // The ip->AS mapping depends on how asmap is constructed.\n-        uint32_t GetMappedAS(const std::vector<bool> &asmap) const;\n-\n-        std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n-        std::vector<unsigned char> GetAddrBytes() const;\n-        int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n-\n-        explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n-        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n-\n-        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n-        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n-\n-        /**\n-         * Whether this address should be relayed to other peers even if we can't reach it ourselves.\n-         */\n-        bool IsRelayable() const\n-        {\n-            return IsIPv4() || IsIPv6() || IsTor() || IsI2P();\n-        }\n+protected:\n+    /**\n+     * Raw representation of the network address.\n+     * In network byte order (big endian) for IPv4 and IPv6.\n+     */\n+    prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n+\n+    /**\n+     * Network to which this address belongs.\n+     */\n+    Network m_net{NET_IPV6};\n+\n+    /**\n+     * Scope id if scoped/link-local IPV6 address.\n+     * See https://tools.ietf.org/html/rfc4007\n+     */\n+    uint32_t m_scope_id{0};\n \n-        /**\n-         * Serialize to a stream.\n-         */\n-        template <typename Stream>\n-        void Serialize(Stream& s) const\n-        {\n-            if (s.GetVersion() & ADDRV2_FORMAT) {\n-                SerializeV2Stream(s);\n-            } else {\n-                SerializeV1Stream(s);\n-            }\n-        }\n+public:\n+    CNetAddr();\n+    explicit CNetAddr(const struct in_addr& ipv4Addr);\n+    void SetIP(const CNetAddr& ip);\n+\n+    /**\n+     * Set from a legacy IPv6 address.\n+     * Legacy IPv6 address may be a normal IPv6 address, or another address\n+     * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n+     * `addr` encoding.\n+     */\n+    void SetLegacyIPv6(Span<const uint8_t> ipv6);\n+\n+    bool SetInternal(const std::string& name);\n+\n+    /**\n+     * Parse a Tor or I2P address and set this object to it.\n+     * @param[in] addr Address to parse, for example\n+     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or\n+     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n+     */\n+    bool SetSpecial(const std::string& addr);\n+\n+    bool IsBindAny() const; // INADDR_ANY equivalent\n+    bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n+    bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n+    bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n+    bool IsRFC2544() const; // IPv4 inter-network communications (198.18.0.0/15)\n+    bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n+    bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n+    bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n+    bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n+    bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n+    bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n+    bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n+    bool IsRFC4843() const; // IPv6 ORCHID (deprecated) (2001:10::/28)\n+    bool IsRFC7343() const; // IPv6 ORCHIDv2 (2001:20::/28)\n+    bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n+    bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n+    bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n+    bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n+    bool IsTor() const;\n+    bool IsI2P() const;\n+    bool IsCJDNS() const;\n+    bool IsLocal() const;\n+    bool IsRoutable() const;\n+    bool IsInternal() const;\n+    bool IsValid() const;\n+\n+    /**\n+     * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n+     */\n+    bool IsAddrV1Compatible() const;\n+\n+    enum Network GetNetwork() const;\n+    std::string ToString() const;\n+    std::string ToStringIP() const;\n+    uint64_t GetHash() const;\n+    bool GetInAddr(struct in_addr* pipv4Addr) const;\n+    Network GetNetClass() const;\n+\n+    //! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32.\n+    uint32_t GetLinkedIPv4() const;\n+    //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n+    bool HasLinkedIPv4() const;\n+\n+    // The AS on the BGP path to the node we use to diversify\n+    // peers in AddrMan bucketing based on the AS infrastructure.\n+    // The ip->AS mapping depends on how asmap is constructed.\n+    uint32_t GetMappedAS(const std::vector<bool>& asmap) const;\n+\n+    std::vector<unsigned char> GetGroup(const std::vector<bool>& asmap) const;\n+    std::vector<unsigned char> GetAddrBytes() const;\n+    int GetReachabilityFrom(const CNetAddr* paddrPartner = nullptr) const;\n+\n+    explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n+    bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n+\n+    friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n+    friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n+    friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n+\n+    /**\n+     * Whether this address should be relayed to other peers even if we can't reach it ourselves.\n+     */\n+    bool IsRelayable() const\n+    {\n+        return IsIPv4() || IsIPv6() || IsTor() || IsI2P();\n+    }\n \n-        /**\n-         * Unserialize from a stream.\n-         */\n-        template <typename Stream>\n-        void Unserialize(Stream& s)\n-        {\n-            if (s.GetVersion() & ADDRV2_FORMAT) {\n-                UnserializeV2Stream(s);\n-            } else {\n-                UnserializeV1Stream(s);\n-            }\n+    /**\n+     * Serialize to a stream.\n+     */\n+    template <typename Stream>\n+    void Serialize(Stream& s) const\n+    {\n+        if (s.GetVersion() & ADDRV2_FORMAT) {\n+            SerializeV2Stream(s);\n+        } else {\n+            SerializeV1Stream(s);\n         }\n+    }\n \n-        friend class CNetAddrHash;\n-        friend class CSubNet;\n-\n-    private:\n-        /**\n-         * Parse a Tor address and set this object to it.\n-         * @param[in] addr Address to parse, must be a valid C string, for example\n-         * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsTor()\n-         */\n-        bool SetTor(const std::string& addr);\n-\n-        /**\n-         * Parse an I2P address and set this object to it.\n-         * @param[in] addr Address to parse, must be a valid C string, for example\n-         * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsI2P()\n-         */\n-        bool SetI2P(const std::string& addr);\n-\n-        /**\n-         * BIP155 network ids recognized by this software.\n-         */\n-        enum BIP155Network : uint8_t {\n-            IPV4 = 1,\n-            IPV6 = 2,\n-            TORV2 = 3,\n-            TORV3 = 4,\n-            I2P = 5,\n-            CJDNS = 6,\n-        };\n-\n-        /**\n-         * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n-         */\n-        static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n-\n-        /**\n-         * Maximum size of an address as defined in BIP155 (in bytes).\n-         * This is only the size of the address, not the entire CNetAddr object\n-         * when serialized.\n-         */\n-        static constexpr size_t MAX_ADDRV2_SIZE = 512;\n-\n-        /**\n-         * Get the BIP155 network id of this address.\n-         * Must not be called for IsInternal() objects.\n-         * @returns BIP155 network id, except TORV2 which is no longer supported.\n-         */\n-        BIP155Network GetBIP155Network() const;\n-\n-        /**\n-         * Set `m_net` from the provided BIP155 network id and size after validation.\n-         * @retval true the network was recognized, is valid and `m_net` was set\n-         * @retval false not recognised (from future?) and should be silently ignored\n-         * @throws std::ios_base::failure if the network is one of the BIP155 founding\n-         * networks (id 1..6) with wrong address size.\n-         */\n-        bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n-\n-        /**\n-         * Serialize in pre-ADDRv2/BIP155 format to an array.\n-         */\n-        void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n-        {\n-            size_t prefix_size;\n-\n-            switch (m_net) {\n-            case NET_IPV6:\n-                assert(m_addr.size() == sizeof(arr));\n-                memcpy(arr, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_IPV4:\n-                prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n-                assert(prefix_size + m_addr.size() == sizeof(arr));\n-                memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n-                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_INTERNAL:\n-                prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n-                assert(prefix_size + m_addr.size() == sizeof(arr));\n-                memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n-                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_ONION:\n-            case NET_I2P:\n-            case NET_CJDNS:\n-                break;\n-            case NET_UNROUTABLE:\n-            case NET_MAX:\n-                assert(false);\n-            } // no default case, so the compiler can warn about missing cases\n-\n-            // Serialize ONION, I2P and CJDNS as all-zeros.\n-            memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n+    /**\n+     * Unserialize from a stream.\n+     */\n+    template <typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        if (s.GetVersion() & ADDRV2_FORMAT) {\n+            UnserializeV2Stream(s);\n+        } else {\n+            UnserializeV1Stream(s);\n         }\n+    }\n \n-        /**\n-         * Serialize in pre-ADDRv2/BIP155 format to a stream.\n-         */\n-        template <typename Stream>\n-        void SerializeV1Stream(Stream& s) const\n-        {\n-            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+    friend class CNetAddrHash;\n+    friend class CSubNet;\n \n-            SerializeV1Array(serialized);\n+private:\n+    /**\n+     * Parse a Tor address and set this object to it.\n+     * @param[in] addr Address to parse, must be a valid C string, for example\n+     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsTor()\n+     */\n+    bool SetTor(const std::string& addr);\n+\n+    /**\n+     * Parse an I2P address and set this object to it.\n+     * @param[in] addr Address to parse, must be a valid C string, for example\n+     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsI2P()\n+     */\n+    bool SetI2P(const std::string& addr);\n+\n+    /**\n+     * BIP155 network ids recognized by this software.\n+     */\n+    enum BIP155Network : uint8_t {\n+        IPV4 = 1,\n+        IPV6 = 2,\n+        TORV2 = 3,\n+        TORV3 = 4,\n+        I2P = 5,\n+        CJDNS = 6,\n+    };\n+\n+    /**\n+     * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n+     */\n+    static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n+\n+    /**\n+     * Maximum size of an address as defined in BIP155 (in bytes).\n+     * This is only the size of the address, not the entire CNetAddr object\n+     * when serialized.\n+     */\n+    static constexpr size_t MAX_ADDRV2_SIZE = 512;\n+\n+    /**\n+     * Get the BIP155 network id of this address.\n+     * Must not be called for IsInternal() objects.\n+     * @returns BIP155 network id, except TORV2 which is no longer supported.\n+     */\n+    BIP155Network GetBIP155Network() const;\n+\n+    /**\n+     * Set `m_net` from the provided BIP155 network id and size after validation.\n+     * @retval true the network was recognized, is valid and `m_net` was set\n+     * @retval false not recognised (from future?) and should be silently ignored\n+     * @throws std::ios_base::failure if the network is one of the BIP155 founding\n+     * networks (id 1..6) with wrong address size.\n+     */\n+    bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n+\n+    /**\n+     * Serialize in pre-ADDRv2/BIP155 format to an array.\n+     */\n+    void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n+    {\n+        size_t prefix_size;\n+\n+        switch (m_net) {\n+        case NET_IPV6:\n+            assert(m_addr.size() == sizeof(arr));\n+            memcpy(arr, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_IPV4:\n+            prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n+            assert(prefix_size + m_addr.size() == sizeof(arr));\n+            memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n+            memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_INTERNAL:\n+            prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n+            assert(prefix_size + m_addr.size() == sizeof(arr));\n+            memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n+            memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_ONION:\n+        case NET_I2P:\n+        case NET_CJDNS:\n+            break;\n+        case NET_UNROUTABLE:\n+        case NET_MAX:\n+            assert(false);\n+        } // no default case, so the compiler can warn about missing cases\n+\n+        // Serialize ONION, I2P and CJDNS as all-zeros.\n+        memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n+    }\n \n-            s << serialized;\n-        }\n+    /**\n+     * Serialize in pre-ADDRv2/BIP155 format to a stream.\n+     */\n+    template <typename Stream>\n+    void SerializeV1Stream(Stream& s) const\n+    {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n \n-        /**\n-         * Serialize as ADDRv2 / BIP155.\n-         */\n-        template <typename Stream>\n-        void SerializeV2Stream(Stream& s) const\n-        {\n-            if (IsInternal()) {\n-                // Serialize NET_INTERNAL as embedded in IPv6. We need to\n-                // serialize such addresses from addrman.\n-                s << static_cast<uint8_t>(BIP155Network::IPV6);\n-                s << COMPACTSIZE(ADDR_IPV6_SIZE);\n-                SerializeV1Stream(s);\n-                return;\n-            }\n+        SerializeV1Array(serialized);\n \n-            s << static_cast<uint8_t>(GetBIP155Network());\n-            s << m_addr;\n-        }\n+        s << serialized;\n+    }\n \n-        /**\n-         * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n-         */\n-        void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n-        {\n-            // Use SetLegacyIPv6() so that m_net is set correctly. For example\n-            // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n-            SetLegacyIPv6(arr);\n+    /**\n+     * Serialize as ADDRv2 / BIP155.\n+     */\n+    template <typename Stream>\n+    void SerializeV2Stream(Stream& s) const\n+    {\n+        if (IsInternal()) {\n+            // Serialize NET_INTERNAL as embedded in IPv6. We need to\n+            // serialize such addresses from addrman.\n+            s << static_cast<uint8_t>(BIP155Network::IPV6);\n+            s << COMPACTSIZE(ADDR_IPV6_SIZE);\n+            SerializeV1Stream(s);\n+            return;\n         }\n \n-        /**\n-         * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n-         */\n-        template <typename Stream>\n-        void UnserializeV1Stream(Stream& s)\n-        {\n-            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+        s << static_cast<uint8_t>(GetBIP155Network());\n+        s << m_addr;\n+    }\n+\n+    /**\n+     * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n+     */\n+    void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n+    {\n+        // Use SetLegacyIPv6() so that m_net is set correctly. For example\n+        // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n+        SetLegacyIPv6(arr);\n+    }\n+\n+    /**\n+     * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n+     */\n+    template <typename Stream>\n+    void UnserializeV1Stream(Stream& s)\n+    {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n \n-            s >> serialized;\n+        s >> serialized;\n+\n+        UnserializeV1Array(serialized);\n+    }\n+\n+    /**\n+     * Unserialize from a ADDRv2 / BIP155 format.\n+     */\n+    template <typename Stream>\n+    void UnserializeV2Stream(Stream& s)\n+    {\n+        uint8_t bip155_net;\n+        s >> bip155_net;\n \n-            UnserializeV1Array(serialized);\n+        size_t address_size;\n+        s >> COMPACTSIZE(address_size);\n+\n+        if (address_size > MAX_ADDRV2_SIZE) {\n+            throw std::ios_base::failure(strprintf(\n+                \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n         }\n \n-        /**\n-         * Unserialize from a ADDRv2 / BIP155 format.\n-         */\n-        template <typename Stream>\n-        void UnserializeV2Stream(Stream& s)\n-        {\n-            uint8_t bip155_net;\n-            s >> bip155_net;\n-\n-            size_t address_size;\n-            s >> COMPACTSIZE(address_size);\n-\n-            if (address_size > MAX_ADDRV2_SIZE) {\n-                throw std::ios_base::failure(strprintf(\n-                    \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n+        m_scope_id = 0;\n+\n+        if (SetNetFromBIP155Network(bip155_net, address_size)) {\n+            m_addr.resize(address_size);\n+            s >> MakeSpan(m_addr);\n+\n+            if (m_net != NET_IPV6) {\n+                return;\n             }\n \n-            m_scope_id = 0;\n-\n-            if (SetNetFromBIP155Network(bip155_net, address_size)) {\n-                m_addr.resize(address_size);\n-                s >> MakeSpan(m_addr);\n-\n-                if (m_net != NET_IPV6) {\n-                    return;\n-                }\n-\n-                // Do some special checks on IPv6 addresses.\n-\n-                // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n-                // gossiped but could be coming from addrman, when unserializing from\n-                // disk.\n-                if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n-                    m_net = NET_INTERNAL;\n-                    memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n-                            ADDR_INTERNAL_SIZE);\n-                    m_addr.resize(ADDR_INTERNAL_SIZE);\n-                    return;\n-                }\n-\n-                if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n-                    !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n-                    return;\n-                }\n-\n-                // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n-                // encoding). Unserialize as !IsValid(), thus ignoring them.\n-            } else {\n-                // If we receive an unknown BIP155 network id (from the future?) then\n-                // ignore the address - unserialize as !IsValid().\n-                s.ignore(address_size);\n+            // Do some special checks on IPv6 addresses.\n+\n+            // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n+            // gossiped but could be coming from addrman, when unserializing from\n+            // disk.\n+            if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n+                m_net = NET_INTERNAL;\n+                memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n+                        ADDR_INTERNAL_SIZE);\n+                m_addr.resize(ADDR_INTERNAL_SIZE);\n+                return;\n             }\n \n-            // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n-            // will not be gossiped, but continue reading next addresses from the stream.\n-            m_net = NET_IPV6;\n-            m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+            if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n+                !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n+                return;\n+            }\n+\n+            // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n+            // encoding). Unserialize as !IsValid(), thus ignoring them.\n+        } else {\n+            // If we receive an unknown BIP155 network id (from the future?) then\n+            // ignore the address - unserialize as !IsValid().\n+            s.ignore(address_size);\n         }\n+\n+        // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n+        // will not be gossiped, but continue reading next addresses from the stream.\n+        m_net = NET_IPV6;\n+        m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+    }\n };\n \n class CNetAddrHash\n@@ -488,104 +485,86 @@ class CNetAddrHash\n \n class CSubNet\n {\n-    protected:\n-        /// Network (base) address\n-        CNetAddr network;\n-        /// Netmask, in network byte order\n-        uint8_t netmask[16];\n-        /// Is this value valid? (only used to signal parse errors)\n-        bool valid;\n-\n-        bool SanityCheck() const;\n-\n-    public:\n-        /**\n-         * Construct an invalid subnet (empty, `Match()` always returns false).\n-         */\n-        CSubNet();\n-\n-        /**\n-         * Construct from a given network start and number of bits (CIDR mask).\n-         * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n-         * created.\n-         * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for\n-         * IPv6 addresses. Otherwise an invalid subnet is created.\n-         */\n-        CSubNet(const CNetAddr& addr, uint8_t mask);\n-\n-        /**\n-         * Construct from a given network start and mask.\n-         * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n-         * created.\n-         * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits\n-         * followed by 1-bits. Otherwise an invalid subnet is created.\n-         */\n-        CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n-\n-        /**\n-         * Construct a single-host subnet.\n-         * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].\n-         */\n-        explicit CSubNet(const CNetAddr& addr);\n-\n-        bool Match(const CNetAddr &addr) const;\n-\n-        std::string ToString() const;\n-        bool IsValid() const;\n-\n-        friend bool operator==(const CSubNet& a, const CSubNet& b);\n-        friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n-        friend bool operator<(const CSubNet& a, const CSubNet& b);\n-\n-        SERIALIZE_METHODS(CSubNet, obj)\n-        {\n-            READWRITE(obj.network);\n-            if (obj.network.IsIPv4()) {\n-                // Before commit 102867c587f5f7954232fb8ed8e85cda78bb4d32, CSubNet used the last 4 bytes of netmask\n-                // to store the relevant bytes for an IPv4 mask. For compatibility reasons, keep doing so in\n-                // serialized form.\n-                unsigned char dummy[12] = {0};\n-                READWRITE(dummy);\n-                READWRITE(MakeSpan(obj.netmask).first(4));\n-            } else {\n-                READWRITE(obj.netmask);\n-            }\n-            READWRITE(obj.valid);\n-            // Mark invalid if the result doesn't pass sanity checking.\n-            SER_READ(obj, if (obj.valid) obj.valid = obj.SanityCheck());\n-        }\n+protected:\n+    /// Network (base) address\n+    CNetAddr network;\n+    /// Netmask, in network byte order\n+    uint8_t netmask[16];\n+    /// Is this value valid? (only used to signal parse errors)\n+    bool valid;\n+\n+    bool SanityCheck() const;\n+\n+public:\n+    /**\n+     * Construct an invalid subnet (empty, `Match()` always returns false).\n+     */\n+    CSubNet();\n+\n+    /**\n+     * Construct from a given network start and number of bits (CIDR mask).\n+     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n+     * created.\n+     * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for\n+     * IPv6 addresses. Otherwise an invalid subnet is created.\n+     */\n+    CSubNet(const CNetAddr& addr, uint8_t mask);\n+\n+    /**\n+     * Construct from a given network start and mask.\n+     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n+     * created.\n+     * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits\n+     * followed by 1-bits. Otherwise an invalid subnet is created.\n+     */\n+    CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n+\n+    /**\n+     * Construct a single-host subnet.\n+     * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].\n+     */\n+    explicit CSubNet(const CNetAddr& addr);\n+\n+    bool Match(const CNetAddr& addr) const;\n+\n+    std::string ToString() const;\n+    bool IsValid() const;\n+\n+    friend bool operator==(const CSubNet& a, const CSubNet& b);\n+    friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n+    friend bool operator<(const CSubNet& a, const CSubNet& b);\n };\n \n /** A combination of a network address (CNetAddr) and a (TCP) port */\n class CService : public CNetAddr\n {\n-    protected:\n-        uint16_t port; // host order\n-\n-    public:\n-        CService();\n-        CService(const CNetAddr& ip, uint16_t port);\n-        CService(const struct in_addr& ipv4Addr, uint16_t port);\n-        explicit CService(const struct sockaddr_in& addr);\n-        uint16_t GetPort() const;\n-        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n-        bool SetSockAddr(const struct sockaddr* paddr);\n-        friend bool operator==(const CService& a, const CService& b);\n-        friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n-        friend bool operator<(const CService& a, const CService& b);\n-        std::vector<unsigned char> GetKey() const;\n-        std::string ToString() const;\n-        std::string ToStringPort() const;\n-        std::string ToStringIPPort() const;\n-\n-        CService(const struct in6_addr& ipv6Addr, uint16_t port);\n-        explicit CService(const struct sockaddr_in6& addr);\n-\n-        SERIALIZE_METHODS(CService, obj)\n-        {\n-            READWRITEAS(CNetAddr, obj);\n-            READWRITE(Using<BigEndianFormatter<2>>(obj.port));\n-        }\n+protected:\n+    uint16_t port; // host order\n+\n+public:\n+    CService();\n+    CService(const CNetAddr& ip, uint16_t port);\n+    CService(const struct in_addr& ipv4Addr, uint16_t port);\n+    explicit CService(const struct sockaddr_in& addr);\n+    uint16_t GetPort() const;\n+    bool GetSockAddr(struct sockaddr* paddr, socklen_t* addrlen) const;\n+    bool SetSockAddr(const struct sockaddr* paddr);\n+    friend bool operator==(const CService& a, const CService& b);\n+    friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n+    friend bool operator<(const CService& a, const CService& b);\n+    std::vector<unsigned char> GetKey() const;\n+    std::string ToString() const;\n+    std::string ToStringPort() const;\n+    std::string ToStringIPPort() const;\n+\n+    CService(const struct in6_addr& ipv6Addr, uint16_t port);\n+    explicit CService(const struct sockaddr_in6& addr);\n+\n+    SERIALIZE_METHODS(CService, obj)\n+    {\n+        READWRITEAS(CNetAddr, obj);\n+        READWRITE(Using<BigEndianFormatter<2>>(obj.port));\n+    }\n };\n \n bool SanityCheckASMap(const std::vector<bool>& asmap);"
      },
      {
        "sha": "90f7ba191db1197a6b8ba5730a62a02dd5f36968",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -518,7 +518,7 @@ void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFile\n                 }\n                 nFile++;\n             }\n-            pblocktree->WriteReindexing(false);\n+            WITH_LOCK(::cs_main, chainman.m_blockman.m_block_tree_db->WriteReindexing(false));\n             fReindex = false;\n             LogPrintf(\"Reindexing finished\\n\");\n             // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):"
      },
      {
        "sha": "69e856dd15ad48fdc9164512433c071e0742652b",
        "filename": "src/node/coinstats.h",
        "status": "modified",
        "additions": 18,
        "deletions": 8,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/node/coinstats.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/node/coinstats.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coinstats.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -45,15 +45,25 @@ struct CCoinsStats\n     bool index_used{false};\n \n     // Following values are only available from coinstats index\n+\n+    //! Total cumulative amount of block subsidies up to and including this block\n     CAmount total_subsidy{0};\n-    CAmount block_unspendable_amount{0};\n-    CAmount block_prevout_spent_amount{0};\n-    CAmount block_new_outputs_ex_coinbase_amount{0};\n-    CAmount block_coinbase_amount{0};\n-    CAmount unspendables_genesis_block{0};\n-    CAmount unspendables_bip30{0};\n-    CAmount unspendables_scripts{0};\n-    CAmount unspendables_unclaimed_rewards{0};\n+    //! Total cumulative amount of unspendable coins up to and including this block\n+    CAmount total_unspendable_amount{0};\n+    //! Total cumulative amount of prevouts spent up to and including this block\n+    CAmount total_prevout_spent_amount{0};\n+    //! Total cumulative amount of outputs created up to and including this block\n+    CAmount total_new_outputs_ex_coinbase_amount{0};\n+    //! Total cumulative amount of coinbase outputs up to and including this block\n+    CAmount total_coinbase_amount{0};\n+    //! The unspendable coinbase amount from the genesis block\n+    CAmount total_unspendables_genesis_block{0};\n+    //! The two unspendable coinbase outputs total amount caused by BIP30\n+    CAmount total_unspendables_bip30{0};\n+    //! Total cumulative amount of outputs sent to unspendable scripts (OP_RETURN for example) up to and including this block\n+    CAmount total_unspendables_scripts{0};\n+    //! Total cumulative amount of coins lost due to unclaimed miner rewards up to and including this block\n+    CAmount total_unspendables_unclaimed_rewards{0};\n \n     CCoinsStats(CoinStatsHashType hash_type) : m_hash_type(hash_type) {}\n };"
      },
      {
        "sha": "2a7bcc057faf220d3ba5385fb6cfe148fac1552c",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 52,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,9 +4,12 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <consensus/validation.h>\n+#include <index/txindex.h>\n #include <net.h>\n #include <net_processing.h>\n+#include <node/blockstorage.h>\n #include <node/context.h>\n+#include <txmempool.h>\n #include <validation.h>\n #include <validationinterface.h>\n #include <node/transaction.h>\n@@ -28,65 +31,83 @@ static TransactionError HandleATMPError(const TxValidationState& state, std::str\n \n TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback)\n {\n-    // BroadcastTransaction can be called by either sendrawtransaction RPC or wallet RPCs.\n-    // node.peerman is assigned both before chain clients and before RPC server is accepting calls,\n-    // and reset after chain clients and RPC sever are stopped. node.peerman should never be null here.\n-    assert(node.peerman);\n+    // BroadcastTransaction can be called by either sendrawtransaction RPC or the wallet.\n+    // chainman, mempool and peerman are initialized before the RPC server and wallet are started\n+    // and reset after the RPC sever and wallet are stopped.\n+    assert(node.chainman);\n     assert(node.mempool);\n+    assert(node.peerman);\n+\n     std::promise<void> promise;\n-    uint256 hashTx = tx->GetHash();\n+    uint256 txid = tx->GetHash();\n+    uint256 wtxid = tx->GetWitnessHash();\n     bool callback_set = false;\n \n-    { // cs_main scope\n-    assert(node.chainman);\n-    LOCK(cs_main);\n-    // If the transaction is already confirmed in the chain, don't do anything\n-    // and return early.\n-    CCoinsViewCache &view = node.chainman->ActiveChainstate().CoinsTip();\n-    for (size_t o = 0; o < tx->vout.size(); o++) {\n-        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n-        // IsSpent doesn't mean the coin is spent, it means the output doesn't exist.\n-        // So if the output does exist, then this transaction exists in the chain.\n-        if (!existingCoin.IsSpent()) return TransactionError::ALREADY_IN_CHAIN;\n-    }\n-    if (!node.mempool->exists(hashTx)) {\n-        // Transaction is not already in the mempool.\n-        if (max_tx_fee > 0) {\n-            // First, call ATMP with test_accept and check the fee. If ATMP\n-            // fails here, return error immediately.\n+    {\n+        LOCK(cs_main);\n+\n+        // If the transaction is already confirmed in the chain, don't do anything\n+        // and return early.\n+        CCoinsViewCache &view = node.chainman->ActiveChainstate().CoinsTip();\n+        for (size_t o = 0; o < tx->vout.size(); o++) {\n+            const Coin& existingCoin = view.AccessCoin(COutPoint(txid, o));\n+            // IsSpent doesn't mean the coin is spent, it means the output doesn't exist.\n+            // So if the output does exist, then this transaction exists in the chain.\n+            if (!existingCoin.IsSpent()) return TransactionError::ALREADY_IN_CHAIN;\n+        }\n+\n+        if (auto mempool_tx = node.mempool->get(txid); mempool_tx) {\n+            // There's already a transaction in the mempool with this txid. Don't\n+            // try to submit this transaction to the mempool (since it'll be\n+            // rejected as a TX_CONFLICT), but do attempt to reannounce the mempool\n+            // transaction if relay=true.\n+            //\n+            // The mempool transaction may have the same or different witness (and\n+            // wtxid) as this transaction. Use the mempool's wtxid for reannouncement.\n+            wtxid = mempool_tx->GetWitnessHash();\n+        } else {\n+            // Transaction is not already in the mempool.\n+            if (max_tx_fee > 0) {\n+                // First, call ATMP with test_accept and check the fee. If ATMP\n+                // fails here, return error immediately.\n+                const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n+                                                                      true /* test_accept */);\n+                if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n+                    return HandleATMPError(result.m_state, err_string);\n+                } else if (result.m_base_fees.value() > max_tx_fee) {\n+                    return TransactionError::MAX_FEE_EXCEEDED;\n+                }\n+            }\n+            // Try to submit the transaction to the mempool.\n             const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n-                                                                  true /* test_accept */);\n+                                                                  false /* test_accept */);\n             if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n                 return HandleATMPError(result.m_state, err_string);\n-            } else if (result.m_base_fees.value() > max_tx_fee) {\n-                return TransactionError::MAX_FEE_EXCEEDED;\n             }\n-        }\n-        // Try to submit the transaction to the mempool.\n-        const MempoolAcceptResult result = AcceptToMemoryPool(node.chainman->ActiveChainstate(), *node.mempool, tx, false /* bypass_limits */,\n-                                                              false /* test_accept */);\n-        if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n-            return HandleATMPError(result.m_state, err_string);\n-        }\n \n-        // Transaction was accepted to the mempool.\n+            // Transaction was accepted to the mempool.\n \n-        if (wait_callback) {\n-            // For transactions broadcast from outside the wallet, make sure\n-            // that the wallet has been notified of the transaction before\n-            // continuing.\n-            //\n-            // This prevents a race where a user might call sendrawtransaction\n-            // with a transaction to/from their wallet, immediately call some\n-            // wallet RPC, and get a stale result because callbacks have not\n-            // yet been processed.\n-            CallFunctionInValidationInterfaceQueue([&promise] {\n-                promise.set_value();\n-            });\n-            callback_set = true;\n-        }\n-    }\n+            if (relay) {\n+                // the mempool tracks locally submitted transactions to make a\n+                // best-effort of initial broadcast\n+                node.mempool->AddUnbroadcastTx(txid);\n+            }\n \n+            if (wait_callback) {\n+                // For transactions broadcast from outside the wallet, make sure\n+                // that the wallet has been notified of the transaction before\n+                // continuing.\n+                //\n+                // This prevents a race where a user might call sendrawtransaction\n+                // with a transaction to/from their wallet, immediately call some\n+                // wallet RPC, and get a stale result because callbacks have not\n+                // yet been processed.\n+                CallFunctionInValidationInterfaceQueue([&promise] {\n+                    promise.set_value();\n+                });\n+                callback_set = true;\n+            }\n+        }\n     } // cs_main\n \n     if (callback_set) {\n@@ -96,11 +117,41 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     }\n \n     if (relay) {\n-        // the mempool tracks locally submitted transactions to make a\n-        // best-effort of initial broadcast\n-        node.mempool->AddUnbroadcastTx(hashTx);\n-        node.peerman->RelayTransaction(hashTx, tx->GetWitnessHash());\n+        node.peerman->RelayTransaction(txid, wtxid);\n     }\n \n     return TransactionError::OK;\n }\n+\n+CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock)\n+{\n+    if (mempool && !block_index) {\n+        CTransactionRef ptx = mempool->get(hash);\n+        if (ptx) return ptx;\n+    }\n+    if (g_txindex) {\n+        CTransactionRef tx;\n+        uint256 block_hash;\n+        if (g_txindex->FindTx(hash, block_hash, tx)) {\n+            if (!block_index || block_index->GetBlockHash() == block_hash) {\n+                // Don't return the transaction if the provided block hash doesn't match.\n+                // The case where a transaction appears in multiple blocks (e.g. reorgs or\n+                // BIP30) is handled by the block lookup below.\n+                hashBlock = block_hash;\n+                return tx;\n+            }\n+        }\n+    }\n+    if (block_index) {\n+        CBlock block;\n+        if (ReadBlockFromDisk(block, block_index, consensusParams)) {\n+            for (const auto& tx : block.vtx) {\n+                if (tx->GetHash() == hash) {\n+                    hashBlock = block_index->GetBlockHash();\n+                    return tx;\n+                }\n+            }\n+        }\n+    }\n+    return nullptr;\n+}"
      },
      {
        "sha": "aed519cf7fac90035481e15442a23304c1a95bf4",
        "filename": "src/node/transaction.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/node/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/node/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -10,7 +10,12 @@\n #include <primitives/transaction.h>\n #include <util/error.h>\n \n+class CBlockIndex;\n+class CTxMemPool;\n struct NodeContext;\n+namespace Consensus {\n+struct Params;\n+}\n \n /** Maximum fee rate for sendrawtransaction and testmempoolaccept RPC calls.\n  * Also used by the GUI when broadcasting a completed PSBT.\n@@ -38,4 +43,19 @@ static const CFeeRate DEFAULT_MAX_RAW_TX_FEE_RATE{COIN / 10};\n  */\n [[nodiscard]] TransactionError BroadcastTransaction(NodeContext& node, CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback);\n \n+/**\n+ * Return transaction with a given hash.\n+ * If mempool is provided and block_index is not provided, check it first for the tx.\n+ * If -txindex is available, check it next for the tx.\n+ * Finally, if block_index is provided, check for tx by reading entire block from disk.\n+ *\n+ * @param[in]  block_index     The block to read from disk, or nullptr\n+ * @param[in]  mempool         If provided, check mempool for tx\n+ * @param[in]  hash            The txid\n+ * @param[in]  consensusParams The params\n+ * @param[out] hashBlock       The block hash, if the tx was found via -txindex or block_index\n+ * @returns                    The tx if found, otherwise nullptr\n+ */\n+CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock);\n+\n #endif // BITCOIN_NODE_TRANSACTION_H"
      },
      {
        "sha": "b5f1df97929c79a5d1027dfd67c874d3f04614f4",
        "filename": "src/outputtype.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/outputtype.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/outputtype.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/outputtype.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -13,29 +13,26 @@\n #include <util/vector.h>\n \n #include <assert.h>\n+#include <optional>\n #include <string>\n \n static const std::string OUTPUT_TYPE_STRING_LEGACY = \"legacy\";\n static const std::string OUTPUT_TYPE_STRING_P2SH_SEGWIT = \"p2sh-segwit\";\n static const std::string OUTPUT_TYPE_STRING_BECH32 = \"bech32\";\n static const std::string OUTPUT_TYPE_STRING_BECH32M = \"bech32m\";\n \n-bool ParseOutputType(const std::string& type, OutputType& output_type)\n+std::optional<OutputType> ParseOutputType(const std::string& type)\n {\n     if (type == OUTPUT_TYPE_STRING_LEGACY) {\n-        output_type = OutputType::LEGACY;\n-        return true;\n+        return OutputType::LEGACY;\n     } else if (type == OUTPUT_TYPE_STRING_P2SH_SEGWIT) {\n-        output_type = OutputType::P2SH_SEGWIT;\n-        return true;\n+        return OutputType::P2SH_SEGWIT;\n     } else if (type == OUTPUT_TYPE_STRING_BECH32) {\n-        output_type = OutputType::BECH32;\n-        return true;\n+        return OutputType::BECH32;\n     } else if (type == OUTPUT_TYPE_STRING_BECH32M) {\n-        output_type = OutputType::BECH32M;\n-        return true;\n+        return OutputType::BECH32M;\n     }\n-    return false;\n+    return std::nullopt;\n }\n \n const std::string& FormatOutputType(OutputType type)"
      },
      {
        "sha": "0de7689125f525f6d484a870da0aa3b2b1526184",
        "filename": "src/outputtype.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/outputtype.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/outputtype.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/outputtype.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -11,6 +11,7 @@\n #include <script/standard.h>\n \n #include <array>\n+#include <optional>\n #include <string>\n #include <vector>\n \n@@ -28,7 +29,7 @@ static constexpr auto OUTPUT_TYPES = std::array{\n     OutputType::BECH32M,\n };\n \n-[[nodiscard]] bool ParseOutputType(const std::string& str, OutputType& output_type);\n+std::optional<OutputType> ParseOutputType(const std::string& str);\n const std::string& FormatOutputType(OutputType type);\n \n /**"
      },
      {
        "sha": "75202e7cf41e9b134691c3cf139fd58e5b6f17ac",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -191,7 +191,7 @@ bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> si\n     assert(sigbytes.size() == 64);\n     secp256k1_xonly_pubkey pubkey;\n     if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;\n-    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n+    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), 32, &pubkey);\n }\n \n static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");"
      },
      {
        "sha": "4ab4e388d9dc49ed7b41bb786a24961844c6534c",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 78,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,38 +7,38 @@\n #endif\n \n #include <qt/bitcoin.h>\n-#include <qt/bitcoingui.h>\n \n #include <chainparams.h>\n+#include <init.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n+#include <node/context.h>\n+#include <node/ui_interface.h>\n+#include <noui.h>\n+#include <qt/bitcoingui.h>\n #include <qt/clientmodel.h>\n #include <qt/guiconstants.h>\n #include <qt/guiutil.h>\n+#include <qt/initexecutor.h>\n #include <qt/intro.h>\n #include <qt/networkstyle.h>\n #include <qt/optionsmodel.h>\n #include <qt/platformstyle.h>\n #include <qt/splashscreen.h>\n #include <qt/utilitydialog.h>\n #include <qt/winshutdownmonitor.h>\n+#include <uint256.h>\n+#include <util/system.h>\n+#include <util/threadnames.h>\n+#include <util/translation.h>\n+#include <validation.h>\n \n #ifdef ENABLE_WALLET\n #include <qt/paymentserver.h>\n #include <qt/walletcontroller.h>\n #include <qt/walletmodel.h>\n #endif // ENABLE_WALLET\n \n-#include <init.h>\n-#include <interfaces/handler.h>\n-#include <interfaces/node.h>\n-#include <node/context.h>\n-#include <node/ui_interface.h>\n-#include <noui.h>\n-#include <uint256.h>\n-#include <util/system.h>\n-#include <util/threadnames.h>\n-#include <util/translation.h>\n-#include <validation.h>\n-\n #include <boost/signals2/connection.hpp>\n #include <memory>\n \n@@ -155,54 +155,11 @@ void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, cons\n     }\n }\n \n-BitcoinCore::BitcoinCore(interfaces::Node& node) :\n-    QObject(), m_node(node)\n-{\n-}\n-\n-void BitcoinCore::handleRunawayException(const std::exception *e)\n-{\n-    PrintExceptionContinue(e, \"Runaway exception\");\n-    Q_EMIT runawayException(QString::fromStdString(m_node.getWarnings().translated));\n-}\n-\n-void BitcoinCore::initialize()\n-{\n-    try\n-    {\n-        util::ThreadRename(\"qt-init\");\n-        qDebug() << __func__ << \": Running initialization in thread\";\n-        interfaces::BlockAndHeaderTipInfo tip_info;\n-        bool rv = m_node.appInitMain(&tip_info);\n-        Q_EMIT initializeResult(rv, tip_info);\n-    } catch (const std::exception& e) {\n-        handleRunawayException(&e);\n-    } catch (...) {\n-        handleRunawayException(nullptr);\n-    }\n-}\n-\n-void BitcoinCore::shutdown()\n-{\n-    try\n-    {\n-        qDebug() << __func__ << \": Running Shutdown in thread\";\n-        m_node.appShutdown();\n-        qDebug() << __func__ << \": Shutdown finished\";\n-        Q_EMIT shutdownResult();\n-    } catch (const std::exception& e) {\n-        handleRunawayException(&e);\n-    } catch (...) {\n-        handleRunawayException(nullptr);\n-    }\n-}\n-\n static int qt_argc = 1;\n static const char* qt_argv = \"bitcoin-qt\";\n \n BitcoinApplication::BitcoinApplication():\n     QApplication(qt_argc, const_cast<char **>(&qt_argv)),\n-    coreThread(nullptr),\n     optionsModel(nullptr),\n     clientModel(nullptr),\n     window(nullptr),\n@@ -230,13 +187,7 @@ void BitcoinApplication::setupPlatformStyle()\n \n BitcoinApplication::~BitcoinApplication()\n {\n-    if(coreThread)\n-    {\n-        qDebug() << __func__ << \": Stopping thread\";\n-        coreThread->quit();\n-        coreThread->wait();\n-        qDebug() << __func__ << \": Stopped thread\";\n-    }\n+    m_executor.reset();\n \n     delete window;\n     window = nullptr;\n@@ -291,22 +242,15 @@ bool BitcoinApplication::baseInitialize()\n \n void BitcoinApplication::startThread()\n {\n-    if(coreThread)\n-        return;\n-    coreThread = new QThread(this);\n-    BitcoinCore *executor = new BitcoinCore(node());\n-    executor->moveToThread(coreThread);\n+    assert(!m_executor);\n+    m_executor.emplace(node());\n \n     /*  communication to and from thread */\n-    connect(executor, &BitcoinCore::initializeResult, this, &BitcoinApplication::initializeResult);\n-    connect(executor, &BitcoinCore::shutdownResult, this, &BitcoinApplication::shutdownResult);\n-    connect(executor, &BitcoinCore::runawayException, this, &BitcoinApplication::handleRunawayException);\n-    connect(this, &BitcoinApplication::requestedInitialize, executor, &BitcoinCore::initialize);\n-    connect(this, &BitcoinApplication::requestedShutdown, executor, &BitcoinCore::shutdown);\n-    /*  make sure executor object is deleted in its own thread */\n-    connect(coreThread, &QThread::finished, executor, &QObject::deleteLater);\n-\n-    coreThread->start();\n+    connect(&m_executor.value(), &InitExecutor::initializeResult, this, &BitcoinApplication::initializeResult);\n+    connect(&m_executor.value(), &InitExecutor::shutdownResult, this, &BitcoinApplication::shutdownResult);\n+    connect(&m_executor.value(), &InitExecutor::runawayException, this, &BitcoinApplication::handleRunawayException);\n+    connect(this, &BitcoinApplication::requestedInitialize, &m_executor.value(), &InitExecutor::initialize);\n+    connect(this, &BitcoinApplication::requestedShutdown, &m_executor.value(), &InitExecutor::shutdown);\n }\n \n void BitcoinApplication::parameterSetup()\n@@ -339,7 +283,6 @@ void BitcoinApplication::requestShutdown()\n     shutdownWindow.reset(ShutdownWindow::showShutdownWindow(window));\n \n     qDebug() << __func__ << \": Requesting shutdown\";\n-    startThread();\n     window->hide();\n     // Must disconnect node signals otherwise current thread can deadlock since\n     // no event loop is running."
      },
      {
        "sha": "ed2f26b7f384df388ac4dcc4481326a00be5255b",
        "filename": "src/qt/bitcoin.h",
        "status": "modified",
        "additions": 6,
        "deletions": 28,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -9,11 +9,14 @@\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <QApplication>\n+#include <interfaces/node.h>\n+#include <qt/initexecutor.h>\n+\n #include <assert.h>\n #include <memory>\n+#include <optional>\n \n-#include <interfaces/node.h>\n+#include <QApplication>\n \n class BitcoinGUI;\n class ClientModel;\n@@ -26,31 +29,6 @@ class WalletController;\n class WalletModel;\n \n \n-/** Class encapsulating Bitcoin Core startup and shutdown.\n- * Allows running startup and shutdown in a different thread from the UI thread.\n- */\n-class BitcoinCore: public QObject\n-{\n-    Q_OBJECT\n-public:\n-    explicit BitcoinCore(interfaces::Node& node);\n-\n-public Q_SLOTS:\n-    void initialize();\n-    void shutdown();\n-\n-Q_SIGNALS:\n-    void initializeResult(bool success, interfaces::BlockAndHeaderTipInfo tip_info);\n-    void shutdownResult();\n-    void runawayException(const QString &message);\n-\n-private:\n-    /// Pass fatal exception message to UI thread\n-    void handleRunawayException(const std::exception *e);\n-\n-    interfaces::Node& m_node;\n-};\n-\n /** Main Bitcoin application object */\n class BitcoinApplication: public QApplication\n {\n@@ -112,7 +90,7 @@ public Q_SLOTS:\n     void windowShown(BitcoinGUI* window);\n \n private:\n-    QThread *coreThread;\n+    std::optional<InitExecutor> m_executor;\n     OptionsModel *optionsModel;\n     ClientModel *clientModel;\n     BitcoinGUI *window;"
      },
      {
        "sha": "863225099afbab60a2eb5b0519ecad923aa765f4",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -682,8 +682,6 @@ void BitcoinGUI::addWallet(WalletModel* walletModel)\n         m_wallet_selector_label_action->setVisible(true);\n         m_wallet_selector_action->setVisible(true);\n     }\n-    const QString display_name = walletModel->getDisplayName();\n-    m_wallet_selector->addItem(display_name, QVariant::fromValue(walletModel));\n \n     connect(wallet_view, &WalletView::outOfSyncWarningClicked, this, &BitcoinGUI::showModalOverlay);\n     connect(wallet_view, &WalletView::transactionClicked, this, &BitcoinGUI::gotoHistoryPage);\n@@ -696,6 +694,8 @@ void BitcoinGUI::addWallet(WalletModel* walletModel)\n     connect(wallet_view, &WalletView::hdEnabledStatusChanged, this, &BitcoinGUI::updateWalletStatus);\n     connect(this, &BitcoinGUI::setPrivacy, wallet_view, &WalletView::setPrivacy);\n     wallet_view->setPrivacy(isPrivacyModeActivated());\n+    const QString display_name = walletModel->getDisplayName();\n+    m_wallet_selector->addItem(display_name, QVariant::fromValue(walletModel));\n }\n \n void BitcoinGUI::removeWallet(WalletModel* walletModel)"
      },
      {
        "sha": "7060f74dab81cb595fc4307f57f266609509e52f",
        "filename": "src/qt/initexecutor.cpp",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/initexecutor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/initexecutor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/initexecutor.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2014-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <qt/initexecutor.h>\n+\n+#include <interfaces/node.h>\n+#include <util/system.h>\n+#include <util/threadnames.h>\n+\n+#include <exception>\n+\n+#include <QDebug>\n+#include <QObject>\n+#include <QString>\n+#include <QThread>\n+\n+InitExecutor::InitExecutor(interfaces::Node& node)\n+    : QObject(), m_node(node)\n+{\n+    this->moveToThread(&m_thread);\n+    m_thread.start();\n+}\n+\n+InitExecutor::~InitExecutor()\n+{\n+    qDebug() << __func__ << \": Stopping thread\";\n+    m_thread.quit();\n+    m_thread.wait();\n+    qDebug() << __func__ << \": Stopped thread\";\n+}\n+\n+void InitExecutor::handleRunawayException(const std::exception* e)\n+{\n+    PrintExceptionContinue(e, \"Runaway exception\");\n+    Q_EMIT runawayException(QString::fromStdString(m_node.getWarnings().translated));\n+}\n+\n+void InitExecutor::initialize()\n+{\n+    try {\n+        util::ThreadRename(\"qt-init\");\n+        qDebug() << __func__ << \": Running initialization in thread\";\n+        interfaces::BlockAndHeaderTipInfo tip_info;\n+        bool rv = m_node.appInitMain(&tip_info);\n+        Q_EMIT initializeResult(rv, tip_info);\n+    } catch (const std::exception& e) {\n+        handleRunawayException(&e);\n+    } catch (...) {\n+        handleRunawayException(nullptr);\n+    }\n+}\n+\n+void InitExecutor::shutdown()\n+{\n+    try {\n+        qDebug() << __func__ << \": Running Shutdown in thread\";\n+        m_node.appShutdown();\n+        qDebug() << __func__ << \": Shutdown finished\";\n+        Q_EMIT shutdownResult();\n+    } catch (const std::exception& e) {\n+        handleRunawayException(&e);\n+    } catch (...) {\n+        handleRunawayException(nullptr);\n+    }\n+}"
      },
      {
        "sha": "319ce40465d459f1eb21d29385fc9eecde2dc0a0",
        "filename": "src/qt/initexecutor.h",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/initexecutor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/initexecutor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/initexecutor.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,46 @@\n+// Copyright (c) 2014-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_INITEXECUTOR_H\n+#define BITCOIN_QT_INITEXECUTOR_H\n+\n+#include <interfaces/node.h>\n+\n+#include <exception>\n+\n+#include <QObject>\n+#include <QThread>\n+\n+QT_BEGIN_NAMESPACE\n+class QString;\n+QT_END_NAMESPACE\n+\n+/** Class encapsulating Bitcoin Core startup and shutdown.\n+ * Allows running startup and shutdown in a different thread from the UI thread.\n+ */\n+class InitExecutor : public QObject\n+{\n+    Q_OBJECT\n+public:\n+    explicit InitExecutor(interfaces::Node& node);\n+    ~InitExecutor();\n+\n+public Q_SLOTS:\n+    void initialize();\n+    void shutdown();\n+\n+Q_SIGNALS:\n+    void initializeResult(bool success, interfaces::BlockAndHeaderTipInfo tip_info);\n+    void shutdownResult();\n+    void runawayException(const QString& message);\n+\n+private:\n+    /// Pass fatal exception message to UI thread\n+    void handleRunawayException(const std::exception* e);\n+\n+    interfaces::Node& m_node;\n+    QThread m_thread;\n+};\n+\n+#endif // BITCOIN_QT_INITEXECUTOR_H"
      },
      {
        "sha": "56f55363b262204c0e2831711f5ef551a03e5ca7",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -288,6 +288,7 @@ bool RPCConsole::RPCParseCommandLine(interfaces::Node* node, std::string &strRes\n                 }\n                 if (breakParsing)\n                     break;\n+                [[fallthrough]];\n             }\n             case STATE_ARGUMENT: // In or after argument\n             case STATE_EATING_SPACES_IN_ARG:\n@@ -401,6 +402,7 @@ bool RPCConsole::RPCParseCommandLine(interfaces::Node* node, std::string &strRes\n                 strResult = lastResult.get_str();\n             else\n                 strResult = lastResult.write(2);\n+            [[fallthrough]];\n         case STATE_ARGUMENT:\n         case STATE_EATING_SPACES:\n             return true;"
      },
      {
        "sha": "8489b331445e1fb63f933bce0b843fb5ba08ef09",
        "filename": "src/qt/test/apptests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/test/apptests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/test/apptests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/apptests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -12,7 +12,6 @@\n #include <qt/rpcconsole.h>\n #include <shutdown.h>\n #include <test/util/setup_common.h>\n-#include <univalue.h>\n #include <validation.h>\n \n #if defined(HAVE_CONFIG_H)\n@@ -21,15 +20,24 @@\n \n #include <QAction>\n #include <QLineEdit>\n+#include <QRegularExpression>\n #include <QScopedPointer>\n #include <QSignalSpy>\n+#include <QString>\n #include <QTest>\n #include <QTextEdit>\n #include <QtGlobal>\n #include <QtTest/QtTestWidgets>\n #include <QtTest/QtTestGui>\n \n namespace {\n+//! Regex find a string group inside of the console output\n+QString FindInConsole(const QString& output, const QString& pattern)\n+{\n+    const QRegularExpression re(pattern);\n+    return re.match(output).captured(1);\n+}\n+\n //! Call getblockchaininfo RPC and check first field of JSON output.\n void TestRpcCommand(RPCConsole* console)\n {\n@@ -41,10 +49,9 @@ void TestRpcCommand(RPCConsole* console)\n     QTest::keyClick(lineEdit, Qt::Key_Return);\n     QVERIFY(mw_spy.wait(1000));\n     QCOMPARE(mw_spy.count(), 4);\n-    QString output = messagesWidget->toPlainText();\n-    UniValue value;\n-    value.read(output.right(output.size() - output.lastIndexOf(QChar::ObjectReplacementCharacter) - 1).toStdString());\n-    QCOMPARE(value[\"chain\"].get_str(), std::string(\"regtest\"));\n+    const QString output = messagesWidget->toPlainText();\n+    const QString pattern = QStringLiteral(\"\\\"chain\\\": \\\"(\\\\w+)\\\"\");\n+    QCOMPARE(FindInConsole(output, pattern), QString(\"regtest\"));\n }\n } // namespace\n "
      },
      {
        "sha": "7d66f67f8a993e2510b6cfaa5cd58cdadd91aac9",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <interfaces/node.h>\n #include <qt/bitcoin.h>\n+#include <qt/initexecutor.h>\n #include <qt/test/apptests.h>\n #include <qt/test/rpcnestedtests.h>\n #include <qt/test/uritests.h>"
      },
      {
        "sha": "e50ab33e5440a9fe40b39b1b927f9fc1dec90842",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -524,6 +524,7 @@ static bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::\n         // convert hex to bin, continue then with bin part\n         std::vector<unsigned char> strRequestV = ParseHex(strRequestMutable);\n         strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n+        [[fallthrough]];\n     }\n \n     case RetFormat::BINARY: {"
      },
      {
        "sha": "4956ee39e94bc37d753f047e84fac55e97c577b8",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 33,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1120,13 +1120,13 @@ static RPCHelpMan gettxoutsetinfo()\n                         {RPCResult::Type::STR_AMOUNT, \"total_unspendable_amount\", \"The total amount of coins permanently excluded from the UTXO set (only available if coinstatsindex is used)\"},\n                         {RPCResult::Type::OBJ, \"block_info\", \"Info on amounts in the block at this block height (only available if coinstatsindex is used)\",\n                         {\n-                            {RPCResult::Type::STR_AMOUNT, \"prevout_spent\", \"\"},\n-                            {RPCResult::Type::STR_AMOUNT, \"coinbase\", \"\"},\n-                            {RPCResult::Type::STR_AMOUNT, \"new_outputs_ex_coinbase\", \"\"},\n-                            {RPCResult::Type::STR_AMOUNT, \"unspendable\", \"\"},\n+                            {RPCResult::Type::STR_AMOUNT, \"prevout_spent\", \"Total amount of all prevouts spent in this block\"},\n+                            {RPCResult::Type::STR_AMOUNT, \"coinbase\", \"Coinbase subsidy amount of this block\"},\n+                            {RPCResult::Type::STR_AMOUNT, \"new_outputs_ex_coinbase\", \"Total amount of new outputs created by this block\"},\n+                            {RPCResult::Type::STR_AMOUNT, \"unspendable\", \"Total amount of unspendable outputs created in this block\"},\n                             {RPCResult::Type::OBJ, \"unspendables\", \"Detailed view of the unspendable categories\",\n                             {\n-                                {RPCResult::Type::STR_AMOUNT, \"genesis_block\", \"\"},\n+                                {RPCResult::Type::STR_AMOUNT, \"genesis_block\", \"The unspendable amount of the Genesis block subsidy\"},\n                                 {RPCResult::Type::STR_AMOUNT, \"bip30\", \"Transactions overridden by duplicates (no longer possible with BIP30)\"},\n                                 {RPCResult::Type::STR_AMOUNT, \"scripts\", \"Amounts sent to scripts that are unspendable (for example OP_RETURN outputs)\"},\n                                 {RPCResult::Type::STR_AMOUNT, \"unclaimed_rewards\", \"Fee rewards that miners did not claim in their coinbase transaction\"},\n@@ -1178,6 +1178,18 @@ static RPCHelpMan gettxoutsetinfo()\n         pindex = ParseHashOrHeight(request.params[1], chainman);\n     }\n \n+    if (stats.index_requested && g_coin_stats_index) {\n+        if (!g_coin_stats_index->BlockUntilSyncedToCurrentChain()) {\n+            const IndexSummary summary{g_coin_stats_index->GetSummary()};\n+\n+            // If a specific block was requested and the index has already synced past that height, we can return the\n+            // data already even though the index is not fully synced yet.\n+            if (pindex->nHeight > summary.best_block_height) {\n+                throw JSONRPCError(RPC_INTERNAL_ERROR, strprintf(\"Unable to get data because coinstatsindex is still syncing. Current height: %d\", summary.best_block_height));\n+            }\n+        }\n+    }\n+\n     if (GetUTXOStats(coins_view, *blockman, stats, node.rpc_interruption_point, pindex)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n@@ -1194,7 +1206,7 @@ static RPCHelpMan gettxoutsetinfo()\n             ret.pushKV(\"transactions\", static_cast<int64_t>(stats.nTransactions));\n             ret.pushKV(\"disk_size\", stats.nDiskSize);\n         } else {\n-            ret.pushKV(\"total_unspendable_amount\", ValueFromAmount(stats.block_unspendable_amount));\n+            ret.pushKV(\"total_unspendable_amount\", ValueFromAmount(stats.total_unspendable_amount));\n \n             CCoinsStats prev_stats{hash_type};\n \n@@ -1203,28 +1215,21 @@ static RPCHelpMan gettxoutsetinfo()\n             }\n \n             UniValue block_info(UniValue::VOBJ);\n-            block_info.pushKV(\"prevout_spent\", ValueFromAmount(stats.block_prevout_spent_amount - prev_stats.block_prevout_spent_amount));\n-            block_info.pushKV(\"coinbase\", ValueFromAmount(stats.block_coinbase_amount - prev_stats.block_coinbase_amount));\n-            block_info.pushKV(\"new_outputs_ex_coinbase\", ValueFromAmount(stats.block_new_outputs_ex_coinbase_amount - prev_stats.block_new_outputs_ex_coinbase_amount));\n-            block_info.pushKV(\"unspendable\", ValueFromAmount(stats.block_unspendable_amount - prev_stats.block_unspendable_amount));\n+            block_info.pushKV(\"prevout_spent\", ValueFromAmount(stats.total_prevout_spent_amount - prev_stats.total_prevout_spent_amount));\n+            block_info.pushKV(\"coinbase\", ValueFromAmount(stats.total_coinbase_amount - prev_stats.total_coinbase_amount));\n+            block_info.pushKV(\"new_outputs_ex_coinbase\", ValueFromAmount(stats.total_new_outputs_ex_coinbase_amount - prev_stats.total_new_outputs_ex_coinbase_amount));\n+            block_info.pushKV(\"unspendable\", ValueFromAmount(stats.total_unspendable_amount - prev_stats.total_unspendable_amount));\n \n             UniValue unspendables(UniValue::VOBJ);\n-            unspendables.pushKV(\"genesis_block\", ValueFromAmount(stats.unspendables_genesis_block - prev_stats.unspendables_genesis_block));\n-            unspendables.pushKV(\"bip30\", ValueFromAmount(stats.unspendables_bip30 - prev_stats.unspendables_bip30));\n-            unspendables.pushKV(\"scripts\", ValueFromAmount(stats.unspendables_scripts - prev_stats.unspendables_scripts));\n-            unspendables.pushKV(\"unclaimed_rewards\", ValueFromAmount(stats.unspendables_unclaimed_rewards - prev_stats.unspendables_unclaimed_rewards));\n+            unspendables.pushKV(\"genesis_block\", ValueFromAmount(stats.total_unspendables_genesis_block - prev_stats.total_unspendables_genesis_block));\n+            unspendables.pushKV(\"bip30\", ValueFromAmount(stats.total_unspendables_bip30 - prev_stats.total_unspendables_bip30));\n+            unspendables.pushKV(\"scripts\", ValueFromAmount(stats.total_unspendables_scripts - prev_stats.total_unspendables_scripts));\n+            unspendables.pushKV(\"unclaimed_rewards\", ValueFromAmount(stats.total_unspendables_unclaimed_rewards - prev_stats.total_unspendables_unclaimed_rewards));\n             block_info.pushKV(\"unspendables\", unspendables);\n \n             ret.pushKV(\"block_info\", block_info);\n         }\n     } else {\n-        if (g_coin_stats_index) {\n-            const IndexSummary summary{g_coin_stats_index->GetSummary()};\n-\n-            if (!summary.synced) {\n-                throw JSONRPCError(RPC_INTERNAL_ERROR, strprintf(\"Unable to read UTXO set because coinstatsindex is still syncing. Current height: %d\", summary.best_block_height));\n-            }\n-        }\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n     }\n     return ret;\n@@ -1377,23 +1382,24 @@ static void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue&\n     case ThresholdState::ACTIVE: bip9.pushKV(\"status\", \"active\"); break;\n     case ThresholdState::FAILED: bip9.pushKV(\"status\", \"failed\"); break;\n     }\n-    if (ThresholdState::STARTED == thresholdState)\n-    {\n+    const bool has_signal = (ThresholdState::STARTED == thresholdState || ThresholdState::LOCKED_IN == thresholdState);\n+    if (has_signal) {\n         bip9.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n     }\n     bip9.pushKV(\"start_time\", consensusParams.vDeployments[id].nStartTime);\n     bip9.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n     int64_t since_height = g_versionbitscache.StateSinceHeight(active_chain_tip, consensusParams, id);\n     bip9.pushKV(\"since\", since_height);\n-    if (ThresholdState::STARTED == thresholdState)\n-    {\n+    if (has_signal) {\n         UniValue statsUV(UniValue::VOBJ);\n         BIP9Stats statsStruct = g_versionbitscache.Statistics(active_chain_tip, consensusParams, id);\n         statsUV.pushKV(\"period\", statsStruct.period);\n-        statsUV.pushKV(\"threshold\", statsStruct.threshold);\n         statsUV.pushKV(\"elapsed\", statsStruct.elapsed);\n         statsUV.pushKV(\"count\", statsStruct.count);\n-        statsUV.pushKV(\"possible\", statsStruct.possible);\n+        if (ThresholdState::LOCKED_IN != thresholdState) {\n+            statsUV.pushKV(\"threshold\", statsStruct.threshold);\n+            statsUV.pushKV(\"possible\", statsStruct.possible);\n+        }\n         bip9.pushKV(\"statistics\", statsUV);\n     }\n     bip9.pushKV(\"min_activation_height\", consensusParams.vDeployments[id].min_activation_height);\n@@ -1422,7 +1428,8 @@ RPCHelpMan getblockchaininfo()\n                         {RPCResult::Type::NUM, \"headers\", \"the current number of headers we have validated\"},\n                         {RPCResult::Type::STR, \"bestblockhash\", \"the hash of the currently best block\"},\n                         {RPCResult::Type::NUM, \"difficulty\", \"the current difficulty\"},\n-                        {RPCResult::Type::NUM, \"mediantime\", \"median time for the current best block\"},\n+                        {RPCResult::Type::NUM_TIME, \"time\", \"The block time expressed in \" + UNIX_EPOCH_TIME},\n+                        {RPCResult::Type::NUM_TIME, \"mediantime\", \"The median block time expressed in \" + UNIX_EPOCH_TIME},\n                         {RPCResult::Type::NUM, \"verificationprogress\", \"estimate of verification progress [0..1]\"},\n                         {RPCResult::Type::BOOL, \"initialblockdownload\", \"(debug information) estimate of whether this node is in Initial Block Download mode\"},\n                         {RPCResult::Type::STR_HEX, \"chainwork\", \"total amount of work in active chain, in hexadecimal\"},\n@@ -1439,18 +1446,18 @@ RPCHelpMan getblockchaininfo()\n                                 {RPCResult::Type::OBJ, \"bip9\", \"status of bip9 softforks (only for \\\"bip9\\\" type)\",\n                                 {\n                                     {RPCResult::Type::STR, \"status\", \"one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\"},\n-                                    {RPCResult::Type::NUM, \"bit\", \"the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" status)\"},\n+                                    {RPCResult::Type::NUM, \"bit\", \"the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" and \\\"locked_in\\\" status)\"},\n                                     {RPCResult::Type::NUM_TIME, \"start_time\", \"the minimum median time past of a block at which the bit gains its meaning\"},\n                                     {RPCResult::Type::NUM_TIME, \"timeout\", \"the median time past of a block at which the deployment is considered failed if not yet locked in\"},\n                                     {RPCResult::Type::NUM, \"since\", \"height of the first block to which the status applies\"},\n                                     {RPCResult::Type::NUM, \"min_activation_height\", \"minimum height of blocks for which the rules may be enforced\"},\n-                                    {RPCResult::Type::OBJ, \"statistics\", \"numeric statistics about BIP9 signalling for a softfork (only for \\\"started\\\" status)\",\n+                                    {RPCResult::Type::OBJ, \"statistics\", \"numeric statistics about signalling for a softfork (only for \\\"started\\\" and \\\"locked_in\\\" status)\",\n                                     {\n-                                        {RPCResult::Type::NUM, \"period\", \"the length in blocks of the BIP9 signalling period\"},\n-                                        {RPCResult::Type::NUM, \"threshold\", \"the number of blocks with the version bit set required to activate the feature\"},\n+                                        {RPCResult::Type::NUM, \"period\", \"the length in blocks of the signalling period\"},\n+                                        {RPCResult::Type::NUM, \"threshold\", \"the number of blocks with the version bit set required to activate the feature (only for \\\"started\\\" status)\"},\n                                         {RPCResult::Type::NUM, \"elapsed\", \"the number of blocks elapsed since the beginning of the current period\"},\n                                         {RPCResult::Type::NUM, \"count\", \"the number of blocks with the version bit set in the current period\"},\n-                                        {RPCResult::Type::BOOL, \"possible\", \"returns false if there are not enough blocks left in this period to pass activation threshold\"},\n+                                        {RPCResult::Type::BOOL, \"possible\", \"returns false if there are not enough blocks left in this period to pass activation threshold (only for \\\"started\\\" status)\"},\n                                     }},\n                                 }},\n                                 {RPCResult::Type::NUM, \"height\", \"height of the first block which the rules are or will be enforced (only for \\\"buried\\\" type, or \\\"bip9\\\" type with \\\"active\\\" status)\"},\n@@ -1478,6 +1485,7 @@ RPCHelpMan getblockchaininfo()\n     obj.pushKV(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1);\n     obj.pushKV(\"bestblockhash\",         tip->GetBlockHash().GetHex());\n     obj.pushKV(\"difficulty\",            (double)GetDifficulty(tip));\n+    obj.pushKV(\"time\",                  (int64_t)tip->nTime);\n     obj.pushKV(\"mediantime\",            (int64_t)tip->GetMedianTimePast());\n     obj.pushKV(\"verificationprogress\",  GuessVerificationProgress(Params().TxData(), tip));\n     obj.pushKV(\"initialblockdownload\",  active_chainstate.IsInitialBlockDownload());"
      },
      {
        "sha": "692096367c8ed2b422a81cdd81652989eb73dd3e",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -850,7 +850,7 @@ static RPCHelpMan getblocktemplate()\n             case ThresholdState::LOCKED_IN:\n                 // Ensure bit is set in block version\n                 pblock->nVersion |= g_versionbitscache.Mask(consensusParams, pos);\n-                // FALL THROUGH to get vbavailable set...\n+                [[fallthrough]];\n             case ThresholdState::STARTED:\n             {\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];"
      },
      {
        "sha": "1a94abf6d3aabfb62ad1fdc908b5374a4e80e42a",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -24,6 +24,7 @@\n #include <util/strencodings.h>\n #include <util/system.h>\n \n+#include <optional>\n #include <stdint.h>\n #include <tuple>\n #ifdef HAVE_MALLOC_INFO\n@@ -128,12 +129,13 @@ static RPCHelpMan createmultisig()\n     // Get the output type\n     OutputType output_type = OutputType::LEGACY;\n     if (!request.params[2].isNull()) {\n-        if (!ParseOutputType(request.params[2].get_str(), output_type)) {\n+        std::optional<OutputType> parsed = ParseOutputType(request.params[2].get_str());\n+        if (!parsed) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[2].get_str()));\n-        }\n-        if (output_type == OutputType::BECH32M) {\n+        } else if (parsed.value() == OutputType::BECH32M) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"createmultisig cannot create bech32m multisig addresses\");\n         }\n+        output_type = parsed.value();\n     }\n \n     // Construct using pay-to-script-hash:"
      },
      {
        "sha": "abc9ec3ce34f54d8a23b7dc0214056f95249b2ff",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -150,6 +150,7 @@ static RPCHelpMan getpeerinfo()\n                             {\n                                 {RPCResult::Type::NUM, \"n\", \"The heights of blocks we're currently asking from this peer\"},\n                             }},\n+                            {RPCResult::Type::BOOL, \"addr_relay_enabled\", \"Whether we participate in address relay with this peer\"},\n                             {RPCResult::Type::ARR, \"permissions\", \"Any special permissions that have been granted to this peer\",\n                             {\n                                 {RPCResult::Type::STR, \"permission_type\", Join(NET_PERMISSIONS_DOC, \",\\n\") + \".\\n\"},\n@@ -242,6 +243,9 @@ static RPCHelpMan getpeerinfo()\n                 heights.push_back(height);\n             }\n             obj.pushKV(\"inflight\", heights);\n+            obj.pushKV(\"addr_relay_enabled\", statestats.m_addr_relay_enabled);\n+            obj.pushKV(\"addr_processed\", statestats.m_addr_processed);\n+            obj.pushKV(\"addr_rate_limited\", statestats.m_addr_rate_limited);\n         }\n         UniValue permissions(UniValue::VARR);\n         for (const auto& permission : NetPermissions::ToStrings(stats.m_permissionFlags)) {\n@@ -337,7 +341,7 @@ static RPCHelpMan addconnection()\n         \"\\nOpen an outbound connection to a specified node. This RPC is for testing only.\\n\",\n         {\n             {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address and port to attempt connecting to.\"},\n-            {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open, either \\\"outbound-full-relay\\\" or \\\"block-relay-only\\\".\"},\n+            {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open (\\\"outbound-full-relay\\\", \\\"block-relay-only\\\" or \\\"addr-fetch\\\").\"},\n         },\n         RPCResult{\n             RPCResult::Type::OBJ, \"\", \"\",\n@@ -363,6 +367,8 @@ static RPCHelpMan addconnection()\n         conn_type = ConnectionType::OUTBOUND_FULL_RELAY;\n     } else if (conn_type_in == \"block-relay-only\") {\n         conn_type = ConnectionType::BLOCK_RELAY;\n+    } else if (conn_type_in == \"addr-fetch\") {\n+        conn_type = ConnectionType::ADDR_FETCH;\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }"
      },
      {
        "sha": "c617b0389cf0ed9fab01089d820fc4353c92bcd5",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -74,12 +74,10 @@ static RPCHelpMan getrawtransaction()\n                 \"getrawtransaction\",\n                 \"\\nReturn the raw transaction data.\\n\"\n \n-                \"\\nBy default this function only works for mempool transactions. When called with a blockhash\\n\"\n-                \"argument, getrawtransaction will return the transaction if the specified block is available and\\n\"\n-                \"the transaction is found in that block. When called without a blockhash argument, getrawtransaction\\n\"\n-                \"will return the transaction if it is in the mempool, or if -txindex is enabled and the transaction\\n\"\n-                \"is in a block in the blockchain.\\n\"\n-\n+                \"\\nBy default, this call only returns a transaction if it is in the mempool. If -txindex is enabled\\n\"\n+                \"and no blockhash argument is passed, it will return the transaction if it is in the mempool or any block.\\n\"\n+                \"If a blockhash argument is passed, it will return the transaction if\\n\"\n+                \"the specified block is available and the transaction is in that block.\\n\"\n                 \"\\nHint: Use gettransaction for wallet transactions.\\n\"\n \n                 \"\\nIf verbose is 'true', returns an Object with information about 'txid'.\\n\""
      },
      {
        "sha": "dd7c0a4a0510147c1b3cb05c75f80b4c87a52fd6",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1807,16 +1807,16 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& exec_script, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n     if (sigversion == SigVersion::TAPSCRIPT) {\n         // OP_SUCCESSx processing overrides everything, including stack element size limits\n-        CScript::const_iterator pc = scriptPubKey.begin();\n-        while (pc < scriptPubKey.end()) {\n+        CScript::const_iterator pc = exec_script.begin();\n+        while (pc < exec_script.end()) {\n             opcodetype opcode;\n-            if (!scriptPubKey.GetOp(pc, opcode)) {\n+            if (!exec_script.GetOp(pc, opcode)) {\n                 // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n                 return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n             }\n@@ -1839,7 +1839,7 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\n+    if (!EvalScript(stack, exec_script, flags, checker, sigversion, execdata, serror)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);"
      },
      {
        "sha": "93136a0b79d7ec9e089b22cd664dc9ee02ecf7e5",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -39,8 +39,7 @@ enum\n  *  All flags are intended to be soft forks: the set of acceptable scripts under\n  *  flags (A | B) is a subset of the acceptable scripts under flag (A).\n  */\n-enum\n-{\n+enum : uint32_t {\n     SCRIPT_VERIFY_NONE      = 0,\n \n     // Evaluate P2SH subscripts (BIP16).\n@@ -140,6 +139,10 @@ enum\n \n     // Making unknown public key versions (in BIP 342 scripts) non-standard\n     SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n+\n+    // Constants to point to the highest flag in use. Add new flags above this line.\n+    //\n+    SCRIPT_VERIFY_END_MARKER\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "7864e690d8d111d8585460a285e9c59ef3125ff7",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -612,15 +612,18 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n \n bool IsSegWitOutput(const SigningProvider& provider, const CScript& script)\n {\n-    std::vector<valtype> solutions;\n-    auto whichtype = Solver(script, solutions);\n-    if (whichtype == TxoutType::WITNESS_V0_SCRIPTHASH || whichtype == TxoutType::WITNESS_V0_KEYHASH || whichtype == TxoutType::WITNESS_UNKNOWN) return true;\n-    if (whichtype == TxoutType::SCRIPTHASH) {\n-        auto h160 = uint160(solutions[0]);\n-        CScript subscript;\n-        if (provider.GetCScript(CScriptID{h160}, subscript)) {\n-            whichtype = Solver(subscript, solutions);\n-            if (whichtype == TxoutType::WITNESS_V0_SCRIPTHASH || whichtype == TxoutType::WITNESS_V0_KEYHASH || whichtype == TxoutType::WITNESS_UNKNOWN) return true;\n+    int version;\n+    valtype program;\n+    if (script.IsWitnessProgram(version, program)) return true;\n+    if (script.IsPayToScriptHash()) {\n+        std::vector<valtype> solutions;\n+        auto whichtype = Solver(script, solutions);\n+        if (whichtype == TxoutType::SCRIPTHASH) {\n+            auto h160 = uint160(solutions[0]);\n+            CScript subscript;\n+            if (provider.GetCScript(CScriptID{h160}, subscript)) {\n+                if (subscript.IsWitnessProgram(version, program)) return true;\n+            }\n         }\n     }\n     return false;"
      },
      {
        "sha": "bf71a70839f59a3b3c67dbba0979843efb6bc6d9",
        "filename": "src/secp256k1/.cirrus.yml",
        "status": "modified",
        "additions": 173,
        "deletions": 29,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.cirrus.yml?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,21 +1,28 @@\n env:\n-  WIDEMUL: auto\n+  ### compiler options\n+  HOST:\n+  # Specific warnings can be disabled with -Wno-error=foo.\n+  # -pedantic-errors is not equivalent to -Werror=pedantic and thus not implied by -Werror according to the GCC manual.\n+  WERROR_CFLAGS: -Werror -pedantic-errors\n+  MAKEFLAGS: -j2\n+  BUILD: check\n+  ### secp256k1 config\n   STATICPRECOMPUTATION: yes\n   ECMULTGENPRECISION: auto\n   ASM: no\n-  BUILD: check\n+  WIDEMUL: auto\n   WITH_VALGRIND: yes\n-  RUN_VALGRIND: no\n   EXTRAFLAGS:\n-  HOST:\n+  ### secp256k1 modules\n+  EXPERIMENTAL: no\n   ECDH: no\n   RECOVERY: no\n   SCHNORRSIG: no\n-  EXPERIMENTAL: no\n-  CTIMETEST: yes\n+  ### test options\n+  TEST_ITERS:\n   BENCH: yes\n-  ITERS: 2\n-  MAKEFLAGS: -j2\n+  BENCH_ITERS: 2\n+  CTIMETEST: yes\n \n cat_logs_snippet: &CAT_LOGS\n   always:\n@@ -63,27 +70,8 @@ task:\n     - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n     - env: {CPPFLAGS: -DDETERMINISTIC}\n     - env: {CFLAGS: -O0, CTIMETEST: no}\n-    - env:\n-        CFLAGS:  \"-fsanitize=undefined -fno-omit-frame-pointer\"\n-        LDFLAGS: \"-fsanitize=undefined -fno-omit-frame-pointer\"\n-        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n-        ASM: x86_64\n-        ECDH: yes\n-        RECOVERY: yes\n-        EXPERIMENTAL: yes\n-        SCHNORRSIG: yes\n-        CTIMETEST: no\n     - env: { ECMULTGENPRECISION: 2 }\n     - env: { ECMULTGENPRECISION: 8 }\n-    - env:\n-        RUN_VALGRIND: yes\n-        ASM: x86_64\n-        ECDH: yes\n-        RECOVERY: yes\n-        EXPERIMENTAL: yes\n-        SCHNORRSIG: yes\n-        EXTRAFLAGS: \"--disable-openssl-tests\"\n-        BUILD:\n   matrix:\n     - env:\n         CC: gcc\n@@ -111,6 +99,7 @@ task:\n         CC: i686-linux-gnu-gcc\n     - env:\n         CC: clang --target=i686-pc-linux-gnu -isystem /usr/i686-linux-gnu/include\n+  << : *MERGE_BASE\n   test_script:\n     - ./ci/cirrus.sh\n   << : *CAT_LOGS\n@@ -181,9 +170,9 @@ task:\n     cpu: 1\n     memory: 1G\n   env:\n-    QEMU_CMD: qemu-s390x\n+    WRAPPER_CMD: qemu-s390x\n+    TEST_ITERS: 16\n     HOST: s390x-linux-gnu\n-    BUILD:\n     WITH_VALGRIND: no\n     ECDH: yes\n     RECOVERY: yes\n@@ -196,3 +185,158 @@ task:\n     - rm /etc/ld.so.cache\n     - ./ci/cirrus.sh\n   << : *CAT_LOGS\n+\n+task:\n+  name: \"ARM32: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-arm\n+    TEST_ITERS: 16\n+    HOST: arm-linux-gnueabihf\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  matrix:\n+    - env: {}\n+    - env: {ASM: arm}\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"ARM64: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-aarch64\n+    TEST_ITERS: 16\n+    HOST: aarch64-linux-gnu\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"ppc64le: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-ppc64le\n+    TEST_ITERS: 16\n+    HOST: powerpc64le-linux-gnu\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"x86_64 (mingw32-w64): Windows (Debian stable, Wine)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: wine64-stable\n+    TEST_ITERS: 16\n+    HOST: x86_64-w64-mingw32\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+# Sanitizers\n+task:\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+    EXTRAFLAGS: \"--disable-openssl-tests\"\n+  matrix:\n+    - name: \"Valgrind (memcheck)\"\n+      env:\n+        # The `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n+        WRAPPER_CMD: \"valgrind --error-exitcode=42\"\n+        TEST_ITERS: 16\n+    - name: \"UBSan, ASan, LSan\"\n+      env:\n+        CFLAGS: \"-fsanitize=undefined,address\"\n+        CFLAGS_FOR_BUILD: \"-fsanitize=undefined,address\"\n+        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n+        ASAN_OPTIONS: \"strict_string_checks=1:detect_stack_use_after_return=1:detect_leaks=1\"\n+        LSAN_OPTIONS: \"use_unaligned=1\"\n+        TEST_ITERS: 32\n+  # Try to cover many configurations with just a tiny matrix.\n+  matrix:\n+    - env:\n+        ASM: auto\n+        STATICPRECOMPUTATION: yes\n+    - env:\n+        ASM: no\n+        STATICPRECOMPUTATION: no\n+        ECMULTGENPRECISION: 2\n+  matrix:\n+    - env:\n+        CC: clang\n+    - env:\n+        HOST: i686-linux-gnu\n+        CC: i686-linux-gnu-gcc\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"C++ -fpermissive\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    # ./configure correctly errors out when given CC=g++.\n+    # We hack around this by passing CC=g++ only to make.\n+    CC: gcc\n+    MAKEFLAGS: -j2 CC=g++ CFLAGS=-fpermissive\n+    WERROR_CFLAGS:\n+    EXPERIMENTAL: yes\n+    ECDH: yes\n+    RECOVERY: yes\n+    SCHNORRSIG: yes\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS"
      },
      {
        "sha": "79b740db8ae3552dade638d75f0f343f8bc15a8c",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -23,6 +23,7 @@ aclocal.m4\n autom4te.cache/\n config.log\n config.status\n+conftest*\n *.tar.gz\n *.la\n libtool\n@@ -33,6 +34,14 @@ libtool\n *~\n *.log\n *.trs\n+\n+coverage/\n+coverage.html\n+coverage.*.html\n+*.gcda\n+*.gcno\n+*.gcov\n+\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h"
      },
      {
        "sha": "1e0356088433883d85a9884209e5c2d07fe01d5a",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,5 +1,9 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n+# AM_CFLAGS will be automatically prepended to CFLAGS by Automake when compiling some foo\n+# which does not have an explicit foo_CFLAGS variable set.\n+AM_CFLAGS = $(SECP_CFLAGS)\n+\n lib_LTLIBRARIES = libsecp256k1.la\n include_HEADERS = include/secp256k1.h\n include_HEADERS += include/secp256k1_preallocated.h\n@@ -68,7 +72,7 @@ endif\n endif\n \n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n libsecp256k1_la_LIBADD = $(SECP_LIBS) $(COMMON_LIB)\n \n if VALGRIND_ENABLED\n@@ -81,27 +85,27 @@ noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n # SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n-bench_verify_CPPFLAGS = -DSECP256K1_BUILD $(SECP_TEST_INCLUDES)\n+bench_verify_CPPFLAGS = $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n-bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n bench_ecmult_SOURCES = src/bench_ecmult.c\n bench_ecmult_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n-bench_ecmult_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_ecmult_CPPFLAGS = $(SECP_INCLUDES)\n endif\n \n TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n@@ -114,7 +118,7 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -I$(top_srcdir)/src $(SECP_INCLUDES)\n if !ENABLE_COVERAGE\n exhaustive_tests_CPPFLAGS += -DVERIFY\n endif\n@@ -129,10 +133,10 @@ CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n-\t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n+\t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n-\t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n+\t$(CC_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n \n $(libsecp256k1_la_OBJECTS): src/ecmult_static_context.h\n $(tests_OBJECTS): src/ecmult_static_context.h"
      },
      {
        "sha": "182c29d9ce5ef58e9c753b1d54b3c0b0a2b6bd6a",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -17,6 +17,7 @@ Features:\n * Suitable for embedded systems.\n * Optional module for public key recovery.\n * Optional module for ECDH key exchange.\n+* Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) (experimental).\n \n Experimental features have not received enough scrutiny to satisfy the standard of quality of this library but are made available for testing and review by the community. The APIs of these features should not be considered stable.\n \n@@ -96,7 +97,8 @@ To create a report, `gcovr` is recommended, as it includes branch coverage repor\n \n To create a HTML report with coloured and annotated source code:\n \n-    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage.html\n+    $ mkdir -p coverage\n+    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage/coverage.html\n \n Reporting a vulnerability\n ------------"
      },
      {
        "sha": "8245b2b8635200093b17ba856025f8b6e862cdda",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -82,3 +82,19 @@ if test x\"$has_valgrind\" != x\"yes\"; then\n   AC_CHECK_HEADER([valgrind/memcheck.h], [has_valgrind=yes; AC_DEFINE(HAVE_VALGRIND,1,[Define this symbol if valgrind is installed])])\n fi\n ])\n+\n+dnl SECP_TRY_APPEND_CFLAGS(flags, VAR)\n+dnl Append flags to VAR if CC accepts them.\n+AC_DEFUN([SECP_TRY_APPEND_CFLAGS], [\n+  AC_MSG_CHECKING([if ${CC} supports $1])\n+  SECP_TRY_APPEND_CFLAGS_saved_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$1 $CFLAGS\"\n+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])], [flag_works=yes], [flag_works=no])\n+  AC_MSG_RESULT($flag_works)\n+  CFLAGS=\"$SECP_TRY_APPEND_CFLAGS_saved_CFLAGS\"\n+  if test x\"$flag_works\" = x\"yes\"; then\n+    $2=\"$$2 $1\"\n+  fi\n+  unset flag_works\n+  AC_SUBST($2)\n+])"
      },
      {
        "sha": "27db1e6779fa621150ccd0c1c64c93f2a39f6317",
        "filename": "src/secp256k1/ci/cirrus.sh",
        "status": "modified",
        "additions": 9,
        "deletions": 24,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/cirrus.sh?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -25,42 +25,27 @@ valgrind --version || true\n make\n \n # Print information about binaries so that we can see that the architecture is correct\n-file *tests || true\n+file *tests* || true\n file bench_* || true\n file .libs/* || true\n \n-if [ -n \"$BUILD\" ]\n-then\n-    make \"$BUILD\"\n-fi\n+# This tells `make check` to wrap test invocations.\n+export LOG_COMPILER=\"$WRAPPER_CMD\"\n \n-if [ \"$RUN_VALGRIND\" = \"yes\" ]\n-then\n-    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n-    valgrind --error-exitcode=42 ./tests 16\n-    valgrind --error-exitcode=42 ./exhaustive_tests\n-fi\n+# This limits the iterations in the tests and benchmarks.\n+export SECP256K1_TEST_ITERS=\"$TEST_ITERS\"\n+export SECP256K1_BENCH_ITERS=\"$BENCH_ITERS\"\n \n-if [ -n \"$QEMU_CMD\" ]\n-then\n-    $QEMU_CMD ./tests 16\n-    $QEMU_CMD ./exhaustive_tests\n-fi\n+make \"$BUILD\"\n \n if [ \"$BENCH\" = \"yes\" ]\n then\n     # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n     EXEC='./libtool --mode=execute'\n-    if [ -n \"$QEMU_CMD\" ]\n-    then\n-       EXEC=\"$EXEC $QEMU_CMD\"\n-    fi\n-    if [ \"$RUN_VALGRIND\" = \"yes\" ]\n+    if [ -n \"$WRAPPER_CMD\" ]\n     then\n-        EXEC=\"$EXEC valgrind --error-exitcode=42\"\n+        EXEC=\"$EXEC $WRAPPER_CMD\"\n     fi\n-    # This limits the iterations in the benchmarks below to ITER iterations.\n-    export SECP256K1_BENCH_ITERS=\"$ITERS\"\n     {\n         $EXEC ./bench_ecmult\n         $EXEC ./bench_internal"
      },
      {
        "sha": "2c02ed69d03f8a9cbf6bfa38f8f1b77cb0bb3d21",
        "filename": "src/secp256k1/ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/linux-debian.Dockerfile?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -2,12 +2,24 @@ FROM debian:stable\n \n RUN dpkg --add-architecture i386\n RUN dpkg --add-architecture s390x\n+RUN dpkg --add-architecture armhf\n+RUN dpkg --add-architecture arm64\n+RUN dpkg --add-architecture ppc64el\n RUN apt-get update\n \n # dkpg-dev: to make pkg-config work in cross-builds\n+# llvm: for llvm-symbolizer, which is used by clang's UBSan for symbolized stack traces\n RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         git ca-certificates \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n-        gcc clang libc6-dbg \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 \\\n-        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x\n+        gcc clang llvm libc6-dbg \\\n+        g++ \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n+        gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n+        gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\\n+        gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross libc6-dbg:ppc64el \\\n+        wine gcc-mingw-w64-x86-64\n+\n+# Run a dummy command in wine to make it set up configuration\n+RUN wine64-stable xcopy || true"
      },
      {
        "sha": "9969cfa343226f06cdb8899929fb3a96929332ee",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 62,
        "deletions": 58,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,10 +8,6 @@ AH_TOP([#define LIBSECP256K1_CONFIG_H])\n AH_BOTTOM([#endif /*LIBSECP256K1_CONFIG_H*/])\n AM_INIT_AUTOMAKE([foreign subdir-objects])\n \n-# Set -g if CFLAGS are not already set, which matches the default autoconf\n-# behavior (see PROG_CC in the Autoconf manual) with the exception that we don't\n-# set -O2 here because we set it in any case (see further down).\n-: ${CFLAGS=\"-g\"}\n LT_INIT\n \n # Make the compilation flags quiet unless V=1 is used.\n@@ -42,8 +38,8 @@ AM_PROG_AS\n case $host_os in\n   *darwin*)\n      if  test x$cross_compiling != xyes; then\n-       AC_PATH_PROG([BREW],brew,)\n-       if test x$BREW != x; then\n+       AC_CHECK_PROG([BREW], brew, brew)\n+       if test x$BREW = xbrew; then\n          # These Homebrew packages may be keg-only, meaning that they won't be found\n          # in expected paths because they may conflict with system files. Ask\n          # Homebrew where each one is located, then adjust paths accordingly.\n@@ -58,10 +54,10 @@ case $host_os in\n            VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n        else\n-         AC_PATH_PROG([PORT],port,)\n+         AC_CHECK_PROG([PORT], port, port)\n          # If homebrew isn't installed and macports is, add the macports default paths\n          # as a last resort.\n-         if test x$PORT != x; then\n+         if test x$PORT = xport; then\n            CPPFLAGS=\"$CPPFLAGS -isystem /opt/local/include\"\n            LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n          fi\n@@ -70,35 +66,41 @@ case $host_os in\n    ;;\n esac\n \n-CFLAGS=\"-W $CFLAGS\"\n-\n-warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n-\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"-Wconditional-uninitialized $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports -Wconditional-uninitialized])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n-\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n+# Try if some desirable compiler flags are supported and append them to SECP_CFLAGS.\n+#\n+# These are our own flags, so we append them to our own SECP_CFLAGS variable (instead of CFLAGS) as\n+# recommended in the automake manual (Section \"Flag Variables Ordering\"). CFLAGS belongs to the user\n+# and we are not supposed to touch it. In the Makefile, we will need to ensure that SECP_CFLAGS\n+# is prepended to CFLAGS when invoking the compiler so that the user always has the last word (flag).\n+#\n+# Another advantage of not touching CFLAGS is that the contents of CFLAGS will be picked up by\n+# libtool for compiling helper executables. For example, when compiling for Windows, libtool will\n+# generate entire wrapper executables (instead of simple wrapper scripts as on Unix) to ensure\n+# proper operation of uninstalled programs linked by libtool against the uninstalled shared library.\n+# These executables are compiled from C source file for which our flags may not be appropriate,\n+# e.g., -std=c89 flag has lead to undesirable warnings in the past.\n+#\n+# TODO We should analogously not touch CPPFLAGS and LDFLAGS but currently there are no issues.\n+AC_DEFUN([SECP_TRY_APPEND_DEFAULT_CFLAGS], [\n+    # Try to append -Werror=unknown-warning-option to CFLAGS temporarily. Otherwise clang will\n+    # not error out if it gets unknown warning flags and the checks here will always succeed\n+    # no matter if clang knows the flag or not.\n+    SECP_TRY_APPEND_DEFAULT_CFLAGS_saved_CFLAGS=\"$CFLAGS\"\n+    SECP_TRY_APPEND_CFLAGS([-Werror=unknown-warning-option], CFLAGS)\n+\n+    SECP_TRY_APPEND_CFLAGS([-std=c89 -pedantic -Wno-long-long -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef], $1) # GCC >= 3.0, -Wlong-long is implied by -pedantic.\n+    SECP_TRY_APPEND_CFLAGS([-Wno-overlength-strings], $1) # GCC >= 4.2, -Woverlength-strings is implied by -pedantic.\n+    SECP_TRY_APPEND_CFLAGS([-Wall], $1) # GCC >= 2.95 and probably many other compilers\n+    SECP_TRY_APPEND_CFLAGS([-Wno-unused-function], $1) # GCC >= 3.0, -Wunused-function is implied by -Wall.\n+    SECP_TRY_APPEND_CFLAGS([-Wextra], $1) # GCC >= 3.4, this is the newer name of -W, which we don't use because older GCCs will warn about unused functions.\n+    SECP_TRY_APPEND_CFLAGS([-Wcast-align], $1) # GCC >= 2.95\n+    SECP_TRY_APPEND_CFLAGS([-Wcast-align=strict], $1) # GCC >= 8.0\n+    SECP_TRY_APPEND_CFLAGS([-Wconditional-uninitialized], $1) # Clang >= 3.0 only\n+    SECP_TRY_APPEND_CFLAGS([-fvisibility=hidden], $1) # GCC >= 4.0\n+\n+    CFLAGS=\"$SECP_TRY_APPEND_DEFAULT_CFLAGS_saved_CFLAGS\"\n+])\n+SECP_TRY_APPEND_DEFAULT_CFLAGS(SECP_CFLAGS)\n \n ###\n ### Define config arguments\n@@ -213,10 +215,14 @@ AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n-    CFLAGS=\"-O0 --coverage $CFLAGS\"\n+    SECP_CFLAGS=\"-O0 --coverage $SECP_CFLAGS\"\n     LDFLAGS=\"--coverage $LDFLAGS\"\n else\n-    CFLAGS=\"-O2 $CFLAGS\"\n+    # Most likely the CFLAGS already contain -O2 because that is autoconf's default.\n+    # We still add it here because passing it twice is not an issue, and handling\n+    # this case would just add unnecessary complexity (see #896).\n+    SECP_CFLAGS=\"-O2 $SECP_CFLAGS\"\n+    SECP_CFLAGS_FOR_BUILD=\"-O2 $SECP_CFLAGS_FOR_BUILD\"\n fi\n \n if test x\"$req_asm\" = x\"auto\"; then\n@@ -351,6 +357,9 @@ if test x\"$enable_valgrind\" = x\"yes\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n fi\n \n+# Add -Werror and similar flags passed from the outside (for testing, e.g., in CI)\n+SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n+\n # Handle static precomputation (after everything which modifies CFLAGS and friends)\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   if test x\"$cross_compiling\" = x\"no\"; then\n@@ -360,8 +369,9 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n     fi\n     # If we're not cross-compiling, simply use the same compiler for building the static precompation code.\n     CC_FOR_BUILD=\"$CC\"\n-    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n     CPPFLAGS_FOR_BUILD=\"$CPPFLAGS\"\n+    SECP_CFLAGS_FOR_BUILD=\"$SECP_CFLAGS\"\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n     LDFLAGS_FOR_BUILD=\"$LDFLAGS\"\n   else\n     AX_PROG_CC_FOR_BUILD\n@@ -371,42 +381,32 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n     cross_compiling=no\n     SAVE_CC=\"$CC\"\n     CC=\"$CC_FOR_BUILD\"\n-    SAVE_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n     SAVE_CPPFLAGS=\"$CPPFLAGS\"\n     CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+    SAVE_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n     SAVE_LDFLAGS=\"$LDFLAGS\"\n     LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n \n-    warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n-    saved_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n-    AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n-    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-        [ AC_MSG_RESULT([yes]) ],\n-        [ AC_MSG_RESULT([no])\n-          CFLAGS=\"$saved_CFLAGS\"\n-        ])\n+    SECP_TRY_APPEND_DEFAULT_CFLAGS(SECP_CFLAGS_FOR_BUILD)\n \n     AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n     AC_RUN_IFELSE(\n       [AC_LANG_PROGRAM([], [])],\n       [working_native_cc=yes],\n       [working_native_cc=no],[:])\n \n-    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n-\n     # Restore the environment\n     cross_compiling=$save_cross_compiling\n     CC=\"$SAVE_CC\"\n-    CFLAGS=\"$SAVE_CFLAGS\"\n     CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+    CFLAGS=\"$SAVE_CFLAGS\"\n     LDFLAGS=\"$SAVE_LDFLAGS\"\n \n     if test x\"$working_native_cc\" = x\"no\"; then\n       AC_MSG_RESULT([no])\n       set_precomp=no\n-      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n+      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CPPFLAGS_FOR_BUILD, CFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n       if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n         AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n       else\n@@ -419,8 +419,9 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   fi\n \n   AC_SUBST(CC_FOR_BUILD)\n-  AC_SUBST(CFLAGS_FOR_BUILD)\n   AC_SUBST(CPPFLAGS_FOR_BUILD)\n+  AC_SUBST(SECP_CFLAGS_FOR_BUILD)\n+  AC_SUBST(CFLAGS_FOR_BUILD)\n   AC_SUBST(LDFLAGS_FOR_BUILD)\n else\n   set_precomp=no\n@@ -490,6 +491,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AC_SUBST(SECP_CFLAGS)\n AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n@@ -532,13 +534,15 @@ fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\"\n-echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  SECP_CFLAGS             = $SECP_CFLAGS\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  LDFLAGS                 = $LDFLAGS\"\n echo\n if test x\"$set_precomp\" = x\"yes\"; then\n echo \"  CC_FOR_BUILD            = $CC_FOR_BUILD\"\n-echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n echo \"  CPPFLAGS_FOR_BUILD      = $CPPFLAGS_FOR_BUILD\"\n+echo \"  SECP_CFLAGS_FOR_BUILD   = $SECP_CFLAGS_FOR_BUILD\"\n+echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n echo \"  LDFLAGS_FOR_BUILD       = $LDFLAGS_FOR_BUILD\"\n fi"
      },
      {
        "sha": "bf562303edd9b11ad499fd6c9e4cbdbfc441a8c9",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -5,7 +5,6 @@\n  ***********************************************************************/\n \n #include <string.h>\n-#include <secp256k1.h>\n \n #include \"lax_der_parsing.h\"\n \n@@ -121,7 +120,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     /* Copy R value */\n     if (rlen > 32) {\n         overflow = 1;\n-    } else {\n+    } else if (rlen) {\n         memcpy(tmpsig + 32 - rlen, input + rpos, rlen);\n     }\n \n@@ -133,7 +132,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     /* Copy S value */\n     if (slen > 32) {\n         overflow = 1;\n-    } else {\n+    } else if (slen) {\n         memcpy(tmpsig + 64 - slen, input + spos, slen);\n     }\n "
      },
      {
        "sha": "034a38e6a0e1d0fb303c78bb9fd0ac20ecd44358",
        "filename": "src/secp256k1/contrib/lax_der_parsing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -51,7 +51,13 @@\n #ifndef SECP256K1_CONTRIB_LAX_DER_PARSING_H\n #define SECP256K1_CONTRIB_LAX_DER_PARSING_H\n \n+/* #include secp256k1.h only when it hasn't been included yet.\n+   This enables this file to be #included directly in other project\n+   files (such as tests.c) without the need to set an explicit -I flag,\n+   which would be necessary to locate secp256k1.h. */\n+#ifndef SECP256K1_H\n #include <secp256k1.h>\n+#endif\n \n #ifdef __cplusplus\n extern \"C\" {"
      },
      {
        "sha": "a1b8200079e144468d226d203b441bf86c695070",
        "filename": "src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_privatekey_parsing.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -5,7 +5,6 @@\n  ***********************************************************************/\n \n #include <string.h>\n-#include <secp256k1.h>\n \n #include \"lax_der_privatekey_parsing.h\"\n \n@@ -45,7 +44,7 @@ int ec_privkey_import_der(const secp256k1_context* ctx, unsigned char *out32, co\n     if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1]) {\n         return 0;\n     }\n-    memcpy(out32 + 32 - privkey[1], privkey + 2, privkey[1]);\n+    if (privkey[1]) memcpy(out32 + 32 - privkey[1], privkey + 2, privkey[1]);\n     if (!secp256k1_ec_seckey_verify(ctx, out32)) {\n         memset(out32, 0, 32);\n         return 0;"
      },
      {
        "sha": "1a8ad8ae0c3b0835d19c4c7cc7df519557a1c33d",
        "filename": "src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_privatekey_parsing.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -28,7 +28,13 @@\n #ifndef SECP256K1_CONTRIB_BER_PRIVATEKEY_H\n #define SECP256K1_CONTRIB_BER_PRIVATEKEY_H\n \n+/* #include secp256k1.h only when it hasn't been included yet.\n+   This enables this file to be #included directly in other project\n+   files (such as tests.c) without the need to set an explicit -I flag,\n+   which would be necessary to locate secp256k1.h. */\n+#ifndef SECP256K1_H\n #include <secp256k1.h>\n+#endif\n \n #ifdef __cplusplus\n extern \"C\" {"
      },
      {
        "sha": "7be7fd57233af86a6ce1a3fdc6cf1a076a425f82",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 57,
        "deletions": 3,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,7 +7,9 @@ extern \"C\" {\n \n #include <stddef.h>\n \n-/* These rules specify the order of arguments in API calls:\n+/* Unless explicitly stated all pointer arguments must not be NULL.\n+ *\n+ * The following rules specify the order of arguments in API calls:\n  *\n  * 1. Context pointers go first, followed by output arguments, combined\n  *    output/input arguments, and finally input-only arguments.\n@@ -61,8 +63,9 @@ typedef struct secp256k1_scratch_space_struct secp256k1_scratch_space;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage, transmission, or\n- *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n+ *  If you need to convert to a format suitable for storage or transmission,\n+ *  use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse. To\n+ *  compare keys, use secp256k1_ec_pubkey_cmp.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -127,6 +130,17 @@ typedef int (*secp256k1_nonce_function)(\n #  define SECP256K1_INLINE inline\n # endif\n \n+/** When this header is used at build-time the SECP256K1_BUILD define needs to be set\n+ *  to correctly setup export attributes and nullness checks.  This is normally done\n+ *  by secp256k1.c but to guard against this header being included before secp256k1.c\n+ *  has had a chance to set the define (e.g. via test harnesses that just includes\n+ *  secp256k1.c) we set SECP256K1_NO_BUILD when this header is processed without the\n+ *  BUILD define so this condition can be caught.\n+ */\n+#ifndef SECP256K1_BUILD\n+# define SECP256K1_NO_BUILD\n+#endif\n+\n #ifndef SECP256K1_API\n # if defined(_WIN32)\n #  ifdef SECP256K1_BUILD\n@@ -370,6 +384,21 @@ SECP256K1_API int secp256k1_ec_pubkey_serialize(\n     unsigned int flags\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Compare two public keys using lexicographic (of compressed serialization) order\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_cmp(\n+    const secp256k1_context* ctx,\n+    const secp256k1_pubkey* pubkey1,\n+    const secp256k1_pubkey* pubkey2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Parse an ECDSA signature in compact (64 bytes) format.\n  *\n  *  Returns: 1 when the signature could be parsed, 0 otherwise.\n@@ -764,6 +793,31 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compute a tagged hash as defined in BIP-340.\n+ *\n+ *  This is useful for creating a message hash and achieving domain separation\n+ *  through an application-specific tag. This function returns\n+ *  SHA256(SHA256(tag)||SHA256(tag)||msg). Therefore, tagged hash\n+ *  implementations optimized for a specific tag can precompute the SHA256 state\n+ *  after hashing the tag hashes.\n+ *\n+ *  Returns 0 if the arguments are invalid and 1 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:  hash32: pointer to a 32-byte array to store the resulting hash\n+ *  In:      tag: pointer to an array containing the tag\n+ *        taglen: length of the tag array\n+ *           msg: pointer to an array containing the message\n+ *        msglen: length of the message array\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_tagged_sha256(\n+    const secp256k1_context* ctx,\n+    unsigned char *hash32,\n+    const unsigned char *tag,\n+    size_t taglen,\n+    const unsigned char *msg,\n+    size_t msglen\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n #ifdef __cplusplus\n }\n #endif"
      },
      {
        "sha": "0a37fb6b9d31809fed5e674c2e035d80ea2db7d8",
        "filename": "src/secp256k1/include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 18,
        "deletions": 3,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_extrakeys.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -15,9 +15,9 @@ extern \"C\" {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage, transmission, or\n- *  comparison, use secp256k1_xonly_pubkey_serialize and\n- *  secp256k1_xonly_pubkey_parse.\n+ *  If you need to convert to a format suitable for storage, transmission, use\n+ *  use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse. To\n+ *  compare keys, use secp256k1_xonly_pubkey_cmp.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -67,6 +67,21 @@ SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_xonly_pubkey* pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two x-only public keys using lexicographic order\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n+    const secp256k1_context* ctx,\n+    const secp256k1_xonly_pubkey* pk1,\n+    const secp256k1_xonly_pubkey* pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n  *\n  *  Returns: 1 if the public key was successfully converted"
      },
      {
        "sha": "74cbcac45ec033aac3509fe718f8d60dc8a3fdf7",
        "filename": "src/secp256k1/include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 87,
        "deletions": 28,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorrsig.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -23,24 +23,29 @@ extern \"C\" {\n  *\n  *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n  *           return an error.\n- *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n- *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n- *           key32:     pointer to a 32-byte secret key (will not be NULL)\n- *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n- *                      (will not be NULL)\n- *           algo16:    pointer to a 16-byte array describing the signature\n- *                      algorithm (will not be NULL).\n- *           data:      Arbitrary data pointer that is passed through.\n+ *  Out:  nonce32: pointer to a 32-byte array to be filled by the function\n+ *  In:       msg: the message being verified. Is NULL if and only if msglen\n+ *                 is 0.\n+ *         msglen: the length of the message\n+ *          key32: pointer to a 32-byte secret key (will not be NULL)\n+ *     xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32\n+ *                 (will not be NULL)\n+ *           algo: pointer to an array describing the signature\n+ *                 algorithm (will not be NULL)\n+ *        algolen: the length of the algo array\n+ *           data: arbitrary data pointer that is passed through\n  *\n  *  Except for test cases, this function should compute some cryptographic hash of\n  *  the message, the key, the pubkey, the algorithm description, and data.\n  */\n typedef int (*secp256k1_nonce_function_hardened)(\n     unsigned char *nonce32,\n-    const unsigned char *msg32,\n+    const unsigned char *msg,\n+    size_t msglen,\n     const unsigned char *key32,\n     const unsigned char *xonly_pk32,\n-    const unsigned char *algo16,\n+    const unsigned char *algo,\n+    size_t algolen,\n     void *data\n );\n \n@@ -50,59 +55,113 @@ typedef int (*secp256k1_nonce_function_hardened)(\n  *\n  *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n  *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n- *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n- *  argument must be non-NULL, otherwise the function will fail and return 0.\n- *  The hash will be tagged with algo16 after removing all terminating null\n- *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n- *  to \"BIP0340/nonce\\0\\0\\0\"\n+ *  the nonce derivation procedure follows BIP-340 by setting the auxiliary\n+ *  random data to zero. The algo argument must be non-NULL, otherwise the\n+ *  function will fail and return 0. The hash will be tagged with algo.\n+ *  Therefore, to create BIP-340 compliant signatures, algo must be set to\n+ *  \"BIP0340/nonce\" and algolen to 13.\n  */\n SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n \n+/** Data structure that contains additional arguments for schnorrsig_sign_custom.\n+ *\n+ *  A schnorrsig_extraparams structure object can be initialized correctly by\n+ *  setting it to SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT.\n+ *\n+ *  Members:\n+ *      magic: set to SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC at initialization\n+ *             and has no other function than making sure the object is\n+ *             initialized.\n+ *    noncefp: pointer to a nonce generation function. If NULL,\n+ *             secp256k1_nonce_function_bip340 is used\n+ *      ndata: pointer to arbitrary data used by the nonce generation function\n+ *             (can be NULL). If it is non-NULL and\n+ *             secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *             pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+typedef struct {\n+    unsigned char magic[4];\n+    secp256k1_nonce_function_hardened noncefp;\n+    void* ndata;\n+} secp256k1_schnorrsig_extraparams;\n+\n+#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC { 0xda, 0x6f, 0xb3, 0x8c }\n+#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT {\\\n+    SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC,\\\n+    NULL,\\\n+    NULL\\\n+}\n+\n /** Create a Schnorr signature.\n  *\n  *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n  *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n  *  abort if it fails.\n  *\n- *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n- *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n- *  randomness.\n+ *  This function only signs 32-byte messages. If you have messages of a\n+ *  different size (or the same size but without a context-specific tag\n+ *  prefix), it is recommended to create a 32-byte message hash with\n+ *  secp256k1_tagged_sha256 and then sign the hash. Tagged hashing allows\n+ *  providing an context-specific tag for domain separation. This prevents\n+ *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n  *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n  *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n  *       keypair: pointer to an initialized keypair (cannot be NULL)\n- *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n- *         ndata: pointer to arbitrary data used by the nonce generation\n- *                function (can be NULL). If it is non-NULL and\n- *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n- *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n+ *                this, it is only supplemental to security and can be NULL. See\n+ *                BIP-340 \"Default Signing\" for a full explanation of this\n+ *                argument and for guidance if randomness is expensive.\n  */\n SECP256K1_API int secp256k1_schnorrsig_sign(\n     const secp256k1_context* ctx,\n     unsigned char *sig64,\n     const unsigned char *msg32,\n     const secp256k1_keypair *keypair,\n-    secp256k1_nonce_function_hardened noncefp,\n-    void *ndata\n+    unsigned char *aux_rand32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Create a Schnorr signature with a more flexible API.\n+ *\n+ *  Same arguments as secp256k1_schnorrsig_sign except that it allows signing\n+ *  variable length messages and accepts a pointer to an extraparams object that\n+ *  allows customizing signing by passing additional arguments.\n+ *\n+ *  Creates the same signatures as schnorrsig_sign if msglen is 32 and the\n+ *  extraparams.ndata is the same as aux_rand32.\n+ *\n+ *  In:     msg: the message being signed. Can only be NULL if msglen is 0.\n+ *       msglen: length of the message\n+ *  extraparams: pointer to a extraparams object (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg,\n+    size_t msglen,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_schnorrsig_extraparams *extraparams\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(5);\n+\n /** Verify a Schnorr signature.\n  *\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n  *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n- *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *           msg: the message being verified. Can only be NULL if msglen is 0.\n+ *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n     const secp256k1_context* ctx,\n     const unsigned char *sig64,\n-    const unsigned char *msg32,\n+    const unsigned char *msg,\n+    size_t msglen,\n     const secp256k1_xonly_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(5);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/secp256k1/obj/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60afee48c306cf16a19ea1914f1bae96987f063a/src/secp256k1/obj/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60afee48c306cf16a19ea1914f1bae96987f063a/src/secp256k1/obj/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/obj/.gitignore?ref=60afee48c306cf16a19ea1914f1bae96987f063a"
      },
      {
        "sha": "cb020d26b4d9969cb54c5e4a9c5476bd70090f04",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -6,8 +6,8 @@\n \n #include <string.h>\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_ecdh.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_ecdh.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "1d463f92d0beeaa15732c7a901c524714d148335",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 189,
        "deletions": 35,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -5,7 +5,8 @@\n  ***********************************************************************/\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n \n #include \"util.h\"\n #include \"hash_impl.h\"\n@@ -14,33 +15,177 @@\n #include \"scalar_impl.h\"\n #include \"ecmult_impl.h\"\n #include \"bench.h\"\n-#include \"secp256k1.c\"\n \n #define POINTS 32768\n \n+void help(char **argv) {\n+    printf(\"Benchmark EC multiplication algorithms\\n\");\n+    printf(\"\\n\");\n+    printf(\"Usage: %s <help|pippenger_wnaf|strauss_wnaf|simple>\\n\", argv[0]);\n+    printf(\"The output shows the number of multiplied and summed points right after the\\n\");\n+    printf(\"function name. The letter 'g' indicates that one of the points is the generator.\\n\");\n+    printf(\"The benchmarks are divided by the number of points.\\n\");\n+    printf(\"\\n\");\n+    printf(\"default (ecmult_multi): picks pippenger_wnaf or strauss_wnaf depending on the\\n\");\n+    printf(\"                        batch size\\n\");\n+    printf(\"pippenger_wnaf:         for all batch sizes\\n\");\n+    printf(\"strauss_wnaf:           for all batch sizes\\n\");\n+    printf(\"simple:                 multiply and sum each point individually\\n\");\n+}\n+\n typedef struct {\n     /* Setup once in advance */\n     secp256k1_context* ctx;\n     secp256k1_scratch_space* scratch;\n     secp256k1_scalar* scalars;\n     secp256k1_ge* pubkeys;\n+    secp256k1_gej* pubkeys_gej;\n     secp256k1_scalar* seckeys;\n     secp256k1_gej* expected_output;\n     secp256k1_ecmult_multi_func ecmult_multi;\n \n-    /* Changes per test */\n+    /* Changes per benchmark */\n     size_t count;\n     int includes_g;\n \n-    /* Changes per test iteration */\n+    /* Changes per benchmark iteration, used to pick different scalars and pubkeys\n+     * in each run. */\n     size_t offset1;\n     size_t offset2;\n \n-    /* Test output. */\n+    /* Benchmark output. */\n     secp256k1_gej* output;\n } bench_data;\n \n-static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n+/* Hashes x into [0, POINTS) twice and store the result in offset1 and offset2. */\n+static void hash_into_offset(bench_data* data, size_t x) {\n+    data->offset1 = (x * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (x * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+}\n+\n+/* Check correctness of the benchmark by computing\n+ * sum(outputs) ?= (sum(scalars_gen) + sum(seckeys)*sum(scalars))*G */\n+static void bench_ecmult_teardown_helper(bench_data* data, size_t* seckey_offset, size_t* scalar_offset, size_t* scalar_gen_offset, int iters) {\n+    int i;\n+    secp256k1_gej sum_output, tmp;\n+    secp256k1_scalar sum_scalars;\n+\n+    secp256k1_gej_set_infinity(&sum_output);\n+    secp256k1_scalar_clear(&sum_scalars);\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_gej_add_var(&sum_output, &sum_output, &data->output[i], NULL);\n+        if (scalar_gen_offset != NULL) {\n+            secp256k1_scalar_add(&sum_scalars, &sum_scalars, &data->scalars[(*scalar_gen_offset+i) % POINTS]);\n+        }\n+        if (seckey_offset != NULL) {\n+            secp256k1_scalar s = data->seckeys[(*seckey_offset+i) % POINTS];\n+            secp256k1_scalar_mul(&s, &s, &data->scalars[(*scalar_offset+i) % POINTS]);\n+            secp256k1_scalar_add(&sum_scalars, &sum_scalars, &s);\n+        }\n+    }\n+    secp256k1_ecmult_gen(&data->ctx->ecmult_gen_ctx, &tmp, &sum_scalars);\n+    secp256k1_gej_neg(&tmp, &tmp);\n+    secp256k1_gej_add_var(&tmp, &tmp, &sum_output, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&tmp));\n+}\n+\n+static void bench_ecmult_setup(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    /* Re-randomize offset to ensure that we're using different scalars and\n+     * group elements in each run. */\n+    hash_into_offset(data, data->offset1);\n+}\n+\n+static void bench_ecmult_gen(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult_gen(&data->ctx->ecmult_gen_ctx, &data->output[i], &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_gen_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n+}\n+\n+static void bench_ecmult_const(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult_const(&data->output[i], &data->pubkeys[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], 256);\n+    }\n+}\n+\n+static void bench_ecmult_const_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n+}\n+\n+static void bench_ecmult_1(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+    }\n+}\n+\n+static void bench_ecmult_1_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n+}\n+\n+static void bench_ecmult_1g(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    secp256k1_scalar zero;\n+    int i;\n+\n+    secp256k1_scalar_set_int(&zero, 0);\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_1g_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n+}\n+\n+static void bench_ecmult_2g(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters/2; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_2g_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, &data->offset1, iters/2);\n+}\n+\n+static void run_ecmult_bench(bench_data* data, int iters) {\n+    char str[32];\n+    sprintf(str, \"ecmult_gen\");\n+    run_benchmark(str, bench_ecmult_gen, bench_ecmult_setup, bench_ecmult_gen_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_const\");\n+    run_benchmark(str, bench_ecmult_const, bench_ecmult_setup, bench_ecmult_const_teardown, data, 10, iters);\n+    /* ecmult with non generator point */\n+    sprintf(str, \"ecmult 1\");\n+    run_benchmark(str, bench_ecmult_1, bench_ecmult_setup, bench_ecmult_1_teardown, data, 10, iters);\n+    /* ecmult with generator point */\n+    sprintf(str, \"ecmult 1g\");\n+    run_benchmark(str, bench_ecmult_1g, bench_ecmult_setup, bench_ecmult_1g_teardown, data, 10, iters);\n+    /* ecmult with generator and non-generator point. The reported time is per point. */\n+    sprintf(str, \"ecmult 2g\");\n+    run_benchmark(str, bench_ecmult_2g, bench_ecmult_setup, bench_ecmult_2g_teardown, data, 10, 2*iters);\n+}\n+\n+static int bench_ecmult_multi_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n     bench_data* data = (bench_data*)arg;\n     if (data->includes_g) ++idx;\n     if (idx == 0) {\n@@ -53,7 +198,7 @@ static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, vo\n     return 1;\n }\n \n-static void bench_ecmult(void* arg, int iters) {\n+static void bench_ecmult_multi(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n \n     int includes_g = data->includes_g;\n@@ -62,19 +207,18 @@ static void bench_ecmult(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n }\n \n-static void bench_ecmult_setup(void* arg) {\n+static void bench_ecmult_multi_setup(void* arg) {\n     bench_data* data = (bench_data*)arg;\n-    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n-    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    hash_into_offset(data, data->count);\n }\n \n-static void bench_ecmult_teardown(void* arg, int iters) {\n+static void bench_ecmult_multi_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int iter;\n     iters = iters / data->count;\n@@ -88,7 +232,7 @@ static void bench_ecmult_teardown(void* arg, int iters) {\n \n static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     secp256k1_sha256 sha256;\n-    unsigned char c[11] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n+    unsigned char c[10] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n     unsigned char buf[32];\n     int overflow = 0;\n     c[6] = num;\n@@ -102,7 +246,7 @@ static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     CHECK(!overflow);\n }\n \n-static void run_test(bench_data* data, size_t count, int includes_g, int num_iters) {\n+static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_g, int num_iters) {\n     char str[32];\n     static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n     size_t iters = 1 + num_iters / count;\n@@ -112,8 +256,7 @@ static void run_test(bench_data* data, size_t count, int includes_g, int num_ite\n     data->includes_g = includes_g;\n \n     /* Compute (the negation of) the expected results directly. */\n-    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n-    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    hash_into_offset(data, data->count);\n     for (iter = 0; iter < iters; ++iter) {\n         secp256k1_scalar tmp;\n         secp256k1_scalar total = data->scalars[(data->offset1++) % POINTS];\n@@ -127,65 +270,75 @@ static void run_test(bench_data* data, size_t count, int includes_g, int num_ite\n     }\n \n     /* Run the benchmark. */\n-    sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n-    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * iters);\n+    sprintf(str, includes_g ? \"ecmult_multi %ig\" : \"ecmult_multi %i\", (int)count);\n+    run_benchmark(str, bench_ecmult_multi, bench_ecmult_multi_setup, bench_ecmult_multi_teardown, data, 10, count * iters);\n }\n \n int main(int argc, char **argv) {\n     bench_data data;\n     int i, p;\n-    secp256k1_gej* pubkeys_gej;\n     size_t scratch_size;\n \n     int iters = get_iters(10000);\n \n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n-    data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n     data.ecmult_multi = secp256k1_ecmult_multi_var;\n \n     if (argc > 1) {\n-        if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n+        if(have_flag(argc, argv, \"-h\")\n+           || have_flag(argc, argv, \"--help\")\n+           || have_flag(argc, argv, \"help\")) {\n+            help(argv);\n+            return 1;\n+        } else if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n             printf(\"Using pippenger_wnaf:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_pippenger_batch_single;\n         } else if(have_flag(argc, argv, \"strauss_wnaf\")) {\n             printf(\"Using strauss_wnaf:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_strauss_batch_single;\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n-            data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n-            data.scratch = NULL;\n         } else {\n-            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n-            fprintf(stderr, \"Use 'pippenger_wnaf', 'strauss_wnaf', 'simple' or no argument to benchmark a combined algorithm.\\n\");\n+            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\\n\", argv[0], argv[1]);\n+            help(argv);\n             return 1;\n         }\n     }\n \n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n+    if (!have_flag(argc, argv, \"simple\")) {\n+        data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n+    } else {\n+        data.scratch = NULL;\n+    }\n+\n     /* Allocate stuff */\n     data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n+    data.pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n     data.expected_output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n     data.output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n \n     /* Generate a set of scalars, and private/public keypairs. */\n-    pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n-    secp256k1_gej_set_ge(&pubkeys_gej[0], &secp256k1_ge_const_g);\n+    secp256k1_gej_set_ge(&data.pubkeys_gej[0], &secp256k1_ge_const_g);\n     secp256k1_scalar_set_int(&data.seckeys[0], 1);\n     for (i = 0; i < POINTS; ++i) {\n         generate_scalar(i, &data.scalars[i]);\n         if (i) {\n-            secp256k1_gej_double_var(&pubkeys_gej[i], &pubkeys_gej[i - 1], NULL);\n+            secp256k1_gej_double_var(&data.pubkeys_gej[i], &data.pubkeys_gej[i - 1], NULL);\n             secp256k1_scalar_add(&data.seckeys[i], &data.seckeys[i - 1], &data.seckeys[i - 1]);\n         }\n     }\n-    secp256k1_ge_set_all_gej_var(data.pubkeys, pubkeys_gej, POINTS);\n-    free(pubkeys_gej);\n+    secp256k1_ge_set_all_gej_var(data.pubkeys, data.pubkeys_gej, POINTS);\n+\n+\n+    /* Initialize offset1 and offset2 */\n+    hash_into_offset(&data, 0);\n+    run_ecmult_bench(&data, iters);\n \n     for (i = 1; i <= 8; ++i) {\n-        run_test(&data, i, 1, iters);\n+        run_ecmult_multi_bench(&data, i, 1, iters);\n     }\n \n     /* This is disabled with low count of iterations because the loop runs 77 times even with iters=1\n@@ -194,7 +347,7 @@ int main(int argc, char **argv) {\n      if (iters > 2) {\n         for (p = 0; p <= 11; ++p) {\n             for (i = 9; i <= 16; ++i) {\n-                run_test(&data, i << p, 1, iters);\n+                run_ecmult_multi_bench(&data, i << p, 1, iters);\n             }\n         }\n     }\n@@ -205,6 +358,7 @@ int main(int argc, char **argv) {\n     secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n+    free(data.pubkeys_gej);\n     free(data.seckeys);\n     free(data.output);\n     free(data.expected_output);"
      },
      {
        "sha": "161b1c4a47666e88b36310fc79675a8f3f13d6c9",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -5,7 +5,8 @@\n  ***********************************************************************/\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -16,7 +17,6 @@\n #include \"ecmult_const_impl.h\"\n #include \"ecmult_impl.h\"\n #include \"bench.h\"\n-#include \"secp256k1.c\"\n \n typedef struct {\n     secp256k1_scalar scalar[2];"
      },
      {
        "sha": "4bcac19dc0a398669a53c55da6ac4b248f98546b",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,8 +4,8 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_recovery.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_recovery.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "d95bc00f485fb2640a0c295cdde79b082591fe0b",
        "filename": "src/secp256k1/src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorrsig.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,11 +8,13 @@\n #include <stdlib.h>\n \n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_schnorrsig.h\"\n #include \"util.h\"\n #include \"bench.h\"\n \n+#define MSGLEN 32\n+\n typedef struct {\n     secp256k1_context *ctx;\n     int n;\n@@ -26,13 +28,13 @@ typedef struct {\n void bench_schnorrsig_sign(void* arg, int iters) {\n     bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n     int i;\n-    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char msg[MSGLEN] = {0};\n     unsigned char sig[64];\n \n     for (i = 0; i < iters; i++) {\n         msg[0] = i;\n         msg[1] = i >> 8;\n-        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_sign_custom(data->ctx, sig, msg, MSGLEN, data->keypairs[i], NULL));\n     }\n }\n \n@@ -43,7 +45,7 @@ void bench_schnorrsig_verify(void* arg, int iters) {\n     for (i = 0; i < iters; i++) {\n         secp256k1_xonly_pubkey pk;\n         CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n-        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], MSGLEN, &pk));\n     }\n }\n \n@@ -58,9 +60,10 @@ int main(void) {\n     data.msgs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n     data.sigs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n \n+    CHECK(MSGLEN >= 4);\n     for (i = 0; i < iters; i++) {\n         unsigned char sk[32];\n-        unsigned char *msg = (unsigned char *)malloc(32);\n+        unsigned char *msg = (unsigned char *)malloc(MSGLEN);\n         unsigned char *sig = (unsigned char *)malloc(64);\n         secp256k1_keypair *keypair = (secp256k1_keypair *)malloc(sizeof(*keypair));\n         unsigned char *pk_char = (unsigned char *)malloc(32);\n@@ -69,7 +72,7 @@ int main(void) {\n         msg[1] = sk[1] = i >> 8;\n         msg[2] = sk[2] = i >> 16;\n         msg[3] = sk[3] = i >> 24;\n-        memset(&msg[4], 'm', 28);\n+        memset(&msg[4], 'm', MSGLEN - 4);\n         memset(&sk[4], 's', 28);\n \n         data.keypairs[i] = keypair;\n@@ -78,7 +81,7 @@ int main(void) {\n         data.sigs[i] = sig;\n \n         CHECK(secp256k1_keypair_create(data.ctx, keypair, sk));\n-        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, keypair, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_sign_custom(data.ctx, sig, msg, MSGLEN, keypair, NULL));\n         CHECK(secp256k1_keypair_xonly_pub(data.ctx, &pk, NULL, keypair));\n         CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n     }"
      },
      {
        "sha": "f659c18c92d0bd20fee399b2c1a0f3ca1a27a41b",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,7 +4,7 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "565ae4beec8a5726b267cd141d61ecf50c101c4f",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,7 +7,7 @@\n #include <stdio.h>\n #include <string.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "c32141e8872de1b97d8bfebd8d51a8b90bd880b5",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -140,7 +140,7 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         overflow = 1;\n     }\n     if (!overflow) {\n-        memcpy(ra + 32 - rlen, *sig, rlen);\n+        if (rlen) memcpy(ra + 32 - rlen, *sig, rlen);\n         secp256k1_scalar_set_b32(r, ra, &overflow);\n     }\n     if (overflow) {"
      },
      {
        "sha": "84537bbfed20a765f00de4d28eb7069745f2d2a2",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -17,7 +17,6 @@ typedef struct {\n     secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n } secp256k1_ecmult_context;\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);"
      },
      {
        "sha": "05cf4d52ccafe91a16077748ae609c96b3ae8b0d",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -35,7 +35,6 @@ typedef struct {\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n-static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);"
      },
      {
        "sha": "f9176eb99674233003afc7685407a37b7ce9e369",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -13,7 +13,13 @@\n /* We can't require the precomputed tables when creating them. */\n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n \n-#include \"include/secp256k1.h\"\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n #include \"field_impl.h\""
      },
      {
        "sha": "47aea32be184a0f401403ffbf98067d7f4f5bb9d",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -100,8 +100,8 @@ static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a) {\n \n static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     secp256k1_fe z2, z3;\n-    r->infinity = a->infinity;\n     if (a->infinity) {\n+        secp256k1_ge_set_infinity(r);\n         return;\n     }\n     secp256k1_fe_inv_var(&a->z, &a->z);\n@@ -110,8 +110,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     secp256k1_fe_mul(&a->x, &a->x, &z2);\n     secp256k1_fe_mul(&a->y, &a->y, &z3);\n     secp256k1_fe_set_int(&a->z, 1);\n-    r->x = a->x;\n-    r->y = a->y;\n+    secp256k1_ge_set_xy(r, &a->x, &a->y);\n }\n \n static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len) {\n@@ -120,7 +119,9 @@ static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a\n     size_t last_i = SIZE_MAX;\n \n     for (i = 0; i < len; i++) {\n-        if (!a[i].infinity) {\n+        if (a[i].infinity) {\n+            secp256k1_ge_set_infinity(&r[i]);\n+        } else {\n             /* Use destination's x coordinates as scratch space */\n             if (last_i == SIZE_MAX) {\n                 r[i].x = a[i].z;\n@@ -148,7 +149,6 @@ static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a\n     r[last_i].x = u;\n \n     for (i = 0; i < len; i++) {\n-        r[i].infinity = a[i].infinity;\n         if (!a[i].infinity) {\n             secp256k1_ge_set_gej_zinv(&r[i], &a[i], &r[i].x);\n         }\n@@ -311,7 +311,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n      *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     if (a->infinity) {\n-        r->infinity = 1;\n+        secp256k1_gej_set_infinity(r);\n         if (rzr != NULL) {\n             secp256k1_fe_set_int(rzr, 1);\n         }"
      },
      {
        "sha": "5408c9de707107eef78d0e7a6707f30535333f7d",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_MODULE_ECDH_MAIN_H\n #define SECP256K1_MODULE_ECDH_MAIN_H\n \n-#include \"include/secp256k1_ecdh.h\"\n-#include \"ecmult_const_impl.h\"\n+#include \"../../../include/secp256k1_ecdh.h\"\n+#include \"../../ecmult_const_impl.h\"\n \n static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n     unsigned char version = (y32[31] & 0x01) | 0x02;"
      },
      {
        "sha": "8607bbede73022a40db8f0c60227d61b4f447b90",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 2,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n #define SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n     return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n@@ -55,6 +55,32 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_cmp(const secp256k1_context* ctx, const secp256k1_xonly_pubkey* pk0, const secp256k1_xonly_pubkey* pk1) {\n+    unsigned char out[2][32];\n+    const secp256k1_xonly_pubkey* pk[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    pk[0] = pk0; pk[1] = pk1;\n+    for (i = 0; i < 2; i++) {\n+        /* If the public key is NULL or invalid, xonly_pubkey_serialize will\n+         * call the illegal_callback and return 0. In that case we will\n+         * serialize the key as all zeros which is less than any valid public\n+         * key. This results in consistent comparisons even if NULL or invalid\n+         * pubkeys are involved and prevents edge cases such as sorting\n+         * algorithms that use this function and do not terminate as a\n+         * result. */\n+        if (!secp256k1_xonly_pubkey_serialize(ctx, out[i], pk[i])) {\n+            /* Note that xonly_pubkey_serialize should already set the output to\n+             * zero in that case, but it's not guaranteed by the API, we can't\n+             * test it and writing a VERIFY_CHECK is more complex than\n+             * explicitly memsetting (again). */\n+            memset(out[i], 0, sizeof(out[i]));\n+        }\n+    }\n+    return secp256k1_memcmp_var(out[0], out[1], sizeof(out[1]));\n+}\n+\n /** Keeps a group element as is if it has an even Y and otherwise negates it.\n  *  y_parity is set to 0 in the former case and to 1 in the latter case.\n  *  Requires that the coordinates of r are normalized. */"
      },
      {
        "sha": "d4a2f5bdf4050e821218816585d4d0a3edfdaf3c",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,7 +8,7 @@\n #define SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n \n #include \"src/modules/extrakeys/main_impl.h\"\n-#include \"include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static void test_exhaustive_extrakeys(const secp256k1_context *ctx, const secp256k1_ge* group) {\n     secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];"
      },
      {
        "sha": "4a5952714c41c5147b9ccf48914f18d196c51531",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n #define SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n \n-#include \"secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static secp256k1_context* api_test_context(int flags, int *ecount) {\n     secp256k1_context *ctx0 = secp256k1_context_create(flags);\n@@ -137,6 +137,43 @@ void test_xonly_pubkey(void) {\n     secp256k1_context_destroy(verify);\n }\n \n+void test_xonly_pubkey_comparison(void) {\n+    unsigned char pk1_ser[32] = {\n+        0x58, 0x84, 0xb3, 0xa2, 0x4b, 0x97, 0x37, 0x88, 0x92, 0x38, 0xa6, 0x26, 0x62, 0x52, 0x35, 0x11,\n+        0xd0, 0x9a, 0xa1, 0x1b, 0x80, 0x0b, 0x5e, 0x93, 0x80, 0x26, 0x11, 0xef, 0x67, 0x4b, 0xd9, 0x23\n+    };\n+    const unsigned char pk2_ser[32] = {\n+        0xde, 0x36, 0x0e, 0x87, 0x59, 0x8f, 0x3c, 0x01, 0x36, 0x2a, 0x2a, 0xb8, 0xc6, 0xf4, 0x5e, 0x4d,\n+        0xb2, 0xc2, 0xd5, 0x03, 0xa7, 0xf9, 0xf1, 0x4f, 0xa8, 0xfa, 0x95, 0xa8, 0xe9, 0x69, 0x76, 0x1c\n+    };\n+    secp256k1_xonly_pubkey pk1;\n+    secp256k1_xonly_pubkey pk2;\n+    int ecount = 0;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk1, pk1_ser) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk2, pk2_ser) == 1);\n+\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, NULL, &pk2) < 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, NULL) > 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk1) > 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk1) == 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk2) == 0);\n+    CHECK(ecount == 2);\n+    memset(&pk1, 0, sizeof(pk1)); /* illegal pubkey */\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk2) < 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk1) > 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+}\n+\n void test_xonly_pubkey_tweak(void) {\n     unsigned char zeros64[64] = { 0 };\n     unsigned char overflows[32];\n@@ -540,6 +577,7 @@ void run_extrakeys_tests(void) {\n     test_xonly_pubkey_tweak();\n     test_xonly_pubkey_tweak_check();\n     test_xonly_pubkey_tweak_recursive();\n+    test_xonly_pubkey_comparison();\n \n     /* keypair tests */\n     test_keypair();"
      },
      {
        "sha": "9e19f2a2dc9c880fd80c48108d46ee4ac5f9a618",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_RECOVERY_MAIN_H\n #define SECP256K1_MODULE_RECOVERY_MAIN_H\n \n-#include \"include/secp256k1_recovery.h\"\n+#include \"../../../include/secp256k1_recovery.h\"\n \n static void secp256k1_ecdsa_recoverable_signature_load(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, int* recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     (void)ctx;"
      },
      {
        "sha": "590a972ed3f74a9e24978ee373895bab5dad8128",
        "filename": "src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -8,7 +8,7 @@\n #define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n \n #include \"src/modules/recovery/main_impl.h\"\n-#include \"include/secp256k1_recovery.h\"\n+#include \"../../../include/secp256k1_recovery.h\"\n \n void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k;"
      },
      {
        "sha": "693b78f03444d6ce8325a4fea44114b73c0a87b4",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,9 +7,9 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n #define SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorrsig.h\"\n-#include \"hash.h\"\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n+#include \"../../hash.h\"\n \n /* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n  * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n@@ -43,16 +43,18 @@ static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *\n     sha->bytes = 64;\n }\n \n-/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+/* algo argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n  * by using the correct tagged hash function. */\n-static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+static const unsigned char bip340_algo[13] = \"BIP0340/nonce\";\n \n-static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+static const unsigned char schnorrsig_extraparams_magic[4] = SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC;\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n     secp256k1_sha256 sha;\n     unsigned char masked_key[32];\n     int i;\n \n-    if (algo16 == NULL) {\n+    if (algo == NULL) {\n         return 0;\n     }\n \n@@ -65,18 +67,14 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         }\n     }\n \n-    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+    /* Tag the hash with algo which is important to avoid nonce reuse across\n      * algorithms. If this nonce function is used in BIP-340 signing as defined\n      * in the spec, an optimized tagging implementation is used. */\n-    if (secp256k1_memcmp_var(algo16, bip340_algo16, 16) == 0) {\n+    if (algolen == sizeof(bip340_algo)\n+            && secp256k1_memcmp_var(algo, bip340_algo, algolen) == 0) {\n         secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n     } else {\n-        int algo16_len = 16;\n-        /* Remove terminating null bytes */\n-        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n-            algo16_len--;\n-        }\n-        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+        secp256k1_sha256_initialize_tagged(&sha, algo, algolen);\n     }\n \n     /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n@@ -86,7 +84,7 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         secp256k1_sha256_write(&sha, key32, 32);\n     }\n     secp256k1_sha256_write(&sha, xonly_pk32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, nonce32);\n     return 1;\n }\n@@ -108,23 +106,23 @@ static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n     sha->bytes = 64;\n }\n \n-static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg32, const unsigned char *pubkey32)\n+static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg, size_t msglen, const unsigned char *pubkey32)\n {\n     unsigned char buf[32];\n     secp256k1_sha256 sha;\n \n-    /* tagged hash(r.x, pk.x, msg32) */\n+    /* tagged hash(r.x, pk.x, msg) */\n     secp256k1_schnorrsig_sha256_tagged(&sha);\n     secp256k1_sha256_write(&sha, r32, 32);\n     secp256k1_sha256_write(&sha, pubkey32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, buf);\n     /* Set scalar e to the challenge hash modulo the curve order as per\n      * BIP340. */\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -139,7 +137,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(keypair != NULL);\n \n     if (noncefp == NULL) {\n@@ -156,7 +154,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n \n     secp256k1_scalar_get_b32(seckey, &sk);\n     secp256k1_fe_get_b32(pk_buf, &pk.x);\n-    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    ret &= !!noncefp(buf, msg, msglen, seckey, pk_buf, bip340_algo, sizeof(bip340_algo), ndata);\n     secp256k1_scalar_set_b32(&k, buf, NULL);\n     ret &= !secp256k1_scalar_is_zero(&k);\n     secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n@@ -174,7 +172,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_fe_normalize_var(&r.x);\n     secp256k1_fe_get_b32(&sig64[0], &r.x);\n \n-    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, pk_buf);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, pk_buf);\n     secp256k1_scalar_mul(&e, &e, &sk);\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n@@ -187,7 +185,26 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     return ret;\n }\n \n-int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, unsigned char *aux_rand32) {\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, aux_rand32);\n+}\n+\n+int secp256k1_schnorrsig_sign_custom(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams) {\n+    secp256k1_nonce_function_hardened noncefp = NULL;\n+    void *ndata = NULL;\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    if (extraparams != NULL) {\n+        ARG_CHECK(secp256k1_memcmp_var(extraparams->magic,\n+                                       schnorrsig_extraparams_magic,\n+                                       sizeof(extraparams->magic)) == 0);\n+        noncefp = extraparams->noncefp;\n+        ndata = extraparams->ndata;\n+    }\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg, msglen, keypair, noncefp, ndata);\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey) {\n     secp256k1_scalar s;\n     secp256k1_scalar e;\n     secp256k1_gej rj;\n@@ -201,7 +218,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n \n     if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n@@ -219,7 +236,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n \n     /* Compute e. */\n     secp256k1_fe_get_b32(buf, &pk.x);\n-    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, buf);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, buf);\n \n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);"
      },
      {
        "sha": "d8df9dd2df7425a0f25a4d2ba185a54c110357ba",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n #define SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n \n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n #include \"src/modules/schnorrsig/main_impl.h\"\n \n static const unsigned char invalid_pubkey_bytes[][32] = {\n@@ -58,15 +58,19 @@ static const unsigned char invalid_pubkey_bytes[][32] = {\n \n #define NUM_INVALID_KEYS (sizeof(invalid_pubkey_bytes) / sizeof(invalid_pubkey_bytes[0]))\n \n-static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg,\n+                                                      size_t msglen,\n                                                       const unsigned char *key32, const unsigned char *xonly_pk32,\n-                                                      const unsigned char *algo16, void* data) {\n+                                                      const unsigned char *algo, size_t algolen,\n+                                                      void* data) {\n     secp256k1_scalar s;\n     int *idata = data;\n-    (void)msg32;\n+    (void)msg;\n+    (void)msglen;\n     (void)key32;\n     (void)xonly_pk32;\n-    (void)algo16;\n+    (void)algo;\n+    (void)algolen;\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n     return 1;\n@@ -101,7 +105,7 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n                 secp256k1_scalar e;\n                 unsigned char msg32[32];\n                 secp256k1_testrand256(msg32);\n-                secp256k1_schnorrsig_challenge(&e, sig64, msg32, pk32);\n+                secp256k1_schnorrsig_challenge(&e, sig64, msg32, sizeof(msg32), pk32);\n                 /* Only do work if we hit a challenge we haven't tried before. */\n                 if (!e_done[e]) {\n                     /* Iterate over the possible valid last 32 bytes in the signature.\n@@ -119,7 +123,7 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n                             secp256k1_testrand256(sig64 + 32);\n                             expect_valid = 0;\n                         }\n-                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, &pubkeys[d - 1]);\n+                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, sizeof(msg32), &pubkeys[d - 1]);\n                         CHECK(valid == expect_valid);\n                         count_valid += valid;\n                     }\n@@ -137,6 +141,8 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsigned char (*xonly_pubkey_bytes)[32], const secp256k1_keypair* keypairs, const int* parities) {\n     int d, k;\n     uint64_t iter = 0;\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+\n     /* Loop over keys. */\n     for (d = 1; d < EXHAUSTIVE_TEST_ORDER; ++d) {\n         int actual_d = d;\n@@ -149,19 +155,21 @@ static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsign\n             unsigned char sig64[64];\n             int actual_k = k;\n             if (skip_section(&iter)) continue;\n+            extraparams.noncefp = secp256k1_hardened_nonce_function_smallint;\n+            extraparams.ndata = &k;\n             if (parities[k - 1]) actual_k = EXHAUSTIVE_TEST_ORDER - k;\n             /* Generate random messages until all challenges have been tried. */\n             while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n                 secp256k1_scalar e;\n                 secp256k1_testrand256(msg32);\n-                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, xonly_pubkey_bytes[d - 1]);\n+                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, sizeof(msg32), xonly_pubkey_bytes[d - 1]);\n                 /* Only do work if we hit a challenge we haven't tried before. */\n                 if (!e_done[e]) {\n                     secp256k1_scalar expected_s = (actual_k + e * actual_d) % EXHAUSTIVE_TEST_ORDER;\n                     unsigned char expected_s_bytes[32];\n                     secp256k1_scalar_get_b32(expected_s_bytes, &expected_s);\n                     /* Invoke the real function to construct a signature. */\n-                    CHECK(secp256k1_schnorrsig_sign(ctx, sig64, msg32, &keypairs[d - 1], secp256k1_hardened_nonce_function_smallint, &k));\n+                    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig64, msg32, sizeof(msg32), &keypairs[d - 1], &extraparams));\n                     /* The first 32 bytes must match the xonly pubkey for the specified k. */\n                     CHECK(secp256k1_memcmp_var(sig64, xonly_pubkey_bytes[k - 1], 32) == 0);\n                     /* The last 32 bytes must match the expected s value. */"
      },
      {
        "sha": "59357afa99ad6a621b164e0c42bae4e2faeec021",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 160,
        "deletions": 75,
        "changes": 235,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,16 +7,16 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n #define SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n \n-#include \"secp256k1_schnorrsig.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n \n /* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n  * bytes) changes the hash function\n  */\n-void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes, size_t msglen, size_t algolen) {\n     unsigned char nonces[2][32];\n-    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(nonce_function_bip340(nonces[0], args[0], msglen, args[1], args[2], args[3], algolen, args[4]) == 1);\n     secp256k1_testrand_flip(args[n_flip], n_bytes);\n-    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], msglen, args[1], args[2], args[3], algolen, args[4]) == 1);\n     CHECK(secp256k1_memcmp_var(nonces[0], nonces[1], 32) != 0);\n }\n \n@@ -34,11 +34,13 @@ void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2)\n void run_nonce_function_bip340_tests(void) {\n     unsigned char tag[13] = \"BIP0340/nonce\";\n     unsigned char aux_tag[11] = \"BIP0340/aux\";\n-    unsigned char algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+    unsigned char algo[13] = \"BIP0340/nonce\";\n+    size_t algolen = sizeof(algo);\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n     unsigned char nonce[32];\n     unsigned char msg[32];\n+    size_t msglen = sizeof(msg);\n     unsigned char key[32];\n     unsigned char pk[32];\n     unsigned char aux_rand[32];\n@@ -68,33 +70,45 @@ void run_nonce_function_bip340_tests(void) {\n     args[0] = msg;\n     args[1] = key;\n     args[2] = pk;\n-    args[3] = algo16;\n+    args[3] = algo;\n     args[4] = aux_rand;\n     for (i = 0; i < count; i++) {\n-        nonce_function_bip340_bitflip(args, 0, 32);\n-        nonce_function_bip340_bitflip(args, 1, 32);\n-        nonce_function_bip340_bitflip(args, 2, 32);\n-        /* Flip algo16 special case \"BIP0340/nonce\" */\n-        nonce_function_bip340_bitflip(args, 3, 16);\n-        /* Flip algo16 again */\n-        nonce_function_bip340_bitflip(args, 3, 16);\n-        nonce_function_bip340_bitflip(args, 4, 32);\n+        nonce_function_bip340_bitflip(args, 0, 32, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 1, 32, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 2, 32, msglen, algolen);\n+        /* Flip algo special case \"BIP0340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, algolen, msglen, algolen);\n+        /* Flip algo again */\n+        nonce_function_bip340_bitflip(args, 3, algolen, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 4, 32, msglen, algolen);\n     }\n \n-    /* NULL algo16 is disallowed */\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n-    /* Empty algo16 is fine */\n-    memset(algo16, 0x00, 16);\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n-    /* algo16 with terminating null bytes is fine */\n-    algo16[1] = 65;\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n-    /* Other algo16 is fine */\n-    memset(algo16, 0xFF, 16);\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* NULL algo is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, NULL, 0, NULL) == 0);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+    /* Other algo is fine */\n+    secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, algo, algolen);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+\n+    for (i = 0; i < count; i++) {\n+        unsigned char nonce2[32];\n+        uint32_t offset = secp256k1_testrand_int(msglen - 1);\n+        size_t msglen_tmp = (msglen + offset) % msglen;\n+        size_t algolen_tmp;\n+\n+        /* Different msglen gives different nonce */\n+        CHECK(nonce_function_bip340(nonce2, msg, msglen_tmp, key, pk, algo, algolen, NULL) == 1);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+\n+        /* Different algolen gives different nonce */\n+        offset = secp256k1_testrand_int(algolen - 1);\n+        algolen_tmp = (algolen + offset) % algolen;\n+        CHECK(nonce_function_bip340(nonce2, msg, msglen, key, pk, algo, algolen_tmp, NULL) == 1);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+    }\n \n     /* NULL aux_rand argument is allowed. */\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n }\n \n void test_schnorrsig_api(void) {\n@@ -103,10 +117,12 @@ void test_schnorrsig_api(void) {\n     unsigned char sk3[32];\n     unsigned char msg[32];\n     secp256k1_keypair keypairs[3];\n-    secp256k1_keypair invalid_keypair = { 0 };\n+    secp256k1_keypair invalid_keypair = {{ 0 }};\n     secp256k1_xonly_pubkey pk[3];\n     secp256k1_xonly_pubkey zero_pk;\n     unsigned char sig[64];\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+    secp256k1_schnorrsig_extraparams invalid_extraparams = {{ 0 }, NULL, NULL};\n \n     /** setup **/\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n@@ -138,36 +154,60 @@ void test_schnorrsig_api(void) {\n \n     /** main test body **/\n     ecount = 0;\n-    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL) == 0);\n+    CHECK(ecount == 6);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign_custom(none, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(vrfy, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, NULL, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, NULL, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 4);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, NULL, 0, &keypairs[0], &extraparams) == 1);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), NULL, &extraparams) == 0);\n     CHECK(ecount == 5);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &invalid_keypair, &extraparams) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], NULL) == 1);\n     CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], &invalid_extraparams) == 0);\n+    CHECK(ecount == 7);\n \n     ecount = 0;\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n     CHECK(ecount == 4);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n     CHECK(ecount == 5);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n     CHECK(ecount == 6);\n \n     secp256k1_context_destroy(none);\n@@ -179,7 +219,7 @@ void test_schnorrsig_api(void) {\n /* Checks that hash initialized by secp256k1_schnorrsig_sha256_tagged has the\n  * expected state. */\n void test_schnorrsig_sha256_tagged(void) {\n-    char tag[17] = \"BIP0340/challenge\";\n+    unsigned char tag[17] = \"BIP0340/challenge\";\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n \n@@ -190,19 +230,19 @@ void test_schnorrsig_sha256_tagged(void) {\n \n /* Helper function for schnorrsig_bip_vectors\n  * Signs the message and checks that it's the same as expected_sig. */\n-void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg, const unsigned char *expected_sig) {\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n     unsigned char sig[64];\n     secp256k1_keypair keypair;\n     secp256k1_xonly_pubkey pk, pk_expected;\n \n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg32, &keypair, aux_rand));\n     CHECK(secp256k1_memcmp_var(sig, expected_sig, 64) == 0);\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n     CHECK(secp256k1_memcmp_var(&pk, &pk_expected, sizeof(pk)) == 0);\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg32, 32, &pk));\n }\n \n /* Helper function for schnorrsig_bip_vectors\n@@ -211,7 +251,7 @@ void test_schnorrsig_bip_vectors_check_verify(const unsigned char *pk_serialized\n     secp256k1_xonly_pubkey pk;\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk, pk_serialized));\n-    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, 32, &pk));\n }\n \n /* Test vectors according to BIP-340 (\"Schnorr Signatures for secp256k1\"). See\n@@ -634,34 +674,40 @@ void test_schnorrsig_bip_vectors(void) {\n }\n \n /* Nonce function that returns constant 0 */\n-static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n     (void) nonce32;\n     return 0;\n }\n \n /* Nonce function that sets nonce to 0 */\n-static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n \n     memset(nonce32, 0, 32);\n     return 1;\n }\n \n /* Nonce function that sets nonce to 0xFF...0xFF */\n-static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n \n     memset(nonce32, 0xFF, 32);\n@@ -670,24 +716,45 @@ static int nonce_function_overflowing(unsigned char *nonce32, const unsigned cha\n \n void test_schnorrsig_sign(void) {\n     unsigned char sk[32];\n+    secp256k1_xonly_pubkey pk;\n     secp256k1_keypair keypair;\n     const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n     unsigned char sig[64];\n+    unsigned char sig2[64];\n     unsigned char zeros64[64] = { 0 };\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+    unsigned char aux_rand[32];\n \n     secp256k1_testrand256(sk);\n+    secp256k1_testrand256(aux_rand);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n \n     /* Test different nonce functions */\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n     memset(sig, 1, sizeof(sig));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n+    extraparams.noncefp = nonce_function_failing;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 0);\n     CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     memset(&sig, 1, sizeof(sig));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n+    extraparams.noncefp = nonce_function_0;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 0);\n     CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n-    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) != 0);\n+    memset(&sig, 1, sizeof(sig));\n+    extraparams.noncefp = nonce_function_overflowing;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n+\n+    /* When using the default nonce function, schnorrsig_sign_custom produces\n+     * the same result as schnorrsig_sign with aux_rand = extraparams.ndata */\n+    extraparams.noncefp = NULL;\n+    extraparams.ndata = aux_rand;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig2, msg, &keypair, extraparams.ndata) == 1);\n+    CHECK(secp256k1_memcmp_var(sig, sig2, sizeof(sig)) == 0);\n }\n \n #define N_SIGS 3\n@@ -709,8 +776,8 @@ void test_schnorrsig_sign_verify(void) {\n \n     for (i = 0; i < N_SIGS; i++) {\n         secp256k1_testrand256(msg[i]);\n-        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n-        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n+        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], sizeof(msg[i]), &pk));\n     }\n \n     {\n@@ -720,36 +787,54 @@ void test_schnorrsig_sign_verify(void) {\n         size_t byte_idx = secp256k1_testrand_int(32);\n         unsigned char xorbyte = secp256k1_testrand_int(254)+1;\n         sig[sig_idx][byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         sig[sig_idx][byte_idx] ^= xorbyte;\n \n         byte_idx = secp256k1_testrand_int(32);\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n \n         byte_idx = secp256k1_testrand_int(32);\n         msg[sig_idx][byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         msg[sig_idx][byte_idx] ^= xorbyte;\n \n         /* Check that above bitflips have been reversed correctly */\n-        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n     }\n \n     /* Test overflowing s */\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n     memset(&sig[0][32], 0xFF, 32);\n-    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n \n     /* Test negative s */\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n     secp256k1_scalar_set_b32(&s, &sig[0][32], NULL);\n     secp256k1_scalar_negate(&s, &s);\n     secp256k1_scalar_get_b32(&sig[0][32], &s);\n-    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n+\n+    /* The empty message can be signed & verified */\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig[0], NULL, 0, &keypair, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], NULL, 0, &pk) == 1);\n+\n+    {\n+        /* Test varying message lengths */\n+        unsigned char msg_large[32 * 8];\n+        uint32_t msglen  = secp256k1_testrand_int(sizeof(msg_large));\n+        for (i = 0; i < sizeof(msg_large); i += 32) {\n+            secp256k1_testrand256(&msg_large[i]);\n+        }\n+        CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig[0], msg_large, msglen, &keypair, NULL) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg_large, msglen, &pk) == 1);\n+        /* Verification for a random wrong message length fails */\n+        msglen = (msglen + (sizeof(msg_large) - 1)) % sizeof(msg_large);\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg_large, msglen, &pk) == 0);\n+    }\n }\n #undef N_SIGS\n \n@@ -777,10 +862,10 @@ void test_schnorrsig_taproot(void) {\n \n     /* Key spend */\n     secp256k1_testrand256(msg);\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL) == 1);\n     /* Verify key spend */\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &output_pk) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &output_pk) == 1);\n \n     /* Script spend */\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, internal_pk_bytes, &internal_pk) == 1);"
      },
      {
        "sha": "9908cab8642a5cdbf8819e227c5a80f734d4ec76",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 47,
        "deletions": 2,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,8 +4,10 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_preallocated.h\"\n+#define SECP256K1_BUILD\n+\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_preallocated.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -21,6 +23,10 @@\n #include \"scratch_impl.h\"\n #include \"selftest.h\"\n \n+#ifdef SECP256K1_NO_BUILD\n+# error \"secp256k1.h processed without SECP256K1_BUILD defined while building secp256k1.c\"\n+#endif\n+\n #if defined(VALGRIND)\n # include <valgrind/memcheck.h>\n #endif\n@@ -316,6 +322,32 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     return ret;\n }\n \n+int secp256k1_ec_pubkey_cmp(const secp256k1_context* ctx, const secp256k1_pubkey* pubkey0, const secp256k1_pubkey* pubkey1) {\n+    unsigned char out[2][33];\n+    const secp256k1_pubkey* pk[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    pk[0] = pubkey0; pk[1] = pubkey1;\n+    for (i = 0; i < 2; i++) {\n+        size_t out_size = sizeof(out[i]);\n+        /* If the public key is NULL or invalid, ec_pubkey_serialize will call\n+         * the illegal_callback and return 0. In that case we will serialize the\n+         * key as all zeros which is less than any valid public key. This\n+         * results in consistent comparisons even if NULL or invalid pubkeys are\n+         * involved and prevents edge cases such as sorting algorithms that use\n+         * this function and do not terminate as a result. */\n+        if (!secp256k1_ec_pubkey_serialize(ctx, out[i], &out_size, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            /* Note that ec_pubkey_serialize should already set the output to\n+             * zero in that case, but it's not guaranteed by the API, we can't\n+             * test it and writing a VERIFY_CHECK is more complex than\n+             * explicitly memsetting (again). */\n+            memset(out[i], 0, sizeof(out[i]));\n+        }\n+    }\n+    return secp256k1_memcmp_var(out[0], out[1], sizeof(out[0]));\n+}\n+\n static void secp256k1_ecdsa_signature_load(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_ecdsa_signature* sig) {\n     (void)ctx;\n     if (sizeof(secp256k1_scalar) == 32) {\n@@ -758,6 +790,19 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+int secp256k1_tagged_sha256(const secp256k1_context* ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen) {\n+    secp256k1_sha256 sha;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(hash32 != NULL);\n+    ARG_CHECK(tag != NULL);\n+    ARG_CHECK(msg != NULL);\n+\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n+    secp256k1_sha256_finalize(&sha, hash32);\n+    return 1;\n+}\n+\n #ifdef ENABLE_MODULE_ECDH\n # include \"modules/ecdh/main_impl.h\"\n #endif"
      },
      {
        "sha": "c8d30ef6a814bae98e77cc9e5ac35f4e2fe2492e",
        "filename": "src/secp256k1/src/testrand_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand_impl.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -127,7 +127,7 @@ static void secp256k1_testrand_init(const char* hexseed) {\n             pos++;\n         }\n     } else {\n-        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        FILE *frand = fopen(\"/dev/urandom\", \"rb\");\n         if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n             uint64_t t = time(NULL) * (uint64_t)1337;\n             fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");"
      },
      {
        "sha": "99d9468e2987cd9cc5cc4b701181bade0aa39ac5",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 172,
        "deletions": 10,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -15,8 +15,8 @@\n #include <time.h>\n \n #include \"secp256k1.c\"\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_preallocated.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n #include \"util.h\"\n \n@@ -30,8 +30,8 @@ void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)\n # endif\n #endif\n \n-#include \"contrib/lax_der_parsing.c\"\n-#include \"contrib/lax_der_privatekey_parsing.c\"\n+#include \"../contrib/lax_der_parsing.c\"\n+#include \"../contrib/lax_der_privatekey_parsing.c\"\n \n #include \"modinv32_impl.h\"\n #ifdef SECP256K1_WIDEMUL_INT128\n@@ -564,6 +564,38 @@ void run_rfc6979_hmac_sha256_tests(void) {\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n }\n \n+void run_tagged_sha256_tests(void) {\n+    int ecount = 0;\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    unsigned char tag[32] = { 0 };\n+    unsigned char msg[32] = { 0 };\n+    unsigned char hash32[32];\n+    unsigned char hash_expected[32] = {\n+        0x04, 0x7A, 0x5E, 0x17, 0xB5, 0x86, 0x47, 0xC1,\n+        0x3C, 0xC6, 0xEB, 0xC0, 0xAA, 0x58, 0x3B, 0x62,\n+        0xFB, 0x16, 0x43, 0x32, 0x68, 0x77, 0x40, 0x6C,\n+        0xE2, 0x76, 0x55, 0x9A, 0x3B, 0xDE, 0x55, 0xB3\n+    };\n+\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+\n+    /* API test */\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, sizeof(tag), msg, sizeof(msg)) == 1);\n+    CHECK(secp256k1_tagged_sha256(none, NULL, tag, sizeof(tag), msg, sizeof(msg)) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, NULL, 0, msg, sizeof(msg)) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, sizeof(tag), NULL, 0) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Static test vector */\n+    memcpy(tag, \"tag\", 3);\n+    memcpy(msg, \"msg\", 3);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, 3, msg, 3) == 1);\n+    CHECK(secp256k1_memcmp_var(hash32, hash_expected, sizeof(hash32)) == 0);\n+    secp256k1_context_destroy(none);\n+}\n+\n /***** RANDOM TESTS *****/\n \n void test_rand_bits(int rand32, int bits) {\n@@ -2508,6 +2540,70 @@ void run_field_misc(void) {\n     }\n }\n \n+void test_fe_mul(const secp256k1_fe* a, const secp256k1_fe* b, int use_sqr)\n+{\n+    secp256k1_fe c, an, bn;\n+    /* Variables in BE 32-byte format. */\n+    unsigned char a32[32], b32[32], c32[32];\n+    /* Variables in LE 16x uint16_t format. */\n+    uint16_t a16[16], b16[16], c16[16];\n+    /* Field modulus in LE 16x uint16_t format. */\n+    static const uint16_t m16[16] = {\n+        0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+    };\n+    uint16_t t16[32];\n+    int i;\n+\n+    /* Compute C = A * B in fe format. */\n+    c = *a;\n+    if (use_sqr) {\n+        secp256k1_fe_sqr(&c, &c);\n+    } else {\n+        secp256k1_fe_mul(&c, &c, b);\n+    }\n+\n+    /* Convert A, B, C into LE 16x uint16_t format. */\n+    an = *a;\n+    bn = *b;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_normalize_var(&an);\n+    secp256k1_fe_normalize_var(&bn);\n+    secp256k1_fe_get_b32(a32, &an);\n+    secp256k1_fe_get_b32(b32, &bn);\n+    secp256k1_fe_get_b32(c32, &c);\n+    for (i = 0; i < 16; ++i) {\n+        a16[i] = a32[31 - 2*i] + ((uint16_t)a32[30 - 2*i] << 8);\n+        b16[i] = b32[31 - 2*i] + ((uint16_t)b32[30 - 2*i] << 8);\n+        c16[i] = c32[31 - 2*i] + ((uint16_t)c32[30 - 2*i] << 8);\n+    }\n+    /* Compute T = A * B in LE 16x uint16_t format. */\n+    mulmod256(t16, a16, b16, m16);\n+    /* Compare */\n+    CHECK(secp256k1_memcmp_var(t16, c16, 32) == 0);\n+}\n+\n+void run_fe_mul(void) {\n+    int i;\n+    for (i = 0; i < 100 * count; ++i) {\n+        secp256k1_fe a, b, c, d;\n+        random_fe(&a);\n+        random_field_element_magnitude(&a);\n+        random_fe(&b);\n+        random_field_element_magnitude(&b);\n+        random_fe_test(&c);\n+        random_field_element_magnitude(&c);\n+        random_fe_test(&d);\n+        random_field_element_magnitude(&d);\n+        test_fe_mul(&a, &a, 1);\n+        test_fe_mul(&c, &c, 1);\n+        test_fe_mul(&a, &b, 0);\n+        test_fe_mul(&a, &c, 0);\n+        test_fe_mul(&c, &b, 0);\n+        test_fe_mul(&c, &d, 0);\n+    }\n+}\n+\n void run_sqr(void) {\n     secp256k1_fe x, s;\n \n@@ -2595,7 +2691,7 @@ void test_inverse_scalar(secp256k1_scalar* out, const secp256k1_scalar* x, int v\n {\n     secp256k1_scalar l, r, t;\n \n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&l, x);  /* l = 1/x */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&l, x);  /* l = 1/x */\n     if (out) *out = l;\n     if (secp256k1_scalar_is_zero(x)) {\n         CHECK(secp256k1_scalar_is_zero(&l));\n@@ -2605,9 +2701,9 @@ void test_inverse_scalar(secp256k1_scalar* out, const secp256k1_scalar* x, int v\n     CHECK(secp256k1_scalar_is_one(&t));                                          /* x*(1/x) == 1 */\n     secp256k1_scalar_add(&r, x, &scalar_minus_one);                              /* r = x-1 */\n     if (secp256k1_scalar_is_zero(&r)) return;\n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&r, &r); /* r = 1/(x-1) */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&r, &r); /* r = 1/(x-1) */\n     secp256k1_scalar_add(&l, &scalar_minus_one, &l);                             /* l = 1/x-1 */\n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&l, &l); /* l = 1/(1/x-1) */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&l, &l); /* l = 1/(1/x-1) */\n     secp256k1_scalar_add(&l, &l, &secp256k1_scalar_one);                         /* l = 1/(1/x-1)+1 */\n     secp256k1_scalar_add(&l, &r, &l);                                            /* l = 1/(1/x-1)+1 + 1/(x-1) */\n     CHECK(secp256k1_scalar_is_zero(&l));                                         /* l == 0 */\n@@ -3101,20 +3197,34 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n+        int odd;\n         random_group_element_test(&ge[i]);\n+        odd = secp256k1_fe_is_odd(&ge[i].x);\n+        CHECK(odd == 0 || odd == 1);\n         /* randomly set half the points to infinity */\n-        if(secp256k1_fe_is_odd(&ge[i].x)) {\n+        if (odd == i % 2) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n         secp256k1_gej_set_ge(&gej[i], &ge[i]);\n     }\n-    /* batch invert */\n+    /* batch convert */\n     secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n     /* check result */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         ge_equals_gej(&ge[i], &gej[i]);\n     }\n \n+    /* Test batch gej -> ge conversion with all infinities. */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        secp256k1_gej_set_infinity(&gej[i]);\n+    }\n+    /* batch convert */\n+    secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n+    /* check result */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        CHECK(secp256k1_ge_is_infinity(&ge[i]));\n+    }\n+\n     free(ge);\n     free(gej);\n }\n@@ -5434,6 +5544,55 @@ void test_random_pubkeys(void) {\n     }\n }\n \n+void run_pubkey_comparison(void) {\n+    unsigned char pk1_ser[33] = {\n+        0x02,\n+        0x58, 0x84, 0xb3, 0xa2, 0x4b, 0x97, 0x37, 0x88, 0x92, 0x38, 0xa6, 0x26, 0x62, 0x52, 0x35, 0x11,\n+        0xd0, 0x9a, 0xa1, 0x1b, 0x80, 0x0b, 0x5e, 0x93, 0x80, 0x26, 0x11, 0xef, 0x67, 0x4b, 0xd9, 0x23\n+    };\n+    const unsigned char pk2_ser[33] = {\n+        0x02,\n+        0xde, 0x36, 0x0e, 0x87, 0x59, 0x8f, 0x3c, 0x01, 0x36, 0x2a, 0x2a, 0xb8, 0xc6, 0xf4, 0x5e, 0x4d,\n+        0xb2, 0xc2, 0xd5, 0x03, 0xa7, 0xf9, 0xf1, 0x4f, 0xa8, 0xfa, 0x95, 0xa8, 0xe9, 0x69, 0x76, 0x1c\n+    };\n+    secp256k1_pubkey pk1;\n+    secp256k1_pubkey pk2;\n+    int32_t ecount = 0;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk1, pk1_ser, sizeof(pk1_ser)) == 1);\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk2, pk2_ser, sizeof(pk2_ser)) == 1);\n+\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, NULL, &pk2) < 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, NULL) > 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk1) > 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk1) == 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk2) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        secp256k1_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp)); /* illegal pubkey */\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk_tmp, &pk2) < 0);\n+        CHECK(ecount == 3);\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk_tmp, &pk_tmp) == 0);\n+        CHECK(ecount == 5);\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk_tmp) > 0);\n+        CHECK(ecount == 6);\n+    }\n+\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+\n+    /* Make pk2 the same as pk1 but with 3 rather than 2. Note that in\n+     * an uncompressed encoding, these would have the opposite ordering */\n+    pk1_ser[0] = 3;\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk2, pk1_ser, sizeof(pk1_ser)) == 1);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk1) > 0);\n+}\n+\n void run_random_pubkeys(void) {\n     int i;\n     for (i = 0; i < 10*count; i++) {\n@@ -6408,7 +6567,7 @@ int main(int argc, char **argv) {\n         count = strtol(argv[1], NULL, 0);\n     } else {\n         const char* env = getenv(\"SECP256K1_TEST_ITERS\");\n-        if (env) {\n+        if (env && strlen(env) > 0) {\n             count = strtol(env, NULL, 0);\n         }\n     }\n@@ -6442,13 +6601,15 @@ int main(int argc, char **argv) {\n     run_sha256_tests();\n     run_hmac_sha256_tests();\n     run_rfc6979_hmac_sha256_tests();\n+    run_tagged_sha256_tests();\n \n     /* scalar tests */\n     run_scalar_tests();\n \n     /* field tests */\n     run_field_misc();\n     run_field_convert();\n+    run_fe_mul();\n     run_sqr();\n     run_sqrt();\n \n@@ -6485,6 +6646,7 @@ int main(int argc, char **argv) {\n #endif\n \n     /* ecdsa tests */\n+    run_pubkey_comparison();\n     run_random_pubkeys();\n     run_ecdsa_der_parse();\n     run_ecdsa_sign_verify();"
      },
      {
        "sha": "5b9a3035d9a717e1d2a3f2846ce670ff3e9648b4",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -10,7 +10,6 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n-\n #include <time.h>\n \n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n@@ -20,10 +19,10 @@\n #define EXHAUSTIVE_TEST_ORDER 13\n #endif\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"group.h\"\n-#include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n static int count = 2;\n@@ -303,6 +302,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n             if (skip_section(&iter)) continue;\n             for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n                 const int starting_k = k;\n+                int ret;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -311,7 +311,8 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 secp256k1_scalar_get_b32(sk32, &sk);\n                 secp256k1_scalar_get_b32(msg32, &msg);\n \n-                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+                ret = secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+                CHECK(ret == 1);\n \n                 secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n                 /* Note that we compute expected_r *after* signing -- this is important"
      },
      {
        "sha": "ea6d4b3deb3bcbebf01cb8002b9281a5bc2955e3",
        "filename": "src/secp256k1/src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/secp256k1/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/valgrind_ctime_test.c?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -7,24 +7,24 @@\n #include <valgrind/memcheck.h>\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n \n #ifdef ENABLE_MODULE_ECDH\n-# include \"include/secp256k1_ecdh.h\"\n+# include \"../include/secp256k1_ecdh.h\"\n #endif\n \n #ifdef ENABLE_MODULE_RECOVERY\n-# include \"include/secp256k1_recovery.h\"\n+# include \"../include/secp256k1_recovery.h\"\n #endif\n \n #ifdef ENABLE_MODULE_EXTRAKEYS\n-# include \"include/secp256k1_extrakeys.h\"\n+# include \"../include/secp256k1_extrakeys.h\"\n #endif\n \n #ifdef ENABLE_MODULE_SCHNORRSIG\n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../include/secp256k1_schnorrsig.h\"\n #endif\n \n void run_tests(secp256k1_context *ctx, unsigned char *key);\n@@ -166,7 +166,7 @@ void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n-    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif"
      },
      {
        "sha": "79c7102c4fc95f28d8f916319a515fbb66eadaa4",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 119,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -2,7 +2,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include <addrman.h>\n-#include <i2p.h>\n #include <test/data/asmap.raw.h>\n #include <test/util/setup_common.h>\n #include <util/asmap.h>\n@@ -35,6 +34,7 @@ class CAddrManTest : public CAddrMan\n     //! Ensure that bucket placement is always the same for testing purposes.\n     void MakeDeterministic()\n     {\n+        LOCK(cs);\n         nKey.SetNull();\n         insecure_rand = FastRandomContext(true);\n     }\n@@ -77,7 +77,7 @@ class CAddrManTest : public CAddrMan\n     {\n          int64_t nLastSuccess = 1;\n          // Set last good connection in the deep past.\n-         Good(addr, true, nLastSuccess);\n+         Good(addr, nLastSuccess);\n \n          bool count_failure = false;\n          int64_t nLastTry = GetAdjustedTime()-61;\n@@ -88,11 +88,11 @@ class CAddrManTest : public CAddrMan\n     {\n         CAddrMan::Clear();\n         if (deterministic) {\n+            LOCK(cs);\n             nKey.SetNull();\n             insecure_rand = FastRandomContext(true);\n         }\n     }\n-\n };\n \n static CNetAddr ResolveIP(const std::string& ip)\n@@ -967,121 +967,5 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n }\n \n-BOOST_AUTO_TEST_CASE(reset_i2p_ports)\n-{\n-    CAddrManTest addrman1;\n-    CAddrManTest addrman2;\n-    const uint32_t good_time{static_cast<uint32_t>(GetAdjustedTime())};\n-    constexpr uint16_t port = 8333;\n-\n-    // Has its port changed, will be re-positioned within the same bucket in vvNew.\n-    const CAddress i2p_new1{\n-        ResolveService(\"72l3ucjkuscrbiiepoehuwqgknyzgo7zuix5ty4puwrkyhtmnsga.b32.i2p\", port),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Has its port changed, will not be re-positioned in vvNew because ports 0 and 10075 result in\n-    // the same bucket position.\n-    const CAddress i2p_new2{\n-        ResolveService(\"gehtac45oaghz54ypyopim64mql7oad2bqclla74l6tfeolzmodq.b32.i2p\", 10075),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Remains unchanged, port is already as it should be.\n-    const CAddress i2p_new3{\n-        ResolveService(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\",\n-                       I2P_SAM31_PORT),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Has its port changed, re-positioning in vvNew will cause i2p_new3 to be evicted.\n-    const CAddress i2p_new4{\n-        ResolveService(\"c4cbbkn46qxftwja53pxiykntegfyfjqtnzbm6iv6r5mungmqgmq.b32.i2p\", port),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Remains unchanged.\n-    const CAddress ipv4_new{ResolveService(\"1.2.3.4\", port), NODE_NONE, good_time};\n-\n-    // Has its port changed, will be re-positioned in vvTried.\n-    const CAddress i2p_tried1{\n-        ResolveService(\"h3r6bkn46qxftwja53pxiykntegfyfjqtnzbm6iv6r5mungmqgmq.b32.i2p\", port),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Has its port changed, will not be re-positioned in vvTried because ports 0 and 10537\n-    // result in the same position (bucket, i).\n-    const CAddress i2p_tried2{\n-        ResolveService(\"pjs7or2ctvteeo5tu4bwyrtydeuhqhvdprtujn4daxr75jpebjxa.b32.i2p\", 10537),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Remains unchanged, port is already as it should be.\n-    const CAddress i2p_tried3{\n-        ResolveService(\"hnbbyjpxx54623l555sta7pocy3se4sdgmuebi5k6reesz5rjp6q.b32.i2p\",\n-                       I2P_SAM31_PORT),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Has its port changed, re-positioning in vvTried will cause i2p_tried3 to be moved to vvNew.\n-    const CAddress i2p_tried4{\n-        ResolveService(\"hna37nqr3ahkqv62cuqfwgtneekvvpnuc4i4f6yo7tpoqjswvcwa.b32.i2p\", port),\n-        NODE_NONE,\n-        good_time};\n-\n-    // Remains unchanged.\n-    const CAddress ipv4_tried{ResolveService(\"2.3.4.5\", port), NODE_NONE, good_time};\n-\n-    const CNetAddr source;\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-\n-    addrman1.Add(i2p_new1, source);\n-    addrman1.Add(i2p_new2, source);\n-    addrman1.Add(i2p_new3, source);\n-    addrman1.Add(i2p_new4, source);\n-    addrman1.Add(ipv4_new, source);\n-\n-    addrman1.Add(i2p_tried1, source);\n-    addrman1.Good(i2p_tried1);\n-    addrman1.Add(i2p_tried2, source);\n-    addrman1.Good(i2p_tried2);\n-    addrman1.Add(i2p_tried3, source);\n-    addrman1.Good(i2p_tried3);\n-    addrman1.Add(i2p_tried4, source);\n-    addrman1.Good(i2p_tried4);\n-    addrman1.Add(ipv4_tried, source);\n-    addrman1.Good(ipv4_tried);\n-\n-    stream << addrman1;\n-    stream >> addrman2;\n-\n-    const size_t max_addresses{0};\n-    const size_t max_pct{0};\n-\n-    auto addresses = addrman2.GetAddr(max_addresses, max_pct, NET_I2P);\n-    BOOST_REQUIRE_EQUAL(addresses.size(), 7UL);\n-    std::sort(addresses.begin(), addresses.end()); // Just some deterministic order.\n-    BOOST_CHECK_EQUAL(addresses[0].ToStringIP(), i2p_new4.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[0].GetPort(), I2P_SAM31_PORT);\n-    BOOST_CHECK_EQUAL(addresses[1].ToStringIP(), i2p_new2.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[1].GetPort(), I2P_SAM31_PORT);\n-    BOOST_CHECK_EQUAL(addresses[2].ToStringIP(), i2p_tried4.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[2].GetPort(), I2P_SAM31_PORT);\n-    BOOST_CHECK_EQUAL(addresses[3].ToStringIP(), i2p_tried3.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[3].GetPort(), I2P_SAM31_PORT);\n-    BOOST_CHECK_EQUAL(addresses[4].ToStringIP(), i2p_tried1.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[4].GetPort(), I2P_SAM31_PORT);\n-    BOOST_CHECK_EQUAL(addresses[5].ToStringIP(), i2p_tried2.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[5].GetPort(), I2P_SAM31_PORT);\n-    BOOST_CHECK_EQUAL(addresses[6].ToStringIP(), i2p_new1.ToStringIP());\n-    BOOST_CHECK_EQUAL(addresses[6].GetPort(), I2P_SAM31_PORT);\n-\n-    addresses = addrman2.GetAddr(max_addresses, max_pct, NET_IPV4);\n-    BOOST_REQUIRE_EQUAL(addresses.size(), 2UL);\n-    std::sort(addresses.begin(), addresses.end()); // Just some deterministic order.\n-    BOOST_CHECK_EQUAL(addresses[0].ToStringIPPort(), ipv4_new.ToStringIPPort());\n-    BOOST_CHECK_EQUAL(addresses[1].ToStringIPPort(), ipv4_tried.ToStringIPPort());\n-}\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0bfe6eecd9b2bdbeb6c8a4414429712c317e9b87",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -53,7 +53,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     const CChainParams& chainparams = Params();\n     auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     const CChainParams& chainparams = Params();\n     auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n     CConnman::Options options;\n@@ -194,7 +194,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     auto banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     CNetAddr tor_netaddr;\n     BOOST_REQUIRE(\n@@ -288,7 +288,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     auto banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "4c29a8ee538a4f6ebb838dc140a328eab838411d",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 224,
        "deletions": 11,
        "changes": 235,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -12,6 +12,7 @@\n #include <time.h>\n #include <util/asmap.h>\n \n+#include <cassert>\n #include <cstdint>\n #include <optional>\n #include <string>\n@@ -25,23 +26,217 @@ void initialize_addrman()\n class CAddrManDeterministic : public CAddrMan\n {\n public:\n-    void MakeDeterministic(const uint256& random_seed)\n+    FuzzedDataProvider& m_fuzzed_data_provider;\n+\n+    explicit CAddrManDeterministic(FuzzedDataProvider& fuzzed_data_provider)\n+        : m_fuzzed_data_provider(fuzzed_data_provider)\n+    {\n+        WITH_LOCK(cs, insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            m_asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n+            if (!SanityCheckASMap(m_asmap)) {\n+                m_asmap.clear();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generate a random address. Always returns a valid address.\n+     */\n+    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(cs)\n+    {\n+        CNetAddr addr;\n+        if (m_fuzzed_data_provider.remaining_bytes() > 1 && m_fuzzed_data_provider.ConsumeBool()) {\n+            addr = ConsumeNetAddr(m_fuzzed_data_provider);\n+        } else {\n+            // The networks [1..6] correspond to CNetAddr::BIP155Network (private).\n+            static const std::map<uint8_t, uint8_t> net_len_map = {{1, ADDR_IPV4_SIZE},\n+                                                                   {2, ADDR_IPV6_SIZE},\n+                                                                   {4, ADDR_TORV3_SIZE},\n+                                                                   {5, ADDR_I2P_SIZE},\n+                                                                   {6, ADDR_CJDNS_SIZE}};\n+            uint8_t net = insecure_rand.randrange(5) + 1; // [1..5]\n+            if (net == 3) {\n+                net = 6;\n+            }\n+\n+            CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+\n+            s << net;\n+            s << insecure_rand.randbytes(net_len_map.at(net));\n+\n+            s >> addr;\n+        }\n+\n+        // Return a dummy IPv4 5.5.5.5 if we generated an invalid address.\n+        if (!addr.IsValid()) {\n+            in_addr v4_addr = {};\n+            v4_addr.s_addr = 0x05050505;\n+            addr = CNetAddr{v4_addr};\n+        }\n+\n+        return addr;\n+    }\n+\n+    /**\n+     * Fill this addrman with lots of addresses from lots of sources.\n+     */\n+    void Fill()\n     {\n-        insecure_rand = FastRandomContext{random_seed};\n-        Clear();\n+        LOCK(cs);\n+\n+        // Add some of the addresses directly to the \"tried\" table.\n+\n+        // 0, 1, 2, 3 corresponding to 0%, 100%, 50%, 33%\n+        const size_t n = m_fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 3);\n+\n+        const size_t num_sources = m_fuzzed_data_provider.ConsumeIntegralInRange<size_t>(10, 50);\n+        CNetAddr prev_source;\n+        // Use insecure_rand inside the loops instead of m_fuzzed_data_provider because when\n+        // the latter is exhausted it just returns 0.\n+        for (size_t i = 0; i < num_sources; ++i) {\n+            const auto source = RandAddr();\n+            const size_t num_addresses = insecure_rand.randrange(500) + 1; // [1..500]\n+\n+            for (size_t j = 0; j < num_addresses; ++j) {\n+                const auto addr = CAddress{CService{RandAddr(), 8333}, NODE_NETWORK};\n+                const auto time_penalty = insecure_rand.randrange(100000001);\n+#if 1\n+                // 2.83 sec to fill.\n+                if (n > 0 && mapInfo.size() % n == 0 && mapAddr.find(addr) == mapAddr.end()) {\n+                    // Add to the \"tried\" table (if the bucket slot is free).\n+                    const CAddrInfo dummy{addr, source};\n+                    const int bucket = dummy.GetTriedBucket(nKey, m_asmap);\n+                    const int bucket_pos = dummy.GetBucketPosition(nKey, false, bucket);\n+                    if (vvTried[bucket][bucket_pos] == -1) {\n+                        int id;\n+                        CAddrInfo* addr_info = Create(addr, source, &id);\n+                        vvTried[bucket][bucket_pos] = id;\n+                        addr_info->fInTried = true;\n+                        ++nTried;\n+                    }\n+                } else {\n+                    // Add to the \"new\" table.\n+                    Add_(addr, source, time_penalty);\n+                }\n+#else\n+                // 261.91 sec to fill.\n+                Add_(addr, source, time_penalty);\n+                if (n > 0 && mapInfo.size() % n == 0) {\n+                    Good_(addr, false, GetTime());\n+                }\n+#endif\n+                // Add 10% of the addresses from more than one source.\n+                if (insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n+                    Add_(addr, prev_source, time_penalty);\n+                }\n+            }\n+            prev_source = source;\n+        }\n+    }\n+\n+    /**\n+     * Compare with another AddrMan.\n+     * This compares:\n+     * - the values in `mapInfo` (the keys aka ids are ignored)\n+     * - vvNew entries refer to the same addresses\n+     * - vvTried entries refer to the same addresses\n+     */\n+    bool operator==(const CAddrManDeterministic& other)\n+    {\n+        LOCK2(cs, other.cs);\n+\n+        if (mapInfo.size() != other.mapInfo.size() || nNew != other.nNew ||\n+            nTried != other.nTried) {\n+            return false;\n+        }\n+\n+        // Check that all values in `mapInfo` are equal to all values in `other.mapInfo`.\n+        // Keys may be different.\n+\n+        using CAddrInfoHasher = std::function<size_t(const CAddrInfo&)>;\n+        using CAddrInfoEq = std::function<bool(const CAddrInfo&, const CAddrInfo&)>;\n+\n+        CNetAddrHash netaddr_hasher;\n+\n+        CAddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const CAddrInfo& a) {\n+            return netaddr_hasher(static_cast<CNetAddr>(a)) ^ netaddr_hasher(a.source) ^\n+                   a.nLastSuccess ^ a.nAttempts ^ a.nRefCount ^ a.fInTried;\n+        };\n+\n+        CAddrInfoEq addrinfo_eq = [](const CAddrInfo& lhs, const CAddrInfo& rhs) {\n+            return static_cast<CNetAddr>(lhs) == static_cast<CNetAddr>(rhs) &&\n+                   lhs.source == rhs.source && lhs.nLastSuccess == rhs.nLastSuccess &&\n+                   lhs.nAttempts == rhs.nAttempts && lhs.nRefCount == rhs.nRefCount &&\n+                   lhs.fInTried == rhs.fInTried;\n+        };\n+\n+        using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n+\n+        const size_t num_addresses{mapInfo.size()};\n+\n+        Addresses addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n+        for (const auto& [id, addr] : mapInfo) {\n+            addresses.insert(addr);\n+        }\n+\n+        Addresses other_addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n+        for (const auto& [id, addr] : other.mapInfo) {\n+            other_addresses.insert(addr);\n+        }\n+\n+        if (addresses != other_addresses) {\n+            return false;\n+        }\n+\n+        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(cs, other.cs) {\n+            if (id == -1 && other_id == -1) {\n+                return true;\n+            }\n+            if ((id == -1 && other_id != -1) || (id != -1 && other_id == -1)) {\n+                return false;\n+            }\n+            return mapInfo.at(id) == other.mapInfo.at(other_id);\n+        };\n+\n+        // Check that `vvNew` contains the same addresses as `other.vvNew`. Notice - `vvNew[i][j]`\n+        // contains just an id and the address is to be found in `mapInfo.at(id)`. The ids\n+        // themselves may differ between `vvNew` and `other.vvNew`.\n+        for (size_t i = 0; i < ADDRMAN_NEW_BUCKET_COUNT; ++i) {\n+            for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n+                if (!IdsReferToSameAddress(vvNew[i][j], other.vvNew[i][j])) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        // Same for `vvTried`.\n+        for (size_t i = 0; i < ADDRMAN_TRIED_BUCKET_COUNT; ++i) {\n+            for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n+                if (!IdsReferToSameAddress(vvTried[i][j], other.vvTried[i][j])) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n     }\n };\n \n FUZZ_TARGET_INIT(addrman, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CAddrManDeterministic addr_man;\n-    addr_man.MakeDeterministic(ConsumeUInt256(fuzzed_data_provider));\n+    CAddrManDeterministic addr_man{fuzzed_data_provider};\n     if (fuzzed_data_provider.ConsumeBool()) {\n-        addr_man.m_asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-        if (!SanityCheckASMap(addr_man.m_asmap)) {\n-            addr_man.m_asmap.clear();\n+        const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n+        CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n+        const auto ser_version{fuzzed_data_provider.ConsumeIntegral<int32_t>()};\n+        ds.SetVersion(ser_version);\n+        try {\n+            ds >> addr_man;\n+        } catch (const std::ios_base::failure&) {\n+            addr_man.Clear();\n         }\n     }\n     while (fuzzed_data_provider.ConsumeBool()) {\n@@ -80,7 +275,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n             [&] {\n                 const std::optional<CService> opt_service = ConsumeDeserializable<CService>(fuzzed_data_provider);\n                 if (opt_service) {\n-                    addr_man.Good(*opt_service, fuzzed_data_provider.ConsumeBool(), ConsumeTime(fuzzed_data_provider));\n+                    addr_man.Good(*opt_service, ConsumeTime(fuzzed_data_provider));\n                 }\n             },\n             [&] {\n@@ -103,12 +298,30 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n             });\n     }\n     const CAddrMan& const_addr_man{addr_man};\n-    (void)/*const_*/addr_man.GetAddr(\n+    (void)const_addr_man.GetAddr(\n         /* max_addresses */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n         /* max_pct */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n         /* network */ std::nullopt);\n-    (void)/*const_*/addr_man.Select(fuzzed_data_provider.ConsumeBool());\n+    (void)const_addr_man.Select(fuzzed_data_provider.ConsumeBool());\n     (void)const_addr_man.size();\n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n     data_stream << const_addr_man;\n }\n+\n+// Check that serialize followed by unserialize produces the same addrman.\n+FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+\n+    CAddrManDeterministic addr_man1{fuzzed_data_provider};\n+    CAddrManDeterministic addr_man2{fuzzed_data_provider};\n+    addr_man2.m_asmap = addr_man1.m_asmap;\n+\n+    CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n+\n+    addr_man1.Fill();\n+    data_stream << addr_man1;\n+    data_stream >> addr_man2;\n+    assert(addr_man1 == addr_man2);\n+}"
      },
      {
        "sha": "de211f601fa0edb28c9b5bf79d87ff476f0067fb",
        "filename": "src/test/fuzz/banman.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/banman.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -52,8 +52,7 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n     const bool start_with_corrupted_banlist{fuzzed_data_provider.ConsumeBool()};\n     bool force_read_and_write_to_err{false};\n     if (start_with_corrupted_banlist) {\n-        const std::string sfx{fuzzed_data_provider.ConsumeBool() ? \".dat\" : \".json\"};\n-        assert(WriteBinaryFile(banlist_file.string() + sfx,\n+        assert(WriteBinaryFile(banlist_file.string() + \".json\",\n                                fuzzed_data_provider.ConsumeRandomLengthString()));\n     } else {\n         force_read_and_write_to_err = fuzzed_data_provider.ConsumeBool();\n@@ -109,9 +108,10 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n             BanMan ban_man_read{banlist_file, /* client_interface */ nullptr, /* default_ban_time */ 0};\n             banmap_t banmap_read;\n             ban_man_read.GetBanned(banmap_read);\n-            assert(banmap == banmap_read);\n+            // Assert temporarily disabled to allow the remainder of the fuzz test to run while a\n+            // fix is being worked on. See https://github.com/bitcoin/bitcoin/pull/22517\n+            (void)(banmap == banmap_read);\n         }\n     }\n-    fs::remove(banlist_file.string() + \".dat\");\n     fs::remove(banlist_file.string() + \".json\");\n }"
      },
      {
        "sha": "bbdb2c6917ddab09ad4e59e60768b967f4be7f80",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -258,7 +258,7 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n                     // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n                     return;\n                 }\n-                const int flags = fuzzed_data_provider.ConsumeIntegral<int>();\n+                const auto flags{fuzzed_data_provider.ConsumeIntegral<uint32_t>()};\n                 if (!transaction.vin.empty() && (flags & SCRIPT_VERIFY_WITNESS) != 0 && (flags & SCRIPT_VERIFY_P2SH) == 0) {\n                     // Avoid:\n                     // script/interpreter.cpp:1705: size_t CountWitnessSigOps(const CScript &, const CScript &, const CScriptWitness *, unsigned int): Assertion `(flags & SCRIPT_VERIFY_P2SH) != 0' failed."
      },
      {
        "sha": "d5b56cb7cd8fc14e98042e346a59d9ef8283c354",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 134,
        "deletions": 145,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -100,228 +100,217 @@ void AssertEqualAfterSerializeDeserialize(const T& obj, const int version = INIT\n } // namespace\n \n FUZZ_TARGET_DESERIALIZE(block_filter_deserialize, {\n-        BlockFilter block_filter;\n-        DeserializeFromFuzzingInput(buffer, block_filter);\n+    BlockFilter block_filter;\n+    DeserializeFromFuzzingInput(buffer, block_filter);\n })\n FUZZ_TARGET_DESERIALIZE(addr_info_deserialize, {\n-        CAddrInfo addr_info;\n-        DeserializeFromFuzzingInput(buffer, addr_info);\n+    CAddrInfo addr_info;\n+    DeserializeFromFuzzingInput(buffer, addr_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_file_info_deserialize, {\n-        CBlockFileInfo block_file_info;\n-        DeserializeFromFuzzingInput(buffer, block_file_info);\n+    CBlockFileInfo block_file_info;\n+    DeserializeFromFuzzingInput(buffer, block_file_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_header_and_short_txids_deserialize, {\n-        CBlockHeaderAndShortTxIDs block_header_and_short_txids;\n-        DeserializeFromFuzzingInput(buffer, block_header_and_short_txids);\n+    CBlockHeaderAndShortTxIDs block_header_and_short_txids;\n+    DeserializeFromFuzzingInput(buffer, block_header_and_short_txids);\n })\n FUZZ_TARGET_DESERIALIZE(fee_rate_deserialize, {\n-        CFeeRate fee_rate;\n-        DeserializeFromFuzzingInput(buffer, fee_rate);\n-        AssertEqualAfterSerializeDeserialize(fee_rate);\n+    CFeeRate fee_rate;\n+    DeserializeFromFuzzingInput(buffer, fee_rate);\n+    AssertEqualAfterSerializeDeserialize(fee_rate);\n })\n FUZZ_TARGET_DESERIALIZE(merkle_block_deserialize, {\n-        CMerkleBlock merkle_block;\n-        DeserializeFromFuzzingInput(buffer, merkle_block);\n+    CMerkleBlock merkle_block;\n+    DeserializeFromFuzzingInput(buffer, merkle_block);\n })\n FUZZ_TARGET_DESERIALIZE(out_point_deserialize, {\n-        COutPoint out_point;\n-        DeserializeFromFuzzingInput(buffer, out_point);\n-        AssertEqualAfterSerializeDeserialize(out_point);\n+    COutPoint out_point;\n+    DeserializeFromFuzzingInput(buffer, out_point);\n+    AssertEqualAfterSerializeDeserialize(out_point);\n })\n FUZZ_TARGET_DESERIALIZE(partial_merkle_tree_deserialize, {\n-        CPartialMerkleTree partial_merkle_tree;\n-        DeserializeFromFuzzingInput(buffer, partial_merkle_tree);\n+    CPartialMerkleTree partial_merkle_tree;\n+    DeserializeFromFuzzingInput(buffer, partial_merkle_tree);\n })\n FUZZ_TARGET_DESERIALIZE(pub_key_deserialize, {\n-        CPubKey pub_key;\n-        DeserializeFromFuzzingInput(buffer, pub_key);\n-        AssertEqualAfterSerializeDeserialize(pub_key);\n+    CPubKey pub_key;\n+    DeserializeFromFuzzingInput(buffer, pub_key);\n+    AssertEqualAfterSerializeDeserialize(pub_key);\n })\n FUZZ_TARGET_DESERIALIZE(script_deserialize, {\n-        CScript script;\n-        DeserializeFromFuzzingInput(buffer, script);\n-})\n-FUZZ_TARGET_DESERIALIZE(sub_net_deserialize, {\n-        CSubNet sub_net_1;\n-        DeserializeFromFuzzingInput(buffer, sub_net_1, INIT_PROTO_VERSION);\n-        AssertEqualAfterSerializeDeserialize(sub_net_1, INIT_PROTO_VERSION);\n-        CSubNet sub_net_2;\n-        DeserializeFromFuzzingInput(buffer, sub_net_2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(sub_net_2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        CSubNet sub_net_3;\n-        DeserializeFromFuzzingInput(buffer, sub_net_3);\n-        AssertEqualAfterSerializeDeserialize(sub_net_3, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CScript script;\n+    DeserializeFromFuzzingInput(buffer, script);\n })\n FUZZ_TARGET_DESERIALIZE(tx_in_deserialize, {\n-        CTxIn tx_in;\n-        DeserializeFromFuzzingInput(buffer, tx_in);\n-        AssertEqualAfterSerializeDeserialize(tx_in);\n+    CTxIn tx_in;\n+    DeserializeFromFuzzingInput(buffer, tx_in);\n+    AssertEqualAfterSerializeDeserialize(tx_in);\n })\n FUZZ_TARGET_DESERIALIZE(flat_file_pos_deserialize, {\n-        FlatFilePos flat_file_pos;\n-        DeserializeFromFuzzingInput(buffer, flat_file_pos);\n-        AssertEqualAfterSerializeDeserialize(flat_file_pos);\n+    FlatFilePos flat_file_pos;\n+    DeserializeFromFuzzingInput(buffer, flat_file_pos);\n+    AssertEqualAfterSerializeDeserialize(flat_file_pos);\n })\n FUZZ_TARGET_DESERIALIZE(key_origin_info_deserialize, {\n-        KeyOriginInfo key_origin_info;\n-        DeserializeFromFuzzingInput(buffer, key_origin_info);\n-        AssertEqualAfterSerializeDeserialize(key_origin_info);\n+    KeyOriginInfo key_origin_info;\n+    DeserializeFromFuzzingInput(buffer, key_origin_info);\n+    AssertEqualAfterSerializeDeserialize(key_origin_info);\n })\n FUZZ_TARGET_DESERIALIZE(partially_signed_transaction_deserialize, {\n-        PartiallySignedTransaction partially_signed_transaction;\n-        DeserializeFromFuzzingInput(buffer, partially_signed_transaction);\n+    PartiallySignedTransaction partially_signed_transaction;\n+    DeserializeFromFuzzingInput(buffer, partially_signed_transaction);\n })\n FUZZ_TARGET_DESERIALIZE(prefilled_transaction_deserialize, {\n-        PrefilledTransaction prefilled_transaction;\n-        DeserializeFromFuzzingInput(buffer, prefilled_transaction);\n+    PrefilledTransaction prefilled_transaction;\n+    DeserializeFromFuzzingInput(buffer, prefilled_transaction);\n })\n FUZZ_TARGET_DESERIALIZE(psbt_input_deserialize, {\n-        PSBTInput psbt_input;\n-        DeserializeFromFuzzingInput(buffer, psbt_input);\n+    PSBTInput psbt_input;\n+    DeserializeFromFuzzingInput(buffer, psbt_input);\n })\n FUZZ_TARGET_DESERIALIZE(psbt_output_deserialize, {\n-        PSBTOutput psbt_output;\n-        DeserializeFromFuzzingInput(buffer, psbt_output);\n+    PSBTOutput psbt_output;\n+    DeserializeFromFuzzingInput(buffer, psbt_output);\n })\n FUZZ_TARGET_DESERIALIZE(block_deserialize, {\n-        CBlock block;\n-        DeserializeFromFuzzingInput(buffer, block);\n+    CBlock block;\n+    DeserializeFromFuzzingInput(buffer, block);\n })\n FUZZ_TARGET_DESERIALIZE(blocklocator_deserialize, {\n-        CBlockLocator bl;\n-        DeserializeFromFuzzingInput(buffer, bl);\n+    CBlockLocator bl;\n+    DeserializeFromFuzzingInput(buffer, bl);\n })\n FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n-        CBlock block;\n-        DeserializeFromFuzzingInput(buffer, block);\n-        bool mutated;\n-        BlockMerkleRoot(block, &mutated);\n+    CBlock block;\n+    DeserializeFromFuzzingInput(buffer, block);\n+    bool mutated;\n+    BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-        CAddrMan am;\n-        DeserializeFromFuzzingInput(buffer, am);\n+    CAddrMan am;\n+    DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {\n-        CBlockHeader bh;\n-        DeserializeFromFuzzingInput(buffer, bh);\n+    CBlockHeader bh;\n+    DeserializeFromFuzzingInput(buffer, bh);\n })\n FUZZ_TARGET_DESERIALIZE(banentry_deserialize, {\n-        CBanEntry be;\n-        DeserializeFromFuzzingInput(buffer, be);\n+    CBanEntry be;\n+    DeserializeFromFuzzingInput(buffer, be);\n })\n FUZZ_TARGET_DESERIALIZE(txundo_deserialize, {\n-        CTxUndo tu;\n-        DeserializeFromFuzzingInput(buffer, tu);\n+    CTxUndo tu;\n+    DeserializeFromFuzzingInput(buffer, tu);\n })\n FUZZ_TARGET_DESERIALIZE(blockundo_deserialize, {\n-        CBlockUndo bu;\n-        DeserializeFromFuzzingInput(buffer, bu);\n+    CBlockUndo bu;\n+    DeserializeFromFuzzingInput(buffer, bu);\n })\n FUZZ_TARGET_DESERIALIZE(coins_deserialize, {\n-        Coin coin;\n-        DeserializeFromFuzzingInput(buffer, coin);\n+    Coin coin;\n+    DeserializeFromFuzzingInput(buffer, coin);\n })\n FUZZ_TARGET_DESERIALIZE(netaddr_deserialize, {\n-        CNetAddr na;\n-        DeserializeFromFuzzingInput(buffer, na);\n-        if (na.IsAddrV1Compatible()) {\n-            AssertEqualAfterSerializeDeserialize(na);\n-        }\n-        AssertEqualAfterSerializeDeserialize(na, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CNetAddr na;\n+    DeserializeFromFuzzingInput(buffer, na);\n+    if (na.IsAddrV1Compatible()) {\n+        AssertEqualAfterSerializeDeserialize(na);\n+    }\n+    AssertEqualAfterSerializeDeserialize(na, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n })\n FUZZ_TARGET_DESERIALIZE(service_deserialize, {\n-        CService s;\n-        DeserializeFromFuzzingInput(buffer, s);\n-        if (s.IsAddrV1Compatible()) {\n-            AssertEqualAfterSerializeDeserialize(s);\n-        }\n-        AssertEqualAfterSerializeDeserialize(s, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        CService s1;\n-        DeserializeFromFuzzingInput(buffer, s1, INIT_PROTO_VERSION);\n-        AssertEqualAfterSerializeDeserialize(s1, INIT_PROTO_VERSION);\n-        assert(s1.IsAddrV1Compatible());\n-        CService s2;\n-        DeserializeFromFuzzingInput(buffer, s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CService s;\n+    DeserializeFromFuzzingInput(buffer, s);\n+    if (s.IsAddrV1Compatible()) {\n+        AssertEqualAfterSerializeDeserialize(s);\n+    }\n+    AssertEqualAfterSerializeDeserialize(s, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    CService s1;\n+    DeserializeFromFuzzingInput(buffer, s1, INIT_PROTO_VERSION);\n+    AssertEqualAfterSerializeDeserialize(s1, INIT_PROTO_VERSION);\n+    assert(s1.IsAddrV1Compatible());\n+    CService s2;\n+    DeserializeFromFuzzingInput(buffer, s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(s2, INIT_PROTO_VERSION | ADDRV2_FORMAT);\n })\n FUZZ_TARGET_DESERIALIZE(messageheader_deserialize, {\n-        CMessageHeader mh;\n-        DeserializeFromFuzzingInput(buffer, mh);\n-        (void)mh.IsCommandValid();\n+    CMessageHeader mh;\n+    DeserializeFromFuzzingInput(buffer, mh);\n+    (void)mh.IsCommandValid();\n })\n FUZZ_TARGET_DESERIALIZE(address_deserialize_v1_notime, {\n-        CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a, INIT_PROTO_VERSION);\n-        // A CAddress without nTime (as is expected under INIT_PROTO_VERSION) will roundtrip\n-        // in all 5 formats (with/without nTime, v1/v2, network/disk)\n-        AssertEqualAfterSerializeDeserialize(a, INIT_PROTO_VERSION);\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n-        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+    CAddress a;\n+    DeserializeFromFuzzingInput(buffer, a, INIT_PROTO_VERSION);\n+    // A CAddress without nTime (as is expected under INIT_PROTO_VERSION) will roundtrip\n+    // in all 5 formats (with/without nTime, v1/v2, network/disk)\n+    AssertEqualAfterSerializeDeserialize(a, INIT_PROTO_VERSION);\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+    AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(address_deserialize_v1_withtime, {\n-        CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION);\n-        // A CAddress in V1 mode will roundtrip in all 4 formats that have nTime.\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n-        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+    CAddress a;\n+    DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION);\n+    // A CAddress in V1 mode will roundtrip in all 4 formats that have nTime.\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+    AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(address_deserialize_v2, {\n-        CAddress a;\n-        DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        // A CAddress in V2 mode will roundtrip in both V2 formats, and also in the V1 formats\n-        // with time if it's V1 compatible.\n-        if (a.IsAddrV1Compatible()) {\n-            AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n-            AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n-        }\n-        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n-        AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n+    CAddress a;\n+    DeserializeFromFuzzingInput(buffer, a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    // A CAddress in V2 mode will roundtrip in both V2 formats, and also in the V1 formats\n+    // with time if it's V1 compatible.\n+    if (a.IsAddrV1Compatible()) {\n+        AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION);\n+        AssertEqualAfterSerializeDeserialize(a, 0, SER_DISK);\n+    }\n+    AssertEqualAfterSerializeDeserialize(a, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    AssertEqualAfterSerializeDeserialize(a, ADDRV2_FORMAT, SER_DISK);\n })\n FUZZ_TARGET_DESERIALIZE(inv_deserialize, {\n-        CInv i;\n-        DeserializeFromFuzzingInput(buffer, i);\n+    CInv i;\n+    DeserializeFromFuzzingInput(buffer, i);\n })\n FUZZ_TARGET_DESERIALIZE(bloomfilter_deserialize, {\n-        CBloomFilter bf;\n-        DeserializeFromFuzzingInput(buffer, bf);\n+    CBloomFilter bf;\n+    DeserializeFromFuzzingInput(buffer, bf);\n })\n FUZZ_TARGET_DESERIALIZE(diskblockindex_deserialize, {\n-        CDiskBlockIndex dbi;\n-        DeserializeFromFuzzingInput(buffer, dbi);\n+    CDiskBlockIndex dbi;\n+    DeserializeFromFuzzingInput(buffer, dbi);\n })\n FUZZ_TARGET_DESERIALIZE(txoutcompressor_deserialize, {\n-        CTxOut to;\n-        auto toc = Using<TxOutCompression>(to);\n-        DeserializeFromFuzzingInput(buffer, toc);\n+    CTxOut to;\n+    auto toc = Using<TxOutCompression>(to);\n+    DeserializeFromFuzzingInput(buffer, toc);\n })\n FUZZ_TARGET_DESERIALIZE(blocktransactions_deserialize, {\n-        BlockTransactions bt;\n-        DeserializeFromFuzzingInput(buffer, bt);\n+    BlockTransactions bt;\n+    DeserializeFromFuzzingInput(buffer, bt);\n })\n FUZZ_TARGET_DESERIALIZE(blocktransactionsrequest_deserialize, {\n-        BlockTransactionsRequest btr;\n-        DeserializeFromFuzzingInput(buffer, btr);\n+    BlockTransactionsRequest btr;\n+    DeserializeFromFuzzingInput(buffer, btr);\n })\n FUZZ_TARGET_DESERIALIZE(snapshotmetadata_deserialize, {\n-        SnapshotMetadata snapshot_metadata;\n-        DeserializeFromFuzzingInput(buffer, snapshot_metadata);\n+    SnapshotMetadata snapshot_metadata;\n+    DeserializeFromFuzzingInput(buffer, snapshot_metadata);\n })\n FUZZ_TARGET_DESERIALIZE(uint160_deserialize, {\n-        uint160 u160;\n-        DeserializeFromFuzzingInput(buffer, u160);\n-        AssertEqualAfterSerializeDeserialize(u160);\n+    uint160 u160;\n+    DeserializeFromFuzzingInput(buffer, u160);\n+    AssertEqualAfterSerializeDeserialize(u160);\n })\n FUZZ_TARGET_DESERIALIZE(uint256_deserialize, {\n-        uint256 u256;\n-        DeserializeFromFuzzingInput(buffer, u256);\n-        AssertEqualAfterSerializeDeserialize(u256);\n-})\n-        // Classes intentionally not covered in this file since their deserialization code is\n-        // fuzzed elsewhere:\n-        // * Deserialization of CTxOut is fuzzed in test/fuzz/tx_out.cpp\n-        // * Deserialization of CMutableTransaction is fuzzed in src/test/fuzz/transaction.cpp\n+    uint256 u256;\n+    DeserializeFromFuzzingInput(buffer, u256);\n+    AssertEqualAfterSerializeDeserialize(u256);\n+})\n+// Classes intentionally not covered in this file since their deserialization code is\n+// fuzzed elsewhere:\n+// * Deserialization of CTxOut is fuzzed in test/fuzz/tx_out.cpp\n+// * Deserialization of CMutableTransaction is fuzzed in src/test/fuzz/transaction.cpp"
      },
      {
        "sha": "82f3a306c586c02762deefaf15ef5a60deaccb84",
        "filename": "src/test/fuzz/kitchen_sink.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/kitchen_sink.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/kitchen_sink.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/kitchen_sink.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -13,6 +13,7 @@\n \n #include <array>\n #include <cstdint>\n+#include <optional>\n #include <vector>\n \n namespace {\n@@ -46,11 +47,10 @@ FUZZ_TARGET(kitchen_sink)\n \n     const OutputType output_type = fuzzed_data_provider.PickValueInArray(OUTPUT_TYPES);\n     const std::string& output_type_string = FormatOutputType(output_type);\n-    OutputType output_type_parsed;\n-    const bool parsed = ParseOutputType(output_type_string, output_type_parsed);\n+    const std::optional<OutputType> parsed = ParseOutputType(output_type_string);\n     assert(parsed);\n-    assert(output_type == output_type_parsed);\n-    (void)ParseOutputType(fuzzed_data_provider.ConsumeRandomLengthString(64), output_type_parsed);\n+    assert(output_type == parsed.value());\n+    (void)ParseOutputType(fuzzed_data_provider.ConsumeRandomLengthString(64));\n \n     const std::vector<uint8_t> bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n     const std::vector<bool> bits = BytesToBits(bytes);"
      },
      {
        "sha": "c7251650c258031391722f2121e428f5c539fd20",
        "filename": "src/test/fuzz/multiplication_overflow.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/multiplication_overflow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/multiplication_overflow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/multiplication_overflow.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -2,6 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n@@ -10,14 +14,6 @@\n #include <string>\n #include <vector>\n \n-#if defined(__has_builtin)\n-#if __has_builtin(__builtin_mul_overflow)\n-#define HAVE_BUILTIN_MUL_OVERFLOW\n-#endif\n-#elif defined(__GNUC__)\n-#define HAVE_BUILTIN_MUL_OVERFLOW\n-#endif\n-\n namespace {\n template <typename T>\n void TestMultiplicationOverflow(FuzzedDataProvider& fuzzed_data_provider)"
      },
      {
        "sha": "447f32ed16cf490c5b85aa744611a4accd1b8589",
        "filename": "src/test/fuzz/prevector.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/prevector.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -206,10 +206,14 @@ class prevector_tester\n \n FUZZ_TARGET(prevector)\n {\n+    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n+    // inputs.\n+    int limit_max_ops{3000};\n+\n     FuzzedDataProvider prov(buffer.data(), buffer.size());\n     prevector_tester<8, int> test;\n \n-    while (prov.remaining_bytes()) {\n+    while (--limit_max_ops >= 0 && prov.remaining_bytes()) {\n         switch (prov.ConsumeIntegralInRange<int>(0, 13 + 3 * (test.size() > 0))) {\n         case 0:\n             test.insert(prov.ConsumeIntegralInRange<size_t>(0, test.size()), prov.ConsumeIntegral<int>());"
      },
      {
        "sha": "7b99193ad04f208acbc3da51f393b03674fd6c8f",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -58,19 +58,7 @@ void initialize_process_message()\n \n     static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n     g_setup = testing_setup.get();\n-\n-    // Temporary debug for https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=35027\n-    {\n-        LOCK(::cs_main);\n-        assert(CheckDiskSpace(gArgs.GetDataDirNet()));\n-        assert(CheckDiskSpace(gArgs.GetDataDirNet(), 48 * 2 * 2 * g_setup->m_node.chainman->ActiveChainstate().CoinsTip().GetCacheSize()));\n-    }\n     for (int i = 0; i < 2 * COINBASE_MATURITY; i++) {\n-        {\n-            LOCK(::cs_main);\n-            assert(CheckDiskSpace(gArgs.GetDataDirNet()));\n-            assert(CheckDiskSpace(gArgs.GetDataDirNet(), 48 * 2 * 2 * g_setup->m_node.chainman->ActiveChainstate().CoinsTip().GetCacheSize()));\n-        }\n         MineBlock(g_setup->m_node, CScript() << OP_TRUE);\n     }\n     SyncWithValidationInterfaceQueue();"
      },
      {
        "sha": "3b33115e72b040c61e890ec16485f06aeb33f55b",
        "filename": "src/test/fuzz/rolling_bloom_filter.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/rolling_bloom_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/rolling_bloom_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/rolling_bloom_filter.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -16,12 +16,16 @@\n \n FUZZ_TARGET(rolling_bloom_filter)\n {\n+    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n+    // inputs.\n+    int limit_max_ops{3000};\n+\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n \n     CRollingBloomFilter rolling_bloom_filter{\n         fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(1, 1000),\n         0.999 / fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(1, std::numeric_limits<unsigned int>::max())};\n-    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+    while (--limit_max_ops >= 0 && fuzzed_data_provider.remaining_bytes() > 0) {\n         CallOneOf(\n             fuzzed_data_provider,\n             [&] {\n@@ -32,13 +36,10 @@ FUZZ_TARGET(rolling_bloom_filter)\n                 assert(present);\n             },\n             [&] {\n-                const std::optional<uint256> u256 = ConsumeDeserializable<uint256>(fuzzed_data_provider);\n-                if (!u256) {\n-                    return;\n-                }\n-                (void)rolling_bloom_filter.contains(*u256);\n-                rolling_bloom_filter.insert(*u256);\n-                const bool present = rolling_bloom_filter.contains(*u256);\n+                const uint256 u256{ConsumeUInt256(fuzzed_data_provider)};\n+                (void)rolling_bloom_filter.contains(u256);\n+                rolling_bloom_filter.insert(u256);\n+                const bool present = rolling_bloom_filter.contains(u256);\n                 assert(present);\n             },\n             [&] {"
      },
      {
        "sha": "0c1b45b86cb83e40b0b19c9706df9170ef24c145",
        "filename": "src/test/fuzz/string.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/string.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/string.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/string.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -66,8 +66,7 @@ FUZZ_TARGET(string)\n         (void)ParseNonRFCJSONValue(random_string_1);\n     } catch (const std::runtime_error&) {\n     }\n-    OutputType output_type;\n-    (void)ParseOutputType(random_string_1, output_type);\n+    (void)ParseOutputType(random_string_1);\n     (void)RemovePrefix(random_string_1, random_string_2);\n     (void)ResolveErrMsg(random_string_1, random_string_2);\n     try {"
      },
      {
        "sha": "dadf772bc1f23cf8fe0a9a53476309729e65827a",
        "filename": "src/test/fuzz/tx_pool.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/tx_pool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/tx_pool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/tx_pool.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -112,6 +112,10 @@ void MockTime(FuzzedDataProvider& fuzzed_data_provider, const CChainState& chain\n \n FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n {\n+    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n+    // inputs.\n+    int limit_max_ops{300};\n+\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     const auto& node = g_setup->m_node;\n     auto& chainstate = node.chainman->ActiveChainstate();\n@@ -142,7 +146,7 @@ FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n         return c.out.nValue;\n     };\n \n-    while (fuzzed_data_provider.ConsumeBool()) {\n+    while (--limit_max_ops >= 0 && fuzzed_data_provider.ConsumeBool()) {\n         {\n             // Total supply is the mempool fee + all outpoints\n             CAmount supply_now{WITH_LOCK(tx_pool.cs, return tx_pool.GetTotalFee())};\n@@ -285,6 +289,10 @@ FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n \n FUZZ_TARGET_INIT(tx_pool, initialize_tx_pool)\n {\n+    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n+    // inputs.\n+    int limit_max_ops{300};\n+\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     const auto& node = g_setup->m_node;\n     auto& chainstate = node.chainman->ActiveChainstate();\n@@ -305,7 +313,7 @@ FUZZ_TARGET_INIT(tx_pool, initialize_tx_pool)\n     CTxMemPool tx_pool_{/* estimator */ nullptr, /* check_ratio */ 1};\n     MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n \n-    while (fuzzed_data_provider.ConsumeBool()) {\n+    while (--limit_max_ops >= 0 && fuzzed_data_provider.ConsumeBool()) {\n         const auto mut_tx = ConsumeTransaction(fuzzed_data_provider, txids);\n \n         if (fuzzed_data_provider.ConsumeBool()) {"
      },
      {
        "sha": "0d87f687d3a3f6f7f38eded08232d07ed6fb0ae6",
        "filename": "src/test/fuzz/util.cpp",
        "status": "modified",
        "additions": 155,
        "deletions": 0,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -343,3 +343,158 @@ CTxDestination ConsumeTxDestination(FuzzedDataProvider& fuzzed_data_provider) no\n     Assert(call_size == std::variant_size_v<CTxDestination>);\n     return tx_destination;\n }\n+\n+CTxMemPoolEntry ConsumeTxMemPoolEntry(FuzzedDataProvider& fuzzed_data_provider, const CTransaction& tx) noexcept\n+{\n+    // Avoid:\n+    // policy/feerate.cpp:28:34: runtime error: signed integer overflow: 34873208148477500 * 1000 cannot be represented in type 'long'\n+    //\n+    // Reproduce using CFeeRate(348732081484775, 10).GetFeePerK()\n+    const CAmount fee = std::min<CAmount>(ConsumeMoney(fuzzed_data_provider), std::numeric_limits<CAmount>::max() / static_cast<CAmount>(100000));\n+    assert(MoneyRange(fee));\n+    const int64_t time = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+    const unsigned int entry_height = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+    const bool spends_coinbase = fuzzed_data_provider.ConsumeBool();\n+    const unsigned int sig_op_cost = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, MAX_BLOCK_SIGOPS_COST);\n+    return CTxMemPoolEntry{MakeTransactionRef(tx), fee, time, entry_height, spends_coinbase, sig_op_cost, {}};\n+}\n+\n+bool ContainsSpentInput(const CTransaction& tx, const CCoinsViewCache& inputs) noexcept\n+{\n+    for (const CTxIn& tx_in : tx.vin) {\n+        const Coin& coin = inputs.AccessCoin(tx_in.prevout);\n+        if (coin.IsSpent()) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+CNetAddr ConsumeNetAddr(FuzzedDataProvider& fuzzed_data_provider) noexcept\n+{\n+    const Network network = fuzzed_data_provider.PickValueInArray({Network::NET_IPV4, Network::NET_IPV6, Network::NET_INTERNAL, Network::NET_ONION});\n+    CNetAddr net_addr;\n+    if (network == Network::NET_IPV4) {\n+        in_addr v4_addr = {};\n+        v4_addr.s_addr = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        net_addr = CNetAddr{v4_addr};\n+    } else if (network == Network::NET_IPV6) {\n+        if (fuzzed_data_provider.remaining_bytes() >= 16) {\n+            in6_addr v6_addr = {};\n+            memcpy(v6_addr.s6_addr, fuzzed_data_provider.ConsumeBytes<uint8_t>(16).data(), 16);\n+            net_addr = CNetAddr{v6_addr, fuzzed_data_provider.ConsumeIntegral<uint32_t>()};\n+        }\n+    } else if (network == Network::NET_INTERNAL) {\n+        net_addr.SetInternal(fuzzed_data_provider.ConsumeBytesAsString(32));\n+    } else if (network == Network::NET_ONION) {\n+        net_addr.SetSpecial(fuzzed_data_provider.ConsumeBytesAsString(32));\n+    }\n+    return net_addr;\n+}\n+\n+FILE* FuzzedFileProvider::open()\n+{\n+    SetFuzzedErrNo(m_fuzzed_data_provider);\n+    if (m_fuzzed_data_provider.ConsumeBool()) {\n+        return nullptr;\n+    }\n+    std::string mode;\n+    CallOneOf(\n+        m_fuzzed_data_provider,\n+        [&] {\n+            mode = \"r\";\n+        },\n+        [&] {\n+            mode = \"r+\";\n+        },\n+        [&] {\n+            mode = \"w\";\n+        },\n+        [&] {\n+            mode = \"w+\";\n+        },\n+        [&] {\n+            mode = \"a\";\n+        },\n+        [&] {\n+            mode = \"a+\";\n+        });\n+#if defined _GNU_SOURCE && !defined __ANDROID__\n+    const cookie_io_functions_t io_hooks = {\n+        FuzzedFileProvider::read,\n+        FuzzedFileProvider::write,\n+        FuzzedFileProvider::seek,\n+        FuzzedFileProvider::close,\n+    };\n+    return fopencookie(this, mode.c_str(), io_hooks);\n+#else\n+    (void)mode;\n+    return nullptr;\n+#endif\n+}\n+\n+ssize_t FuzzedFileProvider::read(void* cookie, char* buf, size_t size)\n+{\n+    FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+    SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n+    if (buf == nullptr || size == 0 || fuzzed_file->m_fuzzed_data_provider.ConsumeBool()) {\n+        return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n+    }\n+    const std::vector<uint8_t> random_bytes = fuzzed_file->m_fuzzed_data_provider.ConsumeBytes<uint8_t>(size);\n+    if (random_bytes.empty()) {\n+        return 0;\n+    }\n+    std::memcpy(buf, random_bytes.data(), random_bytes.size());\n+    if (AdditionOverflow(fuzzed_file->m_offset, (int64_t)random_bytes.size())) {\n+        return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n+    }\n+    fuzzed_file->m_offset += random_bytes.size();\n+    return random_bytes.size();\n+}\n+\n+ssize_t FuzzedFileProvider::write(void* cookie, const char* buf, size_t size)\n+{\n+    FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+    SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n+    const ssize_t n = fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<ssize_t>(0, size);\n+    if (AdditionOverflow(fuzzed_file->m_offset, (int64_t)n)) {\n+        return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n+    }\n+    fuzzed_file->m_offset += n;\n+    return n;\n+}\n+\n+int FuzzedFileProvider::seek(void* cookie, int64_t* offset, int whence)\n+{\n+    assert(whence == SEEK_SET || whence == SEEK_CUR || whence == SEEK_END);\n+    FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+    SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n+    int64_t new_offset = 0;\n+    if (whence == SEEK_SET) {\n+        new_offset = *offset;\n+    } else if (whence == SEEK_CUR) {\n+        if (AdditionOverflow(fuzzed_file->m_offset, *offset)) {\n+            return -1;\n+        }\n+        new_offset = fuzzed_file->m_offset + *offset;\n+    } else if (whence == SEEK_END) {\n+        const int64_t n = fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 4096);\n+        if (AdditionOverflow(n, *offset)) {\n+            return -1;\n+        }\n+        new_offset = n + *offset;\n+    }\n+    if (new_offset < 0) {\n+        return -1;\n+    }\n+    fuzzed_file->m_offset = new_offset;\n+    *offset = new_offset;\n+    return fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int>(-1, 0);\n+}\n+\n+int FuzzedFileProvider::close(void* cookie)\n+{\n+    FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n+    SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n+    return fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int>(-1, 0);\n+}"
      },
      {
        "sha": "bb017b3497fb55f1d1539c28e94d91525d3b7352",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 8,
        "deletions": 147,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -164,20 +164,7 @@ template <typename WeakEnumType, size_t size>\n     return UintToArith256(ConsumeUInt256(fuzzed_data_provider));\n }\n \n-[[nodiscard]] inline CTxMemPoolEntry ConsumeTxMemPoolEntry(FuzzedDataProvider& fuzzed_data_provider, const CTransaction& tx) noexcept\n-{\n-    // Avoid:\n-    // policy/feerate.cpp:28:34: runtime error: signed integer overflow: 34873208148477500 * 1000 cannot be represented in type 'long'\n-    //\n-    // Reproduce using CFeeRate(348732081484775, 10).GetFeePerK()\n-    const CAmount fee = std::min<CAmount>(ConsumeMoney(fuzzed_data_provider), std::numeric_limits<CAmount>::max() / static_cast<CAmount>(100000));\n-    assert(MoneyRange(fee));\n-    const int64_t time = fuzzed_data_provider.ConsumeIntegral<int64_t>();\n-    const unsigned int entry_height = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n-    const bool spends_coinbase = fuzzed_data_provider.ConsumeBool();\n-    const unsigned int sig_op_cost = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, MAX_BLOCK_SIGOPS_COST);\n-    return CTxMemPoolEntry{MakeTransactionRef(tx), fee, time, entry_height, spends_coinbase, sig_op_cost, {}};\n-}\n+[[nodiscard]] CTxMemPoolEntry ConsumeTxMemPoolEntry(FuzzedDataProvider& fuzzed_data_provider, const CTransaction& tx) noexcept;\n \n [[nodiscard]] CTxDestination ConsumeTxDestination(FuzzedDataProvider& fuzzed_data_provider) noexcept;\n \n@@ -215,16 +202,7 @@ template <class T>\n     return std::numeric_limits<T>::max() - i < j;\n }\n \n-[[nodiscard]] inline bool ContainsSpentInput(const CTransaction& tx, const CCoinsViewCache& inputs) noexcept\n-{\n-    for (const CTxIn& tx_in : tx.vin) {\n-        const Coin& coin = inputs.AccessCoin(tx_in.prevout);\n-        if (coin.IsSpent()) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n+[[nodiscard]] bool ContainsSpentInput(const CTransaction& tx, const CCoinsViewCache& inputs) noexcept;\n \n /**\n  * Sets errno to a value selected from the given std::array `errnos`.\n@@ -259,27 +237,7 @@ inline void SetFuzzedErrNo(FuzzedDataProvider& fuzzed_data_provider) noexcept\n     return result;\n }\n \n-inline CNetAddr ConsumeNetAddr(FuzzedDataProvider& fuzzed_data_provider) noexcept\n-{\n-    const Network network = fuzzed_data_provider.PickValueInArray({Network::NET_IPV4, Network::NET_IPV6, Network::NET_INTERNAL, Network::NET_ONION});\n-    CNetAddr net_addr;\n-    if (network == Network::NET_IPV4) {\n-        in_addr v4_addr = {};\n-        v4_addr.s_addr = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n-        net_addr = CNetAddr{v4_addr};\n-    } else if (network == Network::NET_IPV6) {\n-        if (fuzzed_data_provider.remaining_bytes() >= 16) {\n-            in6_addr v6_addr = {};\n-            memcpy(v6_addr.s6_addr, fuzzed_data_provider.ConsumeBytes<uint8_t>(16).data(), 16);\n-            net_addr = CNetAddr{v6_addr, fuzzed_data_provider.ConsumeIntegral<uint32_t>()};\n-        }\n-    } else if (network == Network::NET_INTERNAL) {\n-        net_addr.SetInternal(fuzzed_data_provider.ConsumeBytesAsString(32));\n-    } else if (network == Network::NET_ONION) {\n-        net_addr.SetSpecial(fuzzed_data_provider.ConsumeBytesAsString(32));\n-    }\n-    return net_addr;\n-}\n+CNetAddr ConsumeNetAddr(FuzzedDataProvider& fuzzed_data_provider) noexcept;\n \n inline CSubNet ConsumeSubNet(FuzzedDataProvider& fuzzed_data_provider) noexcept\n {\n@@ -329,112 +287,15 @@ class FuzzedFileProvider\n     {\n     }\n \n-    FILE* open()\n-    {\n-        SetFuzzedErrNo(m_fuzzed_data_provider);\n-        if (m_fuzzed_data_provider.ConsumeBool()) {\n-            return nullptr;\n-        }\n-        std::string mode;\n-        CallOneOf(\n-            m_fuzzed_data_provider,\n-            [&] {\n-                mode = \"r\";\n-            },\n-            [&] {\n-                mode = \"r+\";\n-            },\n-            [&] {\n-                mode = \"w\";\n-            },\n-            [&] {\n-                mode = \"w+\";\n-            },\n-            [&] {\n-                mode = \"a\";\n-            },\n-            [&] {\n-                mode = \"a+\";\n-            });\n-#if defined _GNU_SOURCE && !defined __ANDROID__\n-        const cookie_io_functions_t io_hooks = {\n-            FuzzedFileProvider::read,\n-            FuzzedFileProvider::write,\n-            FuzzedFileProvider::seek,\n-            FuzzedFileProvider::close,\n-        };\n-        return fopencookie(this, mode.c_str(), io_hooks);\n-#else\n-        (void)mode;\n-        return nullptr;\n-#endif\n-    }\n+    FILE* open();\n \n-    static ssize_t read(void* cookie, char* buf, size_t size)\n-    {\n-        FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n-        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n-        if (buf == nullptr || size == 0 || fuzzed_file->m_fuzzed_data_provider.ConsumeBool()) {\n-            return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n-        }\n-        const std::vector<uint8_t> random_bytes = fuzzed_file->m_fuzzed_data_provider.ConsumeBytes<uint8_t>(size);\n-        if (random_bytes.empty()) {\n-            return 0;\n-        }\n-        std::memcpy(buf, random_bytes.data(), random_bytes.size());\n-        if (AdditionOverflow(fuzzed_file->m_offset, (int64_t)random_bytes.size())) {\n-            return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n-        }\n-        fuzzed_file->m_offset += random_bytes.size();\n-        return random_bytes.size();\n-    }\n+    static ssize_t read(void* cookie, char* buf, size_t size);\n \n-    static ssize_t write(void* cookie, const char* buf, size_t size)\n-    {\n-        FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n-        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n-        const ssize_t n = fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<ssize_t>(0, size);\n-        if (AdditionOverflow(fuzzed_file->m_offset, (int64_t)n)) {\n-            return fuzzed_file->m_fuzzed_data_provider.ConsumeBool() ? 0 : -1;\n-        }\n-        fuzzed_file->m_offset += n;\n-        return n;\n-    }\n+    static ssize_t write(void* cookie, const char* buf, size_t size);\n \n-    static int seek(void* cookie, int64_t* offset, int whence)\n-    {\n-        assert(whence == SEEK_SET || whence == SEEK_CUR || whence == SEEK_END);\n-        FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n-        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n-        int64_t new_offset = 0;\n-        if (whence == SEEK_SET) {\n-            new_offset = *offset;\n-        } else if (whence == SEEK_CUR) {\n-            if (AdditionOverflow(fuzzed_file->m_offset, *offset)) {\n-                return -1;\n-            }\n-            new_offset = fuzzed_file->m_offset + *offset;\n-        } else if (whence == SEEK_END) {\n-            const int64_t n = fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, 4096);\n-            if (AdditionOverflow(n, *offset)) {\n-                return -1;\n-            }\n-            new_offset = n + *offset;\n-        }\n-        if (new_offset < 0) {\n-            return -1;\n-        }\n-        fuzzed_file->m_offset = new_offset;\n-        *offset = new_offset;\n-        return fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int>(-1, 0);\n-    }\n+    static int seek(void* cookie, int64_t* offset, int whence);\n \n-    static int close(void* cookie)\n-    {\n-        FuzzedFileProvider* fuzzed_file = (FuzzedFileProvider*)cookie;\n-        SetFuzzedErrNo(fuzzed_file->m_fuzzed_data_provider);\n-        return fuzzed_file->m_fuzzed_data_provider.ConsumeIntegralInRange<int>(-1, 0);\n-    }\n+    static int close(void* cookie);\n };\n \n [[nodiscard]] inline FuzzedFileProvider ConsumeFile(FuzzedDataProvider& fuzzed_data_provider) noexcept"
      },
      {
        "sha": "7f44dcf20ef2cf9178a145b20d33ee22b80a31d3",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 37,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2011-2020 The Bitcoin Core developers\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -16,6 +16,7 @@\n #include <util/system.h>\n #include <util/time.h>\n #include <validation.h>\n+#include <versionbits.h>\n \n #include <test/util/setup_common.h>\n \n@@ -51,36 +52,25 @@ BlockAssembler MinerTestingSetup::AssemblerForTest(const CChainParams& params)\n constexpr static struct {\n     unsigned char extranonce;\n     unsigned int nonce;\n-} blockinfo[] = {\n-    {4, 0xa4a3e223}, {2, 0x15c32f9e}, {1, 0x0375b547}, {1, 0x7004a8a5},\n-    {2, 0xce440296}, {2, 0x52cfe198}, {1, 0x77a72cd0}, {2, 0xbb5d6f84},\n-    {2, 0x83f30c2c}, {1, 0x48a73d5b}, {1, 0xef7dcd01}, {2, 0x6809c6c4},\n-    {2, 0x0883ab3c}, {1, 0x087bbbe2}, {2, 0x2104a814}, {2, 0xdffb6daa},\n-    {1, 0xee8a0a08}, {2, 0xba4237c1}, {1, 0xa70349dc}, {1, 0x344722bb},\n-    {3, 0xd6294733}, {2, 0xec9f5c94}, {2, 0xca2fbc28}, {1, 0x6ba4f406},\n-    {2, 0x015d4532}, {1, 0x6e119b7c}, {2, 0x43e8f314}, {2, 0x27962f38},\n-    {2, 0xb571b51b}, {2, 0xb36bee23}, {2, 0xd17924a8}, {2, 0x6bc212d9},\n-    {1, 0x630d4948}, {2, 0x9a4c4ebb}, {2, 0x554be537}, {1, 0xd63ddfc7},\n-    {2, 0xa10acc11}, {1, 0x759a8363}, {2, 0xfb73090d}, {1, 0xe82c6a34},\n-    {1, 0xe33e92d7}, {3, 0x658ef5cb}, {2, 0xba32ff22}, {5, 0x0227a10c},\n-    {1, 0xa9a70155}, {5, 0xd096d809}, {1, 0x37176174}, {1, 0x830b8d0f},\n-    {1, 0xc6e3910e}, {2, 0x823f3ca8}, {1, 0x99850849}, {1, 0x7521fb81},\n-    {1, 0xaacaabab}, {1, 0xd645a2eb}, {5, 0x7aea1781}, {5, 0x9d6e4b78},\n-    {1, 0x4ce90fd8}, {1, 0xabdc832d}, {6, 0x4a34f32a}, {2, 0xf2524c1c},\n-    {2, 0x1bbeb08a}, {1, 0xad47f480}, {1, 0x9f026aeb}, {1, 0x15a95049},\n-    {2, 0xd1cb95b2}, {2, 0xf84bbda5}, {1, 0x0fa62cd1}, {1, 0xe05f9169},\n-    {1, 0x78d194a9}, {5, 0x3e38147b}, {5, 0x737ba0d4}, {1, 0x63378e10},\n-    {1, 0x6d5f91cf}, {2, 0x88612eb8}, {2, 0xe9639484}, {1, 0xb7fabc9d},\n-    {2, 0x19b01592}, {1, 0x5a90dd31}, {2, 0x5bd7e028}, {2, 0x94d00323},\n-    {1, 0xa9b9c01a}, {1, 0x3a40de61}, {1, 0x56e7eec7}, {5, 0x859f7ef6},\n-    {1, 0xfd8e5630}, {1, 0x2b0c9f7f}, {1, 0xba700e26}, {1, 0x7170a408},\n-    {1, 0x70de86a8}, {1, 0x74d64cd5}, {1, 0x49e738a1}, {2, 0x6910b602},\n-    {0, 0x643c565f}, {1, 0x54264b3f}, {2, 0x97ea6396}, {2, 0x55174459},\n-    {2, 0x03e8779a}, {1, 0x98f34d8f}, {1, 0xc07b2b07}, {1, 0xdfe29668},\n-    {1, 0x3141c7c1}, {1, 0xb3b595f4}, {1, 0x735abf08}, {5, 0x623bfbce},\n-    {2, 0xd351e722}, {1, 0xf4ca48c9}, {1, 0x5b19c670}, {1, 0xa164bf0e},\n-    {2, 0xbbbeb305}, {2, 0xfe1c810a},\n-};\n+} BLOCKINFO[]{{8, 582909131},  {0, 971462344},  {2, 1169481553}, {6, 66147495},  {7, 427785981},  {8, 80538907},\n+              {8, 207348013},  {2, 1951240923}, {4, 215054351},  {1, 491520534}, {8, 1282281282}, {4, 639565734},\n+              {3, 248274685},  {8, 1160085976}, {6, 396349768},  {5, 393780549}, {5, 1096899528}, {4, 965381630},\n+              {0, 728758712},  {5, 318638310},  {3, 164591898},  {2, 274234550}, {2, 254411237},  {7, 561761812},\n+              {2, 268342573},  {0, 402816691},  {1, 221006382},  {6, 538872455}, {7, 393315655},  {4, 814555937},\n+              {7, 504879194},  {6, 467769648},  {3, 925972193},  {2, 200581872}, {3, 168915404},  {8, 430446262},\n+              {5, 773507406},  {3, 1195366164}, {0, 433361157},  {3, 297051771}, {0, 558856551},  {2, 501614039},\n+              {3, 528488272},  {2, 473587734},  {8, 230125274},  {2, 494084400}, {4, 357314010},  {8, 60361686},\n+              {7, 640624687},  {3, 480441695},  {8, 1424447925}, {4, 752745419}, {1, 288532283},  {6, 669170574},\n+              {5, 1900907591}, {3, 555326037},  {3, 1121014051}, {0, 545835650}, {8, 189196651},  {5, 252371575},\n+              {0, 199163095},  {6, 558895874},  {6, 1656839784}, {6, 815175452}, {6, 718677851},  {5, 544000334},\n+              {0, 340113484},  {6, 850744437},  {4, 496721063},  {8, 524715182}, {6, 574361898},  {6, 1642305743},\n+              {6, 355110149},  {5, 1647379658}, {8, 1103005356}, {7, 556460625}, {3, 1139533992}, {5, 304736030},\n+              {2, 361539446},  {2, 143720360},  {6, 201939025},  {7, 423141476}, {4, 574633709},  {3, 1412254823},\n+              {4, 873254135},  {0, 341817335},  {6, 53501687},   {3, 179755410}, {5, 172209688},  {8, 516810279},\n+              {4, 1228391489}, {8, 325372589},  {6, 550367589},  {0, 876291812}, {7, 412454120},  {7, 717202854},\n+              {2, 222677843},  {6, 251778867},  {7, 842004420},  {7, 194762829}, {4, 96668841},   {1, 925485796},\n+              {0, 792342903},  {6, 678455063},  {6, 773251385},  {5, 186617471}, {6, 883189502},  {7, 396077336},\n+              {8, 254702874},  {0, 455592851}};\n \n static CBlockIndex CreateBlockIndex(int nHeight, CBlockIndex* active_chain_tip) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n@@ -220,20 +210,18 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 110 blocks :)\n-    static_assert(std::size(blockinfo) == 110, \"Should have 110 blocks to import\");\n+    static_assert(std::size(BLOCKINFO) == 110, \"Should have 110 blocks to import\");\n     int baseheight = 0;\n     std::vector<CTransactionRef> txFirst;\n-    for (const auto& bi : blockinfo) {\n+    for (const auto& bi : BLOCKINFO) {\n         CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n         {\n             LOCK(cs_main);\n-            pblock->nVersion = 1;\n+            pblock->nVersion = VERSIONBITS_TOP_BITS;\n             pblock->nTime = m_node.chainman->ActiveChain().Tip()->GetMedianTimePast()+1;\n             CMutableTransaction txCoinbase(*pblock->vtx[0]);\n             txCoinbase.nVersion = 1;\n-            txCoinbase.vin[0].scriptSig = CScript();\n-            txCoinbase.vin[0].scriptSig.push_back(bi.extranonce);\n-            txCoinbase.vin[0].scriptSig.push_back(m_node.chainman->ActiveChain().Height());\n+            txCoinbase.vin[0].scriptSig = CScript{} << (m_node.chainman->ActiveChain().Height() + 1) << bi.extranonce;\n             txCoinbase.vout.resize(1); // Ignore the (optional) segwit commitment added by CreateNewBlock (as the hardcoded nonces don't account for this)\n             txCoinbase.vout[0].scriptPubKey = CScript();\n             pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));"
      },
      {
        "sha": "acbbf357d2d26fde3b85b0b30e3d442ff97f4d58",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -37,6 +37,7 @@ class CAddrManSerializationMock : public CAddrMan\n     //! Ensure that bucket placement is always the same for testing purposes.\n     void MakeDeterministic()\n     {\n+        LOCK(cs);\n         nKey.SetNull();\n         insecure_rand = FastRandomContext(true);\n     }"
      },
      {
        "sha": "56e2aa63b9ef37674095507c7bd93c1cddc9ff1c",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -123,7 +123,7 @@ static ScriptError_t ParseScriptError(const std::string& name)\n \n BOOST_FIXTURE_TEST_SUITE(script_tests, BasicTestingSetup)\n \n-void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, int flags, const std::string& message, int scriptError, CAmount nValue = 0)\n+void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, uint32_t flags, const std::string& message, int scriptError, CAmount nValue = 0)\n {\n     bool expect = (scriptError == SCRIPT_ERR_OK);\n     if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n@@ -139,8 +139,8 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n \n     // Verify that removing flags from a passing test or adding flags to a failing test does not change the result.\n     for (int i = 0; i < 16; ++i) {\n-        int extra_flags = InsecureRandBits(16);\n-        int combined_flags = expect ? (flags & ~extra_flags) : (flags | extra_flags);\n+        uint32_t extra_flags(InsecureRandBits(16));\n+        uint32_t combined_flags{expect ? (flags & ~extra_flags) : (flags | extra_flags)};\n         // Weed out some invalid flag combinations.\n         if (combined_flags & SCRIPT_VERIFY_CLEANSTACK && ~combined_flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) continue;\n         if (combined_flags & SCRIPT_VERIFY_WITNESS && ~combined_flags & SCRIPT_VERIFY_P2SH) continue;\n@@ -150,7 +150,7 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n-    int libconsensus_flags = flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL;\n+    uint32_t libconsensus_flags{flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL};\n     if (libconsensus_flags == flags) {\n         int expectedSuccessCode = expect ? 1 : 0;\n         if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n@@ -258,7 +258,7 @@ class TestBuilder\n     bool havePush;\n     std::vector<unsigned char> push;\n     std::string comment;\n-    int flags;\n+    uint32_t flags;\n     int scriptError;\n     CAmount nValue;\n \n@@ -278,7 +278,7 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WitnessMode::NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n+    TestBuilder(const CScript& script_, const std::string& comment_, uint32_t flags_, bool P2SH = false, WitnessMode wm = WitnessMode::NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n         if (wm == WitnessMode::PKH) {\n@@ -1677,7 +1677,7 @@ static void AssetTest(const UniValue& test)\n     const std::vector<CTxOut> prevouts = TxOutsFromJSON(test[\"prevouts\"]);\n     BOOST_CHECK(prevouts.size() == mtx.vin.size());\n     size_t idx = test[\"index\"].get_int64();\n-    unsigned int test_flags = ParseScriptFlags(test[\"flags\"].get_str());\n+    uint32_t test_flags{ParseScriptFlags(test[\"flags\"].get_str())};\n     bool fin = test.exists(\"final\") && test[\"final\"].get_bool();\n \n     if (test.exists(\"success\")) {"
      },
      {
        "sha": "db96fd49401617ef713106cd86442005c50ce99a",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -67,7 +67,7 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n  * Verifies script execution of the zeroth scriptPubKey of tx output and\n  * zeroth scriptSig and witness of tx input.\n  */\n-static ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n+static ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, uint32_t flags)\n {\n     ScriptError error;\n     CTransaction inputi(input);\n@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n     key.MakeNewKey(true);\n     CPubKey pubkey = key.GetPubKey();\n     // Default flags\n-    int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n+    const uint32_t flags{SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH};\n \n     // Multisig script (legacy counting)\n     {"
      },
      {
        "sha": "571f792a5358f845889a0c1969db35944a0c47d1",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -446,7 +446,7 @@ static void CreateCreditAndSpend(const FillableSigningProvider& keystore, const\n     assert(input.vin[0].scriptWitness.stack == inputm.vin[0].scriptWitness.stack);\n }\n \n-static void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, int flags, bool success)\n+static void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, uint32_t flags, bool success)\n {\n     ScriptError error;\n     CTransaction inputi(input);"
      },
      {
        "sha": "1924ea55b1e41883e61c0a92ecf0c49e4e881e33",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -112,10 +112,15 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t failing_flags, bool add_to_cache, CCoinsViewCache& active_coins_tip) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     PrecomputedTransactionData txdata;\n-    // If we add many more flags, this loop can get too expensive, but we can\n-    // rewrite in the future to randomly pick a set of flags to evaluate.\n-    for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\n+\n+    FastRandomContext insecure_rand(true);\n+\n+    for (int count = 0; count < 10000; ++count) {\n         TxValidationState state;\n+\n+        // Randomly selects flag combinations\n+        uint32_t test_flags = (uint32_t) insecure_rand.randrange((SCRIPT_VERIFY_END_MARKER - 1) << 1);\n+\n         // Filter out incompatible flag choices\n         if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\n             // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in"
      },
      {
        "sha": "2d044af184552574d0aa4f10031e0f9b31cb7619",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -141,12 +141,11 @@ ChainTestingSetup::ChainTestingSetup(const std::string& chainName, const std::ve\n     m_node.scheduler->m_service_thread = std::thread(util::TraceThread, \"scheduler\", [&] { m_node.scheduler->serviceQueue(); });\n     GetMainSignals().RegisterBackgroundSignalScheduler(*m_node.scheduler);\n \n-    pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-\n     m_node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();\n     m_node.mempool = std::make_unique<CTxMemPool>(m_node.fee_estimator.get(), 1);\n \n     m_node.chainman = std::make_unique<ChainstateManager>();\n+    m_node.chainman->m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(1 << 20, true);\n \n     // Start script-checking threads. Set g_parallel_script_checks to true so they are used.\n     constexpr int script_check_threads = 2;\n@@ -169,7 +168,6 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.scheduler.reset();\n     m_node.chainman->Reset();\n     m_node.chainman.reset();\n-    pblocktree.reset();\n }\n \n TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const char*>& extra_args)\n@@ -199,7 +197,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,\n-                                       m_node.banman.get(), *m_node.scheduler, *m_node.chainman,\n+                                       m_node.banman.get(), *m_node.chainman,\n                                        *m_node.mempool, false);\n     {\n         CConnman::Options options;"
      },
      {
        "sha": "8f4ff6815bdd63e33e36fac1d5cff99bf9ffb2a1",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -77,22 +77,29 @@ std::shared_ptr<CBlock> MinerTestingSetup::Block(const uint256& prev_hash)\n     txCoinbase.vout[1].nValue = txCoinbase.vout[0].nValue;\n     txCoinbase.vout[0].nValue = 0;\n     txCoinbase.vin[0].scriptWitness.SetNull();\n+    // Always pad with OP_0 at the end to avoid bad-cb-length error\n+    txCoinbase.vin[0].scriptSig = CScript{} << WITH_LOCK(::cs_main, return m_node.chainman->m_blockman.LookupBlockIndex(prev_hash)->nHeight + 1) << OP_0;\n     pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n \n     return pblock;\n }\n \n std::shared_ptr<CBlock> MinerTestingSetup::FinalizeBlock(std::shared_ptr<CBlock> pblock)\n {\n-    LOCK(cs_main); // For m_node.chainman->m_blockman.LookupBlockIndex\n-    GenerateCoinbaseCommitment(*pblock, m_node.chainman->m_blockman.LookupBlockIndex(pblock->hashPrevBlock), Params().GetConsensus());\n+    const CBlockIndex* prev_block{WITH_LOCK(::cs_main, return m_node.chainman->m_blockman.LookupBlockIndex(pblock->hashPrevBlock))};\n+    GenerateCoinbaseCommitment(*pblock, prev_block, Params().GetConsensus());\n \n     pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n \n     while (!CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n         ++(pblock->nNonce);\n     }\n \n+    // submit block header, so that miner can get the block height from the\n+    // global state and the node has the topology of the chain\n+    BlockValidationState ignored;\n+    BOOST_CHECK(Assert(m_node.chainman)->ProcessNewBlockHeaders({pblock->GetBlockHeader()}, ignored, Params()));\n+\n     return pblock;\n }\n \n@@ -147,13 +154,6 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     }\n \n     bool ignored;\n-    BlockValidationState state;\n-    std::vector<CBlockHeader> headers;\n-    std::transform(blocks.begin(), blocks.end(), std::back_inserter(headers), [](std::shared_ptr<const CBlock> b) { return b->GetBlockHeader(); });\n-\n-    // Process all the headers so we understand the toplogy of the chain\n-    BOOST_CHECK(Assert(m_node.chainman)->ProcessNewBlockHeaders(headers, state, Params()));\n-\n     // Connect the genesis block and drain any outstanding events\n     BOOST_CHECK(Assert(m_node.chainman)->ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored));\n     SyncWithValidationInterfaceQueue();"
      },
      {
        "sha": "315ef225992980a08b335a39c18f981523ac47a4",
        "filename": "src/test/validation_chainstate_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/test/validation_chainstate_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/test/validation_chainstate_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstate_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -20,6 +20,7 @@ BOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n {\n     ChainstateManager manager;\n+    WITH_LOCK(::cs_main, manager.m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(1 << 20, true));\n     CTxMemPool mempool;\n \n     //! Create and add a Coin with DynamicMemoryUsage of 80 bytes to the given view."
      },
      {
        "sha": "bedaa14007f1074e81c96d898ada5bdd87a1b71d",
        "filename": "src/tinyformat.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -797,27 +797,27 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& positionalMode\n             break;\n         case 'X':\n             out.setf(std::ios::uppercase);\n-            // Falls through\n+            [[fallthrough]];\n         case 'x': case 'p':\n             out.setf(std::ios::hex, std::ios::basefield);\n             intConversion = true;\n             break;\n         case 'E':\n             out.setf(std::ios::uppercase);\n-            // Falls through\n+            [[fallthrough]];\n         case 'e':\n             out.setf(std::ios::scientific, std::ios::floatfield);\n             out.setf(std::ios::dec, std::ios::basefield);\n             break;\n         case 'F':\n             out.setf(std::ios::uppercase);\n-            // Falls through\n+            [[fallthrough]];\n         case 'f':\n             out.setf(std::ios::fixed, std::ios::floatfield);\n             break;\n         case 'A':\n             out.setf(std::ios::uppercase);\n-            // Falls through\n+            [[fallthrough]];\n         case 'a':\n #           ifdef _MSC_VER\n             // Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html\n@@ -829,7 +829,7 @@ inline const char* streamStateFromFormat(std::ostream& out, bool& positionalMode\n             break;\n         case 'G':\n             out.setf(std::ios::uppercase);\n-            // Falls through\n+            [[fallthrough]];\n         case 'g':\n             out.setf(std::ios::dec, std::ios::basefield);\n             // As in boost::format, let stream decide float format."
      },
      {
        "sha": "bb296456bafc6fcd01545c2c33bf82381d357dc6",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 8,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -132,28 +132,35 @@ void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ct\n \n bool TorControlConnection::Connect(const std::string& tor_control_center, const ConnectionCB& _connected, const ConnectionCB& _disconnected)\n {\n-    if (b_conn)\n+    if (b_conn) {\n         Disconnect();\n-    // Parse tor_control_center address:port\n-    struct sockaddr_storage connect_to_addr;\n-    int connect_to_addrlen = sizeof(connect_to_addr);\n-    if (evutil_parse_sockaddr_port(tor_control_center.c_str(),\n-        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+    }\n+\n+    CService control_service;\n+    if (!Lookup(tor_control_center, control_service, 9051, fNameLookup)) {\n+        LogPrintf(\"tor: Failed to look up control center %s\\n\", tor_control_center);\n+        return false;\n+    }\n+\n+    struct sockaddr_storage control_address;\n+    socklen_t control_address_len = sizeof(control_address);\n+    if (!control_service.GetSockAddr(reinterpret_cast<struct sockaddr*>(&control_address), &control_address_len)) {\n         LogPrintf(\"tor: Error parsing socket address %s\\n\", tor_control_center);\n         return false;\n     }\n \n     // Create a new socket, set up callbacks and enable notification bits\n     b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n-    if (!b_conn)\n+    if (!b_conn) {\n         return false;\n+    }\n     bufferevent_setcb(b_conn, TorControlConnection::readcb, nullptr, TorControlConnection::eventcb, this);\n     bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n     this->connected = _connected;\n     this->disconnected = _disconnected;\n \n     // Finally, connect to tor_control_center\n-    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+    if (bufferevent_socket_connect(b_conn, reinterpret_cast<struct sockaddr*>(&control_address), control_address_len) < 0) {\n         LogPrintf(\"tor: Error connecting to address %s\\n\", tor_control_center);\n         return false;\n     }"
      },
      {
        "sha": "24c8318f369e2c46821eab159c1c620715615e47",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -47,6 +47,13 @@ class TxOrphanage {\n      * (ie orphans that may have found their final missing parent, and so should be reconsidered for the mempool) */\n     void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) const EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n+    /** Return how many entries exist in the orphange */\n+    size_t Size() LOCKS_EXCLUDED(::g_cs_orphans)\n+    {\n+        LOCK(::g_cs_orphans);\n+        return m_orphans.size();\n+    }\n+\n protected:\n     struct OrphanTx {\n         CTransactionRef tx;"
      },
      {
        "sha": "3e63e093daa197f2db3fbfee45f60861c207f371",
        "filename": "src/util/epochguard.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/util/epochguard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/util/epochguard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/epochguard.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -40,6 +40,9 @@ class LOCKABLE Epoch\n     Epoch() = default;\n     Epoch(const Epoch&) = delete;\n     Epoch& operator=(const Epoch&) = delete;\n+    Epoch(Epoch&&) = delete;\n+    Epoch& operator=(Epoch&&) = delete;\n+    ~Epoch() = default;\n \n     bool guarded() const { return m_guarded; }\n \n@@ -51,6 +54,13 @@ class LOCKABLE Epoch\n         // only allow modification via Epoch member functions\n         friend class Epoch;\n         Marker& operator=(const Marker&) = delete;\n+\n+    public:\n+        Marker() = default;\n+        Marker(const Marker&) = default;\n+        Marker(Marker&&) = delete;\n+        Marker& operator=(Marker&&) = delete;\n+        ~Marker() = default;\n     };\n \n     class SCOPED_LOCKABLE Guard"
      },
      {
        "sha": "1b3d00bc6d35a19b1fa20b1b2528311a341b14ec",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 70,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -19,7 +19,6 @@\n #include <flatfile.h>\n #include <hash.h>\n #include <index/blockfilterindex.h>\n-#include <index/txindex.h>\n #include <logging.h>\n #include <logging/timer.h>\n #include <node/blockstorage.h>\n@@ -48,6 +47,7 @@\n #include <util/rbf.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n+#include <util/trace.h>\n #include <util/translation.h>\n #include <validationinterface.h>\n #include <warnings.h>\n@@ -170,8 +170,6 @@ CBlockIndex* BlockManager::FindForkInGlobalIndex(const CChain& chain, const CBlo\n     return chain.Genesis();\n }\n \n-std::unique_ptr<CBlockTreeDB> pblocktree;\n-\n bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,\n                        const CCoinsViewCache& inputs, unsigned int flags, bool cacheSigStore,\n                        bool cacheFullScriptStore, PrecomputedTransactionData& txdata,\n@@ -1156,33 +1154,6 @@ PackageMempoolAcceptResult ProcessNewPackage(CChainState& active_chainstate, CTx\n     return result;\n }\n \n-CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock)\n-{\n-    LOCK(cs_main);\n-\n-    if (block_index) {\n-        CBlock block;\n-        if (ReadBlockFromDisk(block, block_index, consensusParams)) {\n-            for (const auto& tx : block.vtx) {\n-                if (tx->GetHash() == hash) {\n-                    hashBlock = block_index->GetBlockHash();\n-                    return tx;\n-                }\n-            }\n-        }\n-        return nullptr;\n-    }\n-    if (mempool) {\n-        CTransactionRef ptx = mempool->get(hash);\n-        if (ptx) return ptx;\n-    }\n-    if (g_txindex) {\n-        CTransactionRef tx;\n-        if (g_txindex->FindTx(hash, hashBlock, tx)) return tx;\n-    }\n-    return nullptr;\n-}\n-\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n {\n     int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;\n@@ -1647,13 +1618,8 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n         pindex->phashBlock == nullptr || // this is a new candidate block, eg from TestBlockValidity()\n         *pindex->phashBlock != consensusparams.BIP16Exception) // this block isn't the historical exception\n     {\n-        flags |= SCRIPT_VERIFY_P2SH;\n-    }\n-\n-    // Enforce WITNESS rules whenever P2SH is in effect (and the segwit\n-    // deployment is defined).\n-    if (flags & SCRIPT_VERIFY_P2SH && DeploymentEnabled(consensusparams, Consensus::DEPLOYMENT_SEGWIT)) {\n-        flags |= SCRIPT_VERIFY_WITNESS;\n+        // Enforce WITNESS rules whenever P2SH is in effect\n+        flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\n     }\n \n     // Enforce the DERSIG (BIP66) rule\n@@ -1999,6 +1965,16 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     int64_t nTime6 = GetTimeMicros(); nTimeCallbacks += nTime6 - nTime5;\n     LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs (%.2fms/blk)]\\n\", MILLI * (nTime6 - nTime5), nTimeCallbacks * MICRO, nTimeCallbacks * MILLI / nBlocksTotal);\n \n+    TRACE7(validation, block_connected,\n+        block.GetHash().ToString().c_str(),\n+        pindex->nHeight,\n+        block.vtx.size(),\n+        nInputs,\n+        nSigOpsCost,\n+        GetTimeMicros() - nTimeStart, // in microseconds (\u00b5s)\n+        block.GetHash().data()\n+    );\n+\n     return true;\n }\n \n@@ -2075,7 +2051,7 @@ bool CChainState::FlushStateToDisk(\n             if (!setFilesToPrune.empty()) {\n                 fFlushForPrune = true;\n                 if (!fHavePruned) {\n-                    pblocktree->WriteFlag(\"prunedblockfiles\", true);\n+                    m_blockman.m_block_tree_db->WriteFlag(\"prunedblockfiles\", true);\n                     fHavePruned = true;\n                 }\n             }\n@@ -2127,7 +2103,7 @@ bool CChainState::FlushStateToDisk(\n                     vBlocks.push_back(*it);\n                     setDirtyBlockIndex.erase(it++);\n                 }\n-                if (!pblocktree->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {\n+                if (!m_blockman.m_block_tree_db->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {\n                     return AbortNode(state, \"Failed to write to block index database\");\n                 }\n             }\n@@ -3103,25 +3079,23 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     std::vector<unsigned char> commitment;\n     int commitpos = GetWitnessCommitmentIndex(block);\n     std::vector<unsigned char> ret(32, 0x00);\n-    if (DeploymentEnabled(consensusParams, Consensus::DEPLOYMENT_SEGWIT)) {\n-        if (commitpos == NO_WITNESS_COMMITMENT) {\n-            uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);\n-            CHash256().Write(witnessroot).Write(ret).Finalize(witnessroot);\n-            CTxOut out;\n-            out.nValue = 0;\n-            out.scriptPubKey.resize(MINIMUM_WITNESS_COMMITMENT);\n-            out.scriptPubKey[0] = OP_RETURN;\n-            out.scriptPubKey[1] = 0x24;\n-            out.scriptPubKey[2] = 0xaa;\n-            out.scriptPubKey[3] = 0x21;\n-            out.scriptPubKey[4] = 0xa9;\n-            out.scriptPubKey[5] = 0xed;\n-            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);\n-            commitment = std::vector<unsigned char>(out.scriptPubKey.begin(), out.scriptPubKey.end());\n-            CMutableTransaction tx(*block.vtx[0]);\n-            tx.vout.push_back(out);\n-            block.vtx[0] = MakeTransactionRef(std::move(tx));\n-        }\n+    if (commitpos == NO_WITNESS_COMMITMENT) {\n+        uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);\n+        CHash256().Write(witnessroot).Write(ret).Finalize(witnessroot);\n+        CTxOut out;\n+        out.nValue = 0;\n+        out.scriptPubKey.resize(MINIMUM_WITNESS_COMMITMENT);\n+        out.scriptPubKey[0] = OP_RETURN;\n+        out.scriptPubKey[1] = 0x24;\n+        out.scriptPubKey[2] = 0xaa;\n+        out.scriptPubKey[3] = 0x21;\n+        out.scriptPubKey[4] = 0xa9;\n+        out.scriptPubKey[5] = 0xed;\n+        memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);\n+        commitment = std::vector<unsigned char>(out.scriptPubKey.begin(), out.scriptPubKey.end());\n+        CMutableTransaction tx(*block.vtx[0]);\n+        tx.vout.push_back(out);\n+        block.vtx[0] = MakeTransactionRef(std::move(tx));\n     }\n     UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);\n     return commitment;\n@@ -3700,11 +3674,11 @@ CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n \n bool BlockManager::LoadBlockIndex(\n     const Consensus::Params& consensus_params,\n-    CBlockTreeDB& blocktree,\n     std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n {\n-    if (!blocktree.LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); }))\n+    if (!m_block_tree_db->LoadBlockIndexGuts(consensus_params, [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); })) {\n         return false;\n+    }\n \n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n@@ -3764,25 +3738,25 @@ void BlockManager::Unload() {\n     m_block_index.clear();\n }\n \n-bool CChainState::LoadBlockIndexDB()\n+bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)\n {\n-    if (!m_blockman.LoadBlockIndex(\n-            m_params.GetConsensus(), *pblocktree,\n+    if (!LoadBlockIndex(\n+            ::Params().GetConsensus(),\n             setBlockIndexCandidates)) {\n         return false;\n     }\n \n     // Load block file info\n-    pblocktree->ReadLastBlockFile(nLastBlockFile);\n+    m_block_tree_db->ReadLastBlockFile(nLastBlockFile);\n     vinfoBlockFile.resize(nLastBlockFile + 1);\n     LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile);\n     for (int nFile = 0; nFile <= nLastBlockFile; nFile++) {\n-        pblocktree->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);\n+        m_block_tree_db->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);\n     }\n     LogPrintf(\"%s: last block file info: %s\\n\", __func__, vinfoBlockFile[nLastBlockFile].ToString());\n     for (int nFile = nLastBlockFile + 1; true; nFile++) {\n         CBlockFileInfo info;\n-        if (pblocktree->ReadBlockFileInfo(nFile, info)) {\n+        if (m_block_tree_db->ReadBlockFileInfo(nFile, info)) {\n             vinfoBlockFile.push_back(info);\n         } else {\n             break;\n@@ -3792,7 +3766,7 @@ bool CChainState::LoadBlockIndexDB()\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    for (const std::pair<const uint256, CBlockIndex*>& item : m_blockman.m_block_index) {\n+    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {\n         CBlockIndex* pindex = item.second;\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n             setBlkDataFiles.insert(pindex->nFile);\n@@ -3807,13 +3781,13 @@ bool CChainState::LoadBlockIndexDB()\n     }\n \n     // Check whether we have ever pruned block & undo files\n-    pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned);\n+    m_block_tree_db->ReadFlag(\"prunedblockfiles\", fHavePruned);\n     if (fHavePruned)\n         LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n \n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n-    pblocktree->ReadReindexing(fReindexing);\n+    m_block_tree_db->ReadReindexing(fReindexing);\n     if(fReindexing) fReindex = true;\n \n     return true;\n@@ -4114,7 +4088,7 @@ bool ChainstateManager::LoadBlockIndex()\n     // Load block index from databases\n     bool needs_init = fReindex;\n     if (!fReindex) {\n-        bool ret = ActiveChainstate().LoadBlockIndexDB();\n+        bool ret = m_blockman.LoadBlockIndexDB(ActiveChainstate().setBlockIndexCandidates);\n         if (!ret) return false;\n         needs_init = m_blockman.m_block_index.empty();\n     }"
      },
      {
        "sha": "9d8d7c06a9eda1407f2487e55a0c309fac1a5a88",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 19,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -140,19 +140,7 @@ void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);\n void StartScriptCheckWorkerThreads(int threads_num);\n /** Stop all of the script checking worker threads */\n void StopScriptCheckWorkerThreads();\n-/**\n- * Return transaction from the block at block_index.\n- * If block_index is not provided, fall back to mempool.\n- * If mempool is not provided or the tx couldn't be found in mempool, fall back to g_txindex.\n- *\n- * @param[in]  block_index     The block to read from disk, or nullptr\n- * @param[in]  mempool         If block_index is not provided, look in the mempool, if provided\n- * @param[in]  hash            The txid\n- * @param[in]  consensusParams The params\n- * @param[out] hashBlock       The hash of block_index, if the tx was found via block_index\n- * @returns                    The tx if found, otherwise nullptr\n- */\n-CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock);\n+\n CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n \n bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage = bilingual_str{});\n@@ -446,6 +434,10 @@ class BlockManager\n      */\n     std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n \n+    std::unique_ptr<CBlockTreeDB> m_block_tree_db GUARDED_BY(::cs_main);\n+\n+    bool LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n     /**\n      * Load the blocktree off disk and into memory. Populate certain metadata\n      * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral\n@@ -456,7 +448,6 @@ class BlockManager\n      */\n     bool LoadBlockIndex(\n         const Consensus::Params& consensus_params,\n-        CBlockTreeDB& blocktree,\n         std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)\n         EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -798,8 +789,6 @@ class CChainState\n     void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    bool LoadBlockIndexDB() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     //! Indirection necessary to make lock annotations work with an optional mempool.\n     RecursiveMutex* MempoolMutex() const LOCK_RETURNED(m_mempool->cs)\n     {\n@@ -1047,9 +1036,6 @@ class ChainstateManager\n     }\n };\n \n-/** Global variable that points to the active block tree (protected by cs_main) */\n-extern std::unique_ptr<CBlockTreeDB> pblocktree;\n-\n using FopenFn = std::function<FILE*(const fs::path&, const char*)>;\n \n /** Dump the mempool to disk. */"
      },
      {
        "sha": "ac60504419bb63363d834c09a1c0e720d47ed5bc",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -740,7 +740,7 @@ RPCHelpMan dumpwallet()\n     // the user could have gotten from another RPC command prior to now\n     wallet.BlockUntilSyncedToCurrentChain();\n \n-    LOCK2(wallet.cs_wallet, spk_man.cs_KeyStore);\n+    LOCK(wallet.cs_wallet);\n \n     EnsureWalletIsUnlocked(wallet);\n \n@@ -762,9 +762,16 @@ RPCHelpMan dumpwallet()\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n \n     std::map<CKeyID, int64_t> mapKeyBirth;\n-    const std::map<CKeyID, int64_t>& mapKeyPool = spk_man.GetAllReserveKeys();\n     wallet.GetKeyBirthTimes(mapKeyBirth);\n \n+    int64_t block_time = 0;\n+    CHECK_NONFATAL(wallet.chain().findBlock(wallet.GetLastBlockHash(), FoundBlock().time(block_time)));\n+\n+    // Note: To avoid a lock order issue, access to cs_main must be locked before cs_KeyStore.\n+    // So we do the two things in this function that lock cs_main first: GetKeyBirthTimes, and findBlock.\n+    LOCK(spk_man.cs_KeyStore);\n+\n+    const std::map<CKeyID, int64_t>& mapKeyPool = spk_man.GetAllReserveKeys();\n     std::set<CScriptID> scripts = spk_man.GetCScripts();\n \n     // sort time/key pairs\n@@ -779,8 +786,6 @@ RPCHelpMan dumpwallet()\n     file << strprintf(\"# Wallet dump created by Bitcoin %s\\n\", CLIENT_BUILD);\n     file << strprintf(\"# * Created on %s\\n\", FormatISO8601DateTime(GetTime()));\n     file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", wallet.GetLastBlockHeight(), wallet.GetLastBlockHash().ToString());\n-    int64_t block_time = 0;\n-    CHECK_NONFATAL(wallet.chain().findBlock(wallet.GetLastBlockHash(), FoundBlock().time(block_time)));\n     file << strprintf(\"#   mined on %s\\n\", FormatISO8601DateTime(block_time));\n     file << \"\\n\";\n "
      },
      {
        "sha": "43b67076cd0652dc3621e7158f61a6044e71e1ff",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 12,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -266,12 +266,13 @@ static RPCHelpMan getnewaddress()\n \n     OutputType output_type = pwallet->m_default_address_type;\n     if (!request.params[1].isNull()) {\n-        if (!ParseOutputType(request.params[1].get_str(), output_type)) {\n+        std::optional<OutputType> parsed = ParseOutputType(request.params[1].get_str());\n+        if (!parsed) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[1].get_str()));\n-        }\n-        if (output_type == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n+        } else if (parsed.value() == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Legacy wallets cannot provide bech32m addresses\");\n         }\n+        output_type = parsed.value();\n     }\n \n     CTxDestination dest;\n@@ -313,12 +314,13 @@ static RPCHelpMan getrawchangeaddress()\n \n     OutputType output_type = pwallet->m_default_change_type.value_or(pwallet->m_default_address_type);\n     if (!request.params[0].isNull()) {\n-        if (!ParseOutputType(request.params[0].get_str(), output_type)) {\n+        std::optional<OutputType> parsed = ParseOutputType(request.params[0].get_str());\n+        if (!parsed) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[0].get_str()));\n-        }\n-        if (output_type == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n+        } else if (parsed.value() == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Legacy wallets cannot provide bech32m addresses\");\n         }\n+        output_type = parsed.value();\n     }\n \n     CTxDestination dest;\n@@ -1007,12 +1009,13 @@ static RPCHelpMan addmultisigaddress()\n \n     OutputType output_type = pwallet->m_default_address_type;\n     if (!request.params[3].isNull()) {\n-        if (!ParseOutputType(request.params[3].get_str(), output_type)) {\n+        std::optional<OutputType> parsed = ParseOutputType(request.params[3].get_str());\n+        if (!parsed) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[3].get_str()));\n-        }\n-        if (output_type == OutputType::BECH32M) {\n+        } else if (parsed.value() == OutputType::BECH32M) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Bech32m multisig addresses cannot be created with legacy wallets\");\n         }\n+        output_type = parsed.value();\n     }\n \n     // Construct using pay-to-script-hash:\n@@ -3133,11 +3136,11 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n             if (options.exists(\"changeAddress\") || options.exists(\"change_address\")) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot specify both change address and address type options\");\n             }\n-            OutputType out_type;\n-            if (!ParseOutputType(options[\"change_type\"].get_str(), out_type)) {\n+            if (std::optional<OutputType> parsed = ParseOutputType(options[\"change_type\"].get_str())) {\n+                coinControl.m_change_type.emplace(parsed.value());\n+            } else {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown change type '%s'\", options[\"change_type\"].get_str()));\n             }\n-            coinControl.m_change_type.emplace(out_type);\n         }\n \n         const UniValue include_watching_option = options.exists(\"include_watching\") ? options[\"include_watching\"] : options[\"includeWatching\"];"
      },
      {
        "sha": "e329e0cf8fdb697dbe88c69d34fc753a71061cff",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -207,7 +207,7 @@ class ScriptPubKeyMan\n     virtual bool CanGetAddresses(bool internal = false) const { return false; }\n \n     /** Upgrades the wallet to the specified version */\n-    virtual bool Upgrade(int prev_version, int new_version, bilingual_str& error) { return false; }\n+    virtual bool Upgrade(int prev_version, int new_version, bilingual_str& error) { return true; }\n \n     virtual bool HavePrivateKeys() const { return false; }\n "
      },
      {
        "sha": "8821f680b33548c043141532c200ae93531f52e4",
        "filename": "src/wallet/test/spend_tests.cpp",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/spend_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/spend_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/spend_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,61 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <validation.h>\n+#include <wallet/coincontrol.h>\n+#include <wallet/test/util.h>\n+#include <wallet/test/wallet_test_fixture.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(spend_tests, WalletTestingSetup)\n+\n+BOOST_FIXTURE_TEST_CASE(SubtractFee, TestChain100Setup)\n+{\n+    CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n+    auto wallet = CreateSyncedWallet(*m_node.chain, m_node.chainman->ActiveChain(), coinbaseKey);\n+\n+    // Check that a subtract-from-recipient transaction slightly less than the\n+    // coinbase input amount does not create a change output (because it would\n+    // be uneconomical to add and spend the output), and make sure it pays the\n+    // leftover input amount which would have been change to the recipient\n+    // instead of the miner.\n+    auto check_tx = [&wallet](CAmount leftover_input_amount) {\n+        CRecipient recipient{GetScriptForRawPubKey({}), 50 * COIN - leftover_input_amount, true /* subtract fee */};\n+        CTransactionRef tx;\n+        CAmount fee;\n+        int change_pos = -1;\n+        bilingual_str error;\n+        CCoinControl coin_control;\n+        coin_control.m_feerate.emplace(10000);\n+        coin_control.fOverrideFeeRate = true;\n+        FeeCalculation fee_calc;\n+        BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, change_pos, error, coin_control, fee_calc));\n+        BOOST_CHECK_EQUAL(tx->vout.size(), 1);\n+        BOOST_CHECK_EQUAL(tx->vout[0].nValue, recipient.nAmount + leftover_input_amount - fee);\n+        BOOST_CHECK_GT(fee, 0);\n+        return fee;\n+    };\n+\n+    // Send full input amount to recipient, check that only nonzero fee is\n+    // subtracted (to_reduce == fee).\n+    const CAmount fee{check_tx(0)};\n+\n+    // Send slightly less than full input amount to recipient, check leftover\n+    // input amount is paid to recipient not the miner (to_reduce == fee - 123)\n+    BOOST_CHECK_EQUAL(fee, check_tx(123));\n+\n+    // Send full input minus fee amount to recipient, check leftover input\n+    // amount is paid to recipient not the miner (to_reduce == 0)\n+    BOOST_CHECK_EQUAL(fee, check_tx(fee));\n+\n+    // Send full input minus more than the fee amount to recipient, check\n+    // leftover input amount is paid to recipient not the miner (to_reduce ==\n+    // -123). This overpays the recipient instead of overpaying the miner more\n+    // than double the necessary fee.\n+    BOOST_CHECK_EQUAL(fee, check_tx(fee + 123));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c3061b93c061ce6a97382cb1e89f533a8291ec34",
        "filename": "src/wallet/test/util.cpp",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/util.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,38 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/test/util.h>\n+\n+#include <chain.h>\n+#include <key.h>\n+#include <test/util/setup_common.h>\n+#include <wallet/wallet.h>\n+#include <wallet/walletdb.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <memory>\n+\n+std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cchain, const CKey& key)\n+{\n+    auto wallet = std::make_unique<CWallet>(&chain, \"\", CreateMockWalletDatabase());\n+    {\n+        LOCK2(wallet->cs_wallet, ::cs_main);\n+        wallet->SetLastBlockProcessed(cchain.Height(), cchain.Tip()->GetBlockHash());\n+    }\n+    wallet->LoadWallet();\n+    {\n+        auto spk_man = wallet->GetOrCreateLegacyScriptPubKeyMan();\n+        LOCK2(wallet->cs_wallet, spk_man->cs_KeyStore);\n+        spk_man->AddKeyPubKey(key, key.GetPubKey());\n+    }\n+    WalletRescanReserver reserver(*wallet);\n+    reserver.reserve();\n+    CWallet::ScanResult result = wallet->ScanForWalletTransactions(cchain.Genesis()->GetBlockHash(), 0 /* start_height */, {} /* max_height */, reserver, false /* update */);\n+    BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n+    BOOST_CHECK_EQUAL(result.last_scanned_block, cchain.Tip()->GetBlockHash());\n+    BOOST_CHECK_EQUAL(*result.last_scanned_height, cchain.Height());\n+    BOOST_CHECK(result.last_failed_block.IsNull());\n+    return wallet;\n+}"
      },
      {
        "sha": "288c111571c4df1891e3df895eae0162e2bc3694",
        "filename": "src/wallet/test/util.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/util.h?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_TEST_UTIL_H\n+#define BITCOIN_WALLET_TEST_UTIL_H\n+\n+#include <memory>\n+\n+class CChain;\n+class CKey;\n+class CWallet;\n+namespace interfaces {\n+class Chain;\n+} // namespace interfaces\n+\n+std::unique_ptr<CWallet> CreateSyncedWallet(interfaces::Chain& chain, CChain& cchain, const CKey& key);\n+\n+#endif // BITCOIN_WALLET_TEST_UTIL_H"
      },
      {
        "sha": "75a08b6f74ca68ab8accd340f4fdc6a53b509d3e",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 14,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -20,6 +20,7 @@\n #include <util/translation.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n+#include <wallet/test/util.h>\n #include <wallet/test/wallet_test_fixture.h>\n \n #include <boost/test/unit_test.hpp>\n@@ -480,20 +481,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     ListCoinsTestingSetup()\n     {\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-        wallet = std::make_unique<CWallet>(m_node.chain.get(), \"\", CreateMockWalletDatabase());\n-        {\n-            LOCK2(wallet->cs_wallet, ::cs_main);\n-            wallet->SetLastBlockProcessed(m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n-        }\n-        wallet->LoadWallet();\n-        AddKey(*wallet, coinbaseKey);\n-        WalletRescanReserver reserver(*wallet);\n-        reserver.reserve();\n-        CWallet::ScanResult result = wallet->ScanForWalletTransactions(m_node.chainman->ActiveChain().Genesis()->GetBlockHash(), 0 /* start_height */, {} /* max_height */, reserver, false /* update */);\n-        BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n-        BOOST_CHECK_EQUAL(result.last_scanned_block, m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n-        BOOST_CHECK_EQUAL(*result.last_scanned_height, m_node.chainman->ActiveChain().Height());\n-        BOOST_CHECK(result.last_failed_block.IsNull());\n+        wallet = CreateSyncedWallet(*m_node.chain, m_node.chainman->ActiveChain(), coinbaseKey);\n     }\n \n     ~ListCoinsTestingSetup()"
      },
      {
        "sha": "741540f7248fe2ccb8517224cfbe015858058ce8",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 35,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -2298,44 +2298,48 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n     AssertLockHeld(cs_wallet);\n     mapKeyBirth.clear();\n \n-    LegacyScriptPubKeyMan* spk_man = GetLegacyScriptPubKeyMan();\n-    assert(spk_man != nullptr);\n-    LOCK(spk_man->cs_KeyStore);\n-\n-    // get birth times for keys with metadata\n-    for (const auto& entry : spk_man->mapKeyMetadata) {\n-        if (entry.second.nCreateTime) {\n-            mapKeyBirth[entry.first] = entry.second.nCreateTime;\n-        }\n-    }\n-\n     // map in which we'll infer heights of other keys\n     std::map<CKeyID, const CWalletTx::Confirmation*> mapKeyFirstBlock;\n     CWalletTx::Confirmation max_confirm;\n     max_confirm.block_height = GetLastBlockHeight() > 144 ? GetLastBlockHeight() - 144 : 0; // the tip can be reorganized; use a 144-block safety margin\n     CHECK_NONFATAL(chain().findAncestorByHeight(GetLastBlockHash(), max_confirm.block_height, FoundBlock().hash(max_confirm.hashBlock)));\n-    for (const CKeyID &keyid : spk_man->GetKeys()) {\n-        if (mapKeyBirth.count(keyid) == 0)\n-            mapKeyFirstBlock[keyid] = &max_confirm;\n-    }\n \n-    // if there are no such keys, we're done\n-    if (mapKeyFirstBlock.empty())\n-        return;\n+    {\n+        LegacyScriptPubKeyMan* spk_man = GetLegacyScriptPubKeyMan();\n+        assert(spk_man != nullptr);\n+        LOCK(spk_man->cs_KeyStore);\n+\n+        // get birth times for keys with metadata\n+        for (const auto& entry : spk_man->mapKeyMetadata) {\n+            if (entry.second.nCreateTime) {\n+                mapKeyBirth[entry.first] = entry.second.nCreateTime;\n+            }\n+        }\n+\n+        // Prepare to infer birth heights for keys without metadata\n+        for (const CKeyID &keyid : spk_man->GetKeys()) {\n+            if (mapKeyBirth.count(keyid) == 0)\n+                mapKeyFirstBlock[keyid] = &max_confirm;\n+        }\n \n-    // find first block that affects those keys, if there are any left\n-    for (const auto& entry : mapWallet) {\n-        // iterate over all wallet transactions...\n-        const CWalletTx &wtx = entry.second;\n-        if (wtx.m_confirm.status == CWalletTx::CONFIRMED) {\n-            // ... which are already in a block\n-            for (const CTxOut &txout : wtx.tx->vout) {\n-                // iterate over all their outputs\n-                for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *spk_man)) {\n-                    // ... and all their affected keys\n-                    auto rit = mapKeyFirstBlock.find(keyid);\n-                    if (rit != mapKeyFirstBlock.end() && wtx.m_confirm.block_height < rit->second->block_height) {\n-                        rit->second = &wtx.m_confirm;\n+        // if there are no such keys, we're done\n+        if (mapKeyFirstBlock.empty())\n+            return;\n+\n+        // find first block that affects those keys, if there are any left\n+        for (const auto& entry : mapWallet) {\n+            // iterate over all wallet transactions...\n+            const CWalletTx &wtx = entry.second;\n+            if (wtx.m_confirm.status == CWalletTx::CONFIRMED) {\n+                // ... which are already in a block\n+                for (const CTxOut &txout : wtx.tx->vout) {\n+                    // iterate over all their outputs\n+                    for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *spk_man)) {\n+                        // ... and all their affected keys\n+                        auto rit = mapKeyFirstBlock.find(keyid);\n+                        if (rit != mapKeyFirstBlock.end() && wtx.m_confirm.block_height < rit->second->block_height) {\n+                            rit->second = &wtx.m_confirm;\n+                        }\n                     }\n                 }\n             }\n@@ -2582,19 +2586,21 @@ std::shared_ptr<CWallet> CWallet::Create(interfaces::Chain* chain, const std::st\n     }\n \n     if (!gArgs.GetArg(\"-addresstype\", \"\").empty()) {\n-        if (!ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"), walletInstance->m_default_address_type)) {\n+        std::optional<OutputType> parsed = ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"));\n+        if (!parsed) {\n             error = strprintf(_(\"Unknown address type '%s'\"), gArgs.GetArg(\"-addresstype\", \"\"));\n             return nullptr;\n         }\n+        walletInstance->m_default_address_type = parsed.value();\n     }\n \n     if (!gArgs.GetArg(\"-changetype\", \"\").empty()) {\n-        OutputType out_type;\n-        if (!ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"), out_type)) {\n+        std::optional<OutputType> parsed = ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"));\n+        if (!parsed) {\n             error = strprintf(_(\"Unknown change type '%s'\"), gArgs.GetArg(\"-changetype\", \"\"));\n             return nullptr;\n         }\n-        walletInstance->m_default_change_type = out_type;\n+        walletInstance->m_default_change_type = parsed.value();\n     }\n \n     if (gArgs.IsArgSet(\"-mintxfee\")) {"
      },
      {
        "sha": "c39f6e6d4b7090335506a5afee938c47194dfe08",
        "filename": "test/functional/feature_anchors.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_anchors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_anchors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_anchors.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -23,6 +23,7 @@ def check_node_connections(*, node, num_in, num_out):\n class AnchorsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n+        self.disable_autoconnect = False\n \n     def setup_network(self):\n         self.setup_nodes()"
      },
      {
        "sha": "777787ed328aec3d157daf4f32f5d1d172e08f8c",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 24,
        "deletions": 21,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -22,7 +22,7 @@\n     CTransaction,\n     CTxIn,\n     CTxOut,\n-    MAX_BLOCK_BASE_SIZE,\n+    MAX_BLOCK_WEIGHT,\n     uint256_from_compact,\n     uint256_from_str,\n )\n@@ -307,33 +307,33 @@ def run_test(self):\n         b22 = self.next_block(22, spend=out[5])\n         self.send_blocks([b22], success=False, reject_reason='bad-txns-premature-spend-of-coinbase', reconnect=True)\n \n-        # Create a block on either side of MAX_BLOCK_BASE_SIZE and make sure its accepted/rejected\n+        # Create a block on either side of MAX_BLOCK_WEIGHT and make sure its accepted/rejected\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b23 (6)\n         #                                                                           \\-> b24 (6) -> b25 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n-        self.log.info(\"Accept a block of size MAX_BLOCK_BASE_SIZE\")\n+        self.log.info(\"Accept a block of weight MAX_BLOCK_WEIGHT\")\n         self.move_tip(15)\n         b23 = self.next_block(23, spend=out[6])\n         tx = CTransaction()\n-        script_length = MAX_BLOCK_BASE_SIZE - len(b23.serialize()) - 69\n+        script_length = (MAX_BLOCK_WEIGHT - b23.get_weight() - 276) // 4\n         script_output = CScript([b'\\x00' * script_length])\n         tx.vout.append(CTxOut(0, script_output))\n         tx.vin.append(CTxIn(COutPoint(b23.vtx[1].sha256, 0)))\n         b23 = self.update_block(23, [tx])\n-        # Make sure the math above worked out to produce a max-sized block\n-        assert_equal(len(b23.serialize()), MAX_BLOCK_BASE_SIZE)\n+        # Make sure the math above worked out to produce a max-weighted block\n+        assert_equal(b23.get_weight(), MAX_BLOCK_WEIGHT)\n         self.send_blocks([b23], True)\n         self.save_spendable_output()\n \n-        self.log.info(\"Reject a block of size MAX_BLOCK_BASE_SIZE + 1\")\n+        self.log.info(\"Reject a block of weight MAX_BLOCK_WEIGHT + 4\")\n         self.move_tip(15)\n         b24 = self.next_block(24, spend=out[6])\n-        script_length = MAX_BLOCK_BASE_SIZE - len(b24.serialize()) - 69\n+        script_length = (MAX_BLOCK_WEIGHT - b24.get_weight() - 276) // 4\n         script_output = CScript([b'\\x00' * (script_length + 1)])\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = self.update_block(24, [tx])\n-        assert_equal(len(b24.serialize()), MAX_BLOCK_BASE_SIZE + 1)\n+        assert_equal(b24.get_weight(), MAX_BLOCK_WEIGHT + 1 * 4)\n         self.send_blocks([b24], success=False, reject_reason='bad-blk-length', reconnect=True)\n \n         b25 = self.next_block(25, spend=out[7])\n@@ -373,7 +373,9 @@ def run_test(self):\n         # b30 has a max-sized coinbase scriptSig.\n         self.move_tip(23)\n         b30 = self.next_block(30)\n-        b30.vtx[0].vin[0].scriptSig = b'\\x00' * 100\n+        b30.vtx[0].vin[0].scriptSig = bytes(b30.vtx[0].vin[0].scriptSig)  # Convert CScript to raw bytes\n+        b30.vtx[0].vin[0].scriptSig += b'\\x00' * (100 - len(b30.vtx[0].vin[0].scriptSig))  # Fill with 0s\n+        assert_equal(len(b30.vtx[0].vin[0].scriptSig), 100)\n         b30.vtx[0].rehash()\n         b30 = self.update_block(30, [])\n         self.send_blocks([b30], True)\n@@ -484,13 +486,13 @@ def run_test(self):\n         # Until block is full, add tx's with 1 satoshi to p2sh_script, the rest to OP_TRUE\n         tx_new = None\n         tx_last = tx\n-        total_size = len(b39.serialize())\n-        while(total_size < MAX_BLOCK_BASE_SIZE):\n+        total_weight = b39.get_weight()\n+        while total_weight < MAX_BLOCK_WEIGHT:\n             tx_new = self.create_tx(tx_last, 1, 1, p2sh_script)\n             tx_new.vout.append(CTxOut(tx_last.vout[1].nValue - 1, CScript([OP_TRUE])))\n             tx_new.rehash()\n-            total_size += len(tx_new.serialize())\n-            if total_size >= MAX_BLOCK_BASE_SIZE:\n+            total_weight += tx_new.get_weight()\n+            if total_weight >= MAX_BLOCK_WEIGHT:\n                 break\n             b39.vtx.append(tx_new)  # add tx to block\n             tx_last = tx_new\n@@ -501,7 +503,7 @@ def run_test(self):\n         # Make sure we didn't accidentally make too big a block. Note that the\n         # size of the block has non-determinism due to the ECDSA signature in\n         # the first transaction.\n-        while (len(b39.serialize()) >= MAX_BLOCK_BASE_SIZE):\n+        while b39.get_weight() >= MAX_BLOCK_WEIGHT:\n             del b39.vtx[-1]\n \n         b39 = self.update_block(39, [])\n@@ -833,6 +835,7 @@ def run_test(self):\n         b61.vtx[0].rehash()\n         b61 = self.update_block(61, [])\n         assert_equal(duplicate_tx.serialize(), b61.vtx[0].serialize())\n+        # BIP30 is always checked on regtest, regardless of the BIP34 activation height\n         self.send_blocks([b61], success=False, reject_reason='bad-txns-BIP30', reconnect=True)\n \n         # Test BIP30 (allow duplicate if spent)\n@@ -891,7 +894,7 @@ def run_test(self):\n         self.send_blocks([b63], success=False, reject_reason='bad-txns-nonfinal', reconnect=True)\n \n         #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n-        #  the block is > MAX_BLOCK_BASE_SIZE with the bloated varint, but <= MAX_BLOCK_BASE_SIZE without the bloated varint,\n+        #  the block is > MAX_BLOCK_WEIGHT with the bloated varint, but <= MAX_BLOCK_WEIGHT without the bloated varint,\n         #  does not cause a subsequent, identical block with canonical encoding to be rejected.  The test does not\n         #  care whether the bloated block is accepted or rejected; it only cares that the second block is accepted.\n         #\n@@ -916,12 +919,12 @@ def run_test(self):\n         tx = CTransaction()\n \n         # use canonical serialization to calculate size\n-        script_length = MAX_BLOCK_BASE_SIZE - len(b64a.normal_serialize()) - 69\n+        script_length = (MAX_BLOCK_WEIGHT - 4 * len(b64a.normal_serialize()) - 276) // 4\n         script_output = CScript([b'\\x00' * script_length])\n         tx.vout.append(CTxOut(0, script_output))\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = self.update_block(\"64a\", [tx])\n-        assert_equal(len(b64a.serialize()), MAX_BLOCK_BASE_SIZE + 8)\n+        assert_equal(b64a.get_weight(), MAX_BLOCK_WEIGHT + 8 * 4)\n         self.send_blocks([b64a], success=False, reject_reason='non-canonical ReadCompactSize()')\n \n         # bitcoind doesn't disconnect us for sending a bloated block, but if we subsequently\n@@ -935,7 +938,7 @@ def run_test(self):\n         b64 = CBlock(b64a)\n         b64.vtx = copy.deepcopy(b64a.vtx)\n         assert_equal(b64.hash, b64a.hash)\n-        assert_equal(len(b64.serialize()), MAX_BLOCK_BASE_SIZE)\n+        assert_equal(b64.get_weight(), MAX_BLOCK_WEIGHT)\n         self.blocks[64] = b64\n         b64 = self.update_block(64, [])\n         self.send_blocks([b64], True)\n@@ -1269,12 +1272,12 @@ def run_test(self):\n         for i in range(89, LARGE_REORG_SIZE + 89):\n             b = self.next_block(i, spend)\n             tx = CTransaction()\n-            script_length = MAX_BLOCK_BASE_SIZE - len(b.serialize()) - 69\n+            script_length = (MAX_BLOCK_WEIGHT - b.get_weight() - 276) // 4\n             script_output = CScript([b'\\x00' * script_length])\n             tx.vout.append(CTxOut(0, script_output))\n             tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n             b = self.update_block(i, [tx])\n-            assert_equal(len(b.serialize()), MAX_BLOCK_BASE_SIZE)\n+            assert_equal(b.get_weight(), MAX_BLOCK_WEIGHT)\n             blocks.append(b)\n             self.save_spendable_output()\n             spend = self.get_spendable_output()"
      },
      {
        "sha": "7c14f5d5a62501c24257693208783b3479db46f3",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -9,6 +9,7 @@\n \"\"\"\n \n from test_framework.blocktools import (\n+    CLTV_HEIGHT,\n     create_block,\n     create_coinbase,\n )\n@@ -31,8 +32,6 @@\n     MiniWalletMode,\n )\n \n-CLTV_HEIGHT = 1351\n-\n \n # Helper function to modify a transaction by\n # 1) prepending a given script to the scriptSig of vin 0 and"
      },
      {
        "sha": "71d522a2457e7676f6574fdc9325e89f535f8190",
        "filename": "test/functional/feature_coinstatsindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 13,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_coinstatsindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_coinstatsindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_coinstatsindex.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -32,7 +32,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n-    try_rpc,\n )\n \n class CoinStatsIndexTest(BitcoinTestFramework):\n@@ -76,13 +75,11 @@ def _test_coin_stats_index(self):\n         self.sync_blocks(timeout=120)\n \n         self.log.info(\"Test that gettxoutsetinfo() output is consistent with or without coinstatsindex option\")\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", node.gettxoutsetinfo))\n         res0 = node.gettxoutsetinfo('none')\n \n         # The fields 'disk_size' and 'transactions' do not exist on the index\n         del res0['disk_size'], res0['transactions']\n \n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         for hash_option in index_hash_options:\n             res1 = index_node.gettxoutsetinfo(hash_option)\n             # The fields 'block_info' and 'total_unspendable_amount' only exist on the index\n@@ -97,7 +94,6 @@ def _test_coin_stats_index(self):\n         # Generate a new tip\n         node.generate(5)\n \n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         for hash_option in index_hash_options:\n             # Fetch old stats by height\n             res2 = index_node.gettxoutsetinfo(hash_option, 102)\n@@ -176,7 +172,6 @@ def _test_coin_stats_index(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         for hash_option in index_hash_options:\n             # Check all amounts were registered correctly\n             res6 = index_node.gettxoutsetinfo(hash_option, 108)\n@@ -209,7 +204,6 @@ def _test_coin_stats_index(self):\n         self.nodes[0].submitblock(block.serialize().hex())\n         self.sync_all()\n \n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         for hash_option in index_hash_options:\n             res7 = index_node.gettxoutsetinfo(hash_option, 109)\n             assert_equal(res7['total_unspendable_amount'], Decimal('80.98999999'))\n@@ -235,7 +229,6 @@ def _test_coin_stats_index(self):\n         assert_equal(res8, res9)\n \n         index_node.generate(1)\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         res10 = index_node.gettxoutsetinfo('muhash')\n         assert(res8['txouts'] < res10['txouts'])\n \n@@ -256,14 +249,12 @@ def _test_reorg_index(self):\n         index_node = self.nodes[1]\n         reorg_blocks = index_node.generatetoaddress(2, index_node.getnewaddress())\n         reorg_block = reorg_blocks[1]\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         res_invalid = index_node.gettxoutsetinfo('muhash')\n         index_node.invalidateblock(reorg_blocks[0])\n         assert_equal(index_node.gettxoutsetinfo('muhash')['height'], 110)\n \n         # Add two new blocks\n         block = index_node.generate(2)[1]\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         res = index_node.gettxoutsetinfo(hash_type='muhash', hash_or_height=None, use_index=False)\n \n         # Test that the result of the reorged block is not returned for its old block height\n@@ -285,9 +276,7 @@ def _test_reorg_index(self):\n         # Ensure that removing and re-adding blocks yields consistent results\n         block = index_node.getblockhash(99)\n         index_node.invalidateblock(block)\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         index_node.reconsiderblock(block)\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", index_node.gettxoutsetinfo, 'muhash'))\n         res3 = index_node.gettxoutsetinfo(hash_type='muhash', hash_or_height=112)\n         assert_equal(res2, res3)\n \n@@ -297,8 +286,7 @@ def _test_reorg_index(self):\n         node.getblock(reorg_block)\n \n         self.restart_node(0, [\"-coinstatsindex\"])\n-        self.wait_until(lambda: not try_rpc(-32603, \"Unable to read UTXO set\", node.gettxoutsetinfo, 'muhash'))\n-        assert_raises_rpc_error(-32603, \"Unable to read UTXO set\", node.gettxoutsetinfo, 'muhash', reorg_block)\n+        assert_raises_rpc_error(-32603, \"Unable to get data because coinstatsindex is still syncing.\", node.gettxoutsetinfo, 'muhash', reorg_block)\n \n     def _test_index_rejects_hash_serialized(self):\n         self.log.info(\"Test that the rpc raises if the legacy hash is passed with the index\")"
      },
      {
        "sha": "24c8a8987abee90aacda69546cfc2eddd45cc636",
        "filename": "test/functional/feature_config_args.py",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_config_args.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_config_args.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_config_args.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -17,6 +17,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.supports_cli = False\n         self.wallet_names = []\n+        self.disable_autoconnect = False\n \n     def test_config_file_parser(self):\n         self.stop_node(0)\n@@ -158,8 +159,9 @@ def test_seed_peers(self):\n         self.stop_node(0)\n \n         # No peers.dat exists and -dnsseed=1\n-        # We expect the node will use DNS Seeds, but Regtest mode has 0 DNS seeds\n-        # So after 60 seconds, the node should fallback to fixed seeds (this is a slow test)\n+        # We expect the node will use DNS Seeds, but Regtest mode does not have\n+        # any valid DNS seeds. So after 60 seconds, the node should fallback to\n+        # fixed seeds\n         assert not os.path.exists(os.path.join(default_data_dir, \"peers.dat\"))\n         start = int(time.time())\n         with self.nodes[0].assert_debug_log(expected_msgs=["
      },
      {
        "sha": "1ac1a0563f5834675ca50fe1cb2e7c85cf6f3b1a",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -41,6 +41,7 @@\n import time\n \n from test_framework.blocktools import (\n+    CSV_ACTIVATION_HEIGHT,\n     create_block,\n     create_coinbase,\n )\n@@ -63,7 +64,6 @@\n TESTING_TX_COUNT = 83  # Number of testing transactions: 1 BIP113 tx, 16 BIP68 txs, 66 BIP112 txs (see comments above)\n COINBASE_BLOCK_COUNT = TESTING_TX_COUNT  # Number of coinbase blocks we need to generate as inputs for our txs\n BASE_RELATIVE_LOCKTIME = 10\n-CSV_ACTIVATION_HEIGHT = 432\n SEQ_DISABLE_FLAG = 1 << 31\n SEQ_RANDOM_HIGH_BIT = 1 << 25\n SEQ_TYPE_FLAG = 1 << 22"
      },
      {
        "sha": "6d8e5430f801cb0ccd6606b996dd5cf6e75c343a",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -41,7 +41,6 @@\n from test_framework.util import (\n     assert_equal,\n     create_confirmed_utxos,\n-    hex_str_to_bytes,\n )\n \n \n@@ -204,7 +203,7 @@ def generate_small_transactions(self, node, count, utxo_list):\n                 continue\n \n             for _ in range(3):\n-                tx.vout.append(CTxOut(output_amount, hex_str_to_bytes(utxo['scriptPubKey'])))\n+                tx.vout.append(CTxOut(output_amount, bytes.fromhex(utxo['scriptPubKey'])))\n \n             # Sign and send the transaction to get into the mempool\n             tx_signed_hex = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']"
      },
      {
        "sha": "0428588da396e2c4bd76b441c90ec202ab45f63d",
        "filename": "test/functional/feature_presegwit_node_upgrade.py",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_presegwit_node_upgrade.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_presegwit_node_upgrade.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_presegwit_node_upgrade.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,52 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a pre-segwit node upgrading to segwit consensus\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+\n+class SegwitUpgradeTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-segwitheight=10\"]]\n+\n+    def run_test(self):\n+        \"\"\"A pre-segwit node with insufficiently validated blocks needs to redownload blocks\"\"\"\n+\n+        self.log.info(\"Testing upgrade behaviour for pre-segwit node to segwit rules\")\n+        node = self.nodes[0]\n+\n+        # Node hasn't been used or connected yet\n+        assert_equal(node.getblockcount(), 0)\n+\n+        assert not softfork_active(node, \"segwit\")\n+\n+        # Generate 8 blocks without witness data\n+        node.generate(8)\n+        assert_equal(node.getblockcount(), 8)\n+\n+        self.stop_node(0)\n+        # Restarting the node (with segwit activation height set to 5) should result in a shutdown\n+        # because the blockchain consists of 3 insufficiently validated blocks per segwit consensus rules.\n+        node.assert_start_raises_init_error(\n+                extra_args=[\"-segwitheight=5\"],\n+                expected_msg=\": Witness data for blocks after height 5 requires validation. Please restart with -reindex..\\nPlease restart with -reindex or -reindex-chainstate to recover.\")\n+\n+        # As directed, the user restarts the node with -reindex\n+        self.start_node(0, extra_args=[\"-reindex\", \"-segwitheight=5\"])\n+\n+        # With the segwit consensus rules, the node is able to validate only up to block 4\n+        assert_equal(node.getblockcount(), 4)\n+\n+        # The upgraded node should now have segwit activated\n+        assert softfork_active(node, \"segwit\")\n+\n+\n+if __name__ == '__main__':\n+    SegwitUpgradeTest().main()"
      },
      {
        "sha": "65929704eb62a55f412b9b4096493623fc34d985",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 19,
        "deletions": 30,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,6 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the RBF code.\"\"\"\n \n+from copy import deepcopy\n from decimal import Decimal\n \n from test_framework.blocktools import COINBASE_MATURITY\n@@ -84,10 +85,11 @@ def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n-        make_utxo(self.nodes[0], 1 * COIN)\n-\n-        # Ensure nodes are synced\n-        self.sync_all()\n+        self.wallet = MiniWallet(self.nodes[0])\n+        # the pre-mined test framework chain contains coinbase outputs to the\n+        # MiniWallet's default address ADDRESS_BCRT1_P2WSH_OP_TRUE in blocks\n+        # 76-100 (see method BitcoinTestFramework._initialize_chain())\n+        self.wallet.scan_blocks(start=76, num=2)\n \n         self.log.info(\"Running test simple doublespend...\")\n         self.test_simple_doublespend()\n@@ -129,34 +131,25 @@ def run_test(self):\n \n     def test_simple_doublespend(self):\n         \"\"\"Simple doublespend\"\"\"\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1 * COIN))\n-\n-        # make_utxo may have generated a bunch of blocks, so we need to sync\n-        # before we can spend the coins generated, or else the resulting\n-        # transactions might not be accepted by our peers.\n-        self.sync_all()\n+        # we use MiniWallet to create a transaction template with inputs correctly set,\n+        # and modify the output (amount, scriptPubKey) according to our needs\n+        tx_template = self.wallet.create_self_transfer(from_node=self.nodes[0])['tx']\n \n-        tx1a = CTransaction()\n-        tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1a = deepcopy(tx_template)\n         tx1a.vout = [CTxOut(1 * COIN, DUMMY_P2WPKH_SCRIPT)]\n         tx1a_hex = tx1a.serialize().hex()\n         tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n \n-        self.sync_all()\n-\n         # Should fail because we haven't changed the fee\n-        tx1b = CTransaction()\n-        tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1b = deepcopy(tx_template)\n         tx1b.vout = [CTxOut(1 * COIN, DUMMY_2_P2WPKH_SCRIPT)]\n         tx1b_hex = tx1b.serialize().hex()\n \n         # This will raise an exception due to insufficient fee\n         assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n \n         # Extra 0.1 BTC fee\n-        tx1b = CTransaction()\n-        tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n-        tx1b.vout = [CTxOut(int(0.9 * COIN), DUMMY_P2WPKH_SCRIPT)]\n+        tx1b.vout[0].nValue -= int(0.1 * COIN)\n         tx1b_hex = tx1b.serialize().hex()\n         # Works when enabled\n         tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n@@ -574,20 +567,18 @@ def test_rpc(self):\n         assert_equal(json1[\"vin\"][0][\"sequence\"], 4294967294)\n \n     def test_no_inherited_signaling(self):\n-        wallet = MiniWallet(self.nodes[0])\n-        wallet.scan_blocks(start=76, num=1)\n-        confirmed_utxo = wallet.get_utxo()\n+        confirmed_utxo = self.wallet.get_utxo()\n \n         # Create an explicitly opt-in parent transaction\n-        optin_parent_tx = wallet.send_self_transfer(\n+        optin_parent_tx = self.wallet.send_self_transfer(\n             from_node=self.nodes[0],\n             utxo_to_spend=confirmed_utxo,\n             sequence=BIP125_SEQUENCE_NUMBER,\n             fee_rate=Decimal('0.01'),\n         )\n         assert_equal(True, self.nodes[0].getmempoolentry(optin_parent_tx['txid'])['bip125-replaceable'])\n \n-        replacement_parent_tx = wallet.create_self_transfer(\n+        replacement_parent_tx = self.wallet.create_self_transfer(\n             from_node=self.nodes[0],\n             utxo_to_spend=confirmed_utxo,\n             sequence=BIP125_SEQUENCE_NUMBER,\n@@ -601,8 +592,8 @@ def test_no_inherited_signaling(self):\n         assert_equal(res['allowed'], True)\n \n         # Create an opt-out child tx spending the opt-in parent\n-        parent_utxo = wallet.get_utxo(txid=optin_parent_tx['txid'])\n-        optout_child_tx = wallet.send_self_transfer(\n+        parent_utxo = self.wallet.get_utxo(txid=optin_parent_tx['txid'])\n+        optout_child_tx = self.wallet.send_self_transfer(\n             from_node=self.nodes[0],\n             utxo_to_spend=parent_utxo,\n             sequence=0xffffffff,\n@@ -612,7 +603,7 @@ def test_no_inherited_signaling(self):\n         # Reports true due to inheritance\n         assert_equal(True, self.nodes[0].getmempoolentry(optout_child_tx['txid'])['bip125-replaceable'])\n \n-        replacement_child_tx = wallet.create_self_transfer(\n+        replacement_child_tx = self.wallet.create_self_transfer(\n             from_node=self.nodes[0],\n             utxo_to_spend=parent_utxo,\n             sequence=0xffffffff,\n@@ -631,9 +622,7 @@ def test_no_inherited_signaling(self):\n         assert_raises_rpc_error(-26, 'txn-mempool-conflict', self.nodes[0].sendrawtransaction, replacement_child_tx[\"hex\"], 0)\n \n     def test_replacement_relay_fee(self):\n-        wallet = MiniWallet(self.nodes[0])\n-        wallet.scan_blocks(start=77, num=1)\n-        tx = wallet.send_self_transfer(from_node=self.nodes[0])['tx']\n+        tx = self.wallet.send_self_transfer(from_node=self.nodes[0])['tx']\n \n         # Higher fee, higher feerate, different txid, but the replacement does not provide a relay\n         # fee conforming to node's `incrementalrelayfee` policy of 1000 sat per KB."
      },
      {
        "sha": "cbd85214994e1311c2242d84f36be2d177dba1c6",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 15,
        "deletions": 16,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -46,7 +46,6 @@\n     assert_equal,\n     assert_is_hex_string,\n     assert_raises_rpc_error,\n-    hex_str_to_bytes,\n     try_rpc,\n )\n \n@@ -140,7 +139,7 @@ def run_test(self):\n         for i in range(3):\n             newaddress = self.nodes[i].getnewaddress()\n             self.pubkey.append(self.nodes[i].getaddressinfo(newaddress)[\"pubkey\"])\n-            multiscript = CScript([OP_1, hex_str_to_bytes(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n+            multiscript = CScript([OP_1, bytes.fromhex(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n             p2sh_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'p2sh-segwit')['address']\n             bip173_ms_addr = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]], '', 'bech32')['address']\n             assert_equal(p2sh_ms_addr, script_to_p2sh_p2wsh(multiscript))\n@@ -260,8 +259,8 @@ def run_test(self):\n         assert_equal(int(self.nodes[0].getmempoolentry(txid1)[\"wtxid\"], 16), tx1.calc_sha256(True))\n \n         # Check that weight and vsize are properly reported in mempool entry (txid1)\n-        assert_equal(self.nodes[0].getmempoolentry(txid1)[\"vsize\"], (self.nodes[0].getmempoolentry(txid1)[\"weight\"] + 3) // 4)\n-        assert_equal(self.nodes[0].getmempoolentry(txid1)[\"weight\"], len(tx1.serialize_without_witness())*3 + len(tx1.serialize_with_witness()))\n+        assert_equal(self.nodes[0].getmempoolentry(txid1)[\"vsize\"], tx1.get_vsize())\n+        assert_equal(self.nodes[0].getmempoolentry(txid1)[\"weight\"], tx1.get_weight())\n \n         # Now create tx2, which will spend from txid1.\n         tx = CTransaction()\n@@ -276,8 +275,8 @@ def run_test(self):\n         assert_equal(int(self.nodes[0].getmempoolentry(txid2)[\"wtxid\"], 16), tx.calc_sha256(True))\n \n         # Check that weight and vsize are properly reported in mempool entry (txid2)\n-        assert_equal(self.nodes[0].getmempoolentry(txid2)[\"vsize\"], (self.nodes[0].getmempoolentry(txid2)[\"weight\"] + 3) // 4)\n-        assert_equal(self.nodes[0].getmempoolentry(txid2)[\"weight\"], len(tx.serialize_without_witness())*3 + len(tx.serialize_with_witness()))\n+        assert_equal(self.nodes[0].getmempoolentry(txid2)[\"vsize\"], tx.get_vsize())\n+        assert_equal(self.nodes[0].getmempoolentry(txid2)[\"weight\"], tx.get_weight())\n \n         # Now create tx3, which will spend from txid2\n         tx = CTransaction()\n@@ -299,8 +298,8 @@ def run_test(self):\n         assert_equal(int(self.nodes[0].getmempoolentry(txid3)[\"wtxid\"], 16), tx.calc_sha256(True))\n \n         # Check that weight and vsize are properly reported in mempool entry (txid3)\n-        assert_equal(self.nodes[0].getmempoolentry(txid3)[\"vsize\"], (self.nodes[0].getmempoolentry(txid3)[\"weight\"] + 3) // 4)\n-        assert_equal(self.nodes[0].getmempoolentry(txid3)[\"weight\"], len(tx.serialize_without_witness())*3 + len(tx.serialize_with_witness()))\n+        assert_equal(self.nodes[0].getmempoolentry(txid3)[\"vsize\"], tx.get_vsize())\n+        assert_equal(self.nodes[0].getmempoolentry(txid3)[\"weight\"], tx.get_weight())\n \n         # Mine a block to clear the gbt cache again.\n         self.nodes[0].generate(1)\n@@ -352,7 +351,7 @@ def run_test(self):\n         # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n \n         multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])['address']\n-        script = CScript([OP_2, hex_str_to_bytes(pubkeys[3]), hex_str_to_bytes(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n+        script = CScript([OP_2, bytes.fromhex(pubkeys[3]), bytes.fromhex(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n         solvable_after_importaddress.append(script_to_p2sh_script(script))\n \n         for i in compressed_spendable_address:\n@@ -426,7 +425,7 @@ def run_test(self):\n         op1 = CScript([OP_1])\n         op0 = CScript([OP_0])\n         # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n-        unsolvable_address_key = hex_str_to_bytes(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n+        unsolvable_address_key = bytes.fromhex(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n         unsolvablep2pkh = key_to_p2pkh_script(unsolvable_address_key)\n         unsolvablep2wshp2pkh = script_to_p2wsh_script(unsolvablep2pkh)\n         p2shop0 = script_to_p2sh_script(op0)\n@@ -448,11 +447,11 @@ def run_test(self):\n         for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n-                bare = hex_str_to_bytes(v['hex'])\n+                bare = bytes.fromhex(v['hex'])\n                 importlist.append(bare.hex())\n                 importlist.append(script_to_p2wsh_script(bare).hex())\n             else:\n-                pubkey = hex_str_to_bytes(v['pubkey'])\n+                pubkey = bytes.fromhex(v['pubkey'])\n                 p2pk = CScript([pubkey, OP_CHECKSIG])\n                 p2pkh = key_to_p2pkh_script(pubkey)\n                 importlist.append(p2pk.hex())\n@@ -612,18 +611,18 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         return txid\n \n     def p2sh_address_to_script(self, v):\n-        bare = CScript(hex_str_to_bytes(v['hex']))\n-        p2sh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n+        bare = CScript(bytes.fromhex(v['hex']))\n+        p2sh = CScript(bytes.fromhex(v['scriptPubKey']))\n         p2wsh = script_to_p2wsh_script(bare)\n         p2sh_p2wsh = script_to_p2sh_script(p2wsh)\n         return([bare, p2sh, p2wsh, p2sh_p2wsh])\n \n     def p2pkh_address_to_script(self, v):\n-        pubkey = hex_str_to_bytes(v['pubkey'])\n+        pubkey = bytes.fromhex(v['pubkey'])\n         p2wpkh = key_to_p2wpkh_script(pubkey)\n         p2sh_p2wpkh = script_to_p2sh_script(p2wpkh)\n         p2pk = CScript([pubkey, OP_CHECKSIG])\n-        p2pkh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n+        p2pkh = CScript(bytes.fromhex(v['scriptPubKey']))\n         p2sh_p2pk = script_to_p2sh_script(p2pk)\n         p2sh_p2pkh = script_to_p2sh_script(p2pkh)\n         p2wsh_p2pk = script_to_p2wsh_script(p2pk)"
      },
      {
        "sha": "dfa448a1a867a9b8652ecb7a68d5e2d7ecb59e55",
        "filename": "test/functional/interface_bitcoin_cli.py",
        "status": "modified",
        "additions": 98,
        "deletions": 43,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/interface_bitcoin_cli.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/interface_bitcoin_cli.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_bitcoin_cli.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -5,6 +5,7 @@\n \"\"\"Test bitcoin-cli\"\"\"\n \n from decimal import Decimal\n+import re\n \n from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.test_framework import BitcoinTestFramework\n@@ -29,6 +30,41 @@\n WALLET_NOT_LOADED = 'Requested wallet does not exist or is not loaded'\n WALLET_NOT_SPECIFIED = 'Wallet file not specified'\n \n+\n+def cli_get_info_string_to_dict(cli_get_info_string):\n+    \"\"\"Helper method to convert human-readable -getinfo into a dictionary\"\"\"\n+    cli_get_info = {}\n+    lines = cli_get_info_string.splitlines()\n+    line_idx = 0\n+    ansi_escape = re.compile(r'(\\x9B|\\x1B\\[)[0-?]*[ -\\/]*[@-~]')\n+    while line_idx < len(lines):\n+        # Remove ansi colour code\n+        line = ansi_escape.sub('', lines[line_idx])\n+        if \"Balances\" in line:\n+            # When \"Balances\" appears in a line, all of the following lines contain \"balance: wallet\" until an empty line\n+            cli_get_info[\"Balances\"] = {}\n+            while line_idx < len(lines) and not (lines[line_idx + 1] == ''):\n+                line_idx += 1\n+                balance, wallet = lines[line_idx].strip().split(\" \")\n+                # Remove right justification padding\n+                wallet = wallet.strip()\n+                if wallet == '\"\"':\n+                    # Set default wallet(\"\") to empty string\n+                    wallet = ''\n+                cli_get_info[\"Balances\"][wallet] = balance.strip()\n+        elif \": \" in line:\n+            key, value = line.split(\": \")\n+            if key == 'Wallet' and value == '\"\"':\n+                # Set default wallet(\"\") to empty string\n+                value = ''\n+            if key == \"Proxy\" and value == \"N/A\":\n+                # Set N/A to empty string to represent no proxy\n+                value = ''\n+            cli_get_info[key.strip()] = value.strip()\n+        line_idx += 1\n+    return cli_get_info\n+\n+\n class TestBitcoinCli(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -67,37 +103,43 @@ def run_test(self):\n         self.log.info(\"Test -getinfo with arguments fails\")\n         assert_raises_process_error(1, \"-getinfo takes no arguments\", self.nodes[0].cli('-getinfo').help)\n \n+        self.log.info(\"Test -getinfo with -color=never does not return ANSI escape codes\")\n+        assert \"\\u001b[0m\" not in self.nodes[0].cli('-getinfo', '-color=never').send_cli()\n+\n+        self.log.info(\"Test -getinfo with -color=always returns ANSI escape codes\")\n+        assert \"\\u001b[0m\" in self.nodes[0].cli('-getinfo', '-color=always').send_cli()\n+\n+        self.log.info(\"Test -getinfo with invalid value for -color option\")\n+        assert_raises_process_error(1, \"Invalid value for -color option. Valid values: always, auto, never.\", self.nodes[0].cli('-getinfo', '-color=foo').send_cli)\n+\n         self.log.info(\"Test -getinfo returns expected network and blockchain info\")\n         if self.is_wallet_compiled():\n             self.nodes[0].encryptwallet(password)\n-        cli_get_info = self.nodes[0].cli('-getinfo').send_cli()\n+        cli_get_info_string = self.nodes[0].cli('-getinfo').send_cli()\n+        cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n+\n         network_info = self.nodes[0].getnetworkinfo()\n         blockchain_info = self.nodes[0].getblockchaininfo()\n-        assert_equal(cli_get_info['version'], network_info['version'])\n-        assert_equal(cli_get_info['blocks'], blockchain_info['blocks'])\n-        assert_equal(cli_get_info['headers'], blockchain_info['headers'])\n-        assert_equal(cli_get_info['timeoffset'], network_info['timeoffset'])\n-        assert_equal(\n-            cli_get_info['connections'],\n-            {\n-                'in': network_info['connections_in'],\n-                'out': network_info['connections_out'],\n-                'total': network_info['connections']\n-            }\n-        )\n-        assert_equal(cli_get_info['proxy'], network_info['networks'][0]['proxy'])\n-        assert_equal(cli_get_info['difficulty'], blockchain_info['difficulty'])\n-        assert_equal(cli_get_info['chain'], blockchain_info['chain'])\n+        assert_equal(int(cli_get_info['Version']), network_info['version'])\n+        assert_equal(cli_get_info['Verification progress'], \"%.4f%%\" % (blockchain_info['verificationprogress'] * 100))\n+        assert_equal(int(cli_get_info['Blocks']), blockchain_info['blocks'])\n+        assert_equal(int(cli_get_info['Headers']), blockchain_info['headers'])\n+        assert_equal(int(cli_get_info['Time offset (s)']), network_info['timeoffset'])\n+        expected_network_info = f\"in {network_info['connections_in']}, out {network_info['connections_out']}, total {network_info['connections']}\"\n+        assert_equal(cli_get_info[\"Network\"], expected_network_info)\n+        assert_equal(cli_get_info['Proxy'], network_info['networks'][0]['proxy'])\n+        assert_equal(Decimal(cli_get_info['Difficulty']), blockchain_info['difficulty'])\n+        assert_equal(cli_get_info['Chain'], blockchain_info['chain'])\n \n         if self.is_wallet_compiled():\n             self.log.info(\"Test -getinfo and bitcoin-cli getwalletinfo return expected wallet info\")\n-            assert_equal(cli_get_info['balance'], BALANCE)\n-            assert 'balances' not in cli_get_info.keys()\n+            assert_equal(Decimal(cli_get_info['Balance']), BALANCE)\n+            assert 'Balances' not in cli_get_info_string\n             wallet_info = self.nodes[0].getwalletinfo()\n-            assert_equal(cli_get_info['keypoolsize'], wallet_info['keypoolsize'])\n-            assert_equal(cli_get_info['unlocked_until'], wallet_info['unlocked_until'])\n-            assert_equal(cli_get_info['paytxfee'], wallet_info['paytxfee'])\n-            assert_equal(cli_get_info['relayfee'], network_info['relayfee'])\n+            assert_equal(int(cli_get_info['Keypool size']), wallet_info['keypoolsize'])\n+            assert_equal(int(cli_get_info['Unlocked until']), wallet_info['unlocked_until'])\n+            assert_equal(Decimal(cli_get_info['Transaction fee rate (-paytxfee) (BTC/kvB)']), wallet_info['paytxfee'])\n+            assert_equal(Decimal(cli_get_info['Min tx relay fee rate (BTC/kvB)']), network_info['relayfee'])\n             assert_equal(self.nodes[0].cli.getwalletinfo(), wallet_info)\n \n             # Setup to test -getinfo, -generate, and -rpcwallet= with multiple wallets.\n@@ -120,44 +162,57 @@ def run_test(self):\n \n             self.log.info(\"Test -getinfo with multiple wallets and -rpcwallet returns specified wallet balance\")\n             for i in range(len(wallets)):\n-                cli_get_info = self.nodes[0].cli('-getinfo', '-rpcwallet={}'.format(wallets[i])).send_cli()\n-                assert 'balances' not in cli_get_info.keys()\n-                assert_equal(cli_get_info['balance'], amounts[i])\n+                cli_get_info_string = self.nodes[0].cli('-getinfo', '-rpcwallet={}'.format(wallets[i])).send_cli()\n+                cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n+                assert 'Balances' not in cli_get_info_string\n+                assert_equal(cli_get_info[\"Wallet\"], wallets[i])\n+                assert_equal(Decimal(cli_get_info['Balance']), amounts[i])\n \n             self.log.info(\"Test -getinfo with multiple wallets and -rpcwallet=non-existing-wallet returns no balances\")\n-            cli_get_info_keys = self.nodes[0].cli('-getinfo', '-rpcwallet=does-not-exist').send_cli().keys()\n-            assert 'balance' not in cli_get_info_keys\n-            assert 'balances' not in cli_get_info_keys\n+            cli_get_info_string = self.nodes[0].cli('-getinfo', '-rpcwallet=does-not-exist').send_cli()\n+            assert 'Balance' not in cli_get_info_string\n+            assert 'Balances' not in cli_get_info_string\n \n             self.log.info(\"Test -getinfo with multiple wallets returns all loaded wallet names and balances\")\n             assert_equal(set(self.nodes[0].listwallets()), set(wallets))\n-            cli_get_info = self.nodes[0].cli('-getinfo').send_cli()\n-            assert 'balance' not in cli_get_info.keys()\n-            assert_equal(cli_get_info['balances'], {k: v for k, v in zip(wallets, amounts)})\n+            cli_get_info_string = self.nodes[0].cli('-getinfo').send_cli()\n+            cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n+            assert 'Balance' not in cli_get_info\n+            for k, v in zip(wallets, amounts):\n+                assert_equal(Decimal(cli_get_info['Balances'][k]), v)\n \n             # Unload the default wallet and re-verify.\n             self.nodes[0].unloadwallet(wallets[0])\n             assert wallets[0] not in self.nodes[0].listwallets()\n-            cli_get_info = self.nodes[0].cli('-getinfo').send_cli()\n-            assert 'balance' not in cli_get_info.keys()\n-            assert_equal(cli_get_info['balances'], {k: v for k, v in zip(wallets[1:], amounts[1:])})\n+            cli_get_info_string = self.nodes[0].cli('-getinfo').send_cli()\n+            cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n+            assert 'Balance' not in cli_get_info\n+            assert 'Balances' in cli_get_info_string\n+            for k, v in zip(wallets[1:], amounts[1:]):\n+                assert_equal(Decimal(cli_get_info['Balances'][k]), v)\n+            assert wallets[0] not in cli_get_info\n \n             self.log.info(\"Test -getinfo after unloading all wallets except a non-default one returns its balance\")\n             self.nodes[0].unloadwallet(wallets[2])\n             assert_equal(self.nodes[0].listwallets(), [wallets[1]])\n-            cli_get_info = self.nodes[0].cli('-getinfo').send_cli()\n-            assert 'balances' not in cli_get_info.keys()\n-            assert_equal(cli_get_info['balance'], amounts[1])\n+            cli_get_info_string = self.nodes[0].cli('-getinfo').send_cli()\n+            cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n+            assert 'Balances' not in cli_get_info_string\n+            assert_equal(cli_get_info['Wallet'], wallets[1])\n+            assert_equal(Decimal(cli_get_info['Balance']), amounts[1])\n \n             self.log.info(\"Test -getinfo with -rpcwallet=remaining-non-default-wallet returns only its balance\")\n-            cli_get_info = self.nodes[0].cli('-getinfo', rpcwallet2).send_cli()\n-            assert 'balances' not in cli_get_info.keys()\n-            assert_equal(cli_get_info['balance'], amounts[1])\n+            cli_get_info_string = self.nodes[0].cli('-getinfo', rpcwallet2).send_cli()\n+            cli_get_info = cli_get_info_string_to_dict(cli_get_info_string)\n+            assert 'Balances' not in cli_get_info_string\n+            assert_equal(cli_get_info['Wallet'], wallets[1])\n+            assert_equal(Decimal(cli_get_info['Balance']), amounts[1])\n \n             self.log.info(\"Test -getinfo with -rpcwallet=unloaded wallet returns no balances\")\n-            cli_get_info_keys = self.nodes[0].cli('-getinfo', rpcwallet3).send_cli().keys()\n-            assert 'balance' not in cli_get_info_keys\n-            assert 'balances' not in cli_get_info_keys\n+            cli_get_info_string = self.nodes[0].cli('-getinfo', rpcwallet3).send_cli()\n+            cli_get_info_keys = cli_get_info_string_to_dict(cli_get_info_string)\n+            assert 'Balance' not in cli_get_info_keys\n+            assert 'Balances' not in cli_get_info_string\n \n             # Test bitcoin-cli -generate.\n             n1 = 3"
      },
      {
        "sha": "d644a420fc95526834028c602cc167603177f586",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,7 +4,6 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the REST API.\"\"\"\n \n-import binascii\n from decimal import Decimal\n from enum import Enum\n from io import BytesIO\n@@ -19,7 +18,6 @@\n     assert_equal,\n     assert_greater_than,\n     assert_greater_than_or_equal,\n-    hex_str_to_bytes,\n )\n \n from test_framework.messages import BLOCK_HEADER_SIZE\n@@ -147,7 +145,7 @@ def run_test(self):\n \n         bin_request = b'\\x01\\x02'\n         for txid, n in [spending, spent]:\n-            bin_request += hex_str_to_bytes(txid)\n+            bin_request += bytes.fromhex(txid)\n             bin_request += pack(\"i\", n)\n \n         bin_response = self.test_rest_request(\"/getutxos\", http_method='POST', req_type=ReqType.BIN, body=bin_request, ret_type=RetType.BYTES)\n@@ -236,13 +234,13 @@ def run_test(self):\n         response_hex = self.test_rest_request(\"/block/{}\".format(bb_hash), req_type=ReqType.HEX, ret_type=RetType.OBJ)\n         assert_greater_than(int(response_hex.getheader('content-length')), BLOCK_HEADER_SIZE*2)\n         response_hex_bytes = response_hex.read().strip(b'\\n')\n-        assert_equal(binascii.hexlify(response_bytes), response_hex_bytes)\n+        assert_equal(response_bytes.hex().encode(), response_hex_bytes)\n \n         # Compare with hex block header\n         response_header_hex = self.test_rest_request(\"/headers/1/{}\".format(bb_hash), req_type=ReqType.HEX, ret_type=RetType.OBJ)\n         assert_greater_than(int(response_header_hex.getheader('content-length')), BLOCK_HEADER_SIZE*2)\n         response_header_hex_bytes = response_header_hex.read(BLOCK_HEADER_SIZE*2)\n-        assert_equal(binascii.hexlify(response_bytes[:BLOCK_HEADER_SIZE]), response_header_hex_bytes)\n+        assert_equal(response_bytes[:BLOCK_HEADER_SIZE].hex().encode(), response_header_hex_bytes)\n \n         # Check json format\n         block_json_obj = self.test_rest_request(\"/block/{}\".format(bb_hash))"
      },
      {
        "sha": "97d29ff197861b2c4ac449f6cb666ec58b0dc95e",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -15,7 +15,7 @@\n     COutPoint,\n     CTxIn,\n     CTxOut,\n-    MAX_BLOCK_BASE_SIZE,\n+    MAX_BLOCK_WEIGHT,\n     MAX_MONEY,\n     tx_from_hex,\n )\n@@ -209,7 +209,7 @@ def run_test(self):\n \n         self.log.info('A really large transaction')\n         tx = tx_from_hex(raw_tx_reference)\n-        tx.vin = [tx.vin[0]] * math.ceil(MAX_BLOCK_BASE_SIZE / len(tx.vin[0].serialize()))\n+        tx.vin = [tx.vin[0]] * math.ceil(MAX_BLOCK_WEIGHT // 4 / len(tx.vin[0].serialize()))\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-oversize'}],\n             rawtxs=[tx.serialize().hex()],"
      },
      {
        "sha": "ffafe7428fcc2b773e0a238fdfcdae43deb4c83c",
        "filename": "test/functional/mempool_accept_wtxid.py",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_accept_wtxid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_accept_wtxid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept_wtxid.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,9 +4,10 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"\n Test mempool acceptance in case of an already known transaction\n-with identical non-witness data different witness.\n+with identical non-witness data but different witness.\n \"\"\"\n \n+from copy import deepcopy\n from test_framework.messages import (\n     COIN,\n     COutPoint,\n@@ -16,6 +17,7 @@\n     CTxOut,\n     sha256,\n )\n+from test_framework.p2p import P2PTxInvStore\n from test_framework.script import (\n     CScript,\n     OP_0,\n@@ -62,6 +64,8 @@ def run_test(self):\n         parent_txid = node.sendrawtransaction(hexstring=raw_parent, maxfeerate=0)\n         node.generate(1)\n \n+        peer_wtxid_relay = node.add_p2p_connection(P2PTxInvStore())\n+\n         # Create a new transaction with witness solving first branch\n         child_witness_script = CScript([OP_TRUE])\n         child_witness_program = sha256(child_witness_script)\n@@ -76,30 +80,29 @@ def run_test(self):\n         child_one_txid = child_one.rehash()\n \n         # Create another identical transaction with witness solving second branch\n-        child_two = CTransaction()\n-        child_two.vin.append(CTxIn(COutPoint(int(parent_txid, 16), 0), b\"\"))\n-        child_two.vout.append(CTxOut(int(9.99996 * COIN), child_script_pubkey))\n-        child_two.wit.vtxinwit.append(CTxInWitness())\n+        child_two = deepcopy(child_one)\n         child_two.wit.vtxinwit[0].scriptWitness.stack = [b'', witness_script]\n         child_two_wtxid = child_two.getwtxid()\n         child_two_txid = child_two.rehash()\n \n         assert_equal(child_one_txid, child_two_txid)\n         assert child_one_wtxid != child_two_wtxid\n \n-        self.log.info(\"Submit one child to the mempool\")\n+        self.log.info(\"Submit child_one to the mempool\")\n         txid_submitted = node.sendrawtransaction(child_one.serialize().hex())\n         assert_equal(node.getrawmempool(True)[txid_submitted]['wtxid'], child_one_wtxid)\n \n+        peer_wtxid_relay.wait_for_broadcast([child_one_wtxid])\n+        assert_equal(node.getmempoolinfo()[\"unbroadcastcount\"], 0)\n+\n         # testmempoolaccept reports the \"already in mempool\" error\n         assert_equal(node.testmempoolaccept([child_one.serialize().hex()]), [{\n             \"txid\": child_one_txid,\n             \"wtxid\": child_one_wtxid,\n             \"allowed\": False,\n             \"reject-reason\": \"txn-already-in-mempool\"\n         }])\n-        testres_child_two = node.testmempoolaccept([child_two.serialize().hex()])[0]\n-        assert_equal(testres_child_two, {\n+        assert_equal(node.testmempoolaccept([child_two.serialize().hex()])[0], {\n             \"txid\": child_two_txid,\n             \"wtxid\": child_two_wtxid,\n             \"allowed\": False,\n@@ -108,9 +111,18 @@ def run_test(self):\n \n         # sendrawtransaction will not throw but quits early when the exact same transaction is already in mempool\n         node.sendrawtransaction(child_one.serialize().hex())\n+\n+        self.log.info(\"Connect another peer that hasn't seen child_one before\")\n+        peer_wtxid_relay_2 = node.add_p2p_connection(P2PTxInvStore())\n+\n+        self.log.info(\"Submit child_two to the mempool\")\n         # sendrawtransaction will not throw but quits early when a transaction with the same non-witness data is already in mempool\n         node.sendrawtransaction(child_two.serialize().hex())\n \n+        # The node should rebroadcast the transaction using the wtxid of the correct transaction\n+        # (child_one, which is in its mempool).\n+        peer_wtxid_relay_2.wait_for_broadcast([child_one_wtxid])\n+        assert_equal(node.getmempoolinfo()[\"unbroadcastcount\"], 0)\n \n if __name__ == '__main__':\n     MempoolWtxidTest().main()"
      },
      {
        "sha": "b5086e1df1809c86beca97d609b3cb4486373c7b",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -80,7 +80,7 @@ def run_test(self):\n         self.log.info(\"Generate a block\")\n         last_block = self.nodes[0].generate(1)\n         # Sync blocks, so that peer 1 gets the block before timelock_tx\n-        # Otherwise, peer 1 would put the timelock_tx in recentRejects\n+        # Otherwise, peer 1 would put the timelock_tx in m_recent_rejects\n         self.sync_all()\n \n         self.log.info(\"The time-locked transaction can now be spent\")"
      },
      {
        "sha": "7d9e6c306d8ac18f958e04a250e4ac7d74d96d68",
        "filename": "test/functional/mempool_unbroadcast.py",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_unbroadcast.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/mempool_unbroadcast.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_unbroadcast.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -92,6 +92,12 @@ def test_broadcast(self):\n         self.disconnect_nodes(0, 1)\n         node.disconnect_p2ps()\n \n+        self.log.info(\"Rebroadcast transaction and ensure it is not added to unbroadcast set when already in mempool\")\n+        rpc_tx_hsh = node.sendrawtransaction(txFS[\"hex\"])\n+        mempool = node.getrawmempool(True)\n+        assert rpc_tx_hsh in mempool\n+        assert not mempool[rpc_tx_hsh]['unbroadcast']\n+\n     def test_txn_removal(self):\n         self.log.info(\"Test that transactions removed from mempool are removed from unbroadcast set\")\n         node = self.nodes[0]"
      },
      {
        "sha": "01fc02f27e92288e1a34e640ba248e77bf3234dd",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -13,13 +13,15 @@\n \n from test_framework.blocktools import (\n     create_coinbase,\n+    get_witness_script,\n     NORMAL_GBT_REQUEST_PARAMS,\n     TIME_GENESIS_BLOCK,\n )\n from test_framework.messages import (\n     CBlock,\n     CBlockHeader,\n     BLOCK_HEADER_SIZE,\n+    ser_uint256,\n )\n from test_framework.p2p import P2PDataStore\n from test_framework.test_framework import BitcoinTestFramework\n@@ -49,6 +51,9 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n         self.supports_cli = False\n \n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n     def mine_chain(self):\n         self.log.info('Create some old blocks')\n         for t in range(TIME_GENESIS_BLOCK, TIME_GENESIS_BLOCK + 200 * 600, 600):\n@@ -89,7 +94,21 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert_equal(mining_info['networkhashps'], Decimal('0.003333333333333334'))\n         assert_equal(mining_info['pooledtx'], 0)\n \n-        # Mine a block to leave initial block download\n+        self.log.info(\"getblocktemplate: Test default witness commitment\")\n+        txid = int(node.sendtoaddress(node.getnewaddress(), 1), 16)\n+        tmpl = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n+\n+        # Check that default_witness_commitment is present.\n+        assert 'default_witness_commitment' in tmpl\n+        witness_commitment = tmpl['default_witness_commitment']\n+\n+        # Check that default_witness_commitment is correct.\n+        witness_root = CBlock.get_merkle_root([ser_uint256(0),\n+                                               ser_uint256(txid)])\n+        script = get_witness_script(witness_root, 0)\n+        assert_equal(witness_commitment, script.hex())\n+\n+        # Mine a block to leave initial block download and clear the mempool\n         node.generatetoaddress(1, node.get_deterministic_priv_key().address)\n         tmpl = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n         self.log.info(\"getblocktemplate: Test capability advertised\")"
      },
      {
        "sha": "9fc38ebf535e65d033bfe4c754a730415a819954",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -6,7 +6,7 @@\n \n import time\n \n-from test_framework.messages import COIN, MAX_BLOCK_BASE_SIZE\n+from test_framework.messages import COIN, MAX_BLOCK_WEIGHT\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error, create_confirmed_utxos, create_lots_of_big_transactions, gen_return_txouts\n \n@@ -61,15 +61,15 @@ def run_test(self):\n             txids[i] = create_lots_of_big_transactions(self.nodes[0], self.txouts, utxos[start_range:end_range], end_range - start_range, (i+1)*base_fee)\n \n         # Make sure that the size of each group of transactions exceeds\n-        # MAX_BLOCK_BASE_SIZE -- otherwise the test needs to be revised to create\n-        # more transactions.\n+        # MAX_BLOCK_WEIGHT // 4 -- otherwise the test needs to be revised to\n+        # create more transactions.\n         mempool = self.nodes[0].getrawmempool(True)\n         sizes = [0, 0, 0]\n         for i in range(3):\n             for j in txids[i]:\n                 assert j in mempool\n                 sizes[i] += mempool[j]['vsize']\n-            assert sizes[i] > MAX_BLOCK_BASE_SIZE  # Fail => raise utxo_count\n+            assert sizes[i] > MAX_BLOCK_WEIGHT // 4  # Fail => raise utxo_count\n \n         # add a fee delta to something in the cheapest bucket and make sure it gets mined\n         # also check that a different entry in the cheapest bucket is NOT mined"
      },
      {
        "sha": "113e1f9492d8ffff41ba7f481ad6b735344ec026",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 170,
        "deletions": 9,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -11,23 +11,29 @@\n     NODE_NETWORK,\n     NODE_WITNESS,\n     msg_addr,\n-    msg_getaddr\n+    msg_getaddr,\n+    msg_verack\n )\n-from test_framework.p2p import P2PInterface\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n )\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, assert_greater_than\n+import random\n import time\n \n \n class AddrReceiver(P2PInterface):\n     num_ipv4_received = 0\n     test_addr_contents = False\n+    _tokens = 1\n+    send_getaddr = True\n \n-    def __init__(self, test_addr_contents=False):\n+    def __init__(self, test_addr_contents=False, send_getaddr=True):\n         super().__init__()\n         self.test_addr_contents = test_addr_contents\n+        self.send_getaddr = send_getaddr\n \n     def on_addr(self, message):\n         for addr in message.addrs:\n@@ -40,9 +46,28 @@ def on_addr(self, message):\n                     raise AssertionError(\"Invalid addr.port of {} (8333-8342 expected)\".format(addr.port))\n                 assert addr.ip.startswith('123.123.123.')\n \n+    def on_getaddr(self, message):\n+        # When the node sends us a getaddr, it increments the addr relay tokens for the connection by 1000\n+        self._tokens += 1000\n+\n+    @property\n+    def tokens(self):\n+        with p2p_lock:\n+            return self._tokens\n+\n+    def increment_tokens(self, n):\n+        # When we move mocktime forward, the node increments the addr relay tokens for its peers\n+        with p2p_lock:\n+            self._tokens += n\n+\n     def addr_received(self):\n         return self.num_ipv4_received != 0\n \n+    def on_version(self, message):\n+        self.send_message(msg_verack())\n+        if (self.send_getaddr):\n+            self.send_message(msg_getaddr())\n+\n     def getaddr_received(self):\n         return self.message_count['getaddr'] > 0\n \n@@ -53,12 +78,18 @@ class AddrTest(BitcoinTestFramework):\n \n     def set_test_params(self):\n         self.num_nodes = 1\n+        self.extra_args = [[\"-whitelist=addr@127.0.0.1\"]]\n \n     def run_test(self):\n         self.oversized_addr_test()\n         self.relay_tests()\n+        self.inbound_blackhole_tests()\n+\n+        # This test populates the addrman, which can impact the node's behavior\n+        # in subsequent tests\n         self.getaddr_tests()\n         self.blocksonly_mode_tests()\n+        self.rate_limit_tests()\n \n     def setup_addr_msg(self, num):\n         addrs = []\n@@ -75,6 +106,19 @@ def setup_addr_msg(self, num):\n         msg.addrs = addrs\n         return msg\n \n+    def setup_rand_addr_msg(self, num):\n+        addrs = []\n+        for i in range(num):\n+            addr = CAddress()\n+            addr.time = self.mocktime + i\n+            addr.nServices = NODE_NETWORK | NODE_WITNESS\n+            addr.ip = f\"{random.randrange(128,169)}.{random.randrange(1,255)}.{random.randrange(1,255)}.{random.randrange(1,255)}\"\n+            addr.port = 8333\n+            addrs.append(addr)\n+        msg = msg_addr()\n+        msg.addrs = addrs\n+        return msg\n+\n     def send_addr_msg(self, source, msg, receivers):\n         source.send_and_ping(msg)\n         # pop m_next_addr_send timer\n@@ -124,7 +168,7 @@ def relay_tests(self):\n         self.nodes[0].disconnect_p2ps()\n \n         self.log.info('Check relay of addresses received from outbound peers')\n-        inbound_peer = self.nodes[0].add_p2p_connection(AddrReceiver(test_addr_contents=True))\n+        inbound_peer = self.nodes[0].add_p2p_connection(AddrReceiver(test_addr_contents=True, send_getaddr=False))\n         full_outbound_peer = self.nodes[0].add_outbound_p2p_connection(AddrReceiver(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n         msg = self.setup_addr_msg(2)\n         self.send_addr_msg(full_outbound_peer, msg, [inbound_peer])\n@@ -135,6 +179,9 @@ def relay_tests(self):\n         # of the outbound peer which is often sent before the GETADDR response.\n         assert_equal(inbound_peer.num_ipv4_received, 0)\n \n+        # Send an empty ADDR message to initialize address relay on this connection.\n+        inbound_peer.send_and_ping(msg_addr())\n+\n         self.log.info('Check that subsequent addr messages sent from an outbound peer are relayed')\n         msg2 = self.setup_addr_msg(2)\n         self.send_addr_msg(full_outbound_peer, msg2, [inbound_peer])\n@@ -152,7 +199,64 @@ def relay_tests(self):\n \n         self.nodes[0].disconnect_p2ps()\n \n+    def sum_addr_messages(self, msgs_dict):\n+        return sum(bytes_received for (msg, bytes_received) in msgs_dict.items() if msg in ['addr', 'addrv2', 'getaddr'])\n+\n+    def inbound_blackhole_tests(self):\n+        self.log.info('Check that we only relay addresses to inbound peers who have previously sent us addr related messages')\n+\n+        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n+        receiver_peer = self.nodes[0].add_p2p_connection(AddrReceiver())\n+        blackhole_peer = self.nodes[0].add_p2p_connection(AddrReceiver(send_getaddr=False))\n+        initial_addrs_received = receiver_peer.num_ipv4_received\n+\n+        peerinfo = self.nodes[0].getpeerinfo()\n+        assert_equal(peerinfo[0]['addr_relay_enabled'], True)  # addr_source\n+        assert_equal(peerinfo[1]['addr_relay_enabled'], True)  # receiver_peer\n+        assert_equal(peerinfo[2]['addr_relay_enabled'], False)  # blackhole_peer\n+\n+        # addr_source sends 2 addresses to node0\n+        msg = self.setup_addr_msg(2)\n+        addr_source.send_and_ping(msg)\n+        self.mocktime += 30 * 60\n+        self.nodes[0].setmocktime(self.mocktime)\n+        receiver_peer.sync_with_ping()\n+        blackhole_peer.sync_with_ping()\n+\n+        peerinfo = self.nodes[0].getpeerinfo()\n+\n+        # Confirm node received addr-related messages from receiver peer\n+        assert_greater_than(self.sum_addr_messages(peerinfo[1]['bytesrecv_per_msg']), 0)\n+        # And that peer received addresses\n+        assert_equal(receiver_peer.num_ipv4_received - initial_addrs_received, 2)\n+\n+        # Confirm node has not received addr-related messages from blackhole peer\n+        assert_equal(self.sum_addr_messages(peerinfo[2]['bytesrecv_per_msg']), 0)\n+        # And that peer did not receive addresses\n+        assert_equal(blackhole_peer.num_ipv4_received, 0)\n+\n+        self.log.info(\"After blackhole peer sends addr message, it becomes eligible for addr gossip\")\n+        blackhole_peer.send_and_ping(msg_addr())\n+\n+        # Confirm node has now received addr-related messages from blackhole peer\n+        assert_greater_than(self.sum_addr_messages(peerinfo[1]['bytesrecv_per_msg']), 0)\n+        assert_equal(self.nodes[0].getpeerinfo()[2]['addr_relay_enabled'], True)\n+\n+        msg = self.setup_addr_msg(2)\n+        self.send_addr_msg(addr_source, msg, [receiver_peer, blackhole_peer])\n+\n+        # And that peer received addresses\n+        assert_equal(blackhole_peer.num_ipv4_received, 2)\n+\n+        self.nodes[0].disconnect_p2ps()\n+\n     def getaddr_tests(self):\n+        # In the previous tests, the node answered GETADDR requests with an\n+        # empty addrman. Due to GETADDR response caching (see\n+        # CConnman::GetAddresses), the node would continue to provide 0 addrs\n+        # in response until enough time has passed or the node is restarted.\n+        self.restart_node(0)\n+\n         self.log.info('Test getaddr behavior')\n         self.log.info('Check that we send a getaddr message upon connecting to an outbound-full-relay peer')\n         full_outbound_peer = self.nodes[0].add_outbound_p2p_connection(AddrReceiver(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n@@ -165,7 +269,7 @@ def getaddr_tests(self):\n         assert_equal(block_relay_peer.getaddr_received(), False)\n \n         self.log.info('Check that we answer getaddr messages only from inbound peers')\n-        inbound_peer = self.nodes[0].add_p2p_connection(AddrReceiver())\n+        inbound_peer = self.nodes[0].add_p2p_connection(AddrReceiver(send_getaddr=False))\n         inbound_peer.sync_with_ping()\n \n         # Add some addresses to addrman\n@@ -191,7 +295,7 @@ def getaddr_tests(self):\n \n     def blocksonly_mode_tests(self):\n         self.log.info('Test addr relay in -blocksonly mode')\n-        self.restart_node(0, [\"-blocksonly\"])\n+        self.restart_node(0, [\"-blocksonly\", \"-whitelist=addr@127.0.0.1\"])\n         self.mocktime = int(time.time())\n \n         self.log.info('Check that we send getaddr messages')\n@@ -207,6 +311,63 @@ def blocksonly_mode_tests(self):\n \n         self.nodes[0].disconnect_p2ps()\n \n+    def send_addrs_and_test_rate_limiting(self, peer, no_relay, new_addrs, total_addrs):\n+        \"\"\"Send an addr message and check that the number of addresses processed and rate-limited is as expected\"\"\"\n+\n+        peer.send_and_ping(self.setup_rand_addr_msg(new_addrs))\n+\n+        peerinfo = self.nodes[0].getpeerinfo()[0]\n+        addrs_processed = peerinfo['addr_processed']\n+        addrs_rate_limited = peerinfo['addr_rate_limited']\n+        self.log.debug(f\"addrs_processed = {addrs_processed}, addrs_rate_limited = {addrs_rate_limited}\")\n+\n+        if no_relay:\n+            assert_equal(addrs_processed, 0)\n+            assert_equal(addrs_rate_limited, 0)\n+        else:\n+            assert_equal(addrs_processed, min(total_addrs, peer.tokens))\n+            assert_equal(addrs_rate_limited, max(0, total_addrs - peer.tokens))\n+\n+    def rate_limit_tests(self):\n+\n+        self.mocktime = int(time.time())\n+        self.restart_node(0, [])\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        for contype, no_relay in [(\"outbound-full-relay\", False), (\"block-relay-only\", True), (\"inbound\", False)]:\n+            self.log.info(f'Test rate limiting of addr processing for {contype} peers')\n+            if contype == \"inbound\":\n+                peer = self.nodes[0].add_p2p_connection(AddrReceiver())\n+            else:\n+                peer = self.nodes[0].add_outbound_p2p_connection(AddrReceiver(), p2p_idx=0, connection_type=contype)\n+\n+            # Send 600 addresses. For all but the block-relay-only peer this should result in addresses being processed.\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 600, 600)\n+\n+            # Send 600 more addresses. For the outbound-full-relay peer (which we send a GETADDR, and thus will\n+            # process up to 1001 incoming addresses), this means more addresses will be processed.\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 600, 1200)\n+\n+            # Send 10 more. As we reached the processing limit for all nodes, no more addresses should be procesesd.\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 10, 1210)\n+\n+            # Advance the time by 100 seconds, permitting the processing of 10 more addresses.\n+            # Send 200 and verify that 10 are processed.\n+            self.mocktime += 100\n+            self.nodes[0].setmocktime(self.mocktime)\n+            peer.increment_tokens(10)\n+\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 200, 1410)\n+\n+            # Advance the time by 1000 seconds, permitting the processing of 100 more addresses.\n+            # Send 200 and verify that 100 are processed.\n+            self.mocktime += 1000\n+            self.nodes[0].setmocktime(self.mocktime)\n+            peer.increment_tokens(100)\n+\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 200, 1610)\n+\n+            self.nodes[0].disconnect_p2ps()\n \n if __name__ == '__main__':\n     AddrTest().main()"
      },
      {
        "sha": "66ee1544a91d96325c7c16ced62add1a06bcb037",
        "filename": "test/functional/p2p_addrfetch.py",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_addrfetch.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_addrfetch.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addrfetch.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,62 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test p2p addr-fetch connections\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import msg_addr, CAddress, NODE_NETWORK, NODE_WITNESS\n+from test_framework.p2p import P2PInterface, p2p_lock\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+ADDR = CAddress()\n+ADDR.time = int(time.time())\n+ADDR.nServices = NODE_NETWORK | NODE_WITNESS\n+ADDR.ip = \"192.0.0.8\"\n+ADDR.port = 18444\n+\n+\n+class P2PAddrFetch(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Connect to an addr-fetch peer\")\n+        peer = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"addr-fetch\")\n+        info = node.getpeerinfo()\n+        assert_equal(len(info), 1)\n+        assert_equal(info[0]['connection_type'], 'addr-fetch')\n+\n+        self.log.info(\"Check that we send getaddr but don't try to sync headers with the addr-fetch peer\")\n+        peer.sync_send_with_ping()\n+        with p2p_lock:\n+            assert peer.message_count['getaddr'] == 1\n+            assert peer.message_count['getheaders'] == 0\n+\n+        self.log.info(\"Check that answering the getaddr with a single address does not lead to disconnect\")\n+        # This prevents disconnecting on self-announcements\n+        msg = msg_addr()\n+        msg.addrs = [ADDR]\n+        peer.send_and_ping(msg)\n+        assert_equal(len(node.getpeerinfo()), 1)\n+\n+        self.log.info(\"Check that answering with larger addr messages leads to disconnect\")\n+        msg.addrs = [ADDR] * 2\n+        peer.send_message(msg)\n+        peer.wait_for_disconnect(timeout=5)\n+\n+        self.log.info(\"Check timeout for addr-fetch peer that does not send addrs\")\n+        peer = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"addr-fetch\")\n+        node.setmocktime(int(time.time()) + 301)  # Timeout: 5 minutes\n+        peer.wait_for_disconnect(timeout=5)\n+\n+\n+if __name__ == '__main__':\n+    P2PAddrFetch().main()"
      },
      {
        "sha": "32c1d42b1cf80f5fbb0367b79ca1879d23d31c9c",
        "filename": "test/functional/p2p_addrv2_relay.py",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_addrv2_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_addrv2_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addrv2_relay.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -42,7 +42,9 @@ def __init__(self):\n         super().__init__(support_addrv2 = True)\n \n     def on_addrv2(self, message):\n-        if ADDRS == message.addrs:\n+        expected_set = set((addr.ip, addr.port) for addr in ADDRS)\n+        received_set = set((addr.ip, addr.port) for addr in message.addrs)\n+        if expected_set == received_set:\n             self.addrv2_received_and_checked = True\n \n     def wait_for_addrv2(self):\n@@ -53,6 +55,7 @@ class AddrTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n+        self.extra_args = [[\"-whitelist=addr@127.0.0.1\"]]\n \n     def run_test(self):\n         self.log.info('Create connection that sends addrv2 messages')"
      },
      {
        "sha": "e58ad8e0fc8115dc0bfba43900aad09ed6ab2c77",
        "filename": "test/functional/p2p_dns_seeds.py",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_dns_seeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_dns_seeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_dns_seeds.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -0,0 +1,129 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test ThreadDNSAddressSeed logic for querying DNS seeds.\"\"\"\n+\n+import itertools\n+\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+\n+class P2PDNSSeeds(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-dnsseed=1\"]]\n+\n+    def run_test(self):\n+        self.init_arg_tests()\n+        self.existing_outbound_connections_test()\n+        self.existing_block_relay_connections_test()\n+        self.force_dns_test()\n+        self.wait_time_tests()\n+\n+    def init_arg_tests(self):\n+        fakeaddr = \"fakenodeaddr.fakedomain.invalid.\"\n+\n+        self.log.info(\"Check that setting -connect disables -dnsseed by default\")\n+        self.nodes[0].stop_node()\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"DNS seeding disabled\"]):\n+            self.start_node(0, [f\"-connect={fakeaddr}\"])\n+\n+        self.log.info(\"Check that running -connect and -dnsseed means DNS logic runs.\")\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"Loading addresses from DNS seed\"], timeout=12):\n+            self.restart_node(0, [f\"-connect={fakeaddr}\", \"-dnsseed=1\"])\n+\n+        self.log.info(\"Check that running -forcednsseed and -dnsseed=0 throws an error.\")\n+        self.nodes[0].stop_node()\n+        self.nodes[0].assert_start_raises_init_error(\n+            expected_msg=\"Error: Cannot set -forcednsseed to true when setting -dnsseed to false.\",\n+            extra_args=[\"-forcednsseed=1\", \"-dnsseed=0\"],\n+        )\n+\n+        self.log.info(\"Check that running -forcednsseed and -connect throws an error.\")\n+        # -connect soft sets -dnsseed to false, so throws the same error\n+        self.nodes[0].stop_node()\n+        self.nodes[0].assert_start_raises_init_error(\n+            expected_msg=\"Error: Cannot set -forcednsseed to true when setting -dnsseed to false.\",\n+            extra_args=[\"-forcednsseed=1\", f\"-connect={fakeaddr}\"],\n+        )\n+\n+        # Restore default bitcoind settings\n+        self.restart_node(0)\n+\n+    def existing_outbound_connections_test(self):\n+        # Make sure addrman is populated to enter the conditional where we\n+        # delay and potentially skip DNS seeding.\n+        self.nodes[0].addpeeraddress(\"192.0.0.8\", 8333)\n+\n+        self.log.info(\"Check that we *do not* query DNS seeds if we have 2 outbound connections\")\n+\n+        self.restart_node(0)\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"P2P peers available. Skipped DNS seeding.\"], timeout=12):\n+            for i in range(2):\n+                self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\")\n+\n+    def existing_block_relay_connections_test(self):\n+        # Make sure addrman is populated to enter the conditional where we\n+        # delay and potentially skip DNS seeding. No-op when run after\n+        # existing_outbound_connections_test.\n+        self.nodes[0].addpeeraddress(\"192.0.0.8\", 8333)\n+\n+        self.log.info(\"Check that we *do* query DNS seeds if we only have 2 block-relay-only connections\")\n+\n+        self.restart_node(0)\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"Loading addresses from DNS seed\"], timeout=12):\n+            # This mimics the \"anchors\" logic where nodes are likely to\n+            # reconnect to block-relay-only connections on startup.\n+            # Since we do not participate in addr relay with these connections,\n+            # we still want to query the DNS seeds.\n+            for i in range(2):\n+                self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"block-relay-only\")\n+\n+    def force_dns_test(self):\n+        self.log.info(\"Check that we query DNS seeds if -forcednsseed param is set\")\n+\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"Loading addresses from DNS seed\"], timeout=12):\n+            # -dnsseed defaults to 1 in bitcoind, but 0 in the test framework,\n+            # so pass it explicitly here\n+            self.restart_node(0, [\"-forcednsseed\", \"-dnsseed=1\"])\n+\n+        # Restore default for subsequent tests\n+        self.restart_node(0)\n+\n+    def wait_time_tests(self):\n+        self.log.info(\"Check the delay before querying DNS seeds\")\n+\n+        # Populate addrman with < 1000 addresses\n+        for i in range(5):\n+            a = f\"192.0.0.{i}\"\n+            self.nodes[0].addpeeraddress(a, 8333)\n+\n+        # The delay should be 11 seconds\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"Waiting 11 seconds before querying DNS seeds.\\n\"]):\n+            self.restart_node(0)\n+\n+        # Populate addrman with > 1000 addresses\n+        for i in itertools.count():\n+            first_octet = i % 2 + 1\n+            second_octet = i % 256\n+            third_octet = i % 100\n+            a = f\"{first_octet}.{second_octet}.{third_octet}.1\"\n+            self.nodes[0].addpeeraddress(a, 8333)\n+            if (i > 1000 and i % 100 == 0):\n+                # The addrman size is non-deterministic because new addresses\n+                # are sorted into buckets, potentially displacing existing\n+                # addresses. Periodically check if we have met the desired\n+                # threshold.\n+                if len(self.nodes[0].getnodeaddresses(0)) > 1000:\n+                    break\n+\n+        # The delay should be 5 mins\n+        with self.nodes[0].assert_debug_log(expected_msgs=[\"Waiting 300 seconds before querying DNS seeds.\\n\"]):\n+            self.restart_node(0)\n+\n+\n+if __name__ == '__main__':\n+    P2PDNSSeeds().main()"
      },
      {
        "sha": "f3b80abb59fd934ced4631cbe4e2d7eac890c40a",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -28,7 +28,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    hex_str_to_bytes,\n )\n \n VALID_DATA_LIMIT = MAX_PROTOCOL_MESSAGE_LENGTH - 5  # Account for the 5-byte length prefix\n@@ -58,6 +57,7 @@ class InvalidMessagesTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=addr@127.0.0.1\"]]\n \n     def run_test(self):\n         self.test_buffer()\n@@ -186,7 +186,7 @@ def test_addrv2_no_addresses(self):\n             [\n                 'received: addrv2 (1 bytes)',\n             ],\n-            hex_str_to_bytes('00'))\n+            bytes.fromhex('00'))\n \n     def test_addrv2_too_long_address(self):\n         self.test_addrv2('too long address',\n@@ -195,7 +195,7 @@ def test_addrv2_too_long_address(self):\n                 'ProcessMessages(addrv2, 525 bytes): Exception',\n                 'Address too long: 513 > 512',\n             ],\n-            hex_str_to_bytes(\n+            bytes.fromhex(\n                 '01' +       # number of entries\n                 '61bc6649' + # time, Fri Jan  9 02:54:25 UTC 2009\n                 '00' +       # service flags, COMPACTSIZE(NODE_NONE)\n@@ -212,7 +212,7 @@ def test_addrv2_unrecognized_network(self):\n                 'IP 9.9.9.9 mapped',\n                 'Added 1 addresses',\n             ],\n-            hex_str_to_bytes(\n+            bytes.fromhex(\n                 '02' +     # number of entries\n                 # this should be ignored without impeding acceptance of subsequent ones\n                 now_hex +  # time"
      },
      {
        "sha": "8b285907c5a47656d1560138ac43527ccf0e022b",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -130,7 +130,7 @@ def check_tx_relay(self):\n         tx.vout[0].nValue += 1\n         txid = tx.rehash()\n         # Send the transaction twice. The first time, it'll be rejected by ATMP because it conflicts\n-        # with a mempool transaction. The second time, it'll be in the recentRejects filter.\n+        # with a mempool transaction. The second time, it'll be in the m_recent_rejects filter.\n         p2p_rebroadcast_wallet.send_txs_and_test(\n             [tx],\n             self.nodes[1],"
      },
      {
        "sha": "e5093855ff1edf91c305efa81414fafee0160f02",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 105,
        "deletions": 197,
        "changes": 302,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,16 +4,14 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test segwit transactions and blocks on P2P network.\"\"\"\n from decimal import Decimal\n-import math\n import random\n import struct\n import time\n \n-from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, get_witness_script, WITNESS_COMMITMENT_HEADER\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n from test_framework.key import ECKey\n from test_framework.messages import (\n     BIP125_SEQUENCE_NUMBER,\n-    CBlock,\n     CBlockHeader,\n     CInv,\n     COutPoint,\n@@ -22,7 +20,7 @@\n     CTxInWitness,\n     CTxOut,\n     CTxWitness,\n-    MAX_BLOCK_BASE_SIZE,\n+    MAX_BLOCK_WEIGHT,\n     MSG_BLOCK,\n     MSG_TX,\n     MSG_WITNESS_FLAG,\n@@ -82,7 +80,6 @@\n from test_framework.util import (\n     assert_equal,\n     softfork_active,\n-    hex_str_to_bytes,\n     assert_raises_rpc_error,\n )\n \n@@ -102,22 +99,12 @@ def __init__(self, sha256, n, value):\n         self.nValue = value\n \n def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n-    \"\"\"Add signature for a P2PK witness program.\"\"\"\n+    \"\"\"Add signature for a P2PK witness script.\"\"\"\n     tx_hash = SegwitV0SignatureHash(script, tx_to, in_idx, hashtype, value)\n     signature = key.sign_ecdsa(tx_hash) + chr(hashtype).encode('latin-1')\n     tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n     tx_to.rehash()\n \n-def get_virtual_size(witness_block):\n-    \"\"\"Calculate the virtual size of a witness block.\n-\n-    Virtual size is base + witness/4.\"\"\"\n-    base_size = len(witness_block.serialize(with_witness=False))\n-    total_size = len(witness_block.serialize())\n-    # the \"+3\" is so we round up\n-    vsize = int((3 * base_size + total_size + 3) / 4)\n-    return vsize\n-\n def test_transaction_acceptance(node, p2p, tx, with_witness, accepted, reason=None):\n     \"\"\"Send a transaction to the node and check that it's accepted to the mempool\n \n@@ -206,24 +193,17 @@ def request_block(self, blockhash, inv_type, timeout=60):\n class SegWitTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 3\n+        self.num_nodes = 2\n         # This test tests SegWit both pre and post-activation, so use the normal BIP9 activation.\n         self.extra_args = [\n             [\"-acceptnonstdtxn=1\", \"-segwitheight={}\".format(SEGWIT_HEIGHT), \"-whitelist=noban@127.0.0.1\"],\n             [\"-acceptnonstdtxn=0\", \"-segwitheight={}\".format(SEGWIT_HEIGHT)],\n-            [\"-acceptnonstdtxn=1\", \"-segwitheight=-1\"],\n         ]\n         self.supports_cli = False\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n-    def setup_network(self):\n-        self.setup_nodes()\n-        self.connect_nodes(0, 1)\n-        self.connect_nodes(0, 2)\n-        self.sync_all()\n-\n     # Helper functions\n \n     def build_next_block(self, version=4):\n@@ -264,7 +244,6 @@ def run_test(self):\n         self.test_non_witness_transaction()\n         self.test_v0_outputs_arent_spendable()\n         self.test_block_relay()\n-        self.test_getblocktemplate_before_lockin()\n         self.test_unnecessary_witness_before_segwit_activation()\n         self.test_witness_tx_relay_before_segwit_activation()\n         self.test_standardness_v0()\n@@ -281,7 +260,7 @@ def run_test(self):\n         self.test_submit_block()\n         self.test_extra_witness_data()\n         self.test_max_witness_push_length()\n-        self.test_max_witness_program_length()\n+        self.test_max_witness_script_length()\n         self.test_witness_input_length()\n         self.test_block_relay()\n         self.test_tx_relay_after_segwit_activation()\n@@ -292,7 +271,6 @@ def run_test(self):\n         self.test_signature_version_1()\n         self.test_non_standard_witness_blinding()\n         self.test_non_standard_witness()\n-        self.test_upgrade_after_activation()\n         self.test_witness_sigops()\n         self.test_superfluous_witness()\n         self.test_wtxid_relay()\n@@ -425,7 +403,7 @@ def test_block_relay(self):\n                 block = self.test_node.request_block(block_hash, 2)\n                 wit_block = self.test_node.request_block(block_hash, 2 | MSG_WITNESS_FLAG)\n                 assert_equal(block.serialize(), wit_block.serialize())\n-                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n+                assert_equal(block.serialize(), bytes.fromhex(rpc_block))\n         else:\n             # After activation, witness blocks and non-witness blocks should\n             # be different.  Verify rpc getblock() returns witness blocks, while\n@@ -440,16 +418,15 @@ def test_block_relay(self):\n             rpc_block = self.nodes[0].getblock(block.hash, False)\n             non_wit_block = self.test_node.request_block(block.sha256, 2)\n             wit_block = self.test_node.request_block(block.sha256, 2 | MSG_WITNESS_FLAG)\n-            assert_equal(wit_block.serialize(), hex_str_to_bytes(rpc_block))\n+            assert_equal(wit_block.serialize(), bytes.fromhex(rpc_block))\n             assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n             assert_equal(wit_block.serialize(), block.serialize())\n \n             # Test size, vsize, weight\n             rpc_details = self.nodes[0].getblock(block.hash, True)\n             assert_equal(rpc_details[\"size\"], len(block.serialize()))\n             assert_equal(rpc_details[\"strippedsize\"], len(block.serialize(False)))\n-            weight = 3 * len(block.serialize(False)) + len(block.serialize())\n-            assert_equal(rpc_details[\"weight\"], weight)\n+            assert_equal(rpc_details[\"weight\"], block.get_weight())\n \n             # Upgraded node should not ask for blocks from unupgraded\n             block4 = self.build_next_block(version=4)\n@@ -482,14 +459,9 @@ def test_v0_outputs_arent_spendable(self):\n         witness, and so can't be spent before segwit activation (the point at which\n         blocks are permitted to contain witnesses).\"\"\"\n \n-        # node2 doesn't need to be connected for this test.\n-        # (If it's connected, node0 may propagate an invalid block to it over\n-        # compact blocks and the nodes would have inconsistent tips.)\n-        self.disconnect_nodes(0, 2)\n-\n         # Create two outputs, a p2wsh and p2sh-p2wsh\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         p2sh_script_pubkey = script_to_p2sh_script(script_pubkey)\n \n         value = self.utxo[0].nValue // 3\n@@ -544,37 +516,9 @@ def test_v0_outputs_arent_spendable(self):\n             # TODO: support multiple acceptable reject reasons.\n             test_witness_block(self.nodes[0], self.test_node, block, accepted=False, with_witness=False)\n \n-        self.connect_nodes(0, 2)\n-\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(txid, 2, value))\n \n-    @subtest  # type: ignore\n-    def test_getblocktemplate_before_lockin(self):\n-        txid = int(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1), 16)\n-\n-        for node in [self.nodes[0], self.nodes[2]]:\n-            gbt_results = node.getblocktemplate({\"rules\": [\"segwit\"]})\n-            if node == self.nodes[2]:\n-                # If this is a non-segwit node, we should not get a witness\n-                # commitment.\n-                assert 'default_witness_commitment' not in gbt_results\n-            else:\n-                # For segwit-aware nodes, check the witness\n-                # commitment is correct.\n-                assert 'default_witness_commitment' in gbt_results\n-                witness_commitment = gbt_results['default_witness_commitment']\n-\n-                # Check that default_witness_commitment is present.\n-                witness_root = CBlock.get_merkle_root([ser_uint256(0),\n-                                                       ser_uint256(txid)])\n-                script = get_witness_script(witness_root, 0)\n-                assert_equal(witness_commitment, script.hex())\n-\n-        # Clear out the mempool\n-        self.nodes[0].generate(1)\n-        self.sync_blocks()\n-\n     @subtest  # type: ignore\n     def test_witness_tx_relay_before_segwit_activation(self):\n \n@@ -624,9 +568,9 @@ def test_standardness_v0(self):\n         V0 segwit outputs and inputs are always standard.\n         V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n \n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n-        p2sh_script_pubkey = script_to_p2sh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n+        p2sh_script_pubkey = script_to_p2sh_script(witness_script)\n \n         # First prepare a p2sh output (so that spending it will pass standardness)\n         p2sh_tx = CTransaction()\n@@ -642,7 +586,7 @@ def test_standardness_v0(self):\n         # Now test standardness of v0 P2WSH outputs.\n         # Start by creating a transaction with two outputs.\n         tx = CTransaction()\n-        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n+        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_script]))]\n         tx.vout = [CTxOut(p2sh_tx.vout[0].nValue - 10000, script_pubkey)]\n         tx.vout.append(CTxOut(8000, script_pubkey))  # Might burn this later\n         tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER  # Just to have the option to bump this tx from the mempool\n@@ -653,14 +597,14 @@ def test_standardness_v0(self):\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx, with_witness=True, accepted=True)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n-        witness_hash = sha256(witness_program)\n+        witness_hash = sha256(witness_script)\n         script_pubkey = CScript([OP_0, hash160(witness_hash)])\n         tx2 = CTransaction()\n         # tx was accepted, so we spend the second output.\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n         tx2.vout = [CTxOut(7000, script_pubkey)]\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n \n         test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=True)\n@@ -673,7 +617,7 @@ def test_standardness_v0(self):\n         tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n         tx3.vout = [CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n         tx3.wit.vtxinwit.append(CTxInWitness())\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx3.rehash()\n         if not self.segwit_active:\n             # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n@@ -731,8 +675,8 @@ def test_p2sh_witness(self):\n         \"\"\"Test P2SH wrapped witness programs.\"\"\"\n \n         # Prepare the p2sh-wrapped witness output\n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        p2wsh_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        p2wsh_pubkey = script_to_p2wsh_script(witness_script)\n         script_pubkey = script_to_p2sh_script(p2wsh_pubkey)\n         script_sig = CScript([p2wsh_pubkey])  # a push of the redeem script\n \n@@ -776,7 +720,7 @@ def test_p2sh_witness(self):\n         spend_tx.vin[0].scriptSig = script_sig\n         spend_tx.rehash()\n         spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_script]\n \n         # Verify mempool acceptance\n         test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=True, accepted=True)\n@@ -825,18 +769,18 @@ def test_witness_commitments(self):\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n \n-        # Let's construct a witness program\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        # Let's construct a witness script\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n         # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_program))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_script))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n \n         block_3 = self.build_next_block()\n@@ -871,7 +815,7 @@ def test_witness_commitments(self):\n         block_4 = self.build_next_block()\n         tx3 = CTransaction()\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n-        tx3.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_program))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_script))\n         tx3.rehash()\n         block_4.vtx.append(tx3)\n         block_4.hashMerkleRoot = block_4.calc_merkle_root()\n@@ -893,7 +837,7 @@ def test_block_malleability(self):\n         block.solve()\n \n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a' * 5000000)\n-        assert get_virtual_size(block) > MAX_BLOCK_BASE_SIZE\n+        assert block.get_weight() > MAX_BLOCK_WEIGHT\n \n         # We can't send over the p2p network, because this is too big to relay\n         # TODO: repeat this test with a block that can be relayed\n@@ -902,7 +846,7 @@ def test_block_malleability(self):\n         assert self.nodes[0].getbestblockhash() != block.hash\n \n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n-        assert get_virtual_size(block) < MAX_BLOCK_BASE_SIZE\n+        assert block.get_weight() < MAX_BLOCK_WEIGHT\n         assert_equal(None, self.nodes[0].submitblock(block.serialize().hex()))\n \n         assert self.nodes[0].getbestblockhash() == block.hash\n@@ -933,14 +877,14 @@ def test_witness_block_size(self):\n         assert len(self.utxo) > 0\n \n         # Create a P2WSH transaction.\n-        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # The witness script will be a bunch of OP_2DROP's, followed by OP_TRUE.\n         # This should give us plenty of room to tweak the spending tx's\n         # virtual size.\n         NUM_DROPS = 200  # 201 max ops per script!\n         NUM_OUTPUTS = 50\n \n-        witness_program = CScript([OP_2DROP] * NUM_DROPS + [OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_2DROP] * NUM_DROPS + [OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n         value = self.utxo[0].nValue\n@@ -960,15 +904,14 @@ def test_witness_block_size(self):\n         child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n         for _ in range(NUM_OUTPUTS):\n             child_tx.wit.vtxinwit.append(CTxInWitness())\n-            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a' * 195] * (2 * NUM_DROPS) + [witness_program]\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a' * 195] * (2 * NUM_DROPS) + [witness_script]\n         child_tx.rehash()\n         self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n \n-        vsize = get_virtual_size(block)\n-        additional_bytes = (MAX_BLOCK_BASE_SIZE - vsize) * 4\n+        additional_bytes = MAX_BLOCK_WEIGHT - block.get_weight()\n         i = 0\n         while additional_bytes > 0:\n-            # Add some more bytes to each input until we hit MAX_BLOCK_BASE_SIZE+1\n+            # Add some more bytes to each input until we hit MAX_BLOCK_WEIGHT+1\n             extra_bytes = min(additional_bytes + 1, 55)\n             block.vtx[-1].wit.vtxinwit[int(i / (2 * NUM_DROPS))].scriptWitness.stack[i % (2 * NUM_DROPS)] = b'a' * (195 + extra_bytes)\n             additional_bytes -= extra_bytes\n@@ -977,8 +920,7 @@ def test_witness_block_size(self):\n         block.vtx[0].vout.pop()  # Remove old commitment\n         add_witness_commitment(block)\n         block.solve()\n-        vsize = get_virtual_size(block)\n-        assert_equal(vsize, MAX_BLOCK_BASE_SIZE + 1)\n+        assert_equal(block.get_weight(), MAX_BLOCK_WEIGHT + 1)\n         # Make sure that our test case would exceed the old max-network-message\n         # limit\n         assert len(block.serialize()) > 2 * 1024 * 1024\n@@ -991,7 +933,7 @@ def test_witness_block_size(self):\n         block.vtx[0].vout.pop()\n         add_witness_commitment(block)\n         block.solve()\n-        assert get_virtual_size(block) == MAX_BLOCK_BASE_SIZE\n+        assert block.get_weight() == MAX_BLOCK_WEIGHT\n \n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n \n@@ -1041,8 +983,8 @@ def test_extra_witness_data(self):\n \n         block = self.build_next_block()\n \n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         # First try extra witness data on a tx that doesn't require a witness\n         tx = CTransaction()\n@@ -1073,7 +1015,7 @@ def test_extra_witness_data(self):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\"))  # non-witness\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.extend([CTxInWitness(), CTxInWitness()])\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_script]\n         tx2.wit.vtxinwit[1].scriptWitness.stack = [CScript([OP_TRUE])]\n \n         block = self.build_next_block()\n@@ -1113,8 +1055,8 @@ def test_max_witness_push_length(self):\n \n         block = self.build_next_block()\n \n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n@@ -1126,7 +1068,7 @@ def test_max_witness_push_length(self):\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         # First try a 521-byte stack element\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * (MAX_SCRIPT_ELEMENT_SIZE + 1), witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * (MAX_SCRIPT_ELEMENT_SIZE + 1), witness_script]\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n@@ -1144,15 +1086,15 @@ def test_max_witness_push_length(self):\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n     @subtest  # type: ignore\n-    def test_max_witness_program_length(self):\n+    def test_max_witness_script_length(self):\n         \"\"\"Test that witness outputs greater than 10kB can't be spent.\"\"\"\n \n-        MAX_PROGRAM_LENGTH = 10000\n+        MAX_WITNESS_SCRIPT_LENGTH = 10000\n \n-        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n-        long_witness_program = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 63 + [OP_TRUE])\n-        assert len(long_witness_program) == MAX_PROGRAM_LENGTH + 1\n-        long_script_pubkey = script_to_p2wsh_script(long_witness_program)\n+        # This script is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_script = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 63 + [OP_TRUE])\n+        assert len(long_witness_script) == MAX_WITNESS_SCRIPT_LENGTH + 1\n+        long_script_pubkey = script_to_p2wsh_script(long_witness_script)\n \n         block = self.build_next_block()\n \n@@ -1165,22 +1107,22 @@ def test_max_witness_program_length(self):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 44 + [long_witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 44 + [long_witness_script]\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n \n         test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n-        # Try again with one less byte in the witness program\n-        witness_program = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n-        assert len(witness_program) == MAX_PROGRAM_LENGTH\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        # Try again with one less byte in the witness script\n+        witness_script = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n+        assert len(witness_script) == MAX_WITNESS_SCRIPT_LENGTH\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         tx.vout[0] = CTxOut(tx.vout[0].nValue, script_pubkey)\n         tx.rehash()\n         tx2.vin[0].prevout.hash = tx.sha256\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 43 + [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 43 + [witness_script]\n         tx2.rehash()\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n@@ -1193,8 +1135,8 @@ def test_max_witness_program_length(self):\n     def test_witness_input_length(self):\n         \"\"\"Test that vin length must match vtxinwit length.\"\"\"\n \n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         # Create a transaction that splits our utxo into many outputs\n         tx = CTransaction()\n@@ -1238,7 +1180,7 @@ def serialize_with_witness(self):\n         # First try using a too long vtxinwit\n         for i in range(11):\n             tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_script]\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n@@ -1254,15 +1196,15 @@ def serialize_with_witness(self):\n \n         # Now make one of the intermediate witnesses be incorrect\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n-        tx2.wit.vtxinwit[5].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_script]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [witness_script]\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Fix the broken witness and the block should be accepted.\n-        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_script]\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -1300,8 +1242,8 @@ def test_tx_relay_after_segwit_activation(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Now try to add extra witness data to a valid witness tx.\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n@@ -1312,10 +1254,10 @@ def test_tx_relay_after_segwit_activation(self):\n         tx3.wit.vtxinwit.append(CTxInWitness())\n \n         # Add too-large for IsStandard witness and check that it does not enter reject filter\n-        p2sh_program = CScript([OP_TRUE])\n-        witness_program2 = CScript([b'a' * 400000])\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_to_p2sh_script(p2sh_program)))\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program2]\n+        p2sh_script = CScript([OP_TRUE])\n+        witness_script2 = CScript([b'a' * 400000])\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_to_p2sh_script(p2sh_script)))\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_script2]\n         tx3.rehash()\n \n         # Node will not be blinded to the transaction, requesting it any number of times\n@@ -1329,14 +1271,14 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_script]\n         tx3.rehash()\n \n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n \n         # Get rid of the extra witness, and verify acceptance.\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n         self.old_node.wait_for_inv([CInv(MSG_TX, tx2.sha256)])  # wait until tx2 was inv'ed\n@@ -1348,12 +1290,11 @@ def test_tx_relay_after_segwit_activation(self):\n         raw_tx = self.nodes[0].getrawtransaction(tx3.hash, 1)\n         assert_equal(int(raw_tx[\"hash\"], 16), tx3.calc_sha256(True))\n         assert_equal(raw_tx[\"size\"], len(tx3.serialize_with_witness()))\n-        weight = len(tx3.serialize_with_witness()) + 3 * len(tx3.serialize_without_witness())\n-        vsize = math.ceil(weight / 4)\n+        vsize = tx3.get_vsize()\n         assert_equal(raw_tx[\"vsize\"], vsize)\n-        assert_equal(raw_tx[\"weight\"], weight)\n+        assert_equal(raw_tx[\"weight\"], tx3.get_weight())\n         assert_equal(len(raw_tx[\"vin\"][0][\"txinwitness\"]), 1)\n-        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], witness_program.hex())\n+        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], witness_script.hex())\n         assert vsize != raw_tx[\"size\"]\n \n         # Cleanup: mine the transactions and update utxo for next test\n@@ -1389,8 +1330,8 @@ def test_segwit_versions(self):\n         self.sync_blocks()\n         temp_utxo = []\n         tx = CTransaction()\n-        witness_program = CScript([OP_TRUE])\n-        witness_hash = sha256(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_script)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n             # First try to spend to a future version segwit script_pubkey.\n@@ -1418,7 +1359,7 @@ def test_segwit_versions(self):\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n         tx2.vout = [CTxOut(tx.vout[0].nValue - 1000, script_pubkey)]\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n         # Gets accepted to both policy-enforcing nodes and others.\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n@@ -1433,7 +1374,7 @@ def test_segwit_versions(self):\n             tx3.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n             tx3.wit.vtxinwit.append(CTxInWitness())\n             total_value += i.nValue\n-        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_script]\n         tx3.vout.append(CTxOut(total_value - 1000, script_pubkey))\n         tx3.rehash()\n \n@@ -1462,8 +1403,8 @@ def test_premature_coinbase_witness_spend(self):\n \n         block = self.build_next_block()\n         # Change the output of the block to be a witness output.\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         block.vtx[0].vout[0].scriptPubKey = script_pubkey\n         # This next line will rehash the coinbase and update the merkle\n         # root, and solve.\n@@ -1472,9 +1413,9 @@ def test_premature_coinbase_witness_spend(self):\n \n         spend_tx = CTransaction()\n         spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n-        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n+        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_script)]\n         spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         spend_tx.rehash()\n \n         # Now test a premature spend.\n@@ -1523,8 +1464,8 @@ def test_uncompressed_pubkey(self):\n \n         # Now try to spend it. Send it to a P2WSH output, which we'll\n         # use in the next test.\n-        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n-        script_wsh = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        script_wsh = script_to_p2wsh_script(witness_script)\n \n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n@@ -1553,7 +1494,7 @@ def test_uncompressed_pubkey(self):\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n         tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_p2sh))\n         tx3.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n@@ -1570,7 +1511,7 @@ def test_uncompressed_pubkey(self):\n         tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), script_sig))\n         tx4.vout.append(CTxOut(tx3.vout[0].nValue - 1000, script_pubkey))\n         tx4.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n@@ -1601,8 +1542,8 @@ def test_signature_version_1(self):\n         key.generate()\n         pubkey = key.get_pubkey().get_bytes()\n \n-        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         # First create a witness output for use in the tests.\n         tx = CTransaction()\n@@ -1629,18 +1570,18 @@ def test_signature_version_1(self):\n                 tx.vout.append(CTxOut(prev_utxo.nValue - 1000, script_pubkey))\n                 tx.wit.vtxinwit.append(CTxInWitness())\n                 # Too-large input value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n+                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Too-small input value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n+                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n                 block.vtx.pop()  # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Now try correct value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n+                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue, key)\n                 block.vtx.pop()\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -1661,7 +1602,7 @@ def test_signature_version_1(self):\n         for _ in range(NUM_SIGHASH_TESTS):\n             tx.vout.append(CTxOut(split_value, script_pubkey))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n         for i in range(NUM_SIGHASH_TESTS):\n             temp_utxos.append(UTXO(tx.sha256, i, split_value))\n \n@@ -1696,7 +1637,7 @@ def test_signature_version_1(self):\n                 if random.randint(0, 1):\n                     anyonecanpay = SIGHASH_ANYONECANPAY\n                 hashtype = random.randint(1, 3) | anyonecanpay\n-                sign_p2pk_witness_input(witness_program, tx, i, hashtype, temp_utxos[i].nValue, key)\n+                sign_p2pk_witness_input(witness_script, tx, i, hashtype, temp_utxos[i].nValue, key)\n                 if (hashtype == SIGHASH_SINGLE and i >= num_outputs):\n                     used_sighash_single_out_of_bounds = True\n             tx.rehash()\n@@ -1707,7 +1648,7 @@ def test_signature_version_1(self):\n             block.vtx.append(tx)\n \n             # Test the block periodically, if we're close to maxblocksize\n-            if (get_virtual_size(block) > MAX_BLOCK_BASE_SIZE - 1000):\n+            if block.get_weight() > MAX_BLOCK_WEIGHT - 4000:\n                 self.update_witness_block_with_transactions(block, [])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n                 block = self.build_next_block()\n@@ -1726,7 +1667,7 @@ def test_signature_version_1(self):\n         tx.vin.append(CTxIn(COutPoint(temp_utxos[0].sha256, temp_utxos[0].n), b\"\"))\n         tx.vout.append(CTxOut(temp_utxos[0].nValue, script_pkh))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n@@ -1766,7 +1707,7 @@ def test_signature_version_1(self):\n             # the signatures as we go.\n             tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n             tx.wit.vtxinwit.append(CTxInWitness())\n-            sign_p2pk_witness_input(witness_program, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n+            sign_p2pk_witness_input(witness_script, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n             index += 1\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n@@ -1927,46 +1868,13 @@ def test_non_standard_witness(self):\n \n         self.utxo.pop(0)\n \n-    @subtest  # type: ignore\n-    def test_upgrade_after_activation(self):\n-        \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n-\n-        # All nodes are caught up and node 2 is a pre-segwit node that will soon upgrade.\n-        for n in range(2):\n-            assert_equal(self.nodes[n].getblockcount(), self.nodes[2].getblockcount())\n-            assert softfork_active(self.nodes[n], \"segwit\")\n-        assert SEGWIT_HEIGHT < self.nodes[2].getblockcount()\n-        assert 'segwit' not in self.nodes[2].getblockchaininfo()['softforks']\n-\n-        # Restarting node 2 should result in a shutdown because the blockchain consists of\n-        # insufficiently validated blocks per segwit consensus rules.\n-        self.stop_node(2)\n-        self.nodes[2].assert_start_raises_init_error(\n-            extra_args=[f\"-segwitheight={SEGWIT_HEIGHT}\"],\n-            expected_msg=f\": Witness data for blocks after height {SEGWIT_HEIGHT} requires validation. Please restart with -reindex..\\nPlease restart with -reindex or -reindex-chainstate to recover.\",\n-        )\n-\n-        # As directed, the user restarts the node with -reindex\n-        self.start_node(2, extra_args=[\"-reindex\", f\"-segwitheight={SEGWIT_HEIGHT}\"])\n-\n-        # With the segwit consensus rules, the node is able to validate only up to SEGWIT_HEIGHT - 1\n-        assert_equal(self.nodes[2].getblockcount(), SEGWIT_HEIGHT - 1)\n-        self.connect_nodes(0, 2)\n-\n-        # We reconnect more than 100 blocks, give it plenty of time\n-        # sync_blocks() also verifies the best block hash is the same for all nodes\n-        self.sync_blocks(timeout=240)\n-\n-        # The upgraded node should now have segwit activated\n-        assert softfork_active(self.nodes[2], \"segwit\")\n-\n     @subtest  # type: ignore\n     def test_witness_sigops(self):\n         \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n \n         # Keep this under MAX_OPS_PER_SCRIPT (201)\n-        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         sigops_per_script = 20 * 5 + 193 * 1\n         # We'll produce 2 extra outputs, one with a program that would take us\n@@ -1981,13 +1889,13 @@ def test_witness_sigops(self):\n         # This script, when spent with the first\n         # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n         # would push us just over the block sigop limit.\n-        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n-        script_pubkey_toomany = script_to_p2wsh_script(witness_program_toomany)\n+        witness_script_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n+        script_pubkey_toomany = script_to_p2wsh_script(witness_script_toomany)\n \n         # If we spend this script instead, we would exactly reach our sigop\n         # limit (for witness sigops).\n-        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n-        script_pubkey_justright = script_to_p2wsh_script(witness_program_justright)\n+        witness_script_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n+        script_pubkey_justright = script_to_p2wsh_script(witness_script_justright)\n \n         # First split our available utxo into a bunch of outputs\n         split_value = self.utxo[0].nValue // outputs\n@@ -2010,9 +1918,9 @@ def test_witness_sigops(self):\n         for i in range(outputs - 1):\n             tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n             tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_script]\n             total_value += tx.vout[i].nValue\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_toomany]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_script_toomany]\n         tx2.vout.append(CTxOut(total_value, CScript([OP_TRUE])))\n         tx2.rehash()\n \n@@ -2051,7 +1959,7 @@ def test_witness_sigops(self):\n         tx2.vout.pop()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs - 1), b\"\"))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_justright]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_script_justright]\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_5, [tx2])\n         test_witness_block(self.nodes[0], self.test_node, block_5, accepted=True)\n@@ -2119,8 +2027,8 @@ def received_wtxidrelay():\n \n         # Create a Segwit output from the latest UTXO\n         # and announce it to the network\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n@@ -2132,7 +2040,7 @@ def received_wtxidrelay():\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n \n         # Announce Segwit transaction with wtxid"
      },
      {
        "sha": "251cc85ae9a7acf807e0d235096297cd4533a887",
        "filename": "test/functional/rpc_addresses_deprecation.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_addresses_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_addresses_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_addresses_deprecation.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -10,7 +10,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    hex_str_to_bytes\n )\n \n \n@@ -36,7 +35,7 @@ def test_addresses_deprecation(self):\n \n         # This transaction is derived from test/util/data/txcreatemultisig1.json\n         tx = tx_from_hex(signed)\n-        tx.vout[0].scriptPubKey = hex_str_to_bytes(\"522102a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff39721021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d2102df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb48553ae\")\n+        tx.vout[0].scriptPubKey = bytes.fromhex(\"522102a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff39721021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d2102df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb48553ae\")\n         tx_signed = node.signrawtransactionwithwallet(tx.serialize().hex())['hex']\n         txid = node.sendrawtransaction(hexstring=tx_signed, maxfeerate=0)\n "
      },
      {
        "sha": "721e3f93a333f25a2d16af34b368d68b4d3e48fe",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 52,
        "deletions": 37,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -6,13 +6,15 @@\n \n Test the following RPCs:\n     - getblockchaininfo\n+    - getchaintxstats\n     - gettxoutsetinfo\n-    - getdifficulty\n-    - getbestblockhash\n-    - getblockhash\n     - getblockheader\n-    - getchaintxstats\n+    - getdifficulty\n     - getnetworkhashps\n+    - waitforblockheight\n+    - getblock\n+    - getblockhash\n+    - getbestblockhash\n     - verifychain\n \n Tests correspond to code in rpc/blockchain.cpp.\n@@ -49,6 +51,12 @@\n from test_framework.wallet import MiniWallet\n \n \n+HEIGHT = 200  # blocks mined\n+TIME_RANGE_STEP = 600  # ten-minute steps\n+TIME_RANGE_MTP = TIME_GENESIS_BLOCK + (HEIGHT - 6) * TIME_RANGE_STEP\n+TIME_RANGE_END = TIME_GENESIS_BLOCK + HEIGHT * TIME_RANGE_STEP\n+\n+\n class BlockchainTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -71,12 +79,11 @@ def run_test(self):\n         assert self.nodes[0].verifychain(4, 0)\n \n     def mine_chain(self):\n-        self.log.info('Create some old blocks')\n-        for t in range(TIME_GENESIS_BLOCK, TIME_GENESIS_BLOCK + 200 * 600, 600):\n-            # ten-minute steps from genesis block time\n+        self.log.info(f\"Generate {HEIGHT} blocks after the genesis block in ten-minute steps\")\n+        for t in range(TIME_GENESIS_BLOCK, TIME_RANGE_END, TIME_RANGE_STEP):\n             self.nodes[0].setmocktime(t)\n             self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n-        assert_equal(self.nodes[0].getblockchaininfo()['blocks'], 200)\n+        assert_equal(self.nodes[0].getblockchaininfo()['blocks'], HEIGHT)\n \n     def _test_getblockchaininfo(self):\n         self.log.info(\"Test getblockchaininfo\")\n@@ -93,11 +100,15 @@ def _test_getblockchaininfo(self):\n             'pruned',\n             'size_on_disk',\n             'softforks',\n+            'time',\n             'verificationprogress',\n             'warnings',\n         ]\n         res = self.nodes[0].getblockchaininfo()\n \n+        assert_equal(res['time'], TIME_RANGE_END - TIME_RANGE_STEP)\n+        assert_equal(res['mediantime'], TIME_RANGE_MTP)\n+\n         # result should have these additional pruning keys if manual pruning is enabled\n         assert_equal(sorted(res.keys()), sorted(['pruneheight', 'automatic_pruning'] + keys))\n \n@@ -129,7 +140,7 @@ def _test_getblockchaininfo(self):\n         assert_greater_than(res['size_on_disk'], 0)\n \n         assert_equal(res['softforks'], {\n-            'bip34': {'type': 'buried', 'active': False, 'height': 500},\n+            'bip34': {'type': 'buried', 'active': True, 'height': 2},\n             'bip66': {'type': 'buried', 'active': False, 'height': 1251},\n             'bip65': {'type': 'buried', 'active': False, 'height': 1351},\n             'csv': {'type': 'buried', 'active': False, 'height': 432},\n@@ -145,8 +156,8 @@ def _test_getblockchaininfo(self):\n                     'statistics': {\n                         'period': 144,\n                         'threshold': 108,\n-                        'elapsed': 57,\n-                        'count': 57,\n+                        'elapsed': HEIGHT - 143,\n+                        'count': HEIGHT - 143,\n                         'possible': True,\n                     },\n                     'min_activation_height': 0,\n@@ -183,33 +194,33 @@ def _test_getchaintxstats(self):\n         assert_raises_rpc_error(-8, \"blockhash must be of length 64 (not 1, for '0')\", self.nodes[0].getchaintxstats, blockhash='0')\n         assert_raises_rpc_error(-8, \"blockhash must be hexadecimal string (not 'ZZZ0000000000000000000000000000000000000000000000000000000000000')\", self.nodes[0].getchaintxstats, blockhash='ZZZ0000000000000000000000000000000000000000000000000000000000000')\n         assert_raises_rpc_error(-5, \"Block not found\", self.nodes[0].getchaintxstats, blockhash='0000000000000000000000000000000000000000000000000000000000000000')\n-        blockhash = self.nodes[0].getblockhash(200)\n+        blockhash = self.nodes[0].getblockhash(HEIGHT)\n         self.nodes[0].invalidateblock(blockhash)\n         assert_raises_rpc_error(-8, \"Block is not in main chain\", self.nodes[0].getchaintxstats, blockhash=blockhash)\n         self.nodes[0].reconsiderblock(blockhash)\n \n         chaintxstats = self.nodes[0].getchaintxstats(nblocks=1)\n         # 200 txs plus genesis tx\n-        assert_equal(chaintxstats['txcount'], 201)\n+        assert_equal(chaintxstats['txcount'], HEIGHT + 1)\n         # tx rate should be 1 per 10 minutes, or 1/600\n         # we have to round because of binary math\n-        assert_equal(round(chaintxstats['txrate'] * 600, 10), Decimal(1))\n+        assert_equal(round(chaintxstats['txrate'] * TIME_RANGE_STEP, 10), Decimal(1))\n \n         b1_hash = self.nodes[0].getblockhash(1)\n         b1 = self.nodes[0].getblock(b1_hash)\n-        b200_hash = self.nodes[0].getblockhash(200)\n+        b200_hash = self.nodes[0].getblockhash(HEIGHT)\n         b200 = self.nodes[0].getblock(b200_hash)\n         time_diff = b200['mediantime'] - b1['mediantime']\n \n         chaintxstats = self.nodes[0].getchaintxstats()\n         assert_equal(chaintxstats['time'], b200['time'])\n-        assert_equal(chaintxstats['txcount'], 201)\n+        assert_equal(chaintxstats['txcount'], HEIGHT + 1)\n         assert_equal(chaintxstats['window_final_block_hash'], b200_hash)\n-        assert_equal(chaintxstats['window_final_block_height'], 200)\n-        assert_equal(chaintxstats['window_block_count'], 199)\n-        assert_equal(chaintxstats['window_tx_count'], 199)\n+        assert_equal(chaintxstats['window_final_block_height'], HEIGHT )\n+        assert_equal(chaintxstats['window_block_count'], HEIGHT - 1)\n+        assert_equal(chaintxstats['window_tx_count'], HEIGHT - 1)\n         assert_equal(chaintxstats['window_interval'], time_diff)\n-        assert_equal(round(chaintxstats['txrate'] * time_diff, 10), Decimal(199))\n+        assert_equal(round(chaintxstats['txrate'] * time_diff, 10), Decimal(HEIGHT - 1))\n \n         chaintxstats = self.nodes[0].getchaintxstats(blockhash=b1_hash)\n         assert_equal(chaintxstats['time'], b1['time'])\n@@ -226,18 +237,18 @@ def _test_gettxoutsetinfo(self):\n         res = node.gettxoutsetinfo()\n \n         assert_equal(res['total_amount'], Decimal('8725.00000000'))\n-        assert_equal(res['transactions'], 200)\n-        assert_equal(res['height'], 200)\n-        assert_equal(res['txouts'], 200)\n+        assert_equal(res['transactions'], HEIGHT)\n+        assert_equal(res['height'], HEIGHT)\n+        assert_equal(res['txouts'], HEIGHT)\n         assert_equal(res['bogosize'], 16800),\n-        assert_equal(res['bestblock'], node.getblockhash(200))\n+        assert_equal(res['bestblock'], node.getblockhash(HEIGHT))\n         size = res['disk_size']\n         assert size > 6400\n         assert size < 64000\n         assert_equal(len(res['bestblock']), 64)\n         assert_equal(len(res['hash_serialized_2']), 64)\n \n-        self.log.info(\"Test that gettxoutsetinfo() works for blockchain with just the genesis block\")\n+        self.log.info(\"Test gettxoutsetinfo works for blockchain with just the genesis block\")\n         b1hash = node.getblockhash(1)\n         node.invalidateblock(b1hash)\n \n@@ -250,7 +261,7 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res2['bestblock'], node.getblockhash(0))\n         assert_equal(len(res2['hash_serialized_2']), 64)\n \n-        self.log.info(\"Test that gettxoutsetinfo() returns the same result after invalidate/reconsider block\")\n+        self.log.info(\"Test gettxoutsetinfo returns the same result after invalidate/reconsider block\")\n         node.reconsiderblock(b1hash)\n \n         res3 = node.gettxoutsetinfo()\n@@ -259,7 +270,7 @@ def _test_gettxoutsetinfo(self):\n         del res['disk_size'], res3['disk_size']\n         assert_equal(res, res3)\n \n-        self.log.info(\"Test hash_type option for gettxoutsetinfo()\")\n+        self.log.info(\"Test gettxoutsetinfo hash_type option\")\n         # Adding hash_type 'hash_serialized_2', which is the default, should\n         # not change the result.\n         res4 = node.gettxoutsetinfo(hash_type='hash_serialized_2')\n@@ -283,18 +294,19 @@ def _test_gettxoutsetinfo(self):\n         assert_raises_rpc_error(-8, \"foohash is not a valid hash_type\", node.gettxoutsetinfo, \"foohash\")\n \n     def _test_getblockheader(self):\n+        self.log.info(\"Test getblockheader\")\n         node = self.nodes[0]\n \n         assert_raises_rpc_error(-8, \"hash must be of length 64 (not 8, for 'nonsense')\", node.getblockheader, \"nonsense\")\n         assert_raises_rpc_error(-8, \"hash must be hexadecimal string (not 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844')\", node.getblockheader, \"ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844\")\n         assert_raises_rpc_error(-5, \"Block not found\", node.getblockheader, \"0cf7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844\")\n \n         besthash = node.getbestblockhash()\n-        secondbesthash = node.getblockhash(199)\n+        secondbesthash = node.getblockhash(HEIGHT - 1)\n         header = node.getblockheader(blockhash=besthash)\n \n         assert_equal(header['hash'], besthash)\n-        assert_equal(header['height'], 200)\n+        assert_equal(header['height'], HEIGHT)\n         assert_equal(header['confirmations'], 1)\n         assert_equal(header['previousblockhash'], secondbesthash)\n         assert_is_hex_string(header['chainwork'])\n@@ -304,7 +316,7 @@ def _test_getblockheader(self):\n         assert_is_hash_string(header['merkleroot'])\n         assert_is_hash_string(header['bits'], length=None)\n         assert isinstance(header['time'], int)\n-        assert isinstance(header['mediantime'], int)\n+        assert_equal(header['mediantime'], TIME_RANGE_MTP)\n         assert isinstance(header['nonce'], int)\n         assert isinstance(header['version'], int)\n         assert isinstance(int(header['versionHex'], 16), int)\n@@ -322,20 +334,23 @@ def _test_getblockheader(self):\n         assert 'nextblockhash' not in node.getblockheader(node.getbestblockhash())\n \n     def _test_getdifficulty(self):\n+        self.log.info(\"Test getdifficulty\")\n         difficulty = self.nodes[0].getdifficulty()\n         # 1 hash in 2 should be valid, so difficulty should be 1/2**31\n         # binary => decimal => binary math is why we do this check\n         assert abs(difficulty * 2**31 - 1) < 0.0001\n \n     def _test_getnetworkhashps(self):\n+        self.log.info(\"Test getnetworkhashps\")\n         hashes_per_second = self.nodes[0].getnetworkhashps()\n         # This should be 2 hashes every 10 minutes or 1/300\n         assert abs(hashes_per_second * 300 - 1) < 0.0001\n \n     def _test_stopatheight(self):\n-        assert_equal(self.nodes[0].getblockcount(), 200)\n+        self.log.info(\"Test stopping at height\")\n+        assert_equal(self.nodes[0].getblockcount(), HEIGHT)\n         self.nodes[0].generatetoaddress(6, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n-        assert_equal(self.nodes[0].getblockcount(), 206)\n+        assert_equal(self.nodes[0].getblockcount(), HEIGHT + 6)\n         self.log.debug('Node should not stop at this height')\n         assert_raises(subprocess.TimeoutExpired, lambda: self.nodes[0].process.wait(timeout=3))\n         try:\n@@ -345,7 +360,7 @@ def _test_stopatheight(self):\n         self.log.debug('Node should stop at this height...')\n         self.nodes[0].wait_until_stopped()\n         self.start_node(0)\n-        assert_equal(self.nodes[0].getblockcount(), 207)\n+        assert_equal(self.nodes[0].getblockcount(), HEIGHT + 7)\n \n     def _test_waitforblockheight(self):\n         self.log.info(\"Test waitforblockheight\")\n@@ -397,20 +412,20 @@ def _test_getblock(self):\n         miniwallet.send_self_transfer(fee_rate=fee_per_kb, from_node=node)\n         blockhash = node.generate(1)[0]\n \n-        self.log.info(\"Test that getblock with verbosity 1 doesn't include fee\")\n+        self.log.info(\"Test getblock with verbosity 1 doesn't include fee\")\n         block = node.getblock(blockhash, 1)\n         assert 'fee' not in block['tx'][1]\n \n-        self.log.info('Test that getblock with verbosity 2 includes expected fee')\n+        self.log.info('Test getblock with verbosity 2 includes expected fee')\n         block = node.getblock(blockhash, 2)\n         tx = block['tx'][1]\n         assert 'fee' in tx\n         assert_equal(tx['fee'], tx['vsize'] * fee_per_byte)\n \n-        self.log.info(\"Test that getblock with verbosity 2 still works with pruned Undo data\")\n+        self.log.info(\"Test getblock with verbosity 2 still works with pruned Undo data\")\n         datadir = get_datadir_path(self.options.tmpdir, 0)\n \n-        self.log.info(\"Test that getblock with invalid verbosity type returns proper error message\")\n+        self.log.info(\"Test getblock with invalid verbosity type returns proper error message\")\n         assert_raises_rpc_error(-1, \"JSON value is not an integer as expected\", node.getblock, blockhash, \"2\")\n \n         def move_block_file(old, new):"
      },
      {
        "sha": "bb2e51c2f72b4d13ad7a848e49f5ef9ab49a11fa",
        "filename": "test/functional/rpc_createmultisig.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_createmultisig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_createmultisig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_createmultisig.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -3,7 +3,6 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test multisig RPCs\"\"\"\n-import binascii\n import decimal\n import itertools\n import json\n@@ -66,9 +65,9 @@ def run_test(self):\n \n         # decompress pk2\n         pk_obj = ECPubKey()\n-        pk_obj.set(binascii.unhexlify(pk2))\n+        pk_obj.set(bytes.fromhex(pk2))\n         pk_obj.compressed = False\n-        pk2 = binascii.hexlify(pk_obj.get_bytes()).decode()\n+        pk2 = pk_obj.get_bytes().hex()\n \n         node0.createwallet(wallet_name='wmulti0', disable_private_keys=True)\n         wmulti0 = node0.get_wallet_rpc('wmulti0')"
      },
      {
        "sha": "5b1514af6f18c650eaffd786d782be82fa3ccef9",
        "filename": "test/functional/rpc_decodescript.py",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_decodescript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_decodescript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_decodescript.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -11,7 +11,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    hex_str_to_bytes,\n )\n \n \n@@ -86,7 +85,7 @@ def decodescript_script_pub_key(self):\n         rpc_result = self.nodes[0].decodescript(multisig_script)\n         assert_equal('2 ' + public_key + ' ' + public_key + ' ' + public_key +  ' 3 OP_CHECKMULTISIG', rpc_result['asm'])\n         # multisig in P2WSH\n-        multisig_script_hash = sha256(hex_str_to_bytes(multisig_script)).hex()\n+        multisig_script_hash = sha256(bytes.fromhex(multisig_script)).hex()\n         assert_equal('0 ' + multisig_script_hash, rpc_result['segwit']['asm'])\n \n         # 4) P2SH scriptPubKey\n@@ -124,7 +123,7 @@ def decodescript_script_pub_key(self):\n         rpc_result = self.nodes[0].decodescript(cltv_script)\n         assert_equal('OP_IF ' + public_key + ' OP_CHECKSIGVERIFY OP_ELSE 500000 OP_CHECKLOCKTIMEVERIFY OP_DROP OP_ENDIF ' + public_key + ' OP_CHECKSIG', rpc_result['asm'])\n         # CLTV script in P2WSH\n-        cltv_script_hash = sha256(hex_str_to_bytes(cltv_script)).hex()\n+        cltv_script_hash = sha256(bytes.fromhex(cltv_script)).hex()\n         assert_equal('0 ' + cltv_script_hash, rpc_result['segwit']['asm'])\n \n         # 7) P2PK scriptPubKey\n@@ -209,23 +208,23 @@ def decoderawtransaction_asm_sighashtype(self):\n         signature_2_sighash_decoded = der_signature + '[NONE|ANYONECANPAY]'\n \n         # 1) P2PK scriptSig\n-        txSave.vin[0].scriptSig = hex_str_to_bytes(push_signature)\n+        txSave.vin[0].scriptSig = bytes.fromhex(push_signature)\n         rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal(signature_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # make sure that the sighash decodes come out correctly for a more complex / lesser used case.\n-        txSave.vin[0].scriptSig = hex_str_to_bytes(push_signature_2)\n+        txSave.vin[0].scriptSig = bytes.fromhex(push_signature_2)\n         rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal(signature_2_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # 2) multisig scriptSig\n-        txSave.vin[0].scriptSig = hex_str_to_bytes('00' + push_signature + push_signature_2)\n+        txSave.vin[0].scriptSig = bytes.fromhex('00' + push_signature + push_signature_2)\n         rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal('0 ' + signature_sighash_decoded + ' ' + signature_2_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # 3) test a scriptSig that contains more than push operations.\n         # in fact, it contains an OP_RETURN with data specially crafted to cause improper decode if the code does not catch it.\n-        txSave.vin[0].scriptSig = hex_str_to_bytes('6a143011020701010101010101020601010101010101')\n+        txSave.vin[0].scriptSig = bytes.fromhex('6a143011020701010101010101020601010101010101')\n         rpc_result = self.nodes[0].decoderawtransaction(txSave.serialize().hex())\n         assert_equal('OP_RETURN 3011020701010101010101020601010101010101', rpc_result['vin'][0]['scriptSig']['asm'])\n "
      },
      {
        "sha": "563f2ea43e0063d382b1860f01fbc14a45b540d5",
        "filename": "test/functional/rpc_misc.py",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_misc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_misc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_misc.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -54,13 +54,27 @@ def run_test(self):\n \n         assert_raises_rpc_error(-8, \"unknown mode foobar\", node.getmemoryinfo, mode=\"foobar\")\n \n-        self.log.info(\"test logging\")\n+        self.log.info(\"test logging rpc and help\")\n+\n+        # Test logging RPC returns the expected number of logging categories.\n+        assert_equal(len(node.logging()), 24)\n+\n+        # Test toggling a logging category on/off/on with the logging RPC.\n         assert_equal(node.logging()['qt'], True)\n         node.logging(exclude=['qt'])\n         assert_equal(node.logging()['qt'], False)\n         node.logging(include=['qt'])\n         assert_equal(node.logging()['qt'], True)\n \n+        # Test logging RPC returns the logging categories in alphabetical order.\n+        sorted_logging_categories = sorted(node.logging())\n+        assert_equal(list(node.logging()), sorted_logging_categories)\n+\n+        # Test logging help returns the logging categories string in alphabetical order.\n+        categories = ', '.join(sorted_logging_categories)\n+        logging_help = self.nodes[0].help('logging')\n+        assert f\"valid logging categories are: {categories}\" in logging_help\n+\n         self.log.info(\"test echoipc (testing spawned process in multiprocess build)\")\n         assert_equal(node.echoipc(\"hello\"), \"hello\")\n "
      },
      {
        "sha": "9d4a5525d14a2dee7d1f802ef1f2a17867a8284d",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -515,6 +515,15 @@ def run_test(self):\n         assert_equal(testres['allowed'], True)\n         self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')\n \n+        self.log.info('sendrawtransaction/testmempoolaccept with tx that is already in the chain')\n+        self.nodes[2].generate(1)\n+        self.sync_blocks()\n+        for node in self.nodes:\n+            testres = node.testmempoolaccept([rawTxSigned['hex']])[0]\n+            assert_equal(testres['allowed'], False)\n+            assert_equal(testres['reject-reason'], 'txn-already-known')\n+            assert_raises_rpc_error(-27, 'Transaction already in block chain', node.sendrawtransaction, rawTxSigned['hex'])\n+\n \n if __name__ == '__main__':\n     RawTransactionsTest().main()"
      },
      {
        "sha": "312a4abbc3a2ff892c616e5701cf3d63e91e81f6",
        "filename": "test/functional/rpc_signrawtransaction.py",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_signrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/rpc_signrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_signrawtransaction.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,7 +4,11 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test transaction signing using the signrawtransaction* RPCs.\"\"\"\n \n-from test_framework.blocktools import COINBASE_MATURITY\n+from test_framework.blocktools import (\n+    CLTV_HEIGHT,\n+    COINBASE_MATURITY,\n+    CSV_ACTIVATION_HEIGHT,\n+)\n from test_framework.address import (\n     script_to_p2sh,\n     script_to_p2wsh,\n@@ -15,7 +19,7 @@\n     assert_equal,\n     assert_raises_rpc_error,\n     find_vout_for_address,\n-    hex_str_to_bytes,\n+    generate_to_height,\n )\n from test_framework.messages import (\n     CTxInWitness,\n@@ -228,7 +232,7 @@ def verify_txn_with_witness_script(self, tx_type):\n         embedded_pubkey = eckey.get_pubkey().get_bytes().hex()\n         witness_script = {\n             'P2PKH': key_to_p2pkh_script(embedded_pubkey).hex(),\n-            'P2PK': CScript([hex_str_to_bytes(embedded_pubkey), OP_CHECKSIG]).hex()\n+            'P2PK': CScript([bytes.fromhex(embedded_pubkey), OP_CHECKSIG]).hex()\n         }.get(tx_type, \"Invalid tx_type\")\n         redeem_script = script_to_p2wsh_script(witness_script).hex()\n         addr = script_to_p2sh(redeem_script)\n@@ -270,7 +274,8 @@ def test_signing_with_csv(self):\n         getcontext().prec = 8\n \n         # Make sure CSV is active\n-        self.nodes[0].generate(500)\n+        generate_to_height(self.nodes[0], CSV_ACTIVATION_HEIGHT)\n+        assert self.nodes[0].getblockchaininfo()['softforks']['csv']['active']\n \n         # Create a P2WSH script with CSV\n         script = CScript([1, OP_CHECKSEQUENCEVERIFY, OP_DROP])\n@@ -304,8 +309,9 @@ def test_signing_with_cltv(self):\n         self.nodes[0].walletpassphrase(\"password\", 9999)\n         getcontext().prec = 8\n \n-        # Make sure CSV is active\n-        self.nodes[0].generate(1500)\n+        # Make sure CLTV is active\n+        generate_to_height(self.nodes[0], CLTV_HEIGHT)\n+        assert self.nodes[0].getblockchaininfo()['softforks']['bip65']['active']\n \n         # Create a P2WSH script with CLTV\n         script = CScript([1000, OP_CHECKLOCKTIMEVERIFY, OP_DROP])"
      },
      {
        "sha": "fe733e9368db42a7f35170087fb8a95e9a255698",
        "filename": "test/functional/test_framework/address.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/address.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/address.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/address.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -12,7 +12,7 @@\n \n from .script import hash256, hash160, sha256, CScript, OP_0\n from .segwit_addr import encode_segwit_address\n-from .util import assert_equal, hex_str_to_bytes\n+from .util import assert_equal\n \n ADDRESS_BCRT1_UNSPENDABLE = 'bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj'\n ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR = 'addr(bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj)#juyq9d97'\n@@ -33,7 +33,7 @@ def byte_to_base58(b, version):\n     result = ''\n     str = b.hex()\n     str = chr(version).encode('latin-1').hex() + str\n-    checksum = hash256(hex_str_to_bytes(str)).hex()\n+    checksum = hash256(bytes.fromhex(str)).hex()\n     str += checksum[:8]\n     value = int('0x' + str, 0)\n     while value > 0:\n@@ -100,7 +100,7 @@ def key_to_p2sh_p2wpkh(key, main=False):\n \n def program_to_witness(version, program, main=False):\n     if (type(program) is str):\n-        program = hex_str_to_bytes(program)\n+        program = bytes.fromhex(program)\n     assert 0 <= version <= 16\n     assert 2 <= len(program) <= 40\n     assert version > 0 or len(program) in [20, 32]\n@@ -121,14 +121,14 @@ def script_to_p2sh_p2wsh(script, main=False):\n \n def check_key(key):\n     if (type(key) is str):\n-        key = hex_str_to_bytes(key)  # Assuming this is hex string\n+        key = bytes.fromhex(key)  # Assuming this is hex string\n     if (type(key) is bytes and (len(key) == 33 or len(key) == 65)):\n         return key\n     assert False\n \n def check_script(script):\n     if (type(script) is str):\n-        script = hex_str_to_bytes(script)  # Assuming this is hex string\n+        script = bytes.fromhex(script)  # Assuming this is hex string\n     if (type(script) is bytes or type(script) is CScript):\n         return script\n     assert False"
      },
      {
        "sha": "d623bcdf6e91e2b36f184be5baed81276d7d3c4a",
        "filename": "test/functional/test_framework/bdb.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/bdb.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/bdb.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/bdb.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -24,7 +24,6 @@\n `db_dump -da wallet.dat` is useful to see the data in a wallet.dat BDB file\n \"\"\"\n \n-import binascii\n import struct\n \n # Important constants\n@@ -96,7 +95,7 @@ def dump_meta_page(page):\n     metadata['key_count'] = key_count\n     metadata['record_count'] = record_count\n     metadata['flags'] = flags\n-    metadata['uid'] = binascii.hexlify(uid)\n+    metadata['uid'] = uid.hex().encode()\n \n     assert magic == BTREE_MAGIC, 'bdb magic does not match bdb btree magic'\n     assert pg_type == BTREE_META, 'Metadata page is not a btree metadata page'\n@@ -110,8 +109,9 @@ def dump_meta_page(page):\n     metadata['re_pad'] = re_pad\n     metadata['root'] = root\n     metadata['crypto_magic'] = crypto_magic\n-    metadata['iv'] = binascii.hexlify(iv)\n-    metadata['chksum'] = binascii.hexlify(chksum)\n+    metadata['iv'] = iv.hex().encode()\n+    metadata['chksum'] = chksum.hex().encode()\n+\n     return metadata\n \n # Given the dict from dump_leaf_page, get the key-value pairs and put them into a dict"
      },
      {
        "sha": "52ca579b1bef2fd41d50f2beaeeee4d3fd2183c5",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,7 +4,6 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Utilities for manipulating blocks and transactions.\"\"\"\n \n-from binascii import a2b_hex\n import struct\n import time\n import unittest\n@@ -24,7 +23,6 @@\n     CTxInWitness,\n     CTxOut,\n     hash256,\n-    hex_str_to_bytes,\n     ser_uint256,\n     tx_from_hex,\n     uint256_from_str,\n@@ -55,22 +53,27 @@\n # Coinbase transaction outputs can only be spent after this number of new blocks (network rule)\n COINBASE_MATURITY = 100\n \n+# Soft-fork activation heights\n+CLTV_HEIGHT = 1351\n+CSV_ACTIVATION_HEIGHT = 432\n+\n # From BIP141\n WITNESS_COMMITMENT_HEADER = b\"\\xaa\\x21\\xa9\\xed\"\n \n NORMAL_GBT_REQUEST_PARAMS = {\"rules\": [\"segwit\"]}\n+VERSIONBITS_LAST_OLD_BLOCK_VERSION = 4\n \n \n def create_block(hashprev=None, coinbase=None, ntime=None, *, version=None, tmpl=None, txlist=None):\n     \"\"\"Create a block (with regtest difficulty).\"\"\"\n     block = CBlock()\n     if tmpl is None:\n         tmpl = {}\n-    block.nVersion = version or tmpl.get('version') or 1\n+    block.nVersion = version or tmpl.get('version') or VERSIONBITS_LAST_OLD_BLOCK_VERSION\n     block.nTime = ntime or tmpl.get('curtime') or int(time.time() + 600)\n     block.hashPrevBlock = hashprev or int(tmpl['previousblockhash'], 0x10)\n     if tmpl and not tmpl.get('bits') is None:\n-        block.nBits = struct.unpack('>I', a2b_hex(tmpl['bits']))[0]\n+        block.nBits = struct.unpack('>I', bytes.fromhex(tmpl['bits']))[0]\n     else:\n         block.nBits = 0x207fffff  # difficulty retargeting is disabled in REGTEST chainparams\n     if coinbase is None:\n@@ -210,16 +213,16 @@ def witness_script(use_p2wsh, pubkey):\n         pkscript = key_to_p2wpkh_script(pubkey)\n     else:\n         # 1-of-1 multisig\n-        witness_program = CScript([OP_1, hex_str_to_bytes(pubkey), OP_1, OP_CHECKMULTISIG])\n-        pkscript = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_1, bytes.fromhex(pubkey), OP_1, OP_CHECKMULTISIG])\n+        pkscript = script_to_p2wsh_script(witness_script)\n     return pkscript.hex()\n \n def create_witness_tx(node, use_p2wsh, utxo, pubkey, encode_p2sh, amount):\n     \"\"\"Return a transaction (in hex) that spends the given utxo to a segwit output.\n \n     Optionally wrap the segwit output using P2SH.\"\"\"\n     if use_p2wsh:\n-        program = CScript([OP_1, hex_str_to_bytes(pubkey), OP_1, OP_CHECKMULTISIG])\n+        program = CScript([OP_1, bytes.fromhex(pubkey), OP_1, OP_CHECKMULTISIG])\n         addr = script_to_p2sh_p2wsh(program) if encode_p2sh else script_to_p2wsh(program)\n     else:\n         addr = key_to_p2sh_p2wpkh(pubkey) if encode_p2sh else key_to_p2wpkh(pubkey)\n@@ -242,7 +245,7 @@ def send_to_witness(use_p2wsh, node, utxo, pubkey, encode_p2sh, amount, sign=Tru\n     else:\n         if (insert_redeem_script):\n             tx = tx_from_hex(tx_to_witness)\n-            tx.vin[0].scriptSig += CScript([hex_str_to_bytes(insert_redeem_script)])\n+            tx.vin[0].scriptSig += CScript([bytes.fromhex(insert_redeem_script)])\n             tx_to_witness = tx.serialize().hex()\n \n     return node.sendrawtransaction(tx_to_witness)"
      },
      {
        "sha": "ad8cfe5c9aecd9f98fc82974d43c935612784037",
        "filename": "test/functional/test_framework/coverage.py",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/coverage.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/coverage.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/coverage.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -10,6 +10,7 @@\n \n import os\n \n+from .authproxy import AuthServiceProxy\n \n REFERENCE_FILENAME = 'rpc_interface.txt'\n \n@@ -19,24 +20,25 @@ class AuthServiceProxyWrapper():\n     An object that wraps AuthServiceProxy to record specific RPC calls.\n \n     \"\"\"\n-    def __init__(self, auth_service_proxy_instance, coverage_logfile=None):\n+    def __init__(self, auth_service_proxy_instance: AuthServiceProxy, rpc_url: str, coverage_logfile: str=None):\n         \"\"\"\n         Kwargs:\n-            auth_service_proxy_instance (AuthServiceProxy): the instance\n-                being wrapped.\n-            coverage_logfile (str): if specified, write each service_name\n+            auth_service_proxy_instance: the instance being wrapped.\n+            rpc_url: url of the RPC instance being wrapped\n+            coverage_logfile: if specified, write each service_name\n                 out to a file when called.\n \n         \"\"\"\n         self.auth_service_proxy_instance = auth_service_proxy_instance\n+        self.rpc_url = rpc_url\n         self.coverage_logfile = coverage_logfile\n \n     def __getattr__(self, name):\n         return_val = getattr(self.auth_service_proxy_instance, name)\n         if not isinstance(return_val, type(self.auth_service_proxy_instance)):\n             # If proxy getattr returned an unwrapped value, do the same here.\n             return return_val\n-        return AuthServiceProxyWrapper(return_val, self.coverage_logfile)\n+        return AuthServiceProxyWrapper(return_val, self.rpc_url, self.coverage_logfile)\n \n     def __call__(self, *args, **kwargs):\n         \"\"\"\n@@ -57,6 +59,7 @@ def _log_call(self):\n \n     def __truediv__(self, relative_uri):\n         return AuthServiceProxyWrapper(self.auth_service_proxy_instance / relative_uri,\n+                                       self.rpc_url,\n                                        self.coverage_logfile)\n \n     def get_request(self, *args, **kwargs):\n@@ -74,18 +77,18 @@ def get_filename(dirname, n_node):\n         dirname, \"coverage.pid%s.node%s.txt\" % (pid, str(n_node)))\n \n \n-def write_all_rpc_commands(dirname, node):\n+def write_all_rpc_commands(dirname: str, node: AuthServiceProxy) -> bool:\n     \"\"\"\n     Write out a list of all RPC functions available in `bitcoin-cli` for\n     coverage comparison. This will only happen once per coverage\n     directory.\n \n     Args:\n-        dirname (str): temporary test dir\n-        node (AuthServiceProxy): client\n+        dirname: temporary test dir\n+        node: client\n \n     Returns:\n-        bool. if the RPC interface file was written.\n+        if the RPC interface file was written.\n \n     \"\"\"\n     filename = os.path.join(dirname, REFERENCE_FILENAME)"
      },
      {
        "sha": "6e57107f86e103daee29c9c761086f862b300c7d",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 17,
        "deletions": 7,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -30,10 +30,10 @@\n import time\n \n from test_framework.siphash import siphash256\n-from test_framework.util import hex_str_to_bytes, assert_equal\n+from test_framework.util import assert_equal\n \n MAX_LOCATOR_SZ = 101\n-MAX_BLOCK_BASE_SIZE = 1000000\n+MAX_BLOCK_WEIGHT = 4000000\n MAX_BLOOM_FILTER_SIZE = 36000\n MAX_BLOOM_HASH_FUNCS = 50\n \n@@ -197,7 +197,7 @@ def from_hex(obj, hex_string):\n     Note that there is no complementary helper like e.g. `to_hex` for the\n     inverse operation. To serialize a message object to a hex string, simply\n     use obj.serialize().hex()\"\"\"\n-    obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n+    obj.deserialize(BytesIO(bytes.fromhex(hex_string)))\n     return obj\n \n \n@@ -608,12 +608,15 @@ def is_valid(self):\n                 return False\n         return True\n \n-    # Calculate the virtual transaction size using witness and non-witness\n+    # Calculate the transaction weight using witness and non-witness\n     # serialization size (does NOT use sigops).\n-    def get_vsize(self):\n+    def get_weight(self):\n         with_witness_size = len(self.serialize_with_witness())\n         without_witness_size = len(self.serialize_without_witness())\n-        return math.ceil(((WITNESS_SCALE_FACTOR - 1) * without_witness_size + with_witness_size) / WITNESS_SCALE_FACTOR)\n+        return (WITNESS_SCALE_FACTOR - 1) * without_witness_size + with_witness_size\n+\n+    def get_vsize(self):\n+        return math.ceil(self.get_weight() / WITNESS_SCALE_FACTOR)\n \n     def __repr__(self):\n         return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n@@ -639,7 +642,7 @@ def __init__(self, header=None):\n             self.calc_sha256()\n \n     def set_null(self):\n-        self.nVersion = 1\n+        self.nVersion = 4\n         self.hashPrevBlock = 0\n         self.hashMerkleRoot = 0\n         self.nTime = 0\n@@ -761,6 +764,13 @@ def solve(self):\n             self.nNonce += 1\n             self.rehash()\n \n+    # Calculate the block weight using witness and non-witness\n+    # serialization size (does NOT use sigops).\n+    def get_weight(self):\n+        with_witness_size = len(self.serialize(with_witness=True))\n+        without_witness_size = len(self.serialize(with_witness=False))\n+        return (WITNESS_SCALE_FACTOR - 1) * without_witness_size + with_witness_size\n+\n     def __repr__(self):\n         return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n             % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,"
      },
      {
        "sha": "b5f78e0cf3f8a716c58a6e332f4d7b1c5bb5fcdc",
        "filename": "test/functional/test_framework/netutil.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/netutil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/netutil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/netutil.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -12,7 +12,6 @@\n import struct\n import array\n import os\n-from binascii import unhexlify\n \n # STATE_ESTABLISHED = '01'\n # STATE_SYN_SENT  = '02'\n@@ -44,7 +43,7 @@ def _remove_empty(array):\n def _convert_ip_port(array):\n     host,port = array.split(':')\n     # convert host from mangled-per-four-bytes form as used by kernel\n-    host = unhexlify(host)\n+    host = bytes.fromhex(host)\n     host_out = ''\n     for x in range(0, len(host) // 4):\n         (val,) = struct.unpack('=I', host[x*4:(x+1)*4])"
      },
      {
        "sha": "b7d5bd8fab571a664361c16402acb2b206fdc800",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -438,6 +438,7 @@ def on_version(self, message):\n             self.send_message(msg_sendaddrv2())\n         self.send_message(msg_verack())\n         self.nServices = message.nServices\n+        self.send_message(msg_getaddr())\n \n     # Connection helper methods\n "
      },
      {
        "sha": "5d1d7ea45ce5fbf52356f4544c23ec0cbdb20166",
        "filename": "test/functional/test_framework/script_util.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/script_util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/script_util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script_util.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -4,7 +4,6 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Useful Script constants and utils.\"\"\"\n from test_framework.script import CScript, hash160, sha256, OP_0, OP_DUP, OP_HASH160, OP_CHECKSIG, OP_EQUAL, OP_EQUALVERIFY\n-from test_framework.util import hex_str_to_bytes\n \n # To prevent a \"tx-size-small\" policy rule error, a transaction has to have a\n # non-witness size of at least 82 bytes (MIN_STANDARD_TX_NONWITNESS_SIZE in\n@@ -49,7 +48,7 @@ def key_to_p2sh_p2wpkh_script(key, main = False):\n \n def program_to_witness_script(version, program, main = False):\n     if isinstance(program, str):\n-        program = hex_str_to_bytes(program)\n+        program = bytes.fromhex(program)\n     assert 0 <= version <= 16\n     assert 2 <= len(program) <= 40\n     assert version > 0 or len(program) in [20, 32]\n@@ -70,14 +69,14 @@ def script_to_p2sh_p2wsh_script(script, main = False):\n \n def check_key(key):\n     if isinstance(key, str):\n-        key = hex_str_to_bytes(key) # Assuming this is hex string\n+        key = bytes.fromhex(key) # Assuming this is hex string\n     if isinstance(key, bytes) and (len(key) == 33 or len(key) == 65):\n         return key\n     assert False\n \n def check_script(script):\n     if isinstance(script, str):\n-        script = hex_str_to_bytes(script) # Assuming this is hex string\n+        script = bytes.fromhex(script) # Assuming this is hex string\n     if isinstance(script, bytes) or isinstance(script, CScript):\n         return script\n     assert False"
      },
      {
        "sha": "6d8e6ef45c1196db3889a94cb953937e4695f394",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -112,6 +112,9 @@ def __init__(self):\n         # By default the wallet is not required. Set to true by skip_if_no_wallet().\n         # When False, we ignore wallet_names regardless of what it is.\n         self.requires_wallet = False\n+        # Disable ThreadOpenConnections by default, so that adding entries to\n+        # addrman will not result in automatic connections to them.\n+        self.disable_autoconnect = True\n         self.set_test_params()\n         assert self.wallet_names is None or len(self.wallet_names) <= self.num_nodes\n         if self.options.timeout_factor == 0 :\n@@ -711,7 +714,7 @@ def _initialize_chain(self):\n         if not os.path.isdir(cache_node_dir):\n             self.log.debug(\"Creating cache directory {}\".format(cache_node_dir))\n \n-            initialize_datadir(self.options.cachedir, CACHE_NODE_ID, self.chain)\n+            initialize_datadir(self.options.cachedir, CACHE_NODE_ID, self.chain, self.disable_autoconnect)\n             self.nodes.append(\n                 TestNode(\n                     CACHE_NODE_ID,\n@@ -769,15 +772,15 @@ def cache_path(*paths):\n             self.log.debug(\"Copy cache directory {} to node {}\".format(cache_node_dir, i))\n             to_dir = get_datadir_path(self.options.tmpdir, i)\n             shutil.copytree(cache_node_dir, to_dir)\n-            initialize_datadir(self.options.tmpdir, i, self.chain)  # Overwrite port/rpcport in bitcoin.conf\n+            initialize_datadir(self.options.tmpdir, i, self.chain, self.disable_autoconnect)  # Overwrite port/rpcport in bitcoin.conf\n \n     def _initialize_chain_clean(self):\n         \"\"\"Initialize empty blockchain for use by the test.\n \n         Create an empty blockchain and num_nodes wallets.\n         Useful if a test case wants complete control over initialization.\"\"\"\n         for i in range(self.num_nodes):\n-            initialize_datadir(self.options.tmpdir, i, self.chain)\n+            initialize_datadir(self.options.tmpdir, i, self.chain, self.disable_autoconnect)\n \n     def skip_if_no_py3_zmq(self):\n         \"\"\"Attempt to import the zmq package and skip the test if the import fails.\"\"\""
      },
      {
        "sha": "f9e2cfa2f58a18d9420d55f3f8a5366f79f0379d",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -258,7 +258,7 @@ def wait_for_rpc_connection(self):\n                     return\n                 self.rpc = rpc\n                 self.rpc_connected = True\n-                self.url = self.rpc.url\n+                self.url = self.rpc.rpc_url\n                 return\n             except JSONRPCException as e:  # Initialization phase\n                 # -28 RPC in warmup\n@@ -557,9 +557,8 @@ def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, **kwargs):\n         return p2p_conn\n \n     def add_outbound_p2p_connection(self, p2p_conn, *, p2p_idx, connection_type=\"outbound-full-relay\", **kwargs):\n-        \"\"\"Add an outbound p2p connection from node. Either\n-        full-relay(\"outbound-full-relay\") or\n-        block-relay-only(\"block-relay-only\") connection.\n+        \"\"\"Add an outbound p2p connection from node. Must be an\n+        \"outbound-full-relay\", \"block-relay-only\" or \"addr-fetch\" connection.\n \n         This method adds the p2p connection to the self.p2ps list and returns\n         the connection to the caller."
      },
      {
        "sha": "54f2fdee219240d8a95478992411ece43b4fbe34",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 23,
        "deletions": 16,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -5,7 +5,6 @@\n \"\"\"Helpful routines for regression testing.\"\"\"\n \n from base64 import b64encode\n-from binascii import unhexlify\n from decimal import Decimal, ROUND_DOWN\n from subprocess import CalledProcessError\n import hashlib\n@@ -214,10 +213,6 @@ def count_bytes(hex_string):\n     return len(bytearray.fromhex(hex_string))\n \n \n-def hex_str_to_bytes(hex_str):\n-    return unhexlify(hex_str.encode('ascii'))\n-\n-\n def str_to_b64str(string):\n     return b64encode(string.encode('utf-8')).decode('ascii')\n \n@@ -286,15 +281,15 @@ class PortSeed:\n     n = None\n \n \n-def get_rpc_proxy(url, node_number, *, timeout=None, coveragedir=None):\n+def get_rpc_proxy(url: str, node_number: int, *, timeout: int=None, coveragedir: str=None) -> coverage.AuthServiceProxyWrapper:\n     \"\"\"\n     Args:\n-        url (str): URL of the RPC server to call\n-        node_number (int): the node number (or id) that this calls to\n+        url: URL of the RPC server to call\n+        node_number: the node number (or id) that this calls to\n \n     Kwargs:\n-        timeout (int): HTTP timeout in seconds\n-        coveragedir (str): Directory\n+        timeout: HTTP timeout in seconds\n+        coveragedir: Directory\n \n     Returns:\n         AuthServiceProxy. convenience object for making RPC calls.\n@@ -305,11 +300,10 @@ def get_rpc_proxy(url, node_number, *, timeout=None, coveragedir=None):\n         proxy_kwargs['timeout'] = int(timeout)\n \n     proxy = AuthServiceProxy(url, **proxy_kwargs)\n-    proxy.url = url  # store URL on proxy for info\n \n     coverage_logfile = coverage.get_filename(coveragedir, node_number) if coveragedir else None\n \n-    return coverage.AuthServiceProxyWrapper(proxy, coverage_logfile)\n+    return coverage.AuthServiceProxyWrapper(proxy, url, coverage_logfile)\n \n \n def p2p_port(n):\n@@ -338,17 +332,17 @@ def rpc_url(datadir, i, chain, rpchost):\n ################\n \n \n-def initialize_datadir(dirname, n, chain):\n+def initialize_datadir(dirname, n, chain, disable_autoconnect=True):\n     datadir = get_datadir_path(dirname, n)\n     if not os.path.isdir(datadir):\n         os.makedirs(datadir)\n-    write_config(os.path.join(datadir, \"bitcoin.conf\"), n=n, chain=chain)\n+    write_config(os.path.join(datadir, \"bitcoin.conf\"), n=n, chain=chain, disable_autoconnect=disable_autoconnect)\n     os.makedirs(os.path.join(datadir, 'stderr'), exist_ok=True)\n     os.makedirs(os.path.join(datadir, 'stdout'), exist_ok=True)\n     return datadir\n \n \n-def write_config(config_path, *, n, chain, extra_config=\"\"):\n+def write_config(config_path, *, n, chain, extra_config=\"\", disable_autoconnect=True):\n     # Translate chain subdirectory name to config name\n     if chain == 'testnet3':\n         chain_name_conf_arg = 'testnet'\n@@ -376,6 +370,8 @@ def write_config(config_path, *, n, chain, extra_config=\"\"):\n         f.write(\"shrinkdebugfile=0\\n\")\n         # To improve SQLite wallet performance so that the tests don't timeout, use -unsafesqlitesync\n         f.write(\"unsafesqlitesync=1\\n\")\n+        if disable_autoconnect:\n+            f.write(\"connect=0\\n\")\n         f.write(extra_config)\n \n \n@@ -516,7 +512,7 @@ def gen_return_txouts():\n     from .messages import CTxOut\n     txout = CTxOut()\n     txout.nValue = 0\n-    txout.scriptPubKey = hex_str_to_bytes(script_pubkey)\n+    txout.scriptPubKey = bytes.fromhex(script_pubkey)\n     for _ in range(128):\n         txouts.append(txout)\n     return txouts\n@@ -559,6 +555,17 @@ def mine_large_block(node, utxos=None):\n     node.generate(1)\n \n \n+def generate_to_height(node, target_height):\n+    \"\"\"Generates blocks until a given target block height has been reached.\n+       To prevent timeouts, only up to 200 blocks are generated per RPC call.\n+       Can be used to activate certain soft-forks (e.g. CSV, CLTV).\"\"\"\n+    current_height = node.getblockcount()\n+    while current_height < target_height:\n+        nblocks = min(200, target_height - current_height)\n+        current_height += len(node.generate(nblocks))\n+    assert_equal(node.getblockcount(), target_height)\n+\n+\n def find_vout_for_address(node, txid, addr):\n     \"\"\"\n     Locate the vout index of the given transaction sending to the"
      },
      {
        "sha": "609553c6d01b7bfa6de3f6348dc5c1733e409a3b",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -27,7 +27,6 @@\n )\n from test_framework.util import (\n     assert_equal,\n-    hex_str_to_bytes,\n     satoshi_round,\n )\n \n@@ -73,7 +72,7 @@ def __init__(self, test_node, *, mode=MiniWalletMode.ADDRESS_OP_TRUE):\n             self._scriptPubKey = bytes(CScript([pub_key.get_bytes(), OP_CHECKSIG]))\n         elif mode == MiniWalletMode.ADDRESS_OP_TRUE:\n             self._address = ADDRESS_BCRT1_P2WSH_OP_TRUE\n-            self._scriptPubKey = hex_str_to_bytes(self._test_node.validateaddress(self._address)['scriptPubKey'])\n+            self._scriptPubKey = bytes.fromhex(self._test_node.validateaddress(self._address)['scriptPubKey'])\n \n     def scan_blocks(self, *, start=1, num):\n         \"\"\"Scan the blocks for self._address outputs and add them to self._utxos\"\"\""
      },
      {
        "sha": "1ee55aa3b7529832a9f0b6ed0d69519fb5bf9611",
        "filename": "test/functional/test_framework/wallet_util.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/wallet_util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_framework/wallet_util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet_util.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -27,7 +27,6 @@\n     script_to_p2sh_script,\n     script_to_p2wsh_script,\n )\n-from test_framework.util import hex_str_to_bytes\n \n Key = namedtuple('Key', ['privkey',\n                          'pubkey',\n@@ -93,7 +92,7 @@ def get_multisig(node):\n         addr = node.getaddressinfo(node.getnewaddress())\n         addrs.append(addr['address'])\n         pubkeys.append(addr['pubkey'])\n-    script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n+    script_code = CScript([OP_2] + [bytes.fromhex(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n     witness_script = script_to_p2wsh_script(script_code)\n     return Multisig(privkeys=[node.dumpprivkey(addr) for addr in addrs],\n                     pubkeys=pubkeys,"
      },
      {
        "sha": "fecf52d53aa1c90f99bcb31d55d4f81fce66ce44",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -109,8 +109,6 @@\n     'p2p_tx_download.py',\n     'mempool_updatefromblock.py',\n     'wallet_dump.py --legacy-wallet',\n-    'wallet_listtransactions.py --legacy-wallet',\n-    'wallet_listtransactions.py --descriptors',\n     'feature_taproot.py --previous_release',\n     'feature_taproot.py',\n     'rpc_signer.py',\n@@ -123,6 +121,7 @@\n     'wallet_listreceivedby.py --legacy-wallet',\n     'wallet_listreceivedby.py --descriptors',\n     'wallet_abandonconflict.py --legacy-wallet',\n+    'p2p_dns_seeds.py',\n     'wallet_abandonconflict.py --descriptors',\n     'feature_csv_activation.py',\n     'wallet_address_types.py --legacy-wallet',\n@@ -159,6 +158,8 @@\n     'wallet_createwallet.py --legacy-wallet',\n     'wallet_createwallet.py --usecli',\n     'wallet_createwallet.py --descriptors',\n+    'wallet_listtransactions.py --legacy-wallet',\n+    'wallet_listtransactions.py --descriptors',\n     'wallet_watchonly.py --legacy-wallet',\n     'wallet_watchonly.py --usecli --legacy-wallet',\n     'wallet_reorgsrestore.py',\n@@ -186,6 +187,7 @@\n     'p2p_addr_relay.py',\n     'p2p_getaddr_caching.py',\n     'p2p_getdata.py',\n+    'p2p_addrfetch.py',\n     'rpc_net.py',\n     'wallet_keypool.py --legacy-wallet',\n     'wallet_keypool.py --descriptors',\n@@ -296,6 +298,7 @@\n     'wallet_startup.py',\n     'p2p_i2p_ports.py',\n     'feature_config_args.py',\n+    'feature_presegwit_node_upgrade.py',\n     'feature_settings.py',\n     'rpc_getdescriptorinfo.py',\n     'rpc_addresses_deprecation.py',"
      },
      {
        "sha": "91d61216790f034a8a4bfcd9fa52b8dbcda0b174",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -209,6 +209,15 @@ def run_test(self):\n         with self.nodes[0].assert_debug_log(['Flushing wallet.dat'], timeout=20):\n             self.nodes[0].getnewaddress()\n \n+        # Make sure that dumpwallet doesn't have a lock order issue when there is an unconfirmed tx and it is reloaded\n+        # See https://github.com/bitcoin/bitcoin/issues/22489\n+        self.nodes[0].createwallet(\"w3\")\n+        w3 = self.nodes[0].get_wallet_rpc(\"w3\")\n+        w3.importprivkey(privkey=self.nodes[0].get_deterministic_priv_key().key, label=\"coinbase_import\")\n+        w3.sendtoaddress(w3.getnewaddress(), 10)\n+        w3.unloadwallet()\n+        self.nodes[0].loadwallet(\"w3\")\n+        w3.dumpwallet(os.path.join(self.nodes[0].datadir, \"w3.dump\"))\n \n if __name__ == '__main__':\n     WalletDumpTest().main()"
      },
      {
        "sha": "c0386f5d7028d8a9a9790c47410ecd10412b457c",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 20,
        "deletions": 15,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -18,14 +18,15 @@\n class ListTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n+        # This test isn't testing txn relay/timing, so set whitelist on the\n+        # peers for instant txn relay. This speeds up the test run time 2-3x.\n+        self.extra_args = [[\"-whitelist=noban@127.0.0.1\"]] * self.num_nodes\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n-        self.nodes[0].generate(1)  # Get out of IBD\n-        self.sync_all()\n-        # Simple send, 0 to 1:\n+        self.log.info(\"Test simple send from node0 to node1\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n@@ -34,7 +35,7 @@ def run_test(self):\n         assert_array_result(self.nodes[1].listtransactions(),\n                             {\"txid\": txid},\n                             {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n-        # mine a block, confirmations should change:\n+        self.log.info(\"Test confirmations change after mining a block\")\n         blockhash = self.nodes[0].generate(1)[0]\n         blockheight = self.nodes[0].getblockheader(blockhash)['height']\n         self.sync_all()\n@@ -45,7 +46,7 @@ def run_test(self):\n                             {\"txid\": txid},\n                             {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 1, \"blockhash\": blockhash, \"blockheight\": blockheight})\n \n-        # send-to-self:\n+        self.log.info(\"Test send-to-self on node0\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n         assert_array_result(self.nodes[0].listtransactions(),\n                             {\"txid\": txid, \"category\": \"send\"},\n@@ -54,7 +55,7 @@ def run_test(self):\n                             {\"txid\": txid, \"category\": \"receive\"},\n                             {\"amount\": Decimal(\"0.2\")})\n \n-        # sendmany from node1: twice to self, twice to node2:\n+        self.log.info(\"Test sendmany from node1: twice to self, twice to node0\")\n         send_to = {self.nodes[0].getnewaddress(): 0.11,\n                    self.nodes[1].getnewaddress(): 0.22,\n                    self.nodes[0].getnewaddress(): 0.33,\n@@ -88,6 +89,7 @@ def run_test(self):\n \n         if not self.options.descriptors:\n             # include_watchonly is a legacy wallet feature, so don't test it for descriptor wallets\n+            self.log.info(\"Test 'include_watchonly' feature (legacy wallet)\")\n             pubkey = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n             multisig = self.nodes[1].createmultisig(1, [pubkey])\n             self.nodes[0].importaddress(multisig[\"redeemScript\"], \"watchonly\", False, True)\n@@ -103,37 +105,38 @@ def run_test(self):\n \n         self.run_rbf_opt_in_test()\n \n-    # Check that the opt-in-rbf flag works properly, for sent and received\n-    # transactions.\n+\n     def run_rbf_opt_in_test(self):\n-        # Check whether a transaction signals opt-in RBF itself\n+        \"\"\"Test the opt-in-rbf flag for sent and received transactions.\"\"\"\n+\n         def is_opt_in(node, txid):\n+            \"\"\"Check whether a transaction signals opt-in RBF itself.\"\"\"\n             rawtx = node.getrawtransaction(txid, 1)\n             for x in rawtx[\"vin\"]:\n                 if x[\"sequence\"] < 0xfffffffe:\n                     return True\n             return False\n \n-        # Find an unconfirmed output matching a certain txid\n         def get_unconfirmed_utxo_entry(node, txid_to_match):\n+            \"\"\"Find an unconfirmed output matching a certain txid.\"\"\"\n             utxo = node.listunspent(0, 0)\n             for i in utxo:\n                 if i[\"txid\"] == txid_to_match:\n                     return i\n             return None\n \n-        # 1. Chain a few transactions that don't opt-in.\n+        self.log.info(\"Test txs w/o opt-in RBF (bip125-replaceable=no)\")\n+        # Chain a few transactions that don't opt in.\n         txid_1 = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n         assert not is_opt_in(self.nodes[0], txid_1)\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\": \"no\"})\n         self.sync_mempools()\n         assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_1}, {\"bip125-replaceable\": \"no\"})\n \n-        # Tx2 will build off txid_1, still not opting in to RBF.\n+        # Tx2 will build off tx1, still not opting in to RBF.\n         utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[0], txid_1)\n         assert_equal(utxo_to_use[\"safe\"], True)\n         utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[1], txid_1)\n-        utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[1], txid_1)\n         assert_equal(utxo_to_use[\"safe\"], False)\n \n         # Create tx2 using createrawtransaction\n@@ -149,6 +152,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         self.sync_mempools()\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_2}, {\"bip125-replaceable\": \"no\"})\n \n+        self.log.info(\"Test txs with opt-in RBF (bip125-replaceable=yes)\")\n         # Tx3 will opt-in to RBF\n         utxo_to_use = get_unconfirmed_utxo_entry(self.nodes[0], txid_2)\n         inputs = [{\"txid\": txid_2, \"vout\": utxo_to_use[\"vout\"]}]\n@@ -179,6 +183,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         self.sync_mempools()\n         assert_array_result(self.nodes[0].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"yes\"})\n \n+        self.log.info(\"Test tx with unknown RBF state (bip125-replaceable=unknown)\")\n         # Replace tx3, and check that tx4 becomes unknown\n         tx3_b = tx3_modified\n         tx3_b.vout[0].nValue -= int(Decimal(\"0.004\") * COIN)  # bump the fee\n@@ -191,15 +196,15 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n         self.sync_mempools()\n         assert_array_result(self.nodes[1].listtransactions(), {\"txid\": txid_4}, {\"bip125-replaceable\": \"unknown\"})\n \n-        # Check gettransaction as well:\n+        self.log.info(\"Test bip125-replaceable status with gettransaction RPC\")\n         for n in self.nodes[0:2]:\n             assert_equal(n.gettransaction(txid_1)[\"bip125-replaceable\"], \"no\")\n             assert_equal(n.gettransaction(txid_2)[\"bip125-replaceable\"], \"no\")\n             assert_equal(n.gettransaction(txid_3)[\"bip125-replaceable\"], \"yes\")\n             assert_equal(n.gettransaction(txid_3b)[\"bip125-replaceable\"], \"yes\")\n             assert_equal(n.gettransaction(txid_4)[\"bip125-replaceable\"], \"unknown\")\n \n-        # After mining a transaction, it's no longer BIP125-replaceable\n+        self.log.info(\"Test mined transactions are no longer bip125-replaceable\")\n         self.nodes[0].generate(1)\n         assert txid_3b not in self.nodes[0].getrawmempool()\n         assert_equal(self.nodes[0].gettransaction(txid_3b)[\"bip125-replaceable\"], \"no\")"
      },
      {
        "sha": "4d34670ea944b53e673f4cdf38d33565485e0b80",
        "filename": "test/functional/wallet_upgradewallet.py",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/functional/wallet_upgradewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/functional/wallet_upgradewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_upgradewallet.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -94,10 +94,11 @@ def dumb_sync_blocks(self):\n     def test_upgradewallet(self, wallet, previous_version, requested_version=None, expected_version=None):\n         unchanged = expected_version == previous_version\n         new_version = previous_version if unchanged else expected_version if expected_version else requested_version\n-        assert_equal(wallet.getwalletinfo()[\"walletversion\"], previous_version)\n+        old_wallet_info = wallet.getwalletinfo()\n+        assert_equal(old_wallet_info[\"walletversion\"], previous_version)\n         assert_equal(wallet.upgradewallet(requested_version),\n             {\n-                \"wallet_name\": \"\",\n+                \"wallet_name\": old_wallet_info[\"walletname\"],\n                 \"previous_version\": previous_version,\n                 \"current_version\": new_version,\n                 \"result\": \"Already at latest version. Wallet version unchanged.\" if unchanged else \"Wallet upgraded successfully from version {} to version {}.\".format(previous_version, new_version),\n@@ -352,6 +353,11 @@ def copy_split_hd():\n         v16_3_kvs = dump_bdb_kv(v16_3_wallet)\n         assert b'\\x0adefaultkey' not in v16_3_kvs\n \n+        if self.is_sqlite_compiled():\n+            self.log.info(\"Checking that descriptor wallets do nothing, successfully\")\n+            self.nodes[0].createwallet(wallet_name=\"desc_upgrade\", descriptors=True)\n+            desc_wallet = self.nodes[0].get_wallet_rpc(\"desc_upgrade\")\n+            self.test_upgradewallet(desc_wallet, previous_version=169900, expected_version=169900)\n \n if __name__ == '__main__':\n     UpgradeWalletTest().main()"
      },
      {
        "sha": "e92bb402b5888480d2b15eec61b45208cf9d5738",
        "filename": "test/get_previous_releases.py",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/get_previous_releases.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/get_previous_releases.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/get_previous_releases.py?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -112,7 +112,11 @@ def download_binary(tag, args) -> int:\n     tarballHash = hasher.hexdigest()\n \n     if tarballHash not in SHA256_SUMS or SHA256_SUMS[tarballHash] != tarball:\n-        print(\"Checksum did not match\")\n+        if tarball in SHA256_SUMS.values():\n+            print(\"Checksum did not match\")\n+            return 1\n+\n+        print(\"Checksum for given version doesn't exist\")\n         return 1\n     print(\"Checksum matched\")\n "
      },
      {
        "sha": "df5051720b3ee610008fd29ab3f24db60dfe1c62",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -10,7 +10,6 @@ export LC_ALL=C\n \n EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"chainparamsbase -> util/system -> chainparamsbase\"\n-    \"index/txindex -> validation -> index/txindex\"\n     \"node/blockstorage -> validation -> node/blockstorage\"\n     \"index/blockfilterindex -> node/blockstorage -> validation -> index/blockfilterindex\"\n     \"index/base -> validation -> index/blockfilterindex -> index/base\""
      },
      {
        "sha": "111091b7f8a4e6b90e1bc243712524cac4731a5c",
        "filename": "test/lint/lint-spelling.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/lint/lint-spelling.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/lint/lint-spelling.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-spelling.sh?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -15,6 +15,6 @@ if ! command -v codespell > /dev/null; then\n fi\n \n IGNORE_WORDS_FILE=test/lint/lint-spelling.ignore-words.txt\n-if ! codespell --check-filenames --disable-colors --quiet-level=7 --ignore-words=${IGNORE_WORDS_FILE} $(git ls-files -- \":(exclude)build-aux/m4/\" \":(exclude)contrib/seeds/*.txt\" \":(exclude)depends/\" \":(exclude)doc/release-notes/\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/qt/locale/\" \":(exclude)src/qt/*.qrc\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)contrib/gitian-keys/keys.txt\" \":(exclude)contrib/guix/patches\"); then\n+if ! codespell --check-filenames --disable-colors --quiet-level=7 --ignore-words=${IGNORE_WORDS_FILE} $(git ls-files -- \":(exclude)build-aux/m4/\" \":(exclude)contrib/seeds/*.txt\" \":(exclude)depends/\" \":(exclude)doc/release-notes/\" \":(exclude)src/leveldb/\" \":(exclude)src/crc32c/\" \":(exclude)src/qt/locale/\" \":(exclude)src/qt/*.qrc\" \":(exclude)src/secp256k1/\" \":(exclude)src/univalue/\" \":(exclude)contrib/builder-keys/keys.txt\" \":(exclude)contrib/guix/patches\"); then\n     echo \"^ Warning: codespell identified likely spelling errors. Any false positives? Add them to the list of ignored words in ${IGNORE_WORDS_FILE}\"\n fi"
      },
      {
        "sha": "b52e105a33ef083521d6853716ee4220595fe959",
        "filename": "test/sanitizer_suppressions/ubsan",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/971aab70b008e608263840030f04bf67e67c9515/test/sanitizer_suppressions/ubsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/971aab70b008e608263840030f04bf67e67c9515/test/sanitizer_suppressions/ubsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/ubsan?ref=971aab70b008e608263840030f04bf67e67c9515",
        "patch": "@@ -89,6 +89,7 @@ implicit-signed-integer-truncation:leveldb/\n implicit-signed-integer-truncation:miner.cpp\n implicit-signed-integer-truncation:net.cpp\n implicit-signed-integer-truncation:net_processing.cpp\n+implicit-signed-integer-truncation:netaddress.cpp\n implicit-signed-integer-truncation:streams.h\n implicit-signed-integer-truncation:test/arith_uint256_tests.cpp\n implicit-signed-integer-truncation:test/skiplist_tests.cpp"
      }
    ]
  }
]