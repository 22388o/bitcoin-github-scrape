sdaftuar,2019-01-25T20:09:31Z,@sipa @gmaxwell Thoughts?,https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457709953,457709953,
andcoisqu,2019-01-25T20:30:05Z,"If I understand correctly, this would remove the performance hit that https://github.com/bitcoin/bitcoin/pull/15218 would introduce?",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457716622,457716622,
sdaftuar,2019-01-25T20:34:27Z,"> If I understand correctly, this would remove the performance hit that #15218 would introduce?\n\nThat's the idea.  I'm not totally sure this doesn't introduce other problems, however -- right now I'm watching a pruning node do an IBD with this patch (with a large `-dbcache`), and I'm observing that the frequent utxo writes (as files get pruned) are very slow, presumably because it's looping th",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457718002,457718002,
sipa,2019-01-25T20:42:41Z,"@sdaftuar By adding two pointers per CCoinsCacheEntry object we can construct two double-linked lists in the cache, one for all dirty and one for all clean entries. An alternative is separate maps for the two (which is lower memory usage, but now needs two lookups every time).",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457720636,457720636,
gmaxwell,2019-01-26T02:23:40Z,"I tested something like this before and I think I found it had almost(?) as much negative impact to sync time as the full flush.  This isn't too surprising if you assume that the purpose of the dbcache is a write buffer for the purpose of eliminating writes on short lived objects (and the additional writes to delete them), rather than a read cache.  Maybe on a slow disk the read cache component is",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457792904,457792904,
sipa,2019-01-26T02:36:36Z,"@gmaxwell I think that's all true, but not really relevant here.\n\nThe goal isn't speeding up synchronization given the choice of flushing or not flushing entirely. In that case we've already shown several times that not flushing is indeed better.\n\nThe scenario here is what to do when we're forced to flush due to other reasons than the cache being full. And it would seem to me that flushing wit",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457793902,457793902,
gmaxwell,2019-01-26T02:57:07Z,">  And it would seem to me that flushing without wiping should be strictly better than flushing with wiping in that case. \n\nI believe we found otherwise in benchmarking.  If that isn't actually the case, great, better is better.",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-457795318,457795318,
sdaftuar,2019-01-29T18:42:05Z,"I've done some benchmarking on the pruning component of this, comparing a pruning node with big dbcache doing an initial sync using either master or a version of this PR that has been modified to be able to loop over just the dirty entries in the cache when doing a BatchWrite. @gmaxwell's recollection that preserving the read-cache benefit is of limited benefit seems correct both on SSD and spinni",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-458657451,458657451,
Sjors,2019-11-19T16:31:06Z,"I rebased this on top of #17487 in case someone wants to take another stab at benchmarking: https://github.com/Sjors/bitcoin/tree/2019/11/prune-no-erase\n\nWith the recent merge of Android support #17078 mobile devices would make an interesting benchmark. In my experience on a Xiaomi A1 (4 GB RAM, 32 / 64 GB disk) IBD becomes unbearingly slow after block 500,000 or so. This might be partly due t",https://github.com/bitcoin/bitcoin/pull/15265#issuecomment-555591156,555591156,
