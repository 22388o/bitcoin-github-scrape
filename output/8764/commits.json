[
  {
    "sha": "c8b5b746acb41de1744db16301ca127d4f9c08f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOGI1Yjc0NmFjYjQxZGUxNzQ0ZGIxNjMwMWNhMTI3ZDRmOWMwOGYw",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-09-20T12:29:24Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-11-04T07:53:37Z"
      },
      "message": "[Wallet] get rid of pwalletMain, add simple CWallets infrastructure",
      "tree": {
        "sha": "678a03ab9e22cd5d87ce24dffd5e2c1e08604d3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/678a03ab9e22cd5d87ce24dffd5e2c1e08604d3d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c8b5b746acb41de1744db16301ca127d4f9c08f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJYHD6FAAoJECnUvLZBb1PspqAQAINruVP/7K85AQ0x1UWGivgl\nL0Q6TfPvGfwFhnn+9mGSwODK+fqV3UGOYaO7lxuyrv3B+NW35SX0Ys4bEsEyV2pj\nrh0ZwB5KfainCwNMbxm/1RRXNA9zOBVEOZyBaGj8s9lGHA7Ps4eaSvOdmkYAS0Fm\nOYSoMfr7PeYFb2TPtyBrw2fBCw3ezB23z7OH+D9awjcP9km0EV6kGgz3fmRwAo6y\ncS53EautZRFum5ffzdEfRVkCzxZ+rZPADAqfgfnFPCJ6ty/+Qvuf9ce8a84O8LW9\nCIkdeMNgaORP94o6jnujMFL2m+av5QX7vqMmvSFlEYMjXTavKHeWmU9DcCdUmUtX\n2xY0OSXltVKDcz0nvIDQsD8iHIER5gQMv0nRLnfieHS1JCEOZ2W2bAUbaBRJYRO0\njIIFtyxZ6qFSEkUqY0DymXXs4btmTNZRlZ6oWOu1Y0EaG9w8TPd/n3Ohet7zL1O9\nNXHEjCY2xv09WInNwkr7VrpW8eg0IhZgccu4Msv+OQlFYuid6NrnybsWE40j2cG7\n7touDeSNmDT5armxvoLSisiTgNjCWD2pROQgI4+CNRCbeFwpborD4Yvywk4DZOTm\nY+dgXQkMK2tMNgS8xn72Gm8bAfBkMRtGlZrCCHG5ZzUQJzE/ge8Pdqi66gIQOblw\nNxNuoIUP2+R9wiR2qd6e\n=DQMg\n-----END PGP SIGNATURE-----",
        "payload": "tree 678a03ab9e22cd5d87ce24dffd5e2c1e08604d3d\nparent 3665483be7be177dfa6cb608818e04f68f173c53\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1474374564 +0200\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1478246017 +0100\n\n[Wallet] get rid of pwalletMain, add simple CWallets infrastructure\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8b5b746acb41de1744db16301ca127d4f9c08f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c8b5b746acb41de1744db16301ca127d4f9c08f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8b5b746acb41de1744db16301ca127d4f9c08f0/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3665483be7be177dfa6cb608818e04f68f173c53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3665483be7be177dfa6cb608818e04f68f173c53",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3665483be7be177dfa6cb608818e04f68f173c53"
      }
    ],
    "stats": {
      "total": 586,
      "additions": 307,
      "deletions": 279
    },
    "files": [
      {
        "sha": "659ddcf25716d0b59f99c718a8542673d048e8c6",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -197,8 +197,7 @@ void Shutdown()\n     StopRPC();\n     StopHTTPServer();\n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(false);\n+    CWallets::flushAllWallets(false);\n #endif\n     MapPort(false);\n     UnregisterValidationInterface(peerLogic.get());\n@@ -235,8 +234,7 @@ void Shutdown()\n         pblocktree = NULL;\n     }\n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(true);\n+    CWallets::flushAllWallets(true);\n #endif\n \n #if ENABLE_ZMQ\n@@ -256,8 +254,7 @@ void Shutdown()\n #endif\n     UnregisterAllValidationInterfaces();\n #ifdef ENABLE_WALLET\n-    delete pwalletMain;\n-    pwalletMain = NULL;\n+    CWallets::destruct();\n #endif\n     globalVerifyHandle.reset();\n     ECC_Stop();\n@@ -1537,8 +1534,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->postInitProcess(threadGroup);\n+    if (CWallets::defaultWallet())\n+        CWallets::defaultWallet()->postInitProcess(threadGroup);\n #endif\n \n     return !fRequestShutdown;"
      },
      {
        "sha": "710e5c5b86625fae5dd76b5100d83e5922e44e8a",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -448,9 +448,9 @@ void BitcoinApplication::initializeResult(int retval)\n         window->setClientModel(clientModel);\n \n #ifdef ENABLE_WALLET\n-        if(pwalletMain)\n+        if(CWallets::defaultWallet())\n         {\n-            walletModel = new WalletModel(platformStyle, pwalletMain, optionsModel);\n+            walletModel = new WalletModel(platformStyle, CWallets::defaultWallet(), optionsModel);\n \n             window->addWallet(BitcoinGUI::DEFAULT_WALLET, walletModel);\n             window->setCurrentWallet(BitcoinGUI::DEFAULT_WALLET);"
      },
      {
        "sha": "9452c185f333d78b3cf4cfa4e5cfd929ac84c7dd",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -70,7 +70,7 @@ UniValue getinfo(const JSONRPCRequest& request)\n         );\n \n #ifdef ENABLE_WALLET\n-    LOCK2(cs_main, pwalletMain ? &pwalletMain->cs_wallet : NULL);\n+    LOCK2(cs_main, CWallets::defaultWallet() ? &CWallets::defaultWallet()->cs_wallet : NULL);\n #else\n     LOCK(cs_main);\n #endif\n@@ -82,9 +82,9 @@ UniValue getinfo(const JSONRPCRequest& request)\n     obj.push_back(Pair(\"version\", CLIENT_VERSION));\n     obj.push_back(Pair(\"protocolversion\", PROTOCOL_VERSION));\n #ifdef ENABLE_WALLET\n-    if (pwalletMain) {\n-        obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n-        obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n+    if (CWallets::defaultWallet()) {\n+        obj.push_back(Pair(\"walletversion\", CWallets::defaultWallet()->GetVersion()));\n+        obj.push_back(Pair(\"balance\",       ValueFromAmount(CWallets::defaultWallet()->GetBalance())));\n     }\n #endif\n     obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n@@ -95,11 +95,11 @@ UniValue getinfo(const JSONRPCRequest& request)\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"testnet\",       Params().NetworkIDString() == CBaseChainParams::TESTNET));\n #ifdef ENABLE_WALLET\n-    if (pwalletMain) {\n-        obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n-        obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain->GetKeyPoolSize()));\n+    if (CWallets::defaultWallet()) {\n+        obj.push_back(Pair(\"keypoololdest\", CWallets::defaultWallet()->GetOldestKeyPoolTime()));\n+        obj.push_back(Pair(\"keypoolsize\",   (int)CWallets::defaultWallet()->GetKeyPoolSize()));\n     }\n-    if (pwalletMain && pwalletMain->IsCrypted())\n+    if (CWallets::defaultWallet() && CWallets::defaultWallet()->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n #endif\n@@ -118,7 +118,7 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n         UniValue obj(UniValue::VOBJ);\n         CPubKey vchPubKey;\n         obj.push_back(Pair(\"isscript\", false));\n-        if (pwalletMain && pwalletMain->GetPubKey(keyID, vchPubKey)) {\n+        if (CWallets::defaultWallet() && CWallets::defaultWallet()->GetPubKey(keyID, vchPubKey)) {\n             obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n             obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n         }\n@@ -129,7 +129,7 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n         UniValue obj(UniValue::VOBJ);\n         CScript subscript;\n         obj.push_back(Pair(\"isscript\", true));\n-        if (pwalletMain && pwalletMain->GetCScript(scriptID, subscript)) {\n+        if (CWallets::defaultWallet() && CWallets::defaultWallet()->GetCScript(scriptID, subscript)) {\n             std::vector<CTxDestination> addresses;\n             txnouttype whichType;\n             int nRequired;\n@@ -176,7 +176,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n         );\n \n #ifdef ENABLE_WALLET\n-    LOCK2(cs_main, pwalletMain ? &pwalletMain->cs_wallet : NULL);\n+    LOCK2(cs_main, CWallets::defaultWallet() ? &CWallets::defaultWallet()->cs_wallet : NULL);\n #else\n     LOCK(cs_main);\n #endif\n@@ -196,18 +196,18 @@ UniValue validateaddress(const JSONRPCRequest& request)\n         ret.push_back(Pair(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n \n #ifdef ENABLE_WALLET\n-        isminetype mine = pwalletMain ? IsMine(*pwalletMain, dest) : ISMINE_NO;\n+        isminetype mine = CWallets::defaultWallet() ? IsMine(*CWallets::defaultWallet(), dest) : ISMINE_NO;\n         ret.push_back(Pair(\"ismine\", (mine & ISMINE_SPENDABLE) ? true : false));\n         ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true: false));\n         UniValue detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n         ret.pushKVs(detail);\n-        if (pwalletMain && pwalletMain->mapAddressBook.count(dest))\n-            ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[dest].name));\n+        if (CWallets::defaultWallet() && CWallets::defaultWallet()->mapAddressBook.count(dest))\n+            ret.push_back(Pair(\"account\", CWallets::defaultWallet()->mapAddressBook[dest].name));\n         CKeyID keyID;\n-        if (pwalletMain && address.GetKeyID(keyID) && pwalletMain->mapKeyMetadata.count(keyID) && !pwalletMain->mapKeyMetadata[keyID].hdKeypath.empty())\n+        if (CWallets::defaultWallet() && address.GetKeyID(keyID) && CWallets::defaultWallet()->mapKeyMetadata.count(keyID) && !CWallets::defaultWallet()->mapKeyMetadata[keyID].hdKeypath.empty())\n         {\n-            ret.push_back(Pair(\"hdkeypath\", pwalletMain->mapKeyMetadata[keyID].hdKeypath));\n-            ret.push_back(Pair(\"hdmasterkeyid\", pwalletMain->mapKeyMetadata[keyID].hdMasterKeyID.GetHex()));\n+            ret.push_back(Pair(\"hdkeypath\", CWallets::defaultWallet()->mapKeyMetadata[keyID].hdKeypath));\n+            ret.push_back(Pair(\"hdmasterkeyid\", CWallets::defaultWallet()->mapKeyMetadata[keyID].hdMasterKeyID.GetHex()));\n         }\n #endif\n     }\n@@ -239,14 +239,14 @@ CScript _createmultisig_redeemScript(const UniValue& params)\n #ifdef ENABLE_WALLET\n         // Case 1: Bitcoin address and we have full public key:\n         CBitcoinAddress address(ks);\n-        if (pwalletMain && address.IsValid())\n+        if (CWallets::defaultWallet() && address.IsValid())\n         {\n             CKeyID keyID;\n             if (!address.GetKeyID(keyID))\n                 throw runtime_error(\n                     strprintf(\"%s does not refer to a key\",ks));\n             CPubKey vchPubKey;\n-            if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n+            if (!CWallets::defaultWallet()->GetPubKey(keyID, vchPubKey))\n                 throw runtime_error(\n                     strprintf(\"no full public key for address %s\",ks));\n             if (!vchPubKey.IsFullyValid())"
      },
      {
        "sha": "d0cdd2d907707947300180df22c30672f8d3230d",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -640,7 +640,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         );\n \n #ifdef ENABLE_WALLET\n-    LOCK2(cs_main, pwalletMain ? &pwalletMain->cs_wallet : NULL);\n+    LOCK2(cs_main, CWallets::defaultWallet() ? &CWallets::defaultWallet()->cs_wallet : NULL);\n #else\n     LOCK(cs_main);\n #endif\n@@ -703,7 +703,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         }\n     }\n #ifdef ENABLE_WALLET\n-    else if (pwalletMain)\n+    else if (CWallets::defaultWallet())\n         EnsureWalletIsUnlocked();\n #endif\n \n@@ -771,7 +771,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     }\n \n #ifdef ENABLE_WALLET\n-    const CKeyStore& keystore = ((fGivenKeys || !pwalletMain) ? tempKeystore : *pwalletMain);\n+    const CKeyStore& keystore = ((fGivenKeys || !CWallets::defaultWallet()) ? tempKeystore : *CWallets::defaultWallet());\n #else\n     const CKeyStore& keystore = tempKeystore;\n #endif"
      },
      {
        "sha": "5a20ab362fb0f85e3c0cbb9f9e8d8a6ef18deffd",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 85,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -101,7 +101,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         );\n \n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     EnsureWalletIsUnlocked();\n \n@@ -130,23 +130,23 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     assert(key.VerifyPubKey(pubkey));\n     CKeyID vchAddress = pubkey.GetID();\n     {\n-        pwalletMain->MarkDirty();\n-        pwalletMain->SetAddressBook(vchAddress, strLabel, \"receive\");\n+        CWallets::defaultWallet()->MarkDirty();\n+        CWallets::defaultWallet()->SetAddressBook(vchAddress, strLabel, \"receive\");\n \n         // Don't throw error in case a key is already there\n-        if (pwalletMain->HaveKey(vchAddress))\n+        if (CWallets::defaultWallet()->HaveKey(vchAddress))\n             return NullUniValue;\n \n-        pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = 1;\n+        CWallets::defaultWallet()->mapKeyMetadata[vchAddress].nCreateTime = 1;\n \n-        if (!pwalletMain->AddKeyPubKey(key, pubkey))\n+        if (!CWallets::defaultWallet()->AddKeyPubKey(key, pubkey))\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n \n         // whenever a key is imported, we need to scan the whole chain\n-        pwalletMain->nTimeFirstKey = 1; // 0 would be considered 'no value'\n+        CWallets::defaultWallet()->nTimeFirstKey = 1; // 0 would be considered 'no value'\n \n         if (fRescan) {\n-            pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n+            CWallets::defaultWallet()->ScanForWalletTransactions(chainActive.Genesis(), true);\n         }\n     }\n \n@@ -156,22 +156,22 @@ UniValue importprivkey(const JSONRPCRequest& request)\n void ImportAddress(const CBitcoinAddress& address, const string& strLabel);\n void ImportScript(const CScript& script, const string& strLabel, bool isRedeemScript)\n {\n-    if (!isRedeemScript && ::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE)\n+    if (!isRedeemScript && ::IsMine(*CWallets::defaultWallet(), script) == ISMINE_SPENDABLE)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n \n-    pwalletMain->MarkDirty();\n+    CWallets::defaultWallet()->MarkDirty();\n \n-    if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script))\n+    if (!CWallets::defaultWallet()->HaveWatchOnly(script) && !CWallets::defaultWallet()->AddWatchOnly(script))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n \n     if (isRedeemScript) {\n-        if (!pwalletMain->HaveCScript(script) && !pwalletMain->AddCScript(script))\n+        if (!CWallets::defaultWallet()->HaveCScript(script) && !CWallets::defaultWallet()->AddCScript(script))\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n         ImportAddress(CBitcoinAddress(CScriptID(script)), strLabel);\n     } else {\n         CTxDestination destination;\n         if (ExtractDestination(script, destination)) {\n-            pwalletMain->SetAddressBook(destination, strLabel, \"receive\");\n+            CWallets::defaultWallet()->SetAddressBook(destination, strLabel, \"receive\");\n         }\n     }\n }\n@@ -182,7 +182,7 @@ void ImportAddress(const CBitcoinAddress& address, const string& strLabel)\n     ImportScript(script, strLabel, false);\n     // add to address book or update label\n     if (address.IsValid())\n-        pwalletMain->SetAddressBook(address.Get(), strLabel, \"receive\");\n+        CWallets::defaultWallet()->SetAddressBook(address.Get(), strLabel, \"receive\");\n }\n \n UniValue importaddress(const JSONRPCRequest& request)\n@@ -230,7 +230,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n     if (request.params.size() > 3)\n         fP2SH = request.params[3].get_bool();\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     CBitcoinAddress address(request.params[0].get_str());\n     if (address.IsValid()) {\n@@ -246,8 +246,8 @@ UniValue importaddress(const JSONRPCRequest& request)\n \n     if (fRescan)\n     {\n-        pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n-        pwalletMain->ReacceptWalletTransactions();\n+        CWallets::defaultWallet()->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        CWallets::defaultWallet()->ReacceptWalletTransactions();\n     }\n \n     return NullUniValue;\n@@ -271,7 +271,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     if (!DecodeHexTx(tx, request.params[0].get_str()))\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n     uint256 hashTx = tx.GetHash();\n-    CWalletTx wtx(pwalletMain,tx);\n+    CWalletTx wtx(CWallets::defaultWallet(), tx);\n \n     CDataStream ssMB(ParseHexV(request.params[1], \"proof\"), SER_NETWORK, PROTOCOL_VERSION);\n     CMerkleBlock merkleBlock;\n@@ -302,10 +302,10 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     wtx.nIndex = txnIndex;\n     wtx.hashBlock = merkleBlock.header.GetHash();\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n-    if (pwalletMain->IsMine(tx)) {\n-        pwalletMain->AddToWallet(wtx, false);\n+    if (CWallets::defaultWallet()->IsMine(tx)) {\n+        CWallets::defaultWallet()->AddToWallet(wtx, false);\n         return NullUniValue;\n     }\n \n@@ -329,15 +329,15 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"removprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n     vector<uint256> vHash;\n     vHash.push_back(hash);\n     vector<uint256> vHashOut;\n \n-    if(pwalletMain->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n+    if(CWallets::defaultWallet()->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Could not properly delete the transaction.\");\n     }\n \n@@ -391,15 +391,15 @@ UniValue importpubkey(const JSONRPCRequest& request)\n     if (!pubKey.IsFullyValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     ImportAddress(CBitcoinAddress(pubKey.GetID()), strLabel);\n     ImportScript(GetScriptForRawPubKey(pubKey), strLabel, false);\n \n     if (fRescan)\n     {\n-        pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n-        pwalletMain->ReacceptWalletTransactions();\n+        CWallets::defaultWallet()->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        CWallets::defaultWallet()->ReacceptWalletTransactions();\n     }\n \n     return NullUniValue;\n@@ -429,7 +429,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n     if (fPruneMode)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Importing wallets is disabled in pruned mode\");\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     EnsureWalletIsUnlocked();\n \n@@ -445,9 +445,9 @@ UniValue importwallet(const JSONRPCRequest& request)\n     int64_t nFilesize = std::max((int64_t)1, (int64_t)file.tellg());\n     file.seekg(0, file.beg);\n \n-    pwalletMain->ShowProgress(_(\"Importing...\"), 0); // show progress dialog in GUI\n+    CWallets::defaultWallet()->ShowProgress(_(\"Importing...\"), 0); // show progress dialog in GUI\n     while (file.good()) {\n-        pwalletMain->ShowProgress(\"\", std::max(1, std::min(99, (int)(((double)file.tellg() / (double)nFilesize) * 100))));\n+        CWallets::defaultWallet()->ShowProgress(\"\", std::max(1, std::min(99, (int)(((double)file.tellg() / (double)nFilesize) * 100))));\n         std::string line;\n         std::getline(file, line);\n         if (line.empty() || line[0] == '#')\n@@ -464,7 +464,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n         CPubKey pubkey = key.GetPubKey();\n         assert(key.VerifyPubKey(pubkey));\n         CKeyID keyid = pubkey.GetID();\n-        if (pwalletMain->HaveKey(keyid)) {\n+        if (CWallets::defaultWallet()->HaveKey(keyid)) {\n             LogPrintf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString());\n             continue;\n         }\n@@ -484,28 +484,28 @@ UniValue importwallet(const JSONRPCRequest& request)\n             }\n         }\n         LogPrintf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString());\n-        if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+        if (!CWallets::defaultWallet()->AddKeyPubKey(key, pubkey)) {\n             fGood = false;\n             continue;\n         }\n-        pwalletMain->mapKeyMetadata[keyid].nCreateTime = nTime;\n+        CWallets::defaultWallet()->mapKeyMetadata[keyid].nCreateTime = nTime;\n         if (fLabel)\n-            pwalletMain->SetAddressBook(keyid, strLabel, \"receive\");\n+            CWallets::defaultWallet()->SetAddressBook(keyid, strLabel, \"receive\");\n         nTimeBegin = std::min(nTimeBegin, nTime);\n     }\n     file.close();\n-    pwalletMain->ShowProgress(\"\", 100); // hide progress dialog in GUI\n+    CWallets::defaultWallet()->ShowProgress(\"\", 100); // hide progress dialog in GUI\n \n     CBlockIndex *pindex = chainActive.Tip();\n     while (pindex && pindex->pprev && pindex->GetBlockTime() > nTimeBegin - 7200)\n         pindex = pindex->pprev;\n \n-    if (!pwalletMain->nTimeFirstKey || nTimeBegin < pwalletMain->nTimeFirstKey)\n-        pwalletMain->nTimeFirstKey = nTimeBegin;\n+    if (!CWallets::defaultWallet()->nTimeFirstKey || nTimeBegin < CWallets::defaultWallet()->nTimeFirstKey)\n+        CWallets::defaultWallet()->nTimeFirstKey = nTimeBegin;\n \n     LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n-    pwalletMain->ScanForWalletTransactions(pindex);\n-    pwalletMain->MarkDirty();\n+    CWallets::defaultWallet()->ScanForWalletTransactions(pindex);\n+    CWallets::defaultWallet()->MarkDirty();\n \n     if (!fGood)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding some keys to wallet\");\n@@ -533,7 +533,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     EnsureWalletIsUnlocked();\n \n@@ -545,7 +545,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n     if (!address.GetKeyID(keyID))\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n     CKey vchSecret;\n-    if (!pwalletMain->GetKey(keyID, vchSecret))\n+    if (!CWallets::defaultWallet()->GetKey(keyID, vchSecret))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n     return CBitcoinSecret(vchSecret).ToString();\n }\n@@ -567,7 +567,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"dumpwallet\", \"\\\"test\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     EnsureWalletIsUnlocked();\n \n@@ -578,8 +578,8 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n     std::map<CKeyID, int64_t> mapKeyBirth;\n     std::set<CKeyID> setKeyPool;\n-    pwalletMain->GetKeyBirthTimes(mapKeyBirth);\n-    pwalletMain->GetAllReserveKeys(setKeyPool);\n+    CWallets::defaultWallet()->GetKeyBirthTimes(mapKeyBirth);\n+    CWallets::defaultWallet()->GetAllReserveKeys(setKeyPool);\n \n     // sort time/key pairs\n     std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;\n@@ -597,11 +597,11 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     file << \"\\n\";\n \n     // add the base58check encoded extended master if the wallet uses HD \n-    CKeyID masterKeyID = pwalletMain->GetHDChain().masterKeyID;\n+    CKeyID masterKeyID = CWallets::defaultWallet()->GetHDChain().masterKeyID;\n     if (!masterKeyID.IsNull())\n     {\n         CKey key;\n-        if (pwalletMain->GetKey(masterKeyID, key))\n+        if (CWallets::defaultWallet()->GetKey(masterKeyID, key))\n         {\n             CExtKey masterKey;\n             masterKey.SetMaster(key.begin(), key.size());\n@@ -617,20 +617,20 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n         std::string strTime = EncodeDumpTime(it->first);\n         std::string strAddr = CBitcoinAddress(keyid).ToString();\n         CKey key;\n-        if (pwalletMain->GetKey(keyid, key)) {\n+        if (CWallets::defaultWallet()->GetKey(keyid, key)) {\n             file << strprintf(\"%s %s \", CBitcoinSecret(key).ToString(), strTime);\n-            if (pwalletMain->mapAddressBook.count(keyid)) {\n-                file << strprintf(\"label=%s\", EncodeDumpString(pwalletMain->mapAddressBook[keyid].name));\n+            if (CWallets::defaultWallet()->mapAddressBook.count(keyid)) {\n+                file << strprintf(\"label=%s\", EncodeDumpString(CWallets::defaultWallet()->mapAddressBook[keyid].name));\n             } else if (keyid == masterKeyID) {\n                 file << \"hdmaster=1\";\n             } else if (setKeyPool.count(keyid)) {\n                 file << \"reserve=1\";\n-            } else if (pwalletMain->mapKeyMetadata[keyid].hdKeypath == \"m\") {\n+            } else if (CWallets::defaultWallet()->mapKeyMetadata[keyid].hdKeypath == \"m\") {\n                 file << \"inactivehdmaster=1\";\n             } else {\n                 file << \"change=1\";\n             }\n-            file << strprintf(\" # addr=%s%s\\n\", strAddr, (pwalletMain->mapKeyMetadata[keyid].hdKeypath.size() > 0 ? \" hdkeypath=\"+pwalletMain->mapKeyMetadata[keyid].hdKeypath : \"\"));\n+            file << strprintf(\" # addr=%s%s\\n\", strAddr, (CWallets::defaultWallet()->mapKeyMetadata[keyid].hdKeypath.size() > 0 ? \" hdkeypath=\"+CWallets::defaultWallet()->mapKeyMetadata[keyid].hdKeypath : \"\"));\n         }\n     }\n     file << \"\\n\";\n@@ -719,32 +719,32 @@ UniValue processImport(const UniValue& data) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n             }\n \n-            pwalletMain->MarkDirty();\n+            CWallets::defaultWallet()->MarkDirty();\n \n-            if (!pwalletMain->HaveWatchOnly(redeemScript) && !pwalletMain->AddWatchOnly(redeemScript)) {\n+            if (!CWallets::defaultWallet()->HaveWatchOnly(redeemScript) && !CWallets::defaultWallet()->AddWatchOnly(redeemScript)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            if (!pwalletMain->HaveCScript(redeemScript) && !pwalletMain->AddCScript(redeemScript)) {\n+            if (!CWallets::defaultWallet()->HaveCScript(redeemScript) && !CWallets::defaultWallet()->AddCScript(redeemScript)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n             }\n \n             CBitcoinAddress redeemAddress = CBitcoinAddress(CScriptID(redeemScript));\n             CScript redeemDestination = GetScriptForDestination(redeemAddress.Get());\n \n-            if (::IsMine(*pwalletMain, redeemDestination) == ISMINE_SPENDABLE) {\n+            if (::IsMine(*CWallets::defaultWallet(), redeemDestination) == ISMINE_SPENDABLE) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n             }\n \n-            pwalletMain->MarkDirty();\n+            CWallets::defaultWallet()->MarkDirty();\n \n-            if (!pwalletMain->HaveWatchOnly(redeemDestination) && !pwalletMain->AddWatchOnly(redeemDestination)) {\n+            if (!CWallets::defaultWallet()->HaveWatchOnly(redeemDestination) && !CWallets::defaultWallet()->AddWatchOnly(redeemDestination)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n             // add to address book or update label\n             if (address.IsValid()) {\n-                pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                CWallets::defaultWallet()->SetAddressBook(address.Get(), label, \"receive\");\n             }\n \n             // Import private keys.\n@@ -769,21 +769,21 @@ UniValue processImport(const UniValue& data) {\n                     assert(key.VerifyPubKey(pubkey));\n \n                     CKeyID vchAddress = pubkey.GetID();\n-                    pwalletMain->MarkDirty();\n-                    pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+                    CWallets::defaultWallet()->MarkDirty();\n+                    CWallets::defaultWallet()->SetAddressBook(vchAddress, label, \"receive\");\n \n-                    if (pwalletMain->HaveKey(vchAddress)) {\n+                    if (CWallets::defaultWallet()->HaveKey(vchAddress)) {\n                         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n                     }\n \n-                    pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+                    CWallets::defaultWallet()->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                    if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n+                    if (!CWallets::defaultWallet()->AddKeyPubKey(key, pubkey)) {\n                         throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n                     }\n \n-                    if (timestamp < pwalletMain->nTimeFirstKey) {\n-                        pwalletMain->nTimeFirstKey = timestamp;\n+                    if (timestamp < CWallets::defaultWallet()->nTimeFirstKey) {\n+                        CWallets::defaultWallet()->nTimeFirstKey = timestamp;\n                     }\n                 }\n             }\n@@ -827,31 +827,31 @@ UniValue processImport(const UniValue& data) {\n \n                 CScript pubKeyScript = GetScriptForDestination(pubKeyAddress.Get());\n \n-                if (::IsMine(*pwalletMain, pubKeyScript) == ISMINE_SPENDABLE) {\n+                if (::IsMine(*CWallets::defaultWallet(), pubKeyScript) == ISMINE_SPENDABLE) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n                 }\n \n-                pwalletMain->MarkDirty();\n+                CWallets::defaultWallet()->MarkDirty();\n \n-                if (!pwalletMain->HaveWatchOnly(pubKeyScript) && !pwalletMain->AddWatchOnly(pubKeyScript)) {\n+                if (!CWallets::defaultWallet()->HaveWatchOnly(pubKeyScript) && !CWallets::defaultWallet()->AddWatchOnly(pubKeyScript)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n                 // add to address book or update label\n                 if (pubKeyAddress.IsValid()) {\n-                    pwalletMain->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n+                    CWallets::defaultWallet()->SetAddressBook(pubKeyAddress.Get(), label, \"receive\");\n                 }\n \n                 // TODO Is this necessary?\n                 CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n \n-                if (::IsMine(*pwalletMain, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                if (::IsMine(*CWallets::defaultWallet(), scriptRawPubKey) == ISMINE_SPENDABLE) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n                 }\n \n-                pwalletMain->MarkDirty();\n+                CWallets::defaultWallet()->MarkDirty();\n \n-                if (!pwalletMain->HaveWatchOnly(scriptRawPubKey) && !pwalletMain->AddWatchOnly(scriptRawPubKey)) {\n+                if (!CWallets::defaultWallet()->HaveWatchOnly(scriptRawPubKey) && !CWallets::defaultWallet()->AddWatchOnly(scriptRawPubKey)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n@@ -899,42 +899,42 @@ UniValue processImport(const UniValue& data) {\n                 }\n \n                 CKeyID vchAddress = pubKey.GetID();\n-                pwalletMain->MarkDirty();\n-                pwalletMain->SetAddressBook(vchAddress, label, \"receive\");\n+                CWallets::defaultWallet()->MarkDirty();\n+                CWallets::defaultWallet()->SetAddressBook(vchAddress, label, \"receive\");\n \n-                if (pwalletMain->HaveKey(vchAddress)) {\n+                if (CWallets::defaultWallet()->HaveKey(vchAddress)) {\n                     return false;\n                 }\n \n-                pwalletMain->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+                CWallets::defaultWallet()->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                if (!pwalletMain->AddKeyPubKey(key, pubKey)) {\n+                if (!CWallets::defaultWallet()->AddKeyPubKey(key, pubKey)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n                 }\n \n-                if (timestamp < pwalletMain->nTimeFirstKey) {\n-                    pwalletMain->nTimeFirstKey = timestamp;\n+                if (timestamp < CWallets::defaultWallet()->nTimeFirstKey) {\n+                    CWallets::defaultWallet()->nTimeFirstKey = timestamp;\n                 }\n \n                 success = true;\n             }\n \n             // Import scriptPubKey only.\n             if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwalletMain, script) == ISMINE_SPENDABLE) {\n+                if (::IsMine(*CWallets::defaultWallet(), script) == ISMINE_SPENDABLE) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n                 }\n \n-                pwalletMain->MarkDirty();\n+                CWallets::defaultWallet()->MarkDirty();\n \n-                if (!pwalletMain->HaveWatchOnly(script) && !pwalletMain->AddWatchOnly(script)) {\n+                if (!CWallets::defaultWallet()->HaveWatchOnly(script) && !CWallets::defaultWallet()->AddWatchOnly(script)) {\n                     throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n                 }\n \n                 if (scriptPubKey.getType() == UniValue::VOBJ) {\n                     // add to address book or update label\n                     if (address.IsValid()) {\n-                        pwalletMain->SetAddressBook(address.Get(), label, \"receive\");\n+                        CWallets::defaultWallet()->SetAddressBook(address.Get(), label, \"receive\");\n                     }\n                 }\n \n@@ -1012,7 +1012,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n         }\n     }\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n     EnsureWalletIsUnlocked();\n \n     bool fRunScan = false;\n@@ -1052,8 +1052,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n         CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindLatestBefore(nLowestTimestamp) : chainActive.Genesis();\n \n         if (pindex) {\n-            pwalletMain->ScanForWalletTransactions(pindex, true);\n-            pwalletMain->ReacceptWalletTransactions();\n+            CWallets::defaultWallet()->ScanForWalletTransactions(pindex, true);\n+            CWallets::defaultWallet()->ReacceptWalletTransactions();\n         }\n     }\n "
      },
      {
        "sha": "d5b885d3b9e9dd9d0b354951199b88d2804acbf3",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 149,
        "deletions": 149,
        "changes": 298,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -32,14 +32,14 @@ static CCriticalSection cs_nWalletUnlockTime;\n \n std::string HelpRequiringPassphrase()\n {\n-    return pwalletMain && pwalletMain->IsCrypted()\n+    return CWallets::defaultWallet() && CWallets::defaultWallet()->IsCrypted()\n         ? \"\\nRequires wallet passphrase to be set with walletpassphrase call.\"\n         : \"\";\n }\n \n bool EnsureWalletIsAvailable(bool avoidException)\n {\n-    if (!pwalletMain)\n+    if (!CWallets::defaultWallet())\n     {\n         if (!avoidException)\n             throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found (disabled)\");\n@@ -51,7 +51,7 @@ bool EnsureWalletIsAvailable(bool avoidException)\n \n void EnsureWalletIsUnlocked()\n {\n-    if (pwalletMain->IsLocked())\n+    if (CWallets::defaultWallet()->IsLocked())\n         throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n }\n \n@@ -122,23 +122,23 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getnewaddress\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount;\n     if (request.params.size() > 0)\n         strAccount = AccountFromValue(request.params[0]);\n \n-    if (!pwalletMain->IsLocked())\n-        pwalletMain->TopUpKeyPool();\n+    if (!CWallets::defaultWallet()->IsLocked())\n+        CWallets::defaultWallet()->TopUpKeyPool();\n \n     // Generate a new key that is added to wallet\n     CPubKey newKey;\n-    if (!pwalletMain->GetKeyFromPool(newKey))\n+    if (!CWallets::defaultWallet()->GetKeyFromPool(newKey))\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     CKeyID keyID = newKey.GetID();\n \n-    pwalletMain->SetAddressBook(keyID, strAccount, \"receive\");\n+    CWallets::defaultWallet()->SetAddressBook(keyID, strAccount, \"receive\");\n \n     return CBitcoinAddress(keyID).ToString();\n }\n@@ -147,7 +147,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n {\n     CPubKey pubKey;\n-    if (!pwalletMain->GetAccountPubkey(pubKey, strAccount, bForceNew)) {\n+    if (!CWallets::defaultWallet()->GetAccountPubkey(pubKey, strAccount, bForceNew)) {\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     }\n \n@@ -174,7 +174,7 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount = AccountFromValue(request.params[0]);\n@@ -203,12 +203,12 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getrawchangeaddress\", \"\")\n        );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n-    if (!pwalletMain->IsLocked())\n-        pwalletMain->TopUpKeyPool();\n+    if (!CWallets::defaultWallet()->IsLocked())\n+        CWallets::defaultWallet()->TopUpKeyPool();\n \n-    CReserveKey reservekey(pwalletMain);\n+    CReserveKey reservekey(CWallets::defaultWallet());\n     CPubKey vchPubKey;\n     if (!reservekey.GetReservedKey(vchPubKey))\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n@@ -238,7 +238,7 @@ UniValue setaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"tabby\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     CBitcoinAddress address(request.params[0].get_str());\n     if (!address.IsValid())\n@@ -249,16 +249,16 @@ UniValue setaccount(const JSONRPCRequest& request)\n         strAccount = AccountFromValue(request.params[1]);\n \n     // Only add the account if the address is yours.\n-    if (IsMine(*pwalletMain, address.Get()))\n+    if (IsMine(*CWallets::defaultWallet(), address.Get()))\n     {\n         // Detect when changing the account of an address that is the 'unused current key' of another account:\n-        if (pwalletMain->mapAddressBook.count(address.Get()))\n+        if (CWallets::defaultWallet()->mapAddressBook.count(address.Get()))\n         {\n-            string strOldAccount = pwalletMain->mapAddressBook[address.Get()].name;\n+            string strOldAccount = CWallets::defaultWallet()->mapAddressBook[address.Get()].name;\n             if (address == GetAccountAddress(strOldAccount))\n                 GetAccountAddress(strOldAccount, true);\n         }\n-        pwalletMain->SetAddressBook(address.Get(), strAccount, \"receive\");\n+        CWallets::defaultWallet()->SetAddressBook(address.Get(), strAccount, \"receive\");\n     }\n     else\n         throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n@@ -285,15 +285,15 @@ UniValue getaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     CBitcoinAddress address(request.params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n     string strAccount;\n-    map<CTxDestination, CAddressBookData>::iterator mi = pwalletMain->mapAddressBook.find(address.Get());\n-    if (mi != pwalletMain->mapAddressBook.end() && !(*mi).second.name.empty())\n+    map<CTxDestination, CAddressBookData>::iterator mi = CWallets::defaultWallet()->mapAddressBook.find(address.Get());\n+    if (mi != CWallets::defaultWallet()->mapAddressBook.end() && !(*mi).second.name.empty())\n         strAccount = (*mi).second.name;\n     return strAccount;\n }\n@@ -320,13 +320,13 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     string strAccount = AccountFromValue(request.params[0]);\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, CWallets::defaultWallet()->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n         const string& strName = item.second.name;\n@@ -338,7 +338,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew)\n {\n-    CAmount curBalance = pwalletMain->GetBalance();\n+    CAmount curBalance = CWallets::defaultWallet()->GetBalance();\n \n     // Check amount\n     if (nValue <= 0)\n@@ -347,27 +347,27 @@ static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtr\n     if (nValue > curBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds\");\n \n-    if (pwalletMain->GetBroadcastTransactions() && !g_connman)\n+    if (CWallets::defaultWallet()->GetBroadcastTransactions() && !g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n     // Parse Bitcoin address\n     CScript scriptPubKey = GetScriptForDestination(address);\n \n     // Create and send the transaction\n-    CReserveKey reservekey(pwalletMain);\n+    CReserveKey reservekey(CWallets::defaultWallet());\n     CAmount nFeeRequired;\n     std::string strError;\n     vector<CRecipient> vecSend;\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n-    if (!pwalletMain->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n-        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > pwalletMain->GetBalance())\n+    if (!CWallets::defaultWallet()->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n+        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > CWallets::defaultWallet()->GetBalance())\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s\", FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n     CValidationState state;\n-    if (!pwalletMain->CommitTransaction(wtxNew, reservekey, g_connman.get(), state)) {\n+    if (!CWallets::defaultWallet()->CommitTransaction(wtxNew, reservekey, g_connman.get(), state)) {\n         strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason());\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n@@ -402,7 +402,7 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"sendtoaddress\", \"\\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.1, \\\"donation\\\", \\\"seans outpost\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     CBitcoinAddress address(request.params[0].get_str());\n     if (!address.IsValid())\n@@ -459,11 +459,11 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listaddressgroupings\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    map<CTxDestination, CAmount> balances = pwalletMain->GetAddressBalances();\n-    BOOST_FOREACH(set<CTxDestination> grouping, pwalletMain->GetAddressGroupings())\n+    map<CTxDestination, CAmount> balances = CWallets::defaultWallet()->GetAddressBalances();\n+    BOOST_FOREACH(set<CTxDestination> grouping, CWallets::defaultWallet()->GetAddressGroupings())\n     {\n         UniValue jsonGrouping(UniValue::VARR);\n         BOOST_FOREACH(CTxDestination address, grouping)\n@@ -472,8 +472,8 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n             addressInfo.push_back(CBitcoinAddress(address).ToString());\n             addressInfo.push_back(ValueFromAmount(balances[address]));\n             {\n-                if (pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get()) != pwalletMain->mapAddressBook.end())\n-                    addressInfo.push_back(pwalletMain->mapAddressBook.find(CBitcoinAddress(address).Get())->second.name);\n+                if (CWallets::defaultWallet()->mapAddressBook.find(CBitcoinAddress(address).Get()) != CWallets::defaultWallet()->mapAddressBook.end())\n+                    addressInfo.push_back(CWallets::defaultWallet()->mapAddressBook.find(CBitcoinAddress(address).Get())->second.name);\n             }\n             jsonGrouping.push_back(addressInfo);\n         }\n@@ -508,7 +508,7 @@ UniValue signmessage(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", \\\"my message\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     EnsureWalletIsUnlocked();\n \n@@ -524,7 +524,7 @@ UniValue signmessage(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n \n     CKey key;\n-    if (!pwalletMain->GetKey(keyID, key))\n+    if (!CWallets::defaultWallet()->GetKey(keyID, key))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key not available\");\n \n     CHashWriter ss(SER_GETHASH, 0);\n@@ -563,14 +563,14 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getreceivedbyaddress\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\", 6\")\n        );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     // Bitcoin address\n     CBitcoinAddress address = CBitcoinAddress(request.params[0].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     CScript scriptPubKey = GetScriptForDestination(address.Get());\n-    if (!IsMine(*pwalletMain, scriptPubKey))\n+    if (!IsMine(*CWallets::defaultWallet(), scriptPubKey))\n         return ValueFromAmount(0);\n \n     // Minimum confirmations\n@@ -580,7 +580,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = CWallets::defaultWallet()->mapWallet.begin(); it != CWallets::defaultWallet()->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n@@ -621,7 +621,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -630,11 +630,11 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n \n     // Get the set of pub keys assigned to account\n     string strAccount = AccountFromValue(request.params[0]);\n-    set<CTxDestination> setAddress = pwalletMain->GetAccountAddresses(strAccount);\n+    set<CTxDestination> setAddress = CWallets::defaultWallet()->GetAccountAddresses(strAccount);\n \n     // Tally\n     CAmount nAmount = 0;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = CWallets::defaultWallet()->mapWallet.begin(); it != CWallets::defaultWallet()->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n@@ -643,7 +643,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n         {\n             CTxDestination address;\n-            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwalletMain, address) && setAddress.count(address))\n+            if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*CWallets::defaultWallet(), address) && setAddress.count(address))\n                 if (wtx.GetDepthInMainChain() >= nMinDepth)\n                     nAmount += txout.nValue;\n         }\n@@ -680,10 +680,10 @@ UniValue getbalance(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getbalance\", \"\\\"*\\\", 6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     if (request.params.size() == 0)\n-        return  ValueFromAmount(pwalletMain->GetBalance());\n+        return  ValueFromAmount(CWallets::defaultWallet()->GetBalance());\n \n     int nMinDepth = 1;\n     if (request.params.size() > 1)\n@@ -698,7 +698,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n         // (GetBalance() sums up all unspent TxOuts)\n         // getbalance and \"getbalance * 1 true\" should return the same number\n         CAmount nBalance = 0;\n-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+        for (map<uint256, CWalletTx>::iterator it = CWallets::defaultWallet()->mapWallet.begin(); it != CWallets::defaultWallet()->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n@@ -723,7 +723,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n \n     string strAccount = AccountFromValue(request.params[0]);\n \n-    CAmount nBalance = pwalletMain->GetAccountBalance(strAccount, nMinDepth, filter);\n+    CAmount nBalance = CWallets::defaultWallet()->GetAccountBalance(strAccount, nMinDepth, filter);\n \n     return ValueFromAmount(nBalance);\n }\n@@ -738,9 +738,9 @@ UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n                 \"getunconfirmedbalance\\n\"\n                 \"Returns the server's total unconfirmed balance\\n\");\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n-    return ValueFromAmount(pwalletMain->GetUnconfirmedBalance());\n+    return ValueFromAmount(CWallets::defaultWallet()->GetUnconfirmedBalance());\n }\n \n \n@@ -770,7 +770,7 @@ UniValue movecmd(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"move\", \"\\\"timotei\\\", \\\"akiko\\\", 0.01, 6, \\\"happy birthday!\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     string strFrom = AccountFromValue(request.params[0]);\n     string strTo = AccountFromValue(request.params[1]);\n@@ -784,7 +784,7 @@ UniValue movecmd(const JSONRPCRequest& request)\n     if (request.params.size() > 4)\n         strComment = request.params[4].get_str();\n \n-    if (!pwalletMain->AccountMove(strFrom, strTo, nAmount, strComment))\n+    if (!CWallets::defaultWallet()->AccountMove(strFrom, strTo, nAmount, strComment))\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n \n     return true;\n@@ -822,7 +822,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"sendfrom\", \"\\\"tabby\\\", \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\", 0.01, 6, \\\"donation\\\", \\\"seans outpost\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     string strAccount = AccountFromValue(request.params[0]);\n     CBitcoinAddress address(request.params[1].get_str());\n@@ -845,7 +845,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    CAmount nBalance = pwalletMain->GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    CAmount nBalance = CWallets::defaultWallet()->GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n     if (nAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n@@ -896,9 +896,9 @@ UniValue sendmany(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"sendmany\", \"\\\"\\\", \\\"{\\\\\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\\\\\":0.01,\\\\\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\\\\\":0.02}\\\", 6, \\\"testing\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n-    if (pwalletMain->GetBroadcastTransactions() && !g_connman)\n+    if (CWallets::defaultWallet()->GetBroadcastTransactions() && !g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n     string strAccount = AccountFromValue(request.params[0]);\n@@ -951,20 +951,20 @@ UniValue sendmany(const JSONRPCRequest& request)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    CAmount nBalance = pwalletMain->GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    CAmount nBalance = CWallets::defaultWallet()->GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n     if (totalAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n     // Send\n-    CReserveKey keyChange(pwalletMain);\n+    CReserveKey keyChange(CWallets::defaultWallet());\n     CAmount nFeeRequired = 0;\n     int nChangePosRet = -1;\n     string strFailReason;\n-    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n+    bool fCreated = CWallets::defaultWallet()->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n     CValidationState state;\n-    if (!pwalletMain->CommitTransaction(wtx, keyChange, g_connman.get(), state)) {\n+    if (!CWallets::defaultWallet()->CommitTransaction(wtx, keyChange, g_connman.get(), state)) {\n         strFailReason = strprintf(\"Transaction commit failed:: %s\", state.GetRejectReason());\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n@@ -1008,7 +1008,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n         throw runtime_error(msg);\n     }\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     string strAccount;\n     if (request.params.size() > 2)\n@@ -1017,9 +1017,9 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     // Construct using pay-to-script-hash:\n     CScript inner = _createmultisig_redeemScript(request.params);\n     CScriptID innerID(inner);\n-    pwalletMain->AddCScript(inner);\n+    CWallets::defaultWallet()->AddCScript(inner);\n \n-    pwalletMain->SetAddressBook(innerID, strAccount, \"send\");\n+    CWallets::defaultWallet()->SetAddressBook(innerID, strAccount, \"send\");\n     return CBitcoinAddress(innerID).ToString();\n }\n \n@@ -1032,14 +1032,14 @@ class Witnessifier : public boost::static_visitor<bool>\n \n     bool operator()(const CKeyID &keyID) {\n         CPubKey pubkey;\n-        if (pwalletMain) {\n+        if (CWallets::defaultWallet()) {\n             CScript basescript = GetScriptForDestination(keyID);\n             isminetype typ;\n-            typ = IsMine(*pwalletMain, basescript, SIGVERSION_WITNESS_V0);\n+            typ = IsMine(*CWallets::defaultWallet(), basescript, SIGVERSION_WITNESS_V0);\n             if (typ != ISMINE_SPENDABLE && typ != ISMINE_WATCH_SOLVABLE)\n                 return false;\n             CScript witscript = GetScriptForWitness(basescript);\n-            pwalletMain->AddCScript(witscript);\n+            CWallets::defaultWallet()->AddCScript(witscript);\n             result = CScriptID(witscript);\n             return true;\n         }\n@@ -1048,19 +1048,19 @@ class Witnessifier : public boost::static_visitor<bool>\n \n     bool operator()(const CScriptID &scriptID) {\n         CScript subscript;\n-        if (pwalletMain && pwalletMain->GetCScript(scriptID, subscript)) {\n+        if (CWallets::defaultWallet() && CWallets::defaultWallet()->GetCScript(scriptID, subscript)) {\n             int witnessversion;\n             std::vector<unsigned char> witprog;\n             if (subscript.IsWitnessProgram(witnessversion, witprog)) {\n                 result = scriptID;\n                 return true;\n             }\n             isminetype typ;\n-            typ = IsMine(*pwalletMain, subscript, SIGVERSION_WITNESS_V0);\n+            typ = IsMine(*CWallets::defaultWallet(), subscript, SIGVERSION_WITNESS_V0);\n             if (typ != ISMINE_SPENDABLE && typ != ISMINE_WATCH_SOLVABLE)\n                 return false;\n             CScript witscript = GetScriptForWitness(subscript);\n-            pwalletMain->AddCScript(witscript);\n+            CWallets::defaultWallet()->AddCScript(witscript);\n             result = CScriptID(witscript);\n             return true;\n         }\n@@ -1107,7 +1107,7 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet, or the key is uncompressed\");\n     }\n \n-    pwalletMain->SetAddressBook(w.result, \"\", \"receive\");\n+    CWallets::defaultWallet()->SetAddressBook(w.result, \"\", \"receive\");\n \n     return CBitcoinAddress(w.result).ToString();\n }\n@@ -1145,7 +1145,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n \n     // Tally\n     map<CBitcoinAddress, tallyitem> mapTally;\n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = CWallets::defaultWallet()->mapWallet.begin(); it != CWallets::defaultWallet()->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n \n@@ -1162,7 +1162,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n             if (!ExtractDestination(txout.scriptPubKey, address))\n                 continue;\n \n-            isminefilter mine = IsMine(*pwalletMain, address);\n+            isminefilter mine = IsMine(*CWallets::defaultWallet(), address);\n             if(!(mine & filter))\n                 continue;\n \n@@ -1178,7 +1178,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n     // Reply\n     UniValue ret(UniValue::VARR);\n     map<string, tallyitem> mapAccountTally;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, CWallets::defaultWallet()->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n         const string& strAccount = item.second.name;\n@@ -1279,7 +1279,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     return ListReceived(request.params, false);\n }\n@@ -1316,7 +1316,7 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     return ListReceived(request.params, true);\n }\n@@ -1346,14 +1346,14 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n         BOOST_FOREACH(const COutputEntry& s, listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n-            if(involvesWatchonly || (::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n+            if(involvesWatchonly || (::IsMine(*CWallets::defaultWallet(), s.destination) & ISMINE_WATCH_ONLY))\n                 entry.push_back(Pair(\"involvesWatchonly\", true));\n             entry.push_back(Pair(\"account\", strSentAccount));\n             MaybePushAddress(entry, s.destination);\n             entry.push_back(Pair(\"category\", \"send\"));\n             entry.push_back(Pair(\"amount\", ValueFromAmount(-s.amount)));\n-            if (pwalletMain->mapAddressBook.count(s.destination))\n-                entry.push_back(Pair(\"label\", pwalletMain->mapAddressBook[s.destination].name));\n+            if (CWallets::defaultWallet()->mapAddressBook.count(s.destination))\n+                entry.push_back(Pair(\"label\", CWallets::defaultWallet()->mapAddressBook[s.destination].name));\n             entry.push_back(Pair(\"vout\", s.vout));\n             entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n             if (fLong)\n@@ -1369,12 +1369,12 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n         BOOST_FOREACH(const COutputEntry& r, listReceived)\n         {\n             string account;\n-            if (pwalletMain->mapAddressBook.count(r.destination))\n-                account = pwalletMain->mapAddressBook[r.destination].name;\n+            if (CWallets::defaultWallet()->mapAddressBook.count(r.destination))\n+                account = CWallets::defaultWallet()->mapAddressBook[r.destination].name;\n             if (fAllAccounts || (account == strAccount))\n             {\n                 UniValue entry(UniValue::VOBJ);\n-                if(involvesWatchonly || (::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n+                if(involvesWatchonly || (::IsMine(*CWallets::defaultWallet(), r.destination) & ISMINE_WATCH_ONLY))\n                     entry.push_back(Pair(\"involvesWatchonly\", true));\n                 entry.push_back(Pair(\"account\", account));\n                 MaybePushAddress(entry, r.destination);\n@@ -1392,7 +1392,7 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n                     entry.push_back(Pair(\"category\", \"receive\"));\n                 }\n                 entry.push_back(Pair(\"amount\", ValueFromAmount(r.amount)));\n-                if (pwalletMain->mapAddressBook.count(r.destination))\n+                if (CWallets::defaultWallet()->mapAddressBook.count(r.destination))\n                     entry.push_back(Pair(\"label\", account));\n                 entry.push_back(Pair(\"vout\", r.vout));\n                 if (fLong)\n@@ -1484,7 +1484,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listtransactions\", \"\\\"*\\\", 20, 100\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     string strAccount = \"*\";\n     if (request.params.size() > 0)\n@@ -1507,7 +1507,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n \n     UniValue ret(UniValue::VARR);\n \n-    const CWallet::TxItems & txOrdered = pwalletMain->wtxOrdered;\n+    const CWallet::TxItems & txOrdered = CWallets::defaultWallet()->wtxOrdered;\n \n     // iterate backwards until we have nCount items to return:\n     for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n@@ -1575,7 +1575,7 @@ UniValue listaccounts(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listaccounts\", \"6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     int nMinDepth = 1;\n     if (request.params.size() > 0)\n@@ -1586,12 +1586,12 @@ UniValue listaccounts(const JSONRPCRequest& request)\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n     map<string, CAmount> mapAccountBalances;\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n-        if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n+    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, CWallets::defaultWallet()->mapAddressBook) {\n+        if (IsMine(*CWallets::defaultWallet(), entry.first) & includeWatchonly) // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n     }\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+    for (map<uint256, CWalletTx>::iterator it = CWallets::defaultWallet()->mapWallet.begin(); it != CWallets::defaultWallet()->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         CAmount nFee;\n@@ -1608,14 +1608,14 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         if (nDepth >= nMinDepth)\n         {\n             BOOST_FOREACH(const COutputEntry& r, listReceived)\n-                if (pwalletMain->mapAddressBook.count(r.destination))\n-                    mapAccountBalances[pwalletMain->mapAddressBook[r.destination].name] += r.amount;\n+                if (CWallets::defaultWallet()->mapAddressBook.count(r.destination))\n+                    mapAccountBalances[CWallets::defaultWallet()->mapAddressBook[r.destination].name] += r.amount;\n                 else\n                     mapAccountBalances[\"\"] += r.amount;\n         }\n     }\n \n-    const list<CAccountingEntry> & acentries = pwalletMain->laccentries;\n+    const list<CAccountingEntry> & acentries = CWallets::defaultWallet()->laccentries;\n     BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n@@ -1668,7 +1668,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listsinceblock\", \"\\\"000000000000000bacf66f7497b7dc45ef753ee9a7d38571037cdb1a57f663ad\\\", 6\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     CBlockIndex *pindex = NULL;\n     int target_confirms = 1;\n@@ -1700,7 +1700,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n \n     UniValue transactions(UniValue::VARR);\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n+    for (map<uint256, CWalletTx>::iterator it = CWallets::defaultWallet()->mapWallet.begin(); it != CWallets::defaultWallet()->mapWallet.end(); it++)\n     {\n         CWalletTx tx = (*it).second;\n \n@@ -1762,7 +1762,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"gettransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n@@ -1773,9 +1773,9 @@ UniValue gettransaction(const JSONRPCRequest& request)\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     UniValue entry(UniValue::VOBJ);\n-    if (!pwalletMain->mapWallet.count(hash))\n+    if (!CWallets::defaultWallet()->mapWallet.count(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n-    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+    const CWalletTx& wtx = CWallets::defaultWallet()->mapWallet[hash];\n \n     CAmount nCredit = wtx.GetCredit(filter);\n     CAmount nDebit = wtx.GetDebit(filter);\n@@ -1819,14 +1819,14 @@ UniValue abandontransaction(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"abandontransaction\", \"\\\"1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n \n-    if (!pwalletMain->mapWallet.count(hash))\n+    if (!CWallets::defaultWallet()->mapWallet.count(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n-    if (!pwalletMain->AbandonTransaction(hash))\n+    if (!CWallets::defaultWallet()->AbandonTransaction(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not eligible for abandonment\");\n \n     return NullUniValue;\n@@ -1849,10 +1849,10 @@ UniValue backupwallet(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     string strDest = request.params[0].get_str();\n-    if (!pwalletMain->BackupWallet(strDest))\n+    if (!CWallets::defaultWallet()->BackupWallet(strDest))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n \n     return NullUniValue;\n@@ -1876,7 +1876,7 @@ UniValue keypoolrefill(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"keypoolrefill\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n     unsigned int kpSize = 0;\n@@ -1887,9 +1887,9 @@ UniValue keypoolrefill(const JSONRPCRequest& request)\n     }\n \n     EnsureWalletIsUnlocked();\n-    pwalletMain->TopUpKeyPool(kpSize);\n+    CWallets::defaultWallet()->TopUpKeyPool(kpSize);\n \n-    if (pwalletMain->GetKeyPoolSize() < kpSize)\n+    if (CWallets::defaultWallet()->GetKeyPoolSize() < kpSize)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error refreshing keypool.\");\n \n     return NullUniValue;\n@@ -1908,7 +1908,7 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n     if (!EnsureWalletIsAvailable(request.fHelp))\n         return NullUniValue;\n \n-    if (pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 2))\n+    if (CWallets::defaultWallet()->IsCrypted() && (request.fHelp || request.params.size() != 2))\n         throw runtime_error(\n             \"walletpassphrase \\\"passphrase\\\" timeout\\n\"\n             \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n@@ -1928,11 +1928,11 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     if (request.fHelp)\n         return true;\n-    if (!pwalletMain->IsCrypted())\n+    if (!CWallets::defaultWallet()->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n \n     // Note that the walletpassphrase is stored in request.params[0] which is not mlock()ed\n@@ -1944,20 +1944,20 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n \n     if (strWalletPass.length() > 0)\n     {\n-        if (!pwalletMain->Unlock(strWalletPass))\n+        if (!CWallets::defaultWallet()->Unlock(strWalletPass))\n             throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n     }\n     else\n         throw runtime_error(\n             \"walletpassphrase <passphrase> <timeout>\\n\"\n             \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n \n-    pwalletMain->TopUpKeyPool();\n+    CWallets::defaultWallet()->TopUpKeyPool();\n \n     int64_t nSleepTime = request.params[1].get_int64();\n     LOCK(cs_nWalletUnlockTime);\n     nWalletUnlockTime = GetTime() + nSleepTime;\n-    RPCRunLater(\"lockwallet\", boost::bind(LockWallet, pwalletMain), nSleepTime);\n+    RPCRunLater(\"lockwallet\", boost::bind(LockWallet, CWallets::defaultWallet()), nSleepTime);\n \n     return NullUniValue;\n }\n@@ -1968,7 +1968,7 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n     if (!EnsureWalletIsAvailable(request.fHelp))\n         return NullUniValue;\n \n-    if (pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 2))\n+    if (CWallets::defaultWallet()->IsCrypted() && (request.fHelp || request.params.size() != 2))\n         throw runtime_error(\n             \"walletpassphrasechange \\\"oldpassphrase\\\" \\\"newpassphrase\\\"\\n\"\n             \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\"\n@@ -1980,11 +1980,11 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     if (request.fHelp)\n         return true;\n-    if (!pwalletMain->IsCrypted())\n+    if (!CWallets::defaultWallet()->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n \n     // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n@@ -2002,7 +2002,7 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n             \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n             \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n \n-    if (!pwalletMain->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n+    if (!CWallets::defaultWallet()->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n         throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n \n     return NullUniValue;\n@@ -2014,7 +2014,7 @@ UniValue walletlock(const JSONRPCRequest& request)\n     if (!EnsureWalletIsAvailable(request.fHelp))\n         return NullUniValue;\n \n-    if (pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 0))\n+    if (CWallets::defaultWallet()->IsCrypted() && (request.fHelp || request.params.size() != 0))\n         throw runtime_error(\n             \"walletlock\\n\"\n             \"\\nRemoves the wallet encryption key from memory, locking the wallet.\\n\"\n@@ -2031,16 +2031,16 @@ UniValue walletlock(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"walletlock\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     if (request.fHelp)\n         return true;\n-    if (!pwalletMain->IsCrypted())\n+    if (!CWallets::defaultWallet()->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n \n     {\n         LOCK(cs_nWalletUnlockTime);\n-        pwalletMain->Lock();\n+        CWallets::defaultWallet()->Lock();\n         nWalletUnlockTime = 0;\n     }\n \n@@ -2053,7 +2053,7 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n     if (!EnsureWalletIsAvailable(request.fHelp))\n         return NullUniValue;\n \n-    if (!pwalletMain->IsCrypted() && (request.fHelp || request.params.size() != 1))\n+    if (!CWallets::defaultWallet()->IsCrypted() && (request.fHelp || request.params.size() != 1))\n         throw runtime_error(\n             \"encryptwallet \\\"passphrase\\\"\\n\"\n             \"\\nEncrypts the wallet with 'passphrase'. This is for first time encryption.\\n\"\n@@ -2077,11 +2077,11 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"encryptwallet\", \"\\\"my pass phrase\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     if (request.fHelp)\n         return true;\n-    if (pwalletMain->IsCrypted())\n+    if (CWallets::defaultWallet()->IsCrypted())\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n \n     // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n@@ -2095,7 +2095,7 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n             \"encryptwallet <passphrase>\\n\"\n             \"Encrypts the wallet with <passphrase>.\");\n \n-    if (!pwalletMain->EncryptWallet(strWalletPass))\n+    if (!CWallets::defaultWallet()->EncryptWallet(strWalletPass))\n         throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: Failed to encrypt the wallet.\");\n \n     // BDB seems to have a bad habit of writing old data into\n@@ -2147,7 +2147,7 @@ UniValue lockunspent(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"lockunspent\", \"false, \\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\\\\\\\",\\\\\\\"vout\\\\\\\":1}]\\\"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     if (request.params.size() == 1)\n         RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VBOOL));\n@@ -2158,7 +2158,7 @@ UniValue lockunspent(const JSONRPCRequest& request)\n \n     if (request.params.size() == 1) {\n         if (fUnlock)\n-            pwalletMain->UnlockAllCoins();\n+            CWallets::defaultWallet()->UnlockAllCoins();\n         return true;\n     }\n \n@@ -2186,9 +2186,9 @@ UniValue lockunspent(const JSONRPCRequest& request)\n         COutPoint outpt(uint256S(txid), nOutput);\n \n         if (fUnlock)\n-            pwalletMain->UnlockCoin(outpt);\n+            CWallets::defaultWallet()->UnlockCoin(outpt);\n         else\n-            pwalletMain->LockCoin(outpt);\n+            CWallets::defaultWallet()->LockCoin(outpt);\n     }\n \n     return true;\n@@ -2225,10 +2225,10 @@ UniValue listlockunspent(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listlockunspent\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     vector<COutPoint> vOutpts;\n-    pwalletMain->ListLockedCoins(vOutpts);\n+    CWallets::defaultWallet()->ListLockedCoins(vOutpts);\n \n     UniValue ret(UniValue::VARR);\n \n@@ -2261,7 +2261,7 @@ UniValue settxfee(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"settxfee\", \"0.00001\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     // Amount\n     CAmount nAmount = AmountFromValue(request.params[0]);\n@@ -2297,20 +2297,20 @@ UniValue getwalletinfo(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getwalletinfo\", \"\")\n         );\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n     UniValue obj(UniValue::VOBJ);\n-    obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n-    obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n-    obj.push_back(Pair(\"unconfirmed_balance\", ValueFromAmount(pwalletMain->GetUnconfirmedBalance())));\n-    obj.push_back(Pair(\"immature_balance\",    ValueFromAmount(pwalletMain->GetImmatureBalance())));\n-    obj.push_back(Pair(\"txcount\",       (int)pwalletMain->mapWallet.size()));\n-    obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n-    obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain->GetKeyPoolSize()));\n-    if (pwalletMain->IsCrypted())\n+    obj.push_back(Pair(\"walletversion\", CWallets::defaultWallet()->GetVersion()));\n+    obj.push_back(Pair(\"balance\",       ValueFromAmount(CWallets::defaultWallet()->GetBalance())));\n+    obj.push_back(Pair(\"unconfirmed_balance\", ValueFromAmount(CWallets::defaultWallet()->GetUnconfirmedBalance())));\n+    obj.push_back(Pair(\"immature_balance\",    ValueFromAmount(CWallets::defaultWallet()->GetImmatureBalance())));\n+    obj.push_back(Pair(\"txcount\",       (int)CWallets::defaultWallet()->mapWallet.size()));\n+    obj.push_back(Pair(\"keypoololdest\", CWallets::defaultWallet()->GetOldestKeyPoolTime()));\n+    obj.push_back(Pair(\"keypoolsize\",   (int)CWallets::defaultWallet()->GetKeyPoolSize()));\n+    if (CWallets::defaultWallet()->IsCrypted())\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n-    CKeyID masterKeyID = pwalletMain->GetHDChain().masterKeyID;\n+    CKeyID masterKeyID = CWallets::defaultWallet()->GetHDChain().masterKeyID;\n     if (!masterKeyID.IsNull())\n          obj.push_back(Pair(\"hdmasterkeyid\", masterKeyID.GetHex()));\n     return obj;\n@@ -2333,9 +2333,9 @@ UniValue resendwallettransactions(const JSONRPCRequest& request)\n     if (!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n \n-    std::vector<uint256> txids = pwalletMain->ResendWalletTransactionsBefore(GetTime(), g_connman.get());\n+    std::vector<uint256> txids = CWallets::defaultWallet()->ResendWalletTransactionsBefore(GetTime(), g_connman.get());\n     UniValue result(UniValue::VARR);\n     BOOST_FOREACH(const uint256& txid, txids)\n     {\n@@ -2412,9 +2412,9 @@ UniValue listunspent(const JSONRPCRequest& request)\n \n     UniValue results(UniValue::VARR);\n     vector<COutput> vecOutputs;\n-    assert(pwalletMain != NULL);\n-    LOCK2(cs_main, pwalletMain->cs_wallet);\n-    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n+    assert(CWallets::defaultWallet() != NULL);\n+    LOCK2(cs_main, CWallets::defaultWallet()->cs_wallet);\n+    CWallets::defaultWallet()->AvailableCoins(vecOutputs, false, NULL, true);\n     BOOST_FOREACH(const COutput& out, vecOutputs) {\n         if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n             continue;\n@@ -2433,13 +2433,13 @@ UniValue listunspent(const JSONRPCRequest& request)\n         if (fValidAddress) {\n             entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n \n-            if (pwalletMain->mapAddressBook.count(address))\n-                entry.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address].name));\n+            if (CWallets::defaultWallet()->mapAddressBook.count(address))\n+                entry.push_back(Pair(\"account\", CWallets::defaultWallet()->mapAddressBook[address].name));\n \n             if (scriptPubKey.IsPayToScriptHash()) {\n                 const CScriptID& hash = boost::get<CScriptID>(address);\n                 CScript redeemScript;\n-                if (pwalletMain->GetCScript(hash, redeemScript))\n+                if (CWallets::defaultWallet()->GetCScript(hash, redeemScript))\n                     entry.push_back(Pair(\"redeemScript\", HexStr(redeemScript.begin(), redeemScript.end())));\n             }\n         }\n@@ -2571,7 +2571,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     CAmount nFeeOut;\n     string strFailReason;\n \n-    if(!pwalletMain->FundTransaction(tx, nFeeOut, overrideEstimatedFeerate, feeRate, changePosition, strFailReason, includeWatching, lockUnspents, changeAddress))\n+    if(!CWallets::defaultWallet()->FundTransaction(tx, nFeeOut, overrideEstimatedFeerate, feeRate, changePosition, strFailReason, includeWatching, lockUnspents, changeAddress))\n         throw JSONRPCError(RPC_INTERNAL_ERROR, strFailReason);\n \n     UniValue result(UniValue::VOBJ);"
      },
      {
        "sha": "3390b0207d5a9ea2102984162a6ec60d2102bdb2",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -11,13 +11,13 @@\n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n-extern CWallet* pwalletMain;\n-\n BOOST_FIXTURE_TEST_SUITE(accounting_tests, WalletTestingSetup)\n \n static void\n GetResults(std::map<CAmount, CAccountingEntry>& results)\n {\n+    CWallet* pwalletMain = CWallets::defaultWallet();\n+\n     std::list<CAccountingEntry> aes;\n \n     results.clear();\n@@ -31,6 +31,7 @@ GetResults(std::map<CAmount, CAccountingEntry>& results)\n \n BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n {\n+    CWallet* pwalletMain = CWallets::defaultWallet();\n     std::vector<CWalletTx*> vpwtx;\n     CWalletTx wtx;\n     CAccountingEntry ae;"
      },
      {
        "sha": "7c406ac278cdcf9d68d930ea6a848aa274e2bc38",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -14,18 +14,17 @@ WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n     bitdb.MakeMock();\n \n     bool fFirstRun;\n-    pwalletMain = new CWallet(\"wallet_test.dat\");\n-    pwalletMain->LoadWallet(fFirstRun);\n-    RegisterValidationInterface(pwalletMain);\n+    CWallets::addWallet(new CWallet(\"wallet_test.dat\"));\n+    CWallets::defaultWallet()->LoadWallet(fFirstRun);\n+    RegisterValidationInterface(CWallets::defaultWallet());\n \n     RegisterWalletRPCCommands(tableRPC);\n }\n \n WalletTestingSetup::~WalletTestingSetup()\n {\n-    UnregisterValidationInterface(pwalletMain);\n-    delete pwalletMain;\n-    pwalletMain = NULL;\n+    UnregisterValidationInterface(CWallets::defaultWallet());\n+    CWallets::destruct();\n \n     bitdb.Flush(true);\n     bitdb.Reset();"
      },
      {
        "sha": "c3a96cfcdbed21c960235d0b0fc656019fa40bd9",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -34,7 +34,6 @@\n \n using namespace std;\n \n-CWallet* pwalletMain = NULL;\n /** Transaction fee set by the user */\n CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;\n@@ -59,6 +58,7 @@ CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);\n \n const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n \n+std::vector<CWallet*> CWallets::wallets = {};\n /** @defgroup mapWallet\n  *\n  * @{\n@@ -3377,7 +3377,7 @@ std::string CWallet::GetWalletHelpString(bool showDebug)\n bool CWallet::InitLoadWallet()\n {\n     if (GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n-        pwalletMain = NULL;\n+        CWallets::destruct();\n         LogPrintf(\"Wallet disabled!\\n\");\n         return true;\n     }\n@@ -3544,7 +3544,7 @@ bool CWallet::InitLoadWallet()\n         LogPrintf(\"mapAddressBook.size() = %u\\n\",  walletInstance->mapAddressBook.size());\n     }\n \n-    pwalletMain = walletInstance;\n+    CWallets::addWallet(walletInstance);\n \n     return true;\n }"
      },
      {
        "sha": "b17a5766e6568855ef2784a1e1047e572a944128",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 33,
        "deletions": 2,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c8b5b746acb41de1744db16301ca127d4f9c08f0/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=c8b5b746acb41de1744db16301ca127d4f9c08f0",
        "patch": "@@ -29,8 +29,6 @@\n #include <boost/shared_ptr.hpp>\n #include <boost/thread.hpp>\n \n-extern CWallet* pwalletMain;\n-\n /**\n  * Settings\n  */\n@@ -993,4 +991,37 @@ class CAccount\n     }\n };\n \n+static CCriticalSection cs_wallets;\n+class CWallets\n+{\n+private:\n+    static std::vector<CWallet*> wallets;\n+public:\n+    static CWallet* defaultWallet()\n+    {\n+        LOCK(cs_wallets);\n+        if (!wallets.size())\n+            return NULL;\n+        return wallets[0];\n+    }\n+    static void addWallet(CWallet* newWallet)\n+    {\n+        LOCK(cs_wallets);\n+        wallets.push_back(newWallet);\n+    }\n+    static void flushAllWallets(bool shutdown)\n+    {\n+        LOCK(cs_wallets);\n+        for (CWallet *pWallet : wallets)\n+            pWallet->Flush(shutdown);\n+    }\n+    static void destruct()\n+    {\n+        LOCK(cs_wallets);\n+        for (CWallet *pWallet : wallets)\n+            delete pWallet;\n+        wallets.clear();\n+    }\n+};\n+\n #endif // BITCOIN_WALLET_WALLET_H"
      }
    ]
  }
]