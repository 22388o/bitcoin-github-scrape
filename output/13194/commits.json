[
  {
    "sha": "c814e2e7e81fd01fcb07f4a28435741bdc463801",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjODE0ZTJlN2U4MWZkMDFmY2IwN2Y0YTI4NDM1NzQxYmRjNDYzODAx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-05-09T03:24:06Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2018-05-29T21:40:18Z"
      },
      "message": "Remove template matching and pseudo opcodes\n\nThe current code contains a rather complex script template matching engine,\nwhich is only used for 3 particular script types (P2PK, P2PKH, multisig).\nThe first two of these are trivial to match for otherwise, and a specialized\nmatcher for multisig is both more compact and more efficient than a generic\none.\n\nThe goal is being more flexible, so that for example larger standard multisigs\ninside SegWit outputs are more easy to implement.\n\nAs a side-effect, it also gets rid of the pseudo opcodes hack.",
      "tree": {
        "sha": "cbbbdd22d0124e8988d8e6e0c4de6ab1dcb98925",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cbbbdd22d0124e8988d8e6e0c4de6ab1dcb98925"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c814e2e7e81fd01fcb07f4a28435741bdc463801",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c814e2e7e81fd01fcb07f4a28435741bdc463801",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c814e2e7e81fd01fcb07f4a28435741bdc463801",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c814e2e7e81fd01fcb07f4a28435741bdc463801/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6b824c090f53d0a56833930fd38c41bcaec8ff4a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b824c090f53d0a56833930fd38c41bcaec8ff4a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6b824c090f53d0a56833930fd38c41bcaec8ff4a"
      }
    ],
    "stats": {
      "total": 169,
      "additions": 66,
      "deletions": 103
    },
    "files": [
      {
        "sha": "bb254547c89d448ea3b8adf3942c16dc71b05594",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=c814e2e7e81fd01fcb07f4a28435741bdc463801",
        "patch": "@@ -33,10 +33,10 @@ class CPubKey\n     /**\n      * secp256k1:\n      */\n-    static const unsigned int PUBLIC_KEY_SIZE             = 65;\n-    static const unsigned int COMPRESSED_PUBLIC_KEY_SIZE  = 33;\n-    static const unsigned int SIGNATURE_SIZE              = 72;\n-    static const unsigned int COMPACT_SIGNATURE_SIZE      = 65;\n+    static constexpr unsigned int PUBLIC_KEY_SIZE             = 65;\n+    static constexpr unsigned int COMPRESSED_PUBLIC_KEY_SIZE  = 33;\n+    static constexpr unsigned int SIGNATURE_SIZE              = 72;\n+    static constexpr unsigned int COMPACT_SIGNATURE_SIZE      = 65;\n     /**\n      * see www.keylength.com\n      * script supports up to 75 for single byte push"
      },
      {
        "sha": "c84c7b8ec117c4667901d51d866cddd98d92ef37",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=c814e2e7e81fd01fcb07f4a28435741bdc463801",
        "patch": "@@ -141,11 +141,6 @@ const char* GetOpName(opcodetype opcode)\n \n     case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n \n-    // Note:\n-    //  The template matching params OP_SMALLINTEGER/etc are defined in opcodetype enum\n-    //  as kind of implementation hack, they are *NOT* real opcodes.  If found in real\n-    //  Script, just let the default: case deal with them.\n-\n     default:\n         return \"OP_UNKNOWN\";\n     }"
      },
      {
        "sha": "a4f377dd9471eeed9b691b6df45d53b2be1ee338",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=c814e2e7e81fd01fcb07f4a28435741bdc463801",
        "patch": "@@ -181,13 +181,6 @@ enum opcodetype\n     OP_NOP9 = 0xb8,\n     OP_NOP10 = 0xb9,\n \n-\n-    // template matching params\n-    OP_SMALLINTEGER = 0xfa,\n-    OP_PUBKEYS = 0xfb,\n-    OP_PUBKEYHASH = 0xfd,\n-    OP_PUBKEY = 0xfe,\n-\n     OP_INVALIDOPCODE = 0xff,\n };\n "
      },
      {
        "sha": "53fcbe37de8c616750cc29a9f87a1dd5ab3ac1b4",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 87,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c814e2e7e81fd01fcb07f4a28435741bdc463801/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=c814e2e7e81fd01fcb07f4a28435741bdc463801",
        "patch": "@@ -35,22 +35,54 @@ const char* GetTxnOutputType(txnouttype t)\n     return nullptr;\n }\n \n-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet)\n+static bool MatchPayToPubkey(const CScript& script, valtype& pubkey)\n {\n-    // Templates\n-    static std::multimap<txnouttype, CScript> mTemplates;\n-    if (mTemplates.empty())\n-    {\n-        // Standard tx, sender provides pubkey, receiver adds signature\n-        mTemplates.insert(std::make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n+    if (script.size() == CPubKey::PUBLIC_KEY_SIZE + 2 && script[0] == CPubKey::PUBLIC_KEY_SIZE && script.back() == OP_CHECKSIG) {\n+        pubkey = valtype(script.begin() + 1, script.begin() + CPubKey::PUBLIC_KEY_SIZE + 1);\n+        return CPubKey::ValidSize(pubkey);\n+    }\n+    if (script.size() == CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 2 && script[0] == CPubKey::COMPRESSED_PUBLIC_KEY_SIZE && script.back() == OP_CHECKSIG) {\n+        pubkey = valtype(script.begin() + 1, script.begin() + CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1);\n+        return CPubKey::ValidSize(pubkey);\n+    }\n+    return false;\n+}\n \n-        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        mTemplates.insert(std::make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n+static bool MatchPayToPubkeyHash(const CScript& script, valtype& pubkeyhash)\n+{\n+    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160 && script[2] == 20 && script[23] == OP_EQUALVERIFY && script[24] == OP_CHECKSIG) {\n+        pubkeyhash = valtype(script.begin () + 3, script.begin() + 23);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Test for \"small positive integer\" script opcodes - OP_1 through OP_16. */\n+static constexpr bool IsSmallInteger(opcodetype opcode)\n+{\n+    return opcode >= OP_1 && opcode <= OP_16;\n+}\n \n-        // Sender provides N pubkeys, receivers provides M signatures\n-        mTemplates.insert(std::make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n+static bool MatchMultisig(const CScript& script, unsigned int& required, std::vector<valtype>& pubkeys)\n+{\n+    opcodetype opcode;\n+    valtype data;\n+    CScript::const_iterator it = script.begin();\n+    if (script.size() < 1 || script.back() != OP_CHECKMULTISIG) return false;\n+\n+    if (!script.GetOp(it, opcode, data) || !IsSmallInteger(opcode)) return false;\n+    required = CScript::DecodeOP_N(opcode);\n+    while (script.GetOp(it, opcode, data) && CPubKey::ValidSize(data)) {\n+        pubkeys.emplace_back(std::move(data));\n     }\n+    if (!IsSmallInteger(opcode)) return false;\n+    unsigned int keys = CScript::DecodeOP_N(opcode);\n+    if (pubkeys.size() != keys || keys < required) return false;\n+    return (it + 1 == script.end());\n+}\n \n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet)\n+{\n     vSolutionsRet.clear();\n \n     // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n@@ -95,84 +127,27 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n         return true;\n     }\n \n-    // Scan templates\n-    const CScript& script1 = scriptPubKey;\n-    for (const std::pair<txnouttype, CScript>& tplate : mTemplates)\n-    {\n-        const CScript& script2 = tplate.second;\n-        vSolutionsRet.clear();\n+    std::vector<unsigned char> data;\n+    if (MatchPayToPubkey(scriptPubKey, data)) {\n+        typeRet = TX_PUBKEY;\n+        vSolutionsRet.push_back(std::move(data));\n+        return true;\n+    }\n \n-        opcodetype opcode1, opcode2;\n-        std::vector<unsigned char> vch1, vch2;\n+    if (MatchPayToPubkeyHash(scriptPubKey, data)) {\n+        typeRet = TX_PUBKEYHASH;\n+        vSolutionsRet.push_back(std::move(data));\n+        return true;\n+    }\n \n-        // Compare\n-        CScript::const_iterator pc1 = script1.begin();\n-        CScript::const_iterator pc2 = script2.begin();\n-        while (true)\n-        {\n-            if (pc1 == script1.end() && pc2 == script2.end())\n-            {\n-                // Found a match\n-                typeRet = tplate.first;\n-                if (typeRet == TX_MULTISIG)\n-                {\n-                    // Additional checks for TX_MULTISIG:\n-                    unsigned char m = vSolutionsRet.front()[0];\n-                    unsigned char n = vSolutionsRet.back()[0];\n-                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n-                        return false;\n-                }\n-                return true;\n-            }\n-            if (!script1.GetOp(pc1, opcode1, vch1))\n-                break;\n-            if (!script2.GetOp(pc2, opcode2, vch2))\n-                break;\n-\n-            // Template matching opcodes:\n-            if (opcode2 == OP_PUBKEYS)\n-            {\n-                while (CPubKey::ValidSize(vch1))\n-                {\n-                    vSolutionsRet.push_back(vch1);\n-                    if (!script1.GetOp(pc1, opcode1, vch1))\n-                        break;\n-                }\n-                if (!script2.GetOp(pc2, opcode2, vch2))\n-                    break;\n-                // Normal situation is to fall through\n-                // to other if/else statements\n-            }\n-\n-            if (opcode2 == OP_PUBKEY)\n-            {\n-                if (!CPubKey::ValidSize(vch1))\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_PUBKEYHASH)\n-            {\n-                if (vch1.size() != sizeof(uint160))\n-                    break;\n-                vSolutionsRet.push_back(vch1);\n-            }\n-            else if (opcode2 == OP_SMALLINTEGER)\n-            {   // Single-byte small integer pushed onto vSolutions\n-                if (opcode1 == OP_0 ||\n-                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n-                {\n-                    char n = (char)CScript::DecodeOP_N(opcode1);\n-                    vSolutionsRet.push_back(valtype(1, n));\n-                }\n-                else\n-                    break;\n-            }\n-            else if (opcode1 != opcode2 || vch1 != vch2)\n-            {\n-                // Others must match exactly\n-                break;\n-            }\n-        }\n+    unsigned int required;\n+    std::vector<std::vector<unsigned char>> keys;\n+    if (MatchMultisig(scriptPubKey, required, keys)) {\n+        typeRet = TX_MULTISIG;\n+        vSolutionsRet.push_back({static_cast<unsigned char>(required)}); // safe as required is in range 1..16\n+        vSolutionsRet.insert(vSolutionsRet.end(), keys.begin(), keys.end());\n+        vSolutionsRet.push_back({static_cast<unsigned char>(keys.size())}); // safe as size is in range 1..16\n+        return true;\n     }\n \n     vSolutionsRet.clear();"
      }
    ]
  }
]