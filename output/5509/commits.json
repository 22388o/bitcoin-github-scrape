[
  {
    "sha": "a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMmIwNGRkZmU2NDUyZTdkNjI3NGY0MDk2YmYzZjJhZWU2OTVhNmQ5",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-24T22:25:58Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-02-04T03:41:01Z"
      },
      "message": "build: fix newer boost build with c++11",
      "tree": {
        "sha": "7824e65ba6a141c3420999b8c195434009c81cef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7824e65ba6a141c3420999b8c195434009c81cef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fcf646c9b08e7f846d6c99314f937ace50809d7a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcf646c9b08e7f846d6c99314f937ace50809d7a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fcf646c9b08e7f846d6c99314f937ace50809d7a"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 10,
      "deletions": 10
    },
    "files": [
      {
        "sha": "1fd3b0168125e1c64fd4923ed5e4730f9ab9c035",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
        "patch": "@@ -156,11 +156,11 @@ class CMainParams : public CChainParams {\n         vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\"));\n         vSeeds.push_back(CDNSSeedData(\"xf2.org\", \"bitseed.xf2.org\"));\n \n-        base58Prefixes[PUBKEY_ADDRESS] = boost::assign::list_of(0);\n-        base58Prefixes[SCRIPT_ADDRESS] = boost::assign::list_of(5);\n-        base58Prefixes[SECRET_KEY] =     boost::assign::list_of(128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E);\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4);\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n+        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4).convert_to_container<std::vector<unsigned char> >();\n \n         convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main));\n \n@@ -214,11 +214,11 @@ class CTestNetParams : public CMainParams {\n         vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"testnet-seed.bluematt.me\"));\n         vSeeds.push_back(CDNSSeedData(\"bitcoin.schildbach.de\", \"testnet-seed.bitcoin.schildbach.de\"));\n \n-        base58Prefixes[PUBKEY_ADDRESS] = boost::assign::list_of(111);\n-        base58Prefixes[SCRIPT_ADDRESS] = boost::assign::list_of(196);\n-        base58Prefixes[SECRET_KEY]     = boost::assign::list_of(239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF);\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94);\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n+        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n \n         convertSeed6(vFixedSeeds, pnSeed6_test, ARRAYLEN(pnSeed6_test));\n "
      }
    ]
  },
  {
    "sha": "bbacd88204090e9233be375199f52d378bb75627",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYmFjZDg4MjA0MDkwZTkyMzNiZTM3NTE5OWY1MmQzNzhiYjc1NjI3",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-12-19T01:00:01Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-02-04T03:41:33Z"
      },
      "message": "c++11: MOVEONLY: move function definitions out of the header\n\nThese need to be moved out of the header in order to resolve a circular\ndependency between CWallet and CTxWallet. See next commit.",
      "tree": {
        "sha": "9a6d9f9828d2cb9583eb733a78ec5734a50dbb8e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a6d9f9828d2cb9583eb733a78ec5734a50dbb8e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bbacd88204090e9233be375199f52d378bb75627",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbacd88204090e9233be375199f52d378bb75627",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bbacd88204090e9233be375199f52d378bb75627",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbacd88204090e9233be375199f52d378bb75627/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a2b04ddfe6452e7d6274f4096bf3f2aee695a6d9"
      }
    ],
    "stats": {
      "total": 380,
      "additions": 195,
      "deletions": 185
    },
    "files": [
      {
        "sha": "b51c4d4b14aaf9f3025f2440eda2530b9f817073",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 187,
        "deletions": 0,
        "changes": 187,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbacd88204090e9233be375199f52d378bb75627/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbacd88204090e9233be375199f52d378bb75627/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=bbacd88204090e9233be375199f52d378bb75627",
        "patch": "@@ -1015,6 +1015,193 @@ set<uint256> CWalletTx::GetConflicts() const\n     return result;\n }\n \n+CAmount CWalletTx::GetDebit(const isminefilter& filter) const\n+{\n+    if (vin.empty())\n+        return 0;\n+\n+    CAmount debit = 0;\n+    if(filter & ISMINE_SPENDABLE)\n+    {\n+        if (fDebitCached)\n+            debit += nDebitCached;\n+        else\n+        {\n+            nDebitCached = pwallet->GetDebit(*this, ISMINE_SPENDABLE);\n+            fDebitCached = true;\n+            debit += nDebitCached;\n+        }\n+    }\n+    if(filter & ISMINE_WATCH_ONLY)\n+    {\n+        if(fWatchDebitCached)\n+            debit += nWatchDebitCached;\n+        else\n+        {\n+            nWatchDebitCached = pwallet->GetDebit(*this, ISMINE_WATCH_ONLY);\n+            fWatchDebitCached = true;\n+            debit += nWatchDebitCached;\n+        }\n+    }\n+    return debit;\n+}\n+\n+CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n+{\n+    // Must wait until coinbase is safely deep enough in the chain before valuing it\n+    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n+        return 0;\n+\n+    int64_t credit = 0;\n+    if (filter & ISMINE_SPENDABLE)\n+    {\n+        // GetBalance can assume transactions in mapWallet won't change\n+        if (fCreditCached)\n+            credit += nCreditCached;\n+        else\n+        {\n+            nCreditCached = pwallet->GetCredit(*this, ISMINE_SPENDABLE);\n+            fCreditCached = true;\n+            credit += nCreditCached;\n+        }\n+    }\n+    if (filter & ISMINE_WATCH_ONLY)\n+    {\n+        if (fWatchCreditCached)\n+            credit += nWatchCreditCached;\n+        else\n+        {\n+            nWatchCreditCached = pwallet->GetCredit(*this, ISMINE_WATCH_ONLY);\n+            fWatchCreditCached = true;\n+            credit += nWatchCreditCached;\n+        }\n+    }\n+    return credit;\n+}\n+\n+CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n+{\n+    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n+    {\n+        if (fUseCache && fImmatureCreditCached)\n+            return nImmatureCreditCached;\n+        nImmatureCreditCached = pwallet->GetCredit(*this, ISMINE_SPENDABLE);\n+        fImmatureCreditCached = true;\n+        return nImmatureCreditCached;\n+    }\n+\n+    return 0;\n+}\n+\n+CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const\n+{\n+    if (pwallet == 0)\n+        return 0;\n+\n+    // Must wait until coinbase is safely deep enough in the chain before valuing it\n+    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n+        return 0;\n+\n+    if (fUseCache && fAvailableCreditCached)\n+        return nAvailableCreditCached;\n+\n+    CAmount nCredit = 0;\n+    uint256 hashTx = GetHash();\n+    for (unsigned int i = 0; i < vout.size(); i++)\n+    {\n+        if (!pwallet->IsSpent(hashTx, i))\n+        {\n+            const CTxOut &txout = vout[i];\n+            nCredit += pwallet->GetCredit(txout, ISMINE_SPENDABLE);\n+            if (!MoneyRange(nCredit))\n+                throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+        }\n+    }\n+\n+    nAvailableCreditCached = nCredit;\n+    fAvailableCreditCached = true;\n+    return nCredit;\n+}\n+\n+CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool& fUseCache) const\n+{\n+    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n+    {\n+        if (fUseCache && fImmatureWatchCreditCached)\n+            return nImmatureWatchCreditCached;\n+        nImmatureWatchCreditCached = pwallet->GetCredit(*this, ISMINE_WATCH_ONLY);\n+        fImmatureWatchCreditCached = true;\n+        return nImmatureWatchCreditCached;\n+    }\n+\n+    return 0;\n+}\n+\n+CAmount CWalletTx::GetAvailableWatchOnlyCredit(const bool& fUseCache) const\n+{\n+    if (pwallet == 0)\n+        return 0;\n+\n+    // Must wait until coinbase is safely deep enough in the chain before valuing it\n+    if (IsCoinBase() && GetBlocksToMaturity() > 0)\n+        return 0;\n+\n+    if (fUseCache && fAvailableWatchCreditCached)\n+        return nAvailableWatchCreditCached;\n+\n+    CAmount nCredit = 0;\n+    for (unsigned int i = 0; i < vout.size(); i++)\n+    {\n+        if (!pwallet->IsSpent(GetHash(), i))\n+        {\n+            const CTxOut &txout = vout[i];\n+            nCredit += pwallet->GetCredit(txout, ISMINE_WATCH_ONLY);\n+            if (!MoneyRange(nCredit))\n+                throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+        }\n+    }\n+\n+    nAvailableWatchCreditCached = nCredit;\n+    fAvailableWatchCreditCached = true;\n+    return nCredit;\n+}\n+\n+CAmount CWalletTx::GetChange() const\n+{\n+    if (fChangeCached)\n+        return nChangeCached;\n+    nChangeCached = pwallet->GetChange(*this);\n+    fChangeCached = true;\n+    return nChangeCached;\n+}\n+\n+bool CWalletTx::IsTrusted() const\n+{\n+    // Quick answer in most cases\n+    if (!IsFinalTx(*this))\n+        return false;\n+    int nDepth = GetDepthInMainChain();\n+    if (nDepth >= 1)\n+        return true;\n+    if (nDepth < 0)\n+        return false;\n+    if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx's cached debit\n+        return false;\n+\n+    // Trusted if all inputs are from us and are in the mempool:\n+    BOOST_FOREACH(const CTxIn& txin, vin)\n+    {\n+        // Transactions not sent by us: not trusted\n+        const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n+        if (parent == NULL)\n+            return false;\n+        const CTxOut& parentOut = parent->vout[txin.prevout.n];\n+        if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE)\n+            return false;\n+    }\n+    return true;\n+}\n+\n void CWallet::ResendWalletTransactions()\n {\n     // Do this infrequently and randomly to avoid giving away"
      },
      {
        "sha": "d571b92b60661bf1ca9ae31ef2f435d82187c0e5",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 8,
        "deletions": 185,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bbacd88204090e9233be375199f52d378bb75627/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bbacd88204090e9233be375199f52d378bb75627/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=bbacd88204090e9233be375199f52d378bb75627",
        "patch": "@@ -705,165 +705,13 @@ class CWalletTx : public CMerkleTx\n     }\n \n     //! filter decides which addresses will count towards the debit\n-    CAmount GetDebit(const isminefilter& filter) const\n-    {\n-        if (vin.empty())\n-            return 0;\n-\n-        CAmount debit = 0;\n-        if(filter & ISMINE_SPENDABLE)\n-        {\n-            if (fDebitCached)\n-                debit += nDebitCached;\n-            else\n-            {\n-                nDebitCached = pwallet->GetDebit(*this, ISMINE_SPENDABLE);\n-                fDebitCached = true;\n-                debit += nDebitCached;\n-            }\n-        }\n-        if(filter & ISMINE_WATCH_ONLY)\n-        {\n-            if(fWatchDebitCached)\n-                debit += nWatchDebitCached;\n-            else\n-            {\n-                nWatchDebitCached = pwallet->GetDebit(*this, ISMINE_WATCH_ONLY);\n-                fWatchDebitCached = true;\n-                debit += nWatchDebitCached;\n-            }\n-        }\n-        return debit;\n-    }\n-\n-    CAmount GetCredit(const isminefilter& filter) const\n-    {\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n-\n-        int64_t credit = 0;\n-        if (filter & ISMINE_SPENDABLE)\n-        {\n-            // GetBalance can assume transactions in mapWallet won't change\n-            if (fCreditCached)\n-                credit += nCreditCached;\n-            else\n-            {\n-                nCreditCached = pwallet->GetCredit(*this, ISMINE_SPENDABLE);\n-                fCreditCached = true;\n-                credit += nCreditCached;\n-            }\n-        }\n-        if (filter & ISMINE_WATCH_ONLY)\n-        {\n-            if (fWatchCreditCached)\n-                credit += nWatchCreditCached;\n-            else\n-            {\n-                nWatchCreditCached = pwallet->GetCredit(*this, ISMINE_WATCH_ONLY);\n-                fWatchCreditCached = true;\n-                credit += nWatchCreditCached;\n-            }\n-        }\n-        return credit;\n-    }\n-\n-    CAmount GetImmatureCredit(bool fUseCache=true) const\n-    {\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n-        {\n-            if (fUseCache && fImmatureCreditCached)\n-                return nImmatureCreditCached;\n-            nImmatureCreditCached = pwallet->GetCredit(*this, ISMINE_SPENDABLE);\n-            fImmatureCreditCached = true;\n-            return nImmatureCreditCached;\n-        }\n-\n-        return 0;\n-    }\n-\n-    CAmount GetAvailableCredit(bool fUseCache=true) const\n-    {\n-        if (pwallet == 0)\n-            return 0;\n-\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n-\n-        if (fUseCache && fAvailableCreditCached)\n-            return nAvailableCreditCached;\n-\n-        CAmount nCredit = 0;\n-        uint256 hashTx = GetHash();\n-        for (unsigned int i = 0; i < vout.size(); i++)\n-        {\n-            if (!pwallet->IsSpent(hashTx, i))\n-            {\n-                const CTxOut &txout = vout[i];\n-                nCredit += pwallet->GetCredit(txout, ISMINE_SPENDABLE);\n-                if (!MoneyRange(nCredit))\n-                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit(): value out of range\");\n-            }\n-        }\n-\n-        nAvailableCreditCached = nCredit;\n-        fAvailableCreditCached = true;\n-        return nCredit;\n-    }\n-\n-    CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const\n-    {\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())\n-        {\n-            if (fUseCache && fImmatureWatchCreditCached)\n-                return nImmatureWatchCreditCached;\n-            nImmatureWatchCreditCached = pwallet->GetCredit(*this, ISMINE_WATCH_ONLY);\n-            fImmatureWatchCreditCached = true;\n-            return nImmatureWatchCreditCached;\n-        }\n-\n-        return 0;\n-    }\n-\n-    CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const\n-    {\n-        if (pwallet == 0)\n-            return 0;\n-\n-        // Must wait until coinbase is safely deep enough in the chain before valuing it\n-        if (IsCoinBase() && GetBlocksToMaturity() > 0)\n-            return 0;\n-\n-        if (fUseCache && fAvailableWatchCreditCached)\n-            return nAvailableWatchCreditCached;\n-\n-        CAmount nCredit = 0;\n-        for (unsigned int i = 0; i < vout.size(); i++)\n-        {\n-            if (!pwallet->IsSpent(GetHash(), i))\n-            {\n-                const CTxOut &txout = vout[i];\n-                nCredit += pwallet->GetCredit(txout, ISMINE_WATCH_ONLY);\n-                if (!MoneyRange(nCredit))\n-                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit(): value out of range\");\n-            }\n-        }\n-\n-        nAvailableWatchCreditCached = nCredit;\n-        fAvailableWatchCreditCached = true;\n-        return nCredit;\n-    }\n-\n-    CAmount GetChange() const\n-    {\n-        if (fChangeCached)\n-            return nChangeCached;\n-        nChangeCached = pwallet->GetChange(*this);\n-        fChangeCached = true;\n-        return nChangeCached;\n-    }\n+    CAmount GetDebit(const isminefilter& filter) const;\n+    CAmount GetCredit(const isminefilter& filter) const;\n+    CAmount GetImmatureCredit(bool fUseCache=true) const;\n+    CAmount GetAvailableCredit(bool fUseCache=true) const;\n+    CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const;\n+    CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const;\n+    CAmount GetChange() const;\n \n     void GetAmounts(std::list<COutputEntry>& listReceived,\n                     std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n@@ -876,32 +724,7 @@ class CWalletTx : public CMerkleTx\n         return (GetDebit(filter) > 0);\n     }\n \n-    bool IsTrusted() const\n-    {\n-        // Quick answer in most cases\n-        if (!IsFinalTx(*this))\n-            return false;\n-        int nDepth = GetDepthInMainChain();\n-        if (nDepth >= 1)\n-            return true;\n-        if (nDepth < 0)\n-            return false;\n-        if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx's cached debit\n-            return false;\n-\n-        // Trusted if all inputs are from us and are in the mempool:\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-        {\n-            // Transactions not sent by us: not trusted\n-            const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n-            if (parent == NULL)\n-                return false;\n-            const CTxOut& parentOut = parent->vout[txin.prevout.n];\n-            if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE)\n-                return false;\n-        }\n-        return true;\n-    }\n+    bool IsTrusted() const;\n \n     bool WriteToDisk(CWalletDB *pwalletdb);\n "
      }
    ]
  },
  {
    "sha": "3447cf87e27262c57031361b3659fef938783295",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDQ3Y2Y4N2UyNzI2MmM1NzAzMTM2MWIzNjU5ZmVmOTM4NzgzMjk1",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-12-19T01:03:51Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-02-04T04:30:59Z"
      },
      "message": "c++11: MOVEONLY: break circular dependency in wallet\n\nc++11 (libc++'s stdlib implementation anyway) doesn't allow for map types to be\nforward-declared. for example:\n\nclass foo;\nstd::map<int, foo> bar; // error, foo has not been defined.\nclass foo{};\n\nSince CWallet and CWalletTx are inter-dependent, but only std::map<*,CWalletTx>\nis used, forward-declare CWallet instead and define CWalletTx first.\n\nDespite the mangled git diff, this change only amounts to moving ~320 lines in\na single chunk.",
      "tree": {
        "sha": "b4328a8a7658eebea713d7e2a3f05e4e693db560",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b4328a8a7658eebea713d7e2a3f05e4e693db560"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3447cf87e27262c57031361b3659fef938783295",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3447cf87e27262c57031361b3659fef938783295",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3447cf87e27262c57031361b3659fef938783295",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3447cf87e27262c57031361b3659fef938783295/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bbacd88204090e9233be375199f52d378bb75627",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bbacd88204090e9233be375199f52d378bb75627",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bbacd88204090e9233be375199f52d378bb75627"
      }
    ],
    "stats": {
      "total": 990,
      "additions": 494,
      "deletions": 496
    },
    "files": [
      {
        "sha": "6ed87d1e687d5f3833fd9050ee456601241bc503",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 494,
        "deletions": 496,
        "changes": 990,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3447cf87e27262c57031361b3659fef938783295/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3447cf87e27262c57031361b3659fef938783295/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=3447cf87e27262c57031361b3659fef938783295",
        "patch": "@@ -103,114 +103,437 @@ class CAddressBookData\n     StringMap destdata;\n };\n \n-/** \n- * A CWallet is an extension of a keystore, which also maintains a set of transactions and balances,\n- * and provides the ability to create new transactions.\n- */\n-class CWallet : public CCryptoKeyStore, public CValidationInterface\n+\n+typedef std::map<std::string, std::string> mapValue_t;\n+\n+\n+static void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (!mapValue.count(\"n\"))\n+    {\n+        nOrderPos = -1; // TODO: calculate elsewhere\n+        return;\n+    }\n+    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n+}\n+\n+\n+static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (nOrderPos == -1)\n+        return;\n+    mapValue[\"n\"] = i64tostr(nOrderPos);\n+}\n+\n+struct COutputEntry\n+{\n+    CTxDestination destination;\n+    CAmount amount;\n+    int vout;\n+};\n+\n+/** A transaction with a merkle branch linking it to the block chain. */\n+class CMerkleTx : public CTransaction\n {\n private:\n-    bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n+    int GetDepthInMainChainINTERNAL(const CBlockIndex* &pindexRet) const;\n \n-    CWalletDB *pwalletdbEncryption;\n+public:\n+    uint256 hashBlock;\n+    std::vector<uint256> vMerkleBranch;\n+    int nIndex;\n \n-    //! the current wallet version: clients below this version are not able to load the wallet\n-    int nWalletVersion;\n+    // memory only\n+    mutable bool fMerkleVerified;\n \n-    //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n-    int nWalletMaxVersion;\n \n-    int64_t nNextResend;\n-    int64_t nLastResend;\n+    CMerkleTx()\n+    {\n+        Init();\n+    }\n \n-    /**\n-     * Used to keep track of spent outpoints, and\n-     * detect and report conflicts (double-spends or\n-     * mutated transactions where the mutant gets mined).\n-     */\n-    typedef std::multimap<COutPoint, uint256> TxSpends;\n-    TxSpends mapTxSpends;\n-    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n-    void AddToSpends(const uint256& wtxid);\n+    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n+    {\n+        Init();\n+    }\n \n-    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n+    void Init()\n+    {\n+        hashBlock = uint256();\n+        nIndex = -1;\n+        fMerkleVerified = false;\n+    }\n \n-public:\n-    /*\n-     * Main wallet lock.\n-     * This lock protects all the fields added by CWallet\n-     *   except for:\n-     *      fFileBacked (immutable after instantiation)\n-     *      strWalletFile (immutable after instantiation)\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(*(CTransaction*)this);\n+        nVersion = this->nVersion;\n+        READWRITE(hashBlock);\n+        READWRITE(vMerkleBranch);\n+        READWRITE(nIndex);\n+    }\n+\n+    int SetMerkleBranch(const CBlock& block);\n+\n+\n+    /**\n+     * Return depth of transaction in blockchain:\n+     * -1  : not in blockchain, and not in memory pool (conflicted transaction)\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n      */\n-    mutable CCriticalSection cs_wallet;\n+    int GetDepthInMainChain(const CBlockIndex* &pindexRet) const;\n+    int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n+    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChainINTERNAL(pindexRet) > 0; }\n+    int GetBlocksToMaturity() const;\n+    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectAbsurdFee=true);\n+};\n \n-    bool fFileBacked;\n-    std::string strWalletFile;\n+/** \n+ * A transaction with a bunch of additional info that only the owner cares about.\n+ * It includes any unrecorded transactions needed to link it back to the block chain.\n+ */\n+class CWalletTx : public CMerkleTx\n+{\n+private:\n+    const CWallet* pwallet;\n \n-    std::set<int64_t> setKeyPool;\n-    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n+public:\n+    mapValue_t mapValue;\n+    std::vector<std::pair<std::string, std::string> > vOrderForm;\n+    unsigned int fTimeReceivedIsTxTime;\n+    unsigned int nTimeReceived; //! time received by this node\n+    unsigned int nTimeSmart;\n+    char fFromMe;\n+    std::string strFromAccount;\n+    int64_t nOrderPos; //! position in ordered transaction list\n \n-    typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n-    MasterKeyMap mapMasterKeys;\n-    unsigned int nMasterKeyMaxID;\n+    // memory only\n+    mutable bool fDebitCached;\n+    mutable bool fCreditCached;\n+    mutable bool fImmatureCreditCached;\n+    mutable bool fAvailableCreditCached;\n+    mutable bool fWatchDebitCached;\n+    mutable bool fWatchCreditCached;\n+    mutable bool fImmatureWatchCreditCached;\n+    mutable bool fAvailableWatchCreditCached;\n+    mutable bool fChangeCached;\n+    mutable CAmount nDebitCached;\n+    mutable CAmount nCreditCached;\n+    mutable CAmount nImmatureCreditCached;\n+    mutable CAmount nAvailableCreditCached;\n+    mutable CAmount nWatchDebitCached;\n+    mutable CAmount nWatchCreditCached;\n+    mutable CAmount nImmatureWatchCreditCached;\n+    mutable CAmount nAvailableWatchCreditCached;\n+    mutable CAmount nChangeCached;\n \n-    CWallet()\n+    CWalletTx()\n     {\n-        SetNull();\n+        Init(NULL);\n     }\n \n-    CWallet(std::string strWalletFileIn)\n+    CWalletTx(const CWallet* pwalletIn)\n     {\n-        SetNull();\n+        Init(pwalletIn);\n+    }\n \n-        strWalletFile = strWalletFileIn;\n-        fFileBacked = true;\n+    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n+    {\n+        Init(pwalletIn);\n     }\n \n-    ~CWallet()\n+    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n     {\n-        delete pwalletdbEncryption;\n-        pwalletdbEncryption = NULL;\n+        Init(pwalletIn);\n     }\n \n-    void SetNull()\n+    void Init(const CWallet* pwalletIn)\n     {\n-        nWalletVersion = FEATURE_BASE;\n-        nWalletMaxVersion = FEATURE_BASE;\n-        fFileBacked = false;\n-        nMasterKeyMaxID = 0;\n-        pwalletdbEncryption = NULL;\n-        nOrderPosNext = 0;\n-        nNextResend = 0;\n-        nLastResend = 0;\n-        nTimeFirstKey = 0;\n+        pwallet = pwalletIn;\n+        mapValue.clear();\n+        vOrderForm.clear();\n+        fTimeReceivedIsTxTime = false;\n+        nTimeReceived = 0;\n+        nTimeSmart = 0;\n+        fFromMe = false;\n+        strFromAccount.clear();\n+        fDebitCached = false;\n+        fCreditCached = false;\n+        fImmatureCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fWatchDebitCached = false;\n+        fWatchCreditCached = false;\n+        fImmatureWatchCreditCached = false;\n+        fAvailableWatchCreditCached = false;\n+        fChangeCached = false;\n+        nDebitCached = 0;\n+        nCreditCached = 0;\n+        nImmatureCreditCached = 0;\n+        nAvailableCreditCached = 0;\n+        nWatchDebitCached = 0;\n+        nWatchCreditCached = 0;\n+        nAvailableWatchCreditCached = 0;\n+        nImmatureWatchCreditCached = 0;\n+        nChangeCached = 0;\n+        nOrderPos = -1;\n     }\n \n-    std::map<uint256, CWalletTx> mapWallet;\n+    ADD_SERIALIZE_METHODS;\n \n-    int64_t nOrderPosNext;\n-    std::map<uint256, int> mapRequestCount;\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (ser_action.ForRead())\n+            Init(NULL);\n+        char fSpent = false;\n \n-    std::map<CTxDestination, CAddressBookData> mapAddressBook;\n+        if (!ser_action.ForRead())\n+        {\n+            mapValue[\"fromaccount\"] = strFromAccount;\n \n-    CPubKey vchDefaultKey;\n+            WriteOrderPos(nOrderPos, mapValue);\n \n-    std::set<COutPoint> setLockedCoins;\n+            if (nTimeSmart)\n+                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+        }\n \n-    int64_t nTimeFirstKey;\n+        READWRITE(*(CMerkleTx*)this);\n+        std::vector<CMerkleTx> vUnused; //! Used to be vtxPrev\n+        READWRITE(vUnused);\n+        READWRITE(mapValue);\n+        READWRITE(vOrderForm);\n+        READWRITE(fTimeReceivedIsTxTime);\n+        READWRITE(nTimeReceived);\n+        READWRITE(fFromMe);\n+        READWRITE(fSpent);\n \n-    const CWalletTx* GetWalletTx(const uint256& hash) const;\n+        if (ser_action.ForRead())\n+        {\n+            strFromAccount = mapValue[\"fromaccount\"];\n \n-    //! check whether we are allowed to upgrade (or already support) to the named feature\n-    bool CanSupportFeature(enum WalletFeature wf) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n+            ReadOrderPos(nOrderPos, mapValue);\n \n-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL) const;\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const;\n+            nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n+        }\n \n-    bool IsSpent(const uint256& hash, unsigned int n) const;\n+        mapValue.erase(\"fromaccount\");\n+        mapValue.erase(\"version\");\n+        mapValue.erase(\"spent\");\n+        mapValue.erase(\"n\");\n+        mapValue.erase(\"timesmart\");\n+    }\n \n-    bool IsLockedCoin(uint256 hash, unsigned int n) const;\n+    //! make sure balances are recalculated\n+    void MarkDirty()\n+    {\n+        fCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fWatchDebitCached = false;\n+        fWatchCreditCached = false;\n+        fAvailableWatchCreditCached = false;\n+        fImmatureWatchCreditCached = false;\n+        fDebitCached = false;\n+        fChangeCached = false;\n+    }\n+\n+    void BindWallet(CWallet *pwalletIn)\n+    {\n+        pwallet = pwalletIn;\n+        MarkDirty();\n+    }\n+\n+    //! filter decides which addresses will count towards the debit\n+    CAmount GetDebit(const isminefilter& filter) const;\n+    CAmount GetCredit(const isminefilter& filter) const;\n+    CAmount GetImmatureCredit(bool fUseCache=true) const;\n+    CAmount GetAvailableCredit(bool fUseCache=true) const;\n+    CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const;\n+    CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const;\n+    CAmount GetChange() const;\n+\n+    void GetAmounts(std::list<COutputEntry>& listReceived,\n+                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n+\n+    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n+                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n+\n+    bool IsFromMe(const isminefilter& filter) const\n+    {\n+        return (GetDebit(filter) > 0);\n+    }\n+\n+    bool IsTrusted() const;\n+\n+    bool WriteToDisk(CWalletDB *pwalletdb);\n+\n+    int64_t GetTxTime() const;\n+    int GetRequestCount() const;\n+\n+    void RelayWalletTransaction();\n+\n+    std::set<uint256> GetConflicts() const;\n+};\n+\n+\n+\n+\n+class COutput\n+{\n+public:\n+    const CWalletTx *tx;\n+    int i;\n+    int nDepth;\n+    bool fSpendable;\n+\n+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn;\n+    }\n+\n+    std::string ToString() const;\n+};\n+\n+\n+\n+\n+/** Private key that includes an expiration date in case it never gets used. */\n+class CWalletKey\n+{\n+public:\n+    CPrivKey vchPrivKey;\n+    int64_t nTimeCreated;\n+    int64_t nTimeExpires;\n+    std::string strComment;\n+    //! todo: add something to note what created it (user, getnewaddress, change)\n+    //!   maybe should have a map<string, string> property map\n+\n+    CWalletKey(int64_t nExpires=0);\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(nVersion);\n+        READWRITE(vchPrivKey);\n+        READWRITE(nTimeCreated);\n+        READWRITE(nTimeExpires);\n+        READWRITE(LIMITED_STRING(strComment, 65536));\n+    }\n+};\n+\n+\n+\n+/** \n+ * A CWallet is an extension of a keystore, which also maintains a set of transactions and balances,\n+ * and provides the ability to create new transactions.\n+ */\n+class CWallet : public CCryptoKeyStore, public CValidationInterface\n+{\n+private:\n+    bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n+\n+    CWalletDB *pwalletdbEncryption;\n+\n+    //! the current wallet version: clients below this version are not able to load the wallet\n+    int nWalletVersion;\n+\n+    //! the maximum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n+    int nWalletMaxVersion;\n+\n+    int64_t nNextResend;\n+    int64_t nLastResend;\n+\n+    /**\n+     * Used to keep track of spent outpoints, and\n+     * detect and report conflicts (double-spends or\n+     * mutated transactions where the mutant gets mined).\n+     */\n+    typedef std::multimap<COutPoint, uint256> TxSpends;\n+    TxSpends mapTxSpends;\n+    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n+    void AddToSpends(const uint256& wtxid);\n+\n+    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n+\n+public:\n+    /*\n+     * Main wallet lock.\n+     * This lock protects all the fields added by CWallet\n+     *   except for:\n+     *      fFileBacked (immutable after instantiation)\n+     *      strWalletFile (immutable after instantiation)\n+     */\n+    mutable CCriticalSection cs_wallet;\n+\n+    bool fFileBacked;\n+    std::string strWalletFile;\n+\n+    std::set<int64_t> setKeyPool;\n+    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n+\n+    typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n+    MasterKeyMap mapMasterKeys;\n+    unsigned int nMasterKeyMaxID;\n+\n+    CWallet()\n+    {\n+        SetNull();\n+    }\n+\n+    CWallet(std::string strWalletFileIn)\n+    {\n+        SetNull();\n+\n+        strWalletFile = strWalletFileIn;\n+        fFileBacked = true;\n+    }\n+\n+    ~CWallet()\n+    {\n+        delete pwalletdbEncryption;\n+        pwalletdbEncryption = NULL;\n+    }\n+\n+    void SetNull()\n+    {\n+        nWalletVersion = FEATURE_BASE;\n+        nWalletMaxVersion = FEATURE_BASE;\n+        fFileBacked = false;\n+        nMasterKeyMaxID = 0;\n+        pwalletdbEncryption = NULL;\n+        nOrderPosNext = 0;\n+        nNextResend = 0;\n+        nLastResend = 0;\n+        nTimeFirstKey = 0;\n+    }\n+\n+    std::map<uint256, CWalletTx> mapWallet;\n+\n+    int64_t nOrderPosNext;\n+    std::map<uint256, int> mapRequestCount;\n+\n+    std::map<CTxDestination, CAddressBookData> mapAddressBook;\n+\n+    CPubKey vchDefaultKey;\n+\n+    std::set<COutPoint> setLockedCoins;\n+\n+    int64_t nTimeFirstKey;\n+\n+    const CWalletTx* GetWalletTx(const uint256& hash) const;\n+\n+    //! check whether we are allowed to upgrade (or already support) to the named feature\n+    bool CanSupportFeature(enum WalletFeature wf) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n+\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL) const;\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const;\n+\n+    bool IsSpent(const uint256& hash, unsigned int n) const;\n+\n+    bool IsLockedCoin(uint256 hash, unsigned int n) const;\n     void LockCoin(COutPoint& output);\n     void UnlockCoin(COutPoint& output);\n     void UnlockAllCoins();\n@@ -322,471 +645,146 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         if (!MoneyRange(txout.nValue))\n             throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n         return ((IsMine(txout) & filter) ? txout.nValue : 0);\n-    }\n-    bool IsChange(const CTxOut& txout) const;\n-    CAmount GetChange(const CTxOut& txout) const\n-    {\n-        if (!MoneyRange(txout.nValue))\n-            throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n-        return (IsChange(txout) ? txout.nValue : 0);\n-    }\n-    bool IsMine(const CTransaction& tx) const\n-    {\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-            if (IsMine(txout))\n-                return true;\n-        return false;\n-    }\n-    /** should probably be renamed to IsRelevantToMe */\n-    bool IsFromMe(const CTransaction& tx) const\n-    {\n-        return (GetDebit(tx, ISMINE_ALL) > 0);\n-    }\n-    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const\n-    {\n-        CAmount nDebit = 0;\n-        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        {\n-            nDebit += GetDebit(txin, filter);\n-            if (!MoneyRange(nDebit))\n-                throw std::runtime_error(\"CWallet::GetDebit(): value out of range\");\n-        }\n-        return nDebit;\n-    }\n-    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const\n-    {\n-        CAmount nCredit = 0;\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-        {\n-            nCredit += GetCredit(txout, filter);\n-            if (!MoneyRange(nCredit))\n-                throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n-        }\n-        return nCredit;\n-    }\n-    CAmount GetChange(const CTransaction& tx) const\n-    {\n-        CAmount nChange = 0;\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-        {\n-            nChange += GetChange(txout);\n-            if (!MoneyRange(nChange))\n-                throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n-        }\n-        return nChange;\n-    }\n-    void SetBestChain(const CBlockLocator& loc);\n-\n-    DBErrors LoadWallet(bool& fFirstRunRet);\n-    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n-\n-    bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n-\n-    bool DelAddressBook(const CTxDestination& address);\n-\n-    void UpdatedTransaction(const uint256 &hashTx);\n-\n-    void Inventory(const uint256 &hash)\n-    {\n-        {\n-            LOCK(cs_wallet);\n-            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n-            if (mi != mapRequestCount.end())\n-                (*mi).second++;\n-        }\n-    }\n-\n-    unsigned int GetKeyPoolSize()\n-    {\n-        AssertLockHeld(cs_wallet); // setKeyPool\n-        return setKeyPool.size();\n-    }\n-\n-    bool SetDefaultKey(const CPubKey &vchPubKey);\n-\n-    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n-    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n-\n-    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n-    bool SetMaxVersion(int nVersion);\n-\n-    //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n-    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n-\n-    //! Get wallet transactions that conflict with given transaction (spend same outputs)\n-    std::set<uint256> GetConflicts(const uint256& txid) const;\n-\n-    /** \n-     * Address book entry changed.\n-     * @note called with lock cs_wallet held.\n-     */\n-    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n-            &address, const std::string &label, bool isMine,\n-            const std::string &purpose,\n-            ChangeType status)> NotifyAddressBookChanged;\n-\n-    /** \n-     * Wallet transaction added, removed or updated.\n-     * @note called with lock cs_wallet held.\n-     */\n-    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n-            ChangeType status)> NotifyTransactionChanged;\n-\n-    /** Show progress e.g. for rescan */\n-    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n-\n-    /** Watch-only address added */\n-    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n-};\n-\n-/** A key allocated from the key pool. */\n-class CReserveKey\n-{\n-protected:\n-    CWallet* pwallet;\n-    int64_t nIndex;\n-    CPubKey vchPubKey;\n-public:\n-    CReserveKey(CWallet* pwalletIn)\n-    {\n-        nIndex = -1;\n-        pwallet = pwalletIn;\n-    }\n-\n-    ~CReserveKey()\n-    {\n-        ReturnKey();\n-    }\n-\n-    void ReturnKey();\n-    bool GetReservedKey(CPubKey &pubkey);\n-    void KeepKey();\n-};\n-\n-\n-typedef std::map<std::string, std::string> mapValue_t;\n-\n-\n-static void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (!mapValue.count(\"n\"))\n-    {\n-        nOrderPos = -1; // TODO: calculate elsewhere\n-        return;\n-    }\n-    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n-}\n-\n-\n-static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (nOrderPos == -1)\n-        return;\n-    mapValue[\"n\"] = i64tostr(nOrderPos);\n-}\n-\n-struct COutputEntry\n-{\n-    CTxDestination destination;\n-    CAmount amount;\n-    int vout;\n-};\n-\n-/** A transaction with a merkle branch linking it to the block chain. */\n-class CMerkleTx : public CTransaction\n-{\n-private:\n-    int GetDepthInMainChainINTERNAL(const CBlockIndex* &pindexRet) const;\n-\n-public:\n-    uint256 hashBlock;\n-    std::vector<uint256> vMerkleBranch;\n-    int nIndex;\n-\n-    // memory only\n-    mutable bool fMerkleVerified;\n-\n-\n-    CMerkleTx()\n-    {\n-        Init();\n-    }\n-\n-    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n-    {\n-        Init();\n-    }\n-\n-    void Init()\n-    {\n-        hashBlock = uint256();\n-        nIndex = -1;\n-        fMerkleVerified = false;\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(*(CTransaction*)this);\n-        nVersion = this->nVersion;\n-        READWRITE(hashBlock);\n-        READWRITE(vMerkleBranch);\n-        READWRITE(nIndex);\n-    }\n-\n-    int SetMerkleBranch(const CBlock& block);\n-\n-\n-    /**\n-     * Return depth of transaction in blockchain:\n-     * -1  : not in blockchain, and not in memory pool (conflicted transaction)\n-     *  0  : in memory pool, waiting to be included in a block\n-     * >=1 : this many blocks deep in the main chain\n-     */\n-    int GetDepthInMainChain(const CBlockIndex* &pindexRet) const;\n-    int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n-    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChainINTERNAL(pindexRet) > 0; }\n-    int GetBlocksToMaturity() const;\n-    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectAbsurdFee=true);\n-};\n-\n-/** \n- * A transaction with a bunch of additional info that only the owner cares about.\n- * It includes any unrecorded transactions needed to link it back to the block chain.\n- */\n-class CWalletTx : public CMerkleTx\n-{\n-private:\n-    const CWallet* pwallet;\n-\n-public:\n-    mapValue_t mapValue;\n-    std::vector<std::pair<std::string, std::string> > vOrderForm;\n-    unsigned int fTimeReceivedIsTxTime;\n-    unsigned int nTimeReceived; //! time received by this node\n-    unsigned int nTimeSmart;\n-    char fFromMe;\n-    std::string strFromAccount;\n-    int64_t nOrderPos; //! position in ordered transaction list\n-\n-    // memory only\n-    mutable bool fDebitCached;\n-    mutable bool fCreditCached;\n-    mutable bool fImmatureCreditCached;\n-    mutable bool fAvailableCreditCached;\n-    mutable bool fWatchDebitCached;\n-    mutable bool fWatchCreditCached;\n-    mutable bool fImmatureWatchCreditCached;\n-    mutable bool fAvailableWatchCreditCached;\n-    mutable bool fChangeCached;\n-    mutable CAmount nDebitCached;\n-    mutable CAmount nCreditCached;\n-    mutable CAmount nImmatureCreditCached;\n-    mutable CAmount nAvailableCreditCached;\n-    mutable CAmount nWatchDebitCached;\n-    mutable CAmount nWatchCreditCached;\n-    mutable CAmount nImmatureWatchCreditCached;\n-    mutable CAmount nAvailableWatchCreditCached;\n-    mutable CAmount nChangeCached;\n-\n-    CWalletTx()\n+    }\n+    bool IsChange(const CTxOut& txout) const;\n+    CAmount GetChange(const CTxOut& txout) const\n     {\n-        Init(NULL);\n+        if (!MoneyRange(txout.nValue))\n+            throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n+        return (IsChange(txout) ? txout.nValue : 0);\n     }\n-\n-    CWalletTx(const CWallet* pwalletIn)\n+    bool IsMine(const CTransaction& tx) const\n     {\n-        Init(pwalletIn);\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+            if (IsMine(txout))\n+                return true;\n+        return false;\n     }\n-\n-    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n+    /** should probably be renamed to IsRelevantToMe */\n+    bool IsFromMe(const CTransaction& tx) const\n     {\n-        Init(pwalletIn);\n+        return (GetDebit(tx, ISMINE_ALL) > 0);\n     }\n-\n-    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n+    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const\n     {\n-        Init(pwalletIn);\n+        CAmount nDebit = 0;\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            nDebit += GetDebit(txin, filter);\n+            if (!MoneyRange(nDebit))\n+                throw std::runtime_error(\"CWallet::GetDebit(): value out of range\");\n+        }\n+        return nDebit;\n     }\n-\n-    void Init(const CWallet* pwalletIn)\n+    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const\n     {\n-        pwallet = pwalletIn;\n-        mapValue.clear();\n-        vOrderForm.clear();\n-        fTimeReceivedIsTxTime = false;\n-        nTimeReceived = 0;\n-        nTimeSmart = 0;\n-        fFromMe = false;\n-        strFromAccount.clear();\n-        fDebitCached = false;\n-        fCreditCached = false;\n-        fImmatureCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fWatchDebitCached = false;\n-        fWatchCreditCached = false;\n-        fImmatureWatchCreditCached = false;\n-        fAvailableWatchCreditCached = false;\n-        fChangeCached = false;\n-        nDebitCached = 0;\n-        nCreditCached = 0;\n-        nImmatureCreditCached = 0;\n-        nAvailableCreditCached = 0;\n-        nWatchDebitCached = 0;\n-        nWatchCreditCached = 0;\n-        nAvailableWatchCreditCached = 0;\n-        nImmatureWatchCreditCached = 0;\n-        nChangeCached = 0;\n-        nOrderPos = -1;\n+        CAmount nCredit = 0;\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        {\n+            nCredit += GetCredit(txout, filter);\n+            if (!MoneyRange(nCredit))\n+                throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n+        }\n+        return nCredit;\n     }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (ser_action.ForRead())\n-            Init(NULL);\n-        char fSpent = false;\n-\n-        if (!ser_action.ForRead())\n+    CAmount GetChange(const CTransaction& tx) const\n+    {\n+        CAmount nChange = 0;\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n         {\n-            mapValue[\"fromaccount\"] = strFromAccount;\n-\n-            WriteOrderPos(nOrderPos, mapValue);\n-\n-            if (nTimeSmart)\n-                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+            nChange += GetChange(txout);\n+            if (!MoneyRange(nChange))\n+                throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n         }\n+        return nChange;\n+    }\n+    void SetBestChain(const CBlockLocator& loc);\n \n-        READWRITE(*(CMerkleTx*)this);\n-        std::vector<CMerkleTx> vUnused; //! Used to be vtxPrev\n-        READWRITE(vUnused);\n-        READWRITE(mapValue);\n-        READWRITE(vOrderForm);\n-        READWRITE(fTimeReceivedIsTxTime);\n-        READWRITE(nTimeReceived);\n-        READWRITE(fFromMe);\n-        READWRITE(fSpent);\n-\n-        if (ser_action.ForRead())\n-        {\n-            strFromAccount = mapValue[\"fromaccount\"];\n+    DBErrors LoadWallet(bool& fFirstRunRet);\n+    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n \n-            ReadOrderPos(nOrderPos, mapValue);\n+    bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n \n-            nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n-        }\n+    bool DelAddressBook(const CTxDestination& address);\n \n-        mapValue.erase(\"fromaccount\");\n-        mapValue.erase(\"version\");\n-        mapValue.erase(\"spent\");\n-        mapValue.erase(\"n\");\n-        mapValue.erase(\"timesmart\");\n-    }\n+    void UpdatedTransaction(const uint256 &hashTx);\n \n-    //! make sure balances are recalculated\n-    void MarkDirty()\n+    void Inventory(const uint256 &hash)\n     {\n-        fCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fWatchDebitCached = false;\n-        fWatchCreditCached = false;\n-        fAvailableWatchCreditCached = false;\n-        fImmatureWatchCreditCached = false;\n-        fDebitCached = false;\n-        fChangeCached = false;\n+        {\n+            LOCK(cs_wallet);\n+            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n+            if (mi != mapRequestCount.end())\n+                (*mi).second++;\n+        }\n     }\n \n-    void BindWallet(CWallet *pwalletIn)\n+    unsigned int GetKeyPoolSize()\n     {\n-        pwallet = pwalletIn;\n-        MarkDirty();\n+        AssertLockHeld(cs_wallet); // setKeyPool\n+        return setKeyPool.size();\n     }\n \n-    //! filter decides which addresses will count towards the debit\n-    CAmount GetDebit(const isminefilter& filter) const;\n-    CAmount GetCredit(const isminefilter& filter) const;\n-    CAmount GetImmatureCredit(bool fUseCache=true) const;\n-    CAmount GetAvailableCredit(bool fUseCache=true) const;\n-    CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const;\n-    CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const;\n-    CAmount GetChange() const;\n+    bool SetDefaultKey(const CPubKey &vchPubKey);\n \n-    void GetAmounts(std::list<COutputEntry>& listReceived,\n-                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n+    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n+    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n \n-    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n-                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n+    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n+    bool SetMaxVersion(int nVersion);\n \n-    bool IsFromMe(const isminefilter& filter) const\n-    {\n-        return (GetDebit(filter) > 0);\n-    }\n+    //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n+    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n \n-    bool IsTrusted() const;\n+    //! Get wallet transactions that conflict with given transaction (spend same outputs)\n+    std::set<uint256> GetConflicts(const uint256& txid) const;\n \n-    bool WriteToDisk(CWalletDB *pwalletdb);\n+    /** \n+     * Address book entry changed.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n+            &address, const std::string &label, bool isMine,\n+            const std::string &purpose,\n+            ChangeType status)> NotifyAddressBookChanged;\n \n-    int64_t GetTxTime() const;\n-    int GetRequestCount() const;\n+    /** \n+     * Wallet transaction added, removed or updated.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n+            ChangeType status)> NotifyTransactionChanged;\n \n-    void RelayWalletTransaction();\n+    /** Show progress e.g. for rescan */\n+    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n \n-    std::set<uint256> GetConflicts() const;\n+    /** Watch-only address added */\n+    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n };\n \n-\n-\n-\n-class COutput\n+/** A key allocated from the key pool. */\n+class CReserveKey\n {\n+protected:\n+    CWallet* pwallet;\n+    int64_t nIndex;\n+    CPubKey vchPubKey;\n public:\n-    const CWalletTx *tx;\n-    int i;\n-    int nDepth;\n-    bool fSpendable;\n-\n-    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn)\n+    CReserveKey(CWallet* pwalletIn)\n     {\n-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn;\n+        nIndex = -1;\n+        pwallet = pwalletIn;\n     }\n \n-    std::string ToString() const;\n-};\n-\n-\n-\n-\n-/** Private key that includes an expiration date in case it never gets used. */\n-class CWalletKey\n-{\n-public:\n-    CPrivKey vchPrivKey;\n-    int64_t nTimeCreated;\n-    int64_t nTimeExpires;\n-    std::string strComment;\n-    //! todo: add something to note what created it (user, getnewaddress, change)\n-    //!   maybe should have a map<string, string> property map\n-\n-    CWalletKey(int64_t nExpires=0);\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(vchPrivKey);\n-        READWRITE(nTimeCreated);\n-        READWRITE(nTimeExpires);\n-        READWRITE(LIMITED_STRING(strComment, 65536));\n+    ~CReserveKey()\n+    {\n+        ReturnKey();\n     }\n-};\n-\n-\n-\n \n+    void ReturnKey();\n+    bool GetReservedKey(CPubKey &pubkey);\n+    void KeepKey();\n+};\n \n \n /** "
      }
    ]
  },
  {
    "sha": "5a6155ccfa7ee8bb2187054c67f750101986588f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YTYxNTVjY2ZhN2VlOGJiMjE4NzA1NGM2N2Y3NTAxMDE5ODY1ODhm",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-12-19T01:17:28Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-02-04T04:30:59Z"
      },
      "message": "c++11: don't forward-declare types used in maps",
      "tree": {
        "sha": "7637a86b5c8e77caf3af820ac20bce10539af56b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7637a86b5c8e77caf3af820ac20bce10539af56b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a6155ccfa7ee8bb2187054c67f750101986588f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6155ccfa7ee8bb2187054c67f750101986588f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5a6155ccfa7ee8bb2187054c67f750101986588f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6155ccfa7ee8bb2187054c67f750101986588f/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3447cf87e27262c57031361b3659fef938783295",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3447cf87e27262c57031361b3659fef938783295",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3447cf87e27262c57031361b3659fef938783295"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 2,
      "deletions": 5
    },
    "files": [
      {
        "sha": "7531737e04d53d3e84300336fd640cb31e5ac507",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a6155ccfa7ee8bb2187054c67f750101986588f/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a6155ccfa7ee8bb2187054c67f750101986588f/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=5a6155ccfa7ee8bb2187054c67f750101986588f",
        "patch": "@@ -7,8 +7,6 @@\n \n #include \"crypter.h\"\n #include \"key.h\"\n-#include \"script/script.h\"\n-#include \"script/standard.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>"
      },
      {
        "sha": "4a4b6d20afe7270ec1a6397925905e185513d674",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a6155ccfa7ee8bb2187054c67f750101986588f/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a6155ccfa7ee8bb2187054c67f750101986588f/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=5a6155ccfa7ee8bb2187054c67f750101986588f",
        "patch": "@@ -8,14 +8,13 @@\n \n #include \"key.h\"\n #include \"pubkey.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n #include \"sync.h\"\n \n #include <boost/signals2/signal.hpp>\n #include <boost/variant.hpp>\n \n-class CScript;\n-class CScriptID;\n-\n /** A virtual base class for key stores */\n class CKeyStore\n {"
      }
    ]
  },
  {
    "sha": "7f991e364eb50bd14970de9d96981a7ca268d4aa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3Zjk5MWUzNjRlYjUwYmQxNDk3MGRlOWQ5Njk4MWE3Y2EyNjhkNGFh",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-12-19T01:43:48Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-02-04T04:31:00Z"
      },
      "message": "c++11: These look like user-defined literals.\n\nAdd a space to keep the compiler happy",
      "tree": {
        "sha": "a0cd24690077c0b241b711d1c555f33389f5fe88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0cd24690077c0b241b711d1c555f33389f5fe88"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f991e364eb50bd14970de9d96981a7ca268d4aa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f991e364eb50bd14970de9d96981a7ca268d4aa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f991e364eb50bd14970de9d96981a7ca268d4aa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f991e364eb50bd14970de9d96981a7ca268d4aa/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5a6155ccfa7ee8bb2187054c67f750101986588f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a6155ccfa7ee8bb2187054c67f750101986588f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5a6155ccfa7ee8bb2187054c67f750101986588f"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 9,
      "deletions": 9
    },
    "files": [
      {
        "sha": "d829ec228db6dda417904bc4347b725d009303f0",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f991e364eb50bd14970de9d96981a7ca268d4aa/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f991e364eb50bd14970de9d96981a7ca268d4aa/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=7f991e364eb50bd14970de9d96981a7ca268d4aa",
        "patch": "@@ -282,21 +282,21 @@ BOOST_AUTO_TEST_CASE(strprintf_numbers)\n {\n     int64_t s64t = -9223372036854775807LL; /* signed 64 bit test value */\n     uint64_t u64t = 18446744073709551615ULL; /* unsigned 64 bit test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, s64t, E) == B\" -9223372036854775807 \"E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, u64t, E) == B\" 18446744073709551615 \"E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, u64t, E) == B\" ffffffffffffffff \"E);\n+    BOOST_CHECK(strprintf(\"%s %d %s\", B, s64t, E) == B\" -9223372036854775807 \" E);\n+    BOOST_CHECK(strprintf(\"%s %u %s\", B, u64t, E) == B\" 18446744073709551615 \" E);\n+    BOOST_CHECK(strprintf(\"%s %x %s\", B, u64t, E) == B\" ffffffffffffffff \" E);\n \n     size_t st = 12345678; /* unsigned size_t test value */\n     ssize_t sst = -12345678; /* signed size_t test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, sst, E) == B\" -12345678 \"E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, st, E) == B\" 12345678 \"E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, st, E) == B\" bc614e \"E);\n+    BOOST_CHECK(strprintf(\"%s %d %s\", B, sst, E) == B\" -12345678 \" E);\n+    BOOST_CHECK(strprintf(\"%s %u %s\", B, st, E) == B\" 12345678 \" E);\n+    BOOST_CHECK(strprintf(\"%s %x %s\", B, st, E) == B\" bc614e \" E);\n \n     ptrdiff_t pt = 87654321; /* positive ptrdiff_t test value */\n     ptrdiff_t spt = -87654321; /* negative ptrdiff_t test value */\n-    BOOST_CHECK(strprintf(\"%s %d %s\", B, spt, E) == B\" -87654321 \"E);\n-    BOOST_CHECK(strprintf(\"%s %u %s\", B, pt, E) == B\" 87654321 \"E);\n-    BOOST_CHECK(strprintf(\"%s %x %s\", B, pt, E) == B\" 5397fb1 \"E);\n+    BOOST_CHECK(strprintf(\"%s %d %s\", B, spt, E) == B\" -87654321 \" E);\n+    BOOST_CHECK(strprintf(\"%s %u %s\", B, pt, E) == B\" 87654321 \" E);\n+    BOOST_CHECK(strprintf(\"%s %x %s\", B, pt, E) == B\" 5397fb1 \" E);\n }\n #undef B\n #undef E"
      }
    ]
  }
]