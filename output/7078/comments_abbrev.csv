jgarzik,2015-11-23T02:54:52Z,"eh, use WriteLE64()?\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-158838927,158838927,
dcousens,2015-11-24T00:52:10Z,"~~LGTM, utACK~~\n\n**edit:** See @laanwj's comment\n\n**edit2:** Conflicted, utACK on the code\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159116495,159116495,
laanwj,2015-11-24T07:58:52Z,"This is on purpose! The ""hash"" is meant to be as fast as possible by using endian-dependent operations. E.g. within one program run it is stable and that is all that matters - it is not supposed to be used with anything that leaves the program.\nThis is mentioned, literally, in the comment:\nhttps://github.com/bitcoin/bitcoin/blob/master/src/uint256.h#L118\n\nEdit: as for the test failure, have yo",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159188879,159188879,
arowser,2015-11-25T07:32:47Z,"The failed test case is addrman_new_collisions and addrman_tried_collisions: https://github.com/bitcoin/bitcoin/blob/master/src/test/addrman_tests.cpp#L141\n\nThe testcase make a hash collision, The value of ""hash1 % ADDRMAN_BUCKET_SIZE"" https://github.com/bitcoin/bitcoin/blob/master/src/addrman.cpp#L29 is always 28 when addr1 is 250.1.1.1 or addr1 is 250.1.1.4 when little endian, but its differen",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159525120,159525120,
laanwj,2015-11-25T07:38:14Z,"Bleh, so the test relies very strongly on the exact outcome of the hash function (as the algorithm is ""randomized"" by that), even though both results are correct inthemselves?\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159525772,159525772,
luke-jr,2015-11-25T07:41:30Z,"These addrman ""tests"" look pretty crappy in general... lots of checking internal implementation details rather than expected external behaviour. :/\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159526141,159526141,
arowser,2015-11-25T08:02:29Z,"The addrman_new_collisions first call addrman.MakeDeterministic(), it set addrman.nKey is NULL, then the addrman addr placement in new table will be deterministic, it seems try to simulate hash collisions when addrman.add() .\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159528959,159528959,
laanwj,2015-11-25T08:05:35Z,"The primary reason I'm protesting here is because GetCheapHash is used in `CSignatureCacheHasher`, which is a performance critical path, and also the only use beside `addrman`.\n\nIt is possible that adding a (conditional) byte swap has hardly impact on performance, but that would have to be benchmarked.\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159529381,159529381,
sipa,2015-11-26T20:53:39Z,"I doubt the performance penalty of ReadLE64 is going to matter really on any system.\n\nI liked the idea of having an unportable fast function, though, but being able to rely on behaviour does make testing easier too.\n\nUnsure.\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-159993015,159993015,
laanwj,2015-11-27T09:48:30Z,"> I liked the idea of having an unportable fast function, though, but being able to rely on behaviour does make testing easier too.\n\nRight - in the case of addrman, the overhead is nothing compared to the double-SHA256, in all its uses:\n\n```\nsrc/addrman.cpp:    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetHash().GetCheapHash();\nsrc/addrman.cpp:    uint64_t hash2 = (C",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-160098262,160098262,
sipa,2015-11-27T14:17:31Z,@laanwj Even the signature cache now uses a SHA256 (though that should at some point be replaced with a fast non-cryptographic but highly collision-resistant hash function). A single byteswap (and only on BE platforms...) is not going to be measurable.\n,https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-160148680,160148680,
laanwj,2015-11-27T14:24:47Z,"OK, just going ahead and merging this then\n",https://github.com/bitcoin/bitcoin/pull/7078#issuecomment-160149899,160149899,
laanwj,2015-11-25T08:06:30Z,"Nit: what you want here is ReadLE64, not WriteLE64:\n\n```\nreturn ReadLE64(data);\n```\n",https://github.com/bitcoin/bitcoin/pull/7078#discussion_r45837873,45837873,src/uint256.h
