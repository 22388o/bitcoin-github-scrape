[
  {
    "sha": "c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMDIwY2JhYTVjOGU5ZTYxYjJiOGVmZDhkYzA5YmU3NDNmY2Q0Mjcz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-14T17:02:02Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-14T17:02:02Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from efad3506a8..be8d9c262f\n\nbe8d9c262f Merge bitcoin-core/secp256k1#965: gen_context: Don't use any ASM\naeece44599 gen_context: Don't use any ASM\n7688a4f13a Merge bitcoin-core/secp256k1#963: \"Schnorrsig API overhaul\" fixups\n90e83449b2 ci: Add C++ test\nf698caaff6 Use unsigned char consistently for byte arrays\nb5b8e7b719 Don't declare constants twice\n769528f307 Don't use string literals for char arrays without NUL termination\n2cc3cfa583 Fix -Wmissing-braces warning in clang\n0440945fb5 Merge #844: schnorrsig API overhaul\nec3aaa5014 Merge #960: tests_exhaustive: check the result of secp256k1_ecdsa_sign\na1ee83c654 tests_exhaustive: check the result of secp256k1_ecdsa_sign\n253f90cdeb Merge bitcoin-core/secp256k1#951: configure: replace AC_PATH_PROG to AC_CHECK_PROG\n446d28d9de Merge bitcoin-core/secp256k1#944: Various improvements related to CFLAGS\n0302138f75 ci: Make compiler warning into errors on CI\nb924e1e605 build: Ensure that configure's compile checks default to -O2\n7939cd571c build: List *CPPFLAGS before *CFLAGS like on the compiler command line\n595e8a35d8 build: Enable -Wcast-align=strict warning\n07256267ff build: Use own variable SECP_CFLAGS instead of touching user CFLAGS\n4866178dfc Merge bitcoin-core/secp256k1#955: Add random field multiply/square tests\n75ce488c2a Merge bitcoin-core/secp256k1#959: tests: really test the non-var scalar inverse\n41ed13942b tests: really test the non-var scalar inverse\n5f6ceafcfa schnorrsig: allow setting MSGLEN != 32 in benchmark\nfdd06b7967 schnorrsig: add tests for sign_custom and varlen msg verification\nd8d806aaf3 schnorrsig: add extra parameter struct for sign_custom\na0c3fc177f schnorrsig: allow signing and verification of variable length msgs\n5a8e4991ad Add secp256k1_tagged_sha256 as defined in BIP-340\nb6c0b72fb0 schnorrsig: remove noncefp args from sign; add sign_custom function\nbdf19f105c Add random field multiply/square tests\n8ae56e33e7 Merge #879: Avoid passing out-of-bound pointers to 0-size memcpy\na4642fa15e configure: replace AC_PATH_PROG to AC_CHECK_PROG\n1758a92ffd Merge #950: ci: Add ppc64le build\nc58c4ea470 ci: Add ppc64le build\n7973576f6e Merge #662: Add ecmult_gen, ecmult_const and ecmult to benchmark\n8f879c2887 Fix array size in bench_ecmult\n2fe1b50df1 Add ecmult_gen, ecmult_const and ecmult to benchmark\n593e6bad9c Clean up ecmult_bench to make space for more benchmarks\n50f3367712 Merge #947: ci: Run PRs on merge result even for i686\na35fdd3478 ci: Run PRs on merge result even for i686\n442cee5baf schnorrsig: add algolen argument to nonce_function_hardened\ndf3bfa12c3 schnorrsig: clarify result of calling nonce_function_bip340 without data\n99e8614812 README: mention schnorrsig module\n3dc8c072b6 Merge #846: ci: Run ASan/LSan and reorganize sanitizer and Valgrind jobs\n02dcea1ad9 ci: Make test iterations configurable and tweak for sanitizer builds\n489ff5c20a tests: Treat empty SECP2561_TEST_ITERS as if it was unset\nfcfcb97e74 ci: Simplify to use generic wrapper for QEMU, Valgrind, etc\nde4157f13a ci: Run ASan/LSan and reorganize sanitizer and Valgrind jobs\n399722a63a Merge #941: Clean up git tree\n09b3bb8648 Clean up git tree\nbf0ac46066 Merge #930: Add ARM32/ARM64 CI\n202a030f7d Merge #850: add `secp256k1_ec_pubkey_cmp` method\n1e78c18d5b Merge bitcoin-core/secp256k1#940: contrib: Explain explicit header guards\n69394879b6 Merge #926: secp256k1.h: clarify that by default arguments must be != NULL\n6eceec6d56 add `secp256k1_xonly_pubkey_cmp` method\n0d9561ae87 add `secp256k1_ec_pubkey_cmp` method\n22a9ea154a contrib: Explain explicit header guards\n6c52ae8724 Merge #937: Have ge_set_gej_var, gej_double_var and ge_set_all_gej_var initialize all fields of their outputs.\n185a6af227 Merge #925: changed include statements without prefix 'include/'\n14c9739a1f tests: Improve secp256k1_ge_set_all_gej_var for some infinity inputs\n4a19668c37 tests: Test secp256k1_ge_set_all_gej_var for all infinity inputs\n3c90bdda95 change local lib headers to be relative for those pointing at \"include/\" dir\n45b6468d7e Have secp256k1_ge_set_all_gej_var initialize all fields. Previous behaviour would not initialize r->y values in the case where infinity is passed in. Furthermore, the previous behaviour wouldn't initialize anything in the case where all inputs were infinity.\n31c0f6de41 Have secp256k1_gej_double_var initialize all fields. Previous behaviour would not initialize r->x and r->y values in the case where infinity is passed in.\ndd6c3de322 Have secp256k1_ge_set_gej_var initialize all fields. Previous behaviour would not initialize r->x and r->y values in the case where infinity is passed in.\nd0bd2693e3 Merge bitcoin-core/secp256k1#936: Fix gen_context/ASM build on ARM\n8bbad7a18e Add asm build to ARM32 CI\n7d65ed5214 Add ARM32/ARM64 CI\nc8483520c9 Makefile.am: Don't pass a variable twice\n2161f31785 Makefile.am: Honor config when building gen_context\n99f47c20ec gen_context: Don't use external ASM because it complicates the build\n98e0358d29 Merge #933: Avoids a missing brace warning in schnorrsig/tests_impl.h on old compilers\n99e2d5be0d Avoids a missing brace warning in schnorrsig/tests_impl.h on old compilers.\n34388af6b6 Merge #922: Add mingw32-w64/wine CI build\n7012a188e6 Merge #928: Define SECP256K1_BUILD in secp256k1.c directly.\ned5a199bed tests: fopen /dev/urandom in binary mode\nae9e648526 Define SECP256K1_BUILD in secp256k1.c directly.\n4dc37bf81b Add mingw32-w64/wine CI build\n0881633dfd secp256k1.h: clarify that by default arguments must be != NULL\n9570f674cc Avoid passing out-of-bound pointers to 0-size memcpy\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: be8d9c262f46309d9b4165b0498b71d704aba8fe",
      "tree": {
        "sha": "b7f4357396a8a5f073bf628567ef10b2e2edd410",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7f4357396a8a5f073bf628567ef10b2e2edd410"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bdca9bcb6c9379707d09c63f02326884befbefb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdca9bcb6c9379707d09c63f02326884befbefb2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdca9bcb6c9379707d09c63f02326884befbefb2"
      }
    ],
    "stats": {
      "total": 1587,
      "additions": 1222,
      "deletions": 365
    },
    "files": [
      {
        "sha": "bf71a70839f59a3b3c67dbba0979843efb6bc6d9",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 173,
        "deletions": 29,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -1,21 +1,28 @@\n env:\n-  WIDEMUL: auto\n+  ### compiler options\n+  HOST:\n+  # Specific warnings can be disabled with -Wno-error=foo.\n+  # -pedantic-errors is not equivalent to -Werror=pedantic and thus not implied by -Werror according to the GCC manual.\n+  WERROR_CFLAGS: -Werror -pedantic-errors\n+  MAKEFLAGS: -j2\n+  BUILD: check\n+  ### secp256k1 config\n   STATICPRECOMPUTATION: yes\n   ECMULTGENPRECISION: auto\n   ASM: no\n-  BUILD: check\n+  WIDEMUL: auto\n   WITH_VALGRIND: yes\n-  RUN_VALGRIND: no\n   EXTRAFLAGS:\n-  HOST:\n+  ### secp256k1 modules\n+  EXPERIMENTAL: no\n   ECDH: no\n   RECOVERY: no\n   SCHNORRSIG: no\n-  EXPERIMENTAL: no\n-  CTIMETEST: yes\n+  ### test options\n+  TEST_ITERS:\n   BENCH: yes\n-  ITERS: 2\n-  MAKEFLAGS: -j2\n+  BENCH_ITERS: 2\n+  CTIMETEST: yes\n \n cat_logs_snippet: &CAT_LOGS\n   always:\n@@ -63,27 +70,8 @@ task:\n     - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n     - env: {CPPFLAGS: -DDETERMINISTIC}\n     - env: {CFLAGS: -O0, CTIMETEST: no}\n-    - env:\n-        CFLAGS:  \"-fsanitize=undefined -fno-omit-frame-pointer\"\n-        LDFLAGS: \"-fsanitize=undefined -fno-omit-frame-pointer\"\n-        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n-        ASM: x86_64\n-        ECDH: yes\n-        RECOVERY: yes\n-        EXPERIMENTAL: yes\n-        SCHNORRSIG: yes\n-        CTIMETEST: no\n     - env: { ECMULTGENPRECISION: 2 }\n     - env: { ECMULTGENPRECISION: 8 }\n-    - env:\n-        RUN_VALGRIND: yes\n-        ASM: x86_64\n-        ECDH: yes\n-        RECOVERY: yes\n-        EXPERIMENTAL: yes\n-        SCHNORRSIG: yes\n-        EXTRAFLAGS: \"--disable-openssl-tests\"\n-        BUILD:\n   matrix:\n     - env:\n         CC: gcc\n@@ -111,6 +99,7 @@ task:\n         CC: i686-linux-gnu-gcc\n     - env:\n         CC: clang --target=i686-pc-linux-gnu -isystem /usr/i686-linux-gnu/include\n+  << : *MERGE_BASE\n   test_script:\n     - ./ci/cirrus.sh\n   << : *CAT_LOGS\n@@ -181,9 +170,9 @@ task:\n     cpu: 1\n     memory: 1G\n   env:\n-    QEMU_CMD: qemu-s390x\n+    WRAPPER_CMD: qemu-s390x\n+    TEST_ITERS: 16\n     HOST: s390x-linux-gnu\n-    BUILD:\n     WITH_VALGRIND: no\n     ECDH: yes\n     RECOVERY: yes\n@@ -196,3 +185,158 @@ task:\n     - rm /etc/ld.so.cache\n     - ./ci/cirrus.sh\n   << : *CAT_LOGS\n+\n+task:\n+  name: \"ARM32: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-arm\n+    TEST_ITERS: 16\n+    HOST: arm-linux-gnueabihf\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  matrix:\n+    - env: {}\n+    - env: {ASM: arm}\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"ARM64: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-aarch64\n+    TEST_ITERS: 16\n+    HOST: aarch64-linux-gnu\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"ppc64le: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-ppc64le\n+    TEST_ITERS: 16\n+    HOST: powerpc64le-linux-gnu\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"x86_64 (mingw32-w64): Windows (Debian stable, Wine)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: wine64-stable\n+    TEST_ITERS: 16\n+    HOST: x86_64-w64-mingw32\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+# Sanitizers\n+task:\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+    EXTRAFLAGS: \"--disable-openssl-tests\"\n+  matrix:\n+    - name: \"Valgrind (memcheck)\"\n+      env:\n+        # The `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n+        WRAPPER_CMD: \"valgrind --error-exitcode=42\"\n+        TEST_ITERS: 16\n+    - name: \"UBSan, ASan, LSan\"\n+      env:\n+        CFLAGS: \"-fsanitize=undefined,address\"\n+        CFLAGS_FOR_BUILD: \"-fsanitize=undefined,address\"\n+        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n+        ASAN_OPTIONS: \"strict_string_checks=1:detect_stack_use_after_return=1:detect_leaks=1\"\n+        LSAN_OPTIONS: \"use_unaligned=1\"\n+        TEST_ITERS: 32\n+  # Try to cover many configurations with just a tiny matrix.\n+  matrix:\n+    - env:\n+        ASM: auto\n+        STATICPRECOMPUTATION: yes\n+    - env:\n+        ASM: no\n+        STATICPRECOMPUTATION: no\n+        ECMULTGENPRECISION: 2\n+  matrix:\n+    - env:\n+        CC: clang\n+    - env:\n+        HOST: i686-linux-gnu\n+        CC: i686-linux-gnu-gcc\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"C++ -fpermissive\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    # ./configure correctly errors out when given CC=g++.\n+    # We hack around this by passing CC=g++ only to make.\n+    CC: gcc\n+    MAKEFLAGS: -j2 CC=g++ CFLAGS=-fpermissive\n+    WERROR_CFLAGS:\n+    EXPERIMENTAL: yes\n+    ECDH: yes\n+    RECOVERY: yes\n+    SCHNORRSIG: yes\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS"
      },
      {
        "sha": "79b740db8ae3552dade638d75f0f343f8bc15a8c",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -23,6 +23,7 @@ aclocal.m4\n autom4te.cache/\n config.log\n config.status\n+conftest*\n *.tar.gz\n *.la\n libtool\n@@ -33,6 +34,14 @@ libtool\n *~\n *.log\n *.trs\n+\n+coverage/\n+coverage.html\n+coverage.*.html\n+*.gcda\n+*.gcno\n+*.gcov\n+\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h"
      },
      {
        "sha": "1e0356088433883d85a9884209e5c2d07fe01d5a",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -1,5 +1,9 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n+# AM_CFLAGS will be automatically prepended to CFLAGS by Automake when compiling some foo\n+# which does not have an explicit foo_CFLAGS variable set.\n+AM_CFLAGS = $(SECP_CFLAGS)\n+\n lib_LTLIBRARIES = libsecp256k1.la\n include_HEADERS = include/secp256k1.h\n include_HEADERS += include/secp256k1_preallocated.h\n@@ -68,7 +72,7 @@ endif\n endif\n \n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n libsecp256k1_la_LIBADD = $(SECP_LIBS) $(COMMON_LIB)\n \n if VALGRIND_ENABLED\n@@ -81,27 +85,27 @@ noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n # SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n-bench_verify_CPPFLAGS = -DSECP256K1_BUILD $(SECP_TEST_INCLUDES)\n+bench_verify_CPPFLAGS = $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n-bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n bench_ecmult_SOURCES = src/bench_ecmult.c\n bench_ecmult_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n-bench_ecmult_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_ecmult_CPPFLAGS = $(SECP_INCLUDES)\n endif\n \n TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n@@ -114,7 +118,7 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -I$(top_srcdir)/src $(SECP_INCLUDES)\n if !ENABLE_COVERAGE\n exhaustive_tests_CPPFLAGS += -DVERIFY\n endif\n@@ -129,10 +133,10 @@ CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n-\t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n+\t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n-\t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n+\t$(CC_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n \n $(libsecp256k1_la_OBJECTS): src/ecmult_static_context.h\n $(tests_OBJECTS): src/ecmult_static_context.h"
      },
      {
        "sha": "182c29d9ce5ef58e9c753b1d54b3c0b0a2b6bd6a",
        "filename": "README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -17,6 +17,7 @@ Features:\n * Suitable for embedded systems.\n * Optional module for public key recovery.\n * Optional module for ECDH key exchange.\n+* Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) (experimental).\n \n Experimental features have not received enough scrutiny to satisfy the standard of quality of this library but are made available for testing and review by the community. The APIs of these features should not be considered stable.\n \n@@ -96,7 +97,8 @@ To create a report, `gcovr` is recommended, as it includes branch coverage repor\n \n To create a HTML report with coloured and annotated source code:\n \n-    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage.html\n+    $ mkdir -p coverage\n+    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage/coverage.html\n \n Reporting a vulnerability\n ------------"
      },
      {
        "sha": "8245b2b8635200093b17ba856025f8b6e862cdda",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -82,3 +82,19 @@ if test x\"$has_valgrind\" != x\"yes\"; then\n   AC_CHECK_HEADER([valgrind/memcheck.h], [has_valgrind=yes; AC_DEFINE(HAVE_VALGRIND,1,[Define this symbol if valgrind is installed])])\n fi\n ])\n+\n+dnl SECP_TRY_APPEND_CFLAGS(flags, VAR)\n+dnl Append flags to VAR if CC accepts them.\n+AC_DEFUN([SECP_TRY_APPEND_CFLAGS], [\n+  AC_MSG_CHECKING([if ${CC} supports $1])\n+  SECP_TRY_APPEND_CFLAGS_saved_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$1 $CFLAGS\"\n+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])], [flag_works=yes], [flag_works=no])\n+  AC_MSG_RESULT($flag_works)\n+  CFLAGS=\"$SECP_TRY_APPEND_CFLAGS_saved_CFLAGS\"\n+  if test x\"$flag_works\" = x\"yes\"; then\n+    $2=\"$$2 $1\"\n+  fi\n+  unset flag_works\n+  AC_SUBST($2)\n+])"
      },
      {
        "sha": "27db1e6779fa621150ccd0c1c64c93f2a39f6317",
        "filename": "ci/cirrus.sh",
        "status": "modified",
        "additions": 9,
        "deletions": 24,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/cirrus.sh?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -25,42 +25,27 @@ valgrind --version || true\n make\n \n # Print information about binaries so that we can see that the architecture is correct\n-file *tests || true\n+file *tests* || true\n file bench_* || true\n file .libs/* || true\n \n-if [ -n \"$BUILD\" ]\n-then\n-    make \"$BUILD\"\n-fi\n+# This tells `make check` to wrap test invocations.\n+export LOG_COMPILER=\"$WRAPPER_CMD\"\n \n-if [ \"$RUN_VALGRIND\" = \"yes\" ]\n-then\n-    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n-    valgrind --error-exitcode=42 ./tests 16\n-    valgrind --error-exitcode=42 ./exhaustive_tests\n-fi\n+# This limits the iterations in the tests and benchmarks.\n+export SECP256K1_TEST_ITERS=\"$TEST_ITERS\"\n+export SECP256K1_BENCH_ITERS=\"$BENCH_ITERS\"\n \n-if [ -n \"$QEMU_CMD\" ]\n-then\n-    $QEMU_CMD ./tests 16\n-    $QEMU_CMD ./exhaustive_tests\n-fi\n+make \"$BUILD\"\n \n if [ \"$BENCH\" = \"yes\" ]\n then\n     # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n     EXEC='./libtool --mode=execute'\n-    if [ -n \"$QEMU_CMD\" ]\n-    then\n-       EXEC=\"$EXEC $QEMU_CMD\"\n-    fi\n-    if [ \"$RUN_VALGRIND\" = \"yes\" ]\n+    if [ -n \"$WRAPPER_CMD\" ]\n     then\n-        EXEC=\"$EXEC valgrind --error-exitcode=42\"\n+        EXEC=\"$EXEC $WRAPPER_CMD\"\n     fi\n-    # This limits the iterations in the benchmarks below to ITER iterations.\n-    export SECP256K1_BENCH_ITERS=\"$ITERS\"\n     {\n         $EXEC ./bench_ecmult\n         $EXEC ./bench_internal"
      },
      {
        "sha": "2c02ed69d03f8a9cbf6bfa38f8f1b77cb0bb3d21",
        "filename": "ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/linux-debian.Dockerfile?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -2,12 +2,24 @@ FROM debian:stable\n \n RUN dpkg --add-architecture i386\n RUN dpkg --add-architecture s390x\n+RUN dpkg --add-architecture armhf\n+RUN dpkg --add-architecture arm64\n+RUN dpkg --add-architecture ppc64el\n RUN apt-get update\n \n # dkpg-dev: to make pkg-config work in cross-builds\n+# llvm: for llvm-symbolizer, which is used by clang's UBSan for symbolized stack traces\n RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         git ca-certificates \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n-        gcc clang libc6-dbg \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 \\\n-        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x\n+        gcc clang llvm libc6-dbg \\\n+        g++ \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n+        gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n+        gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\\n+        gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross libc6-dbg:ppc64el \\\n+        wine gcc-mingw-w64-x86-64\n+\n+# Run a dummy command in wine to make it set up configuration\n+RUN wine64-stable xcopy || true"
      },
      {
        "sha": "9969cfa343226f06cdb8899929fb3a96929332ee",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 62,
        "deletions": 58,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -8,10 +8,6 @@ AH_TOP([#define LIBSECP256K1_CONFIG_H])\n AH_BOTTOM([#endif /*LIBSECP256K1_CONFIG_H*/])\n AM_INIT_AUTOMAKE([foreign subdir-objects])\n \n-# Set -g if CFLAGS are not already set, which matches the default autoconf\n-# behavior (see PROG_CC in the Autoconf manual) with the exception that we don't\n-# set -O2 here because we set it in any case (see further down).\n-: ${CFLAGS=\"-g\"}\n LT_INIT\n \n # Make the compilation flags quiet unless V=1 is used.\n@@ -42,8 +38,8 @@ AM_PROG_AS\n case $host_os in\n   *darwin*)\n      if  test x$cross_compiling != xyes; then\n-       AC_PATH_PROG([BREW],brew,)\n-       if test x$BREW != x; then\n+       AC_CHECK_PROG([BREW], brew, brew)\n+       if test x$BREW = xbrew; then\n          # These Homebrew packages may be keg-only, meaning that they won't be found\n          # in expected paths because they may conflict with system files. Ask\n          # Homebrew where each one is located, then adjust paths accordingly.\n@@ -58,10 +54,10 @@ case $host_os in\n            VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n        else\n-         AC_PATH_PROG([PORT],port,)\n+         AC_CHECK_PROG([PORT], port, port)\n          # If homebrew isn't installed and macports is, add the macports default paths\n          # as a last resort.\n-         if test x$PORT != x; then\n+         if test x$PORT = xport; then\n            CPPFLAGS=\"$CPPFLAGS -isystem /opt/local/include\"\n            LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n          fi\n@@ -70,35 +66,41 @@ case $host_os in\n    ;;\n esac\n \n-CFLAGS=\"-W $CFLAGS\"\n-\n-warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n-\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"-Wconditional-uninitialized $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports -Wconditional-uninitialized])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n-\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n+# Try if some desirable compiler flags are supported and append them to SECP_CFLAGS.\n+#\n+# These are our own flags, so we append them to our own SECP_CFLAGS variable (instead of CFLAGS) as\n+# recommended in the automake manual (Section \"Flag Variables Ordering\"). CFLAGS belongs to the user\n+# and we are not supposed to touch it. In the Makefile, we will need to ensure that SECP_CFLAGS\n+# is prepended to CFLAGS when invoking the compiler so that the user always has the last word (flag).\n+#\n+# Another advantage of not touching CFLAGS is that the contents of CFLAGS will be picked up by\n+# libtool for compiling helper executables. For example, when compiling for Windows, libtool will\n+# generate entire wrapper executables (instead of simple wrapper scripts as on Unix) to ensure\n+# proper operation of uninstalled programs linked by libtool against the uninstalled shared library.\n+# These executables are compiled from C source file for which our flags may not be appropriate,\n+# e.g., -std=c89 flag has lead to undesirable warnings in the past.\n+#\n+# TODO We should analogously not touch CPPFLAGS and LDFLAGS but currently there are no issues.\n+AC_DEFUN([SECP_TRY_APPEND_DEFAULT_CFLAGS], [\n+    # Try to append -Werror=unknown-warning-option to CFLAGS temporarily. Otherwise clang will\n+    # not error out if it gets unknown warning flags and the checks here will always succeed\n+    # no matter if clang knows the flag or not.\n+    SECP_TRY_APPEND_DEFAULT_CFLAGS_saved_CFLAGS=\"$CFLAGS\"\n+    SECP_TRY_APPEND_CFLAGS([-Werror=unknown-warning-option], CFLAGS)\n+\n+    SECP_TRY_APPEND_CFLAGS([-std=c89 -pedantic -Wno-long-long -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef], $1) # GCC >= 3.0, -Wlong-long is implied by -pedantic.\n+    SECP_TRY_APPEND_CFLAGS([-Wno-overlength-strings], $1) # GCC >= 4.2, -Woverlength-strings is implied by -pedantic.\n+    SECP_TRY_APPEND_CFLAGS([-Wall], $1) # GCC >= 2.95 and probably many other compilers\n+    SECP_TRY_APPEND_CFLAGS([-Wno-unused-function], $1) # GCC >= 3.0, -Wunused-function is implied by -Wall.\n+    SECP_TRY_APPEND_CFLAGS([-Wextra], $1) # GCC >= 3.4, this is the newer name of -W, which we don't use because older GCCs will warn about unused functions.\n+    SECP_TRY_APPEND_CFLAGS([-Wcast-align], $1) # GCC >= 2.95\n+    SECP_TRY_APPEND_CFLAGS([-Wcast-align=strict], $1) # GCC >= 8.0\n+    SECP_TRY_APPEND_CFLAGS([-Wconditional-uninitialized], $1) # Clang >= 3.0 only\n+    SECP_TRY_APPEND_CFLAGS([-fvisibility=hidden], $1) # GCC >= 4.0\n+\n+    CFLAGS=\"$SECP_TRY_APPEND_DEFAULT_CFLAGS_saved_CFLAGS\"\n+])\n+SECP_TRY_APPEND_DEFAULT_CFLAGS(SECP_CFLAGS)\n \n ###\n ### Define config arguments\n@@ -213,10 +215,14 @@ AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n-    CFLAGS=\"-O0 --coverage $CFLAGS\"\n+    SECP_CFLAGS=\"-O0 --coverage $SECP_CFLAGS\"\n     LDFLAGS=\"--coverage $LDFLAGS\"\n else\n-    CFLAGS=\"-O2 $CFLAGS\"\n+    # Most likely the CFLAGS already contain -O2 because that is autoconf's default.\n+    # We still add it here because passing it twice is not an issue, and handling\n+    # this case would just add unnecessary complexity (see #896).\n+    SECP_CFLAGS=\"-O2 $SECP_CFLAGS\"\n+    SECP_CFLAGS_FOR_BUILD=\"-O2 $SECP_CFLAGS_FOR_BUILD\"\n fi\n \n if test x\"$req_asm\" = x\"auto\"; then\n@@ -351,6 +357,9 @@ if test x\"$enable_valgrind\" = x\"yes\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n fi\n \n+# Add -Werror and similar flags passed from the outside (for testing, e.g., in CI)\n+SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n+\n # Handle static precomputation (after everything which modifies CFLAGS and friends)\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   if test x\"$cross_compiling\" = x\"no\"; then\n@@ -360,8 +369,9 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n     fi\n     # If we're not cross-compiling, simply use the same compiler for building the static precompation code.\n     CC_FOR_BUILD=\"$CC\"\n-    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n     CPPFLAGS_FOR_BUILD=\"$CPPFLAGS\"\n+    SECP_CFLAGS_FOR_BUILD=\"$SECP_CFLAGS\"\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n     LDFLAGS_FOR_BUILD=\"$LDFLAGS\"\n   else\n     AX_PROG_CC_FOR_BUILD\n@@ -371,42 +381,32 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n     cross_compiling=no\n     SAVE_CC=\"$CC\"\n     CC=\"$CC_FOR_BUILD\"\n-    SAVE_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n     SAVE_CPPFLAGS=\"$CPPFLAGS\"\n     CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+    SAVE_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n     SAVE_LDFLAGS=\"$LDFLAGS\"\n     LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n \n-    warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n-    saved_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n-    AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n-    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-        [ AC_MSG_RESULT([yes]) ],\n-        [ AC_MSG_RESULT([no])\n-          CFLAGS=\"$saved_CFLAGS\"\n-        ])\n+    SECP_TRY_APPEND_DEFAULT_CFLAGS(SECP_CFLAGS_FOR_BUILD)\n \n     AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n     AC_RUN_IFELSE(\n       [AC_LANG_PROGRAM([], [])],\n       [working_native_cc=yes],\n       [working_native_cc=no],[:])\n \n-    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n-\n     # Restore the environment\n     cross_compiling=$save_cross_compiling\n     CC=\"$SAVE_CC\"\n-    CFLAGS=\"$SAVE_CFLAGS\"\n     CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+    CFLAGS=\"$SAVE_CFLAGS\"\n     LDFLAGS=\"$SAVE_LDFLAGS\"\n \n     if test x\"$working_native_cc\" = x\"no\"; then\n       AC_MSG_RESULT([no])\n       set_precomp=no\n-      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n+      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CPPFLAGS_FOR_BUILD, CFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n       if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n         AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n       else\n@@ -419,8 +419,9 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   fi\n \n   AC_SUBST(CC_FOR_BUILD)\n-  AC_SUBST(CFLAGS_FOR_BUILD)\n   AC_SUBST(CPPFLAGS_FOR_BUILD)\n+  AC_SUBST(SECP_CFLAGS_FOR_BUILD)\n+  AC_SUBST(CFLAGS_FOR_BUILD)\n   AC_SUBST(LDFLAGS_FOR_BUILD)\n else\n   set_precomp=no\n@@ -490,6 +491,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AC_SUBST(SECP_CFLAGS)\n AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n@@ -532,13 +534,15 @@ fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\"\n-echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  SECP_CFLAGS             = $SECP_CFLAGS\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  LDFLAGS                 = $LDFLAGS\"\n echo\n if test x\"$set_precomp\" = x\"yes\"; then\n echo \"  CC_FOR_BUILD            = $CC_FOR_BUILD\"\n-echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n echo \"  CPPFLAGS_FOR_BUILD      = $CPPFLAGS_FOR_BUILD\"\n+echo \"  SECP_CFLAGS_FOR_BUILD   = $SECP_CFLAGS_FOR_BUILD\"\n+echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n echo \"  LDFLAGS_FOR_BUILD       = $LDFLAGS_FOR_BUILD\"\n fi"
      },
      {
        "sha": "bf562303edd9b11ad499fd6c9e4cbdbfc441a8c9",
        "filename": "contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -5,7 +5,6 @@\n  ***********************************************************************/\n \n #include <string.h>\n-#include <secp256k1.h>\n \n #include \"lax_der_parsing.h\"\n \n@@ -121,7 +120,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     /* Copy R value */\n     if (rlen > 32) {\n         overflow = 1;\n-    } else {\n+    } else if (rlen) {\n         memcpy(tmpsig + 32 - rlen, input + rpos, rlen);\n     }\n \n@@ -133,7 +132,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     /* Copy S value */\n     if (slen > 32) {\n         overflow = 1;\n-    } else {\n+    } else if (slen) {\n         memcpy(tmpsig + 64 - slen, input + spos, slen);\n     }\n "
      },
      {
        "sha": "034a38e6a0e1d0fb303c78bb9fd0ac20ecd44358",
        "filename": "contrib/lax_der_parsing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -51,7 +51,13 @@\n #ifndef SECP256K1_CONTRIB_LAX_DER_PARSING_H\n #define SECP256K1_CONTRIB_LAX_DER_PARSING_H\n \n+/* #include secp256k1.h only when it hasn't been included yet.\n+   This enables this file to be #included directly in other project\n+   files (such as tests.c) without the need to set an explicit -I flag,\n+   which would be necessary to locate secp256k1.h. */\n+#ifndef SECP256K1_H\n #include <secp256k1.h>\n+#endif\n \n #ifdef __cplusplus\n extern \"C\" {"
      },
      {
        "sha": "a1b8200079e144468d226d203b441bf86c695070",
        "filename": "contrib/lax_der_privatekey_parsing.c",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_privatekey_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_privatekey_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_privatekey_parsing.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -5,7 +5,6 @@\n  ***********************************************************************/\n \n #include <string.h>\n-#include <secp256k1.h>\n \n #include \"lax_der_privatekey_parsing.h\"\n \n@@ -45,7 +44,7 @@ int ec_privkey_import_der(const secp256k1_context* ctx, unsigned char *out32, co\n     if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1]) {\n         return 0;\n     }\n-    memcpy(out32 + 32 - privkey[1], privkey + 2, privkey[1]);\n+    if (privkey[1]) memcpy(out32 + 32 - privkey[1], privkey + 2, privkey[1]);\n     if (!secp256k1_ec_seckey_verify(ctx, out32)) {\n         memset(out32, 0, 32);\n         return 0;"
      },
      {
        "sha": "1a8ad8ae0c3b0835d19c4c7cc7df519557a1c33d",
        "filename": "contrib/lax_der_privatekey_parsing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_privatekey_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/contrib/lax_der_privatekey_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_privatekey_parsing.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -28,7 +28,13 @@\n #ifndef SECP256K1_CONTRIB_BER_PRIVATEKEY_H\n #define SECP256K1_CONTRIB_BER_PRIVATEKEY_H\n \n+/* #include secp256k1.h only when it hasn't been included yet.\n+   This enables this file to be #included directly in other project\n+   files (such as tests.c) without the need to set an explicit -I flag,\n+   which would be necessary to locate secp256k1.h. */\n+#ifndef SECP256K1_H\n #include <secp256k1.h>\n+#endif\n \n #ifdef __cplusplus\n extern \"C\" {"
      },
      {
        "sha": "7be7fd57233af86a6ce1a3fdc6cf1a076a425f82",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 57,
        "deletions": 3,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,7 +7,9 @@ extern \"C\" {\n \n #include <stddef.h>\n \n-/* These rules specify the order of arguments in API calls:\n+/* Unless explicitly stated all pointer arguments must not be NULL.\n+ *\n+ * The following rules specify the order of arguments in API calls:\n  *\n  * 1. Context pointers go first, followed by output arguments, combined\n  *    output/input arguments, and finally input-only arguments.\n@@ -61,8 +63,9 @@ typedef struct secp256k1_scratch_space_struct secp256k1_scratch_space;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage, transmission, or\n- *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n+ *  If you need to convert to a format suitable for storage or transmission,\n+ *  use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse. To\n+ *  compare keys, use secp256k1_ec_pubkey_cmp.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -127,6 +130,17 @@ typedef int (*secp256k1_nonce_function)(\n #  define SECP256K1_INLINE inline\n # endif\n \n+/** When this header is used at build-time the SECP256K1_BUILD define needs to be set\n+ *  to correctly setup export attributes and nullness checks.  This is normally done\n+ *  by secp256k1.c but to guard against this header being included before secp256k1.c\n+ *  has had a chance to set the define (e.g. via test harnesses that just includes\n+ *  secp256k1.c) we set SECP256K1_NO_BUILD when this header is processed without the\n+ *  BUILD define so this condition can be caught.\n+ */\n+#ifndef SECP256K1_BUILD\n+# define SECP256K1_NO_BUILD\n+#endif\n+\n #ifndef SECP256K1_API\n # if defined(_WIN32)\n #  ifdef SECP256K1_BUILD\n@@ -370,6 +384,21 @@ SECP256K1_API int secp256k1_ec_pubkey_serialize(\n     unsigned int flags\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Compare two public keys using lexicographic (of compressed serialization) order\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_cmp(\n+    const secp256k1_context* ctx,\n+    const secp256k1_pubkey* pubkey1,\n+    const secp256k1_pubkey* pubkey2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Parse an ECDSA signature in compact (64 bytes) format.\n  *\n  *  Returns: 1 when the signature could be parsed, 0 otherwise.\n@@ -764,6 +793,31 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compute a tagged hash as defined in BIP-340.\n+ *\n+ *  This is useful for creating a message hash and achieving domain separation\n+ *  through an application-specific tag. This function returns\n+ *  SHA256(SHA256(tag)||SHA256(tag)||msg). Therefore, tagged hash\n+ *  implementations optimized for a specific tag can precompute the SHA256 state\n+ *  after hashing the tag hashes.\n+ *\n+ *  Returns 0 if the arguments are invalid and 1 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:  hash32: pointer to a 32-byte array to store the resulting hash\n+ *  In:      tag: pointer to an array containing the tag\n+ *        taglen: length of the tag array\n+ *           msg: pointer to an array containing the message\n+ *        msglen: length of the message array\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_tagged_sha256(\n+    const secp256k1_context* ctx,\n+    unsigned char *hash32,\n+    const unsigned char *tag,\n+    size_t taglen,\n+    const unsigned char *msg,\n+    size_t msglen\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n #ifdef __cplusplus\n }\n #endif"
      },
      {
        "sha": "0a37fb6b9d31809fed5e674c2e035d80ea2db7d8",
        "filename": "include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 18,
        "deletions": 3,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_extrakeys.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -15,9 +15,9 @@ extern \"C\" {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage, transmission, or\n- *  comparison, use secp256k1_xonly_pubkey_serialize and\n- *  secp256k1_xonly_pubkey_parse.\n+ *  If you need to convert to a format suitable for storage, transmission, use\n+ *  use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse. To\n+ *  compare keys, use secp256k1_xonly_pubkey_cmp.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -67,6 +67,21 @@ SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_xonly_pubkey* pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two x-only public keys using lexicographic order\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n+    const secp256k1_context* ctx,\n+    const secp256k1_xonly_pubkey* pk1,\n+    const secp256k1_xonly_pubkey* pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n  *\n  *  Returns: 1 if the public key was successfully converted"
      },
      {
        "sha": "74cbcac45ec033aac3509fe718f8d60dc8a3fdf7",
        "filename": "include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 87,
        "deletions": 28,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorrsig.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -23,24 +23,29 @@ extern \"C\" {\n  *\n  *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n  *           return an error.\n- *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n- *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n- *           key32:     pointer to a 32-byte secret key (will not be NULL)\n- *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n- *                      (will not be NULL)\n- *           algo16:    pointer to a 16-byte array describing the signature\n- *                      algorithm (will not be NULL).\n- *           data:      Arbitrary data pointer that is passed through.\n+ *  Out:  nonce32: pointer to a 32-byte array to be filled by the function\n+ *  In:       msg: the message being verified. Is NULL if and only if msglen\n+ *                 is 0.\n+ *         msglen: the length of the message\n+ *          key32: pointer to a 32-byte secret key (will not be NULL)\n+ *     xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32\n+ *                 (will not be NULL)\n+ *           algo: pointer to an array describing the signature\n+ *                 algorithm (will not be NULL)\n+ *        algolen: the length of the algo array\n+ *           data: arbitrary data pointer that is passed through\n  *\n  *  Except for test cases, this function should compute some cryptographic hash of\n  *  the message, the key, the pubkey, the algorithm description, and data.\n  */\n typedef int (*secp256k1_nonce_function_hardened)(\n     unsigned char *nonce32,\n-    const unsigned char *msg32,\n+    const unsigned char *msg,\n+    size_t msglen,\n     const unsigned char *key32,\n     const unsigned char *xonly_pk32,\n-    const unsigned char *algo16,\n+    const unsigned char *algo,\n+    size_t algolen,\n     void *data\n );\n \n@@ -50,59 +55,113 @@ typedef int (*secp256k1_nonce_function_hardened)(\n  *\n  *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n  *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n- *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n- *  argument must be non-NULL, otherwise the function will fail and return 0.\n- *  The hash will be tagged with algo16 after removing all terminating null\n- *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n- *  to \"BIP0340/nonce\\0\\0\\0\"\n+ *  the nonce derivation procedure follows BIP-340 by setting the auxiliary\n+ *  random data to zero. The algo argument must be non-NULL, otherwise the\n+ *  function will fail and return 0. The hash will be tagged with algo.\n+ *  Therefore, to create BIP-340 compliant signatures, algo must be set to\n+ *  \"BIP0340/nonce\" and algolen to 13.\n  */\n SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n \n+/** Data structure that contains additional arguments for schnorrsig_sign_custom.\n+ *\n+ *  A schnorrsig_extraparams structure object can be initialized correctly by\n+ *  setting it to SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT.\n+ *\n+ *  Members:\n+ *      magic: set to SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC at initialization\n+ *             and has no other function than making sure the object is\n+ *             initialized.\n+ *    noncefp: pointer to a nonce generation function. If NULL,\n+ *             secp256k1_nonce_function_bip340 is used\n+ *      ndata: pointer to arbitrary data used by the nonce generation function\n+ *             (can be NULL). If it is non-NULL and\n+ *             secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *             pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+typedef struct {\n+    unsigned char magic[4];\n+    secp256k1_nonce_function_hardened noncefp;\n+    void* ndata;\n+} secp256k1_schnorrsig_extraparams;\n+\n+#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC { 0xda, 0x6f, 0xb3, 0x8c }\n+#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT {\\\n+    SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC,\\\n+    NULL,\\\n+    NULL\\\n+}\n+\n /** Create a Schnorr signature.\n  *\n  *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n  *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n  *  abort if it fails.\n  *\n- *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n- *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n- *  randomness.\n+ *  This function only signs 32-byte messages. If you have messages of a\n+ *  different size (or the same size but without a context-specific tag\n+ *  prefix), it is recommended to create a 32-byte message hash with\n+ *  secp256k1_tagged_sha256 and then sign the hash. Tagged hashing allows\n+ *  providing an context-specific tag for domain separation. This prevents\n+ *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n  *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n  *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n  *       keypair: pointer to an initialized keypair (cannot be NULL)\n- *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n- *         ndata: pointer to arbitrary data used by the nonce generation\n- *                function (can be NULL). If it is non-NULL and\n- *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n- *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n+ *                this, it is only supplemental to security and can be NULL. See\n+ *                BIP-340 \"Default Signing\" for a full explanation of this\n+ *                argument and for guidance if randomness is expensive.\n  */\n SECP256K1_API int secp256k1_schnorrsig_sign(\n     const secp256k1_context* ctx,\n     unsigned char *sig64,\n     const unsigned char *msg32,\n     const secp256k1_keypair *keypair,\n-    secp256k1_nonce_function_hardened noncefp,\n-    void *ndata\n+    unsigned char *aux_rand32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Create a Schnorr signature with a more flexible API.\n+ *\n+ *  Same arguments as secp256k1_schnorrsig_sign except that it allows signing\n+ *  variable length messages and accepts a pointer to an extraparams object that\n+ *  allows customizing signing by passing additional arguments.\n+ *\n+ *  Creates the same signatures as schnorrsig_sign if msglen is 32 and the\n+ *  extraparams.ndata is the same as aux_rand32.\n+ *\n+ *  In:     msg: the message being signed. Can only be NULL if msglen is 0.\n+ *       msglen: length of the message\n+ *  extraparams: pointer to a extraparams object (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg,\n+    size_t msglen,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_schnorrsig_extraparams *extraparams\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(5);\n+\n /** Verify a Schnorr signature.\n  *\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n  *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n- *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *           msg: the message being verified. Can only be NULL if msglen is 0.\n+ *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n     const secp256k1_context* ctx,\n     const unsigned char *sig64,\n-    const unsigned char *msg32,\n+    const unsigned char *msg,\n+    size_t msglen,\n     const secp256k1_xonly_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(5);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "obj/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/obj/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/obj/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/obj/.gitignore?ref=bdca9bcb6c9379707d09c63f02326884befbefb2"
      },
      {
        "sha": "cb020d26b4d9969cb54c5e4a9c5476bd70090f04",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -6,8 +6,8 @@\n \n #include <string.h>\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_ecdh.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_ecdh.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "1d463f92d0beeaa15732c7a901c524714d148335",
        "filename": "src/bench_ecmult.c",
        "status": "modified",
        "additions": 189,
        "deletions": 35,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -5,7 +5,8 @@\n  ***********************************************************************/\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n \n #include \"util.h\"\n #include \"hash_impl.h\"\n@@ -14,33 +15,177 @@\n #include \"scalar_impl.h\"\n #include \"ecmult_impl.h\"\n #include \"bench.h\"\n-#include \"secp256k1.c\"\n \n #define POINTS 32768\n \n+void help(char **argv) {\n+    printf(\"Benchmark EC multiplication algorithms\\n\");\n+    printf(\"\\n\");\n+    printf(\"Usage: %s <help|pippenger_wnaf|strauss_wnaf|simple>\\n\", argv[0]);\n+    printf(\"The output shows the number of multiplied and summed points right after the\\n\");\n+    printf(\"function name. The letter 'g' indicates that one of the points is the generator.\\n\");\n+    printf(\"The benchmarks are divided by the number of points.\\n\");\n+    printf(\"\\n\");\n+    printf(\"default (ecmult_multi): picks pippenger_wnaf or strauss_wnaf depending on the\\n\");\n+    printf(\"                        batch size\\n\");\n+    printf(\"pippenger_wnaf:         for all batch sizes\\n\");\n+    printf(\"strauss_wnaf:           for all batch sizes\\n\");\n+    printf(\"simple:                 multiply and sum each point individually\\n\");\n+}\n+\n typedef struct {\n     /* Setup once in advance */\n     secp256k1_context* ctx;\n     secp256k1_scratch_space* scratch;\n     secp256k1_scalar* scalars;\n     secp256k1_ge* pubkeys;\n+    secp256k1_gej* pubkeys_gej;\n     secp256k1_scalar* seckeys;\n     secp256k1_gej* expected_output;\n     secp256k1_ecmult_multi_func ecmult_multi;\n \n-    /* Changes per test */\n+    /* Changes per benchmark */\n     size_t count;\n     int includes_g;\n \n-    /* Changes per test iteration */\n+    /* Changes per benchmark iteration, used to pick different scalars and pubkeys\n+     * in each run. */\n     size_t offset1;\n     size_t offset2;\n \n-    /* Test output. */\n+    /* Benchmark output. */\n     secp256k1_gej* output;\n } bench_data;\n \n-static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n+/* Hashes x into [0, POINTS) twice and store the result in offset1 and offset2. */\n+static void hash_into_offset(bench_data* data, size_t x) {\n+    data->offset1 = (x * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (x * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+}\n+\n+/* Check correctness of the benchmark by computing\n+ * sum(outputs) ?= (sum(scalars_gen) + sum(seckeys)*sum(scalars))*G */\n+static void bench_ecmult_teardown_helper(bench_data* data, size_t* seckey_offset, size_t* scalar_offset, size_t* scalar_gen_offset, int iters) {\n+    int i;\n+    secp256k1_gej sum_output, tmp;\n+    secp256k1_scalar sum_scalars;\n+\n+    secp256k1_gej_set_infinity(&sum_output);\n+    secp256k1_scalar_clear(&sum_scalars);\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_gej_add_var(&sum_output, &sum_output, &data->output[i], NULL);\n+        if (scalar_gen_offset != NULL) {\n+            secp256k1_scalar_add(&sum_scalars, &sum_scalars, &data->scalars[(*scalar_gen_offset+i) % POINTS]);\n+        }\n+        if (seckey_offset != NULL) {\n+            secp256k1_scalar s = data->seckeys[(*seckey_offset+i) % POINTS];\n+            secp256k1_scalar_mul(&s, &s, &data->scalars[(*scalar_offset+i) % POINTS]);\n+            secp256k1_scalar_add(&sum_scalars, &sum_scalars, &s);\n+        }\n+    }\n+    secp256k1_ecmult_gen(&data->ctx->ecmult_gen_ctx, &tmp, &sum_scalars);\n+    secp256k1_gej_neg(&tmp, &tmp);\n+    secp256k1_gej_add_var(&tmp, &tmp, &sum_output, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&tmp));\n+}\n+\n+static void bench_ecmult_setup(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    /* Re-randomize offset to ensure that we're using different scalars and\n+     * group elements in each run. */\n+    hash_into_offset(data, data->offset1);\n+}\n+\n+static void bench_ecmult_gen(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult_gen(&data->ctx->ecmult_gen_ctx, &data->output[i], &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_gen_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n+}\n+\n+static void bench_ecmult_const(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult_const(&data->output[i], &data->pubkeys[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], 256);\n+    }\n+}\n+\n+static void bench_ecmult_const_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n+}\n+\n+static void bench_ecmult_1(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+    }\n+}\n+\n+static void bench_ecmult_1_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n+}\n+\n+static void bench_ecmult_1g(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    secp256k1_scalar zero;\n+    int i;\n+\n+    secp256k1_scalar_set_int(&zero, 0);\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_1g_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n+}\n+\n+static void bench_ecmult_2g(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters/2; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_2g_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, &data->offset1, iters/2);\n+}\n+\n+static void run_ecmult_bench(bench_data* data, int iters) {\n+    char str[32];\n+    sprintf(str, \"ecmult_gen\");\n+    run_benchmark(str, bench_ecmult_gen, bench_ecmult_setup, bench_ecmult_gen_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_const\");\n+    run_benchmark(str, bench_ecmult_const, bench_ecmult_setup, bench_ecmult_const_teardown, data, 10, iters);\n+    /* ecmult with non generator point */\n+    sprintf(str, \"ecmult 1\");\n+    run_benchmark(str, bench_ecmult_1, bench_ecmult_setup, bench_ecmult_1_teardown, data, 10, iters);\n+    /* ecmult with generator point */\n+    sprintf(str, \"ecmult 1g\");\n+    run_benchmark(str, bench_ecmult_1g, bench_ecmult_setup, bench_ecmult_1g_teardown, data, 10, iters);\n+    /* ecmult with generator and non-generator point. The reported time is per point. */\n+    sprintf(str, \"ecmult 2g\");\n+    run_benchmark(str, bench_ecmult_2g, bench_ecmult_setup, bench_ecmult_2g_teardown, data, 10, 2*iters);\n+}\n+\n+static int bench_ecmult_multi_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n     bench_data* data = (bench_data*)arg;\n     if (data->includes_g) ++idx;\n     if (idx == 0) {\n@@ -53,7 +198,7 @@ static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, vo\n     return 1;\n }\n \n-static void bench_ecmult(void* arg, int iters) {\n+static void bench_ecmult_multi(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n \n     int includes_g = data->includes_g;\n@@ -62,19 +207,18 @@ static void bench_ecmult(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n }\n \n-static void bench_ecmult_setup(void* arg) {\n+static void bench_ecmult_multi_setup(void* arg) {\n     bench_data* data = (bench_data*)arg;\n-    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n-    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    hash_into_offset(data, data->count);\n }\n \n-static void bench_ecmult_teardown(void* arg, int iters) {\n+static void bench_ecmult_multi_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int iter;\n     iters = iters / data->count;\n@@ -88,7 +232,7 @@ static void bench_ecmult_teardown(void* arg, int iters) {\n \n static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     secp256k1_sha256 sha256;\n-    unsigned char c[11] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n+    unsigned char c[10] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n     unsigned char buf[32];\n     int overflow = 0;\n     c[6] = num;\n@@ -102,7 +246,7 @@ static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     CHECK(!overflow);\n }\n \n-static void run_test(bench_data* data, size_t count, int includes_g, int num_iters) {\n+static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_g, int num_iters) {\n     char str[32];\n     static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n     size_t iters = 1 + num_iters / count;\n@@ -112,8 +256,7 @@ static void run_test(bench_data* data, size_t count, int includes_g, int num_ite\n     data->includes_g = includes_g;\n \n     /* Compute (the negation of) the expected results directly. */\n-    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n-    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    hash_into_offset(data, data->count);\n     for (iter = 0; iter < iters; ++iter) {\n         secp256k1_scalar tmp;\n         secp256k1_scalar total = data->scalars[(data->offset1++) % POINTS];\n@@ -127,65 +270,75 @@ static void run_test(bench_data* data, size_t count, int includes_g, int num_ite\n     }\n \n     /* Run the benchmark. */\n-    sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n-    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * iters);\n+    sprintf(str, includes_g ? \"ecmult_multi %ig\" : \"ecmult_multi %i\", (int)count);\n+    run_benchmark(str, bench_ecmult_multi, bench_ecmult_multi_setup, bench_ecmult_multi_teardown, data, 10, count * iters);\n }\n \n int main(int argc, char **argv) {\n     bench_data data;\n     int i, p;\n-    secp256k1_gej* pubkeys_gej;\n     size_t scratch_size;\n \n     int iters = get_iters(10000);\n \n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n-    data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n     data.ecmult_multi = secp256k1_ecmult_multi_var;\n \n     if (argc > 1) {\n-        if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n+        if(have_flag(argc, argv, \"-h\")\n+           || have_flag(argc, argv, \"--help\")\n+           || have_flag(argc, argv, \"help\")) {\n+            help(argv);\n+            return 1;\n+        } else if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n             printf(\"Using pippenger_wnaf:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_pippenger_batch_single;\n         } else if(have_flag(argc, argv, \"strauss_wnaf\")) {\n             printf(\"Using strauss_wnaf:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_strauss_batch_single;\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n-            data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n-            data.scratch = NULL;\n         } else {\n-            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n-            fprintf(stderr, \"Use 'pippenger_wnaf', 'strauss_wnaf', 'simple' or no argument to benchmark a combined algorithm.\\n\");\n+            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\\n\", argv[0], argv[1]);\n+            help(argv);\n             return 1;\n         }\n     }\n \n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n+    if (!have_flag(argc, argv, \"simple\")) {\n+        data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n+    } else {\n+        data.scratch = NULL;\n+    }\n+\n     /* Allocate stuff */\n     data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n+    data.pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n     data.expected_output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n     data.output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n \n     /* Generate a set of scalars, and private/public keypairs. */\n-    pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n-    secp256k1_gej_set_ge(&pubkeys_gej[0], &secp256k1_ge_const_g);\n+    secp256k1_gej_set_ge(&data.pubkeys_gej[0], &secp256k1_ge_const_g);\n     secp256k1_scalar_set_int(&data.seckeys[0], 1);\n     for (i = 0; i < POINTS; ++i) {\n         generate_scalar(i, &data.scalars[i]);\n         if (i) {\n-            secp256k1_gej_double_var(&pubkeys_gej[i], &pubkeys_gej[i - 1], NULL);\n+            secp256k1_gej_double_var(&data.pubkeys_gej[i], &data.pubkeys_gej[i - 1], NULL);\n             secp256k1_scalar_add(&data.seckeys[i], &data.seckeys[i - 1], &data.seckeys[i - 1]);\n         }\n     }\n-    secp256k1_ge_set_all_gej_var(data.pubkeys, pubkeys_gej, POINTS);\n-    free(pubkeys_gej);\n+    secp256k1_ge_set_all_gej_var(data.pubkeys, data.pubkeys_gej, POINTS);\n+\n+\n+    /* Initialize offset1 and offset2 */\n+    hash_into_offset(&data, 0);\n+    run_ecmult_bench(&data, iters);\n \n     for (i = 1; i <= 8; ++i) {\n-        run_test(&data, i, 1, iters);\n+        run_ecmult_multi_bench(&data, i, 1, iters);\n     }\n \n     /* This is disabled with low count of iterations because the loop runs 77 times even with iters=1\n@@ -194,7 +347,7 @@ int main(int argc, char **argv) {\n      if (iters > 2) {\n         for (p = 0; p <= 11; ++p) {\n             for (i = 9; i <= 16; ++i) {\n-                run_test(&data, i << p, 1, iters);\n+                run_ecmult_multi_bench(&data, i << p, 1, iters);\n             }\n         }\n     }\n@@ -205,6 +358,7 @@ int main(int argc, char **argv) {\n     secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n+    free(data.pubkeys_gej);\n     free(data.seckeys);\n     free(data.output);\n     free(data.expected_output);"
      },
      {
        "sha": "161b1c4a47666e88b36310fc79675a8f3f13d6c9",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -5,7 +5,8 @@\n  ***********************************************************************/\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -16,7 +17,6 @@\n #include \"ecmult_const_impl.h\"\n #include \"ecmult_impl.h\"\n #include \"bench.h\"\n-#include \"secp256k1.c\"\n \n typedef struct {\n     secp256k1_scalar scalar[2];"
      },
      {
        "sha": "4bcac19dc0a398669a53c55da6ac4b248f98546b",
        "filename": "src/bench_recover.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -4,8 +4,8 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_recovery.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_recovery.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "d95bc00f485fb2640a0c295cdde79b082591fe0b",
        "filename": "src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_schnorrsig.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -8,11 +8,13 @@\n #include <stdlib.h>\n \n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_schnorrsig.h\"\n #include \"util.h\"\n #include \"bench.h\"\n \n+#define MSGLEN 32\n+\n typedef struct {\n     secp256k1_context *ctx;\n     int n;\n@@ -26,13 +28,13 @@ typedef struct {\n void bench_schnorrsig_sign(void* arg, int iters) {\n     bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n     int i;\n-    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char msg[MSGLEN] = {0};\n     unsigned char sig[64];\n \n     for (i = 0; i < iters; i++) {\n         msg[0] = i;\n         msg[1] = i >> 8;\n-        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_sign_custom(data->ctx, sig, msg, MSGLEN, data->keypairs[i], NULL));\n     }\n }\n \n@@ -43,7 +45,7 @@ void bench_schnorrsig_verify(void* arg, int iters) {\n     for (i = 0; i < iters; i++) {\n         secp256k1_xonly_pubkey pk;\n         CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n-        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], MSGLEN, &pk));\n     }\n }\n \n@@ -58,9 +60,10 @@ int main(void) {\n     data.msgs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n     data.sigs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n \n+    CHECK(MSGLEN >= 4);\n     for (i = 0; i < iters; i++) {\n         unsigned char sk[32];\n-        unsigned char *msg = (unsigned char *)malloc(32);\n+        unsigned char *msg = (unsigned char *)malloc(MSGLEN);\n         unsigned char *sig = (unsigned char *)malloc(64);\n         secp256k1_keypair *keypair = (secp256k1_keypair *)malloc(sizeof(*keypair));\n         unsigned char *pk_char = (unsigned char *)malloc(32);\n@@ -69,7 +72,7 @@ int main(void) {\n         msg[1] = sk[1] = i >> 8;\n         msg[2] = sk[2] = i >> 16;\n         msg[3] = sk[3] = i >> 24;\n-        memset(&msg[4], 'm', 28);\n+        memset(&msg[4], 'm', MSGLEN - 4);\n         memset(&sk[4], 's', 28);\n \n         data.keypairs[i] = keypair;\n@@ -78,7 +81,7 @@ int main(void) {\n         data.sigs[i] = sig;\n \n         CHECK(secp256k1_keypair_create(data.ctx, keypair, sk));\n-        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, keypair, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_sign_custom(data.ctx, sig, msg, MSGLEN, keypair, NULL));\n         CHECK(secp256k1_keypair_xonly_pub(data.ctx, &pk, NULL, keypair));\n         CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n     }"
      },
      {
        "sha": "f659c18c92d0bd20fee399b2c1a0f3ca1a27a41b",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -4,7 +4,7 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "565ae4beec8a5726b267cd141d61ecf50c101c4f",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,7 +7,7 @@\n #include <stdio.h>\n #include <string.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "c32141e8872de1b97d8bfebd8d51a8b90bd880b5",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -140,7 +140,7 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         overflow = 1;\n     }\n     if (!overflow) {\n-        memcpy(ra + 32 - rlen, *sig, rlen);\n+        if (rlen) memcpy(ra + 32 - rlen, *sig, rlen);\n         secp256k1_scalar_set_b32(r, ra, &overflow);\n     }\n     if (overflow) {"
      },
      {
        "sha": "84537bbfed20a765f00de4d28eb7069745f2d2a2",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -17,7 +17,6 @@ typedef struct {\n     secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n } secp256k1_ecmult_context;\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);"
      },
      {
        "sha": "05cf4d52ccafe91a16077748ae609c96b3ae8b0d",
        "filename": "src/ecmult_gen.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -35,7 +35,6 @@ typedef struct {\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n-static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);"
      },
      {
        "sha": "f9176eb99674233003afc7685407a37b7ce9e369",
        "filename": "src/gen_context.c",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_context.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -13,7 +13,13 @@\n /* We can't require the precomputed tables when creating them. */\n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n \n-#include \"include/secp256k1.h\"\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n #include \"field_impl.h\""
      },
      {
        "sha": "47aea32be184a0f401403ffbf98067d7f4f5bb9d",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -100,8 +100,8 @@ static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a) {\n \n static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     secp256k1_fe z2, z3;\n-    r->infinity = a->infinity;\n     if (a->infinity) {\n+        secp256k1_ge_set_infinity(r);\n         return;\n     }\n     secp256k1_fe_inv_var(&a->z, &a->z);\n@@ -110,8 +110,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     secp256k1_fe_mul(&a->x, &a->x, &z2);\n     secp256k1_fe_mul(&a->y, &a->y, &z3);\n     secp256k1_fe_set_int(&a->z, 1);\n-    r->x = a->x;\n-    r->y = a->y;\n+    secp256k1_ge_set_xy(r, &a->x, &a->y);\n }\n \n static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len) {\n@@ -120,7 +119,9 @@ static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a\n     size_t last_i = SIZE_MAX;\n \n     for (i = 0; i < len; i++) {\n-        if (!a[i].infinity) {\n+        if (a[i].infinity) {\n+            secp256k1_ge_set_infinity(&r[i]);\n+        } else {\n             /* Use destination's x coordinates as scratch space */\n             if (last_i == SIZE_MAX) {\n                 r[i].x = a[i].z;\n@@ -148,7 +149,6 @@ static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a\n     r[last_i].x = u;\n \n     for (i = 0; i < len; i++) {\n-        r[i].infinity = a[i].infinity;\n         if (!a[i].infinity) {\n             secp256k1_ge_set_gej_zinv(&r[i], &a[i], &r[i].x);\n         }\n@@ -311,7 +311,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n      *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     if (a->infinity) {\n-        r->infinity = 1;\n+        secp256k1_gej_set_infinity(r);\n         if (rzr != NULL) {\n             secp256k1_fe_set_int(rzr, 1);\n         }"
      },
      {
        "sha": "5408c9de707107eef78d0e7a6707f30535333f7d",
        "filename": "src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/main_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_MODULE_ECDH_MAIN_H\n #define SECP256K1_MODULE_ECDH_MAIN_H\n \n-#include \"include/secp256k1_ecdh.h\"\n-#include \"ecmult_const_impl.h\"\n+#include \"../../../include/secp256k1_ecdh.h\"\n+#include \"../../ecmult_const_impl.h\"\n \n static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n     unsigned char version = (y32[31] & 0x01) | 0x02;"
      },
      {
        "sha": "8607bbede73022a40db8f0c60227d61b4f447b90",
        "filename": "src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 2,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/main_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n #define SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n     return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n@@ -55,6 +55,32 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_cmp(const secp256k1_context* ctx, const secp256k1_xonly_pubkey* pk0, const secp256k1_xonly_pubkey* pk1) {\n+    unsigned char out[2][32];\n+    const secp256k1_xonly_pubkey* pk[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    pk[0] = pk0; pk[1] = pk1;\n+    for (i = 0; i < 2; i++) {\n+        /* If the public key is NULL or invalid, xonly_pubkey_serialize will\n+         * call the illegal_callback and return 0. In that case we will\n+         * serialize the key as all zeros which is less than any valid public\n+         * key. This results in consistent comparisons even if NULL or invalid\n+         * pubkeys are involved and prevents edge cases such as sorting\n+         * algorithms that use this function and do not terminate as a\n+         * result. */\n+        if (!secp256k1_xonly_pubkey_serialize(ctx, out[i], pk[i])) {\n+            /* Note that xonly_pubkey_serialize should already set the output to\n+             * zero in that case, but it's not guaranteed by the API, we can't\n+             * test it and writing a VERIFY_CHECK is more complex than\n+             * explicitly memsetting (again). */\n+            memset(out[i], 0, sizeof(out[i]));\n+        }\n+    }\n+    return secp256k1_memcmp_var(out[0], out[1], sizeof(out[1]));\n+}\n+\n /** Keeps a group element as is if it has an even Y and otherwise negates it.\n  *  y_parity is set to 0 in the former case and to 1 in the latter case.\n  *  Requires that the coordinates of r are normalized. */"
      },
      {
        "sha": "d4a2f5bdf4050e821218816585d4d0a3edfdaf3c",
        "filename": "src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_exhaustive_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -8,7 +8,7 @@\n #define SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n \n #include \"src/modules/extrakeys/main_impl.h\"\n-#include \"include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static void test_exhaustive_extrakeys(const secp256k1_context *ctx, const secp256k1_ge* group) {\n     secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];"
      },
      {
        "sha": "4a5952714c41c5147b9ccf48914f18d196c51531",
        "filename": "src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n #define SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n \n-#include \"secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static secp256k1_context* api_test_context(int flags, int *ecount) {\n     secp256k1_context *ctx0 = secp256k1_context_create(flags);\n@@ -137,6 +137,43 @@ void test_xonly_pubkey(void) {\n     secp256k1_context_destroy(verify);\n }\n \n+void test_xonly_pubkey_comparison(void) {\n+    unsigned char pk1_ser[32] = {\n+        0x58, 0x84, 0xb3, 0xa2, 0x4b, 0x97, 0x37, 0x88, 0x92, 0x38, 0xa6, 0x26, 0x62, 0x52, 0x35, 0x11,\n+        0xd0, 0x9a, 0xa1, 0x1b, 0x80, 0x0b, 0x5e, 0x93, 0x80, 0x26, 0x11, 0xef, 0x67, 0x4b, 0xd9, 0x23\n+    };\n+    const unsigned char pk2_ser[32] = {\n+        0xde, 0x36, 0x0e, 0x87, 0x59, 0x8f, 0x3c, 0x01, 0x36, 0x2a, 0x2a, 0xb8, 0xc6, 0xf4, 0x5e, 0x4d,\n+        0xb2, 0xc2, 0xd5, 0x03, 0xa7, 0xf9, 0xf1, 0x4f, 0xa8, 0xfa, 0x95, 0xa8, 0xe9, 0x69, 0x76, 0x1c\n+    };\n+    secp256k1_xonly_pubkey pk1;\n+    secp256k1_xonly_pubkey pk2;\n+    int ecount = 0;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk1, pk1_ser) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk2, pk2_ser) == 1);\n+\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, NULL, &pk2) < 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, NULL) > 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk1) > 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk1) == 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk2) == 0);\n+    CHECK(ecount == 2);\n+    memset(&pk1, 0, sizeof(pk1)); /* illegal pubkey */\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk2) < 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk1) > 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+}\n+\n void test_xonly_pubkey_tweak(void) {\n     unsigned char zeros64[64] = { 0 };\n     unsigned char overflows[32];\n@@ -540,6 +577,7 @@ void run_extrakeys_tests(void) {\n     test_xonly_pubkey_tweak();\n     test_xonly_pubkey_tweak_check();\n     test_xonly_pubkey_tweak_recursive();\n+    test_xonly_pubkey_comparison();\n \n     /* keypair tests */\n     test_keypair();"
      },
      {
        "sha": "9e19f2a2dc9c880fd80c48108d46ee4ac5f9a618",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_RECOVERY_MAIN_H\n #define SECP256K1_MODULE_RECOVERY_MAIN_H\n \n-#include \"include/secp256k1_recovery.h\"\n+#include \"../../../include/secp256k1_recovery.h\"\n \n static void secp256k1_ecdsa_recoverable_signature_load(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, int* recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     (void)ctx;"
      },
      {
        "sha": "590a972ed3f74a9e24978ee373895bab5dad8128",
        "filename": "src/modules/recovery/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_exhaustive_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -8,7 +8,7 @@\n #define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n \n #include \"src/modules/recovery/main_impl.h\"\n-#include \"include/secp256k1_recovery.h\"\n+#include \"../../../include/secp256k1_recovery.h\"\n \n void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k;"
      },
      {
        "sha": "693b78f03444d6ce8325a4fea44114b73c0a87b4",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,9 +7,9 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n #define SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorrsig.h\"\n-#include \"hash.h\"\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n+#include \"../../hash.h\"\n \n /* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n  * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n@@ -43,16 +43,18 @@ static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *\n     sha->bytes = 64;\n }\n \n-/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+/* algo argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n  * by using the correct tagged hash function. */\n-static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+static const unsigned char bip340_algo[13] = \"BIP0340/nonce\";\n \n-static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+static const unsigned char schnorrsig_extraparams_magic[4] = SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC;\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n     secp256k1_sha256 sha;\n     unsigned char masked_key[32];\n     int i;\n \n-    if (algo16 == NULL) {\n+    if (algo == NULL) {\n         return 0;\n     }\n \n@@ -65,18 +67,14 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         }\n     }\n \n-    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+    /* Tag the hash with algo which is important to avoid nonce reuse across\n      * algorithms. If this nonce function is used in BIP-340 signing as defined\n      * in the spec, an optimized tagging implementation is used. */\n-    if (secp256k1_memcmp_var(algo16, bip340_algo16, 16) == 0) {\n+    if (algolen == sizeof(bip340_algo)\n+            && secp256k1_memcmp_var(algo, bip340_algo, algolen) == 0) {\n         secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n     } else {\n-        int algo16_len = 16;\n-        /* Remove terminating null bytes */\n-        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n-            algo16_len--;\n-        }\n-        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+        secp256k1_sha256_initialize_tagged(&sha, algo, algolen);\n     }\n \n     /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n@@ -86,7 +84,7 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         secp256k1_sha256_write(&sha, key32, 32);\n     }\n     secp256k1_sha256_write(&sha, xonly_pk32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, nonce32);\n     return 1;\n }\n@@ -108,23 +106,23 @@ static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n     sha->bytes = 64;\n }\n \n-static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg32, const unsigned char *pubkey32)\n+static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg, size_t msglen, const unsigned char *pubkey32)\n {\n     unsigned char buf[32];\n     secp256k1_sha256 sha;\n \n-    /* tagged hash(r.x, pk.x, msg32) */\n+    /* tagged hash(r.x, pk.x, msg) */\n     secp256k1_schnorrsig_sha256_tagged(&sha);\n     secp256k1_sha256_write(&sha, r32, 32);\n     secp256k1_sha256_write(&sha, pubkey32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, buf);\n     /* Set scalar e to the challenge hash modulo the curve order as per\n      * BIP340. */\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -139,7 +137,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(keypair != NULL);\n \n     if (noncefp == NULL) {\n@@ -156,7 +154,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n \n     secp256k1_scalar_get_b32(seckey, &sk);\n     secp256k1_fe_get_b32(pk_buf, &pk.x);\n-    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    ret &= !!noncefp(buf, msg, msglen, seckey, pk_buf, bip340_algo, sizeof(bip340_algo), ndata);\n     secp256k1_scalar_set_b32(&k, buf, NULL);\n     ret &= !secp256k1_scalar_is_zero(&k);\n     secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n@@ -174,7 +172,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_fe_normalize_var(&r.x);\n     secp256k1_fe_get_b32(&sig64[0], &r.x);\n \n-    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, pk_buf);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, pk_buf);\n     secp256k1_scalar_mul(&e, &e, &sk);\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n@@ -187,7 +185,26 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     return ret;\n }\n \n-int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, unsigned char *aux_rand32) {\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, aux_rand32);\n+}\n+\n+int secp256k1_schnorrsig_sign_custom(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams) {\n+    secp256k1_nonce_function_hardened noncefp = NULL;\n+    void *ndata = NULL;\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    if (extraparams != NULL) {\n+        ARG_CHECK(secp256k1_memcmp_var(extraparams->magic,\n+                                       schnorrsig_extraparams_magic,\n+                                       sizeof(extraparams->magic)) == 0);\n+        noncefp = extraparams->noncefp;\n+        ndata = extraparams->ndata;\n+    }\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg, msglen, keypair, noncefp, ndata);\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey) {\n     secp256k1_scalar s;\n     secp256k1_scalar e;\n     secp256k1_gej rj;\n@@ -201,7 +218,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n \n     if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n@@ -219,7 +236,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n \n     /* Compute e. */\n     secp256k1_fe_get_b32(buf, &pk.x);\n-    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, buf);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, buf);\n \n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);"
      },
      {
        "sha": "d8df9dd2df7425a0f25a4d2ba185a54c110357ba",
        "filename": "src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n #define SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n \n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n #include \"src/modules/schnorrsig/main_impl.h\"\n \n static const unsigned char invalid_pubkey_bytes[][32] = {\n@@ -58,15 +58,19 @@ static const unsigned char invalid_pubkey_bytes[][32] = {\n \n #define NUM_INVALID_KEYS (sizeof(invalid_pubkey_bytes) / sizeof(invalid_pubkey_bytes[0]))\n \n-static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg,\n+                                                      size_t msglen,\n                                                       const unsigned char *key32, const unsigned char *xonly_pk32,\n-                                                      const unsigned char *algo16, void* data) {\n+                                                      const unsigned char *algo, size_t algolen,\n+                                                      void* data) {\n     secp256k1_scalar s;\n     int *idata = data;\n-    (void)msg32;\n+    (void)msg;\n+    (void)msglen;\n     (void)key32;\n     (void)xonly_pk32;\n-    (void)algo16;\n+    (void)algo;\n+    (void)algolen;\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n     return 1;\n@@ -101,7 +105,7 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n                 secp256k1_scalar e;\n                 unsigned char msg32[32];\n                 secp256k1_testrand256(msg32);\n-                secp256k1_schnorrsig_challenge(&e, sig64, msg32, pk32);\n+                secp256k1_schnorrsig_challenge(&e, sig64, msg32, sizeof(msg32), pk32);\n                 /* Only do work if we hit a challenge we haven't tried before. */\n                 if (!e_done[e]) {\n                     /* Iterate over the possible valid last 32 bytes in the signature.\n@@ -119,7 +123,7 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n                             secp256k1_testrand256(sig64 + 32);\n                             expect_valid = 0;\n                         }\n-                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, &pubkeys[d - 1]);\n+                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, sizeof(msg32), &pubkeys[d - 1]);\n                         CHECK(valid == expect_valid);\n                         count_valid += valid;\n                     }\n@@ -137,6 +141,8 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsigned char (*xonly_pubkey_bytes)[32], const secp256k1_keypair* keypairs, const int* parities) {\n     int d, k;\n     uint64_t iter = 0;\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+\n     /* Loop over keys. */\n     for (d = 1; d < EXHAUSTIVE_TEST_ORDER; ++d) {\n         int actual_d = d;\n@@ -149,19 +155,21 @@ static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsign\n             unsigned char sig64[64];\n             int actual_k = k;\n             if (skip_section(&iter)) continue;\n+            extraparams.noncefp = secp256k1_hardened_nonce_function_smallint;\n+            extraparams.ndata = &k;\n             if (parities[k - 1]) actual_k = EXHAUSTIVE_TEST_ORDER - k;\n             /* Generate random messages until all challenges have been tried. */\n             while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n                 secp256k1_scalar e;\n                 secp256k1_testrand256(msg32);\n-                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, xonly_pubkey_bytes[d - 1]);\n+                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, sizeof(msg32), xonly_pubkey_bytes[d - 1]);\n                 /* Only do work if we hit a challenge we haven't tried before. */\n                 if (!e_done[e]) {\n                     secp256k1_scalar expected_s = (actual_k + e * actual_d) % EXHAUSTIVE_TEST_ORDER;\n                     unsigned char expected_s_bytes[32];\n                     secp256k1_scalar_get_b32(expected_s_bytes, &expected_s);\n                     /* Invoke the real function to construct a signature. */\n-                    CHECK(secp256k1_schnorrsig_sign(ctx, sig64, msg32, &keypairs[d - 1], secp256k1_hardened_nonce_function_smallint, &k));\n+                    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig64, msg32, sizeof(msg32), &keypairs[d - 1], &extraparams));\n                     /* The first 32 bytes must match the xonly pubkey for the specified k. */\n                     CHECK(secp256k1_memcmp_var(sig64, xonly_pubkey_bytes[k - 1], 32) == 0);\n                     /* The last 32 bytes must match the expected s value. */"
      },
      {
        "sha": "59357afa99ad6a621b164e0c42bae4e2faeec021",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 160,
        "deletions": 75,
        "changes": 235,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,16 +7,16 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n #define SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n \n-#include \"secp256k1_schnorrsig.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n \n /* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n  * bytes) changes the hash function\n  */\n-void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes, size_t msglen, size_t algolen) {\n     unsigned char nonces[2][32];\n-    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(nonce_function_bip340(nonces[0], args[0], msglen, args[1], args[2], args[3], algolen, args[4]) == 1);\n     secp256k1_testrand_flip(args[n_flip], n_bytes);\n-    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], msglen, args[1], args[2], args[3], algolen, args[4]) == 1);\n     CHECK(secp256k1_memcmp_var(nonces[0], nonces[1], 32) != 0);\n }\n \n@@ -34,11 +34,13 @@ void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2)\n void run_nonce_function_bip340_tests(void) {\n     unsigned char tag[13] = \"BIP0340/nonce\";\n     unsigned char aux_tag[11] = \"BIP0340/aux\";\n-    unsigned char algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+    unsigned char algo[13] = \"BIP0340/nonce\";\n+    size_t algolen = sizeof(algo);\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n     unsigned char nonce[32];\n     unsigned char msg[32];\n+    size_t msglen = sizeof(msg);\n     unsigned char key[32];\n     unsigned char pk[32];\n     unsigned char aux_rand[32];\n@@ -68,33 +70,45 @@ void run_nonce_function_bip340_tests(void) {\n     args[0] = msg;\n     args[1] = key;\n     args[2] = pk;\n-    args[3] = algo16;\n+    args[3] = algo;\n     args[4] = aux_rand;\n     for (i = 0; i < count; i++) {\n-        nonce_function_bip340_bitflip(args, 0, 32);\n-        nonce_function_bip340_bitflip(args, 1, 32);\n-        nonce_function_bip340_bitflip(args, 2, 32);\n-        /* Flip algo16 special case \"BIP0340/nonce\" */\n-        nonce_function_bip340_bitflip(args, 3, 16);\n-        /* Flip algo16 again */\n-        nonce_function_bip340_bitflip(args, 3, 16);\n-        nonce_function_bip340_bitflip(args, 4, 32);\n+        nonce_function_bip340_bitflip(args, 0, 32, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 1, 32, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 2, 32, msglen, algolen);\n+        /* Flip algo special case \"BIP0340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, algolen, msglen, algolen);\n+        /* Flip algo again */\n+        nonce_function_bip340_bitflip(args, 3, algolen, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 4, 32, msglen, algolen);\n     }\n \n-    /* NULL algo16 is disallowed */\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n-    /* Empty algo16 is fine */\n-    memset(algo16, 0x00, 16);\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n-    /* algo16 with terminating null bytes is fine */\n-    algo16[1] = 65;\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n-    /* Other algo16 is fine */\n-    memset(algo16, 0xFF, 16);\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* NULL algo is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, NULL, 0, NULL) == 0);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+    /* Other algo is fine */\n+    secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, algo, algolen);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+\n+    for (i = 0; i < count; i++) {\n+        unsigned char nonce2[32];\n+        uint32_t offset = secp256k1_testrand_int(msglen - 1);\n+        size_t msglen_tmp = (msglen + offset) % msglen;\n+        size_t algolen_tmp;\n+\n+        /* Different msglen gives different nonce */\n+        CHECK(nonce_function_bip340(nonce2, msg, msglen_tmp, key, pk, algo, algolen, NULL) == 1);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+\n+        /* Different algolen gives different nonce */\n+        offset = secp256k1_testrand_int(algolen - 1);\n+        algolen_tmp = (algolen + offset) % algolen;\n+        CHECK(nonce_function_bip340(nonce2, msg, msglen, key, pk, algo, algolen_tmp, NULL) == 1);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+    }\n \n     /* NULL aux_rand argument is allowed. */\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n }\n \n void test_schnorrsig_api(void) {\n@@ -103,10 +117,12 @@ void test_schnorrsig_api(void) {\n     unsigned char sk3[32];\n     unsigned char msg[32];\n     secp256k1_keypair keypairs[3];\n-    secp256k1_keypair invalid_keypair = { 0 };\n+    secp256k1_keypair invalid_keypair = {{ 0 }};\n     secp256k1_xonly_pubkey pk[3];\n     secp256k1_xonly_pubkey zero_pk;\n     unsigned char sig[64];\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+    secp256k1_schnorrsig_extraparams invalid_extraparams = {{ 0 }, NULL, NULL};\n \n     /** setup **/\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n@@ -138,36 +154,60 @@ void test_schnorrsig_api(void) {\n \n     /** main test body **/\n     ecount = 0;\n-    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL) == 0);\n+    CHECK(ecount == 6);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign_custom(none, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(vrfy, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, NULL, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, NULL, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 4);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, NULL, 0, &keypairs[0], &extraparams) == 1);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), NULL, &extraparams) == 0);\n     CHECK(ecount == 5);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &invalid_keypair, &extraparams) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], NULL) == 1);\n     CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], &invalid_extraparams) == 0);\n+    CHECK(ecount == 7);\n \n     ecount = 0;\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n     CHECK(ecount == 4);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n     CHECK(ecount == 5);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n     CHECK(ecount == 6);\n \n     secp256k1_context_destroy(none);\n@@ -179,7 +219,7 @@ void test_schnorrsig_api(void) {\n /* Checks that hash initialized by secp256k1_schnorrsig_sha256_tagged has the\n  * expected state. */\n void test_schnorrsig_sha256_tagged(void) {\n-    char tag[17] = \"BIP0340/challenge\";\n+    unsigned char tag[17] = \"BIP0340/challenge\";\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n \n@@ -190,19 +230,19 @@ void test_schnorrsig_sha256_tagged(void) {\n \n /* Helper function for schnorrsig_bip_vectors\n  * Signs the message and checks that it's the same as expected_sig. */\n-void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg, const unsigned char *expected_sig) {\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n     unsigned char sig[64];\n     secp256k1_keypair keypair;\n     secp256k1_xonly_pubkey pk, pk_expected;\n \n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg32, &keypair, aux_rand));\n     CHECK(secp256k1_memcmp_var(sig, expected_sig, 64) == 0);\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n     CHECK(secp256k1_memcmp_var(&pk, &pk_expected, sizeof(pk)) == 0);\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg32, 32, &pk));\n }\n \n /* Helper function for schnorrsig_bip_vectors\n@@ -211,7 +251,7 @@ void test_schnorrsig_bip_vectors_check_verify(const unsigned char *pk_serialized\n     secp256k1_xonly_pubkey pk;\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk, pk_serialized));\n-    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, 32, &pk));\n }\n \n /* Test vectors according to BIP-340 (\"Schnorr Signatures for secp256k1\"). See\n@@ -634,34 +674,40 @@ void test_schnorrsig_bip_vectors(void) {\n }\n \n /* Nonce function that returns constant 0 */\n-static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n     (void) nonce32;\n     return 0;\n }\n \n /* Nonce function that sets nonce to 0 */\n-static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n \n     memset(nonce32, 0, 32);\n     return 1;\n }\n \n /* Nonce function that sets nonce to 0xFF...0xFF */\n-static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n \n     memset(nonce32, 0xFF, 32);\n@@ -670,24 +716,45 @@ static int nonce_function_overflowing(unsigned char *nonce32, const unsigned cha\n \n void test_schnorrsig_sign(void) {\n     unsigned char sk[32];\n+    secp256k1_xonly_pubkey pk;\n     secp256k1_keypair keypair;\n     const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n     unsigned char sig[64];\n+    unsigned char sig2[64];\n     unsigned char zeros64[64] = { 0 };\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+    unsigned char aux_rand[32];\n \n     secp256k1_testrand256(sk);\n+    secp256k1_testrand256(aux_rand);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n \n     /* Test different nonce functions */\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n     memset(sig, 1, sizeof(sig));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n+    extraparams.noncefp = nonce_function_failing;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 0);\n     CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     memset(&sig, 1, sizeof(sig));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n+    extraparams.noncefp = nonce_function_0;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 0);\n     CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n-    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) != 0);\n+    memset(&sig, 1, sizeof(sig));\n+    extraparams.noncefp = nonce_function_overflowing;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n+\n+    /* When using the default nonce function, schnorrsig_sign_custom produces\n+     * the same result as schnorrsig_sign with aux_rand = extraparams.ndata */\n+    extraparams.noncefp = NULL;\n+    extraparams.ndata = aux_rand;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig2, msg, &keypair, extraparams.ndata) == 1);\n+    CHECK(secp256k1_memcmp_var(sig, sig2, sizeof(sig)) == 0);\n }\n \n #define N_SIGS 3\n@@ -709,8 +776,8 @@ void test_schnorrsig_sign_verify(void) {\n \n     for (i = 0; i < N_SIGS; i++) {\n         secp256k1_testrand256(msg[i]);\n-        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n-        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n+        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], sizeof(msg[i]), &pk));\n     }\n \n     {\n@@ -720,36 +787,54 @@ void test_schnorrsig_sign_verify(void) {\n         size_t byte_idx = secp256k1_testrand_int(32);\n         unsigned char xorbyte = secp256k1_testrand_int(254)+1;\n         sig[sig_idx][byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         sig[sig_idx][byte_idx] ^= xorbyte;\n \n         byte_idx = secp256k1_testrand_int(32);\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n \n         byte_idx = secp256k1_testrand_int(32);\n         msg[sig_idx][byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         msg[sig_idx][byte_idx] ^= xorbyte;\n \n         /* Check that above bitflips have been reversed correctly */\n-        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n     }\n \n     /* Test overflowing s */\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n     memset(&sig[0][32], 0xFF, 32);\n-    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n \n     /* Test negative s */\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n     secp256k1_scalar_set_b32(&s, &sig[0][32], NULL);\n     secp256k1_scalar_negate(&s, &s);\n     secp256k1_scalar_get_b32(&sig[0][32], &s);\n-    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n+\n+    /* The empty message can be signed & verified */\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig[0], NULL, 0, &keypair, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], NULL, 0, &pk) == 1);\n+\n+    {\n+        /* Test varying message lengths */\n+        unsigned char msg_large[32 * 8];\n+        uint32_t msglen  = secp256k1_testrand_int(sizeof(msg_large));\n+        for (i = 0; i < sizeof(msg_large); i += 32) {\n+            secp256k1_testrand256(&msg_large[i]);\n+        }\n+        CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig[0], msg_large, msglen, &keypair, NULL) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg_large, msglen, &pk) == 1);\n+        /* Verification for a random wrong message length fails */\n+        msglen = (msglen + (sizeof(msg_large) - 1)) % sizeof(msg_large);\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg_large, msglen, &pk) == 0);\n+    }\n }\n #undef N_SIGS\n \n@@ -777,10 +862,10 @@ void test_schnorrsig_taproot(void) {\n \n     /* Key spend */\n     secp256k1_testrand256(msg);\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL) == 1);\n     /* Verify key spend */\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &output_pk) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &output_pk) == 1);\n \n     /* Script spend */\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, internal_pk_bytes, &internal_pk) == 1);"
      },
      {
        "sha": "9908cab8642a5cdbf8819e227c5a80f734d4ec76",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 47,
        "deletions": 2,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -4,8 +4,10 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_preallocated.h\"\n+#define SECP256K1_BUILD\n+\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_preallocated.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -21,6 +23,10 @@\n #include \"scratch_impl.h\"\n #include \"selftest.h\"\n \n+#ifdef SECP256K1_NO_BUILD\n+# error \"secp256k1.h processed without SECP256K1_BUILD defined while building secp256k1.c\"\n+#endif\n+\n #if defined(VALGRIND)\n # include <valgrind/memcheck.h>\n #endif\n@@ -316,6 +322,32 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     return ret;\n }\n \n+int secp256k1_ec_pubkey_cmp(const secp256k1_context* ctx, const secp256k1_pubkey* pubkey0, const secp256k1_pubkey* pubkey1) {\n+    unsigned char out[2][33];\n+    const secp256k1_pubkey* pk[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    pk[0] = pubkey0; pk[1] = pubkey1;\n+    for (i = 0; i < 2; i++) {\n+        size_t out_size = sizeof(out[i]);\n+        /* If the public key is NULL or invalid, ec_pubkey_serialize will call\n+         * the illegal_callback and return 0. In that case we will serialize the\n+         * key as all zeros which is less than any valid public key. This\n+         * results in consistent comparisons even if NULL or invalid pubkeys are\n+         * involved and prevents edge cases such as sorting algorithms that use\n+         * this function and do not terminate as a result. */\n+        if (!secp256k1_ec_pubkey_serialize(ctx, out[i], &out_size, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            /* Note that ec_pubkey_serialize should already set the output to\n+             * zero in that case, but it's not guaranteed by the API, we can't\n+             * test it and writing a VERIFY_CHECK is more complex than\n+             * explicitly memsetting (again). */\n+            memset(out[i], 0, sizeof(out[i]));\n+        }\n+    }\n+    return secp256k1_memcmp_var(out[0], out[1], sizeof(out[0]));\n+}\n+\n static void secp256k1_ecdsa_signature_load(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_ecdsa_signature* sig) {\n     (void)ctx;\n     if (sizeof(secp256k1_scalar) == 32) {\n@@ -758,6 +790,19 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+int secp256k1_tagged_sha256(const secp256k1_context* ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen) {\n+    secp256k1_sha256 sha;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(hash32 != NULL);\n+    ARG_CHECK(tag != NULL);\n+    ARG_CHECK(msg != NULL);\n+\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n+    secp256k1_sha256_finalize(&sha, hash32);\n+    return 1;\n+}\n+\n #ifdef ENABLE_MODULE_ECDH\n # include \"modules/ecdh/main_impl.h\"\n #endif"
      },
      {
        "sha": "c8d30ef6a814bae98e77cc9e5ac35f4e2fe2492e",
        "filename": "src/testrand_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand_impl.h?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -127,7 +127,7 @@ static void secp256k1_testrand_init(const char* hexseed) {\n             pos++;\n         }\n     } else {\n-        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        FILE *frand = fopen(\"/dev/urandom\", \"rb\");\n         if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n             uint64_t t = time(NULL) * (uint64_t)1337;\n             fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");"
      },
      {
        "sha": "99d9468e2987cd9cc5cc4b701181bade0aa39ac5",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 172,
        "deletions": 10,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -15,8 +15,8 @@\n #include <time.h>\n \n #include \"secp256k1.c\"\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_preallocated.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n #include \"util.h\"\n \n@@ -30,8 +30,8 @@ void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)\n # endif\n #endif\n \n-#include \"contrib/lax_der_parsing.c\"\n-#include \"contrib/lax_der_privatekey_parsing.c\"\n+#include \"../contrib/lax_der_parsing.c\"\n+#include \"../contrib/lax_der_privatekey_parsing.c\"\n \n #include \"modinv32_impl.h\"\n #ifdef SECP256K1_WIDEMUL_INT128\n@@ -564,6 +564,38 @@ void run_rfc6979_hmac_sha256_tests(void) {\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n }\n \n+void run_tagged_sha256_tests(void) {\n+    int ecount = 0;\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    unsigned char tag[32] = { 0 };\n+    unsigned char msg[32] = { 0 };\n+    unsigned char hash32[32];\n+    unsigned char hash_expected[32] = {\n+        0x04, 0x7A, 0x5E, 0x17, 0xB5, 0x86, 0x47, 0xC1,\n+        0x3C, 0xC6, 0xEB, 0xC0, 0xAA, 0x58, 0x3B, 0x62,\n+        0xFB, 0x16, 0x43, 0x32, 0x68, 0x77, 0x40, 0x6C,\n+        0xE2, 0x76, 0x55, 0x9A, 0x3B, 0xDE, 0x55, 0xB3\n+    };\n+\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+\n+    /* API test */\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, sizeof(tag), msg, sizeof(msg)) == 1);\n+    CHECK(secp256k1_tagged_sha256(none, NULL, tag, sizeof(tag), msg, sizeof(msg)) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, NULL, 0, msg, sizeof(msg)) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, sizeof(tag), NULL, 0) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Static test vector */\n+    memcpy(tag, \"tag\", 3);\n+    memcpy(msg, \"msg\", 3);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, 3, msg, 3) == 1);\n+    CHECK(secp256k1_memcmp_var(hash32, hash_expected, sizeof(hash32)) == 0);\n+    secp256k1_context_destroy(none);\n+}\n+\n /***** RANDOM TESTS *****/\n \n void test_rand_bits(int rand32, int bits) {\n@@ -2508,6 +2540,70 @@ void run_field_misc(void) {\n     }\n }\n \n+void test_fe_mul(const secp256k1_fe* a, const secp256k1_fe* b, int use_sqr)\n+{\n+    secp256k1_fe c, an, bn;\n+    /* Variables in BE 32-byte format. */\n+    unsigned char a32[32], b32[32], c32[32];\n+    /* Variables in LE 16x uint16_t format. */\n+    uint16_t a16[16], b16[16], c16[16];\n+    /* Field modulus in LE 16x uint16_t format. */\n+    static const uint16_t m16[16] = {\n+        0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+    };\n+    uint16_t t16[32];\n+    int i;\n+\n+    /* Compute C = A * B in fe format. */\n+    c = *a;\n+    if (use_sqr) {\n+        secp256k1_fe_sqr(&c, &c);\n+    } else {\n+        secp256k1_fe_mul(&c, &c, b);\n+    }\n+\n+    /* Convert A, B, C into LE 16x uint16_t format. */\n+    an = *a;\n+    bn = *b;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_normalize_var(&an);\n+    secp256k1_fe_normalize_var(&bn);\n+    secp256k1_fe_get_b32(a32, &an);\n+    secp256k1_fe_get_b32(b32, &bn);\n+    secp256k1_fe_get_b32(c32, &c);\n+    for (i = 0; i < 16; ++i) {\n+        a16[i] = a32[31 - 2*i] + ((uint16_t)a32[30 - 2*i] << 8);\n+        b16[i] = b32[31 - 2*i] + ((uint16_t)b32[30 - 2*i] << 8);\n+        c16[i] = c32[31 - 2*i] + ((uint16_t)c32[30 - 2*i] << 8);\n+    }\n+    /* Compute T = A * B in LE 16x uint16_t format. */\n+    mulmod256(t16, a16, b16, m16);\n+    /* Compare */\n+    CHECK(secp256k1_memcmp_var(t16, c16, 32) == 0);\n+}\n+\n+void run_fe_mul(void) {\n+    int i;\n+    for (i = 0; i < 100 * count; ++i) {\n+        secp256k1_fe a, b, c, d;\n+        random_fe(&a);\n+        random_field_element_magnitude(&a);\n+        random_fe(&b);\n+        random_field_element_magnitude(&b);\n+        random_fe_test(&c);\n+        random_field_element_magnitude(&c);\n+        random_fe_test(&d);\n+        random_field_element_magnitude(&d);\n+        test_fe_mul(&a, &a, 1);\n+        test_fe_mul(&c, &c, 1);\n+        test_fe_mul(&a, &b, 0);\n+        test_fe_mul(&a, &c, 0);\n+        test_fe_mul(&c, &b, 0);\n+        test_fe_mul(&c, &d, 0);\n+    }\n+}\n+\n void run_sqr(void) {\n     secp256k1_fe x, s;\n \n@@ -2595,7 +2691,7 @@ void test_inverse_scalar(secp256k1_scalar* out, const secp256k1_scalar* x, int v\n {\n     secp256k1_scalar l, r, t;\n \n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&l, x);  /* l = 1/x */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&l, x);  /* l = 1/x */\n     if (out) *out = l;\n     if (secp256k1_scalar_is_zero(x)) {\n         CHECK(secp256k1_scalar_is_zero(&l));\n@@ -2605,9 +2701,9 @@ void test_inverse_scalar(secp256k1_scalar* out, const secp256k1_scalar* x, int v\n     CHECK(secp256k1_scalar_is_one(&t));                                          /* x*(1/x) == 1 */\n     secp256k1_scalar_add(&r, x, &scalar_minus_one);                              /* r = x-1 */\n     if (secp256k1_scalar_is_zero(&r)) return;\n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&r, &r); /* r = 1/(x-1) */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&r, &r); /* r = 1/(x-1) */\n     secp256k1_scalar_add(&l, &scalar_minus_one, &l);                             /* l = 1/x-1 */\n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&l, &l); /* l = 1/(1/x-1) */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&l, &l); /* l = 1/(1/x-1) */\n     secp256k1_scalar_add(&l, &l, &secp256k1_scalar_one);                         /* l = 1/(1/x-1)+1 */\n     secp256k1_scalar_add(&l, &r, &l);                                            /* l = 1/(1/x-1)+1 + 1/(x-1) */\n     CHECK(secp256k1_scalar_is_zero(&l));                                         /* l == 0 */\n@@ -3101,20 +3197,34 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n+        int odd;\n         random_group_element_test(&ge[i]);\n+        odd = secp256k1_fe_is_odd(&ge[i].x);\n+        CHECK(odd == 0 || odd == 1);\n         /* randomly set half the points to infinity */\n-        if(secp256k1_fe_is_odd(&ge[i].x)) {\n+        if (odd == i % 2) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n         secp256k1_gej_set_ge(&gej[i], &ge[i]);\n     }\n-    /* batch invert */\n+    /* batch convert */\n     secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n     /* check result */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         ge_equals_gej(&ge[i], &gej[i]);\n     }\n \n+    /* Test batch gej -> ge conversion with all infinities. */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        secp256k1_gej_set_infinity(&gej[i]);\n+    }\n+    /* batch convert */\n+    secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n+    /* check result */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        CHECK(secp256k1_ge_is_infinity(&ge[i]));\n+    }\n+\n     free(ge);\n     free(gej);\n }\n@@ -5434,6 +5544,55 @@ void test_random_pubkeys(void) {\n     }\n }\n \n+void run_pubkey_comparison(void) {\n+    unsigned char pk1_ser[33] = {\n+        0x02,\n+        0x58, 0x84, 0xb3, 0xa2, 0x4b, 0x97, 0x37, 0x88, 0x92, 0x38, 0xa6, 0x26, 0x62, 0x52, 0x35, 0x11,\n+        0xd0, 0x9a, 0xa1, 0x1b, 0x80, 0x0b, 0x5e, 0x93, 0x80, 0x26, 0x11, 0xef, 0x67, 0x4b, 0xd9, 0x23\n+    };\n+    const unsigned char pk2_ser[33] = {\n+        0x02,\n+        0xde, 0x36, 0x0e, 0x87, 0x59, 0x8f, 0x3c, 0x01, 0x36, 0x2a, 0x2a, 0xb8, 0xc6, 0xf4, 0x5e, 0x4d,\n+        0xb2, 0xc2, 0xd5, 0x03, 0xa7, 0xf9, 0xf1, 0x4f, 0xa8, 0xfa, 0x95, 0xa8, 0xe9, 0x69, 0x76, 0x1c\n+    };\n+    secp256k1_pubkey pk1;\n+    secp256k1_pubkey pk2;\n+    int32_t ecount = 0;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk1, pk1_ser, sizeof(pk1_ser)) == 1);\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk2, pk2_ser, sizeof(pk2_ser)) == 1);\n+\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, NULL, &pk2) < 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, NULL) > 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk1) > 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk1) == 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk2) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        secp256k1_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp)); /* illegal pubkey */\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk_tmp, &pk2) < 0);\n+        CHECK(ecount == 3);\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk_tmp, &pk_tmp) == 0);\n+        CHECK(ecount == 5);\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk_tmp) > 0);\n+        CHECK(ecount == 6);\n+    }\n+\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+\n+    /* Make pk2 the same as pk1 but with 3 rather than 2. Note that in\n+     * an uncompressed encoding, these would have the opposite ordering */\n+    pk1_ser[0] = 3;\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk2, pk1_ser, sizeof(pk1_ser)) == 1);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk1) > 0);\n+}\n+\n void run_random_pubkeys(void) {\n     int i;\n     for (i = 0; i < 10*count; i++) {\n@@ -6408,7 +6567,7 @@ int main(int argc, char **argv) {\n         count = strtol(argv[1], NULL, 0);\n     } else {\n         const char* env = getenv(\"SECP256K1_TEST_ITERS\");\n-        if (env) {\n+        if (env && strlen(env) > 0) {\n             count = strtol(env, NULL, 0);\n         }\n     }\n@@ -6442,13 +6601,15 @@ int main(int argc, char **argv) {\n     run_sha256_tests();\n     run_hmac_sha256_tests();\n     run_rfc6979_hmac_sha256_tests();\n+    run_tagged_sha256_tests();\n \n     /* scalar tests */\n     run_scalar_tests();\n \n     /* field tests */\n     run_field_misc();\n     run_field_convert();\n+    run_fe_mul();\n     run_sqr();\n     run_sqrt();\n \n@@ -6485,6 +6646,7 @@ int main(int argc, char **argv) {\n #endif\n \n     /* ecdsa tests */\n+    run_pubkey_comparison();\n     run_random_pubkeys();\n     run_ecdsa_der_parse();\n     run_ecdsa_sign_verify();"
      },
      {
        "sha": "5b9a3035d9a717e1d2a3f2846ce670ff3e9648b4",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -10,7 +10,6 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n-\n #include <time.h>\n \n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n@@ -20,10 +19,10 @@\n #define EXHAUSTIVE_TEST_ORDER 13\n #endif\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"group.h\"\n-#include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n static int count = 2;\n@@ -303,6 +302,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n             if (skip_section(&iter)) continue;\n             for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n                 const int starting_k = k;\n+                int ret;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -311,7 +311,8 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 secp256k1_scalar_get_b32(sk32, &sk);\n                 secp256k1_scalar_get_b32(msg32, &msg);\n \n-                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+                ret = secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+                CHECK(ret == 1);\n \n                 secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n                 /* Note that we compute expected_r *after* signing -- this is important"
      },
      {
        "sha": "ea6d4b3deb3bcbebf01cb8002b9281a5bc2955e3",
        "filename": "src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/valgrind_ctime_test.c?ref=c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "patch": "@@ -7,24 +7,24 @@\n #include <valgrind/memcheck.h>\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n \n #ifdef ENABLE_MODULE_ECDH\n-# include \"include/secp256k1_ecdh.h\"\n+# include \"../include/secp256k1_ecdh.h\"\n #endif\n \n #ifdef ENABLE_MODULE_RECOVERY\n-# include \"include/secp256k1_recovery.h\"\n+# include \"../include/secp256k1_recovery.h\"\n #endif\n \n #ifdef ENABLE_MODULE_EXTRAKEYS\n-# include \"include/secp256k1_extrakeys.h\"\n+# include \"../include/secp256k1_extrakeys.h\"\n #endif\n \n #ifdef ENABLE_MODULE_SCHNORRSIG\n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../include/secp256k1_schnorrsig.h\"\n #endif\n \n void run_tests(secp256k1_context *ctx, unsigned char *key);\n@@ -166,7 +166,7 @@ void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n-    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif"
      }
    ]
  },
  {
    "sha": "e4ffb44716bb7a7b9f0a5d70ac07058632234370",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNGZmYjQ0NzE2YmI3YTdiOWYwYTVkNzBhYzA3MDU4NjMyMjM0Mzcw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-14T17:02:02Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-14T21:43:45Z"
      },
      "message": "Update secp256k1 subtree to latest upstream + adapt API\n\nThe new schnorrsig API requires changing a few arguments.",
      "tree": {
        "sha": "b658b1afefbcbe30b42d819c59dd5172f64dc79b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b658b1afefbcbe30b42d819c59dd5172f64dc79b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e4ffb44716bb7a7b9f0a5d70ac07058632234370",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4ffb44716bb7a7b9f0a5d70ac07058632234370",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e4ffb44716bb7a7b9f0a5d70ac07058632234370",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4ffb44716bb7a7b9f0a5d70ac07058632234370/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "531c2b7c04898f5a2097f44e8c12bfb2f53aaf9b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/531c2b7c04898f5a2097f44e8c12bfb2f53aaf9b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/531c2b7c04898f5a2097f44e8c12bfb2f53aaf9b"
      },
      {
        "sha": "c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273"
      }
    ],
    "stats": {
      "total": 1591,
      "additions": 1224,
      "deletions": 367
    },
    "files": [
      {
        "sha": "7bef3d529b5f9e05674f76b7fed48d9d064ffe01",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -274,7 +274,7 @@ bool CKey::SignSchnorr(const uint256& hash, Span<unsigned char> sig, const uint2\n         uint256 tweak = XOnlyPubKey(pubkey_bytes).ComputeTapTweakHash(merkle_root->IsNull() ? nullptr : merkle_root);\n         if (!secp256k1_keypair_xonly_tweak_add(GetVerifyContext(), &keypair, tweak.data())) return false;\n     }\n-    bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, secp256k1_nonce_function_bip340, aux ? (void*)aux->data() : nullptr);\n+    bool ret = secp256k1_schnorrsig_sign(secp256k1_context_sign, sig.data(), hash.data(), &keypair, aux ? (unsigned char*)aux->data() : nullptr);\n     memory_cleanse(&keypair, sizeof(keypair));\n     return ret;\n }"
      },
      {
        "sha": "75202e7cf41e9b134691c3cf139fd58e5b6f17ac",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -191,7 +191,7 @@ bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> si\n     assert(sigbytes.size() == 64);\n     secp256k1_xonly_pubkey pubkey;\n     if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;\n-    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n+    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), 32, &pubkey);\n }\n \n static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");"
      },
      {
        "sha": "bf71a70839f59a3b3c67dbba0979843efb6bc6d9",
        "filename": "src/secp256k1/.cirrus.yml",
        "status": "modified",
        "additions": 173,
        "deletions": 29,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.cirrus.yml?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -1,21 +1,28 @@\n env:\n-  WIDEMUL: auto\n+  ### compiler options\n+  HOST:\n+  # Specific warnings can be disabled with -Wno-error=foo.\n+  # -pedantic-errors is not equivalent to -Werror=pedantic and thus not implied by -Werror according to the GCC manual.\n+  WERROR_CFLAGS: -Werror -pedantic-errors\n+  MAKEFLAGS: -j2\n+  BUILD: check\n+  ### secp256k1 config\n   STATICPRECOMPUTATION: yes\n   ECMULTGENPRECISION: auto\n   ASM: no\n-  BUILD: check\n+  WIDEMUL: auto\n   WITH_VALGRIND: yes\n-  RUN_VALGRIND: no\n   EXTRAFLAGS:\n-  HOST:\n+  ### secp256k1 modules\n+  EXPERIMENTAL: no\n   ECDH: no\n   RECOVERY: no\n   SCHNORRSIG: no\n-  EXPERIMENTAL: no\n-  CTIMETEST: yes\n+  ### test options\n+  TEST_ITERS:\n   BENCH: yes\n-  ITERS: 2\n-  MAKEFLAGS: -j2\n+  BENCH_ITERS: 2\n+  CTIMETEST: yes\n \n cat_logs_snippet: &CAT_LOGS\n   always:\n@@ -63,27 +70,8 @@ task:\n     - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n     - env: {CPPFLAGS: -DDETERMINISTIC}\n     - env: {CFLAGS: -O0, CTIMETEST: no}\n-    - env:\n-        CFLAGS:  \"-fsanitize=undefined -fno-omit-frame-pointer\"\n-        LDFLAGS: \"-fsanitize=undefined -fno-omit-frame-pointer\"\n-        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n-        ASM: x86_64\n-        ECDH: yes\n-        RECOVERY: yes\n-        EXPERIMENTAL: yes\n-        SCHNORRSIG: yes\n-        CTIMETEST: no\n     - env: { ECMULTGENPRECISION: 2 }\n     - env: { ECMULTGENPRECISION: 8 }\n-    - env:\n-        RUN_VALGRIND: yes\n-        ASM: x86_64\n-        ECDH: yes\n-        RECOVERY: yes\n-        EXPERIMENTAL: yes\n-        SCHNORRSIG: yes\n-        EXTRAFLAGS: \"--disable-openssl-tests\"\n-        BUILD:\n   matrix:\n     - env:\n         CC: gcc\n@@ -111,6 +99,7 @@ task:\n         CC: i686-linux-gnu-gcc\n     - env:\n         CC: clang --target=i686-pc-linux-gnu -isystem /usr/i686-linux-gnu/include\n+  << : *MERGE_BASE\n   test_script:\n     - ./ci/cirrus.sh\n   << : *CAT_LOGS\n@@ -181,9 +170,9 @@ task:\n     cpu: 1\n     memory: 1G\n   env:\n-    QEMU_CMD: qemu-s390x\n+    WRAPPER_CMD: qemu-s390x\n+    TEST_ITERS: 16\n     HOST: s390x-linux-gnu\n-    BUILD:\n     WITH_VALGRIND: no\n     ECDH: yes\n     RECOVERY: yes\n@@ -196,3 +185,158 @@ task:\n     - rm /etc/ld.so.cache\n     - ./ci/cirrus.sh\n   << : *CAT_LOGS\n+\n+task:\n+  name: \"ARM32: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-arm\n+    TEST_ITERS: 16\n+    HOST: arm-linux-gnueabihf\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  matrix:\n+    - env: {}\n+    - env: {ASM: arm}\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"ARM64: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-aarch64\n+    TEST_ITERS: 16\n+    HOST: aarch64-linux-gnu\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"ppc64le: Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: qemu-ppc64le\n+    TEST_ITERS: 16\n+    HOST: powerpc64le-linux-gnu\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"x86_64 (mingw32-w64): Windows (Debian stable, Wine)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    WRAPPER_CMD: wine64-stable\n+    TEST_ITERS: 16\n+    HOST: x86_64-w64-mingw32\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+# Sanitizers\n+task:\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+    EXTRAFLAGS: \"--disable-openssl-tests\"\n+  matrix:\n+    - name: \"Valgrind (memcheck)\"\n+      env:\n+        # The `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n+        WRAPPER_CMD: \"valgrind --error-exitcode=42\"\n+        TEST_ITERS: 16\n+    - name: \"UBSan, ASan, LSan\"\n+      env:\n+        CFLAGS: \"-fsanitize=undefined,address\"\n+        CFLAGS_FOR_BUILD: \"-fsanitize=undefined,address\"\n+        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n+        ASAN_OPTIONS: \"strict_string_checks=1:detect_stack_use_after_return=1:detect_leaks=1\"\n+        LSAN_OPTIONS: \"use_unaligned=1\"\n+        TEST_ITERS: 32\n+  # Try to cover many configurations with just a tiny matrix.\n+  matrix:\n+    - env:\n+        ASM: auto\n+        STATICPRECOMPUTATION: yes\n+    - env:\n+        ASM: no\n+        STATICPRECOMPUTATION: no\n+        ECMULTGENPRECISION: 2\n+  matrix:\n+    - env:\n+        CC: clang\n+    - env:\n+        HOST: i686-linux-gnu\n+        CC: i686-linux-gnu-gcc\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"C++ -fpermissive\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    # ./configure correctly errors out when given CC=g++.\n+    # We hack around this by passing CC=g++ only to make.\n+    CC: gcc\n+    MAKEFLAGS: -j2 CC=g++ CFLAGS=-fpermissive\n+    WERROR_CFLAGS:\n+    EXPERIMENTAL: yes\n+    ECDH: yes\n+    RECOVERY: yes\n+    SCHNORRSIG: yes\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS"
      },
      {
        "sha": "79b740db8ae3552dade638d75f0f343f8bc15a8c",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -23,6 +23,7 @@ aclocal.m4\n autom4te.cache/\n config.log\n config.status\n+conftest*\n *.tar.gz\n *.la\n libtool\n@@ -33,6 +34,14 @@ libtool\n *~\n *.log\n *.trs\n+\n+coverage/\n+coverage.html\n+coverage.*.html\n+*.gcda\n+*.gcno\n+*.gcov\n+\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h"
      },
      {
        "sha": "1e0356088433883d85a9884209e5c2d07fe01d5a",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -1,5 +1,9 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n+# AM_CFLAGS will be automatically prepended to CFLAGS by Automake when compiling some foo\n+# which does not have an explicit foo_CFLAGS variable set.\n+AM_CFLAGS = $(SECP_CFLAGS)\n+\n lib_LTLIBRARIES = libsecp256k1.la\n include_HEADERS = include/secp256k1.h\n include_HEADERS += include/secp256k1_preallocated.h\n@@ -68,7 +72,7 @@ endif\n endif\n \n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n libsecp256k1_la_LIBADD = $(SECP_LIBS) $(COMMON_LIB)\n \n if VALGRIND_ENABLED\n@@ -81,27 +85,27 @@ noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n # SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n-bench_verify_CPPFLAGS = -DSECP256K1_BUILD $(SECP_TEST_INCLUDES)\n+bench_verify_CPPFLAGS = $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n-bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n bench_ecmult_SOURCES = src/bench_ecmult.c\n bench_ecmult_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n-bench_ecmult_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n+bench_ecmult_CPPFLAGS = $(SECP_INCLUDES)\n endif\n \n TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n@@ -114,7 +118,7 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -I$(top_srcdir)/src $(SECP_INCLUDES)\n if !ENABLE_COVERAGE\n exhaustive_tests_CPPFLAGS += -DVERIFY\n endif\n@@ -129,10 +133,10 @@ CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n-\t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n+\t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n-\t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n+\t$(CC_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $^ -o $@\n \n $(libsecp256k1_la_OBJECTS): src/ecmult_static_context.h\n $(tests_OBJECTS): src/ecmult_static_context.h"
      },
      {
        "sha": "182c29d9ce5ef58e9c753b1d54b3c0b0a2b6bd6a",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -17,6 +17,7 @@ Features:\n * Suitable for embedded systems.\n * Optional module for public key recovery.\n * Optional module for ECDH key exchange.\n+* Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) (experimental).\n \n Experimental features have not received enough scrutiny to satisfy the standard of quality of this library but are made available for testing and review by the community. The APIs of these features should not be considered stable.\n \n@@ -96,7 +97,8 @@ To create a report, `gcovr` is recommended, as it includes branch coverage repor\n \n To create a HTML report with coloured and annotated source code:\n \n-    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage.html\n+    $ mkdir -p coverage\n+    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage/coverage.html\n \n Reporting a vulnerability\n ------------"
      },
      {
        "sha": "8245b2b8635200093b17ba856025f8b6e862cdda",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -82,3 +82,19 @@ if test x\"$has_valgrind\" != x\"yes\"; then\n   AC_CHECK_HEADER([valgrind/memcheck.h], [has_valgrind=yes; AC_DEFINE(HAVE_VALGRIND,1,[Define this symbol if valgrind is installed])])\n fi\n ])\n+\n+dnl SECP_TRY_APPEND_CFLAGS(flags, VAR)\n+dnl Append flags to VAR if CC accepts them.\n+AC_DEFUN([SECP_TRY_APPEND_CFLAGS], [\n+  AC_MSG_CHECKING([if ${CC} supports $1])\n+  SECP_TRY_APPEND_CFLAGS_saved_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$1 $CFLAGS\"\n+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])], [flag_works=yes], [flag_works=no])\n+  AC_MSG_RESULT($flag_works)\n+  CFLAGS=\"$SECP_TRY_APPEND_CFLAGS_saved_CFLAGS\"\n+  if test x\"$flag_works\" = x\"yes\"; then\n+    $2=\"$$2 $1\"\n+  fi\n+  unset flag_works\n+  AC_SUBST($2)\n+])"
      },
      {
        "sha": "27db1e6779fa621150ccd0c1c64c93f2a39f6317",
        "filename": "src/secp256k1/ci/cirrus.sh",
        "status": "modified",
        "additions": 9,
        "deletions": 24,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/cirrus.sh?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -25,42 +25,27 @@ valgrind --version || true\n make\n \n # Print information about binaries so that we can see that the architecture is correct\n-file *tests || true\n+file *tests* || true\n file bench_* || true\n file .libs/* || true\n \n-if [ -n \"$BUILD\" ]\n-then\n-    make \"$BUILD\"\n-fi\n+# This tells `make check` to wrap test invocations.\n+export LOG_COMPILER=\"$WRAPPER_CMD\"\n \n-if [ \"$RUN_VALGRIND\" = \"yes\" ]\n-then\n-    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n-    valgrind --error-exitcode=42 ./tests 16\n-    valgrind --error-exitcode=42 ./exhaustive_tests\n-fi\n+# This limits the iterations in the tests and benchmarks.\n+export SECP256K1_TEST_ITERS=\"$TEST_ITERS\"\n+export SECP256K1_BENCH_ITERS=\"$BENCH_ITERS\"\n \n-if [ -n \"$QEMU_CMD\" ]\n-then\n-    $QEMU_CMD ./tests 16\n-    $QEMU_CMD ./exhaustive_tests\n-fi\n+make \"$BUILD\"\n \n if [ \"$BENCH\" = \"yes\" ]\n then\n     # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n     EXEC='./libtool --mode=execute'\n-    if [ -n \"$QEMU_CMD\" ]\n-    then\n-       EXEC=\"$EXEC $QEMU_CMD\"\n-    fi\n-    if [ \"$RUN_VALGRIND\" = \"yes\" ]\n+    if [ -n \"$WRAPPER_CMD\" ]\n     then\n-        EXEC=\"$EXEC valgrind --error-exitcode=42\"\n+        EXEC=\"$EXEC $WRAPPER_CMD\"\n     fi\n-    # This limits the iterations in the benchmarks below to ITER iterations.\n-    export SECP256K1_BENCH_ITERS=\"$ITERS\"\n     {\n         $EXEC ./bench_ecmult\n         $EXEC ./bench_internal"
      },
      {
        "sha": "2c02ed69d03f8a9cbf6bfa38f8f1b77cb0bb3d21",
        "filename": "src/secp256k1/ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/linux-debian.Dockerfile?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -2,12 +2,24 @@ FROM debian:stable\n \n RUN dpkg --add-architecture i386\n RUN dpkg --add-architecture s390x\n+RUN dpkg --add-architecture armhf\n+RUN dpkg --add-architecture arm64\n+RUN dpkg --add-architecture ppc64el\n RUN apt-get update\n \n # dkpg-dev: to make pkg-config work in cross-builds\n+# llvm: for llvm-symbolizer, which is used by clang's UBSan for symbolized stack traces\n RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         git ca-certificates \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n-        gcc clang libc6-dbg \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 \\\n-        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x\n+        gcc clang llvm libc6-dbg \\\n+        g++ \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n+        gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n+        gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\\n+        gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross libc6-dbg:ppc64el \\\n+        wine gcc-mingw-w64-x86-64\n+\n+# Run a dummy command in wine to make it set up configuration\n+RUN wine64-stable xcopy || true"
      },
      {
        "sha": "9969cfa343226f06cdb8899929fb3a96929332ee",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 62,
        "deletions": 58,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -8,10 +8,6 @@ AH_TOP([#define LIBSECP256K1_CONFIG_H])\n AH_BOTTOM([#endif /*LIBSECP256K1_CONFIG_H*/])\n AM_INIT_AUTOMAKE([foreign subdir-objects])\n \n-# Set -g if CFLAGS are not already set, which matches the default autoconf\n-# behavior (see PROG_CC in the Autoconf manual) with the exception that we don't\n-# set -O2 here because we set it in any case (see further down).\n-: ${CFLAGS=\"-g\"}\n LT_INIT\n \n # Make the compilation flags quiet unless V=1 is used.\n@@ -42,8 +38,8 @@ AM_PROG_AS\n case $host_os in\n   *darwin*)\n      if  test x$cross_compiling != xyes; then\n-       AC_PATH_PROG([BREW],brew,)\n-       if test x$BREW != x; then\n+       AC_CHECK_PROG([BREW], brew, brew)\n+       if test x$BREW = xbrew; then\n          # These Homebrew packages may be keg-only, meaning that they won't be found\n          # in expected paths because they may conflict with system files. Ask\n          # Homebrew where each one is located, then adjust paths accordingly.\n@@ -58,10 +54,10 @@ case $host_os in\n            VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n        else\n-         AC_PATH_PROG([PORT],port,)\n+         AC_CHECK_PROG([PORT], port, port)\n          # If homebrew isn't installed and macports is, add the macports default paths\n          # as a last resort.\n-         if test x$PORT != x; then\n+         if test x$PORT = xport; then\n            CPPFLAGS=\"$CPPFLAGS -isystem /opt/local/include\"\n            LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n          fi\n@@ -70,35 +66,41 @@ case $host_os in\n    ;;\n esac\n \n-CFLAGS=\"-W $CFLAGS\"\n-\n-warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n-\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"-Wconditional-uninitialized $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports -Wconditional-uninitialized])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n-\n-saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n-AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-    [ AC_MSG_RESULT([yes]) ],\n-    [ AC_MSG_RESULT([no])\n-      CFLAGS=\"$saved_CFLAGS\"\n-    ])\n+# Try if some desirable compiler flags are supported and append them to SECP_CFLAGS.\n+#\n+# These are our own flags, so we append them to our own SECP_CFLAGS variable (instead of CFLAGS) as\n+# recommended in the automake manual (Section \"Flag Variables Ordering\"). CFLAGS belongs to the user\n+# and we are not supposed to touch it. In the Makefile, we will need to ensure that SECP_CFLAGS\n+# is prepended to CFLAGS when invoking the compiler so that the user always has the last word (flag).\n+#\n+# Another advantage of not touching CFLAGS is that the contents of CFLAGS will be picked up by\n+# libtool for compiling helper executables. For example, when compiling for Windows, libtool will\n+# generate entire wrapper executables (instead of simple wrapper scripts as on Unix) to ensure\n+# proper operation of uninstalled programs linked by libtool against the uninstalled shared library.\n+# These executables are compiled from C source file for which our flags may not be appropriate,\n+# e.g., -std=c89 flag has lead to undesirable warnings in the past.\n+#\n+# TODO We should analogously not touch CPPFLAGS and LDFLAGS but currently there are no issues.\n+AC_DEFUN([SECP_TRY_APPEND_DEFAULT_CFLAGS], [\n+    # Try to append -Werror=unknown-warning-option to CFLAGS temporarily. Otherwise clang will\n+    # not error out if it gets unknown warning flags and the checks here will always succeed\n+    # no matter if clang knows the flag or not.\n+    SECP_TRY_APPEND_DEFAULT_CFLAGS_saved_CFLAGS=\"$CFLAGS\"\n+    SECP_TRY_APPEND_CFLAGS([-Werror=unknown-warning-option], CFLAGS)\n+\n+    SECP_TRY_APPEND_CFLAGS([-std=c89 -pedantic -Wno-long-long -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef], $1) # GCC >= 3.0, -Wlong-long is implied by -pedantic.\n+    SECP_TRY_APPEND_CFLAGS([-Wno-overlength-strings], $1) # GCC >= 4.2, -Woverlength-strings is implied by -pedantic.\n+    SECP_TRY_APPEND_CFLAGS([-Wall], $1) # GCC >= 2.95 and probably many other compilers\n+    SECP_TRY_APPEND_CFLAGS([-Wno-unused-function], $1) # GCC >= 3.0, -Wunused-function is implied by -Wall.\n+    SECP_TRY_APPEND_CFLAGS([-Wextra], $1) # GCC >= 3.4, this is the newer name of -W, which we don't use because older GCCs will warn about unused functions.\n+    SECP_TRY_APPEND_CFLAGS([-Wcast-align], $1) # GCC >= 2.95\n+    SECP_TRY_APPEND_CFLAGS([-Wcast-align=strict], $1) # GCC >= 8.0\n+    SECP_TRY_APPEND_CFLAGS([-Wconditional-uninitialized], $1) # Clang >= 3.0 only\n+    SECP_TRY_APPEND_CFLAGS([-fvisibility=hidden], $1) # GCC >= 4.0\n+\n+    CFLAGS=\"$SECP_TRY_APPEND_DEFAULT_CFLAGS_saved_CFLAGS\"\n+])\n+SECP_TRY_APPEND_DEFAULT_CFLAGS(SECP_CFLAGS)\n \n ###\n ### Define config arguments\n@@ -213,10 +215,14 @@ AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n-    CFLAGS=\"-O0 --coverage $CFLAGS\"\n+    SECP_CFLAGS=\"-O0 --coverage $SECP_CFLAGS\"\n     LDFLAGS=\"--coverage $LDFLAGS\"\n else\n-    CFLAGS=\"-O2 $CFLAGS\"\n+    # Most likely the CFLAGS already contain -O2 because that is autoconf's default.\n+    # We still add it here because passing it twice is not an issue, and handling\n+    # this case would just add unnecessary complexity (see #896).\n+    SECP_CFLAGS=\"-O2 $SECP_CFLAGS\"\n+    SECP_CFLAGS_FOR_BUILD=\"-O2 $SECP_CFLAGS_FOR_BUILD\"\n fi\n \n if test x\"$req_asm\" = x\"auto\"; then\n@@ -351,6 +357,9 @@ if test x\"$enable_valgrind\" = x\"yes\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n fi\n \n+# Add -Werror and similar flags passed from the outside (for testing, e.g., in CI)\n+SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n+\n # Handle static precomputation (after everything which modifies CFLAGS and friends)\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   if test x\"$cross_compiling\" = x\"no\"; then\n@@ -360,8 +369,9 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n     fi\n     # If we're not cross-compiling, simply use the same compiler for building the static precompation code.\n     CC_FOR_BUILD=\"$CC\"\n-    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n     CPPFLAGS_FOR_BUILD=\"$CPPFLAGS\"\n+    SECP_CFLAGS_FOR_BUILD=\"$SECP_CFLAGS\"\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n     LDFLAGS_FOR_BUILD=\"$LDFLAGS\"\n   else\n     AX_PROG_CC_FOR_BUILD\n@@ -371,42 +381,32 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n     cross_compiling=no\n     SAVE_CC=\"$CC\"\n     CC=\"$CC_FOR_BUILD\"\n-    SAVE_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n     SAVE_CPPFLAGS=\"$CPPFLAGS\"\n     CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+    SAVE_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n     SAVE_LDFLAGS=\"$LDFLAGS\"\n     LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n \n-    warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n-    saved_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n-    AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n-    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-        [ AC_MSG_RESULT([yes]) ],\n-        [ AC_MSG_RESULT([no])\n-          CFLAGS=\"$saved_CFLAGS\"\n-        ])\n+    SECP_TRY_APPEND_DEFAULT_CFLAGS(SECP_CFLAGS_FOR_BUILD)\n \n     AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n     AC_RUN_IFELSE(\n       [AC_LANG_PROGRAM([], [])],\n       [working_native_cc=yes],\n       [working_native_cc=no],[:])\n \n-    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n-\n     # Restore the environment\n     cross_compiling=$save_cross_compiling\n     CC=\"$SAVE_CC\"\n-    CFLAGS=\"$SAVE_CFLAGS\"\n     CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+    CFLAGS=\"$SAVE_CFLAGS\"\n     LDFLAGS=\"$SAVE_LDFLAGS\"\n \n     if test x\"$working_native_cc\" = x\"no\"; then\n       AC_MSG_RESULT([no])\n       set_precomp=no\n-      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n+      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CPPFLAGS_FOR_BUILD, CFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n       if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n         AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n       else\n@@ -419,8 +419,9 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   fi\n \n   AC_SUBST(CC_FOR_BUILD)\n-  AC_SUBST(CFLAGS_FOR_BUILD)\n   AC_SUBST(CPPFLAGS_FOR_BUILD)\n+  AC_SUBST(SECP_CFLAGS_FOR_BUILD)\n+  AC_SUBST(CFLAGS_FOR_BUILD)\n   AC_SUBST(LDFLAGS_FOR_BUILD)\n else\n   set_precomp=no\n@@ -490,6 +491,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AC_SUBST(SECP_CFLAGS)\n AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n@@ -532,13 +534,15 @@ fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\"\n-echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  SECP_CFLAGS             = $SECP_CFLAGS\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  LDFLAGS                 = $LDFLAGS\"\n echo\n if test x\"$set_precomp\" = x\"yes\"; then\n echo \"  CC_FOR_BUILD            = $CC_FOR_BUILD\"\n-echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n echo \"  CPPFLAGS_FOR_BUILD      = $CPPFLAGS_FOR_BUILD\"\n+echo \"  SECP_CFLAGS_FOR_BUILD   = $SECP_CFLAGS_FOR_BUILD\"\n+echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n echo \"  LDFLAGS_FOR_BUILD       = $LDFLAGS_FOR_BUILD\"\n fi"
      },
      {
        "sha": "bf562303edd9b11ad499fd6c9e4cbdbfc441a8c9",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -5,7 +5,6 @@\n  ***********************************************************************/\n \n #include <string.h>\n-#include <secp256k1.h>\n \n #include \"lax_der_parsing.h\"\n \n@@ -121,7 +120,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     /* Copy R value */\n     if (rlen > 32) {\n         overflow = 1;\n-    } else {\n+    } else if (rlen) {\n         memcpy(tmpsig + 32 - rlen, input + rpos, rlen);\n     }\n \n@@ -133,7 +132,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     /* Copy S value */\n     if (slen > 32) {\n         overflow = 1;\n-    } else {\n+    } else if (slen) {\n         memcpy(tmpsig + 64 - slen, input + spos, slen);\n     }\n "
      },
      {
        "sha": "034a38e6a0e1d0fb303c78bb9fd0ac20ecd44358",
        "filename": "src/secp256k1/contrib/lax_der_parsing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -51,7 +51,13 @@\n #ifndef SECP256K1_CONTRIB_LAX_DER_PARSING_H\n #define SECP256K1_CONTRIB_LAX_DER_PARSING_H\n \n+/* #include secp256k1.h only when it hasn't been included yet.\n+   This enables this file to be #included directly in other project\n+   files (such as tests.c) without the need to set an explicit -I flag,\n+   which would be necessary to locate secp256k1.h. */\n+#ifndef SECP256K1_H\n #include <secp256k1.h>\n+#endif\n \n #ifdef __cplusplus\n extern \"C\" {"
      },
      {
        "sha": "a1b8200079e144468d226d203b441bf86c695070",
        "filename": "src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_privatekey_parsing.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -5,7 +5,6 @@\n  ***********************************************************************/\n \n #include <string.h>\n-#include <secp256k1.h>\n \n #include \"lax_der_privatekey_parsing.h\"\n \n@@ -45,7 +44,7 @@ int ec_privkey_import_der(const secp256k1_context* ctx, unsigned char *out32, co\n     if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1]) {\n         return 0;\n     }\n-    memcpy(out32 + 32 - privkey[1], privkey + 2, privkey[1]);\n+    if (privkey[1]) memcpy(out32 + 32 - privkey[1], privkey + 2, privkey[1]);\n     if (!secp256k1_ec_seckey_verify(ctx, out32)) {\n         memset(out32, 0, 32);\n         return 0;"
      },
      {
        "sha": "1a8ad8ae0c3b0835d19c4c7cc7df519557a1c33d",
        "filename": "src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_privatekey_parsing.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -28,7 +28,13 @@\n #ifndef SECP256K1_CONTRIB_BER_PRIVATEKEY_H\n #define SECP256K1_CONTRIB_BER_PRIVATEKEY_H\n \n+/* #include secp256k1.h only when it hasn't been included yet.\n+   This enables this file to be #included directly in other project\n+   files (such as tests.c) without the need to set an explicit -I flag,\n+   which would be necessary to locate secp256k1.h. */\n+#ifndef SECP256K1_H\n #include <secp256k1.h>\n+#endif\n \n #ifdef __cplusplus\n extern \"C\" {"
      },
      {
        "sha": "7be7fd57233af86a6ce1a3fdc6cf1a076a425f82",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 57,
        "deletions": 3,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,7 +7,9 @@ extern \"C\" {\n \n #include <stddef.h>\n \n-/* These rules specify the order of arguments in API calls:\n+/* Unless explicitly stated all pointer arguments must not be NULL.\n+ *\n+ * The following rules specify the order of arguments in API calls:\n  *\n  * 1. Context pointers go first, followed by output arguments, combined\n  *    output/input arguments, and finally input-only arguments.\n@@ -61,8 +63,9 @@ typedef struct secp256k1_scratch_space_struct secp256k1_scratch_space;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage, transmission, or\n- *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n+ *  If you need to convert to a format suitable for storage or transmission,\n+ *  use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse. To\n+ *  compare keys, use secp256k1_ec_pubkey_cmp.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -127,6 +130,17 @@ typedef int (*secp256k1_nonce_function)(\n #  define SECP256K1_INLINE inline\n # endif\n \n+/** When this header is used at build-time the SECP256K1_BUILD define needs to be set\n+ *  to correctly setup export attributes and nullness checks.  This is normally done\n+ *  by secp256k1.c but to guard against this header being included before secp256k1.c\n+ *  has had a chance to set the define (e.g. via test harnesses that just includes\n+ *  secp256k1.c) we set SECP256K1_NO_BUILD when this header is processed without the\n+ *  BUILD define so this condition can be caught.\n+ */\n+#ifndef SECP256K1_BUILD\n+# define SECP256K1_NO_BUILD\n+#endif\n+\n #ifndef SECP256K1_API\n # if defined(_WIN32)\n #  ifdef SECP256K1_BUILD\n@@ -370,6 +384,21 @@ SECP256K1_API int secp256k1_ec_pubkey_serialize(\n     unsigned int flags\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Compare two public keys using lexicographic (of compressed serialization) order\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_cmp(\n+    const secp256k1_context* ctx,\n+    const secp256k1_pubkey* pubkey1,\n+    const secp256k1_pubkey* pubkey2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Parse an ECDSA signature in compact (64 bytes) format.\n  *\n  *  Returns: 1 when the signature could be parsed, 0 otherwise.\n@@ -764,6 +793,31 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compute a tagged hash as defined in BIP-340.\n+ *\n+ *  This is useful for creating a message hash and achieving domain separation\n+ *  through an application-specific tag. This function returns\n+ *  SHA256(SHA256(tag)||SHA256(tag)||msg). Therefore, tagged hash\n+ *  implementations optimized for a specific tag can precompute the SHA256 state\n+ *  after hashing the tag hashes.\n+ *\n+ *  Returns 0 if the arguments are invalid and 1 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:  hash32: pointer to a 32-byte array to store the resulting hash\n+ *  In:      tag: pointer to an array containing the tag\n+ *        taglen: length of the tag array\n+ *           msg: pointer to an array containing the message\n+ *        msglen: length of the message array\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_tagged_sha256(\n+    const secp256k1_context* ctx,\n+    unsigned char *hash32,\n+    const unsigned char *tag,\n+    size_t taglen,\n+    const unsigned char *msg,\n+    size_t msglen\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n #ifdef __cplusplus\n }\n #endif"
      },
      {
        "sha": "0a37fb6b9d31809fed5e674c2e035d80ea2db7d8",
        "filename": "src/secp256k1/include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 18,
        "deletions": 3,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_extrakeys.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -15,9 +15,9 @@ extern \"C\" {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage, transmission, or\n- *  comparison, use secp256k1_xonly_pubkey_serialize and\n- *  secp256k1_xonly_pubkey_parse.\n+ *  If you need to convert to a format suitable for storage, transmission, use\n+ *  use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse. To\n+ *  compare keys, use secp256k1_xonly_pubkey_cmp.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -67,6 +67,21 @@ SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_xonly_pubkey* pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Compare two x-only public keys using lexicographic order\n+ *\n+ *  Returns: <0 if the first public key is less than the second\n+ *           >0 if the first public key is greater than the second\n+ *           0 if the two public keys are equal\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  In:   pubkey1:  first public key to compare\n+ *        pubkey2:  second public key to compare\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n+    const secp256k1_context* ctx,\n+    const secp256k1_xonly_pubkey* pk1,\n+    const secp256k1_xonly_pubkey* pk2\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n  *\n  *  Returns: 1 if the public key was successfully converted"
      },
      {
        "sha": "74cbcac45ec033aac3509fe718f8d60dc8a3fdf7",
        "filename": "src/secp256k1/include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 87,
        "deletions": 28,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorrsig.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -23,24 +23,29 @@ extern \"C\" {\n  *\n  *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n  *           return an error.\n- *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n- *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n- *           key32:     pointer to a 32-byte secret key (will not be NULL)\n- *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n- *                      (will not be NULL)\n- *           algo16:    pointer to a 16-byte array describing the signature\n- *                      algorithm (will not be NULL).\n- *           data:      Arbitrary data pointer that is passed through.\n+ *  Out:  nonce32: pointer to a 32-byte array to be filled by the function\n+ *  In:       msg: the message being verified. Is NULL if and only if msglen\n+ *                 is 0.\n+ *         msglen: the length of the message\n+ *          key32: pointer to a 32-byte secret key (will not be NULL)\n+ *     xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32\n+ *                 (will not be NULL)\n+ *           algo: pointer to an array describing the signature\n+ *                 algorithm (will not be NULL)\n+ *        algolen: the length of the algo array\n+ *           data: arbitrary data pointer that is passed through\n  *\n  *  Except for test cases, this function should compute some cryptographic hash of\n  *  the message, the key, the pubkey, the algorithm description, and data.\n  */\n typedef int (*secp256k1_nonce_function_hardened)(\n     unsigned char *nonce32,\n-    const unsigned char *msg32,\n+    const unsigned char *msg,\n+    size_t msglen,\n     const unsigned char *key32,\n     const unsigned char *xonly_pk32,\n-    const unsigned char *algo16,\n+    const unsigned char *algo,\n+    size_t algolen,\n     void *data\n );\n \n@@ -50,59 +55,113 @@ typedef int (*secp256k1_nonce_function_hardened)(\n  *\n  *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n  *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n- *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n- *  argument must be non-NULL, otherwise the function will fail and return 0.\n- *  The hash will be tagged with algo16 after removing all terminating null\n- *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n- *  to \"BIP0340/nonce\\0\\0\\0\"\n+ *  the nonce derivation procedure follows BIP-340 by setting the auxiliary\n+ *  random data to zero. The algo argument must be non-NULL, otherwise the\n+ *  function will fail and return 0. The hash will be tagged with algo.\n+ *  Therefore, to create BIP-340 compliant signatures, algo must be set to\n+ *  \"BIP0340/nonce\" and algolen to 13.\n  */\n SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n \n+/** Data structure that contains additional arguments for schnorrsig_sign_custom.\n+ *\n+ *  A schnorrsig_extraparams structure object can be initialized correctly by\n+ *  setting it to SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT.\n+ *\n+ *  Members:\n+ *      magic: set to SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC at initialization\n+ *             and has no other function than making sure the object is\n+ *             initialized.\n+ *    noncefp: pointer to a nonce generation function. If NULL,\n+ *             secp256k1_nonce_function_bip340 is used\n+ *      ndata: pointer to arbitrary data used by the nonce generation function\n+ *             (can be NULL). If it is non-NULL and\n+ *             secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *             pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+typedef struct {\n+    unsigned char magic[4];\n+    secp256k1_nonce_function_hardened noncefp;\n+    void* ndata;\n+} secp256k1_schnorrsig_extraparams;\n+\n+#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC { 0xda, 0x6f, 0xb3, 0x8c }\n+#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT {\\\n+    SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC,\\\n+    NULL,\\\n+    NULL\\\n+}\n+\n /** Create a Schnorr signature.\n  *\n  *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n  *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n  *  abort if it fails.\n  *\n- *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n- *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n- *  randomness.\n+ *  This function only signs 32-byte messages. If you have messages of a\n+ *  different size (or the same size but without a context-specific tag\n+ *  prefix), it is recommended to create a 32-byte message hash with\n+ *  secp256k1_tagged_sha256 and then sign the hash. Tagged hashing allows\n+ *  providing an context-specific tag for domain separation. This prevents\n+ *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n  *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n  *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n  *       keypair: pointer to an initialized keypair (cannot be NULL)\n- *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n- *         ndata: pointer to arbitrary data used by the nonce generation\n- *                function (can be NULL). If it is non-NULL and\n- *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n- *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n+ *                this, it is only supplemental to security and can be NULL. See\n+ *                BIP-340 \"Default Signing\" for a full explanation of this\n+ *                argument and for guidance if randomness is expensive.\n  */\n SECP256K1_API int secp256k1_schnorrsig_sign(\n     const secp256k1_context* ctx,\n     unsigned char *sig64,\n     const unsigned char *msg32,\n     const secp256k1_keypair *keypair,\n-    secp256k1_nonce_function_hardened noncefp,\n-    void *ndata\n+    unsigned char *aux_rand32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Create a Schnorr signature with a more flexible API.\n+ *\n+ *  Same arguments as secp256k1_schnorrsig_sign except that it allows signing\n+ *  variable length messages and accepts a pointer to an extraparams object that\n+ *  allows customizing signing by passing additional arguments.\n+ *\n+ *  Creates the same signatures as schnorrsig_sign if msglen is 32 and the\n+ *  extraparams.ndata is the same as aux_rand32.\n+ *\n+ *  In:     msg: the message being signed. Can only be NULL if msglen is 0.\n+ *       msglen: length of the message\n+ *  extraparams: pointer to a extraparams object (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg,\n+    size_t msglen,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_schnorrsig_extraparams *extraparams\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(5);\n+\n /** Verify a Schnorr signature.\n  *\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n  *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n- *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *           msg: the message being verified. Can only be NULL if msglen is 0.\n+ *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n     const secp256k1_context* ctx,\n     const unsigned char *sig64,\n-    const unsigned char *msg32,\n+    const unsigned char *msg,\n+    size_t msglen,\n     const secp256k1_xonly_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(5);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/secp256k1/obj/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/531c2b7c04898f5a2097f44e8c12bfb2f53aaf9b/src/secp256k1/obj/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/531c2b7c04898f5a2097f44e8c12bfb2f53aaf9b/src/secp256k1/obj/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/obj/.gitignore?ref=531c2b7c04898f5a2097f44e8c12bfb2f53aaf9b"
      },
      {
        "sha": "cb020d26b4d9969cb54c5e4a9c5476bd70090f04",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -6,8 +6,8 @@\n \n #include <string.h>\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_ecdh.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_ecdh.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "1d463f92d0beeaa15732c7a901c524714d148335",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 189,
        "deletions": 35,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -5,7 +5,8 @@\n  ***********************************************************************/\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n \n #include \"util.h\"\n #include \"hash_impl.h\"\n@@ -14,33 +15,177 @@\n #include \"scalar_impl.h\"\n #include \"ecmult_impl.h\"\n #include \"bench.h\"\n-#include \"secp256k1.c\"\n \n #define POINTS 32768\n \n+void help(char **argv) {\n+    printf(\"Benchmark EC multiplication algorithms\\n\");\n+    printf(\"\\n\");\n+    printf(\"Usage: %s <help|pippenger_wnaf|strauss_wnaf|simple>\\n\", argv[0]);\n+    printf(\"The output shows the number of multiplied and summed points right after the\\n\");\n+    printf(\"function name. The letter 'g' indicates that one of the points is the generator.\\n\");\n+    printf(\"The benchmarks are divided by the number of points.\\n\");\n+    printf(\"\\n\");\n+    printf(\"default (ecmult_multi): picks pippenger_wnaf or strauss_wnaf depending on the\\n\");\n+    printf(\"                        batch size\\n\");\n+    printf(\"pippenger_wnaf:         for all batch sizes\\n\");\n+    printf(\"strauss_wnaf:           for all batch sizes\\n\");\n+    printf(\"simple:                 multiply and sum each point individually\\n\");\n+}\n+\n typedef struct {\n     /* Setup once in advance */\n     secp256k1_context* ctx;\n     secp256k1_scratch_space* scratch;\n     secp256k1_scalar* scalars;\n     secp256k1_ge* pubkeys;\n+    secp256k1_gej* pubkeys_gej;\n     secp256k1_scalar* seckeys;\n     secp256k1_gej* expected_output;\n     secp256k1_ecmult_multi_func ecmult_multi;\n \n-    /* Changes per test */\n+    /* Changes per benchmark */\n     size_t count;\n     int includes_g;\n \n-    /* Changes per test iteration */\n+    /* Changes per benchmark iteration, used to pick different scalars and pubkeys\n+     * in each run. */\n     size_t offset1;\n     size_t offset2;\n \n-    /* Test output. */\n+    /* Benchmark output. */\n     secp256k1_gej* output;\n } bench_data;\n \n-static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n+/* Hashes x into [0, POINTS) twice and store the result in offset1 and offset2. */\n+static void hash_into_offset(bench_data* data, size_t x) {\n+    data->offset1 = (x * 0x537b7f6f + 0x8f66a481) % POINTS;\n+    data->offset2 = (x * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+}\n+\n+/* Check correctness of the benchmark by computing\n+ * sum(outputs) ?= (sum(scalars_gen) + sum(seckeys)*sum(scalars))*G */\n+static void bench_ecmult_teardown_helper(bench_data* data, size_t* seckey_offset, size_t* scalar_offset, size_t* scalar_gen_offset, int iters) {\n+    int i;\n+    secp256k1_gej sum_output, tmp;\n+    secp256k1_scalar sum_scalars;\n+\n+    secp256k1_gej_set_infinity(&sum_output);\n+    secp256k1_scalar_clear(&sum_scalars);\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_gej_add_var(&sum_output, &sum_output, &data->output[i], NULL);\n+        if (scalar_gen_offset != NULL) {\n+            secp256k1_scalar_add(&sum_scalars, &sum_scalars, &data->scalars[(*scalar_gen_offset+i) % POINTS]);\n+        }\n+        if (seckey_offset != NULL) {\n+            secp256k1_scalar s = data->seckeys[(*seckey_offset+i) % POINTS];\n+            secp256k1_scalar_mul(&s, &s, &data->scalars[(*scalar_offset+i) % POINTS]);\n+            secp256k1_scalar_add(&sum_scalars, &sum_scalars, &s);\n+        }\n+    }\n+    secp256k1_ecmult_gen(&data->ctx->ecmult_gen_ctx, &tmp, &sum_scalars);\n+    secp256k1_gej_neg(&tmp, &tmp);\n+    secp256k1_gej_add_var(&tmp, &tmp, &sum_output, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&tmp));\n+}\n+\n+static void bench_ecmult_setup(void* arg) {\n+    bench_data* data = (bench_data*)arg;\n+    /* Re-randomize offset to ensure that we're using different scalars and\n+     * group elements in each run. */\n+    hash_into_offset(data, data->offset1);\n+}\n+\n+static void bench_ecmult_gen(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult_gen(&data->ctx->ecmult_gen_ctx, &data->output[i], &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_gen_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n+}\n+\n+static void bench_ecmult_const(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult_const(&data->output[i], &data->pubkeys[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], 256);\n+    }\n+}\n+\n+static void bench_ecmult_const_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n+}\n+\n+static void bench_ecmult_1(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+    }\n+}\n+\n+static void bench_ecmult_1_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, NULL, iters);\n+}\n+\n+static void bench_ecmult_1g(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    secp256k1_scalar zero;\n+    int i;\n+\n+    secp256k1_scalar_set_int(&zero, 0);\n+    for (i = 0; i < iters; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_1g_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, NULL, NULL, &data->offset1, iters);\n+}\n+\n+static void bench_ecmult_2g(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    int i;\n+\n+    for (i = 0; i < iters/2; ++i) {\n+        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+    }\n+}\n+\n+static void bench_ecmult_2g_teardown(void* arg, int iters) {\n+    bench_data* data = (bench_data*)arg;\n+    bench_ecmult_teardown_helper(data, &data->offset1, &data->offset2, &data->offset1, iters/2);\n+}\n+\n+static void run_ecmult_bench(bench_data* data, int iters) {\n+    char str[32];\n+    sprintf(str, \"ecmult_gen\");\n+    run_benchmark(str, bench_ecmult_gen, bench_ecmult_setup, bench_ecmult_gen_teardown, data, 10, iters);\n+    sprintf(str, \"ecmult_const\");\n+    run_benchmark(str, bench_ecmult_const, bench_ecmult_setup, bench_ecmult_const_teardown, data, 10, iters);\n+    /* ecmult with non generator point */\n+    sprintf(str, \"ecmult 1\");\n+    run_benchmark(str, bench_ecmult_1, bench_ecmult_setup, bench_ecmult_1_teardown, data, 10, iters);\n+    /* ecmult with generator point */\n+    sprintf(str, \"ecmult 1g\");\n+    run_benchmark(str, bench_ecmult_1g, bench_ecmult_setup, bench_ecmult_1g_teardown, data, 10, iters);\n+    /* ecmult with generator and non-generator point. The reported time is per point. */\n+    sprintf(str, \"ecmult 2g\");\n+    run_benchmark(str, bench_ecmult_2g, bench_ecmult_setup, bench_ecmult_2g_teardown, data, 10, 2*iters);\n+}\n+\n+static int bench_ecmult_multi_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, void* arg) {\n     bench_data* data = (bench_data*)arg;\n     if (data->includes_g) ++idx;\n     if (idx == 0) {\n@@ -53,7 +198,7 @@ static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, vo\n     return 1;\n }\n \n-static void bench_ecmult(void* arg, int iters) {\n+static void bench_ecmult_multi(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n \n     int includes_g = data->includes_g;\n@@ -62,19 +207,18 @@ static void bench_ecmult(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n }\n \n-static void bench_ecmult_setup(void* arg) {\n+static void bench_ecmult_multi_setup(void* arg) {\n     bench_data* data = (bench_data*)arg;\n-    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n-    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    hash_into_offset(data, data->count);\n }\n \n-static void bench_ecmult_teardown(void* arg, int iters) {\n+static void bench_ecmult_multi_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n     int iter;\n     iters = iters / data->count;\n@@ -88,7 +232,7 @@ static void bench_ecmult_teardown(void* arg, int iters) {\n \n static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     secp256k1_sha256 sha256;\n-    unsigned char c[11] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n+    unsigned char c[10] = {'e', 'c', 'm', 'u', 'l', 't', 0, 0, 0, 0};\n     unsigned char buf[32];\n     int overflow = 0;\n     c[6] = num;\n@@ -102,7 +246,7 @@ static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     CHECK(!overflow);\n }\n \n-static void run_test(bench_data* data, size_t count, int includes_g, int num_iters) {\n+static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_g, int num_iters) {\n     char str[32];\n     static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n     size_t iters = 1 + num_iters / count;\n@@ -112,8 +256,7 @@ static void run_test(bench_data* data, size_t count, int includes_g, int num_ite\n     data->includes_g = includes_g;\n \n     /* Compute (the negation of) the expected results directly. */\n-    data->offset1 = (data->count * 0x537b7f6f + 0x8f66a481) % POINTS;\n-    data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n+    hash_into_offset(data, data->count);\n     for (iter = 0; iter < iters; ++iter) {\n         secp256k1_scalar tmp;\n         secp256k1_scalar total = data->scalars[(data->offset1++) % POINTS];\n@@ -127,65 +270,75 @@ static void run_test(bench_data* data, size_t count, int includes_g, int num_ite\n     }\n \n     /* Run the benchmark. */\n-    sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n-    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * iters);\n+    sprintf(str, includes_g ? \"ecmult_multi %ig\" : \"ecmult_multi %i\", (int)count);\n+    run_benchmark(str, bench_ecmult_multi, bench_ecmult_multi_setup, bench_ecmult_multi_teardown, data, 10, count * iters);\n }\n \n int main(int argc, char **argv) {\n     bench_data data;\n     int i, p;\n-    secp256k1_gej* pubkeys_gej;\n     size_t scratch_size;\n \n     int iters = get_iters(10000);\n \n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n-    data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n     data.ecmult_multi = secp256k1_ecmult_multi_var;\n \n     if (argc > 1) {\n-        if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n+        if(have_flag(argc, argv, \"-h\")\n+           || have_flag(argc, argv, \"--help\")\n+           || have_flag(argc, argv, \"help\")) {\n+            help(argv);\n+            return 1;\n+        } else if(have_flag(argc, argv, \"pippenger_wnaf\")) {\n             printf(\"Using pippenger_wnaf:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_pippenger_batch_single;\n         } else if(have_flag(argc, argv, \"strauss_wnaf\")) {\n             printf(\"Using strauss_wnaf:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_strauss_batch_single;\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n-            data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n-            data.scratch = NULL;\n         } else {\n-            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n-            fprintf(stderr, \"Use 'pippenger_wnaf', 'strauss_wnaf', 'simple' or no argument to benchmark a combined algorithm.\\n\");\n+            fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\\n\", argv[0], argv[1]);\n+            help(argv);\n             return 1;\n         }\n     }\n \n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n+    if (!have_flag(argc, argv, \"simple\")) {\n+        data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n+    } else {\n+        data.scratch = NULL;\n+    }\n+\n     /* Allocate stuff */\n     data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n+    data.pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n     data.expected_output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n     data.output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n \n     /* Generate a set of scalars, and private/public keypairs. */\n-    pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n-    secp256k1_gej_set_ge(&pubkeys_gej[0], &secp256k1_ge_const_g);\n+    secp256k1_gej_set_ge(&data.pubkeys_gej[0], &secp256k1_ge_const_g);\n     secp256k1_scalar_set_int(&data.seckeys[0], 1);\n     for (i = 0; i < POINTS; ++i) {\n         generate_scalar(i, &data.scalars[i]);\n         if (i) {\n-            secp256k1_gej_double_var(&pubkeys_gej[i], &pubkeys_gej[i - 1], NULL);\n+            secp256k1_gej_double_var(&data.pubkeys_gej[i], &data.pubkeys_gej[i - 1], NULL);\n             secp256k1_scalar_add(&data.seckeys[i], &data.seckeys[i - 1], &data.seckeys[i - 1]);\n         }\n     }\n-    secp256k1_ge_set_all_gej_var(data.pubkeys, pubkeys_gej, POINTS);\n-    free(pubkeys_gej);\n+    secp256k1_ge_set_all_gej_var(data.pubkeys, data.pubkeys_gej, POINTS);\n+\n+\n+    /* Initialize offset1 and offset2 */\n+    hash_into_offset(&data, 0);\n+    run_ecmult_bench(&data, iters);\n \n     for (i = 1; i <= 8; ++i) {\n-        run_test(&data, i, 1, iters);\n+        run_ecmult_multi_bench(&data, i, 1, iters);\n     }\n \n     /* This is disabled with low count of iterations because the loop runs 77 times even with iters=1\n@@ -194,7 +347,7 @@ int main(int argc, char **argv) {\n      if (iters > 2) {\n         for (p = 0; p <= 11; ++p) {\n             for (i = 9; i <= 16; ++i) {\n-                run_test(&data, i << p, 1, iters);\n+                run_ecmult_multi_bench(&data, i << p, 1, iters);\n             }\n         }\n     }\n@@ -205,6 +358,7 @@ int main(int argc, char **argv) {\n     secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n+    free(data.pubkeys_gej);\n     free(data.seckeys);\n     free(data.output);\n     free(data.expected_output);"
      },
      {
        "sha": "161b1c4a47666e88b36310fc79675a8f3f13d6c9",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -5,7 +5,8 @@\n  ***********************************************************************/\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -16,7 +17,6 @@\n #include \"ecmult_const_impl.h\"\n #include \"ecmult_impl.h\"\n #include \"bench.h\"\n-#include \"secp256k1.c\"\n \n typedef struct {\n     secp256k1_scalar scalar[2];"
      },
      {
        "sha": "4bcac19dc0a398669a53c55da6ac4b248f98546b",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -4,8 +4,8 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_recovery.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_recovery.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "d95bc00f485fb2640a0c295cdde79b082591fe0b",
        "filename": "src/secp256k1/src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorrsig.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -8,11 +8,13 @@\n #include <stdlib.h>\n \n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_schnorrsig.h\"\n #include \"util.h\"\n #include \"bench.h\"\n \n+#define MSGLEN 32\n+\n typedef struct {\n     secp256k1_context *ctx;\n     int n;\n@@ -26,13 +28,13 @@ typedef struct {\n void bench_schnorrsig_sign(void* arg, int iters) {\n     bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n     int i;\n-    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char msg[MSGLEN] = {0};\n     unsigned char sig[64];\n \n     for (i = 0; i < iters; i++) {\n         msg[0] = i;\n         msg[1] = i >> 8;\n-        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_sign_custom(data->ctx, sig, msg, MSGLEN, data->keypairs[i], NULL));\n     }\n }\n \n@@ -43,7 +45,7 @@ void bench_schnorrsig_verify(void* arg, int iters) {\n     for (i = 0; i < iters; i++) {\n         secp256k1_xonly_pubkey pk;\n         CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n-        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], MSGLEN, &pk));\n     }\n }\n \n@@ -58,9 +60,10 @@ int main(void) {\n     data.msgs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n     data.sigs = (const unsigned char **)malloc(iters * sizeof(unsigned char *));\n \n+    CHECK(MSGLEN >= 4);\n     for (i = 0; i < iters; i++) {\n         unsigned char sk[32];\n-        unsigned char *msg = (unsigned char *)malloc(32);\n+        unsigned char *msg = (unsigned char *)malloc(MSGLEN);\n         unsigned char *sig = (unsigned char *)malloc(64);\n         secp256k1_keypair *keypair = (secp256k1_keypair *)malloc(sizeof(*keypair));\n         unsigned char *pk_char = (unsigned char *)malloc(32);\n@@ -69,7 +72,7 @@ int main(void) {\n         msg[1] = sk[1] = i >> 8;\n         msg[2] = sk[2] = i >> 16;\n         msg[3] = sk[3] = i >> 24;\n-        memset(&msg[4], 'm', 28);\n+        memset(&msg[4], 'm', MSGLEN - 4);\n         memset(&sk[4], 's', 28);\n \n         data.keypairs[i] = keypair;\n@@ -78,7 +81,7 @@ int main(void) {\n         data.sigs[i] = sig;\n \n         CHECK(secp256k1_keypair_create(data.ctx, keypair, sk));\n-        CHECK(secp256k1_schnorrsig_sign(data.ctx, sig, msg, keypair, NULL, NULL));\n+        CHECK(secp256k1_schnorrsig_sign_custom(data.ctx, sig, msg, MSGLEN, keypair, NULL));\n         CHECK(secp256k1_keypair_xonly_pub(data.ctx, &pk, NULL, keypair));\n         CHECK(secp256k1_xonly_pubkey_serialize(data.ctx, pk_char, &pk) == 1);\n     }"
      },
      {
        "sha": "f659c18c92d0bd20fee399b2c1a0f3ca1a27a41b",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -4,7 +4,7 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "565ae4beec8a5726b267cd141d61ecf50c101c4f",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,7 +7,7 @@\n #include <stdio.h>\n #include <string.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"util.h\"\n #include \"bench.h\"\n "
      },
      {
        "sha": "c32141e8872de1b97d8bfebd8d51a8b90bd880b5",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -140,7 +140,7 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         overflow = 1;\n     }\n     if (!overflow) {\n-        memcpy(ra + 32 - rlen, *sig, rlen);\n+        if (rlen) memcpy(ra + 32 - rlen, *sig, rlen);\n         secp256k1_scalar_set_b32(r, ra, &overflow);\n     }\n     if (overflow) {"
      },
      {
        "sha": "84537bbfed20a765f00de4d28eb7069745f2d2a2",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -17,7 +17,6 @@ typedef struct {\n     secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n } secp256k1_ecmult_context;\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);"
      },
      {
        "sha": "05cf4d52ccafe91a16077748ae609c96b3ae8b0d",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -35,7 +35,6 @@ typedef struct {\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n-static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);"
      },
      {
        "sha": "f9176eb99674233003afc7685407a37b7ce9e369",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -13,7 +13,13 @@\n /* We can't require the precomputed tables when creating them. */\n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n \n-#include \"include/secp256k1.h\"\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n #include \"field_impl.h\""
      },
      {
        "sha": "47aea32be184a0f401403ffbf98067d7f4f5bb9d",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -100,8 +100,8 @@ static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a) {\n \n static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     secp256k1_fe z2, z3;\n-    r->infinity = a->infinity;\n     if (a->infinity) {\n+        secp256k1_ge_set_infinity(r);\n         return;\n     }\n     secp256k1_fe_inv_var(&a->z, &a->z);\n@@ -110,8 +110,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     secp256k1_fe_mul(&a->x, &a->x, &z2);\n     secp256k1_fe_mul(&a->y, &a->y, &z3);\n     secp256k1_fe_set_int(&a->z, 1);\n-    r->x = a->x;\n-    r->y = a->y;\n+    secp256k1_ge_set_xy(r, &a->x, &a->y);\n }\n \n static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len) {\n@@ -120,7 +119,9 @@ static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a\n     size_t last_i = SIZE_MAX;\n \n     for (i = 0; i < len; i++) {\n-        if (!a[i].infinity) {\n+        if (a[i].infinity) {\n+            secp256k1_ge_set_infinity(&r[i]);\n+        } else {\n             /* Use destination's x coordinates as scratch space */\n             if (last_i == SIZE_MAX) {\n                 r[i].x = a[i].z;\n@@ -148,7 +149,6 @@ static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a\n     r[last_i].x = u;\n \n     for (i = 0; i < len; i++) {\n-        r[i].infinity = a[i].infinity;\n         if (!a[i].infinity) {\n             secp256k1_ge_set_gej_zinv(&r[i], &a[i], &r[i].x);\n         }\n@@ -311,7 +311,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n      *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     if (a->infinity) {\n-        r->infinity = 1;\n+        secp256k1_gej_set_infinity(r);\n         if (rzr != NULL) {\n             secp256k1_fe_set_int(rzr, 1);\n         }"
      },
      {
        "sha": "5408c9de707107eef78d0e7a6707f30535333f7d",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_MODULE_ECDH_MAIN_H\n #define SECP256K1_MODULE_ECDH_MAIN_H\n \n-#include \"include/secp256k1_ecdh.h\"\n-#include \"ecmult_const_impl.h\"\n+#include \"../../../include/secp256k1_ecdh.h\"\n+#include \"../../ecmult_const_impl.h\"\n \n static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n     unsigned char version = (y32[31] & 0x01) | 0x02;"
      },
      {
        "sha": "8607bbede73022a40db8f0c60227d61b4f447b90",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 2,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n #define SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n     return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n@@ -55,6 +55,32 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_cmp(const secp256k1_context* ctx, const secp256k1_xonly_pubkey* pk0, const secp256k1_xonly_pubkey* pk1) {\n+    unsigned char out[2][32];\n+    const secp256k1_xonly_pubkey* pk[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    pk[0] = pk0; pk[1] = pk1;\n+    for (i = 0; i < 2; i++) {\n+        /* If the public key is NULL or invalid, xonly_pubkey_serialize will\n+         * call the illegal_callback and return 0. In that case we will\n+         * serialize the key as all zeros which is less than any valid public\n+         * key. This results in consistent comparisons even if NULL or invalid\n+         * pubkeys are involved and prevents edge cases such as sorting\n+         * algorithms that use this function and do not terminate as a\n+         * result. */\n+        if (!secp256k1_xonly_pubkey_serialize(ctx, out[i], pk[i])) {\n+            /* Note that xonly_pubkey_serialize should already set the output to\n+             * zero in that case, but it's not guaranteed by the API, we can't\n+             * test it and writing a VERIFY_CHECK is more complex than\n+             * explicitly memsetting (again). */\n+            memset(out[i], 0, sizeof(out[i]));\n+        }\n+    }\n+    return secp256k1_memcmp_var(out[0], out[1], sizeof(out[1]));\n+}\n+\n /** Keeps a group element as is if it has an even Y and otherwise negates it.\n  *  y_parity is set to 0 in the former case and to 1 in the latter case.\n  *  Requires that the coordinates of r are normalized. */"
      },
      {
        "sha": "d4a2f5bdf4050e821218816585d4d0a3edfdaf3c",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -8,7 +8,7 @@\n #define SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n \n #include \"src/modules/extrakeys/main_impl.h\"\n-#include \"include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static void test_exhaustive_extrakeys(const secp256k1_context *ctx, const secp256k1_ge* group) {\n     secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];"
      },
      {
        "sha": "4a5952714c41c5147b9ccf48914f18d196c51531",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 39,
        "deletions": 1,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n #define SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n \n-#include \"secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n \n static secp256k1_context* api_test_context(int flags, int *ecount) {\n     secp256k1_context *ctx0 = secp256k1_context_create(flags);\n@@ -137,6 +137,43 @@ void test_xonly_pubkey(void) {\n     secp256k1_context_destroy(verify);\n }\n \n+void test_xonly_pubkey_comparison(void) {\n+    unsigned char pk1_ser[32] = {\n+        0x58, 0x84, 0xb3, 0xa2, 0x4b, 0x97, 0x37, 0x88, 0x92, 0x38, 0xa6, 0x26, 0x62, 0x52, 0x35, 0x11,\n+        0xd0, 0x9a, 0xa1, 0x1b, 0x80, 0x0b, 0x5e, 0x93, 0x80, 0x26, 0x11, 0xef, 0x67, 0x4b, 0xd9, 0x23\n+    };\n+    const unsigned char pk2_ser[32] = {\n+        0xde, 0x36, 0x0e, 0x87, 0x59, 0x8f, 0x3c, 0x01, 0x36, 0x2a, 0x2a, 0xb8, 0xc6, 0xf4, 0x5e, 0x4d,\n+        0xb2, 0xc2, 0xd5, 0x03, 0xa7, 0xf9, 0xf1, 0x4f, 0xa8, 0xfa, 0x95, 0xa8, 0xe9, 0x69, 0x76, 0x1c\n+    };\n+    secp256k1_xonly_pubkey pk1;\n+    secp256k1_xonly_pubkey pk2;\n+    int ecount = 0;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk1, pk1_ser) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk2, pk2_ser) == 1);\n+\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, NULL, &pk2) < 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, NULL) > 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk1) > 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk1) == 0);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk2) == 0);\n+    CHECK(ecount == 2);\n+    memset(&pk1, 0, sizeof(pk1)); /* illegal pubkey */\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk2) < 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk1, &pk1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_xonly_pubkey_cmp(none, &pk2, &pk1) > 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+}\n+\n void test_xonly_pubkey_tweak(void) {\n     unsigned char zeros64[64] = { 0 };\n     unsigned char overflows[32];\n@@ -540,6 +577,7 @@ void run_extrakeys_tests(void) {\n     test_xonly_pubkey_tweak();\n     test_xonly_pubkey_tweak_check();\n     test_xonly_pubkey_tweak_recursive();\n+    test_xonly_pubkey_comparison();\n \n     /* keypair tests */\n     test_keypair();"
      },
      {
        "sha": "9e19f2a2dc9c880fd80c48108d46ee4ac5f9a618",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_RECOVERY_MAIN_H\n #define SECP256K1_MODULE_RECOVERY_MAIN_H\n \n-#include \"include/secp256k1_recovery.h\"\n+#include \"../../../include/secp256k1_recovery.h\"\n \n static void secp256k1_ecdsa_recoverable_signature_load(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, int* recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     (void)ctx;"
      },
      {
        "sha": "590a972ed3f74a9e24978ee373895bab5dad8128",
        "filename": "src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -8,7 +8,7 @@\n #define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n \n #include \"src/modules/recovery/main_impl.h\"\n-#include \"include/secp256k1_recovery.h\"\n+#include \"../../../include/secp256k1_recovery.h\"\n \n void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k;"
      },
      {
        "sha": "693b78f03444d6ce8325a4fea44114b73c0a87b4",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,9 +7,9 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n #define SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorrsig.h\"\n-#include \"hash.h\"\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n+#include \"../../hash.h\"\n \n /* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n  * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n@@ -43,16 +43,18 @@ static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *\n     sha->bytes = 64;\n }\n \n-/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+/* algo argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n  * by using the correct tagged hash function. */\n-static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+static const unsigned char bip340_algo[13] = \"BIP0340/nonce\";\n \n-static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+static const unsigned char schnorrsig_extraparams_magic[4] = SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC;\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n     secp256k1_sha256 sha;\n     unsigned char masked_key[32];\n     int i;\n \n-    if (algo16 == NULL) {\n+    if (algo == NULL) {\n         return 0;\n     }\n \n@@ -65,18 +67,14 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         }\n     }\n \n-    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+    /* Tag the hash with algo which is important to avoid nonce reuse across\n      * algorithms. If this nonce function is used in BIP-340 signing as defined\n      * in the spec, an optimized tagging implementation is used. */\n-    if (secp256k1_memcmp_var(algo16, bip340_algo16, 16) == 0) {\n+    if (algolen == sizeof(bip340_algo)\n+            && secp256k1_memcmp_var(algo, bip340_algo, algolen) == 0) {\n         secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n     } else {\n-        int algo16_len = 16;\n-        /* Remove terminating null bytes */\n-        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n-            algo16_len--;\n-        }\n-        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+        secp256k1_sha256_initialize_tagged(&sha, algo, algolen);\n     }\n \n     /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n@@ -86,7 +84,7 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n         secp256k1_sha256_write(&sha, key32, 32);\n     }\n     secp256k1_sha256_write(&sha, xonly_pk32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, nonce32);\n     return 1;\n }\n@@ -108,23 +106,23 @@ static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n     sha->bytes = 64;\n }\n \n-static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg32, const unsigned char *pubkey32)\n+static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg, size_t msglen, const unsigned char *pubkey32)\n {\n     unsigned char buf[32];\n     secp256k1_sha256 sha;\n \n-    /* tagged hash(r.x, pk.x, msg32) */\n+    /* tagged hash(r.x, pk.x, msg) */\n     secp256k1_schnorrsig_sha256_tagged(&sha);\n     secp256k1_sha256_write(&sha, r32, 32);\n     secp256k1_sha256_write(&sha, pubkey32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n     secp256k1_sha256_finalize(&sha, buf);\n     /* Set scalar e to the challenge hash modulo the curve order as per\n      * BIP340. */\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -139,7 +137,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(keypair != NULL);\n \n     if (noncefp == NULL) {\n@@ -156,7 +154,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n \n     secp256k1_scalar_get_b32(seckey, &sk);\n     secp256k1_fe_get_b32(pk_buf, &pk.x);\n-    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    ret &= !!noncefp(buf, msg, msglen, seckey, pk_buf, bip340_algo, sizeof(bip340_algo), ndata);\n     secp256k1_scalar_set_b32(&k, buf, NULL);\n     ret &= !secp256k1_scalar_is_zero(&k);\n     secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n@@ -174,7 +172,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_fe_normalize_var(&r.x);\n     secp256k1_fe_get_b32(&sig64[0], &r.x);\n \n-    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, pk_buf);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, pk_buf);\n     secp256k1_scalar_mul(&e, &e, &sk);\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n@@ -187,7 +185,26 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     return ret;\n }\n \n-int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, unsigned char *aux_rand32) {\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, aux_rand32);\n+}\n+\n+int secp256k1_schnorrsig_sign_custom(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams) {\n+    secp256k1_nonce_function_hardened noncefp = NULL;\n+    void *ndata = NULL;\n+    VERIFY_CHECK(ctx != NULL);\n+\n+    if (extraparams != NULL) {\n+        ARG_CHECK(secp256k1_memcmp_var(extraparams->magic,\n+                                       schnorrsig_extraparams_magic,\n+                                       sizeof(extraparams->magic)) == 0);\n+        noncefp = extraparams->noncefp;\n+        ndata = extraparams->ndata;\n+    }\n+    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg, msglen, keypair, noncefp, ndata);\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey) {\n     secp256k1_scalar s;\n     secp256k1_scalar e;\n     secp256k1_gej rj;\n@@ -201,7 +218,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n \n     if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n@@ -219,7 +236,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n \n     /* Compute e. */\n     secp256k1_fe_get_b32(buf, &pk.x);\n-    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, buf);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, buf);\n \n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);"
      },
      {
        "sha": "d8df9dd2df7425a0f25a4d2ba185a54c110357ba",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,7 +7,7 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n #define SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n \n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n #include \"src/modules/schnorrsig/main_impl.h\"\n \n static const unsigned char invalid_pubkey_bytes[][32] = {\n@@ -58,15 +58,19 @@ static const unsigned char invalid_pubkey_bytes[][32] = {\n \n #define NUM_INVALID_KEYS (sizeof(invalid_pubkey_bytes) / sizeof(invalid_pubkey_bytes[0]))\n \n-static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg,\n+                                                      size_t msglen,\n                                                       const unsigned char *key32, const unsigned char *xonly_pk32,\n-                                                      const unsigned char *algo16, void* data) {\n+                                                      const unsigned char *algo, size_t algolen,\n+                                                      void* data) {\n     secp256k1_scalar s;\n     int *idata = data;\n-    (void)msg32;\n+    (void)msg;\n+    (void)msglen;\n     (void)key32;\n     (void)xonly_pk32;\n-    (void)algo16;\n+    (void)algo;\n+    (void)algolen;\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n     return 1;\n@@ -101,7 +105,7 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n                 secp256k1_scalar e;\n                 unsigned char msg32[32];\n                 secp256k1_testrand256(msg32);\n-                secp256k1_schnorrsig_challenge(&e, sig64, msg32, pk32);\n+                secp256k1_schnorrsig_challenge(&e, sig64, msg32, sizeof(msg32), pk32);\n                 /* Only do work if we hit a challenge we haven't tried before. */\n                 if (!e_done[e]) {\n                     /* Iterate over the possible valid last 32 bytes in the signature.\n@@ -119,7 +123,7 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n                             secp256k1_testrand256(sig64 + 32);\n                             expect_valid = 0;\n                         }\n-                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, &pubkeys[d - 1]);\n+                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, sizeof(msg32), &pubkeys[d - 1]);\n                         CHECK(valid == expect_valid);\n                         count_valid += valid;\n                     }\n@@ -137,6 +141,8 @@ static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, cons\n static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsigned char (*xonly_pubkey_bytes)[32], const secp256k1_keypair* keypairs, const int* parities) {\n     int d, k;\n     uint64_t iter = 0;\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+\n     /* Loop over keys. */\n     for (d = 1; d < EXHAUSTIVE_TEST_ORDER; ++d) {\n         int actual_d = d;\n@@ -149,19 +155,21 @@ static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsign\n             unsigned char sig64[64];\n             int actual_k = k;\n             if (skip_section(&iter)) continue;\n+            extraparams.noncefp = secp256k1_hardened_nonce_function_smallint;\n+            extraparams.ndata = &k;\n             if (parities[k - 1]) actual_k = EXHAUSTIVE_TEST_ORDER - k;\n             /* Generate random messages until all challenges have been tried. */\n             while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n                 secp256k1_scalar e;\n                 secp256k1_testrand256(msg32);\n-                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, xonly_pubkey_bytes[d - 1]);\n+                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, sizeof(msg32), xonly_pubkey_bytes[d - 1]);\n                 /* Only do work if we hit a challenge we haven't tried before. */\n                 if (!e_done[e]) {\n                     secp256k1_scalar expected_s = (actual_k + e * actual_d) % EXHAUSTIVE_TEST_ORDER;\n                     unsigned char expected_s_bytes[32];\n                     secp256k1_scalar_get_b32(expected_s_bytes, &expected_s);\n                     /* Invoke the real function to construct a signature. */\n-                    CHECK(secp256k1_schnorrsig_sign(ctx, sig64, msg32, &keypairs[d - 1], secp256k1_hardened_nonce_function_smallint, &k));\n+                    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig64, msg32, sizeof(msg32), &keypairs[d - 1], &extraparams));\n                     /* The first 32 bytes must match the xonly pubkey for the specified k. */\n                     CHECK(secp256k1_memcmp_var(sig64, xonly_pubkey_bytes[k - 1], 32) == 0);\n                     /* The last 32 bytes must match the expected s value. */"
      },
      {
        "sha": "59357afa99ad6a621b164e0c42bae4e2faeec021",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 160,
        "deletions": 75,
        "changes": 235,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,16 +7,16 @@\n #ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n #define SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n \n-#include \"secp256k1_schnorrsig.h\"\n+#include \"../../../include/secp256k1_schnorrsig.h\"\n \n /* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n  * bytes) changes the hash function\n  */\n-void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes, size_t msglen, size_t algolen) {\n     unsigned char nonces[2][32];\n-    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(nonce_function_bip340(nonces[0], args[0], msglen, args[1], args[2], args[3], algolen, args[4]) == 1);\n     secp256k1_testrand_flip(args[n_flip], n_bytes);\n-    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], msglen, args[1], args[2], args[3], algolen, args[4]) == 1);\n     CHECK(secp256k1_memcmp_var(nonces[0], nonces[1], 32) != 0);\n }\n \n@@ -34,11 +34,13 @@ void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2)\n void run_nonce_function_bip340_tests(void) {\n     unsigned char tag[13] = \"BIP0340/nonce\";\n     unsigned char aux_tag[11] = \"BIP0340/aux\";\n-    unsigned char algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+    unsigned char algo[13] = \"BIP0340/nonce\";\n+    size_t algolen = sizeof(algo);\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n     unsigned char nonce[32];\n     unsigned char msg[32];\n+    size_t msglen = sizeof(msg);\n     unsigned char key[32];\n     unsigned char pk[32];\n     unsigned char aux_rand[32];\n@@ -68,33 +70,45 @@ void run_nonce_function_bip340_tests(void) {\n     args[0] = msg;\n     args[1] = key;\n     args[2] = pk;\n-    args[3] = algo16;\n+    args[3] = algo;\n     args[4] = aux_rand;\n     for (i = 0; i < count; i++) {\n-        nonce_function_bip340_bitflip(args, 0, 32);\n-        nonce_function_bip340_bitflip(args, 1, 32);\n-        nonce_function_bip340_bitflip(args, 2, 32);\n-        /* Flip algo16 special case \"BIP0340/nonce\" */\n-        nonce_function_bip340_bitflip(args, 3, 16);\n-        /* Flip algo16 again */\n-        nonce_function_bip340_bitflip(args, 3, 16);\n-        nonce_function_bip340_bitflip(args, 4, 32);\n+        nonce_function_bip340_bitflip(args, 0, 32, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 1, 32, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 2, 32, msglen, algolen);\n+        /* Flip algo special case \"BIP0340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, algolen, msglen, algolen);\n+        /* Flip algo again */\n+        nonce_function_bip340_bitflip(args, 3, algolen, msglen, algolen);\n+        nonce_function_bip340_bitflip(args, 4, 32, msglen, algolen);\n     }\n \n-    /* NULL algo16 is disallowed */\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n-    /* Empty algo16 is fine */\n-    memset(algo16, 0x00, 16);\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n-    /* algo16 with terminating null bytes is fine */\n-    algo16[1] = 65;\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n-    /* Other algo16 is fine */\n-    memset(algo16, 0xFF, 16);\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* NULL algo is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, NULL, 0, NULL) == 0);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+    /* Other algo is fine */\n+    secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, algo, algolen);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n+\n+    for (i = 0; i < count; i++) {\n+        unsigned char nonce2[32];\n+        uint32_t offset = secp256k1_testrand_int(msglen - 1);\n+        size_t msglen_tmp = (msglen + offset) % msglen;\n+        size_t algolen_tmp;\n+\n+        /* Different msglen gives different nonce */\n+        CHECK(nonce_function_bip340(nonce2, msg, msglen_tmp, key, pk, algo, algolen, NULL) == 1);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+\n+        /* Different algolen gives different nonce */\n+        offset = secp256k1_testrand_int(algolen - 1);\n+        algolen_tmp = (algolen + offset) % algolen;\n+        CHECK(nonce_function_bip340(nonce2, msg, msglen, key, pk, algo, algolen_tmp, NULL) == 1);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+    }\n \n     /* NULL aux_rand argument is allowed. */\n-    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    CHECK(nonce_function_bip340(nonce, msg, msglen, key, pk, algo, algolen, NULL) == 1);\n }\n \n void test_schnorrsig_api(void) {\n@@ -103,10 +117,12 @@ void test_schnorrsig_api(void) {\n     unsigned char sk3[32];\n     unsigned char msg[32];\n     secp256k1_keypair keypairs[3];\n-    secp256k1_keypair invalid_keypair = { 0 };\n+    secp256k1_keypair invalid_keypair = {{ 0 }};\n     secp256k1_xonly_pubkey pk[3];\n     secp256k1_xonly_pubkey zero_pk;\n     unsigned char sig[64];\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+    secp256k1_schnorrsig_extraparams invalid_extraparams = {{ 0 }, NULL, NULL};\n \n     /** setup **/\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n@@ -138,36 +154,60 @@ void test_schnorrsig_api(void) {\n \n     /** main test body **/\n     ecount = 0;\n-    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL) == 0);\n+    CHECK(ecount == 6);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign_custom(none, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(vrfy, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], &extraparams) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, NULL, msg, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, NULL, sizeof(msg), &keypairs[0], &extraparams) == 0);\n     CHECK(ecount == 4);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, NULL, 0, &keypairs[0], &extraparams) == 1);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), NULL, &extraparams) == 0);\n     CHECK(ecount == 5);\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &invalid_keypair, NULL, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &invalid_keypair, &extraparams) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], NULL) == 1);\n     CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_sign_custom(sign, sig, msg, sizeof(msg), &keypairs[0], &invalid_extraparams) == 0);\n+    CHECK(ecount == 7);\n \n     ecount = 0;\n-    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n     CHECK(ecount == 3);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n     CHECK(ecount == 4);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n     CHECK(ecount == 5);\n-    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n     CHECK(ecount == 6);\n \n     secp256k1_context_destroy(none);\n@@ -179,7 +219,7 @@ void test_schnorrsig_api(void) {\n /* Checks that hash initialized by secp256k1_schnorrsig_sha256_tagged has the\n  * expected state. */\n void test_schnorrsig_sha256_tagged(void) {\n-    char tag[17] = \"BIP0340/challenge\";\n+    unsigned char tag[17] = \"BIP0340/challenge\";\n     secp256k1_sha256 sha;\n     secp256k1_sha256 sha_optimized;\n \n@@ -190,19 +230,19 @@ void test_schnorrsig_sha256_tagged(void) {\n \n /* Helper function for schnorrsig_bip_vectors\n  * Signs the message and checks that it's the same as expected_sig. */\n-void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg, const unsigned char *expected_sig) {\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, unsigned char *aux_rand, const unsigned char *msg32, const unsigned char *expected_sig) {\n     unsigned char sig[64];\n     secp256k1_keypair keypair;\n     secp256k1_xonly_pubkey pk, pk_expected;\n \n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg32, &keypair, aux_rand));\n     CHECK(secp256k1_memcmp_var(sig, expected_sig, 64) == 0);\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n     CHECK(secp256k1_memcmp_var(&pk, &pk_expected, sizeof(pk)) == 0);\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg32, 32, &pk));\n }\n \n /* Helper function for schnorrsig_bip_vectors\n@@ -211,7 +251,7 @@ void test_schnorrsig_bip_vectors_check_verify(const unsigned char *pk_serialized\n     secp256k1_xonly_pubkey pk;\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk, pk_serialized));\n-    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, sig, msg32, 32, &pk));\n }\n \n /* Test vectors according to BIP-340 (\"Schnorr Signatures for secp256k1\"). See\n@@ -634,34 +674,40 @@ void test_schnorrsig_bip_vectors(void) {\n }\n \n /* Nonce function that returns constant 0 */\n-static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_failing(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n     (void) nonce32;\n     return 0;\n }\n \n /* Nonce function that sets nonce to 0 */\n-static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_0(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n \n     memset(nonce32, 0, 32);\n     return 1;\n }\n \n /* Nonce function that sets nonce to 0xFF...0xFF */\n-static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n-    (void) msg32;\n+static int nonce_function_overflowing(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {\n+    (void) msg;\n+    (void) msglen;\n     (void) key32;\n     (void) xonly_pk32;\n-    (void) algo16;\n+    (void) algo;\n+    (void) algolen;\n     (void) data;\n \n     memset(nonce32, 0xFF, 32);\n@@ -670,24 +716,45 @@ static int nonce_function_overflowing(unsigned char *nonce32, const unsigned cha\n \n void test_schnorrsig_sign(void) {\n     unsigned char sk[32];\n+    secp256k1_xonly_pubkey pk;\n     secp256k1_keypair keypair;\n     const unsigned char msg[32] = \"this is a msg for a schnorrsig..\";\n     unsigned char sig[64];\n+    unsigned char sig2[64];\n     unsigned char zeros64[64] = { 0 };\n+    secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;\n+    unsigned char aux_rand[32];\n \n     secp256k1_testrand256(sk);\n+    secp256k1_testrand256(aux_rand);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n \n     /* Test different nonce functions */\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n     memset(sig, 1, sizeof(sig));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n+    extraparams.noncefp = nonce_function_failing;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 0);\n     CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     memset(&sig, 1, sizeof(sig));\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n+    extraparams.noncefp = nonce_function_0;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 0);\n     CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n-    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) != 0);\n+    memset(&sig, 1, sizeof(sig));\n+    extraparams.noncefp = nonce_function_overflowing;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &pk));\n+\n+    /* When using the default nonce function, schnorrsig_sign_custom produces\n+     * the same result as schnorrsig_sign with aux_rand = extraparams.ndata */\n+    extraparams.noncefp = NULL;\n+    extraparams.ndata = aux_rand;\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig, msg, sizeof(msg), &keypair, &extraparams) == 1);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig2, msg, &keypair, extraparams.ndata) == 1);\n+    CHECK(secp256k1_memcmp_var(sig, sig2, sizeof(sig)) == 0);\n }\n \n #define N_SIGS 3\n@@ -709,8 +776,8 @@ void test_schnorrsig_sign_verify(void) {\n \n     for (i = 0; i < N_SIGS; i++) {\n         secp256k1_testrand256(msg[i]);\n-        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n-        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n+        CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], sizeof(msg[i]), &pk));\n     }\n \n     {\n@@ -720,36 +787,54 @@ void test_schnorrsig_sign_verify(void) {\n         size_t byte_idx = secp256k1_testrand_int(32);\n         unsigned char xorbyte = secp256k1_testrand_int(254)+1;\n         sig[sig_idx][byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         sig[sig_idx][byte_idx] ^= xorbyte;\n \n         byte_idx = secp256k1_testrand_int(32);\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n \n         byte_idx = secp256k1_testrand_int(32);\n         msg[sig_idx][byte_idx] ^= xorbyte;\n-        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n         msg[sig_idx][byte_idx] ^= xorbyte;\n \n         /* Check that above bitflips have been reversed correctly */\n-        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], sizeof(msg[sig_idx]), &pk));\n     }\n \n     /* Test overflowing s */\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n     memset(&sig[0][32], 0xFF, 32);\n-    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n \n     /* Test negative s */\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL, NULL));\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig[0], msg[0], &keypair, NULL));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n     secp256k1_scalar_set_b32(&s, &sig[0][32], NULL);\n     secp256k1_scalar_negate(&s, &s);\n     secp256k1_scalar_get_b32(&sig[0][32], &s);\n-    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], &pk));\n+    CHECK(!secp256k1_schnorrsig_verify(ctx, sig[0], msg[0], sizeof(msg[0]), &pk));\n+\n+    /* The empty message can be signed & verified */\n+    CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig[0], NULL, 0, &keypair, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], NULL, 0, &pk) == 1);\n+\n+    {\n+        /* Test varying message lengths */\n+        unsigned char msg_large[32 * 8];\n+        uint32_t msglen  = secp256k1_testrand_int(sizeof(msg_large));\n+        for (i = 0; i < sizeof(msg_large); i += 32) {\n+            secp256k1_testrand256(&msg_large[i]);\n+        }\n+        CHECK(secp256k1_schnorrsig_sign_custom(ctx, sig[0], msg_large, msglen, &keypair, NULL) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg_large, msglen, &pk) == 1);\n+        /* Verification for a random wrong message length fails */\n+        msglen = (msglen + (sizeof(msg_large) - 1)) % sizeof(msg_large);\n+        CHECK(secp256k1_schnorrsig_verify(ctx, sig[0], msg_large, msglen, &pk) == 0);\n+    }\n }\n #undef N_SIGS\n \n@@ -777,10 +862,10 @@ void test_schnorrsig_taproot(void) {\n \n     /* Key spend */\n     secp256k1_testrand256(msg);\n-    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n+    CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL) == 1);\n     /* Verify key spend */\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &output_pk) == 1);\n+    CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, sizeof(msg), &output_pk) == 1);\n \n     /* Script spend */\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, internal_pk_bytes, &internal_pk) == 1);"
      },
      {
        "sha": "9908cab8642a5cdbf8819e227c5a80f734d4ec76",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 47,
        "deletions": 2,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -4,8 +4,10 @@\n  * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n  ***********************************************************************/\n \n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_preallocated.h\"\n+#define SECP256K1_BUILD\n+\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_preallocated.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -21,6 +23,10 @@\n #include \"scratch_impl.h\"\n #include \"selftest.h\"\n \n+#ifdef SECP256K1_NO_BUILD\n+# error \"secp256k1.h processed without SECP256K1_BUILD defined while building secp256k1.c\"\n+#endif\n+\n #if defined(VALGRIND)\n # include <valgrind/memcheck.h>\n #endif\n@@ -316,6 +322,32 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     return ret;\n }\n \n+int secp256k1_ec_pubkey_cmp(const secp256k1_context* ctx, const secp256k1_pubkey* pubkey0, const secp256k1_pubkey* pubkey1) {\n+    unsigned char out[2][33];\n+    const secp256k1_pubkey* pk[2];\n+    int i;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    pk[0] = pubkey0; pk[1] = pubkey1;\n+    for (i = 0; i < 2; i++) {\n+        size_t out_size = sizeof(out[i]);\n+        /* If the public key is NULL or invalid, ec_pubkey_serialize will call\n+         * the illegal_callback and return 0. In that case we will serialize the\n+         * key as all zeros which is less than any valid public key. This\n+         * results in consistent comparisons even if NULL or invalid pubkeys are\n+         * involved and prevents edge cases such as sorting algorithms that use\n+         * this function and do not terminate as a result. */\n+        if (!secp256k1_ec_pubkey_serialize(ctx, out[i], &out_size, pk[i], SECP256K1_EC_COMPRESSED)) {\n+            /* Note that ec_pubkey_serialize should already set the output to\n+             * zero in that case, but it's not guaranteed by the API, we can't\n+             * test it and writing a VERIFY_CHECK is more complex than\n+             * explicitly memsetting (again). */\n+            memset(out[i], 0, sizeof(out[i]));\n+        }\n+    }\n+    return secp256k1_memcmp_var(out[0], out[1], sizeof(out[0]));\n+}\n+\n static void secp256k1_ecdsa_signature_load(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_ecdsa_signature* sig) {\n     (void)ctx;\n     if (sizeof(secp256k1_scalar) == 32) {\n@@ -758,6 +790,19 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+int secp256k1_tagged_sha256(const secp256k1_context* ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen) {\n+    secp256k1_sha256 sha;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(hash32 != NULL);\n+    ARG_CHECK(tag != NULL);\n+    ARG_CHECK(msg != NULL);\n+\n+    secp256k1_sha256_initialize_tagged(&sha, tag, taglen);\n+    secp256k1_sha256_write(&sha, msg, msglen);\n+    secp256k1_sha256_finalize(&sha, hash32);\n+    return 1;\n+}\n+\n #ifdef ENABLE_MODULE_ECDH\n # include \"modules/ecdh/main_impl.h\"\n #endif"
      },
      {
        "sha": "c8d30ef6a814bae98e77cc9e5ac35f4e2fe2492e",
        "filename": "src/secp256k1/src/testrand_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand_impl.h?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -127,7 +127,7 @@ static void secp256k1_testrand_init(const char* hexseed) {\n             pos++;\n         }\n     } else {\n-        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        FILE *frand = fopen(\"/dev/urandom\", \"rb\");\n         if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n             uint64_t t = time(NULL) * (uint64_t)1337;\n             fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");"
      },
      {
        "sha": "99d9468e2987cd9cc5cc4b701181bade0aa39ac5",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 172,
        "deletions": 10,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -15,8 +15,8 @@\n #include <time.h>\n \n #include \"secp256k1.c\"\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_preallocated.h\"\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n #include \"util.h\"\n \n@@ -30,8 +30,8 @@ void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)\n # endif\n #endif\n \n-#include \"contrib/lax_der_parsing.c\"\n-#include \"contrib/lax_der_privatekey_parsing.c\"\n+#include \"../contrib/lax_der_parsing.c\"\n+#include \"../contrib/lax_der_privatekey_parsing.c\"\n \n #include \"modinv32_impl.h\"\n #ifdef SECP256K1_WIDEMUL_INT128\n@@ -564,6 +564,38 @@ void run_rfc6979_hmac_sha256_tests(void) {\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n }\n \n+void run_tagged_sha256_tests(void) {\n+    int ecount = 0;\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    unsigned char tag[32] = { 0 };\n+    unsigned char msg[32] = { 0 };\n+    unsigned char hash32[32];\n+    unsigned char hash_expected[32] = {\n+        0x04, 0x7A, 0x5E, 0x17, 0xB5, 0x86, 0x47, 0xC1,\n+        0x3C, 0xC6, 0xEB, 0xC0, 0xAA, 0x58, 0x3B, 0x62,\n+        0xFB, 0x16, 0x43, 0x32, 0x68, 0x77, 0x40, 0x6C,\n+        0xE2, 0x76, 0x55, 0x9A, 0x3B, 0xDE, 0x55, 0xB3\n+    };\n+\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+\n+    /* API test */\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, sizeof(tag), msg, sizeof(msg)) == 1);\n+    CHECK(secp256k1_tagged_sha256(none, NULL, tag, sizeof(tag), msg, sizeof(msg)) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, NULL, 0, msg, sizeof(msg)) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, sizeof(tag), NULL, 0) == 0);\n+    CHECK(ecount == 3);\n+\n+    /* Static test vector */\n+    memcpy(tag, \"tag\", 3);\n+    memcpy(msg, \"msg\", 3);\n+    CHECK(secp256k1_tagged_sha256(none, hash32, tag, 3, msg, 3) == 1);\n+    CHECK(secp256k1_memcmp_var(hash32, hash_expected, sizeof(hash32)) == 0);\n+    secp256k1_context_destroy(none);\n+}\n+\n /***** RANDOM TESTS *****/\n \n void test_rand_bits(int rand32, int bits) {\n@@ -2508,6 +2540,70 @@ void run_field_misc(void) {\n     }\n }\n \n+void test_fe_mul(const secp256k1_fe* a, const secp256k1_fe* b, int use_sqr)\n+{\n+    secp256k1_fe c, an, bn;\n+    /* Variables in BE 32-byte format. */\n+    unsigned char a32[32], b32[32], c32[32];\n+    /* Variables in LE 16x uint16_t format. */\n+    uint16_t a16[16], b16[16], c16[16];\n+    /* Field modulus in LE 16x uint16_t format. */\n+    static const uint16_t m16[16] = {\n+        0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+        0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+    };\n+    uint16_t t16[32];\n+    int i;\n+\n+    /* Compute C = A * B in fe format. */\n+    c = *a;\n+    if (use_sqr) {\n+        secp256k1_fe_sqr(&c, &c);\n+    } else {\n+        secp256k1_fe_mul(&c, &c, b);\n+    }\n+\n+    /* Convert A, B, C into LE 16x uint16_t format. */\n+    an = *a;\n+    bn = *b;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_normalize_var(&an);\n+    secp256k1_fe_normalize_var(&bn);\n+    secp256k1_fe_get_b32(a32, &an);\n+    secp256k1_fe_get_b32(b32, &bn);\n+    secp256k1_fe_get_b32(c32, &c);\n+    for (i = 0; i < 16; ++i) {\n+        a16[i] = a32[31 - 2*i] + ((uint16_t)a32[30 - 2*i] << 8);\n+        b16[i] = b32[31 - 2*i] + ((uint16_t)b32[30 - 2*i] << 8);\n+        c16[i] = c32[31 - 2*i] + ((uint16_t)c32[30 - 2*i] << 8);\n+    }\n+    /* Compute T = A * B in LE 16x uint16_t format. */\n+    mulmod256(t16, a16, b16, m16);\n+    /* Compare */\n+    CHECK(secp256k1_memcmp_var(t16, c16, 32) == 0);\n+}\n+\n+void run_fe_mul(void) {\n+    int i;\n+    for (i = 0; i < 100 * count; ++i) {\n+        secp256k1_fe a, b, c, d;\n+        random_fe(&a);\n+        random_field_element_magnitude(&a);\n+        random_fe(&b);\n+        random_field_element_magnitude(&b);\n+        random_fe_test(&c);\n+        random_field_element_magnitude(&c);\n+        random_fe_test(&d);\n+        random_field_element_magnitude(&d);\n+        test_fe_mul(&a, &a, 1);\n+        test_fe_mul(&c, &c, 1);\n+        test_fe_mul(&a, &b, 0);\n+        test_fe_mul(&a, &c, 0);\n+        test_fe_mul(&c, &b, 0);\n+        test_fe_mul(&c, &d, 0);\n+    }\n+}\n+\n void run_sqr(void) {\n     secp256k1_fe x, s;\n \n@@ -2595,7 +2691,7 @@ void test_inverse_scalar(secp256k1_scalar* out, const secp256k1_scalar* x, int v\n {\n     secp256k1_scalar l, r, t;\n \n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&l, x);  /* l = 1/x */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&l, x);  /* l = 1/x */\n     if (out) *out = l;\n     if (secp256k1_scalar_is_zero(x)) {\n         CHECK(secp256k1_scalar_is_zero(&l));\n@@ -2605,9 +2701,9 @@ void test_inverse_scalar(secp256k1_scalar* out, const secp256k1_scalar* x, int v\n     CHECK(secp256k1_scalar_is_one(&t));                                          /* x*(1/x) == 1 */\n     secp256k1_scalar_add(&r, x, &scalar_minus_one);                              /* r = x-1 */\n     if (secp256k1_scalar_is_zero(&r)) return;\n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&r, &r); /* r = 1/(x-1) */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&r, &r); /* r = 1/(x-1) */\n     secp256k1_scalar_add(&l, &scalar_minus_one, &l);                             /* l = 1/x-1 */\n-    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse_var)(&l, &l); /* l = 1/(1/x-1) */\n+    (var ? secp256k1_scalar_inverse_var : secp256k1_scalar_inverse)(&l, &l); /* l = 1/(1/x-1) */\n     secp256k1_scalar_add(&l, &l, &secp256k1_scalar_one);                         /* l = 1/(1/x-1)+1 */\n     secp256k1_scalar_add(&l, &r, &l);                                            /* l = 1/(1/x-1)+1 + 1/(x-1) */\n     CHECK(secp256k1_scalar_is_zero(&l));                                         /* l == 0 */\n@@ -3101,20 +3197,34 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n+        int odd;\n         random_group_element_test(&ge[i]);\n+        odd = secp256k1_fe_is_odd(&ge[i].x);\n+        CHECK(odd == 0 || odd == 1);\n         /* randomly set half the points to infinity */\n-        if(secp256k1_fe_is_odd(&ge[i].x)) {\n+        if (odd == i % 2) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n         secp256k1_gej_set_ge(&gej[i], &ge[i]);\n     }\n-    /* batch invert */\n+    /* batch convert */\n     secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n     /* check result */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         ge_equals_gej(&ge[i], &gej[i]);\n     }\n \n+    /* Test batch gej -> ge conversion with all infinities. */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        secp256k1_gej_set_infinity(&gej[i]);\n+    }\n+    /* batch convert */\n+    secp256k1_ge_set_all_gej_var(ge, gej, 4 * runs + 1);\n+    /* check result */\n+    for (i = 0; i < 4 * runs + 1; i++) {\n+        CHECK(secp256k1_ge_is_infinity(&ge[i]));\n+    }\n+\n     free(ge);\n     free(gej);\n }\n@@ -5434,6 +5544,55 @@ void test_random_pubkeys(void) {\n     }\n }\n \n+void run_pubkey_comparison(void) {\n+    unsigned char pk1_ser[33] = {\n+        0x02,\n+        0x58, 0x84, 0xb3, 0xa2, 0x4b, 0x97, 0x37, 0x88, 0x92, 0x38, 0xa6, 0x26, 0x62, 0x52, 0x35, 0x11,\n+        0xd0, 0x9a, 0xa1, 0x1b, 0x80, 0x0b, 0x5e, 0x93, 0x80, 0x26, 0x11, 0xef, 0x67, 0x4b, 0xd9, 0x23\n+    };\n+    const unsigned char pk2_ser[33] = {\n+        0x02,\n+        0xde, 0x36, 0x0e, 0x87, 0x59, 0x8f, 0x3c, 0x01, 0x36, 0x2a, 0x2a, 0xb8, 0xc6, 0xf4, 0x5e, 0x4d,\n+        0xb2, 0xc2, 0xd5, 0x03, 0xa7, 0xf9, 0xf1, 0x4f, 0xa8, 0xfa, 0x95, 0xa8, 0xe9, 0x69, 0x76, 0x1c\n+    };\n+    secp256k1_pubkey pk1;\n+    secp256k1_pubkey pk2;\n+    int32_t ecount = 0;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk1, pk1_ser, sizeof(pk1_ser)) == 1);\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk2, pk2_ser, sizeof(pk2_ser)) == 1);\n+\n+    secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, NULL, &pk2) < 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, NULL) > 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk1) > 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk1) == 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk2) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        secp256k1_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp)); /* illegal pubkey */\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk_tmp, &pk2) < 0);\n+        CHECK(ecount == 3);\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk_tmp, &pk_tmp) == 0);\n+        CHECK(ecount == 5);\n+        CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk_tmp) > 0);\n+        CHECK(ecount == 6);\n+    }\n+\n+    secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n+\n+    /* Make pk2 the same as pk1 but with 3 rather than 2. Note that in\n+     * an uncompressed encoding, these would have the opposite ordering */\n+    pk1_ser[0] = 3;\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk2, pk1_ser, sizeof(pk1_ser)) == 1);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk1, &pk2) < 0);\n+    CHECK(secp256k1_ec_pubkey_cmp(ctx, &pk2, &pk1) > 0);\n+}\n+\n void run_random_pubkeys(void) {\n     int i;\n     for (i = 0; i < 10*count; i++) {\n@@ -6408,7 +6567,7 @@ int main(int argc, char **argv) {\n         count = strtol(argv[1], NULL, 0);\n     } else {\n         const char* env = getenv(\"SECP256K1_TEST_ITERS\");\n-        if (env) {\n+        if (env && strlen(env) > 0) {\n             count = strtol(env, NULL, 0);\n         }\n     }\n@@ -6442,13 +6601,15 @@ int main(int argc, char **argv) {\n     run_sha256_tests();\n     run_hmac_sha256_tests();\n     run_rfc6979_hmac_sha256_tests();\n+    run_tagged_sha256_tests();\n \n     /* scalar tests */\n     run_scalar_tests();\n \n     /* field tests */\n     run_field_misc();\n     run_field_convert();\n+    run_fe_mul();\n     run_sqr();\n     run_sqrt();\n \n@@ -6485,6 +6646,7 @@ int main(int argc, char **argv) {\n #endif\n \n     /* ecdsa tests */\n+    run_pubkey_comparison();\n     run_random_pubkeys();\n     run_ecdsa_der_parse();\n     run_ecdsa_sign_verify();"
      },
      {
        "sha": "5b9a3035d9a717e1d2a3f2846ce670ff3e9648b4",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -10,7 +10,6 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n-\n #include <time.h>\n \n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n@@ -20,10 +19,10 @@\n #define EXHAUSTIVE_TEST_ORDER 13\n #endif\n \n-#include \"include/secp256k1.h\"\n+#include \"secp256k1.c\"\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"group.h\"\n-#include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n static int count = 2;\n@@ -303,6 +302,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n             if (skip_section(&iter)) continue;\n             for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n                 const int starting_k = k;\n+                int ret;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -311,7 +311,8 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 secp256k1_scalar_get_b32(sk32, &sk);\n                 secp256k1_scalar_get_b32(msg32, &msg);\n \n-                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+                ret = secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+                CHECK(ret == 1);\n \n                 secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n                 /* Note that we compute expected_r *after* signing -- this is important"
      },
      {
        "sha": "ea6d4b3deb3bcbebf01cb8002b9281a5bc2955e3",
        "filename": "src/secp256k1/src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ffb44716bb7a7b9f0a5d70ac07058632234370/src/secp256k1/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/valgrind_ctime_test.c?ref=e4ffb44716bb7a7b9f0a5d70ac07058632234370",
        "patch": "@@ -7,24 +7,24 @@\n #include <valgrind/memcheck.h>\n #include <stdio.h>\n \n-#include \"include/secp256k1.h\"\n+#include \"../include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n \n #ifdef ENABLE_MODULE_ECDH\n-# include \"include/secp256k1_ecdh.h\"\n+# include \"../include/secp256k1_ecdh.h\"\n #endif\n \n #ifdef ENABLE_MODULE_RECOVERY\n-# include \"include/secp256k1_recovery.h\"\n+# include \"../include/secp256k1_recovery.h\"\n #endif\n \n #ifdef ENABLE_MODULE_EXTRAKEYS\n-# include \"include/secp256k1_extrakeys.h\"\n+# include \"../include/secp256k1_extrakeys.h\"\n #endif\n \n #ifdef ENABLE_MODULE_SCHNORRSIG\n-#include \"include/secp256k1_schnorrsig.h\"\n+#include \"../include/secp256k1_schnorrsig.h\"\n #endif\n \n void run_tests(secp256k1_context *ctx, unsigned char *key);\n@@ -166,7 +166,7 @@ void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n-    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif"
      }
    ]
  }
]