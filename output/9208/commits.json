[
  {
    "sha": "9decd648ac0a1f7f525bca06cd42e0f6525b759a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZGVjZDY0OGFjMGExZjdmNTI1YmNhMDZjZDQyZTBmNjUyNWI3NTlh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-11-07T18:42:09Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-05-04T20:50:50Z"
      },
      "message": "[qa] Relax assumptions on mempool behavior during reorg\n\nPolicy limits (such as chain limits and mempool total size) could reasonably\nbe enforced more aggressively during a reorg, so use resendwallettransactions\nto repopulate the mempool to avoid mined blocks being too small, and increase\nthe chain limits from the default for this test.\n\nThis is in preparation for a change in mempool behavior during a reorg.",
      "tree": {
        "sha": "83350351d2a5a96979b1c49e3f8fd2164ba19942",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83350351d2a5a96979b1c49e3f8fd2164ba19942"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9decd648ac0a1f7f525bca06cd42e0f6525b759a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9decd648ac0a1f7f525bca06cd42e0f6525b759a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9decd648ac0a1f7f525bca06cd42e0f6525b759a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9decd648ac0a1f7f525bca06cd42e0f6525b759a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "35da2aeed7d4000dde93957c3b6e048ab83c4f2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35da2aeed7d4000dde93957c3b6e048ab83c4f2b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/35da2aeed7d4000dde93957c3b6e048ab83c4f2b"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 12,
      "deletions": 3
    },
    "files": [
      {
        "sha": "7995e418c936027192dfc0cef91956f83ad7bdb6",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 12,
        "deletions": 3,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9decd648ac0a1f7f525bca06cd42e0f6525b759a/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9decd648ac0a1f7f525bca06cd42e0f6525b759a/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=9decd648ac0a1f7f525bca06cd42e0f6525b759a",
        "patch": "@@ -34,10 +34,11 @@ def __init__(self):\n \n         # Create nodes 0 and 1 to mine.\n         # Create node 2 to test pruning.\n+        self.full_node_default_args = [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\", \"-limitdescendantcount=100\", \"-limitdescendantsize=5000\", \"-limitancestorcount=100\", \"-limitancestorsize=5000\" ]\n         # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n         # Create nodes 5 to test wallet in prune mode, but do not connect\n-        self.extra_args = [[\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n-                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n+        self.extra_args = [self.full_node_default_args,\n+                           self.full_node_default_args,\n                            [\"-maxreceivebuffer=20000\", \"-prune=550\"],\n                            [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n                            [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n@@ -97,12 +98,15 @@ def create_chain_with_staleblocks(self):\n             # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n             # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n             self.stop_node(0)\n-            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n+            self.nodes[0]=start_node(0, self.options.tmpdir, self.full_node_default_args, timewait=900)\n             # Mine 24 blocks in node 1\n             for i in range(24):\n                 if j == 0:\n                     mine_large_block(self.nodes[1], self.utxo_cache_1)\n                 else:\n+                    # Add node1's wallet transactions back to the mempool, to\n+                    # avoid the mined blocks from being too small.\n+                    self.nodes[1].resendwallettransactions()\n                     self.nodes[1].generate(1) #tx's already in mempool from previous disconnects\n \n             # Reorg back with 25 block chain from node 0\n@@ -159,6 +163,11 @@ def reorg_test(self):\n         self.log.info(\"Usage possibly still high bc of stale blocks in block files: %d\" % calc_usage(self.prunedir))\n \n         self.log.info(\"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\")\n+\n+        # Get node0's wallet transactions back in its mempool, to avoid the\n+        # mined blocks from being too small.\n+        self.nodes[0].resendwallettransactions()\n+\n         for i in range(22):\n             # This can be slow, so do this in multiple RPC calls to avoid\n             # RPC timeouts."
      }
    ]
  },
  {
    "sha": "71f1903353e6452fd4e80e8ae698a49d16a7b61d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MWYxOTAzMzUzZTY0NTJmZDRlODBlOGFlNjk4YTQ5ZDE2YTdiNjFk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-11-03T18:45:10Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-05-04T20:50:52Z"
      },
      "message": "Store disconnected block transactions outside mempool during reorg\n\nRather than re-add disconnected block transactions back to the mempool\nimmediately, store them in a separate disconnectpool for later processing,\nbecause we expect most such transactions to reappear in the chain that is\nstill to be connected (and thus we can avoid the work of reprocessing those\ntransactions through the mempool altogether).",
      "tree": {
        "sha": "ee04e10dccc7d9bfe1a5399ef955f883322e13ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee04e10dccc7d9bfe1a5399ef955f883322e13ed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/71f1903353e6452fd4e80e8ae698a49d16a7b61d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/71f1903353e6452fd4e80e8ae698a49d16a7b61d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/71f1903353e6452fd4e80e8ae698a49d16a7b61d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/71f1903353e6452fd4e80e8ae698a49d16a7b61d/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9decd648ac0a1f7f525bca06cd42e0f6525b759a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9decd648ac0a1f7f525bca06cd42e0f6525b759a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9decd648ac0a1f7f525bca06cd42e0f6525b759a"
      }
    ],
    "stats": {
      "total": 226,
      "additions": 195,
      "deletions": 31
    },
    "files": [
      {
        "sha": "4a83c3f844f218016a0bcc9552bda0f4cd0f6508",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 98,
        "deletions": 1,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/71f1903353e6452fd4e80e8ae698a49d16a7b61d/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/71f1903353e6452fd4e80e8ae698a49d16a7b61d/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=71f1903353e6452fd4e80e8ae698a49d16a7b61d",
        "patch": "@@ -23,6 +23,7 @@\n #include \"boost/multi_index_container.hpp\"\n #include \"boost/multi_index/ordered_index.hpp\"\n #include \"boost/multi_index/hashed_index.hpp\"\n+#include <boost/multi_index/sequenced_index.hpp>\n \n #include <boost/signals2/signal.hpp>\n \n@@ -191,14 +192,19 @@ struct update_lock_points\n     const LockPoints& lp;\n };\n \n-// extracts a TxMemPoolEntry's transaction hash\n+// extracts a transaction hash from CTxMempoolEntry or CTransactionRef\n struct mempoolentry_txid\n {\n     typedef uint256 result_type;\n     result_type operator() (const CTxMemPoolEntry &entry) const\n     {\n         return entry.GetTx().GetHash();\n     }\n+\n+    result_type operator() (const CTransactionRef& tx) const\n+    {\n+        return tx->GetHash();\n+    }\n };\n \n /** \\class CompareTxMemPoolEntryByDescendantScore\n@@ -676,4 +682,95 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n     bool HaveCoins(const uint256 &txid) const;\n };\n \n+/**\n+ * DisconnectedBlockTransactions\n+\n+ * During the reorg, it's desirable to re-add previously confirmed transactions\n+ * to the mempool, so that anything not re-confirmed in the new chain is\n+ * available to be mined. However, it's more efficient to wait until the reorg\n+ * is complete and process all still-unconfirmed transactions at that time,\n+ * since we expect most confirmed transactions to (typically) still be\n+ * confirmed in the new chain, and re-accepting to the memory pool is expensive\n+ * (and therefore better to not do in the middle of reorg-processing).\n+ * Instead, store the disconnected transactions (in order!) as we go, remove any\n+ * that are included in blocks in the new chain, and then process the remaining\n+ * still-unconfirmed transactions at the end.\n+ */\n+\n+// multi_index tag names\n+struct txid_index {};\n+struct insertion_order {};\n+\n+struct DisconnectedBlockTransactions {\n+    typedef boost::multi_index_container<\n+        CTransactionRef,\n+        boost::multi_index::indexed_by<\n+            // sorted by txid\n+            boost::multi_index::hashed_unique<\n+                boost::multi_index::tag<txid_index>,\n+                mempoolentry_txid,\n+                SaltedTxidHasher\n+            >,\n+            // sorted by order in the blockchain\n+            boost::multi_index::sequenced<\n+                boost::multi_index::tag<insertion_order>\n+            >\n+        >\n+    > indexed_disconnected_transactions;\n+\n+    // It's almost certainly a logic bug if we don't clear out queuedTx before\n+    // destruction, as we add to it while disconnecting blocks, and then we\n+    // need to re-process remaining transactions to ensure mempool consistency.\n+    // For now, assert() that we've emptied out this object on destruction.\n+    // This assert() can always be removed if the reorg-processing code were\n+    // to be refactored such that this assumption is no longer true (for\n+    // instance if there was some other way we cleaned up the mempool after a\n+    // reorg, besides draining this object).\n+    ~DisconnectedBlockTransactions() { assert(queuedTx.empty()); }\n+\n+    indexed_disconnected_transactions queuedTx;\n+    uint64_t cachedInnerUsage = 0;\n+\n+    // Estimate the overhead of queuedTx to be 6 pointers + an allocation, as\n+    // no exact formula for boost::multi_index_contained is implemented.\n+    size_t DynamicMemoryUsage() const {\n+        return memusage::MallocUsage(sizeof(CTransactionRef) + 6 * sizeof(void*)) * queuedTx.size() + cachedInnerUsage;\n+    }\n+\n+    void addTransaction(const CTransactionRef& tx)\n+    {\n+        queuedTx.insert(tx);\n+        cachedInnerUsage += RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+    }\n+\n+    // Remove entries based on txid_index, and update memory usage.\n+    void removeForBlock(const std::vector<CTransactionRef>& vtx)\n+    {\n+        // Short-circuit in the common case of a block being added to the tip\n+        if (queuedTx.empty()) {\n+            return;\n+        }\n+        for (auto const &tx : vtx) {\n+            auto it = queuedTx.find(tx->GetHash());\n+            if (it != queuedTx.end()) {\n+                cachedInnerUsage -= RecursiveDynamicUsage(**it) + memusage::DynamicUsage(*it);\n+                queuedTx.erase(it);\n+            }\n+        }\n+    }\n+\n+    // Remove an entry by insertion_order index, and update memory usage.\n+    void removeEntry(indexed_disconnected_transactions::index<insertion_order>::type::iterator entry)\n+    {\n+        cachedInnerUsage -= RecursiveDynamicUsage(**entry) + memusage::DynamicUsage(*entry);\n+        queuedTx.get<insertion_order>().erase(entry);\n+    }\n+\n+    void clear()\n+    {\n+        cachedInnerUsage = 0;\n+        queuedTx.clear();\n+    }\n+};\n+\n #endif // BITCOIN_TXMEMPOOL_H"
      },
      {
        "sha": "88b071825e609d9af2da13b601a4a94a077250dd",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 30,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/71f1903353e6452fd4e80e8ae698a49d16a7b61d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/71f1903353e6452fd4e80e8ae698a49d16a7b61d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=71f1903353e6452fd4e80e8ae698a49d16a7b61d",
        "patch": "@@ -539,6 +539,56 @@ static bool IsCurrentForFeeEstimation()\n     return true;\n }\n \n+/* Make mempool consistent after a reorg, by re-adding or recursively erasing\n+ * disconnected block transactions from the mempool, and also removing any\n+ * other transactions from the mempool that are no longer valid given the new\n+ * tip/height.\n+ *\n+ * Note: we assume that disconnectpool only contains transactions that are NOT\n+ * confirmed in the current chain nor already in the mempool (otherwise,\n+ * in-mempool descendants of such transactions would be removed).\n+ *\n+ * Passing fAddToMempool=false will skip trying to add the transactions back,\n+ * and instead just erase from the mempool as needed.\n+ */\n+\n+void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool fAddToMempool)\n+{\n+    AssertLockHeld(cs_main);\n+    std::vector<uint256> vHashUpdate;\n+    // disconnectpool's insertion_order index sorts the entries from\n+    // oldest to newest, but the oldest entry will be the last tx from the\n+    // latest mined block that was disconnected.\n+    // Iterate disconnectpool in reverse, so that we add transactions\n+    // back to the mempool starting with the earliest transaction that had\n+    // been previously seen in a block.\n+    auto it = disconnectpool.queuedTx.get<insertion_order>().rbegin();\n+    while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n+        // ignore validation errors in resurrected transactions\n+        CValidationState stateDummy;\n+        if (!fAddToMempool || (*it)->IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, *it, false, NULL, NULL, true)) {\n+            // If the transaction doesn't make it in to the mempool, remove any\n+            // transactions that depend on it (which would now be orphans).\n+            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+        } else if (mempool.exists((*it)->GetHash())) {\n+            vHashUpdate.push_back((*it)->GetHash());\n+        }\n+        ++it;\n+    }\n+    disconnectpool.queuedTx.clear();\n+    // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n+    // no in-mempool children, which is generally not true when adding\n+    // previously-confirmed transactions back to the mempool.\n+    // UpdateTransactionsFromBlock finds descendants of any transactions in\n+    // the disconnectpool that were added back and cleans up the mempool state.\n+    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n+\n+    // We also need to remove any now-immature transactions\n+    mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    // Re-limit mempool size, in case we added any transactions\n+    LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+}\n+\n bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<uint256>& vHashTxnToUncache)\n@@ -2119,8 +2169,17 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n \n }\n \n-/** Disconnect chainActive's tip. You probably want to call mempool.removeForReorg and manually re-limit mempool size after this, with cs_main held. */\n-bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, bool fBare = false)\n+/** Disconnect chainActive's tip.\n+  * After calling, the mempool will be in an inconsistent state, with\n+  * transactions from disconnected blocks being added to disconnectpool.  You\n+  * should make the mempool consistent again by calling UpdateMempoolForReorg.\n+  * with cs_main held.\n+  *\n+  * If disconnectpool is NULL, then no disconnected transactions are added to\n+  * disconnectpool (note that the caller is responsible for mempool consistency\n+  * in any case).\n+  */\n+bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n {\n     CBlockIndex *pindexDelete = chainActive.Tip();\n     assert(pindexDelete);\n@@ -2143,25 +2202,17 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n \n-    if (!fBare) {\n-        // Resurrect mempool transactions from the disconnected block.\n-        std::vector<uint256> vHashUpdate;\n-        for (const auto& it : block.vtx) {\n-            const CTransaction& tx = *it;\n-            // ignore validation errors in resurrected transactions\n-            CValidationState stateDummy;\n-            if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, it, false, NULL, NULL, true)) {\n-                mempool.removeRecursive(tx, MemPoolRemovalReason::REORG);\n-            } else if (mempool.exists(tx.GetHash())) {\n-                vHashUpdate.push_back(tx.GetHash());\n-            }\n+    if (disconnectpool) {\n+        // Save transactions to re-add to mempool at end of reorg\n+        for (auto it = block.vtx.rbegin(); it != block.vtx.rend(); ++it) {\n+            disconnectpool->addTransaction(*it);\n+        }\n+        while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {\n+            // Drop the earliest entry, and remove its children from the mempool.\n+            auto it = disconnectpool->queuedTx.get<insertion_order>().begin();\n+            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+            disconnectpool->removeEntry(it);\n         }\n-        // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n-        // no in-mempool children, which is generally not true when adding\n-        // previously-confirmed transactions back to the mempool.\n-        // UpdateTransactionsFromBlock finds descendants of any transactions in this\n-        // block that were added back and cleans up the mempool state.\n-        mempool.UpdateTransactionsFromBlock(vHashUpdate);\n     }\n \n     // Update chainActive and related variables.\n@@ -2249,7 +2300,7 @@ class ConnectTrace {\n  *\n  * The block is added to connectTrace if connection succeeds.\n  */\n-bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace)\n+bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n     assert(pindexNew->pprev == chainActive.Tip());\n     // Read block from disk.\n@@ -2291,6 +2342,7 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n+    disconnectpool.removeForBlock(blockConnecting.vtx);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew, chainparams);\n \n@@ -2384,9 +2436,14 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n     // Disconnect active blocks which are no longer in the best chain.\n     bool fBlocksDisconnected = false;\n+    DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Tip() && chainActive.Tip() != pindexFork) {\n-        if (!DisconnectTip(state, chainparams))\n+        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+            // This is likely a fatal error, but keep the mempool consistent,\n+            // just in case. Only remove from the mempool in this case.\n+            UpdateMempoolForReorg(disconnectpool, false);\n             return false;\n+        }\n         fBlocksDisconnected = true;\n     }\n \n@@ -2409,7 +2466,7 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n         // Connect new blocks.\n         BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n-            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace)) {\n+            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n                     if (!state.CorruptionPossible())\n@@ -2420,6 +2477,9 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n                     break;\n                 } else {\n                     // A system error occurred (disk space, database error, ...).\n+                    // Make the mempool consistent with the current tip, just in case\n+                    // any observers try to use it before shutdown.\n+                    UpdateMempoolForReorg(disconnectpool, false);\n                     return false;\n                 }\n             } else {\n@@ -2434,8 +2494,9 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n     }\n \n     if (fBlocksDisconnected) {\n-        mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n-        LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+        // If any blocks were disconnected, disconnectpool may be non empty.  Add\n+        // any disconnected transactions back to the mempool.\n+        UpdateMempoolForReorg(disconnectpool, true);\n     }\n     mempool.check(pcoinsTip);\n \n@@ -2584,20 +2645,25 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n     setDirtyBlockIndex.insert(pindex);\n     setBlockIndexCandidates.erase(pindex);\n \n+    DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Contains(pindex)) {\n         CBlockIndex *pindexWalk = chainActive.Tip();\n         pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n         setDirtyBlockIndex.insert(pindexWalk);\n         setBlockIndexCandidates.erase(pindexWalk);\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n-        if (!DisconnectTip(state, chainparams)) {\n-            mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+            // It's probably hopeless to try to make the mempool consistent\n+            // here if DisconnectTip failed, but we can try.\n+            UpdateMempoolForReorg(disconnectpool, false);\n             return false;\n         }\n     }\n \n-    LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+    // DisconnectTip will add transactions to disconnectpool; try to add these\n+    // back to the mempool.\n+    UpdateMempoolForReorg(disconnectpool, true);\n \n     // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n     // add it again.\n@@ -2610,7 +2676,6 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n     }\n \n     InvalidChainFound(pindex);\n-    mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);\n     return true;\n }\n@@ -3724,7 +3789,7 @@ bool RewindBlockIndex(const CChainParams& params)\n             // of the blockchain).\n             break;\n         }\n-        if (!DisconnectTip(state, params, true)) {\n+        if (!DisconnectTip(state, params, NULL)) {\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk."
      },
      {
        "sha": "8c91a3806d43f7a2f31f34320aeace6256f09a94",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/71f1903353e6452fd4e80e8ae698a49d16a7b61d/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/71f1903353e6452fd4e80e8ae698a49d16a7b61d/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=71f1903353e6452fd4e80e8ae698a49d16a7b61d",
        "patch": "@@ -69,6 +69,8 @@ static const unsigned int DEFAULT_DESCENDANT_LIMIT = 25;\n static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101;\n /** Default for -mempoolexpiry, expiration time for mempool transactions in hours */\n static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 336;\n+/** Maximum kilobytes for transactions to store for processing during reorg */\n+static const unsigned int MAX_DISCONNECTED_TX_POOL_SIZE = 20000;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */"
      }
    ]
  },
  {
    "sha": "c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMTIzNWUzZjJkZDViMDFiNjNiMDIwZDFiOGY3MjgzZThiYWRhZjA5",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-11-21T16:47:12Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-05-04T20:50:52Z"
      },
      "message": "Add RecursiveDynamicUsage overload for std::shared_ptr\n\nThis simplifies a few usage expressions.",
      "tree": {
        "sha": "e9ea1cd546eb391da083a0dadbabb4ccc82d0842",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e9ea1cd546eb391da083a0dadbabb4ccc82d0842"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "71f1903353e6452fd4e80e8ae698a49d16a7b61d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/71f1903353e6452fd4e80e8ae698a49d16a7b61d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/71f1903353e6452fd4e80e8ae698a49d16a7b61d"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 9,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e4ccd54c4238b899752a7924da0ebc384e44206c",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
        "patch": "@@ -63,4 +63,9 @@ static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) {\n     return memusage::DynamicUsage(locator.vHave);\n }\n \n+template<typename X>\n+static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) {\n+    return p ? memusage::DynamicUsage(p) + RecursiveDynamicUsage(*p) : 0;\n+}\n+\n #endif // BITCOIN_CORE_MEMUSAGE_H"
      },
      {
        "sha": "45980bb60e4f5e17366095e35fe1d3953fad29b7",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
        "patch": "@@ -23,7 +23,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFe\n     spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n     nTxWeight = GetTransactionWeight(*tx);\n-    nUsageSize = RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+    nUsageSize = RecursiveDynamicUsage(tx);\n \n     nCountWithDescendants = 1;\n     nSizeWithDescendants = GetTxSize();"
      },
      {
        "sha": "ff90b4eda580f7298cabb990af6ba06abce2f9f5",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c1235e3f2dd5b01b63b020d1b8f7283e8badaf09/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=c1235e3f2dd5b01b63b020d1b8f7283e8badaf09",
        "patch": "@@ -740,7 +740,7 @@ struct DisconnectedBlockTransactions {\n     void addTransaction(const CTransactionRef& tx)\n     {\n         queuedTx.insert(tx);\n-        cachedInnerUsage += RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+        cachedInnerUsage += RecursiveDynamicUsage(tx);\n     }\n \n     // Remove entries based on txid_index, and update memory usage.\n@@ -753,7 +753,7 @@ struct DisconnectedBlockTransactions {\n         for (auto const &tx : vtx) {\n             auto it = queuedTx.find(tx->GetHash());\n             if (it != queuedTx.end()) {\n-                cachedInnerUsage -= RecursiveDynamicUsage(**it) + memusage::DynamicUsage(*it);\n+                cachedInnerUsage -= RecursiveDynamicUsage(*it);\n                 queuedTx.erase(it);\n             }\n         }\n@@ -762,7 +762,7 @@ struct DisconnectedBlockTransactions {\n     // Remove an entry by insertion_order index, and update memory usage.\n     void removeEntry(indexed_disconnected_transactions::index<insertion_order>::type::iterator entry)\n     {\n-        cachedInnerUsage -= RecursiveDynamicUsage(**entry) + memusage::DynamicUsage(*entry);\n+        cachedInnerUsage -= RecursiveDynamicUsage(*entry);\n         queuedTx.get<insertion_order>().erase(entry);\n     }\n "
      }
    ]
  }
]